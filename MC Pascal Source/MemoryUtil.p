unit MemoryUtil;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}interface	uses		Quickdraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, 		TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface, Script;	procedure UnLockHandle (H: univ Handle; var oldState: SignedByte);	procedure LockHandle (H: univ Handle; var oldState: SignedByte);	procedure ResetHandle (H: univ Handle; oldState: SignedByte);	function GetMaster (H: Handle): longint;	procedure ZapWindow(var theWindow: WindowPtr);	procedure ZapHandle (var H: univ Handle);	procedure ZapPointer (var P: univ Ptr);	procedure ZapRegion (var R: univ RgnHandle);	procedure ZapPixPat(var PPH: univ PixPatHandle);	procedure ZapMenu(MenuID: integer; var MHdl:  MenuHandle);	procedure ZapAndReInsertMenu(MenuID: integer; var MHdl:  MenuHandle);		function myFreeMem: longint;	function EnoughMemory (memoryRequested: longint; var amountneeded: longint): boolean;	function GetWindowRefCon(theWindow: WindowPtr): longint;	procedure ReplaceEndOfHandle(H: Handle; location: longint; fillPtr: Ptr; fillSize: longint);	procedure ReplaceHandleContentsWithString(H: Handle; ds: str255);	procedure InsertPieceIntoHandle(H: Handle; location: longint; fillPtr: Ptr; fillSize: longint);	procedure DeletePieceOfHandle(H: Handle; location: longint; deleteSize: longint);	procedure InsertEmptyPieceIntoHandle(H: Handle; location: longint;fillSize: longint);{еееееееееееееееееееееее}implementation {е$S MemoryUtil}{The following 3 procedures allow you to lock and unlock handles, and the oldstate of the handle will be passed back}{in oldState.  when you then call ResetHandle, the handle will be restored to its former state}{In general, you should use these procedures instead of HLock and HUnlock, unless the handle is local}{to a procedure and you thus know that it begins the procedure unlocked, and is disposed of before the}{end of the procedure.}{In general, the rules are: }{1. handles are always unlocked in the main event loop}{2. if you are far up, nested away from the main event loop, you can not necessarily count on a handle}{being unlocked or locked when it is passed into a procedure.  Therefore, before all SetHandleSize calls,}{Munger calls, PtrtoHand, HandAndHand, etc., calls, you should call UnlockHandle(H,oldState), and before}{accessing the handle's contents when it might move call LockHandle(H,oldstate), and call ResetHandle(H,oldstate)}{before exiting the procedure.  Note that there are collections of calls to things like SetHandleSize in procedures}{in RowColumn and GenOpenFile and GenCloseFile that are close enough to the main event loop so that all the}{handles can safely presumed to be unlocked}{if you have two or more separate Handles to set and reset in one procedure, be sure you nest the oldstate }{variables correctly.  eg.}{LockHandle(H1,oldstate1);}{LockHandle(H2,oldstate2);}{...other code...}{ResetHandle(H2,oldstate2);}{ResetHandle(H1,oldstate1);}{in System 6 Handles, bit 0 is lock/unlock, bit 1 is purge/nopurge}{---------------------------------------------------------------------}	procedure UnLockHandle (H: univ Handle; var oldState: SignedByte);	begin		oldState := HGetState(H);		HUnLock(H);	end;{---------------------------------------------------------------------}	procedure LockHandle (H: univ Handle; var oldState: SignedByte);	begin		oldState := HGetState(H);		HLock(H);	end;{$IFC DEBUG}{---------------------------------------------------------------------}	procedure ResetHandle (H: univ Handle; oldState: SignedByte);		var			theBit: integer;			badbits: boolean;	begin		badbits := false;		for theBit := 1 to 7 do			if BitTst(@oldState, theBit) then				begin					badbits := true;					leave;				end;		if badbits then			instantInfo(concat('Bad Handle Bits  ', StringFromNum(oldState), '  ', StringFromNum(theBit)));		HSetState(H, oldState);	end;{$ELSEC}{---------------------------------------------------------------------}	procedure ResetHandle (H: univ Handle; oldState: SignedByte);	begin		HSetState(H, oldState);	end;{$ENDC }{----------------------------------------------------------------------------}	function GetMaster (H: Handle): longint;	begin{$IFC CARBON}		GetMaster := Longint(H^);{$ELSEC}		if hasStripAddress then			GetMaster := Longint(StripAddress(Pointer(H^)))		else			GetMaster := ord4(H^) mod 16777216;{$ENDC}	end;{---------------------------------------------------------------------}	procedure ReportFFFFdispose (dL: longint);	begin		if (dL = ($FFFFFFFF)) then			begin{$IFC WRITETEMPFILE}	writeln(tempFile,'FFFFFFFFF dispose');{$ENDC}			dL := 0;			end;	end;{-----------------------------------------------------------------------------}	procedure ZapWindow(var theWindow: WindowPtr);	var wP: windowInfoP;	begin		if (theWindow<> nil) then			begin				wP := WindowInfoP(GetWindowRefCon(theWindow));				ZapPointer(wP);				DisposeWindow(theWindow);				theWindow := nil;			end;	end;{---------------------------------------------------------------------}	procedure ZapHandle (var H: univ Handle);{this is to be used in place of the toolbox call DisposHandle}	begin		if H <> nil then			DisposeHandle(H);		H := nil;	end;{---------------------------------------------------------------------}	procedure ZapPointer (var P: univ Ptr);{this is to be used in place of the toolbox call DisposPtr}	begin		if P <> nil then			DisposePtr(P);		P := nil;	end;{---------------------------------------------------------------------}	procedure ZapRegion (var R: univ RgnHandle);{this is to be used in place of the toolbox call DisposeRgn}	begin		if R <> nil then			DisposeRgn(R);		R := nil;	end;{----------------------------------------------------------------------------}	procedure ZapPixPat(var PPH: univ PixPatHandle);	begin		if PPH <> nil then			begin				DisposePixPat(PPH);				PPH := nil;			end;	end;{----------------------------------------------------------------------------}	procedure ZapMenu(MenuID: integer; var MHdl:  MenuHandle);	begin		if MHdl <> nil then			begin				DeleteMenu(MenuID);				ReleaseResource(Handle(MHdl));				{MHdl := nil;}			end;	end;{----------------------------------------------------------------------------}	procedure ZapAndReInsertMenu(MenuID: integer; var MHdl:  MenuHandle);	begin		ZapMenu(MenuID,MHdl);		MHdl := GetMenu(MenuID);		InsertMenu(MHdl, -1);	end;{-----------------------------------------------------------------------------}{	procedure ZeroBlockWords (p: univ ptr; numWords: longint);	EXTERNAL;}{-----------------------------------------------------------------------------}{	procedure ZeroBlockLongwords (p: univ ptr; numlongs: longint);	EXTERNAL;}{----------------------------------------------------------------------------}	function myFreeMem: longint;	begin		if (isMacOSX) then			begin				myFreeMem := maxLongint;			end		else			begin				myFreeMem := freeMem;			end;	end;{----------------------------------------------------------------------------}	function EnoughMemory (memoryRequested: longint; var amountneeded: longint): boolean;	var H: Handle;	begin		if (isMacOSX) then			begin				amountneeded := memoryRequested + memorySlack ;				H := NewHandle(amountNeeded);				EnoughMemory := (H<>nil) & (MemError=NoErr);				ZapHandle(H);				amountNeeded := 102400; 			end		else			begin				amountneeded := memoryRequested + memorySlack - myFreeMem;				if amountneeded < 0 then					amountneeded := 0;				EnoughMemory := amountneeded = 0;				if (amountNeeded > 0) & (amountNeeded < 10240) then  {do this just so that it reports that at least 10K more is needed}					amountNeeded := 10240; 			end;	end;{----------------------------------------------------------------------------}	function GetWindowRefCon(theWindow: WindowPtr): longint;	begin{$IFC NOT CARBON}		GetWindowRefCon := WindowPeek(theWindow)^.refcon;{$ELSEC}		GetWindowRefCon := GetWRefCon(theWindow);{$ENDC}	end;{Munger Notes}{deletes len1 bytes at positions offset:}{    dL := M unger(H, offset, nil, len1, Ptr(2), 0);     }{replaces all rest of handle with string 2:}{    dL := M unger(H, offset, nil, -1, ptr2, len2);     }{doesn't search for string, just inserts string2 at offset}{    dL := M unger(H, offset, nil, 0, ptr2, len2);     }{finds first occurrence (after offset) of string 1, and replaces by string 2:}{    dL := M unger(H, offset, ptr1, len1, ptr2, len2);     }{doesn't search for string 1, just replaces len1 bytes, beginning at offset, by string 2}{    dL := M unger(H, offset, nil, len1, ptr2, len2);     }{finds first occurrence (after offset) of string 1, and reports back in dL:}{    dL := M unger(H, offset, ptr1, len1, nil, 0);     }{finds first occurrence (after offset) of string 1, and deletes:}{    dL := M unger(H, offset, ptr1, len1, Ptr(2), 0);     }{----------------------------------------------------------------------------}	procedure ReplaceEndOfHandle(H: Handle; location: longint; fillPtr: Ptr; fillSize: longint);	var dL: longint;	begin{$IFC NOT CARBON}		dL := Munger(H, location, nil, -1, fillPtr, fillSize);{$ELSEC}		dL := Munger(H, location, nil, -1, fillPtr, fillSize);{$ENDC}	end;{----------------------------------------------------------------------------}	procedure ReplaceHandleContentsWithString(H: Handle; ds: str255);	var dL: longint;	begin{$IFC NOT CARBON}		dL := Munger(H, 0, nil, -1, Pointer(ord4(@ds) + 1), length(ds));{$ELSEC}		dL := Munger(H, 0, nil, -1, Pointer(ord4(@ds) + 1), length(ds));		// use os := PtrToXHand(Pointer(ord4(@ds) + 1), H, length(ds)){$ENDC}	end;{----------------------------------------------------------------------------}	procedure InsertPieceIntoHandle(H: Handle; location: longint; fillPtr: Ptr; fillSize: longint);	var dL: longint;		oldState: SignedByte;		oldHandleSize: longint;	begin{$IFC NOT CARBON}		dL := Munger(H, location, nil, 0, fillPtr, fillSize);{$ELSEC}		oldHandleSize:= GetHandleSize(H);		UnlockHandle(H, oldstate);		SetHandleSize(H, oldHandleSize+fillSize);		HLock(H);		BlockMove(Ptr(GetMaster(H) + location), Ptr(GetMaster(H) + location+fillSize),oldHandleSize-location);		BlockMove(fillPtr, Ptr(GetMaster(H) + location),fillSize);		ResetHandle(H, oldstate);{$ENDC}	end;{----------------------------------------------------------------------------}	procedure InsertEmptyPieceIntoHandle(H: Handle; location: longint;fillSize: longint);	var dL: longint;		oldState: SignedByte;		oldHandleSize: longint;	begin{$IFC NOT CARBON}		dL := Munger(H, location, nil, 0, @quit, fillSize);{$ELSEC}		oldHandleSize:= GetHandleSize(H);		UnlockHandle(H, oldstate);		SetHandleSize(H, oldHandleSize+fillSize);		HLock(H);		BlockMove(Ptr(GetMaster(H) + location), Ptr(GetMaster(H) + location+fillSize),oldHandleSize-location);		ResetHandle(H, oldstate);{$ENDC}	end;{----------------------------------------------------------------------------}	procedure DeletePieceOfHandle(H: Handle; location: longint; deleteSize: longint);	var dL: longint;		dummy: boolean;	begin{$IFC NOT CARBON}		dL := Munger(H, location, nil, deleteSize, Ptr(2), 0);{$ELSEC}		dL := Munger(H, location, nil, deleteSize, Ptr(2), 0);{$ENDC}	end;{----------------------------------------------------------------------------}end.