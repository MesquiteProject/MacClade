unit ChangeAssumptions;{еееееееееееееееееееееее}interface	uses		QuickDraw, 		Types, Events, Controls, Menus, Files, QuickDrawText, OSUtils, TextUtils, 		Windows, Sound, Dialogs, TextEdit,Lists,ToolUtils,Memory, Fonts,Resources,Scrap , 		Globals, MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, CharUtil, 		MenuUtil, TreeUtil, LinkUtil,  		InfoWindows, SymbolsNames,  MCWindows, TypeDLOG, Selection;	procedure PostIncExcCharactersChange;	function ChangeIncExc (ic, toDo: integer; polysorfixanc: boolean): boolean;	procedure WtConvertDiscCont;	procedure DoIncExcCharactersMenu (itemNo: integer);	procedure DoCodingMenu (itemNo: integer);	procedure ChangeWt (towt: integer);	function SetWtDialog (var  towt: integer): boolean;	procedure DoWeightMenu (itemNo: integer);	procedure DoTypeMenu (ItemNo: integer);	procedure SetSelectedToNewPart(editorFront: boolean);	procedure DoCharPartMenu (itemNo: integer);{еееееееееееееееееееееее}implementation {е$S ChangeAssumptions}{-----------------------------------------------------------------------------}	function ChangeIncExc (ic, toDo: integer; polysorfixanc: boolean): boolean;{returns true if successfully changed}		var			height: integer;			box: rect;			tport: WindowPtr;			failed: boolean;	begin		if (CharIncluded(ic) and (toDo = ExcludeItem)) or (not CharIncluded(ic) and (toDo = IncludeItem)) or (toDo = SwitchItem) then			begin				SwitchIncExc(ic);				failed := not TypeLegalForchar(TypeOfChar(ic), ic);				if failed then					begin						NewError(41, 0);						SwitchIncExc(ic);					end;				if not failed then					begin						dirtyfile := true;						if treeopen then							begin								InvalidateWindow(tlegwindow, false);								InvalidateWindow(twmesswindow, false);{FROZEN 3.0}								ChangeExclusionsGolist;{change include exclude; redo all calculations except those concerning i (if excluded will be handled later) and continuous}								if (traceshown = traceAllStates) or (traceshown = traceAllChanges) then									InvalidateWindow(treewindow, false);							end;					end;				ChangeIncExc := not failed;			end		else			ChangeIncExc := false;	end;{-----------------------------------------------------------------------------}	procedure CharToChange (var foundnum, onefound: integer);	begin		if IsTreeWindow(frontwindow) then			begin				foundnum := 1;				onefound := i;			end		else if IsEditorWindow(frontwindow) then			begin				foundnum := CharOfCell(editorSelectionBotRight) - CharOfCell(editorSelectionTopLeft)+1;  {4.01: +1 added}				onefound := CharOfCell(editorSelectionTopLeft);			end		else			CheckCharInfoSelected(foundnum, onefound);	end;{-----------------------------------------------------------------------------}	procedure ChangeWt (towt: integer);		var			ic, onefound: integer;			tport: windowptr;			foundnum: integer;			changedone: boolean;{.........}		procedure ChangeCharWeight (ic, towt: integer);		begin			SetWeight(ic, towt);			UsetoWtStorage(ic);			changedone := true;		end;{.........}	begin{weightschanged := true;}		genericGetPort(tport);		Setcursor(clockCursor);		CharToChange(foundnum, onefound);		changedone := false;		if (foundnum > 1) then			begin				if infoOpen[charinfo] then					InvalidateInfoColumn(charinfo, charinfoweights, 1, numchars);				if frontwindow = infoWindow[charinfo] then					begin						for ic := 1 to numchars do							if InfoRowSelected(charinfo, ic) then								ChangeCharWeight(ic, towt);					end				else if IsEditorWindow(frontwindow) then					for ic := CharOfCell(editorSelectionTopLeft) to CharOfCell(editorSelectionBotRight) do						ChangeCharWeight(ic, towt);				if not changedone then					begin						InstantError(217);						Exit(ChangeWt);					end;			end		else if foundnum = 1 then			begin				InvalidateWindowRect(infoWindow[charinfo],InfoRowBox(charinfo, InfoHeight(charinfo, onefound)),true);				ChangeCharWeight(onefound, towt);			end;		if changedone and treeopen then			WtChangeGoList;		dirtyfile := true;		dirtylink[wtsetchain] := true;		CheckWt1;		myEnableItem(xxWeightSetsMHdl, StoreWeightSetItem);		InvalidateInfoWindow(charinfo);		InvalidateInfoWindow(wtsetinfo);		if treeopen then			InvalidateWindow(tlegwindow, false);		SetCursorToArrow;		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	procedure WtConvertDiscCont;		var			ic: integer;			append, truncate: boolean;{..................}		procedure ConvertWtsDC (toReal: boolean);			var				cwtP: IP;				cwt: longint;				ic: integer;				oldState1: SignedByte;		begin			realwt := toreal;			LockHandle(chwtH, oldState1);			cwtP := IP(GetMaster(chwtH));			for ic := 1 to numchars do				begin					if toreal and Append then						cwtP^ := cwtP^ * WtInflate {bumping up old weights by 100; note never need to decrease since can't go back}					else if truncate & not toreal then						cwtP^ := cwtP^ div WtInflate;					UsetoWtStorage(ic);					cwtP := IP(ord4(cwtP) + chwb);				end;			ResetHandle(chwtH, oldState1);			InvalidateWindow(infoWindow[charinfo], false);			CheckInflate;			if treeopen then				begin					WtChangeGoList;					InvalidateWindow(tlegwindow, false);				end;		end;{..................}	begin		if not realwt then  {inflate all wt by 100 since newly decimal}			begin				append := CWARNING(' Do you want to simply append a decimal point to each weight, or divide by 100 first?', 'Append', 'Divide');				if append then					for ic := 1 to numchars do {First Check if OK to make continuous}						if wtInflate * CharWeight(ic) > maxwtreal then							begin								InstantError(220);								Exit(WtConvertDiscCont);							end;				ConvertWtsDC(true);			end		else   {deflate all dists by 100 since no longer decimal}			begin				truncate := CWARNING(' Do you want to truncate each weight to next smallest integer, or multiply by 100 first?', 'Truncate', 'Multiply');				ConvertWtsDC(false);			end;	end;	{-----------------------------------------------------------------------------}	procedure DoTypeMenu (ItemNo: integer);		var			db: boolean;	begin		if ((IsEditorWindow(frontwindow)) and WholeCharSel) or ((frontwindow = infoWindow[charinfo]) and infoSomeSelected[charinfo]) or (IsTreeWindow(frontwindow) and (traceshown = traceDiscrete)) then			begin				if (ItemNo >= 1) and (ItemNo <= numtypes) then					begin						if (ItemNo >= 32) and (treeopen and (nullson or ancon)) then{remember, menu items beyond 31 ALWAYS enabled!!!}							InstantError(218)						else							begin								if dirtymaxst then									ReCalcMaxstAndStates(1,numchars);								db := ChangeType(ItemNo, frontwindow);							end;					end;			end		else if ItemNo > 0 then			InstantError(219);	end;{-----------------------------------------------------------------------------}	function SingleSelectedBlock (var icstart, icend: integer): boolean;		var			ic: integer;			charHdl: chHdl;			taxonhdl: tHdl;	begin		SingleSelectedBlock := true;		if frontwindow = infoWindow[charinfo] then			begin				icstart := -1;				icend := -1;				for ic := 1 to numchars do					begin						charHdl := getchHdl(ic);						if (icstart = -1) & CharHdl^^.infoSelected then							icstart := ic						else if (icstart > -1) & (icend > -1) & CharHdl^^.infoSelected then  {a new block!}							begin								SingleSelectedBlock := false;								leave;							end						else if (icstart > -1) & (icend = -1) & not CharHdl^^.infoSelected then							icend := ic - 1;					end;				if icend = -1 then					icend := numchars;			end		else if IsEditorWindow(frontwindow) then			begin				icstart := CharOfCell(editorSelectionTopLeft);				icend := CharOfCell(editorSelectionBotRight);			end;	end;{-----------------------------------------------------------------------------}	function TotalStopCodons: longint;	var it, total: longint;	begin		total := 0;		for it := 1 to numtaxa do 			total := total + NumStopCodonsInTaxon (it, true);		TotalStopCodons := total;	end;{-----------------------------------------------------------------------------}	procedure CalcCodPositions;		var			theDialog: DialogPtr;			tempP: WindowPtr;			firstcodpos: integer;			forcecoding: boolean;			icend, icstart: integer;			singleblock: boolean;			ic: integer;			charHdl: chHdl;			restartAt1: boolean;			prevCodPos, localItemHit: integer;			totalStops ,minTotalStops: longint;			minStopsStart : integer;{.........}		procedure CheckCodPos;		begin			ItemCheckMark(theDialog, 3, firstcodpos = 1);			ItemCheckMark(theDialog, 4, firstcodpos = 2);			ItemCheckMark(theDialog, 5, firstcodpos = 3);			ItemCheckMark(theDialog, 11, firstcodpos = 4);			ItemCheckMark(theDialog, 8, forcecoding);			ItemCheckMark(theDialog, 9, reStartAt1);		end;{.........}	begin		if not SingleSelectedBlock(icstart, icend) then			begin				Instanterror(289);				Exit(CalcCodPositions);			end;				forcecoding := true;		reStartAt1 := false;		if (icstart > 1) & CodPosSet(icstart - 1) then			begin				prevCodPos := CharCodPos(icstart - 1);				if prevCodPos = 3 then					firstcodpos := 1				else					firstcodPos := prevCodPos + 1;			end		else			firstcodPos := 1;		StartDLOG(580, theDialog, tempP);		CheckCodPos;		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			if localItemHit in [3, 4, 5] then				firstCodPos := localItemHit - 2			else if localItemHit = 8 then				forcecoding := not forcecoding			else if localItemHit in [9, 10] then				restartAt1 := not restartAt1			else if localitemHit = 11 then				firstCodPos := 4;			CheckCodPos;		until localItemHit in [1, 2];		EndDLOG(theDialog, tempP);		if localItemHit = 1 then			begin				{SetEWClip(noscroll);}				if firstCodPos=4 then					begin						SetCodonPositions(icstart, icend, 1, forcecoding, restartAt1);						CheckForCodPos(true);						totalStops := TotalStopCodons;						minTotalStops := totalStops;						minStopsStart := 1;						SetCodonPositions(icstart, icend, 2, forcecoding, restartAt1);						totalStops := TotalStopCodons;						if minTotalStops > totalStops then							begin								minStopsStart := 2;								minTotalStops := totalStops;							end;						SetCodonPositions(icstart, icend, 3, forcecoding, restartAt1);						totalStops := TotalStopCodons;						if minTotalStops > totalStops then							begin								minStopsStart := 3;								minTotalStops := totalStops;							end;						if minStopsStart <> 3 then							SetCodonPositions(icstart, icend, minStopsStart, forcecoding, restartAt1);					end				else 					SetCodonPositions(icstart, icend, firstcodPos, forcecoding, restartAt1);				dirtyfile := true;			end;	end;{-----------------------------------------------------------------------------}	procedure DoCodingMenu (itemNo: integer);		var			charHdl: chHdl;			ic: integer;			didchange: boolean;{...........}		procedure ChangeCoding (ic: integer);		begin			if itemNo in [Pos1Item, Pos2Item, Pos3Item] then				begin					charHdl^^.coding := true;					charHdl^^.codpos := itemNo - Pos1Item + 1;				end			else if itemNo = codeNotSetItem then				begin					charHdl^^.coding := true;					charHdl^^.codpos := codeNotSet;				end			else if itemNo = NotCodingItem then				begin					charHdl^^.coding := false;					charHdl^^.codpos := nonCoding;				end;			datachanged := true;			didchange := true;		end;{...........}	begin		didchange := false;		if ((IsEditorWindow(frontwindow)) & WholeCharSel) | ((frontwindow = infoWindow[charinfo]) & infoSomeSelected[charinfo]) then			begin				if itemNo >= 1 then					if itemNo = CalcCodPosItem then						CalcCodPositions					else if frontwindow = infoWindow[charinfo] then						for ic := 1 to numchars do							begin								charHdl := getchHdl(ic);								if charHdl^^.infoSelected then									ChangeCoding(ic);							end					else if IsTreeWindow(frontwindow) then						begin							charHdl := getchHdl(i);							ChangeCoding(i);						end					else						for ic := CharOfCell(editorSelectionTopLeft) to CharOfCell(editorSelectionBotRight) do							begin								charHdl := getchHdl(ic);								ChangeCoding(ic);							end;			end		else if itemNo > 0 then			InstantError(219);		if didchange then			PostCodPosChanged;	end;{-----------------------------------------------------------------------------}	procedure ChangePartition (toPartition: integer);		var			ic, onefound: integer;			tport: windowptr;			foundnum: integer;			changedone: boolean;{.........}		procedure ChangeCharPart (ic, toPartition: integer);		begin			SetPartition(ic, toPartition);			UsetoPartStorage(ic);			changedone := true;		end;{.........}	begin{weightschanged := true;}		genericGetPort(tport);		Setcursor(clockCursor);		CharToChange(foundnum, onefound);		changedone := false;		if foundnum >= 1 then			begin				if (foundnum > 1) then					begin						if infoOpen[charinfo] then							InvalidateInfoColumn(charinfo, CharInfoPartition, 1, numchars);						if frontwindow = infoWindow[charinfo] then							begin								for ic := 1 to numchars do									if InfoRowSelected(charinfo, ic) then										ChangeCharPart(ic, toPartition);							end						else if IsEditorWindow(frontwindow) then							for ic := CharOfCell(editorSelectionTopLeft) to CharOfCell(editorSelectionBotRight) do								ChangeCharPart(ic, toPartition);						if not changedone then							begin								InstantError(451);								Exit(ChangePartition);							end;					end				else if foundnum=1 then					begin						InvalidateWindowRect(infoWindow[charinfo],InfoRowBox(charinfo, InfoHeight(charinfo, onefound)), true);						ChangeCharPart(onefound, toPartition);					end;				dirtyfile := true;				dirtylink[CharPartitionchain] := true;				CheckAllOnePartition;				//myEnableItem(xxWeightSetsMHdl, StoreWeightSetItem);				InvalidateInfoWindow(charinfo);				InvalidateInfoWindow(charPartinfo);				charPartitionsChanged := true;			end;		SetCursorToArrow;		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	procedure SetSelectedToNewPart(editorFront: boolean);	begin		MakeNewObject(charpartnameinfo,'',true, false,true);		if editorFront then			SelectEditorWindows		else			OpenOrSelectInfoWindow(charinfo);		ChangePartition(numCharPartNames);		OpenOrSelectInfoWindow(charpartnameinfo);	end;{-----------------------------------------------------------------------------}	procedure DoCharPartMenu (itemNo: integer);	begin		if ItemNo > 0 then			if ItemNo = myCountMenuItems(CharPartMHdl) then				SetSelectedToNewPart(IsEditorWindow(frontWindow))			else if ItemNo < myCountMenuItems(CharPartMHdl) - 1 then				ChangePartition(itemNo);	end;{-----------------------------------------------------------------------------}	procedure DoWeightMenu (itemNo: integer);		var			 towt: integer;	begin		if itemNo > 0 then			if (itemNo <> ContWtsItem) & not (((IsEditorWindow(frontwindow)) & WholeCharSel) | ((frontwindow = infoWindow[charinfo]) & infoSomeSelected[charinfo]) ) then				InstantError(221)			else				case itemNo of					ChgWtItem: 						if SetWtDialog(towt) then							ChangeWt(towt);					ContWtsItem: 						begin							if realwt then								begin									if Cwarning('Do you want to convert the weights of ALL CHARACTERS to integers (discrete values)?', 'Yes', 'Cancel') then										WtConvertDiscCont;								end							else								begin									if Cwarning('Do you want to use continuous value (decimal) weights?', 'Yes', 'Cancel') then										WtConvertDiscCont;								end;							myCheckMenuItem(WeightMHdl, ContWtsItem, realwt);						end;					otherwise						if (itemNo >= ZeroWtItem) then							if realwt then								ChangeWt((itemNo - ZeroWtItem) * WtInflate)							else								ChangeWt(itemNo - ZeroWtItem);				end;	end;{-----------------------------------------------------------------------------}	procedure PostIncExcCharactersChange;	begin		dirtylink[exsetchain] := true;		CalcNumCharIncluded;		CheckCurrentTypes;		if nucleotides then			CheckForCodPos(false);		InvalidateInfoWindow(charinfo);		InvalidateInfoWindow(exsetinfo);		if infoOpen[taxinfo] & not taxInfoConsiderAllCharacters then			InvalidateWindow(infoWindow[taxinfo],false);		if editorOpen & ((editorCharacterSetToShade=AllIncludedShadeCharSet)|(editorCharacterSetToShade=AllExcludedShadeCharSet)) then			InvalidateWindow(editorWindow,false);				end;{-----------------------------------------------------------------------------}	procedure DoIncExcCharactersMenu (itemNo: integer);		var			charHdl: chHdl;			tport: windowPtr;			ic, numexcluded: integer;			polyoranc, didchange: boolean;			doCharacters, warnNotSelected: boolean;	begin		doCharacters :=  (IsTreeWindow(frontwindow) & (traceshown = traceDiscrete)) | ((IsEditorWindow(frontwindow)) & WholeCharSel) | ((frontwindow = infoWindow[charinfo]) & infoSomeSelected[charinfo]);		doCharacters := doCharacters | (ItemNo=ExcUninform);		warnNotSelected := not doCharacters;		if warnNotSelected then			begin				if ItemNo > 0 then					InstantError(219);			end		else if ItemNo in [1..4] then			begin				polyoranc := nullson or ancon;				didchange := false;				if IsEditorWindow(frontwindow) then					begin						for ic := CharOfCell(editorSelectionTopLeft) to CharOfCell(editorSelectionBotRight) do							if ChangeIncExc(ic, ItemNo, polyoranc) then								didchange := true;					end				else if IsTreeWindow(frontwindow) & (traceshown = traceDiscrete) & not (ItemNo = ExcUninform) then					begin						if ChangeIncExc(i, ItemNo, polyoranc) then							didchange := true;					end				else					begin  {Exclude uninformative}						numexcluded := 0;						for ic := 1 to numchars do							begin								charHdl := getchHdl(ic);								if ItemNo = ExcUninform then									begin										if typeofChar(ic) < irreversible then											begin												if charHdl^^.minlen = charHdl^^.maxlen then													if ChangeIncExc(ic, ExcludeItem, polyoranc) then														begin															didchange := true;															numexcluded := numexcluded + 1;														end;											end										else if charincluded(ic) then											NewError(91, 0);									end								else if CharHdl^^.infoSelected then									if ChangeIncExc(ic, ItemNo, polyoranc) then										didchange := true;							end;						if ItemNo = ExcUninform then							InstantErrorPlus(386, StringFromNum(numexcluded));					end;				if didchange then					PostIncExcCharactersChange;			end;	end;{-----------------------------------------------------------------------------}{-----------------------------------------------------------------------------}	function SetWtDialog (var  towt: integer): boolean;		label			1;		var			TD: DialogPtr;			ic, onefound, foundnum: integer;			tempP: WindowPtr;			ds: str255;			changed, fromonly: boolean;			tempwt: longint;			tempwtreal: double;			localItemHit: integer;{.........}		function StringToWeight (ds: str255; var theWt: integer): boolean;		begin			StringToWeight := false;			if pos('.', ds) > 0 then				begin					if realwt then						begin							tempwtreal := TokenToReal(ds);							if tempwtreal < 0.0 then								InstantError(164)							else if (tempwtreal <= (1.0 * MaxWtReal / (WtInflate * 1.0) + 0.002)) then								begin									StringToWeight := true;									theWt := RoundValue(WtInflate * tempwtreal);								end							else								InstantErrorPlus(165, RealToIntegerstring(MaxWtReal, WtInflate));						end					else						InstantError(222);				end			else				begin					stringtonum(ds, tempwt);					if tempwt < 0 then						InstantError(164)					else if ((realwt and (tempwt <= RoundValue(1.0 * MaxWtReal / (WtInflate * 1.0)))) or (not realwt and (tempwt <= MaxWtInt))) then						begin							StringToWeight := true;							if realwt then								theWt := WtInflate * tempwt							else								theWt := tempwt;						end					else if realwt then						InstantErrorPlus(165, RealToIntegerstring(MaxWtReal, WtInflate))					else						InstantErrorPlus(166, stringfromNum(MaxWtInt));				end;		end;{..........}	begin		fromonly := false;		if IsEditorWindow(frontwindow) | (frontwindow = infoWindow[charinfo]) then			ParamText('selected character(s)', '', '', '')		else if IsTreeWindow(frontwindow) then			ParamText('traced character', '', '', '');		StartDLOG(594, TD, tempP);		CharToChange(foundnum, onefound);		if foundnum > 1 then			if realwt then				ds := '1.0'			else				ds := '1'		else if realwt then			ds := RealToIntegerstring(CharWeight(onefound), WtInflate)		else			ds := StringFromNum(CharWeight(onefound));		SetDLOGText(TD, 3, ds, true);		myShowDialog(TD);		changed := false;		FrameButton(TD, 1);1:		repeat			ModalDialog(nil, localItemHit);		until localItemHit in [1, 2];		if localItemHit = 1 then			begin				ds := GetEditText(TD, 3);				changed := StringToWeight(ds, toWt);				if not changed then					goto 1;			end;		SetWtDialog := changed;		EndDLOG(TD, tempP);		CheckInflate;	end;end.