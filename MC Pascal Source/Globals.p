unit GLOBALS;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright David R. Maddison & Wayne P. Maddison 2005}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of David or Wayne Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}interface{$SETC RELEASEVERSION=TRUE}	{if RELEASEVERSION is true, }	{ will say Release Version in About}	{- CHANGE TO ONLY for FINAL version}{$SETC BETA=FALSE}{$SETC EXPIRABLE=FALSE}{$SETC RESEARCH=TRUE}{$SETC DEMO=FALSE}{$SETC WRITETEMPFILE=FALSE}{$SETC ARIZONAVERSION=FALSE}{$SETC UBCVERSION=FALSE}{--------------------}	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap, Printing;{--------------------}	const	{$IFC RELEASEVERSION}		VERSION = '4.08a';{$ELSEC}		VERSION = '4.09beta';			{change this string to change the version number displayed throughout the program}{$ENDC}		testVersion = '4.09b05';		testDate = '1 May 2011';		MacCladeBlockVersionString = '4.0';		MacCladeBlockSubVersionString = '88';		MacCladeBlockSubVersionNumber = 88;  {this should be an integral version of the previous}					{see bottom of BugList.p for history of subversion numbers and release dates}		subVersionForPrintRecord = 72;		betaFile = 'PAINT TEMP GDFE';   {ready for 4.09b03}		expiryMonth =12;		expiryYear = 2013;{$SETC EDUCATIONAL=NOT RESEARCH}      {if RESEARCH is true, then a full research version of MacClade will be produced. Otherwise, }	{the educational version will be}{$SETC LOCKCONTROL= NOT EDUCATIONAL}	{if this is true, then have access to toggle editing restrictions of file}{еееееееееееееееее}{$SETC SHIFTMINSTOPS=RESEARCH}{$SETC MATCHPROTEINALIGN=RESEARCH}{$SETC FLASHRNACOMP=RESEARCH}	{if this is turned off, then the menus need to be changed, as documented at the bottom of BugList.p}{еееееееееееееееее}	{set DEMO to true only for copies of MacClade that are intended for demo purposes.  Such}	{copies cannot save files (text, graphics, or otherwise), nor can they print anything, and they are}	{limited to 12 taxa and 50 characters}{$SETC DEBUGFILE=FALSE}{$SETC DEBUG = FALSE}	{if DEBUG is true, then various debugging tools in MacClade will be enabled}{$SETC DEVELOPMENT = FALSE}	{if DEVELOPMENT is true, then various facilities still in development within MacClade will be enabled}{$SETC CARBON=TARGET_API_MAC_CARBON}{$SETC SPEECH = TRUE}{$SETC SIDETREE=FALSE}{$SETC TRACKPAGENUMBERS=true}{$SETC REALLENGTHS=FALSE}{$SETC ALWAYSENABLED = FALSE}{$SETC MINMAXIN=TRUE}{$SETC FOOTSOUNDS = FALSE}{$SETC SHADOWTREE = FALSE}{$SETC COLORCELLS=TRUE}{$SETC READGENBANK=TRUE}{$SETC CUMUL=FALSE}{$SETC SQUAREBRANCHES=TRUE}	{if change SQUAREBRANCHES, then you must also change TWDisplay menu}{$SETC FILLWITHOBS=TRUE}{$SETC SETBRANCHLENGTHS = TRUE}{$SETC SepLengthChange=FALSE}{$SETC SHOWBRANCHLENGTHS=TRUE}{$SETC COLORTICKS=TRUE}   {ееее NOTE: if this is changed, need to change settings subversion number, above, and value for traceAllChangesDisplayID еееее}{$SETC SCALEWINDOW=FALSE}{$SETC MLE=FALSE}{$SETC REQAPPLEEVENTS=TRUE}{$SETC USETRACEMODE=TRUE}{$SETC FLIPTREE = FALSE}{$SETC TINKERTOY = FALSE}{$SETC PROBSTEPCHART=FALSE}{$SETC PROBRECONSTRUCT=FALSE}{$SETC CHARPARTITIONS = TRUE}{$SETC MEGA=TRUE}	const			UnStoredLink = 'UNTITLED';       {name of unstored link (tree, wtset, etc.) saved by MacClade - must be UPPER CASE}		TempBase = 'MacClade Temp';{-------- MacClade Limits -----}{$IFC NOT DEMO}		mnchars = 32000; 	{max number characters}		mntaxa = 1500;  		{max number taxa}{$ELSEC}		mnchars = 50; 	{max number characters if demo copy}		mntaxa = 12;  	{max number taxa if demo copy}{$ENDC}		maxCtlValue = 32000;				mintaxain = 3;	{minimum number of taxa in tree}		maxCS = 30;  {max number of nodes in Character State Trees}		mncontinuous = 10;		absmaxstate = 25;   {absolute maxima for state set values}		absmaxnumstates = 26;		absmaxhighestbit = 31;		maxproteinstate = 24;		maxAAstate = 20;		maxDNAstate = 3;		maxerrorswithchars = 5;		maxcharsoferrors = 10;{$IFC USETRACEMODE}{traceshown constants |||}		tracenothing = 0;		tracediscrete = 1;		traceallchanges = 2;		traceallstates = 3;		tracecontinuous = 4;		traceallreroots = 5;		traceallmoves = 6;		traceprobability = 7;		tracegenericdisc = 8;		tracegenericcont = 9;		traceCellColors = 10;{$ENDC}		maxTraceKinds = 10;{=== trace probability constants}		stateexact = 1;		statenotwrong = 2;		changecorrect = 3;		numchangeUnamb = 4;		numchangeAllowed = 5;		numsteps = 1;		allstates = 2;{!!!-------- calculation control constants ------''''''''''''''''''''''}{fullgotree"""""""""""""""""""""}		settaxdnall = 0;		calcminlenall = 1;		calcmaxlenall = 2;		countall = 3;		changesall = 4;		ciall = 5;		riall = 6;		reconstructall = 7;		reconstructi = 8; 		{"""igos}		brchangesall = 9;		GOcontinuous = 10;{on demand only"""""""""""}		resetlengthall = 11;		resetminlengthall = 12;		resetmaxlengthall = 13;		settaxdni2 = 14;		calcminleni2 = 15;		calcmaxleni2 = 16;		counti2 = 17;		reconstructi2 = 18;{fullgoChartone"""""""""""""one tree charts}		stepschart = 19;		CIRIchart = 20;		stepsChgschart = 21;		Changesichart = 22; 			{"""igos}		ChangesAllchart = 23;		statesichart = 24; 			{"""igos}		statesallchart = 25;{fullgoChartMult"""""""""""""multiple trees charts}		stepsIchartmult = 26;		{"""igos}		stepsAllchartmult = 27;		stepsChgsIchartmult = 28;		{"""igos}		stepsChgsAllchartmult = 29;		treelengthschart = 30;		CIRIichartmult = 31;		{"""igos}		CIRIAllChartMult = 32;		ChangesiChartmult = 33; 			{"""igos }		ChangesAllChartmult = 34;		Twotreeschart = 35;		TwoTreefiles = 36;{$IFC PROBRECONSTRUCT}		goProbability = 37;  {Wayne: also put in FullgoTree}{$ENDC}{$IFC PROBSTEPCHART}		goProbStepsChart = 38;{$ENDC}{-------- BITS constants ------}		MSl = 31;   	{missing data bit (largest)}		ERl = 30; 		{error data bit (largest)}		UCl = 29;  	{uncertain data bit (largest)}		GAl = 28;  	{ gap data bit (largest)}		FTl = 27;   	{foottext present bit (largest)}		FPl = 26;		{footpict present bit (largest)}		SSl = 25;		{small symbols bit (largest)}				MSo = 0;   	{missing data offset}		ERo = 1; 		{error data offset}		UCo = 2;  		{uncertain data offset}		GAo = 3;  		{ gap data offset}		FTo = 4;   		{foottext present offset}		FPo = 5;		{footpict present offset}		SSo = 6;   	{small symbols offset}		defState = MSl;{--------  width in bytes and bits of various memory storage elements ---------------}{tcB = 2;	# of bytes for states of 1 character of 1 taxon; NOW VARIABLE}{chsB = 2;	 # of bytes for set of all states of 1 character; NOW VARIABLE}		exb = 2;	{# of bytes for inc exc of 1 character}		chlB = 4;	{# of bytes for length of 1 character}		chtB = 2;	{# of bytes for typ of 1 character}		chwB = 2;	{# of bytes for wt of 1 character}		chpB = 4;	{# of bytes for polymorphism length of 1 character}		chpartB = 2; 	{# of bytes for partition of 1 character}		slb = 6; {# of info bytes at start of each wtset,typeset,exset,tree link}			{NOTE: SLB must be and even Number!!!}		wtrealbit = 16;		{for wtset}		polytomybit = 16;		fixancbit = 17;		charfixedbit = 18;		segstoredbit = 19;		branchLengthStoredBit=20;				{notesbit = 20;  not used}		{lengthsbit = 21; not used}		selectedbit = 22;		showbit=23;		{lockedNamebit = 23;  not used}				numberInLinkByte = 4;		maxchangesshown = 9;		goMax = 63;{|||||||||||   MENUS ||||||||||||}		firstMenu = 257;		AppleMenu = 256;		FileMenu = 257;		EditMenu = 258;		TreeMenu = 259;		TraceMenu = 260;		WindowsMenu = 261;		EWDisplayMenu = 262;		GDisplayMenu = 263;		TWDisplayMenu = 264;		EquivMenu = 265;		ToolMenu = 266;		NewChartMenu = 267;		EdUtilitiesMenu = 268;		CalcMenu = 269;		CharactersMenu=270;		TaxaMenu = 271;		ChartDisplayMenu=272;		lastMenu = 272;				firstHierarchicalMenu = 8;		ExpFileMenu = 8;		ExpTreeMenu = 9;		PrOptionsMenu = 10;		CodingMenu = 11;		SimpleSelectMenu = 12;{colorTicksIndexClassMenu = 13; in TraceAllChangesOptions}		StyleMenu = 14;		SaveOptionsMenu = 15;		SizeMenu = 16;		FontMenu = 17;		IncExcMenu = 18;		TypeMenu = 19;		TextMenu = 20;		SaveOtherMenu = 21;		PrintOtherMenu = 22;		WeightMenu = 23;{еее}		ExpDelMenu = 25;		ImpFileMenu = 26;		ShadesMenu = 27;		GenCodeMenu = 28;{еее}		ConsensusTaxSetMenu=30;		StateNamesMenu = 31;{32 taken by pop up importtypesmenu}		InfoSelectMenu = 33;		ShowMenu = 34;		CopySpecialMenu = 35;		xxCreateCharactersMenu = 36;		TemporaryMenu = 37;   {not defined in resource fork}		xxCharacterSetsMenu = 38;		xxDataFormatMenu = 39;		xxCreateTaxaMenu = 40;		xxImportTaxaMenu = 41;		xxTaxonSetsMenu = 42;		xxCreateTreesMenu = 43;{xxTreeFileMenu = 44;}		xxTypeSetsMenu = 45;		xxWeightSetsMenu =46;		xxInclusionSetsMenu=47;		FindMenu=48;		ColumnWidthMenu=49;		ShadeCharSetMenu=50;		NEXUSBlocksMenu=51;		DataMatrixStyleMenu = 52;		ColorCellsMenu=53;		AATranslateMenu=54;		ColorCodPosMenu=55;		ReplaceAllMenu=56;		IncExcTaxaMenu = 57;		ChartViewsMenu=58;		TaxonListOptionsMenu=59;		CharListOptionsMenu=60;		GoToMenu = 61;		CharPartMenu = 62;		CharPartListMenu = 63;		ColorCharPartitionMenu=64;		MismatchMenu=65;		dlogStyleMenu = 66;		dlogSizeMenu = 67;		dlogFontMenu = 68;		dlogImportTaxaMenu = 69;		infoMoveMenu = 70;		lastHierarchicalMenu = 70;				var		CharactersMHdl: MenuHandle;		xxCreateCharactersMHdl: MenuHandle;		xxCharacterSetsMHdl: MenuHandle;		TaxaMHdl : MenuHandle;		xxDataFormatMHdl: MenuHandle;		xxCreateTaxaMHdl: MenuHandle;		xxImportTaxaMHdl: MenuHandle;		xxTaxonSetsMHdl: MenuHandle;		xxCreateTreesMHdl: MenuHandle;		xxTreeFileMHdl: MenuHandle;		xxTypeSetsMHdl: MenuHandle;		xxWeightSetsMHdl: MenuHandle;		xxInclusionSetsMHdl: MenuHandle;		ColumnWidthMHdl: MenuHandle;		ShadeCharSetMHdl: MenuHandle;		NexusBlocksMHdl: MenuHandle;		DataMatrixStyleMHdl: MenuHandle;		ColorCellsMHdl: MenuHandle;		ConsensusTaxSetMHdl: MenuHandle;		AATranslateMHdl: MenuHandle;		ColorCodPosMHdl: MenuHandle;		ColorCharPartitionMHdl: MenuHandle;		MisMatchMHdl: Menuhandle;		CategoriesMHdl: MenuHandle;		CharPartitionsMHdl: MenuHandle;		ReplaceAllMHdl: MenuHandle;		IncExcTaxaMHdl: MenuHandle;		ChartViewsMHdl: MenuHandle;		TaxonListOptionsMHdl: MenuHandle;		CharListOptionsMHdl: MenuHandle;		GoToMHdl: MenuHandle;		const{----- menu items -----------}{apple menu items}		AboutMCItem = 1;{file menu items}		NewItem = 1;		OpenItem = 2;		CloseFileItem = 3;		CloseWindowItem=4;		RevertItem=5;		SaveDataItem = 7;		SaveDataAsItem = 8;		ExportItem = 9;		GraphicFileItem = 10;		ToTextItem = 11;		IOOptionsItem = 12;		PageSetUpItem = 14;		PrintingItem = 15;		PrintExtraItem=16;		PrintOtherItem = 17;		PreferenceItem = 19;		QuitItem = 21;{edit menu items}		UndoItem = 1;		{WarnIfCantUndoItem=2;}		CutItem = 3;		CopyItem = 4;		PasteItem =5;		ClearItem = 6;		DeleteItem = 7;		xxxxDuplicateItem = 8;		xxxxMultiplyItem=9;		SelectItem = 11;		SelectTaxaWithStateItem = 12;		TransferSelectionItem=13;		ShrinkWrapSelectionItem=14;		MoveSelectedRowsToTopItem = 15;		GoToSubmenuItem=16;		NexusBlocksSubmenuItem=18;		CopyPAUPSubmenuItem=19;		ContinuousEditItem = 20;		LockControlItem = 21;				LastEditItemInTreeWindow = 21;				EntryInterpretItem = 23;		TrackCellItem = 24;		TreatMissingAsGapItem = 25;				{GoTo menu}		GoToSelection =1;		GoToHomeItem = 2;		GoToObjectItem=3;		GoToTraceCharacterItem =4;{copy special items}		CopyConstraintTreeItem=1;		CopyOutgroupItem=2;		CopyCustom1Item=3;		CopyCustom2Item=4;		PAUPCommandsOptionsItem=5;		{NEXUS BLocks}		NexusBlockListItem=1;		NewNexusBlockItem=2;		OpenPAUPBlockItem=3;		EditNexusBlockItem=4;{edit utilities item}		{AddItem = 1;		MultiplicateItem = 2;		DuplicateItem = 3;}		{MergeCharsItem = 1;		FilterCharItem = 2;		MergeTaxaItem = 3;		FilterTaxItem = 4;}		FindSubmenuItem=1;		SearchAndReplaceItem = 2;   {v3.06:  was 8 in 3.05}		RecodeItem = 3;		ComplementItem = 4;		ReplaceAllSubmenuItem=5;		FillItem = 6;		RandomFillItem = 7;		UpperCaseItem = 8;		LowerCaseItem=9;		ShuffleItem = 11;		ReverseItem =12;		CondenseTaxonNamesItem = 14;		TranslateTaxonNamesItem = 15;{$IFC RESEARCH}		ShiftMinimizeStopsItem=16;		//ShiftToMatchItem=17;		ShiftOtherToMatchItem=17;		ImportProteinAlignmentItem=18;		SpeakMatrixItem = 20;		SpeechOptionsItem = 21;		xxxxImportPictureItem = 23;		xxxxRemovePictureItem=24;{$ELSEC}		SpeakMatrixItem = 17;		SpeechOptionsItem = 18;		xxxxImportPictureItem = 20;		xxxxRemovePictureItem=21;{$ENDC}		{Replace All  submenu}				TerminalMissingToGapsItem = 1;		TerminalGapsToMissingItem = 2;		NtoMissingItem = 3;		MissingToNItem = 4;		TerminalPartTripletsToGapsItem=5;{Find submenu}		FindItem=1;		EnterFindItem=2;		FindNextItem=3;		FindPreviousItem=4;		FlashFindItem=6;		FlashFindIgnoreGapsItem=7;		FlashNonCodonsItem=9;{$IFC RESEARCH}		FindNonCodonsItem=10;{$ENDC}{$IFC FLASHRNACOMP}		EnterRNARCItem=12;		FlashRNARCIgnoreGapsItem=13;		FlashRNARCMisMatchSubItem=14;		FlashRNARCOffItem=15;{$ENDC}{tree menu items}		TreeListItem = 1;		ShowTreeItem=2;		StoreTreeItem =3;		CreateTreeItem=4;  {submenu}		WarningsItem=5;		NewTreeFileItem = 7;		OpenTreeFileItem = 8;		CloseTreeFileItem = 9;		SaveTreeFileItem = 10;		SaveAsTreeFileItem = 11;		ExTreeFileItem = 12;		TransferTreeItem = 13;		IncExcTaxaItem = 15;	{	SearchOptionsItem = 16;}		PolyRealItem = 16;		AllTermItem = 17;		{create Tree submenu}		DefaultLadderItem=1;		DefaultBushItem=2;		RandomTreeItem = 3;		AllRootingsItem=4;{trace menu items}		TraceOnOffItem = 1;		TraceSelectedItem = 2;		TraceCharItem = 3;		TraceLastItem = 4;		EquivCycleItem = 5;		NumberMPRsItem=6;		MPRCalcOptions = 7;  {+++}		ResolveOptionItem = 8;		UnfixAllItem = 9;		TraceAllChangesItem = 11;		AllChangesOptionsItem = 12;		TraceAllStatesItem = 14;		AllStatesOptionsItem = 15;		ContinuousOptionsItem = 17;		ProbReconstructItem = 18;{characters menu}		xxxxCharacterListItem = 1;		CharListOptionsSubmenuItem=2;		CharacterSetsSubmenuItem=3;		CharacterPartSubmenuItem=4;		xxxxAddEmptyCharacterItem=5;		xxxxCompressCharactersItem=6;		{xxxxFilterCharactersItem=5;}		{character partitions submenu}		{categories submenu}		{----}		dataFormatSubmenuItem=8;		xxxxStateNamesSymbolsItem=9;		xxxxGeneticCodeItem = 10;		xxxxCodonPosItem=11;  {submenu}		{----}		changeTypeSubmenuItem=13;		xxxxEditTypeItem = 14;		xxxxImportTypeItem=15;		TypeSetListSubMenuItem=16;		{----}		changeWtSubmenuItem=18;		WtSetListSubMenuItem=19;		{----}		changeIncExcSubmenuItem=21;		ExSetListSubMenuItem=22;		{----}		xxxxEvolveCharacterItem=24;				CharacterSetsListItem = 1;		StoreCharacterSetItem=2;{groups & partitions submenu}		GroupLabelListItem=1;		NewGroupLabelItem=2;		SetGroupColorItem=3;		ShowCurrentPartitionItem=4;		SetSelectedAsGroupItem=5;		CharacterPartitionListItem = 7;		UseCharPartitionItem=8;		StoreCharacterPartitionItem=9;{char list options submenu}		ShowMissingInCharListItem=1;		ShowGapsInCharListItem=2;		ShowPartitioninCharListItem=3;		{DataFormat submenu}{these constants are also used for SetDataFormat}		StandFormItem = 1;		Stand32Item = 2;		DNAFormItem = 3;		RNAFormItem = 4;		proteinItem = 5;		{GeneticCodeItem = 7;		xxxxStandardDatatypeItem=1;		xxxxExtendedDatatypeItem=2;		xxxxDNADatatypeItem=3;		xxxxRNADatatypeItem=4;		xxxxProteinDatatypeItem=5;}				TypeSetListItem=1;		UseTypeSetItem=2;		StoreTypeSetItem=3;		AllUnorderedItem=5;		AllOrderedItem=6;				WeightSetListItem=1;		UseWeightSetItem=2;		StoreWeightSetItem=3;		AllEqualItem=5;				InclusionSetListItem=1;		UseInclusionSetItem=2;		StoreInclusionSetItem=3;		AllIncludedItem=5;		AllExcludedItem=6;		xxxxExcludeUninformItem=7;		{taxa menu}		TaxonListItem =1;		TaxonListOptionsSubMenuItem=2;		TaxonSetsSubmenuItem = 3; {submenu}		AddEmptyTaxaItem=4;		ImportTaxaSubmenuItem = 5; {submenu}		MoveToTaxonItem=6;		xxxxMergeTaxaItem=7;		xxxxFilterTaxaItem=8;		ReorderByTreeItem = 10;		ReorderRandomlyItem = 11;		ShowNucFrequenciesInTaxonListItem=1;		ShowStopCodonsInTaxonListItem=2;		ShowPartTripletsInTaxonListItem=3;		ShowFirstBaseInTaxonListItem = 4;		ShowLastBaseInTaxonListItem = 5;		ShowLowerCaseInTaxonListItem = 6;		ShowUncertaintyInTaxonListItem = 7;		ShowPolymorphismInTaxonListItem = 8;		ConsiderExcludedInTaxonListItem=10;		{import taxa menu}		ImportNBRFItem = 1;		ImportGenbankItem=2;		ImportFASTAItem=3;		ImportSimpleTextItem=4;		ImportSequenceOnlyItem=5;		ImportOptionsItem = 7;		{taxon set menu}		TaxonSetListItem=1;		StoreTaxonSetItem=2;{assump menu items}		{ChangeTypeItem = 1;		SetWtItem = 2;		IncludeExcludeItem = 3;		CodMenuItem = 4;		GettypeItem = 6;		SavetypeItem = 7;		TypeImpItem = 8;		TypeDefItem = 9;		GetWtItem = 11;		SaveWtItem = 12;		GetExSetITem = 14;		SaveExSetItem = 15;		ExcludeUninformItem = 16;}{calcmenu}		LengthItem = 1;		ChangesItem = 2;		CIItem = 3;		RIItem = 4;		RCItem = 5;		MinPosItem = 6;		MaxPosItem = 7;				IndexNotationItem = 9;		DecayIndexItem=11;		ProbModelItem = 13;		maxCalcItem = 7;{Equiv menu items}		EquivNextItem = 1;		EquivGoToItem = 2;		EquivNumberItem = 3;		EquivOffItem = 4;{window menu items}		TreeWindowItem = 1;		DataEditorItem = 2;		FileNotesItem = 4;		TreeNotesItem=5;		ToolPaletteItem = 6;		LastToolItem = 7;				OpenWindowsFirstItem=9;				{ChartWindowItem = 3;		CharInfoItem = 5;		StateNamesItem = 6;		TaxInfoItem = 7;		TreeInfoItem = 8;		CharSetInfoItem=15;  		TaxSetInfoItem = 16;		WtSetInfoItem = 17;		TypeSetInfoItem = 18;		ExSetInfoItem = 19;}{TWdisplay menu items}		TraceLabelItem = 6;		BarDisplayOptionsItem = 7;		BranchPatternsAndColorsItem = 8;		TreeShapeAndSizeItem = 9;		TipLabelsItem = 10;		LockLegendsItem = 12;		ZoomTWItem = 13;{EWdisplay menu items}		EWFontItem = 1;		EWSizeItem = 2;		EWStyleItem = 3;				DataMatrixStyleSubmenuItem=5; {submenu}		ShowMenuSubITem=6; {submenu}		ColorCellsSubMenuItem=7;  {submenu}		ShadeCharSetMenuItem=8;  {submenu}		ColorCodPosSubMenuItem=9; {submenu}		ColorPartitionsSubMenuItem=10; {submenu}				ColumnWidthSubmenuItem=11; {submenu}		AATranslateSubMenuItem=12;  {submenu}				EditorTransposedItem=13;		SymbolsItem =14;	{	EWColorsItem=15;}				MatchCharItem = 16; 		ConsensusItem = 17;		ConsensusTaxSetSubmenuItem=18;	{	AutoAATranslateItem=21;  }	{	ShowSimilarItem=10;}		PICTshowItem = 19;		SetEditorSelectionColorItem = 20;		footTextItem = 22;		FootstatesItem = 23;		{Chart Display Menu Items}		ChartFontItem=1;		ChartSizeItem=2;		ChartStyleItem=3;				ChartDisplayShowSubMenuItem=5;		ChartDisplayViewSubMenuItem=6;		ChartDisplayVerticalAxisItem=7;		ChartDisplayHorizontalAxisItem=8;		ChartDisplayPercentageItem=9;		ChartDisplayValuesItem=10;		ChartDisplayCircleSizeItem=11;		ChartDisplayPatternsColorsItem=12;				{ChartDisplayShow Menu Items}		ChartShowTitleItem=1;		ChartShowGridItem=2;	{ChartViews Menu Items}		ChartViewsChartItem=1;		ChartViewsTableItem=2;		ChartViewsSummaryItem=3;	{ShadeCharSet Submenu}		ShadeNumbersItem=1;		ShadeTitlesItem=2;		ShadeCellsItem=3;		ShadeDarkerItem=5;		ShadeLighterItem=6;		FirstShadeCharSetItem=8;		ShadeAllItem=8;		ShadeNoneItem=9;		// ShadeExcludedItem is a variable.		{infoWindows selection menu}		infoSelectAllItem =1;		infoSelectNoneItem =2;		infoSelectReverseItem =3;		infoSelectIncludedTaxaItem=4;		infoSelectExcludedTaxaItem=5;				infoSelectIncludedCharsItem=4;		infoSelectExcludedCharsItem=5;		infoSelectInvariantCharsItem=6;		infoSelectGapsMissingCharsItem=7;		infoSelectEvery10thCharsItem=8;		infoSelectGapRunsCharsItem=9;		infoSelectCodingCharsItem=10;		infoSelectNonCodingCharsItem=11;		infoSelectPos1CharsItem=12;		infoSelectPos2CharsItem=13;		infoSelectPos3CharsItem=14;		{AATranslateMenu}		AATranslateShowItem=1;		AATranslateColorItem=2;		AATranslateDimNucItem=3;	{Color Partition}		PartNumbersItem=1;		PartTitlesItem=2;		PartCellsItem=3;	{Color CellsSubmenu}		ColorCellsOffItem=1;		ColorCellsByStateItem=2;		ColorCellsByAAStateItem=3;		ColorCellsMatchFirstItem=4;		ColorCellsDimLowerCaseItem = 6;		ColorCellsStateColorItem=8;		ColorCellsProteinStateColorItem=9;		ColorCellsLettersOnlyItem=10;				{ColorCellsByCodPosItem=4;		ColorCellsByPartitionItem=5;		ColorCellsAATranslate=7;}	{ColumnWidth menu}		OtherColumnWidthItem = 12;{NOTE: if you change column width submenu items, then search for DoColumnWidthMenu, and change relevant values}		{DataMatrixStyle menu}		styleStandardItem = 1;		styleMolecularItem=2;		styleShadedMolecularItem=3;		styleDNAwithAAColorsItem=4;		styleShadedDNAwithAAColorsItem=5;		styleDNAwithAAItem=6;		styleBirdsEyeItem=7;		styleWideNamesItem=8;		styleDimExcludedItem=9;		{EWShow menu Items}		EWGridItem = 1;		EWTaxonNumbersItem = 2;		EWTaxonNamesItem=3;		EWCharacterNumbersItem = 4;		EWCellSymbolsItem=5;		EWStateNamesItem=6;		EWUseIUPACItem=7;	{	EWColorCellsItem = 6;		EWAAColorCellsItem=7;}				{EWAAwithDNAItem=6;}				EWShowMaxItem = 7;{TWShow menu Items}		{ToolPaletteItem=1;}		BranchNumbersItem = 1;		EvolveSegsItem = 2;		Nex7onItem = 3;		ShrinkItem = 4;		TWShowMaxItem = 5;{PrintOtherMenu}		PtNotesItem = 1;		PtNodeListItem = 2;		PtFootTextItem = 3;		PtFootPictsItem = 4;		PtDataBoxesItem = 5;		PtTypesItem = 6;		PtGenCodeItem = 7;		PtContinuousItem = 8;{size menu}		S8Item = 1;		S9Item = 2;		S10Item = 3;		S12Item = 4;		S14Item = 5;		S18Item = 6;		SOtherItem = 7;{style menu}		PlainItem = 1;		ItalicItem = 2;		BoldItem = 3;		UnderlineItem = 4;		ShadowItem = 5;		OutlineItem = 6;		CondenseItem = 7;		ExtendItem = 8;{chart menu}		sStepsItem = 1;		sTreeLengthItem = 2;		sChangesItem = 3;		sStatesItem = 4;		sTwoTreesItem = 5;		sTwoTreeFileItem = 6;		MaxChartItem = 6;		CWCSteps = 1;		CWCCTAll = 2;		CWCChanges = 3;		CWCStates = 4;		CWCC2T = 5;		CWCC2TF = 6;		CWCProbSteps = 7;		CWCcst = 8;   {for cycling through  CST's}		numCharts = 8;		CWCCTTrace = 6;{chart menu lower items}		ChartOptionsItem = 8;		ChartWtTypeItem = 9;		ChartPrintItem = 10;		ChartQuietRecalcItem = 11;		ChartLogOptionsItem=12;{export file menu}		NBRFFileItem = 1;		NBRFNoGapsFileItem = 2;		TEXTFileItem = 3;		PHYLIPFileItem = 4;		PHYLIP34FileItem = 5;		PHYLIP36FileItem=6;		DescFileItem = 7;		HTMLFileItem = 8;		HennigFileItem = 9;		NonaFileItem=10;		MegaItem = 11;		MalignItem = 12;		FastaItem=13;{export treefile menu}		HennigTreesItem = 1;		PHYLIPTreesItem = 2;		PHYLIP34TreesItem = 3;{IncExcMenu}		IncludeItem = 1;		ExcludeItem = 2;		SwitchItem = 3;		ExcUninform = 4;   {not in menu, but used to pass stuff to DoIncExcMenu}{WeightMenu}		ChgWtItem = 1;		ContWtsItem = 2;		ZeroWtItem = 4;{CodingMenu}		CalcCodPosItem = 1;		Pos1Item = 2;		Pos2Item = 3;		Pos3Item = 4;		CodeNotSetItem=5;		NotCodingItem = 6;{SaveOtherMenu}		SvTxtWindowItem = 1;		SvTxtNotesItem = 2;		SvTxtNodeListItem = 3;		SvTxtCharListItem=4;{SavingOptionsMenu}		NEXUSItem = 1;		SaveOptOtherItem = 2;{------ alert boxes ---------}		SaveChangeID = 256;		QueryEditID = 261;		FinderAlertID = 290;		WarningID = 301;		IOAlertID = 302;		DebugID = 303;		OopsID = 304;		{FindHelpID = 313;}		CharTypeID = 315;{----- dialog boxes ---------}		PrintNoteID = 314;		osEvent = App4Evt;		suspendResumeMessage = 1;		resumeMask = 1;{|||||||||||   ||||||||||||}{----- fonts ---------}	{	MacCladeFontName = 'maccladesmall';		FontFileName = 'MacClade Font File';}{----- filetypes ---------}		notAFileType = -1;		simpletext = 0;		{*}		macclade = 1;		paup = 2;		hennig = 3;			{*}		phylip = 4;			{*}		descriptions = 5;		{*}		oldmacclade = 6;		NBRF = 7;			{*}		{maxFileTypes3 = 7;  }		mega = 8;			{*}		genbank = 9;		malign=10;		htmlmatrix = 11;		NBRFnogaps = 12;		nona = 13;		sequenceOnly=14;		clustal=15;		gcg=16;		fasta = 17;		taxonNamesOnly=18;				maxFileTypes = 20;   {can''t change this without changing SETTINGS version of saveoptionsid!!!!}{---------------------------}		pi = 3.14159265358979;{------ sets of different kinds of amino acids ------}		nonpolarAA = [0, 4, 7, 9, 10, 12, 17, 18];		polarAA = [1, 5, 11, 13, 15, 16, 19];		negativeAA = [2, 3];		positiveAA = [8, 6, 14];{-------- function constants for SACW and ChartToType --------}		SACWInverse = -1;		SACWSquareInverse = -2;		SACWRC = -3;		SACWCI = -4;		SACWRI = -5;		ChartTypeInverse = -1;		ChartTypeSquareInverse = -2;		ChartTypeLN = -3;		ChartTypeLNMatNorm = -4;{-------- continuous tracing --------}		manhattan = 0;		sqrooted = 1;		sqUnrooted = 2;		manhatmin = 3;		manhatmax = 4;		sqFelsX = 5;  {ввв}		sqFelsContrast = 6; {ввв}		sqFelsContrastSTD = 7; {ввв}		sqFelsVariance = 8; {ввв}{-------- continuous tracing --------}		notASet = -1;		pos1charSet = -2;		pos2charSet = -3;		pos3charSet = -4;		nonCodingCharSet = -5;		invarCharSet = -6;		uninformCharSet = -7;{----- Chart Window views ---------}		histoview = 0;		scatterview = 1;		tableview = 2;		infoview = 3;		numChartViews = 3;{----- types of Alerts ---------}		StopA = 0;		CautionA = 1;		NoteA = 2;		GenericA = 3;{----- equivocal constants ---------}		allpossible = 0;		deltran = 1;		acctran = 2;		maxtran = 3;		mintran = 4;{----- TreeOrUtree constants ---------}		tutRooted = 0;		tutUnRooted = 1;		tutAsTypes = 2;{----- changessummary views ---------}		asticks = 0;		aspattern = 1;		asphylo = 2;		asLengthNum = 3;		asBlack = 4;		numsummaryviews = 4;{----- colorTicksIndexClass ---------}		colorTicksCI = 0;		colorTicksRI = 1;		colorTicksRC = 2;{-------- algorithm passes --------}		down = -1;		triple = 0;		up = 1;		minlength = 2;		maxlength = 3;{------- traced or not, for readability of calls to calc procedures ------}		tracedtrue = true;		tracedfalse = false;{-------- ignore --------}		uninform = 0;		invar = 1;		notgiven = 2;		ignorenone = 3;{-------- undo constants --------}		justmove = 0;		justgot = 1;		justreroot = 2;		justswap = 3;		justcollapseall = 4;		justRootnullmove = 5;		justinex = 6;		justother = 7;{--------  tree constants -------}		RTResolve = -8;		RTequiprobable = -7;		RTjoining = -6;		RTpartition = -5;		ladder = 44;		bush = 55;{--------  ChartWindow Trees To Use -------}		CWCurrentTree = 0;		CWTreeFile = 1;		CWRandomTrees = 2;		CWStoredTrees = 3;{--------  CWStepsShow -------}		CWStepsSteps = 0;		CWStepsChanges = 1;		CWStepsCI = 2;		CWStepsRI = 3;		CWStepsRC = 4;{--------  ChartLinearData categories -------}		CLmin = 0;		CLstandard = 1;		CLmax = 2;		CLextra = 3;		CLmin1 = 0;		CLmax1 = 1;		CLmin2 = 2;		CLmax2 = 3;		CLminmin = 0;		CLminmean = 1;		CLminmax = 2;		CLmaxmin = 3;		CLmaxmean = 4;		CLmaxmax = 5;		CLextraMin = 6;		CLextraMax = 7;		numCLkinds = 7;{--------  ChartMatrixData categories -------}		CMmin = 0;		CMstandard = 1;		CMmax = 2;		CMextra = 3;		CMminmin = 0;		CMminmean = 1;		CMminmax = 2;		CMmaxmin = 3;		CMmaxmean = 4;		CMmaxmax = 5;		CMextraMin = 6;		CMextraMax = 7;		numCMkinds = 7;{--------  ChartMatrix categories to show (for CWScatterMinMax) -------}		CWScatterExtremes = 0;		CWScatterMeans = 1;		CWScatterMins = 2;		CWScatterMaxs = 3;{-------- chains --------}		notAChain = -1;				datafileChain = 0;		treefileChain = 1;		typeSetChain = 2;		wtSetChain = 3;		exSetChain = 4;		CharSetChain = 5;		taxSetChain = 6;		charPartitionChain=7;{$IFC CHARPARTITIONS}		maxchain = 7;		stringchains = 7;		codPosChain = 8;  {note that this is not really a chain, but it is processed in some places as a chain}{$ELSEC}		maxchain = 6;		stringchains = 6;		codPosChain = 7;  {note that this is not really a chain, but it is processed in some places as a chain}{$ENDC}		minchain = 0;		extratreeChain = 2;				defaultPartition = 1;				{--------- for file writing ---------}				scriptTag = 0;{-------- BLOCKS in data file --------}		notABlock = 0;		maccladeStartBlock = 1;		taxaBlock = 2;		charactersBlock = 3;		dataBlock = 4;		continuousBlock = 5;				codonsBlock = 6;		setsBlock = 7;		assumptionsBlock = 8;				treesDataBlock = 9;		treefileblock = 10;		notesBlock = 11;		MacCladeBlock = 12;		labelsBlock = 13;		numblocks = 13;		paupblock=14;				foreignBlock = 15;   {must be maximum value}		skipBlock = -1;		maximumBlock = 15;{------  datatypes ------}		standard = 0;  {16 bits}		standard32 = 1; {32 bits}		DNA = 2;		RNA = 3;		protein = 4;		continuous = 5;		distribution = 6;	{for COMPONENT}		frequency = 7;		unknownDataType = 15;{=== laserboxes ===}		TreeB = 0;		taxanameB = 1;		legB = 2;		treestatsB = 3;		treenamB = 4;		commentB = 5;		treenumB = 6;		numlaserB = 6;{=== qd.arrow key equiv ===}		upA = 30;		downA = 31;		leftA = 28;		rightA = 29;{=== types ===}		excluded = 255;		unordered = 1;		ordered = 2;		irreversible = 3;		fisher = 4;		Dollo = 5;		usedef = 6;		maxtypes = 245;		AnyTypesAll = [unordered..usedef];		polytomyTypes = [unordered, ordered];		fixancTypes = [unordered, ordered, irreversible, fisher];{-------- tree legend stats --------}		tlegTreeLength = 0;		tlegCI = 1;		tlegRI = 2;		tlegRC = 3;		tlegMin = 4;		tlegMax = 5;		tlegChg = 6;		tlegTAXCHAR = 7;		maxtlegstats = 7;{-------- summary modes --------}		unambigmode = 0;		ambigmode = 1;		maxmode = 2;		minmaxmode = 3;		meanmode = 4;		meanByresolutions = 0;  {whether mean branch lengths calculated over resolutions or by class of changes}		meanBychangeclass = 1;		mmmin = 0;   {mmEnd for printing of minmaxmode branch lengths}		mmmax = 1;		mmmean = 2;		mmShowBars = 0;  {mmShow for printing of minmaxmode branch lengths}		mmShowTicks = 1;		mmDontShow = 2;{----- BranchShades variables -------}		noBranchShades = 1;		branchPatterns = 2;		branchColors = 4;		branchGrayScale = 8;{----- BranchShades array variables -------}{see constants for traceshown, above}{$IFC FALSE}		noTrace = 0;		traceChar = 1;		traceAllChanges = 2;		traceAllStates = 3;		traceConts = 4;		traceCellColors=5;{$ENDC}{-------- char status window selection modes --------}		selectReplace = 0;		selectUnion = 1;		selectIntersection = 2;{-------- setOperator constants --------}		setReplace = 0;		setUnion = 1;		setIntersection = 2;		setSubtraction = 3;		setComplement = 4;{---- printing treeshapes ----}		slanttree = 0;		squaretree = 1;		eurotree = 2;		circletree = 3;{$IFC SIDETREE}		sidetree = 4;		numtreeshapes = 4;{$ELSEC}		numtreeshapes = 3;{$ENDC}{---- theGeneticCode ----}		nuclearcode = 0;		mtDNAcode = 1;		othercode = 2;{v3.05}		universalCode = 1;		universalExtendedCode = 2;  {same as nuclearcode}		drosophilaMTDNACode = 3;		drosophilaMTDNAExtendedCode = 4;		mammalMTDNACode = 5;		mammalMTDNAExtendedCode = 6;   {same as mtDNAcode}		yeastMTDNACode = 7;		protozoanMTDNACode = 8;		echinoMTDNACode = 9;		flatwormMTDNACode = 10;		ciliateNucCode = 11;		candidaCode = 12;				{neurosporaMTDNACode = 8;}		customCode = 13;{---- TWMessWindow entries ----}		TWmessPolyT = 0;		TWmessEquiv = 1;		TWmessFix = 2;		TWmessRoot = 3;		TWmessTaxExc = 4;		TWmessCharExc = 5;		TWmessExpd = 6;		TWmessStop = 7;		TWmessSusp = 8;		maxTWmessIcons = 8;{----- branch list constants - states -------}		BLSstates = 0;		BLSstatesum = 1;{----- branch list constants - states -------}		BLCchanges = 0;		BLClength = 1;{----- Export Delimiters -------}		ExpCR = 0;		ExpCRLF = 1;		ExpLF = 2;						{----- constants for clipping regions in data editor -------}		noscroll = 0;		vertscroll = 1;		horscroll = 2;		justdata = 3;		justdataAndConsenses = 4;		justDataAndCharacters = 5;{----- res id's of cursors -----}		salticid = 287;		carabid = 288;		amoeba = 289;		planaria = 290;		anemone = 291;		starfish = 292;		fish = 293;		tree = 294;		flower = 295;		mouse = 296;		bacteria = 168;		trilobite = 1704;		mushrooms = 19710;		fern = 169;		scallop = 16784;		memory16 = 28824;		memory32 = 3491;		countchange = 3587;		owlfly = 306;		virus = 307;		DNAcurs = 19754;		cantDoCursorID = 164;		crossHairCursorID = 700;		questionCursorID = 151;		gotoCursorID = 174;{----- name lengths ------}		tnw = 127;  {max width of taxon name}		taxonNameLength=127;		characterNameLength=250;		cnw = 250;  {max width of character name}		stnw = 250;  {max width of character state name}		typesig = 31; {max width of name of type name}		linknw = 31; {max width of link names}{----- tiplabel constants ------}		tipTaxa = 1;  	{write taxon name}		tipState = 2;		{write state name}		tipTaxNum = 3;   {write taxon number}{----- mstaxa constants ------}		mstUncertain = 0;  {for mstaxa}		mstPolymorph = 1;		mstVariable = 2;{----- misc ------}		nullpacked = -32768;		maxtok = 252;		TWorigV = 4;		on = 0;		off = 255;		superinfinity = 9999;		infinity = -1;				TWlock = 0;		TWloose = 0; // was 1		TWveryLoose = 2;		notTWWindow = 3;		noButton = -1;						HdlSize = 4;		notinDialog = 100;		readWriteBufferSize = 2000;		growsize = 20000;		n7splitW = 2;		n7top = 2;		ChartInfinity = 100000000;		maxBranchSegments = 1000;		defaultNumBoxes = 7;		footPictFlag = 'е';		footTextFlag = '*';		fixedFlag = 'а';		memorySlack = 32000;  {when MacClade asks for memory, and it checks first to see if there}			{is enough, it checks to see that there is amountrequested+memorySlack; thus, this memorySlack}			{is just a safetyzone to allow for a little slop in the request}		continuousBoxes = 10;		TypeInflate = 10;		MaxTypeReal = 999;		MaxTypeInt = 999;		maxFileNameLength = 31;		footText = 0;		footPict = 1;{$IFC FOOTSOUNDS}		footSound = 2;		maxfoottype = 2;{$ELSEC}		maxfoottype = 1;{$ENDC}		variableFeet = -1;		footTaxBytes = 2;		footCharBytes = 2;		pictmargin = 3;		maxRandomTreeReportTaxa = 150;		sys6NewButton = 11;		sys7NewButton = 10;		WTInflate = 100;		MaxWtReal = 9999;		MaxWtInt = 9999;		MaxPartition = 25;		defRootSize = 35;   {default length of root in tree window}		picgrpbeg = 140;		picGrpEnd = 141;		codeNotSet = 0;		nonCoding = -1;		{codToQuery = -2;}		transposewidth = 26;		defSymbols = '0123456789ABCDEFGHJKLMNPQRSTUVW';		protSymbols = 'ACDEFGHIKLMNPQRSTVWY*1234';{ASCII  characters}		BS = chr(8);		UndefinedGap = ' ';		MCFlagChar = '*';		NoName = chr(8);		EndNames = chr(7);		FillAsFirst = chr(8);		andsepDef = '&';		orsepDef = '/';		gapDef = '-';		missingDef = '?';		matchcharDef = '.';		purine = [0, 2];		pyrim = [1, 3];		maxcyclecurs = 5;		slantright = 1;		slantleft = -1;		charSetMenuBase = 6;   {basic number of elements in Select menu - all, none, reverse, included, excluded, invariant}		charSetMenuNuc = 5;   {extra number of elements if nucleotide data - prot coding, non coding, 1st, 2nd, 3rd}		textbegin = 150;		textend = 151;		textcenter = 154;		numfrontW = 6;		lockBoxWidth=16;{############################}	const		PostScriptBegin = 190;		PostScriptEnd = 191;		TextIsPostScript = 194;		tFlipNone = 0; {no flip of text}		tFlipHorizontal = 1; {horizontal flip of text}		tFlipVertical = 2; {vertical flip of text}		tJusNone = 0; {no alignment}		tJusLeft = 1; {flush left}		tJusCenter = 2; {centered}		tJusRight = 3; {flush right}		tJusFull = 4; {full justification}	type		goSet = set of 0..goMax;		aaset = set of 0..maxproteinstate;		LongRect = record				top, bottom, right, left: longint;			end;		LongPoint = record				v, h: longint;			end;		TTPRHdl = ^TTPRPtr;		TTPRPtr = ^TTxtPicRec;{		TTxtPicRec = packed record				tJus: Byte;				tFlip: Byte;				TRot: Integer;				tLine: Byte;				TCmnt: Byte;			end;}		TTxtPicRec = packed record				tJus: Byte;				tFlip: Byte;				tAngle: Integer;				tLine: Byte;				TCmnt: Byte;				tAngleFixed: Fixed;			end;		TTCHdl = ^TTCPtr;		TTCPtr = ^TTxtCenter;		TTxtCenter = record				y, x: Fixed;			end;		SinglePt = record				h, v: Single;			end;		tracetype = array[0..maxTraceKinds] of integer;		DataTypeSet = set of 0..unknownDataType;		blockSet = set of 0..maximumBlock;		str128 = string[128];		str32 = string[32];		strCharName = string[cnw+1];		strTaxName = string[tnw+1];				strCharStateName = string[stnw+1];				str15 = string[15];		setchars15 = set of 0..15;     { state set}		setchars31 = set of 0..31;     { state set}		set7 = set of 0..7;		set15 = set of 0..15;		Largestsetchars = setchars31;		lgsetchars = ptr;  {new 4 byte set storage}		equatesType = array[0..255] of LargestSetchars;		equatesPtr = ^equatesType;		equatesHandle = ^equatesPtr;		gentype = array[0..absmaxstate] of longint;		genRealType = array[0..absmaxstate] of double;		genRealTypePtr = ^genRealType;		genBooleanType = array[0..absmaxstate] of boolean;		CMDDoubleArray = array[0..absmaxstate, 0..absmaxstate] of Double;		CMDDoublePtr = ^CMDDoubleArray;		CMDDoublePtrArray = array[0..numCMkinds] of CMDDoublePtr;		CMDDoubleCube = array[0..absmaxstate, 0..absmaxstate, 0..absmaxstate] of Double;		CMDDoubleCubePtr = ^CMDDoubleCube;		CMDArray = array[0..absmaxstate, 0..absmaxstate] of longint;		CMDPtr = ^CMDArray;		CMDPtrArray = array[0..numCMkinds] of CMDPtr;				Nptr = ^Ntype;		Ntype = record                {еNode record}				lf,rt, anc: Nptr;				{rt & lf descendants, ancestor}				name: Integer;   				{0 internal, taxon number if external}				original: lgsetchars;  {sets for use with equivocal cycling}				length1: longint;		{branchlengths ; eventually have assigned length}				length2: longint;		{branchlengths ; eventually have assigned length}				real1: double;				real2: double;				lengthmean: double;				chg: integer;				int1, int2: integer;		{miscellaneous integers for general use; used for branch lengths}				int3: integer;   {only used in trace all changes maxmode dual MPR calculations}								realLength: double;								MPR1,MPR2,MPR3,MPR4: genType;				MPRreal,MPRUp: genRealType;				MPRCube: Ptr;				MPRisReal: genBooleanType;				slant: SignedByte;			{-1 if left leaning, 1 if right}				fixanc: BOOLEAN;	        	{true if made ancestral or made anc. onto}				null: BOOLEAN; 				{true if node is null }				fix: BOOLEAN;            		{true if state is fixed}				wasnull: BOOLEAN; 				{true if node was null (used for polytomy randomization)}				down, up, final: Largestsetchars;	{state sets for traced character}				dnstH, upstH, stsH: Handle;	{DownPass & UpPass states for non-u-s types}				downA, downb, upA, upb, finalC, finalD: single;  {storage for continuous characters}				fixsts: LargestSetchars;				{states node is fixed to}				gdnst, gupst: gentype;		{likewise, for user-defined types}												bset1, bset2, bset3: lgsetchars;		{binary sets for general use; used in charcorrelation}		{NOTE: bset1 is used as a pointer in minmaxmode of Trace All Changes}				loc: LongPoint;					{upper left point of branch}				 resolved, dnequiv: lgsetchars;  {sets for use with equivocal cycling}				setLength: integer;				angle, polarLength: single;				loc2: LongPoint;				sLoc, sLoc2: SinglePt;				notes: Ptr;			end;		set255 = set of 1..255;   {for polych calculations}		csintype = array[0..absmaxstate] of set255;  {for polych unord calculations}		scraptype = record				ntax, nchar: integer;  {number of elements in block}				starttaxa, endtaxa, startchars, endchars: integer;				SelOutline: REct;				BUF: Handle;  {Handle to block of sets}			end;		extracodes = array[1..4] of integer;		messtype = array[0..2] of str32;{------laser storage------}		fontSet = record				font, size: integer;				face: style;			end;		laserfontarray = array[0..numlaserB] of fontSet;		startarray = array[0..numlaserB] of point;		treeshaperects = array[0..numtreeshapes] of rect;		treeshapebools = array[0..numtreeshapes] of boolean;{NOTE: if change entries of lasertype, then increase setversion by one in Settings.p & ReadMisc.p}		lasertype = record				fonts: laserfontarray;				LPPCvalue: integer; 				{laser pixel per change value if constant}				width, tracewidth, txsp, versp: integer;				pixelperchg: single;				LPPCconstant, square, all, postscripton, databoxes, printequiv: boolean;				multicharacters: Boolean;		{true if print all characters}				scaleon: boolean;   				{true if put scale by branchlength tree}				showstepslaser: boolean;				showtype: boolean;				summaryView: integer;				condensedTree: boolean;				branchShades: tracetype;				printbranchlengths: boolean;				numbernodes: boolean;				showEvolveSegments: boolean;				showEvolveRealLengths : boolean;				showbox: array[0..numlaserB] of boolean;				treepages, treesPerPage, anglept: point;				treeshape: treeshapebools;				treeshapeB: treeshaperects;				starts: startarray;				LaserTreeLegendInit: boolean;{$IFC MINMAXIN}				mmShow: SignedByte;				mmEnd: signedbyte;{$ENDC}				circleanglept, nameanglept: point;			end;		laserPtr = ^lasertype;		newlasertype = record   {contains new settings for lasertree post 3.0}				ticksNoNames: boolean;				tickstates: boolean;				ticknames: boolean;				tickboxes: boolean;			end;		newLaserPtr = ^newlasertype;		LaserBoxesType = record				growbox: boolean;				R, storage: Rect;			end;		LaserBoxesArray = array[0..numlaserB] of laserBoxesType;		LaserBoxesArrayPtr = ^LaserBoxesArray;		stateFreqType = Array [0..absmaxstate] of integer;		stateFreqPtr = ^stateFreqType;{еееееееееееееееееееееее}		THdlPtr = ^Thdl;		THdl = ^Tptr;		Tptr = ^ttype;		ttype = packed record               	{еterminal taxon record}				B: RECT;			{box under name to show state}				N: Nptr;				deleted: boolean;				footText: boolean;				footPict: boolean;				extra: boolean;				isItalic: boolean;				newTaxon: Boolean;				newlyInserted: boolean;				taxonInTreeDesc: Boolean;    {true if taxon in tree description on read in}				taxSet: boolean;   {for taxsets}				infoSelected: boolean;  {for taxsets}				otherSelected: boolean; {secondary source for taxsets}				direction5to3: boolean;				senseStrand: boolean;				splitTaxon: boolean;				unused1, unused2, unused3, unused4: Boolean;				newlyDeletedFollowing: integer;				charToSplit: integer;				tipNumbers: array[0..absmaxstate] of longint;				dataPoints: longint;      {v3.01: number of "data points" in taxon = num non-missing, non-gaps if no polymorph, no uncert}				nonGaps: longint;      {v3.01}				firstCodPos: integer;				oldNumber: integer;				freqP: stateFreqPtr;				labl: strTaxName;           {label for translation table}				name: strTaxName;		{name of taxon}				contsmin, contsmax: array[1..mncontinuous] of single;  {for continuous}			end;{еееееееееееееееееееееее}		chHdlPtr = ^chHdl;		chHdl = ^chPtr;		chPtr = ^chtype;		chtype = packed record               {е character record}				minLen: longint;	{min conceivable number of steps}				maxLen: longint;	{max conceivable number of steps}				ci, ri: double;		{consistency index!!!}				minchg, maxchg: integer;  {min number of changes on current tree; max number of changes on current tree}				minRestchg, maxRestchg: integer;				consensusAllTies: LargestSetChars; 				consensusMaxFreq: integer;				consensusNumValues: integer;{min number of restricted changes on current tree; max number of restricted changes on current tree}				maxst: SignedByte;		{highest state}				codpos: SignedByte;				consensusAreTies: boolean; 				deleted: boolean;				footText: boolean;				footPict: boolean;				constant: boolean;				charSet: boolean;				charSetToShade: boolean;				MSTTree: boolean;				MSTData: boolean;				PMTree: boolean;				newlyInserted: boolean;				infoSelected: Boolean;				otherSelected: boolean; {secondary source for charsets}				coding: boolean;		{if true, then character is part of a coding region, if false, then note}				extra: boolean;				unused1: boolean;				unused2: Boolean;				extrabits: 0..15;				newlyDeletedFollowing: integer;				oldNumber: integer;				sureset, singletons, fullstates: largestsetchars;				num1, num2, num3: longint;				name: strCharName;				namebackup: strCharName;			end;{еееееееееееееееееееееее}		neighbortype = array[0..maxCS] of set of 0..maxCS;		distancetype = array[0..absmaxstate, 0..absmaxstate] of integer;		typeHdlPtr = ^typeHandle;		typeHandle = ^typePtr;		typePtr = ^typeRecord;		typeRecord = record				inuse: boolean;				polar: boolean;				isreal: boolean;				dist: distancetype;				nbors: neighbortype;				root, max, maxstar: integer;				setdefined: largestsetchars;				name: string[typesig];			end;{еееееееееееееееееееееее}				ChangesSelArray = array[0..absmaxstate, 0..absmaxstate] of boolean;		ChangesSelPtr = ^ChangesSelArray;		setchar = set of char;		codontype = array[0..2] of largestsetchars;		gencodearray = array[0..3, 0..3, 0..3] of Byte;		gencodePtr = ^gencodearray;		stBtype = array[1..absmaxnumstates] of RECT;		windowInfoP = ^windowinfo;		windowInfo = record				windowtype: integer;  {TWLock etc}				font, size: integer;				face: style;				topleft: point;				linewidth: integer;				order: integer;				hasGrowBox: boolean;				updatesAllowed: boolean;				left,top: integer;				width,height: integer;				name: str15;  {name to be used in file settings}			end;		wstype = set of char;		strCHBArray = array[0..stringchains] of Handle;		CLDHandleArray = array[0..numCLkinds] of Handle;		CHAININT = array[0..maxchain] of LONGINT;		CHAINHANDLE = array[0..maxchain] of HANDLE;		CHAINBOOL = array[0..maxchain] of BOOLEAN;		ChainNameType = array[0..maxchain] of StringHandle;		TreeLabMax = array[0..2] of integer;		ChartIntegers = array[1..numcharts] of integer;		tlegtype = record				show: boolean;				lines: integer;				linesabove: integer;			end;		tlegarray = array[0..maxtlegstats] of tlegtype;						DiscreteSet = Longint;  {REPRESENTING SET}		twoid = array[0..1] of longint;		TWMesstype = record				show: boolean;				left: integer;				right: integer;				cursid: twoid;				curcursor: integer;			end;		TWmessarray = array[0..maxTWMessIcons] of TWMesstype;		IP = ^Integer;		LIP = ^Longint;		SetPointer15 = ^SetChars15;		SetPointer31 = ^SetChars31;		LargestSetPointer = ^LargestSetchars;		HdlPtr = ^Handle;		CharPointer = ^char;	{	ExportDelimType3 = array[0..maxFileTypes3] of Integer;  }		ExportDelimType = array[0..maxFileTypes] of Integer;		cyclecursors = array[0..maxcyclecurs] of cursor;	{	foreignlinearray = array[1..numblocks] of Handle;}		randomArray = array[0..absmaxstate] of integer;		RandomArrayPtr = ^randomArray;		RandomArrayHandle = ^RandomArrayPtr;		ExtraTFName = array[1..2] of StringHandle;{############################}	var{ control structures !!!}		golist, gomask, Fullgotree, fullgochartone, fullgochartmult, igos, taxaonlygos: goSet;{16/32 bit controlling integers ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}		mnsts: integer; 			{max number of states per character}		MSb: integer;   			{current missing data bit}		ERb: integer; 				{current error data bit}		UCb: integer;  			{current uncertain data bit}		GAb: integer;  			{current gap data bit}		FTb: integer;   			{current foottext present bit}		FPb: integer;				{current footpict present bit}		maxstbit: integer;		{highest state value allowed by current setchars (9 or 25)}		dollosize: integer;		{size of dollo substorage allowed by current setchars (3 or 8) }		maxstbitplusone: integer;		{highest number of states allowed by current setchars (10 or 26)}		maxbit: integer;			{highest bit in current setchars (15 or 31)}		maxstate: INTEGER;		{highest state value allowed by current data format (3, 9 or 25)}		tcB: integer;				{# of bytes for states of 1 character of 1 taxon}		chsB: integer;			{# of bytes for set of all states of 1 character}{~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}{=== BOOLEANS ===}		quit: BOOLEAN;					{if true, then quit MacClade}		fileopen: BOOLEAN;				{true iff a file is open}		newfile: BOOLEAN;				{true iff an unsaved file is open}		dblclick: BOOLEAN;				{}		treeopen: BOOLEAN;				{true iff treewindow is open}		treefile: BOOLEAN;				{true iff current source of trees is a treefile}		nonCLADwarn: BOOLEAN;		{true iff warn before writing over non-MacClade file}		ErrorFlag: BOOLEAN;				{error in read in or other processing}		badfile: BOOLEAN;				{}		badtree: BOOLEAN;				{}		badio: BOOLEAN;					{}		badmemory: BOOLEAN;			{}		openasuntitled: BOOLEAN;		{}		dodoublecheck: boolean;		randEvolveUseLengths: boolean; 	{}		showEvolveSegments: boolean;	{}		showEvolveRealLengths: boolean;				abortedThermo: BOOLEAN;		{true if commandperiod hit during UpdateThermo}		saveAbbrevHeader: BOOLEAN;	{true if should write into header above data matrix abbreviated header }		saveCanvas: BOOLEAN;			{true if should save rotated text in Canvas 2.1/3.0 format}		useSetsBlock: BOOLEAN;			{true iff write SETS block and ASSUMPTIONS block separately}		ThermoAbortable: BOOLEAN;	{true iff thermometer dialog is abortable}		allminlenillegal: BOOLEAN;		{true iff all included characters cannot have minimum length calculated}		allmaxlenillegal: BOOLEAN;		{true iff all included characters cannot have maximum length calculated}		numericalNames: boolean;		{true iff on read in some numerical names were found}		readingFile: boolean;				{true iff in process of reading file}		colorQDexists: BOOLEAN;		{true iff color QuickDraw exists}		ScreenInColor: BOOLEAN;			{true iff each pixel is several bits () deep - i.e. is in color or QDGray-scale}		nucleotides: BOOLEAN;			{true if DATATYPE=DNA,RNA}		molecular: BOOLEAN;			{true if DATATYPE=DNA,RNA,protein}		datachanged: BOOLEAN;			{}		dirtytree: BOOLEAN;				{}		dirtyfix: boolean;		dirtyfile: BOOLEAN;				{}		dirtytreefile: BOOLEAN;			{}		dirtytaxnames: BOOLEAN;		{}		dirtymaxst: BOOLEAN;			{}		dirtyTreeTaxNames: boolean;		ScrapDirty: BOOLEAN;			{}		scrappictdirty: BOOLEAN;		{}		scraptextdirty: BOOLEAN;		{}		scrapisPICT: BOOLEAN;			{}		MacCladeUpFront: BOOLEAN;	{true iff the front window is a MacClade window OR there is no window visible}{$SETC SPACETRIPLETS=FALSE}{$IFC SPACETRIPLETS}		spacetriplets: boolean; {$ENDC}		singleCharNamePerLine: boolean;		nexusSpaceAfterTriplet: boolean;		standardGenCodeOrder: boolean;		goerror: BOOLEAN;				{}		godraw: BOOLEAN;				{}		goNex7on: boolean;				{true of nex7on has to be updated}		goTWhome: BOOLEAN;			{true if have to reset tree to home position}		goUpdateWindows: BOOLEAN;		chartbeingcalculated: boolean;		blastpolytomies: boolean;		stopaftertree: BOOLEAN;		{}		uniqueresolution: boolean;		interpretStateNames: boolean;		count: BOOLEAN;					{true if should calculate and display treelength in tlegwindow}		calcCI: BOOLEAN;					{true if should calculate and display ci in tlegwindow}		calcRI: BOOLEAN;					{true if should calculate and display ri in tlegwindow}		calcRC: BOOLEAN;				{true if should calculate and display rc in tlegwindow}		calcTreeChanges: BOOLEAN; 	{true if should calculate number of changes in tree}		grid: BOOLEAN;					{}		trackcell: BOOLEAN;				{}		autotabdown: BOOLEAN;			{}		autotabright: BOOLEAN;			{}		MCFlag: BOOLEAN;				{true if on reading file one encounters the special MCFlagChar as the sole character}										{within a comment - eg, if MCFlagChar=*, then MCFlag is set true after finding [*]}		badcellentry: BOOLEAN;			{}		SelCellChanged: BOOLEAN;		{true if currently selected single cell has been changed since it was selected; for undo}		equateson: BOOLEAN;			{true iff EQUATES in NEXUS file}		treewasopen: BOOLEAN;			{}		editwasopen: BOOLEAN;			{}		aboutwasopen: BOOLEAN;		{}		contweighted: BOOLEAN;			{ввв continuous reconstruct using weights on branches}		picton: BOOLEAN;					{true if pictwindow is on}		SavePictOn: BOOLEAN;			{true iff currently in process of drawing to be spooled to pict file}		fullNexus1: BOOLEAN;			{true iff use formal nexus1}		{TempFolderAddresses: boolean;  		true iff there is an addresses file in temporary folder}		{autoWriteAddressesFile: boolean;  		true iff addresses file is to be written on startup}		{addressesFileTime: longint;	 		stores longint with time of writing of addresses file}		currentIOPosition: integer;		emptyChart: boolean;		sequencechart: BOOLEAN;		{}		positionchart: BOOLEAN;			{}		CWJustChanges: BOOLEAN;		{true if show changes, not steps, in steps chart}		CWPercent: BOOLEAN;			{}		CWTraced: BOOLEAN;			{}		CWLinear: BOOLEAN;				{}		CWScatterMultiColor: BOOLEAN;{true if scattergram is multicolored; e.g. transitions red, transversions green}		CWScatterArea: BOOLEAN;		{true if area, not diameter, of scattergram bubbles are proportional to value}		C2TsayShorter: BOOLEAN; 	{if true, then label compare 2 tree axes with shorter rather than longer}		biggraph: BOOLEAN;				{true iff Chartwindow graph is too big to fit on one screen}		addPolychanges: boolean; 		{╫╫╫}		writeScatterStates: boolean;     {if true, and single character Changes and Stasis, then write state names rather than symbols}		Chartgrid: BOOLEAN;				{}		axisleft: BOOLEAN;				{}		axisright: BOOLEAN;				{}		CWfullprint: BOOLEAN;			{}		CW100Axis: BOOLEAN;			{}		CWnormRows: BOOLEAN;		{}		CWShowConstant: BOOLEAN;	{}		CWScaleToMax: BOOLEAN;		{}		ShowChartTitle: BOOLEAN;		{}		autoPixWid: BOOLEAN;			{}		CWUsePostscript: BOOLEAN;	{}		chartAlreadyDrawn: BOOLEAN;	{true iff chart has been drawn previously since calculated}{$IFC CUMUL}		CumView: integer;{$ENDC}		pixwid: integer;		usercatwid: longint;		userMaxChartIntervals: longint;		autoIncreaseChartIntervals: boolean;				warnedAboutMovedSequenceSites : boolean;		includeTranslate: BOOLEAN;		{true iff write translation table in treefile}		scrapPICT: BOOLEAN;			{true iff desk scrap clipboard is of type PICT}		equivcycle: BOOLEAN;			{true if Equivocal Cycling is on}		makenew: BOOLEAN;				{true if New button pressed in SFGetFile}		treeFileOptionsButtonClicked: boolean;		{true if Options button when chosing treefile}{$IFC USETRACEMODE}		traceshown: integer; {$ELSEC}		traceon: BOOLEAN;				{true if a character is being traced in the treewindow}		showallstates: BOOLEAN;		{true iff TraceAllStates is on}		showchangeson: BOOLEAN;		{true iff TraceAllChanges is on}		Reroottraceon: boolean;		AllmoveTraceon: boolean;		continuouson: BOOLEAN;			{true if continuous character is being traced}{$ENDC}		uncertpres: BOOLEAN;			{true iff partial uncertainty present in taxa in tree}		polyon: BOOLEAN;				{true iff polymorphism present in taxa in tree}		FixAncPolymorph: BOOLEAN;		equivpres: BOOLEAN;			{}		anyMSAll: BOOLEAN;				{true if multistate taxon exists in data matrix}		anyMSTree: BOOLEAN;			{true if multistate taxon exists in taxa in tree}		optionIsDown: boolean;		CommandIsDown, ControlIsDown, ShiftIsDown, CapsLockIsDown: boolean;		ticknames, tickstates, tickboxes: boolean;		ambigdistinguish: boolean;		BranchListChgbynames: boolean;		BranchListStatesByNames: boolean;		ShowContTraceLabels: boolean;		ShowProbTraceLabels: boolean;		Noteson: BOOLEAN;				{true iff notes window is on}		ChartOn: BOOLEAN;				{true if chart window is visible}		showfix: BOOLEAN;				{true if ask to show fixed branches}		ancon: BOOLEAN;					{}		noundo: BOOLEAN;				{}		fullundo: BOOLEAN;				{}		justundid: BOOLEAN;				{}		FixLostByUndo: BOOLEAN;		cfound: BOOLEAN;				{true if color found by FindPat}		expd: BOOLEAN;					{}		fixon: BOOLEAN;					{}		nodes: BOOLEAN;					{true if tree is built}		treedrawn: boolean;				{true if tree is drawn}		nex7on: BOOLEAN;				{true if databoxes are shown}		pictEditable: BOOLEAN;			{true iff pictures can be added and removed from file}										{ - i.e. temporary resource file can be made}		symbolson: BOOLEAN;			{}		justchanc: BOOLEAN;				{}		polyreal: BOOLEAN;				{}		nomove: BOOLEAN;				{}		nullson: BOOLEAN;				{}		problemwithcount: BOOLEAN;	{}		debugon: BOOLEAN;				{}		matchcharon: BOOLEAN;			{}		flashbranchon: BOOLEAN;		{}		TWfullscreen: BOOLEAN;			{}		treeinmemory: BOOLEAN;		{}		treeonscreen: BOOLEAN;			{to prevent flash branches when first bringing up treewindow}		treemakingfailed: BOOLEAN;		comingback: BOOLEAN;			{for cursor etc control}		footdirty: BOOLEAN;				{}		chLegTypeBSel: BOOLEAN;		{}		TWscrolling: BOOLEAN;			{}		readHelp: BOOLEAN;				{}		scrollup: BOOLEAN;				{}		interleave: BOOLEAN;			{}		anyGenChar: BOOLEAN;			{}		anydirected: BOOLEAN;			{}		anypolymorph: BOOLEAN;		{}		anyexclchar: BOOLEAN;			{}		RTallTaxa: BOOLEAN;			{true if random trees are to include all taxa in matrix}		cantear: BOOLEAN;				{}		realwt: BOOLEAN;				{}		realtypes: BOOLEAN;				{}		ChartJustCalc: BOOLEAN;		{true if chartwindow has just been recalculated}		branchLengthsweighted: boolean;{...modes...}		BranchListon: BOOLEAN;			{}		readon: Boolean;					{true if currently reading file}		foottexton: BOOLEAN;			{}		footpictson: BOOLEAN;			{}		footsoundon: BOOLEAN;			{}		footediting: BOOLEAN;			{}		CWBlastPolyt: BOOLEAN;		{}		PleaseOffChart: BOOLEAN;		PleaseOffCI: BOOLEAN;		PleaseOffRIRC: BOOLEAN;		PleaseOffMinAll: BOOLEAN;		PleaseOffMaxAll: BOOLEAN;		pleaseoffequivocal: boolean;		pleaseoffcount: boolean;		pleaseoffcontinuous: boolean;		pleaseofftrace: boolean;		pleaseoffchanges: boolean;		wholeword: BOOLEAN;			{if true, then changeedit looks for whole cell match with search string}		vertMatrixNames: Boolean;		writeTaxaCharBlocks: boolean;		writeInTriplets: boolean;		spaceEveryTenth: boolean;			{if true, then writes space after every 10th element of matrix}		branchlistShown: boolean;{check below to see if these need to be globals}		fromroot: BOOLEAN;				{}		toroot: BOOLEAN;				{}		ignoregaps: BOOLEAN;			{true if ignore gaps on DNA->protein conversion}				showtaxnum, showcharnum, showtaxname: boolean;		thermo1: BOOLEAN;				{true if first thermo DLOG is visible}		thermo2: BOOLEAN;				{true if second thermo DLOG is visible}		alwaysCLAD: BOOLEAN;			{true if always write a NEXUS file as a CLAD file}		dirtycharnames: BOOLEAN;		{true if charnames have been changed}		isforeground: BOOLEAN;		poorentry: BOOLEAN;		justredo: BOOLEAN;				{}		polytomiesBlasted: BOOLEAN;		LaserTreeInit: boolean;		wasShowChangesOn: boolean;		squareBranches: boolean; 		{}		autoScaleTicks: boolean;		treeflipped: boolean;		allwt1: BOOLEAN;				{}		onePartition : boolean;		updateHasPriority: boolean;		{}		centerSquareBranches: boolean;		condensedBranches: boolean;		showMinSteps: BOOLEAN;		{}		showMaxSteps: BOOLEAN;		{}		showNodeNumbers: BOOLEAN;	{}		showtracelabels: boolean;		{true iff show boxes with states on traced characters}		chlegbynames, tracelabelsbyname: boolean;		showbranchswappath: boolean;		slowbranchswap: boolean;		traceallShowFisher: boolean;		showcharnumlaser: boolean;		{moveCellBlocks: boolean;}		quietCodPosCalc: boolean;		var 			MSTinTree, MSTinEdit: BOOLEAN;{$IFC SHADOWTREE}		shadowTree: BOOLEAN;{$ENDC}		fileSaved: BOOLEAN;			{}		treefileSaved: BOOLEAN;		{}		writeExpon: BOOLEAN;			{true if write exponential notation to file}		CharInfoExpon: BOOLEAN;		{true if show exponential notation on char status}		fileIsStationery: boolean;		{true iff file currently being process is stationery}		dontCancelUpdate: boolean;		doCodPosQuery: boolean;		speekMatchChar: boolean;		defLaserShowChLeg: boolean;		NoNewErrorStopped: boolean;		StateNamesAreSymbols: boolean;		CharWithStateNamesAsSymbols: integer;				system7orGreater: boolean;		hasStripAddress: BOOLEAN;			{true iff has trap for toolbox call StripAddress}		hasWaitNextEvent: boolean;		hasGestalt: BOOLEAN;		hasBalloonHelp: BOOLEAN;		hasSys7StandFile: BOOLEAN;		hasFindFolder: BOOLEAN;		hasPopUpCDEF: BOOLEAN;		hasSpeechManager: BOOLEAN;		hasSoundInput: boolean;		hasNotificationManager: boolean;		has32BitControlValues: boolean;		hasAppearanceManager: boolean;{$IFC FOOTSOUNDS}		hasSndPlay: boolean;{$ENDC}		hasAppleEventMgr: boolean;		hasNavigationalServices: boolean;		hasNewPrinting: boolean;		hasExchangeFiles: boolean;		hasFSSpecCalls: boolean;		isMacOSX: boolean;		hasAquaMenuLayout: boolean;		sysStationeryAware: boolean;  	{true iff system is stationery pad aware}		showBranchLengths: boolean;		updateFontChangedWindows: boolean;		chartQuietRecalc: boolean;		someCoding: boolean; 			{true iff nucleotide data with at least one site designated as coding}		someCodingIncluded: boolean;	{as above, but among included sites}		someCodPosSet: boolean; 		{true iff nucleotide data with at least one site assigned pos 1,2, or 3}		someCodPosSetIncluded: boolean;   {as above, but among included sites}{$IFC TINKERTOY}		tinkerToy: boolean;		tinkerwidth: integer;		tinkerIncrease: integer;{$ENDC}{for random evolving characters up tree}		EvolveSaveOnlyChanged: BOOLEAN; {}		EvolveAncConstant: BOOLEAN;	{}		EvolveNumChars: INTEGER;		{}		EvolveAncState: INTEGER;		{}{|||||||||||||||||    ||||||||||||||||||}{the following variables are new}		fisheredited: boolean;		legendstates, istates, GrayScaleStates: LargestSetchars;		asteriskset: largestsetchars;		asteriskchar: char;		errorsposted, errorsturnedoff: Ptr;		{memoryErrors: Ptr;				errors dealing with low memory - therefore need special handling}		errorswithChars: array[1..maxerrorswithchars, 0..maxcharsoferrors] of integer;		Fishercost: array[0..absmaxstate] of integer;		pictcount: longint; {current size of treepicture}		globalref: integer;		grabpicture, newpicthand, treepicture, clippicture: PicHandle;		SaveRndTreesReport: boolean;		split: Ptr;{|||||||||||||||||  SIGNEDBYTEs  ||||||||||||||||||}		treeChain: Integer;			{=datafilechain if treefile=datafile, = treefilechain if a separate treefile is in use}										{=extratreechain if temporary value}		BranchListmode: SIGNEDBYTE;	{}		meanBymode: signedbyte;{|||||||||||||||||  INTEGERs  ||||||||||||||||||}		ExportDelimiter: ExportDelimType;		Chartchangesmode: integer;		MOS: INTEGER;					{maximum observed state in whole matrix; 0 based}		MAXS: INTEGER;					{maximum allowable state in whole matrix; 0 based}		numbytes: INTEGER;		maxReconstructedState: integer;	{maximum state reconstructed on all included characters in tree; 0 based}		maxReconstructedStatei: integer;	{maximum state reconstructed on traced character in tree; 0 based}		maxReconstructedStateim: integer;	{maximum state reconstructed on traced character for chart multtrees; 0 based}		maxChangesState: integer;			{maximum state in for chart calculations}		numtaxa: INTEGER; 				{number of taxa in data matrix}		numtaxain: INTEGER; 			{number of taxa in current tree}		oldnumtaxain: INTEGER;			{}		numchars: INTEGER; 				{number of characters in data matrix}		numcharin: INTEGER; 			{number of characters currently included}		numcontinuous: INTEGER;		{number of continuous characters}		sigContinuous: INTEGER;			{num significant digits in continuous chars}		sigIndices: INTEGER;				{num significant digits in CI, etc.}		bywhichsamplesize: integer;		minTicksSpacing: integer;		branchLengthSpacing: integer;		branchLengthSpacingUser: integer;		treeHeight: longint;		screenExtraBranchLength: integer;		nexusVersionProgram: integer;		{version number of Nexus files written and easily understood by program, x10}		nexusVersionFile: integer;			{version number of Nexus used in current file, x10}		squareHScaling, squareVScaling: integer;		interleaveLength: INTEGER;		{}		ignore: INTEGER;					{}		UserCharSetItem: INTEGER;		{first menu item in charsetmenu with user defined char set}		theGeneticCode: INTEGER;		{stores whether standard nuclear, mitochondrial, or othercode genetic code}		prefGeneticCode: INTEGER;		{stores whether standard nuclear, mitochondrial, or othercode genetic code Settings}		totWriteUnits: longint;			{for writing thermometer}		WriteUnit: longint;				{for writing thermometer}		MacCladeSmall: integer;			{font number for maccladesmall font}		continuousmode: INTEGER;		{stores manhattan,sqrooted,sqUnrooted }		numtypes: INTEGER;				{}		tlegline: INTEGER;				{}		tiplabel: INTEGER;				{}		RTKind: INTEGER;					{stores the current type of random tree}		taxonheight: INTEGER;			{}		resolveoption: INTEGER;			{}		NumChangesShown: INTEGER;	{}		oldtracei: INTEGER;				{}		LegScrollW: INTEGER;			{}		twmessWidth: INTEGER;			{width of twmessage box in lower left hand corner of treewindow}		rootsize: INTEGER;				{height of root as shown in standard treewindow}		summaryview: INTEGER;		{}		i: INTEGER;						{number of character traced}		icont: integer;		i2: INTEGER;						{number of single character to be recalculated (not nec. i)}		i7: INTEGER;						{number of character shown at top of databoxes}		//iD: INTEGER;						{number of character shown at top of charinfo window}		ist: INTEGER;						{}		junkinteger: INTEGER;			{}		showPass: INTEGER;				{stores whether up, down, triple pass, etc., to be shown}		ladderDir: INTEGER;				{= 1 if ladderize right,   = -1 if ladderize left}		edw: INTEGER;					{}		natedw: INTEGER;				{}		boxedw: integer;		maxedw: INTEGER;		ntscreen: INTEGER;				{}		numnodesintree: integer;		topmargin: INTEGER;				{}		lasttx: INTEGER;					{}		firsttx: INTEGER;					{}		firstDrawTx: INTEGER;		txsp: INTEGER;					{}		vertTxsp : longint;		mintxsp: INTEGER;				{}		treesblock: integer;		lenplus: INTEGER;					{}		branchShades: tracetype;			{current setting of branchShades (patterns, colors, grayscale)}		defBranchShades: tracetype;		{branch shades requested by preferences file}		userBranchShades: tracetype;		{branch shades requested by user in current run of MC; = noBranchShades if user not requested}		curTrace: integer;				{current thing being traced}		maxswap: INTEGER;				{}		maxchg: INTEGER;				{}		mstaxa: INTEGER;				{}		taxcount: INTEGER;				{}		numboxes: INTEGER;				{}		adjust: INTEGER;					{}		nattop: INTEGER;					{}		displace7: INTEGER;				{}		ScrapCompare: INTEGER;		{}		originoffset: INTEGER;			{}		globalItemHit: INTEGER;				{}		numitems: INTEGER;				{}		maxChangesToRoot: INTEGER;	{}		code: INTEGER;					{}		undotoNull: INTEGER;				{}		undotype: INTEGER;				{}		taxnameL: INTEGER;				{}		gedw: INTEGER;					{}		natnumboxes: INTEGER;			{}		oldtax: INTEGER;					{}		ttelements: INTEGER;			{}		polyLengthtotal: INTEGER;		{}		ascii: INTEGER;					{}		deftype: INTEGER;				{}		speechspeed: INTEGER;			{}		speechdelay: INTEGER;			{}		legnumW: INTEGER;				{}		histopat: INTEGER;				{number (within pat[0...] that serves as pattern for histogram bars}		databoxBHeight: INTEGER;		{}		maxerrors: INTEGER;			{}		oldtreelinknumber: INTEGER;	{}		datatype: INTEGER;				{}		OSResult: INTEGER;				{}		chlegboxheight: INTEGER;		{}		thermo1TimeStart: longint;		{}		thermo2TimeStart: longint;		{}		TreeOrUTree: INTEGER;			{save trees as UTREES, TREES, or astypes}		n7LW: INTEGER;					{}		oldnumLaserTaxa: integer;		SACWfunction: INTEGER;			{}		ChartTypefunction: INTEGER;	{}		BranchListtop: INTEGER;			{}		BranchListrows: INTEGER;		{}		BranchListlw: INTEGER;			{}		BranchListselected: INTEGER;	{}		BLSWhat: INTEGER; 				{Branch List option for all States - what's shown by branchlist tool}		CWTrees: ChartIntegers;		{}		CWScatterMinMax: INTEGER;	{}		CWChart: INTEGER; 				{Chart Window Chart - current type of Chart being displayed by Chartwindow}		CWView: INTEGER;	{current view in Chartwindow, whether histoview,tableview, etc.}		CWTableTop: INTEGER; 			{Chart Window Table Top - number of Top row in Chartwindow Table}		CWTableRows: INTEGER; 		{Chart Window Rows - number of rows in Chartwindow Table}		CWLW: INTEGER; 					{Chart Window Line Width - height in pixels of a row in the Chartwindow Table}		CLkind: INTEGER;					{ChartLinearData kind - which kind of linear chart to draw}		CMkind: integer;		CWStepsShow: INTEGER;			{what to show in steps chart}		catwid: LONGINT;		selectMode: INTEGER;			{selection mode for selection menu}		phylipversion: integer;		NEXUSdelim: integer;		drawWriteStringLines: longint;		chartTextLines: longint;		fileRefNum, treeFileRefNum: integer;		{CharSetItem: INTEGER;		TaxSetItem: Integer;}{==== font info ====}		TWfont, TWfontsize, TWlw: INTEGER;				{general font for treewindow and associated windows,}																{excluding taxon names}		treetaxafont, treetaxafontsize: INTEGER;			{font for taxa in treewindow}		CWfont, CWfontsize: INTEGER;						{font for ChartWindow}		printOtherFont, printOtherSize: INTEGER;			{font for Print Other...}		TWstyle, spreadstyle, CWstyle, treetaxastyle, printOtherStyle: Style;{===============}		startreadtree, endreadtree, startreadcharttree, endreadcharttree: longint;		translateTable: boolean;		quickTranslate: boolean;		isteps, istepsnative: Longint;					{number of steps in character traced}		NYLENGTH, minSQLength: single;		maxstattrace: integer;			{maximum state in trace }{||||||||||||||  LONGINTs ||||||||||||||}		equivcyclenum: LONGINT;		{}		maxNumberEquivocalCycles: longint; 				treelength: LONGINT;				{}		minTreeLength: LONGINT;		{}		maxTreeLength: LONGINT;		{}		treechangesMIN: LONGINT;		treechangesMAX: LONGINT;		lengthinflate: LONGINT;			{}		ticks: UInt32;					{}		longnum: LONGINT;				{}		oldtime: UInt32;				{}		lasttime: UInt32;				{}		speechpause: LONGINT;			{}		numMScells: LONGINT;			{}		fileLastModified: LONGINT;		{}		treeFileLastModified: LONGINT;	{}		CHUNKpos: LONGINT;				{}		oldTreeSeed: LONGINT;			{stored last random number seed used for randomtrees}		oldrandSeed: LONGINT;			{stored last random number seed used}		OurRandSeed: Longint;			{randomnumber seed for our own procedure}		numFootText: longint;			{number of foottexts}		numFootPict: longint;			{number of footpicts}		numFootSound: longint;			{number of footsounds}		oneswap: boolean;{||||||||||||||  POINTs ||||||||||||||}		sfgetwhere, sfputwhere, DlgOrigin, wh, m1: POINT;		DrawRloc: LongPoint;		abovept, belowpt, cipt, txnumpt, chnumpt, swappt, tearpt: POINT;		tlegpt, chlegpt, palpt: POINT;		messspot: point;		drawTWR: LongRect;				visTWR, maxTWR, minTWR: RECT;		drawEWR, visEWR, maxEWR, minEWR: RECT;		Boxrect, ScrollBoxRect, ScrollDlgRect: RECT;		claspRect, dataBoxB,patternBox: RECT;		treerect, treenameB, charnameB, chlengthB, chlegtypeB, equivB, polyB: RECT;		editorTitleCornerRect, tearrect, TWmessageB: rect;		CWTableBox: rect;		chartbox: rect;		editMessagebox: rect;		categories: array[0..9] of longint; { this stores boundaries of branch lengths shading}		numcats: integer;		minbrlength, maxbrlength: longint;		mincont, maxcont: double;		realcategories: array[0..9] of double;		changesSel, totalChangesSel: ChangesSelPtr;		totalChangesRestricted: boolean;	{totalChangesSel is not full}		changesRestricted: boolean;			{changesSel is not full}		restrictTreeChanges: boolean;		{for Tree Changes, use restriction!}		paletteTitleLineWidth : integer;		pictCreator: OSType;		maxlabel: TreeLabMax;		treeScale: single;			{the scale of drawing trees, applies to both horizontal and vertical}		treeScaleVert: single;			{the height/width ratio of trees in treewindow}		symbols, TWmessage, defaultTWmessage: str32;		prefname: str255;		iofilename: STRINGHANDLE;			{}		treefilename: STRINGHANDLE;			{}		filename: STRINGHANDLE;				{}		treename: STRINGHANDLE;				{}		dsh: STRINGHANDLE;					{}		CWClassName: STRINGHANDLE;		{}		ChartToTypeName: STRINGHANDLE;	{}		ChartToWtName: STRINGHANDLE;		{}		userName, userInstitution: StringHandle;		genzero, genInf: gentype;		tlegStats: tlegArray;		gencode: gencodePtr;		PrintOtherFonts, TWFonts, ChartFonts: fontSet;		RandomMax, RandomFillMax, RandomObservedFillMax, RandomAncMax: integer;		RandomStatesH, RandomFillH, RandomAncH,RandomObservedFillH: RandomArrayHandle;		ExtraTreeFileName: ExtraTFName;		treeblock: ptr; {%%%%%}		twotrees: twoid;{----CharCorrelation parameters---}		actual, firstres, lastres: boolean;		statedgains, statedlosses, maxsample: longint;		exactcount, checkabortoften: boolean;		zeroblack, oneblack, equivblack: boolean;		Compensation: integer;		simulationAncestor: integer;		ci, ri: double;		equivocalPattern, polym, uncert, dashpat, stratpat, upterm: PATTERN;		equivocalPPH, polymPPH, uncertPPH, dashpatPPH, stratpatPPH, uptermPPH: PixPatHandle;		//equivocalPPH: PixPatHandle;		next, fillchar, cr, missing, gap, orsep, andsep, defsep, holdkey, matchchar: CHAR;		previousChar: CHAR;		textsep: CHAR;			{character separating entries in text file}		flashchar: char;		cancelChar: char;		CLkindset: set7;				{set of ChartLinearData kinds to show}		CMkindset: set7;		updateRgn: RgnHandle;		grow1, grow2: SIZE;		resultcode: OSErr;		cursormap: BITMAP;		TWMessIcon: twmessarray;		equates: equatesHandle;		SetPtr15: SetPointer15;		SetPtr31: SetPointer31;		locSetPtr31: SetPointer31;  {used locally within RowColumn procedures FillTaxSts & FillCharacters ONLY}		strect: stBtype;{$IFC DEBUG}		debugfile: text; {$ENDC}		firstTWactivate: boolean;		CMShow: set15;		su, brushset: largestsetchars;		R, ScreenR, subR, subsubR, subRlf, toN, fN, reNR, reN, oldNR: Nptr;		fromN, undofromN, undotoN, DrawR, lastselN, storedN, flashN, BranchListN, cladeN: Nptr;		freqmatrix: distancetype;		ddist: distancetype;		maxdefgen: integer;		whitespace, punctuation, reserved, vacuum: set of char;		curTypes, typesinfile: set255;{|||||||||||||| LINKS |||||||||||||||}	var		PreDeflinks: CHAININT;				{number of predefined links in chain, 1 based}		Userlinks: CHAININT;				{number of userlinks in chain, 1 based}			{therefore, total number of links is PreDefLinks+UserLinks}			{but, as links are numbered from 0, last link is link number PredefLinks+UserLinks-1}		DefaultLink: CHAININT;				{default link in chain, 0 based}		linknumber: CHAININT;				{current link number in chain, 0 based }		oldlinknumber: CHAININT;			{last link number in chain, 0 based }		linkBytes: CHAININT;				{number of bytes taken up by each character in each link}		curLinkNames, chainNames: ChainNameType;		{array of stringhandles to names of chains}		dirtylink: CHAINBOOL;		laser: laserPtr;		newlaser: newLaserPtr;		laserBoxes: LaserBoxesArrayPtr;		extraAAStates: extracodes;		{stores the amino acids that extra AA's 1,2,3,4 correspond to}		probchangeRec: array[0..3, 0..3] of double;		probRecitem: integer;		probTreeitem: integer;		segListenProb: boolean;						extraOverHang: integer;		printRecordH: THPrint;		printRecordSize: LONGINT;		printerOK: BOOLEAN;			{}		printon: BOOLEAN;				{}		printerColorGrayScale: boolean;		printDefaultsSet: boolean;				windowEdgeThickness: integer;		TTPR: TTPRHdl;		TTC: TTCHdl;{TREEWINDOW VARIABLES}{$IFC CARBON}		var TWOrigin: LongPoint;{$ELSEC}		TWOrigin: Point;{$ENDC}		TWmessW, LegTitleW: integer;		Event: EventRecord;			{=== windows ===}		whichWindow: WindowPtr;		tLegWindow, chLegWindow, twmesswindow, ChartWindow: WindowPtr;		treeWindow, BranchListWindow, pictWindow: WindowPtr;{$IFC SCALEWINDOW}		scaleWindow: WindowPtr;{$ENDC}		{editrecord, treerecord, BranchListrecord, commrecord, Chartrecord: WindowRecord;		tLegrecord, chLegrecord, palrecord, twmessrecord, pictRecord: WindowRecord;}{$IFC SCALEWINDOW}		{scaleRecord: WindowRecord;} {$ENDC}		oldfrontW: array[0..numfrontW] of WindowPtr;		numFW: integer;			{number of front windows that are not treewindow locked}		iothermo: DialogPtr;		searchThermo: DialogPtr;		thermo1Window,thermo2Window: DialogPtr;		thermo1Control, thermo2Control: ControlHandle;		equivocalCycleCalculation: boolean;		cancelCheckFreq :integer;		{=== Regions ===}		TWClip, EWClip, oldGlobalClip: RgnHandle;		nodeClip: RgnHandle;		nodetriangle: polyhandle;{=== foot stuff ===}		footH: array[0..maxfoottype] of Handle;		footResType: array[0..maxfoottype] of restype;		numfeet: array[0..maxfoottype] of longint;		footBytes, footBits: array[0..maxfoottype] of SignedByte;  {number of bytes for feet info, after taxa char info}		footResource: array[0..maxfoottype] of boolean;   {true iff foot stored as resource}{=== Handles ===}		chtypH, chstoretypH: Handle;			{stores in expanded form current typeset, and storage typeset}		chstorewtH, chwtH: Handle;				{stores in expanded form current wtset, and storage wtset}		chStorePartitionH, chPartitionH: Handle;		chLenH: Handle;							{stores lengths for each character}		chpLH: Handle;							{stores length due to polymorphism}		chstatesH: Handle;						{stores all states found in all characters}		treedataH, oldtreeH: Handle;		GrowH: Handle;		fixdataH: Handle;		segdataH: Handle;		realBranchLengthsDataH: Handle;		branchLengthSigDigits: integer;					const		realBranchLengthDefault =0.01;			var		ChartMatrixData: CMDPtrArray;		ChartLinearData: CLDHandleArray;		strCHUNKs: strCHBArray;		{array of handles to CHUNKHandleBlock for wt,type,tree chains}		chunkPtr: Ptr;					{pointer into a CHUNK}		taxonCHUNKs: Handle;			{handle to CHUNKHandleBlock for basic taxon info}		taxstsCHUNKs: Handle;			{handle to CHUNKHandleBlock for taxon states}				chCHUNKs: Handle;				{handle to CHUNKHandleBlock for basic character info}		statenamesCHUNKs: Handle;			{handle to CHUNKHandleBlock for state names info}		statenamesCHUNKsBU: Handle;			{handle to CHUNKHandleBlock for backup state names info}		statenamesHdl: Handle;		AminoAcidNamesHdl: Handle;				typeCHUNKs: Handle;		typeCHUNKsBU: Handle;		typeHdl: typeHandle;{$IFC SETBRANCHLENGTHS}		setBranchLengths: boolean;		editingBranchLengths: boolean;{$ENDC}		saveAmbiguities: BOOLEAN;		{true iff save a line summarizing all states in line using nucleotide ambiguity codes}		saveNonGaps: BOOLEAN;   {for version 4 - always true in version 3}		autoCharNumberRefSequence: integer;		autoCharNumberByRef: boolean;{=== scrolls ===}		 vTWScroll, hTWScroll, whichControl, notescroll: ControlRef;		tLegScroll, chLegScroll, databoxScroll, CWScroll, vPICTScroll, hPICTScroll, histoScroll: ControlRef;{=== cursors ===}		clasper, linkcurs: Cursor;		polyRealcurs, polyUnccurs: Cursor;		newcolcurs, newrowcurs, closedscissors: Cursor;		oldtreecurs, DnstsCurs, MinLenCurs, StatesCurs: Cursor;		downpasscurs, uppasscurs, triplepasscurs: Cursor;		downscissors, closeddownscissors, downcollapse: Cursor;		ibeam, clockCursor: Cursor;		cyclecurs: cyclecursors;		cyclecursnum: integer;		KCHRPtr: Ptr;		hasGetEnvirons: boolean;{=== menus ===}		TWMBar, EWMBar, CloseFileMBar, NoWMBar, EquivMBar, ChartMBar: Handle;		SimpleWMBar: Handle;		dlogFontMHdl, dlogStyleMHdl, dlogSizeMHdl: MenuHandle;		dlogImportTaxaMHdl: MenuHandle;		AppleMHdl, FileMHdl, EditMHdl, TreeMHdl, FontMHdl: MenuHandle;		TraceMHdl, {AssumpMHdl, }EWDisplayMHdl, TWDisplayMHdl, ChartDisplayMHdl,GDisplayMHdl: MenuHandle;		ExpFileMHdl, ExpTreeMHdl{, DataFormMHdl}: MenuHandle;		EquivMHdl, NewChartMHdl, ChartMHdl, StyleMHdl: MenuHandle;		SizeMHdl, EdUtilitiesMHdl: menuHandle;		TypeMHdl, IncExcMHdl, CodingMHdl: MenuHandle;		SimpleSelectMHdl: MenuHandle;		WeightMHdl: MenuHandle;		CharPartMHdl: MenuHandle;		CharPartListMHdl: MenuHandle;		SaveOtherMHdl: MenuHandle;		PrintOtherMHdl: MenuHandle;		ExpDelMHdl: MenuHandle;		ImpFileMHdl: MenuHandle;		SaveOptionsMHdl: MenuHandle;		CalcMHdl: MenuHandle;		ShowMHdl: MenuHandle;		CopySpecialMHdl: MenuHandle;		WindowsMHdl: MenuHandle;		FindMHdl: MenuHandle;{$IFC DEBUG}{these are global variables strictly for use in debugging}		xSignedByte1, xSignedByte2: SignedByte;		xHandle1, xHandle2: Handle;		xPtr1, xPtr2: Ptr;		xInt1, xInt2: integer;		xLongint1, xLongint2: integer;		xBoolean1, xBoolean2: boolean;		xSet1, xSet2: LargestSetchars;{$ENDC}{$IFC COLORTICKS}	const		ticksIndexColorLevels = 10;		TicksIndexPatLevels = 4;				colorTicksNone= 0;		colorTicksIndex = 1;		colorTicksCodPos = 2;		colorTicksCharSet = 3;		colorTicksTiTv = 4;		colorTicksPartition = 5;	var		colorTicksByIndex: boolean;		colorTicksIndexClass: integer;		colorTicksClass: integer;		highValueColor, lowValueColor, highestValueColor: RGBColor;		colorTicksBarWidth : integer;		colorTicksMinSpaceBetween: integer;		colorTicksFramed : boolean; {$ENDC}		showTickClass: boolean;		ticksAutoHeighten: boolean;		ticksNoNames: boolean;			{if true, then don't write char numbers or names}		ticksSideNames: boolean;		{if true, then write stuff sideways}		ticksTextBox: boolean;			{if true, then write all char in one box}		ticksShowReversals: boolean;		ticksShowUnique: boolean;		mayHaveAVBug: boolean;	const		punct304 = [',', ';', '=', '*', '\'];		punct305 = [',', ';', '=', '*', '(', ')', ':', '/', '\', '"', '{', '}', ']', '[', '`', '-', '+', '<', '>', '~', '^'];		newpunct2 = ['(', ')', ':', '/', '\', '"', '{', '}', ']', '[', '`', '-', '+', '<', '>', '~', '^'];		newpunct = ['+', '`', '<', '>'];	var		useOldPunct, useVeryOldPunct: boolean;					{29Augе  	var		WorkingDirectoryNumber: INTEGER;						treeWorkingDirectoryNumber: INTEGER;				ioWorkingDirectoryNumber: INTEGER;			}	const		maccladeFDI = 0;		preferencesFDI = 1;		systemFDI = 2;		dataFileFDI = 3;		treeFileFDI = 4;		extraTreeFile1FDI = 5;		extraTreeFile2FDI = 6;		chartCalcFileFDI = 7;		extraIOFileFDI = 8;		{resourcesFileFDI = 9;  for file that stores pict resources for current data file}		readFileFDI = 10;		writeFileFDI = 11;		betaFileFDI = 12;		{		addressesFileFDI = 12;}		maxFDI = 12;   {maximum file directory information blocks}				kInitialReadPos = -1;					type		fileDirInfoRec = record				fs: FSSpec;				rfFileNum: integer;				dfFileNum: integer;			end;		fileDirInfoArray = array[0..maxFDI] of fileDirInfoRec;		fileDirInfoPtr = ^fileDirInfoArray;	var		FDI: fileDirInfoPtr;		ioFileFDI, pictResFileFDI : integer;{========  Universal Proc Proc ========}	var		ScrollInfoUpDownUPP: UniversalProcPtr;		ScrollCWUpDownUPP: UniversalProcPtr;  {in ChartWindow}		ScrollSpreadUpDownUPP: UniversalProcPtr;  {in EditControl}		ScrollLegUpDownUPP: UniversalProcPtr;  {in MouseInTree}		ScrollN7UpDownUPP: UniversalProcPtr;  {in N7On}		ScrollTreeUpDownUPP: UniversalProcPtr;  {in ScrollTree}		ScrollStatesUpDownUPP: UniversalProcPtr;  {in StatesWindow}		ScrollTextUpDownUPP: UniversalProcPtr;				UniversalDLOGFilterUPP: UniversalProcPtr;				ScrollContinuousUpDownUPP: UniversalProcPtr;  {ContinuousSBar}		{ScrollHelpUpDownUPP: UniversalProcPtr;}  {ScrollDlgUpDown}		ScrollTypeUpDownUPP: UniversalProcPtr;  {doTypeScroll}				readBufferCurrentPositionPtr: ptr;	{pointer to position within reading buffer}		writeBufferCurrentPositionPtr: ptr;	{pointer to position within writing buffer}		readBufferLength, writeBufferLength: LONGINT;	{}		readBufferBasePtr, writeBufferBasePtr: Ptr;	{pointer to base of block of memory of reading buffer}		readBufferEndPtr, writeBufferEndPtr: Ptr;		{}		readMemoryBuffer: Ptr;		readMemoryBufferSize: longint;		mcFileLength: LONGINT;				{}		fpos: LONGINT;					{}		startBlockPos: longint;			{fpos at start of block}		StartExclam: LONGINT;			{}		EndExclam: LONGINT;			{}		starttokensearch: LONGINT;		{}					type		nucleotidePatternKeyRecord = array [0..maxDNAstate] of signedByte;		nucleotidePatternKeyPtr = ^nucleotidePatternKeyRecord;		proteinPatternKeyRecord = array[0..maxproteinstate] of signedByte;		proteinPatternKeyPtr = ^proteinPatternKeyRecord;		nucleotideColorKeyType = array [0..maxDNAstate] of RGBColor;		nucleotideColorKeyPtr = ^nucleotideColorKeyType;		proteinColorKeyRecord = array[0..maxproteinstate] of RGBColor;		proteinColorKeyPtr = ^proteinColorKeyRecord;		pattype = array[0..31] of PATTERN;		patkeytype = array[2..absmaxnumstates, 0..absmaxnumstates] of signedByte;		patkeyPtr = ^patkeytype;		colorkeytype = array[2..absmaxnumstates, 0..absmaxnumstates] of RGBColor;		colorkeyPtr = ^colorkeytype;		sumcolortype = array[0..maxchangesshown] of RGBColor;		sumcolorPtr = ^sumcolortype;		sumPattype = array[0..maxchangesshown] of signedByte;		sumPatPtr = ^sumpattype;	var{=== colors and patterns ===}		pat: pattype;		patkey: patkeyPtr;		colorkey: colorkeyPtr;		summarycolors: sumcolorPtr;		summarypat: sumpatPtr;		usecolor, defcolor, blackRGB, whiteRGB, histocolor, brushcolor, gridcolor, faintTextRGB: RGBColor;		redRGB, blueRGB, greenRGB, polyMorphColor: RGBColor;		codeNotSetRGB: RGBColor;		purRGB, pyrRGB: RGBColor;		defaultPartitionRGB: RGBColor;{$IFC COLORCELLS}		singleColorCell: RGBColor;{$ENDC}		nucleotideColorKey: nucleotideColorKeyPtr;		proteinColorKey: proteinColorKeyPtr;		nucleotidePatternKey: nucleotidePatternKeyPtr;		proteinPatternKey: proteinPatternKeyPtr;			const{------}		useOldDataBackTinge = -1;		notinge = 0;		blueTinge = 1;		greenTinge = 2;		brownTinge = 3;		redTinge = 4;		yellowTinge = 5;		grayTinge = 6;		infoCurrentTinge=7;{========================== Lists ==================================}const		noinfo = 0;		charInfo = 1;		taxinfo = 2;		treeinfo = 3;		typeinfo = 4;		typesetinfo = 5;		wtsetinfo = 6;		exsetinfo = 7;		charsetinfo = 8;		taxsetinfo = 9;		treefileinfo = 10;		nexusblockinfo=11;{$IFC CHARPARTITIONS}		charpartinfo = 12;		charpartnameinfo = 13;		numinfoWindows = 13;  {///}{$ELSEC}		numinfoWindows = 11;  {///}{$ENDC}			{remember that for the selection menu, there are arrays of integers storing info about }{the position of the save set item, etc.  the range of these arrays is keyed in to }{numinfoWindows.  E.g.   changeSetObject = numinfoWindows + 1;}		notAColumn = -1;		infoName = 0;		{---- NexusBlockInfo table columnID's ----}		NexusBlockInfoForeign=1;		NexusBlockInfoWithForeignLines = 2;		NexusBlockInfoSize=3;		NexusBlockInfoEditable = 4;		NexusBlockInfoWillWrite = 5;		NexusBlockInfoTitle = 6;		NexusBlockInfoLinkText = 7;{---- CharInfo table columnID's ----}		CharInfoExpand = 1;		CharInfoIncExc = 2;		CharInfoCodPos = 3;		CharInfoTypes = 4;		CharInfoWeights = 5;		CharInfoStates = 6;		CharInfoMin = 7;		CharInfoSteps = 8;		CharInfoMax = 9;		CharInfoCI = 10;		CharInfoRI = 11;		CharInfoRC = 12;		CharInfoChgs = 13;		CharInfoPartition = 14;		CharInfoCharSet = 15;		CharInfoMissing = 16;		CharInfoGaps = 17;		CharInfoMPRs = 18;		CharInfoPolymorphisms = 19;		CharInfoUncertainty = 20;{---- TaxInfo table columnID's ----}		TaxInfoIncExc = 1;		TaxInfoMissing = 5;		TaxInfoGaps = 13;		TaxInfoSeqLength=14;		TaxInfoA=15;		TaxInfoC=16;		TaxInfoG=17;		TaxInfoT=18;		TaxInfoAT=19;		TaxInfoPartition=20;		TaxInfoStopCodons = 21;		TaxInfoFirstBase = 22;		TaxInfoLastBase = 23;		TaxInfoPartTriplets = 24;		TaxInfoLowerCase = 25;		TaxInfoUncertainty = 26;		TaxInfoPolymorphism = 27;		{TaxInfoRank = 2;		TaxInfoIncertaeSedis = 3;		TaxInfoNetLinks = 4;		TaxInfoParaphyletic = 6;		TaxInfoExtinct = 7;		TaxInfoAuthor = 8;		TaxInfoWriteTT = 9;		TaxTOLFigure = 10;		TaxInfoTOLItems = 11;		TaxInfoTOLLinks = 12;}{---- TreeInfo table columnID's ----}		TreeInfoExpand = 1;		TreeInfoIncExc = 2;		TreeInfoNumTaxa = 3;		TreeInfoPoly = 4;		TreeInfoFixAnc = 5;{---- TypeInfo table columnID's ----}		TypeInfoExpand = 1;		TypeInfoCategory = 2;		TypeInfoReal = 3;		TypeInfoMaxStates = 4;		TypeInfoDirected = 5;		TypeInfoInUse = 6;		{---- TypeInfo table columnID's ----}		TypeSetInfoDirected = 1;		TypeSetInfoUserDefined = 2;		{---- WtSetInfo table columnID's ----}		WtSetInfoMinWt = 1;		WtSetInfoMaxWt = 2;		WtSetInfoReal = 3;{---- CharSetInfo table columnID's ----}		CharSetInfoNumberChars = 1;		{---- TaxSetInfo table columnID's ----}		TaxSetInfoNumberTaxa = 1;		{---- ExSetInfo table columnID's ----}		ExSetInfoNumberChars = 1;		{---- CharPartInfo table columnID's ----}		CharPartInfoNumParts = 1;{---- CharPartNameInfo table columnID's ----}		CharPartNameInfoColor = 1;		{		valueIsInteger=0;		valueIsLongint=1;		valueIsSingle = 2;		valueIsString = 3;		valueIsBoolean = 4;		valueIsDouble = 5;}	type		infoWindowType = array[1..numInfoWindows] of WindowPtr;		{infoWindowRecType = array[1..numInfoWindows] of WindowRecord;}		infoWindowBooleans = array[1..numInfoWindows] of Boolean;		infoWindowRects = array[1..numInfoWindows] of Rect;		InfoStr32Type = array[1..numInfoWindows] of str32;		infoWindowIntegers = array[1..numInfoWindows] of Integer;		infoWindowLongint = array[1..numInfoWindows] of longint;		infoWindowStyleType = array[1..numInfoWindows] of Style;		infoWindowControlHandles = array[1..numInfoWindows] of ControlRef;		infoWindowHandles = array[1..numinfoWindows] of Handle;		infoTEType = array[1..numinfoWindows] of TEHandle;{infoSetsMenuHandle = array[1..numinfoWindows] of MenuHandle;}	const		columnIsString = 0;		columnIsInteger = 1;		columnIsLongint = 2;		columnIsDouble = 3;		columnIsSingle = 4;		columnIsBoolean = 5;		columnIsColor = 6;		columnIsPicture = 7;			type		{ListWindowPublicRecord = record				objectName: str32;				selected: BOOLEAN;				open: BOOLEAN;				editorOpen: BOOLEAN;				locked: boolean;			end;		ListWindowPublicRecordArray = array[1..numInfoWindows] of ListWindowPublicRecord;		ListWindowPublicRecordArrayPtr = ^ListWindowPublicRecordArray;}		infoWindowColumnPtr = ^infoWindowColumnType;		infoWindowColumnType = record				nextLink, prevLink: infoWindowColumnPtr;				proc: ProcPtr;				columnID: longint;				remote: boolean;				isString: boolean;				columnType: integer;				show: boolean;				menu: boolean;				canDoMagicWand: boolean;				width: integer;				left: integer;				right: integer;				title: str15;			end;		InfoWindowColumns = array[1..numinfoWindows] of infoWindowColumnPtr;		{ListWindowRecord = record				window: WindowPtr;				font, fontsize: integer;				maxNameWidth: integer;				editorLineWidth: integer;				top, left: longint;				rows: longint;				maxColumns: integer;				infoTE: TEHandle;				NameStart, NameEnd: integer;				editRow: longint;				columns: infoWindowColumnPtr;				infoScroll, infoHScroll: ControlRef;				wasOpen: BOOLEAN;				dirtyNames: BOOLEAN;			end;		ListWindowRecordArray = array[1..numInfoWindows] of ListWindowRecord;		ListWindowRecordArrayPtr = ^ListWindowRecordArray;}	var		{listWindow: ListWindowRecordArrayPtr;		listWindowPublic: ListWindowPublicRecordArrayPtr;}				infoCol: InfoWindowColumns;		infoWindow: infoWindowType;		{infoWindowRecord: infoWindowRecType;}		{infoWSel: infoWindowBooleans;}		infoOpen: infoWindowBooleans;		infoSomeSelected: infoWindowBooleans;		infoWithButtons: infoWindowBooleans;		infoWithToolRow: infoWindowBooleans;		infoEditRow: infoWindowLongint;		infoWasOpen, infoHasBeenOpen, infoDirtyNames, infoEditing: infoWindowBooleans;		infoFont, infoFontSize, infoFontDescent, infoFontAscent, infoMaxNameWidth: infoWindowIntegers;		infoLW: infoWindowIntegers;		infoTop: infoWindowLongint;		infoBottom: infoWindowLongint;		infoLeft: infoWindowIntegers;		infoRows: infoWindowLongint;		infoDrawRect: infoWindowRects;		infoAllCellsDrawRect: infoWindowRects;		infoStyle: infoWindowStyleType;		infoScroll, infoHScroll: infoWindowControlHandles;		infoColumnsMax: infoWindowIntegers;		infoTE: InfoTEType;		infoNameStart, infoNameEnd: infoWindowIntegers;		infoWindowButton: infoWindowControlHandles;		infoObjectName: InfoStr32Type;		infoLocked: infoWindowBooleans;//		infoUseButtonBox: InfoWindowRects;		numInfoWindowsThatHaveBeenOpen: integer;				taxInfoConsiderAllCharacters: boolean;		taxInfoShowNucFrequencies: boolean;		taxInfoShowStopCodons: boolean;		taxInfoShowFirstBase: boolean;		taxInfoShowLastBase: boolean;		taxInfoShowLowerCase: boolean;		taxInfoShowUncertainty: boolean;		taxInfoShowPolymorphism: boolean;		taxInfoShowPartTriplets: boolean;		charInfoShowMissing: boolean;		charInfoShowGaps: boolean;		charInfoShowMPRs: boolean;		charInfoShowPolymorphisms: boolean;		charInfoShowUncertainty: boolean;		charInfoShowPartition: boolean;		nexusBlockInfoShowTitleLink: boolean;		InfoMHdl: MenuHandle;		infoUndoH: infoWindowHandles;			const		numInfoTools = 4;				infoScissorsT=0;		infoWandT = 1;		infoSortDescendingT = 2;		infoSortAscendingT = 3;		infoArrowT = 4;			type		infoToolRecord = record				cursorID: integer;				hasOptionCursor: boolean;				optionCursorID: integer;				hasControlCursor: boolean;				controlCursorID: integer;				enabled: boolean;				R: RECT;			end;		infoToolArray = array[1..numinfoWindows,0..numInfoTools] of infoToolRecord;		infoToolPtr = ^infoToolArray;			var		infoTools : infoToolPtr;		currentInfoTool: infoWindowIntegers;		{##########  STATES WINDOW ##########}	const		statesWindowDefaultRows=10;	var		statesWindow: WindowPtr;		{statesWindowRec: WindowRecord;}		statesWindowOpen: boolean;		statesWindowWasOpen: boolean;		statesWindowLineWidth: integer;		statesWindowTitleWidth: integer;		statesWindowRows: integer;		statesWindowTop: integer;		statesWindowHScroll, statesWindowVScroll: ControlRef;		statesTE: TEHandle;		statesSelected: boolean;		statesSelectedTop, stateSelectedBottom: integer;		statesWindowCharacter: integer;		statesEditing: boolean;		statesFont, statesFontSize: integer;		statesSymbolWidth: integer;		statesNameStart: integer;		statesMaxRows: integer;		statesSymbolIsSelected: boolean;		statesSymbolSelected: integer;		statesFontDescent,statesFontAscent: integer;				statesClipboardH: Handle;		statesUndoH: Handle;		symbolsUndoSH: StringHandle;		symbolEditing: boolean;		symbolSelected: integer;		statesSelection: array[0..absmaxstate] of boolean;			const		{changeSetObject = numinfoWindows + 1;}		{stateSetObject = numinfoWindows + 2;}		maxSelectObjects = numinfoWindows;  {if ever these numbers become different, make sure you check over whichObject/whichInfo use in MenuUtil}		SelectAllItem = 1;		SelectNoneItem = 2;		SelectReverseItem = 3;		LastPreDefinedSelectItem = 3;	type		SelectMenuIntegers = array[1..maxSelectObjects] of Integer;	var		InfoSelectMHdl: MenuHandle;		charSelectMHdl: MenuHandle;		InfoMoveMHdl: MenuHandle;		FirstUserSetMenuItem: SelectMenuIntegers;   {first user-defined set in selection menu}		RenameDeleteSetMenuItem: SelectMenuIntegers;		{menu item for Rename-Delete Set}		SaveSetItem: SelectMenuIntegers;		{menu item for Store Set}	var		ScreenRectangle:Rect;		blackpattern: pattern;		whitepattern: pattern;		graypattern: pattern;		ltgraypattern: pattern;{============ TOOLS  ===========}	const		numToolPalettes = 2;		treeTools = 1;		editorTools = 2;		toolCellWidth = 28;		arrowT = 0;		scissorsT = 1;		ancT =2;		rerootT = 3; 		SwapT = 4;				collapseT = 5;		collapseallT = 6;		ladderT = 7;		rotateT = 8;		polyflipT = 9;				paintT = 10;		turpentineT = 11;		queryT = 12;		traceTickT = 13;		statsTestT = 14;				handT = 15;		expandT = 16;		evolveSegmentsT = 17;		treeWandT = 18;		treePictureT = 19;		numTreeTools = 19;   {remember, 0-based}				editorArrowT = 0;		editorSelectionT = 1;		magicWandT = 2;		selectToEndT = 3;		editorScissorsT =4;		stampPasteT = 5;		autoAlignT = 6;		blockMoveT = 7;		selectedBlockMoveT =8;		splitBlockT = 9;		{splitMultiBlockT = 10;}		splitBlockOtherT =10;		closeGapsT =11;		eyedropperT = 12;		editorPaintBrushT = 13;		editorBucketT = 14;		popUpStatesT =15;		showPictureT = 16;		editorSortT = 17;				numEditorTools = 17;				maxNumTools = 19;		arrowID = 0;		diamondID = 257;		emptybrushID = 143;		fullbrushID = 148;		handcursID = 139;		shrinkMagID = 2720;		paletteMessageLineWidth = 14;		paletteMessageExtraLineWidth=16;	type		twocursors = record				H: CursHandle;				colorH: CCrsrHandle;			end;		tooltype = packed record				curs: twocursors;				optionCursID: integer;				cursID: integer;				transposedCursorID: integer;				transposedOptionCursorID : integer;				R: RECT;  								hasOptionCurs: boolean;				enabled: boolean;				behaveAsArrowOnRCNumbers: boolean;				behaveAsArrowOnCharacterNumbers: boolean;				behaveAsArrowOnTaxonNumbers: boolean;				worksInDataCells : boolean;				worksInNameCells: boolean;				worksOnTicks: boolean;				onlyInEditorMatrix: boolean;				hasTransposedCursor: boolean;				hasPopUpMenu: boolean;			end;		toolarray = array[1..numToolPalettes,0..maxNumTools] of tooltype;		toolarrayPtr = ^toolarray;			const		horizontalToolsTextMinimum = 3;	var		tool: toolarrayPtr;		{checkTools: boolean;}				handcurs, arrowcurs, fullbrush, emptybrush, diamond: twocursors;	type		toolPaletteWindowArray = array [1..numToolPalettes] of WindowPtr;		toolPaletteIntegerArray = array [1..numToolPalettes] of integer;		toolPaletteBooleanArray = array [1..numToolPalettes] of boolean;		toolPaletteRectArray = array [1..numToolPalettes] of Rect;		toolPalettePointArray = array [1..numToolPalettes] of Point;			var		toolPaletteWindow: toolPaletteWindowArray;		currentTool: toolPaletteIntegerArray;		lastTool: toolPaletteIntegerArray;		verticalTools, horizontalTools: toolPaletteIntegerArray;		numPaletteMessageLines: toolPaletteIntegerArray;		showToolPaletteMessageLine: toolPaletteBooleanArray;		showToolPaletteExtraMessageLine: toolPaletteBooleanArray;		numTools: toolPaletteIntegerArray;		paletteMessageBox, paletteExtraMessageBox: toolPaletteRectArray;		toolPaletteOpen: toolPaletteBooleanArray;		toolPaletteWasOpen: toolPaletteBooleanArray;		firstToolCursorID: toolPaletteIntegerArray;		paletteMessageWidth: toolPaletteIntegerArray;		toolPaletteHasExtraMessage: toolPaletteBooleanArray;		toolPaletteFirstAppearance: toolPaletteBooleanArray;		toolPaletteOpenOnce: toolPaletteBooleanArray;		toolPalettePositionRead: toolPaletteBooleanArray;		toolPalettePoint: toolPalettePointArray;		paletteGrowBox: toolPaletteRectArray;				selectToEndMode: integer;		{selectToEndSelectsToEnd: boolean;}		selectToEndIncludeTerminalGaps: boolean;				editorScissorsShiftsToStart: boolean;		editorScissorsWarn: boolean;				rerootToolRootsDrawR: boolean;		scissorsCutAbove: boolean;		collapseAllCollapsesAbove: boolean;				editorSortAscending: boolean;				swapAbove: boolean;		fancySearch: boolean;		QuickestDescent: boolean;		showNewTreeWhileSearching: boolean;		searchForLongTrees: boolean;		queryToolsPopUp: boolean;		traceTickToolTemporary: boolean;				ladderizeRight: boolean;		paintToolTriesAllStates: boolean;				multipleSwaps: boolean;				searchAncestorAbove: boolean;		ancestorToolMode: integer;		searchAncestorReps: integer;		searchAncestorRandomNumber: integer;		searchAncestorStartWithAncestors: boolean;		searchAncestorReportReps: boolean;		searchAncestorSeed: longint;					closeGapsTowardEnd: boolean;		// closeGapsCollapseAllGaps: boolean;		closeGapsMode: integer;		alignTreatsTerminalMissingAsGaps: boolean;				blockMovePushBoundaries: boolean;		blockMoveAccumulate: boolean;		blockMoveEntireSequence: boolean;		blockMoveSplitBlockToo: boolean;				magicWandEntireSequence: boolean;		magicWandMode: integer;		editorMagicWandExactMatch: boolean;		selectedBlockMoveMode: integer;	{	splitMode: integer;		splitOtherMode: integer;}				splitBlockEntireSequence: boolean;		splitBlockPushBoundaries: boolean;		splitBlockMultiSequence: boolean;				stampToolMode: integer;				showPicturesMode: integer;				evolveSegmentsToolMode: integer;		evolveSegmentsAreReal: boolean;				paintBucketMode: integer;		paintBucketFillCellsWithState: largestSetChars;		paintBucketFillFraction: integer;		paintBucketPaint: largestsetchars;				editorToolsTreatMissingAsGaps: boolean;				popUpEnterStates : boolean;				splitTaxonStart, splitTaxonEnd: integer;		splitCharacter: integer;			const		defaultFillFraction = 1000;				showPicturesWindowMode=0;		showPicturesPopUpMode=1;				stampToolMultiCellMode=0;		stampToolToFootMode=1;				selectToLastCharacterMode=0;		selectToFirstCharacterMode=1;		selectToLastTaxonMode=2;		selectToFirstTaxonMode=3;				closeGapsNormalMode=0;		closeGapsCloseAllMode = 1;		closeGapsSingleBaseMode=2;		closeGapsExactlyOneBaseMode = 3;				magicWandNormalMode=0;		magicWandMixedBlockMode=1;		magicWandExtendTaxaBlockMode=2;		magicWandExtendCharactersBlockMode=3;				ancestorToolNormalMode =0;		ancestorToolSearchHeuristicMode = 1;		ancestorToolSearchAllMode = 2;			{	splitNormalMode=0;		splitMultiTaxaMode=1;				splitOtherNormalMode = 0;		splitOtherMultiTaxaMode = 1;}				selectedBlockMoveNormalMode=0;		selectedBlockMoveSpecifiedMode=3;		selectedBlockMoveClickMode=4;				evolveSegmentsNormalMode=0;		evolveSegmentsAllOneMode=1;		evolveSegmentsRandomMode=2;		evolveSegmentsUltraMetricMode=3;				paintBucketNormalMode=0;		paintBucketRandomMode=1;		paintBucketFillObservedStatesMode=2;		paintBucketFillObservedFreqMode=3;				maxBranchLength = 9;{========= TextWindows ========}	const		notAText = 0;		aboutFileText = 1;		aboutTreesText = 2;		aboutTreeFileText = 3;		NexusBlockText = 4;				numTextWindows = 4;	type		textWindowArray = Array [1..numTextWindows] of WindowPtr;		textWindowInfoRecord = record				TE: TEHandle;				H: Handle;				open, wasOpen: boolean;				hasBeenOpen: boolean;				hasCommentLine : boolean;				scroll: ControlRef;				origin: integer;				position: integer;				box: rect;				rows: integer;				rowWidth: integer;				font, size: integer;				face: style;				name: str255;			end;		textWindowInfoPtr = ^textWindowInfoRecord;		textWindowInfoArray = Array [1..numTextWindows] of textWindowInfoPtr;	const		numline = 26;		maxcolname = 100;		editorGridThickness = 1;		editorExtraGridThickness = 1;		defaultEditorLineSensitivity = 4;	var		textWindowInfo: textWindowInfoArray;		textWindow: textWindowArray;		curTextH: Handle;		numTextWindowsG: integer;		numTextWindowsThatHaveBeenOpen: integer;		colorSetCells: BOOLEAN;		{if true, then in spreadsheet color only those cells matching colorCellSet}		colorCellSet: largestsetchars;	{if a spreadsheet cell has this setchars, color it}		colorCodPosEditor: BOOLEAN;		codonPositionsChanged: boolean;				charPartitionsChanged: boolean;				editorColorCellSetToMatch: largestsetchars;		editorColorCellSetExactMatch: boolean;		editorWindowTop: integer;			const		editorColorCellsOff=0;		editorColorCellsState=1;   		editorColorCellsMatchFirst=2;		editorColorCellsMatchStateSet=3;		editorColorCellsAAState=4;		editorColorCellsPurPyr=5;				editorColorPartitionOff=0;		editorColorPartitionCodPos=1;		editorColorPartitionPartition=2;			var		editorColorCellsMode: integer;		{editorColorPartitionsMode: integer;}		editorPartitionToColor: integer;		editorColorPartitionTitle: boolean;		editorColorPartitionCells: boolean;		editorColorPartitionNumbers: boolean;		editorColorCodPosTitle: boolean;		editorColorCodPosCells: boolean;		editorColorCodPosNumbers: boolean;		editorShadeCharSetTitle: boolean;		editorShadeCharSetCells: boolean;		editorShadeCharSetNumbers: boolean;		editorShadeCharSetLighter: boolean;		editorColorCellsByFillRect: boolean;		editorColorCellsDimLowerCase: boolean;		findSequenceMatchMustBeExact: boolean;		findSequenceRespectCase: boolean;			const		flashOff = 0;		flashFindSequence=1;		flashNonCodons=2;		flashRNAReverseComplement = 3;	var		editorFlashMode: integer;		flashRNARCFirstChar: integer;		flashRNARCLastChar: integer;		flashRNARCFirstTax: integer;		flashRNARCLastTax: integer;				flashRNARevCompNumMismatches: integer;		flashRNARevCompIgnoreGaps: boolean;		flashFindIgnoreGaps: boolean;		findNumMismatches: integer;						editorOpen: BOOLEAN;				{true iff editorWindow is visible}		editorLineWidth: INTEGER;						{editor linewidth for data - height of cell in data editor}		editorTitleLineWidth: INTEGER;						{title linewidth for editor - height of column title cells in data editor}		editorTitlesWidth: INTEGER;				{total title width in editor - basically, position of bottom of colum title in}											{data editor}		editorLineSensitivity: integer;						editorHScroll, editorVScroll: ControlRef;		editorRowNameEnd: INTEGER;			{position of right side of row name cell in data editor}		editorRowNameStart: INTEGER;		{position of left side of row name cell in data editor}		editorRowNameWidth: INTEGER;		{width of row name cell in data editor (editorRowNameEnd-editorRowNameStart)}		editorMinRowNameEnd: integer;		notewidth: INTEGER;				{width (that is, height) of footnote bar in editor}		editorColumnWidth: INTEGER;				{width of columns in data editor}		editorFont, editorFontSize: INTEGER;				{font for data editor}		editorFontDescent, editorFontAscent: INTEGER;				{}		oldDataBack: RGBColor;		standardBack: RGBColor;		editorEdgeColor: RGBColor;		editorMatrixRect: RECT;					{rectangle in editor in which data cells are drawn  - used to be dRect}		editorDataCellsRect: Rect;		editorBoundaryRect: RECT;				{maximum size of editorMatrixRect; = editorMatrixRect unless edges of matrix are visible}		editorShimmerRect: Rect;		editorFootNoteRect: Rect;		editorSelectionRect: Rect;		editorCellTE, noteTE: TEHandle;		editorWindow: WindowPtr;		editorTransposed: BOOLEAN;				{true if rows are characters}		editorSelected: BOOLEAN;  				{true if a cell is selected}		editorSelectionTopLeft, editorSelectionBotRight: Point;      {selected cell}		editorOrigin: Point;  				{cell currently in upper left corner of spreadsheet}		editorColumns: integer;		editorRows: integer;		editorTotalColumns: integer;		editorTotalRows: integer;		editorRowNumbersRight: integer;				editorPaintReferenceTaxon: integer;				editorShowAAwithDNA: boolean;		editorColorAAwithDNA: boolean;		editorUseTripletColor: boolean;		editorFrequentRedraw: boolean;		editorShowCellSymbol: boolean;				editorShowFullStateNames: boolean;		editorShowIUPACSymbols: boolean;								editorMarkGC: boolean;		editorMatchAgainstConsensus: boolean;						editorMode: integer;				dataTabRightBox, dataTabDownBox: rect;			const		AllShadeCharSet=1;		NoneShadeCharSet=2;		AllIncludedShadeCharSet=3;		AllExcludedShadeCharSet=4;		AllInvariantShadeCharSet=5;		AllGapsMissingShadeCharSet=6;		Every10thShadeCharSet=7;			AllDataTypesStandardShadeCharSet=7;  {D3}		ProteinCodingShadeCharSet=8;		NonCodingShadeCharSet=9;		EveryFirstShadeCharSet=10;		EverySecondShadeCharSet=11;		EveryThirdShadeCharSet=12;			NucleotideStandardShadeCharSet=12;				defaultCharSetToShade= NoneShadeCharSet;	var		editorDimCharacterSet: boolean;		editorCharacterSetToShade: integer;		FirstUserShadeCharSet: integer;		LastUserShadeCharSet: integer;		editorDimDNAwithAA: boolean;		DimDNAwithAAItem: integer;  {menu item for this}		sameStateColorsForAllCharacters: boolean;		useMOSForSameColorsForAll: boolean;		const		consensusBoundaryLineThickness = 3;		AllTaxSet=0;		defaultTaxSetForConsensus=AllTaxSet;			type		consensusPtr= ^consensusRecord;		consensusRecord = record				prev,next: consensusPtr;				majorityPercent: integer;				modalFullFreq,modalFreq: integer;				taxSet: integer;				majorityFraction: single;				exactMatch: boolean;				show: boolean;				dimProportionalToNonGaps: boolean;				dimProportionalToFreq: boolean;				showOnlyFullMajority: boolean;				selected: boolean;				dontShowTies: boolean;				showModalFreqOnMove: boolean;				{				allTies: LargestSetChars; 				areTies: boolean; 				maxFreq,numValues: integer}			end;	var		editorConsensus: consensusPtr;		editorShowConsensusSequences: boolean;		editorNumConsensusSequences: integer;		editorConsensusTaxSet: integer;	type		charSetEditorRowPtr= ^charSetEditorRowRecord;		charSetEditorRowRecord = record				prev,next: charSetEditorRowPtr;				charSetNumber: integer;				charSetName: str255;				selected: boolean;			end;	var		editorCharSetRow: charSetEditorRowPtr;		editorShowCharSetRows: boolean;		editorNumCharSetRows: integer;		editorNumExtraRows: integer;		editorFirstRow, editorFirstColumn: integer;		editorFirstRowTop: integer;		{vertical position of start of first row, below editorTitlesWidth and below any consensus sequences}		editorFirstColumnLeft: integer;	{horizontal position of start of first column, to right of editorRowNameEnd and any consensus sequences}				editorCursorTaxon,editorCursorCharacter: integer;					{from proto4: 				editorWindow: WindowPtr;				editorOpen: boolean;				editorTransposed: boolean;				editorCellEditing: boolean;				editorFootEditing: boolean;				editorSelected: boolean;				editorSinglePieceSelection: boolean;				editorDataCellsSelected: boolean;				editorSelectionTopLeft: point;				editorSelectionBotRight: point;				editorSelectionFirstTaxon: integer;				editorSelectionLastTaxon: integer;				editorSelectionFirstCharacter: integer;				editorSelectionLastCharacter: integer;				editorSelectionRect: rect;				editorHScroll,editorVScroll: ControlRef;				editorCellTE,editorFootNoteTE: TEHandle;				editorFont: integer;				editorFontSize: integer;				editorFontDescent: integer;				editorLineWidth: integer;				editorTitleLineWidth: integer;  				editorTitlesWidth: integer;				editorRowNameStart,editorRowNameEnd: integer;				editorRowNameWidth: integer;				editorClip: RgnHandle;				editorOrigin: point;				editorColumns, editorRows: integer;				editorTotalColumns,editorTotalRows: integer;				editorColumnWidth: integer;				editorMatrixRect,editorBoundaryRect: rect;				editorFootNoteWidth: integer;				editorFootNoteLines: integer;				editorMessageRect:rect;				editorFootNoteRect: rect;}	{const				edNormal = 0;		edBlockMove = 1;		edSelectedBlockMove = 2;				selectNormal = 0;		selectPiece = 1;			var		editorSelectionMode: integer;}	var		notificationPosted: boolean;		notificationRecord: NMRec;				oldOption: boolean;{======}{$IFC FALSE}	const	{---- comments ----}		filecom = 0;		treedatacom = 1;		treefilecom = 2;		numcoms = 2;			type		comTEtype = array[0..numcoms] of TEHandle;		comHtype = array[0..numcoms] of Handle;	var		curcom: INTEGER;				{}		aboutopen: BOOLEAN;			{true iff commwindow is open}		commwindow: WindowPtr;{=== TE stuff ===}		{helpTE: TEHandle;}		commentsTE: comTEtype;		commentsH: comHtype;		curcomH: Handle;		commScroll: ControlRef;		commOrigin: integer;		commTextBox: Rect;		commWindowLines: integer;{$ENDC}	var		commreadon: BOOLEAN;			{true if currently reading a comment from file}		decaySearchSubcommandStr: str255;		decaySearchHS: boolean;			const 		grayPalest = 1;		grayPale = 2;		grayPlain = 3;		grayDark = 4;		grayDarkest = 5;				muchPaler = 1;		paler = 2;		slightlyPaler=5;		darker = 3;		muchDarker=4;		selectionShade = 6;				defaultShade = 3;			const		numMacCladeWindows=numInfoWindows+numTextWindows+6;				{editorWindow			palette		treewindow			twmesswindow			tlegwindow			chlegwindow			numInfoWindows			palette		    branchlistwindow		stateswindow		pictwindow		chartwindow		textwindows		infowindows}					type		WindowPtrArray = Array [1..numMacCladeWindows] of WindowPtr;			var		MacCladeWindowList: WindowPtrArray;		type		{cellBlockPtr = ^CellBlockType;		cellBlockType = record				ntax, nchar: integer;  				starttaxa, endtaxa, startchars, endchars: integer;  				selOutline: rect;			end;}					CellBlockPtr = ^CellBlockRecord;		CellBlockRecord = record				ntax, nchar: integer;  {number of elements in block}				starttaxa, endtaxa, startchars, endchars: integer;  {original boundaries}				clickCharacter, clickTaxon: integer;				horCells,vertCells: integer; {horizontal and vertical cells in cellBlock}				offSetToBlockTopLeft: point;  {offset from mouse to topleft corner of fullRect}				offSetToCellTopLeft: point;  {offset from mouse to topleft corner of clickCell}				topLeftCell, botRightCell: point;  {cells at corners of fullRect}				clickCellOffset: point;  {number of cells over and down clickCell is from topLeftCell}				clickCell: point;  {cell originally clicked on}				currentMouseCell: point;  {coordinates of current mouse location}				currentClickCell: point;  {coordinates of Click Cell, in new position as block is moved}				currentStartChars, currentEndChars, currentStartTaxa, currentEndTaxa: integer;				visibleStartChars, visibleEndChars,visibleStartTaxa, visibleEndTaxa: integer;				fullRect: rect;				visibleRect: rect;				lowerLimit,upperLimit: integer;				gapsLower,gapsUpper: integer;				taxaLocked: boolean;				H: Handle;				blocktcb, blocknumbytes: integer;				firstEdgeTSTS, lastEdgeTSTS: LargestSetChars;				firstEdgeTSTSH,lastEdgeTSTSH: Handle;				oldicstart,oldicend: integer;			end;	const		drawBlockMoveOff = 0;		drawBlockMoveUp = 1;		drawBlockMoveDown = 2;	var		{EWscrap: scraptype;		EWScrapBlock, EWMoveBlock: cellBlockType;		EWScrapBlockP2: cellBlockPtr;}		EWMoveBlockP, EWScrapBlockP, EWFindSequenceBlockP, EWFindRNARCBlockP: CellBlockPtr;		EWCurrentDrawBlockP: CellBlockPtr;		blockMoveOn: boolean;		drawBlockMoveMode: integer;				selectPixMapH:  PixMapHandle;		selectWeightColor: RGBColor;		standardSelectionColor: RGBColor;		standardSelectionColorNumber: integer;		selectOffScreenWorld: GWorldPtr;		selectOffScreenWorldBox: Rect;				useOldFloatingWindows: boolean;				allEditingLocked: boolean;  {obsolete?}		dataLocked: boolean;		assumptionsLocked: boolean;		treesLocked: boolean;		savingLocked : boolean;		editorDisplayLocked: boolean;		nexusBlocksLocked: boolean;		applyLockOnlyToRestrictedVersion: boolean;			const		lockData=1;		lockAssumptions=2;		lockTrees=3;		lockSaving=4;		lockEditorDisplay=5;		lockNexusBlocks=6;			var		dataTinge: integer;		scrollWidth: integer;	{type		UndoMatrixRecord = record 			end;}{Edit undo stuff}		undoableEdit: BOOLEAN;			{true if last change to editor is undoable}		undoCellStates: LargestSetChars; 		{set for the currently selected single cell in the editor before any changes to that cell}		undoNameCellStringH: StringHandle;				undoSelectionTopLeft, undoSelectionBotRight: Point;		undoCellTaxon,undoCellCharacter: integer;		undoNameRow: longint;		undoWhichInfo: integer;		undoSelectionValid: boolean;		EWUndoBlockP: CellBlockPtr;		warnIfCantUndo: boolean;		newlyDeletedTaxaFromStart: integer;		newlyDeletedCharactersFromStart: integer;		lastChangeInEditor: integer;		lastChangeIsEither: boolean;				onOpenFileSetAsPlainMolecularStyle: boolean;		 	const 		lastChangeCantUndo = -1; 		lastChangeDataCell = 0; 		lastChangeNameCell=1; 		lastChangeCellBlock = 2; 		lastChangeInsertCharAndCellBlock = 3; 		lastChangeAddCharacters = 4; 		lastChangeAddTaxa = 5; 		lastChangeInsertTaxaAndCellBlock = 6; 		 		lastChangeDestroyCharacters =7; 		lastChangeMoveCharacters = 8; 		lastChangeDestroyTaxa =9; 		lastChangeMoveTaxa = 10; 		lastChangeNameRow=11;{	var		undoMatrixH : Handle;		undochCHUNKs: Handle;		undoTaxonCHUNKs: Handle;		undoStrCHUNKs: strCHBArray;		undoSegDataH: Handle;		undoFixDataH: Handle;		undoTreeDataH: Handle;		undoCHTypeH, undoCHStoreTypeH: Handle;		undoCHWtH, undoCHStoreWtH: Handle;		undoCHStatesH: Handle;		undoStateNamesCHUNKs: Handle;		undoFootH: array[0..maxfoottype] of Handle;		const 		 		maxUndoRecords = 4; 	type 	 	EditorUndoRecord = record	 			lastChangeType: integer;	 			object1,object2,objectLocation: integer;	 			cellBlock: CellBlockPtr;	 			states: LargestSetChars;	 			selectionTopLeft, selectionBotRight: point;	 			selectionValid: boolean;	 		end;	 	EditorUndoArray = Array[1..maxUndoRecords] of EditorUndoRecord;	 	EditorUndoArrayPtr = ^EditorUndoArray;	 		 var	 	EditorUndo: EditorUndoArrayPtr;}	const		notABlockName = '*';	type		NexusBlockPtr = ^NexusBlockRecord;		NexusBlockRecord = record				prev,next: NexusBlockPtr;				blocktype: integer;				cursID: integer;				nativeBlock: boolean;				willWriteBlock: boolean;				selected: boolean;				blockName: str255;				linkText: str255;				title: str255;				H: Handle;  {block contents}			end;				var 		NexusBlocks: NexusBlockPtr;		numNexusBlocks: integer;		nexusBlockBeingEdited: NexusBlockPtr;		nexusBlockNameBeingEdited: str255;		paupCommandCopyToClipBoard: boolean;			const maxNumParts=255;	type		CharPartNamePtr = ^CharPartNameRecord;		CharPartNameRecord = record				prev,next: CharPartNamePtr;				selected,inUse, inPartition: boolean;				name: str255;				color: RGBColor;			end;				var 		CharPartNames: CharPartNamePtr;		numCharPartNames: integer;		CharPartNameBeingEdited: str255;		type		FootPicturesPtr = ^FootPicturesRecord;		FootPicturesRecord = record				prev,next: FootPicturesPtr;				ID: integer;				picH: PicHandle;  { contents}			end;				var 		FootPictures: FootPicturesPtr;		numFootPicts: integer;	const		notSettingsID=0;		numSettingLinkedLists = 2;		bothSettings=-1;		programSettings = 1;		fileSettings = 2;			type		SettingsPtr = ^SettingsRecord;		SettingsRecord = record				prev,next: SettingsPtr;				ID,subID: integer;				subVersionRequired: integer;				name, subName: str128;				H: Handle;  { contents}				willWrite: boolean;			end;		SettingsPtrArray = Array[1..numSettingLinkedLists] of SettingsPtr;			SettingsNumberArray = Array[1..numSettingLinkedLists] of integer;		var		baseSettings: SettingsPtrArray;		writingToHandle : boolean;		writingH: Handle;		numSettings: SettingsNumberArray;		ReadingSettings: boolean;				copySpecialCustomH1,copySpecialCustomH2: StringHandle;				universalCodPos: boolean;			var 	gapExtensionCost: integer;		alignmentChangeCost: integer;		gapStartCost : integer;		terminalGapStartCost: integer;		terminalGapExtensionCost: integer;		alignmentAccuracy: integer;		approxAlignRange: integer;		alignmentCostMatrix: integer;		approximateAlignment: boolean;		useGotohIfPossible: boolean;		autoAlignSelected: boolean;		noCostForTerminalGaps: boolean;		alignmentCodonCosts: array [-1..3] of integer;		alignmentInnerCodonCost: integer;				allowCursorChange: boolean;			const		alignmentBest = 2;		alignmentOK=1;		alignmentPoor = 0;	type		ThermoRecord = record				open: boolean;				asPercent: boolean;				allowUpdates: boolean;				backGroundable: boolean;				timeStart: longint;				whichThermo: integer;				theDialog: DialogPtr;			end;		ThermoArray = array[1..2] of ThermoRecord;		ThermoArrayPtr = ^ThermoArray;	var		ThermoP : ThermoArrayPtr;	const		flashInterval = 1;		maxFlashPattern = 8;	var		lastFlashTime: longint;		curFlashPattern: integer;		theflashRgn: RgnHandle;		editorFlashOn: boolean;		flashHidden: boolean;					var		ChartLogSigDigits: integer;	var 	writeHTMLAsTable: boolean;		writeHTMLShowGaps: boolean;		writeHTMLBlockLength: integer;		writeHTMLShowCellBorders: boolean;		writeHTMLCharacterNames: boolean;		writeHTMLCharacterNumbers : boolean;		writeHTMLPageTitle: str255;		writeHTMLInterleaved : boolean;		writeHTMLCreator: OSType;	const		tickOther = 100;	{simple rectangle}		tickUnique = 0;		{rectangle, thick line}		tickChangedAbove = 1;	{simple rectangle}		tickPointUp = 2;	{triangle, pointing up}		tickPointDown = 3;  	{triangle, pointing down}		tickPointBoth = 4;	{diamond}		tickAmbiguous = 5;		{oval, faint framing}		tickDerivedUnclear = 6;	{simple rectangle, faint framing}				tickMajorClassMax = 6;				tickAboveAncestral = 0;		tickAboveMaybeAncestral = 1;		tickAboveConvergent = 2;		tickAboveNovel = 3;		tickAboveUniform = 4;		tickAboveOther = 5;				tickBelowAncestral = 0;		tickBelowMaybeAncestral = 1;		tickBelowConvergent = 2;		tickBelowUniform = 3;		tickBelowAbsent = 4;		tickBelowOther = 5;				changeUnknown=0;		changeTransversion = 1;		changeTransition = 2;			var		prettyPrintWhiteSymbols: boolean;		prettyPrintSpaceBetweenCodons: boolean;		pageSetupChanged: boolean;	const		searchSwap = 1;		searchAncestor=2;		maxSearches= 2;				maxSearchSwapCurs = 23;		maxSearchAncestorCurs = 11;		maxSearchCurs = 23;	type		searchCursArray = array[1..maxSearches,0..maxSearchCurs] of CursHandle;		searchCursIntegerArray = array[1..maxSearches] of integer;	var		searchCursor: searchCursArray;		maxSearchCursors,searchCursorNumber,searchCursorBaseID: searchCursIntegerArray;		treeWindowPositionRead: boolean;		CharLegendPositionRead, TreeLegendPositionRead: boolean;		justReadANexusFile: boolean;		windowOrderRead: boolean;				numCharLegendBoxes: integer;		legboxheight: INTEGER;			{height taken up by one line with box in a legend}		legLineHeight: INTEGER;			{height of a line of text in a tree window legend}		locklegends: BOOLEAN;			{true if character legend and tree legend locked in place to treewindow}		hidelegends: BOOLEAN; 			{true if legends hidden from treewindow}		legendTitleIsWindowTitle: boolean;		legMessageBox: Rect;			const		treeLegendTitleWidth = 12;		charLegendTitleWidth = 12;		standtlegW = 93;		{standard width of treelegend}		standchlegW = 85;	{standard width of character legend}	var		warnIfUnstoredTreeWillDisappear: boolean;				flashTickBox: rect;		flashTickCharacter: integer;		flashTickN: NPtr;		flashTickOn: boolean;			const		MPROldMode = 0;		MPRNewMode = 1;		MPRDualMode = 2;		var	calcRestChanges: boolean;		mprCubeDimensions:integer;		maxMPRState: integer;		MPRCalculationsMode: integer;		allowCLADImportFromFinder : boolean;		userCanceledRead: boolean;			const		chartColorNone = 0;		chartColorCodPos = 1;		chartColorPartitions = 2;	var		colorCodPos: BOOLEAN;			{true if color different codon positions differently in sequencechart}		chartColorMode: integer;		dragSoundActive: boolean;      		showTextOrAllinNav: boolean;      		      		allowImportMoleculeIntoStandard: boolean;      		queriedAboutImportedSequenceType: boolean;      		importedDataType: integer;      		      		printDataBoxesInColor: boolean;      		      		      		showMultiAlignmentCost: boolean;      		multiAlignmentCost: longint;      		multiGapCost, multiSubstitutionCost: longint;		ShadeExcludedItem: integer;				lastImpSequenceFileType:integer;			const 		impNBRF=1;		impGenbank = 2;		impFASTA = 3;		impNameSeq = 4;		impSeqOnly = 5;{$IFC NOT RELEASEVERSION}	var		tempFile: text;{$ENDC}implementationend.