unit Continuous;{ееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap, 		 Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, 		 EventUtil, GenUtil, BoxUtil, MenuUtil, CharUtil, TaxonCHUtil, Legends, StrUtil, TreeUtil, 		 TypeUtil, Prohibitions, TraceControl, Settings, NexusBlocks;	procedure ReconstructContinuous;	procedure TurnOnContinuous;	procedure ContinuousEdit;	procedure ContinuousOptions;	procedure ContinuousSBar (whichControl: ControlRef; theCode: INTEGER);	function GetContString (contmin, contmax: single): str255;	function ContinuousComplete (ic: integer; intree: boolean): boolean;	function NextCompleteCont (ic: integer; intree: boolean): integer;	function PrevCompleteCont (ic: integer; intree: boolean): integer;	function FirstEmptyCont(var icont: integer): boolean;	procedure SetContinuousToGCBias;	{ееееееееееееееееееееее}implementation	var		contrect, fullrect: rect;		contlist: ListHandle;		contH: handle;		icontedit: integer;{$IFC DEVELOPMENT}		mult10: single;  {used in iterative averaging algorithm} {$ENDC}{----}{In Trace Continuous under Squared change to rooted/unrooted add /Felsenstein's X (or whatever)}{	from his contrast calculations  ITEM 21}{In Trace Continuous have radio button for weight by segments  ITEM 22}{In Chart menu add contrast Correlation chart for continuous}{GET CMAP From Martins/Garland}{}{ввв if change segments need to update continuous}{ввв only give choice to follow segments if different from 1}{}{------------------------------------}	function TooBigTooSmall (rr: single): boolean;{continuous variables allowed only to be positive, and must be less than 10000}	begin		TooBigTooSmall := (rr < 0) or (rr > 9999.9);  {Wayne: eventually allow negatives}	end;{------------------------------------}	function GetContinuousMin (it, ics: integer): single;		var			TaxonHdl: thdl;{returns value of continuous character ics for taxon it}	begin		TaxonHdl := gettaxonHdl(it);		GetContinuousMin := TaxonHdl^^.contsmin[ics];	end;{------------------------------------}	function GetContinuousMax (it, ics: integer): single;		var			TaxonHdl: thdl;{returns value of continuous character ics for taxon it}	begin		TaxonHdl := gettaxonHdl(it);		GetContinuousMax := TaxonHdl^^.contsmax[ics];	end;{============================================================}{================ LINEAR PARSIMONY ====================}	procedure NYReconstruct;{FROZEN 3.0}{Reconstructs ancestral states for continuous characters using linear parsimony.}{N^.downA, downB store the minima and maxima of downpass ranges}{N^.upA, upB store the minima and maxima of uppass ranges}{N^.finalC, finalD store the minima and maxima of final pass ranges}{	(final named C and D because finalC doubly used; see MinSQReconstruct)}		var			dummy: single;			sister: Nptr;{...............}		procedure combine (var minA, maxA: single; minD, maxD, minE, maxE: single; var inc: single);{This is the continuous value state set operator; takes state ranges}{[minD..maxD] and [minE..maxE] and combines them and outputs range [minA..maxA]}{inc is the increment on length caused by the combining}		begin			if minD < minE then				begin					if maxD < minE then  {no overlap}						begin  {DDDDD EEEEE}							minA := maxD;							maxA := minE;							inc := inc + minE - maxD;						end					else if maxD < maxE then						begin  {DDDDDEDEDEEEEE}							minA := minE;							maxA := maxD;						end					else						begin  {DDDDEDEDEDDDDD}							minA := minE;							maxA := maxE;						end;				end			else				begin					if maxE < minD then  {no overlap}						begin   {EEEEEEE   DDDDDDD}							minA := maxE;							maxA := minD;							inc := inc + minD - maxE;						end					else if maxE < maxD then						begin   {EEEEEEDEDEDDDDDD}							minA := minD;							maxA := maxE;						end					else						begin   {EEEEEEDEDEDEEEEE}							minA := minD;							maxA := maxD;						end;				end;		end;{...............}		procedure Triplecombine (var minA, maxA: single; minD, maxD, minE, maxE, minF, maxF: single);{This is the continuous value state set operator for 3 SETS; takes state ranges}{[minD..maxD], [minE..maxE] and [minF..maxF] and combines them and outputs range [minA..maxA]}{Uses the trick of taking two most distant state sets, applying binary set operator on them, then}{taking result and combine it with third set using binary set operator again}			procedure DoCombineOneThenOther (min11, max11, min22, max22, min33, max33: single);			begin				dummy := 0;				Combine(minA, maxA, min11, max11, min22, max22, dummy);				Combine(minA, maxA, minA, maxA, min33, max33, dummy);			end;			procedure CombinefromGreatestMin (minG, maxG, min22, max22, min33, max33: single);{here minG, maxG are min and max of set with rightmost minimum}{First we find out which of the other sets' maximum is the furthest left of minG, if either is}			begin				if max33 < minG then					begin						if max22 < max33 then {max22 furthest left, and is left of minG; Thus combine set G and set 22 first, then 33}							DoCombineOneThenOther(minG, maxG, min22, max22, min33, max33)						else {max33 furthest left, and is left of minG; Thus combine set G and set 33 first, then 22}							DoCombineOneThenOther(minG, maxG, min33, max33, min22, max22)					end				else			{Either: max22 furthest left, and is left of minG; Thus combine set G and set 22 first, then 33}			{Or: Both max22 and max33 are right of minG, thus there must be triple intersection, and order doesn't matter}					DoCombineOneThenOther(minG, maxG, min22, max22, min33, max33);			end;		begin			if minD < minE then				begin					if minE < minF then  	{е minF is greatest}						CombinefromGreatestMin(minF, maxF, minD, maxD, minE, maxE)					else 					{е minE greatest}						CombinefromGreatestMin(minE, maxE, minD, maxD, minF, maxF)				end			else if minF > minD then {е minF greatest}				CombinefromGreatestMin(minF, maxF, minD, maxD, minE, maxE)			else  						{е minD greatest}				CombinefromGreatestMin(minD, maxD, minF, maxF, minE, maxE);		end;{...............}		procedure NYdown (N: Nptr);{Downpass of linear parsimony on continuous characters}		begin			if NodeIsInternal(N) then				begin  {internal node}					NYdown(N^.lf);					NYdown(N^.rt);{^.downA is minimum of state range; ^.downB is maximum}{note here we let Combine increment the NYlength during downpass}					Combine(N^.downA, N^.downB, N^.lf^.downA, N^.lf^.downB, N^.rt^.downA, N^.rt^.downB, NYlength);				end			else				begin					N^.downA := GetContinuousMin(N^.name, icont); {Get minimum observed state in terminal}					if GetContinuousMax(N^.name, icont) > N^.downA then {recall if not assigned, stored as negative number}						begin							N^.downB := GetContinuousMax(N^.name, icont);							NYlength := NYlength + N^.downB - N^.downA;						end					else						N^.downB := N^.downA;					if (TooBigTooSmall(N^.downA) | TooBigTooSmall(N^.downB)) then						NewError(51, icont);				end;		end;{...............}		procedure NYfinal (N: Nptr);{This is combined UpPass and FinalPass for continuous characters, linear parsimony}		begin			if NodeIsInternal(N) then				begin  {internal node}					if N = R then						begin							N^.finalC := N^.downA;  {use downpass states for root's final}							N^.finalD := N^.downB;						end					else						begin{First calculate up states}							sister := Sis(N);							if N^.anc = R then								begin									N^.upA := sister^.downA;									N^.upB := sister^.downB;								end							else								begin									dummy := 0;									Combine(N^.upA, N^.upB, N^.anc^.upA, N^.anc^.upB, sister^.downA, sister^.downB, dummy);								end;{Then calculate final states}							TripleCombine(N^.finalC, N^.finalD, N^.lf^.downA, N^.lf^.downB, N^.rt^.downA, N^.rt^.downB, N^.upA, N^.upB);						end;					NYfinal(N^.lf);					NYfinal(N^.rt);				end			else {terminal node}				begin					N^.finalC := N^.downA; {Results stored in [finalC .. finalD]}					N^.finalD := N^.downB;				end;		end;{...............}	begin		NYlength := 0;		NYDown(R);		NYFinal(R);	end;{.....................}{MINSTATE resolution for continuous character}	procedure FirstResInContinuous (N: Nptr);	begin		N^.finalD := N^.finalC;		if NodeIsInternal(N) then			begin				FirstResInContinuous(N^.lf);				FirstResInContinuous(N^.rt);			end;	end;{MAXSTATE resolution for continuous character}	procedure LastResInContinuous (N: Nptr);	begin		N^.finalC := N^.finalD;		if NodeIsInternal(N) then			begin				LastResInContinuous(N^.lf);				LastResInContinuous(N^.rt);			end;	end;{============================================================}{================ SQUARED CHANGE PARSIMONY ====================}{$IFC DEVELOPMENT}	procedure SQbyAverages (rooted: boolean);		var			iterations, ir: integer;			NotQuiteCloseEnough: boolean;			taxonHdl: tHdl;		procedure CheckIfCloseToMinSQ (N: Nptr);		begin			if (TruncateValue(abs(N^.finalC - N^.lengthmean) * 1000.0) <> 0) then				InstantInfo('failcheck sq change');			if NodeIsInternal(N) then				begin					CheckIfCloseToMinSQ(N^.lf);					CheckIfCloseToMinSQ(N^.rt);				end;		end;		procedure InitializeSQAvg (N: Nptr);		begin			if NodeIsInternal(N) then				begin					InitializeSQAvg(N^.lf);					InitializeSQAvg(N^.rt);					N^.finalC := (N^.lf^.finalC + N^.rt^.finalC) / 2.0;				end			else				begin					TaxonHdl := gettaxonHdl(N^.name);					N^.finalC := (TaxonHdl^^.contsmin[icont]);					N^.finalD := N^.finalC;				end;		end;		function CheckCloseEnough (areal, breal: single): boolean;			var				along, blong: longint;				decim: single;		begin			CheckCloseEnough := TruncateValue(abs(areal - breal) * mult10) = 0;		end;		procedure IterateSQAvg (N: Nptr);		begin			if NodeIsInternal(N) then				begin					if N = R then {on way up, part of two way}						N^.finalD := N^.finalC					else						N^.finalD := (N^.lf^.finalC + N^.rt^.finalC + N^.anc^.finalD) / 3.0;					IterateSQAvg(N^.lf);					IterateSQAvg(N^.rt);					if N = R then  {on way down, part of double}						N^.finalD := (N^.lf^.finalD + N^.rt^.finalD) / 2.0					else						N^.finalD := (N^.lf^.finalD + N^.rt^.finalD + N^.anc^.finalD) / 3.0;					if not CheckCloseEnough(N^.finalD, N^.finalC) then						NotQuiteCloseEnough := true;					N^.finalC := N^.finalD;				end;		end;		procedure LengthSQAvg (N: Nptr);		begin			if N <> R then				minSQlength := minSQlength + sqr(N^.finalD - N^.anc^.finalD);			if NodeIsInternal(N) then				begin					LengthSQAvg(N^.lf);					LengthSQAvg(N^.rt);				end;		end;	begin		if rooted then			begin				mult10 := 1000.0;				InitializeSQAvg(R);				repeat					iterations := iterations + 1;					NotQuiteCloseEnough := false;					IterateSQAvg(R);				until not notquitecloseenough;				minSQlength := 0;				LengthSQAvg(R);				CheckIfCloseToMinSQ(R);			end;	end; {$ENDC}{------------------------------------------------------------------------}	procedure minSQReconstruct (rooted: boolean);{FROZEN 3.0}{This procedure reconstructs continuous ancestral states using the squared-change}{parsimony criterion (see Maddison, 1991).  There are two options; either the root is taken as}{non-existant (unrooted) or as being a node (rooted)}{Wayne: check unrooted weighted to see if OK}		var			tA, tB, tC: single;			SQlengthchecked, SQlengthcheckedWt: single;{...............}{$IFC FALSE}		procedure checkSQlength (N: Nptr);		begin			if N <> R then				begin					SQlengthchecked := SQlengthchecked + sqr(N^.finalC - N^.anc^.finalC);					SQlengthcheckedWt := SQlengthcheckedWt + sqr(N^.finalC - N^.anc^.finalC) / N^.setlength;				end;			if NodeIsInternal(N) then				begin					checkSQlength(N^.lf);					checkSQlength(N^.rt);				end;		end; {$ENDC}{.......}		function BranchWeight (dN: Nptr): single;		begin			if contweighted then				begin					if dN = R then {asking for weight across root for unrooted case}						Branchweight := R^.lf^.setlength + R^.rt^.setlength					else if dN^.setlength = 0 then						begin							BranchWeight := 1.0;							NewError(406, icont);						end					else						BranchWeight := 1.0 * dN^.setlength				end			else				BranchWeight := 1.0;		end;{.......}		procedure AddABCdown (var A, B, C: single; dN: Nptr; WtdN: single);{this procedure adds dN's contribution to running total for three down pass parameters}{See pages 306-307 of paper}{v 3.05: NOW WEIGHTED see p. 310 of paper}			var				ts: single;		begin			if NodeIsTerminal(dN) then  {terminal, add 1, -2b, c2}				begin					ts := GetContinuousMin(dN^.name, icont);					A := A + 1.0 / WtdN;					B := B - 2.0 * (ts) / WtdN;					C := C + sqr(ts) / WtdN;					if TooBigTooSmall(ts) then						NewError(51, icont);				end			else				with dN^ do					begin   {internal, add a/(a+1), b/(a+1), b2/(4(a+1))-c}						A := A + downA / (downA * WtdN + 1.0);						B := B + downB / (downA * WtdN + 1.0);						C := C + finalC - (sqr(downB) / 4.0 / (downA + 1.0 / WtdN));					end;		end;{...............}		procedure AddABCAllDescendants (var A, B, C: single; dN: Nptr);{visits all descendants of dN, whether dN is polytomous or not, }{and accumulates three parameters of downpass for dN}			var				sisright, lastdone: Nptr;		begin			lastdone := firstnonnullleft(dN^.lf);			AddABCdown(A, B, C, lastdone, Branchweight(lastdone));			sisRight := NextSisterRight(lastdone);			while sisright <> lastdone do				begin					AddABCdown(A, B, C, sisright, BranchWeight(sisright));					lastdone := sisright;					sisRight := NextSisterRight(Sisright);				end;		end;{...................................................................................}{..................The downpass of squared parsimony...........................}		procedure squaredown (N: Nptr);		begin			if NodeIsInternal(N) then				begin  {internal node}					squaredown(N^.lf);					squaredown(N^.rt);					if not N^.null then						begin							N^.downA := 0; {initialize three parameters to 0}							N^.downB := 0;							N^.finalC := 0;							AddABCAllDescendants(N^.downA, N^.downB, N^.finalC, N);						end;				end;		end;{...................................................................................}{..................The finalpass of calculations of Felsenstein's X's...........................}{$SETC CONTRASTS=FALSE}{$IFC CONTRASTS}		procedure FelsXFinal (N: Nptr);		begin			if NodeIsInternal(N) then				begin  {internal node}					FelsXFinal(N^.lf);					FelsXFinal(N^.rt);					if not N^.null then  {even though not allowed for polytomous trees!}						begin							N^.finalC := N^.downB / (-2.0 * N^.downA);  {most parsimonious at root of clade}{N^.finalD := N^.finalC;}						end;				end			else				begin					N^.finalC := GetContinuousMin(N^.name, icont);{N^.finalD := N^.finalC;}					if TooBigTooSmall(GetContinuousMin(N^.name, icont)) then						NewError(51, icont);					if GetContinuousMax(N^.name, icont) >= -0.5 then						NewError(315, 0);				end;		end;{...................................................................................}{..................The finalpass of calculations of Felsenstein's contrasts...........................}		procedure FelsContrastsFinal (N: Nptr);		begin			if NodeIsInternal(N) then				begin  {internal node}					if BranchExists(N) then  {even though not allowed for polytomous trees!}						begin							N^.finalC := N^.lf^.finalC - N^.rt^.finalC;							if continuousmode = sqFelsContrastSTD then {standardize}								N^.finalC := N^.finalC / (sqrt(N^.lf^.downA + N^.rt^.downA));						end;					FelsContrastsFinal(N^.lf);					FelsContrastsFinal(N^.rt);				end			else				N^.finalC := GetContinuousMin(N^.name, icont);		end;{...................................................................................}		procedure FelsVariances (N: Nptr);			var				luse: integer;		begin			if contweighted then				luse := N^.setlength			else				luse := 1;			if NodeIsInternal(N) then				begin  {internal node}					FelsVariances(N^.lf);					FelsVariances(N^.rt);					if BranchExists(N) then  {even though not allowed for polytomous trees!}						N^.downA := luse + (N^.lf^.downA * N^.rt^.downA) / (N^.lf^.downA + N^.rt^.downA); {downA used temporarily!}				end			else				N^.downA := luse;		end;{---$IFC FALSE}		procedure ResetVariances (N: Nptr);		begin			if NodeIsInternal(N) then				begin  {internal node}					if BranchExists(N) then  {even though not allowed for polytomous trees!}						N^.finalC := sqrt(N^.lf^.downA + N^.rt^.downA); {downA used temporarily!}					ResetVariances(N^.lf);					ResetVariances(N^.rt);				end;		end; {$ENDC}{...................................................................................}{..................The uppass & final pass of squared parsimony...........................}		procedure squarefinal (N: Nptr);			var				sister: Nptr;				sisright, lastdone, Nanc: Nptr;{.....}			procedure AddABdown (var A, B: single; dN: Nptr; wt: single);{This procedure adds downpass parameters of dN to running total of parameters A,B}			begin				if NodeIsTerminal(dN) then  {again, adding down}					begin  {Terminal, add 1, -2b}						A := A + 1.0 / wt;						B := B - 2.0 * (GetContinuousMin(dN^.name, icont)) / wt;						if TooBigTooSmall(GetContinuousMin(dN^.name, icont)) then							NewError(51, icont);					end				else					with dN^ do   {internal, add a/(a+1), b/(a+1)}						begin							A := A + downA / (downA * wt + 1);							B := B + downB / (downA * wt + 1);						end;			end;{................................................................}{...........MAIN of Squared Final Pass ............}		begin			if (N = R) then				begin					squarefinal(N^.lf);					squarefinal(N^.rt);					if (continuousmode = squnrooted) then						begin							N^.finalC := -1.0;						end					else if (N^.downA = 0) then						begin							N^.finalC := 0;							NewError(142, icont);						end					else						N^.finalC := N^.downB / (-2.0 * N^.downA);  {most parsimonious at root; p. 9 of resubmission}{N^.finalD := N^.finalC;}				end			else if (NodeIsInternal(N)) then				begin  {internal node}					if not N^.null then						begin{now we need to poll descendant nodes and nodes below by adding up their contributions}{to the first and second parameters (final) at N}{FIRST look to contribution from ABOVE}							N^.finalC := N^.downA;  {additions from above already summed in N^.downA and downB}							N^.finalD := N^.downB;{Now look to contribution from BELOW}							Nanc := NotNullAnc(N);							if Nanc = R then  {ancestor is root}								begin									if rooted then {----- rooted -----}										begin					{**since just above root, uppass states from below are just sum}					{of downpass states from all sisters, which can be found by taking R's down and}					{subtracting what had been N's contribution, so as to leave contribution of sisters.}					{Unlike the case with other parsimony algorithms}					{this can be done because everything is additive}											N^.upA := R^.downA - (N^.downA / (N^.downA * BranchWeight(N) + 1));											N^.upB := R^.downB - (N^.downB / (N^.downA * BranchWeight(N) + 1));											with N^ do						{this calculation adds to finals the contribution from below}						{(other side of root), using a/(a+1) etc to add effect of the root node}												begin													finalC := finalC + upA / (upA * BranchWeight(N) + 1);													finalD := finalD + upB / (upA * BranchWeight(N) + 1);												end;										end									else  {----- unrooted -----}										begin					{not rooted, thus use sister's downs directly, without extra calculation to add root}											sister := Sis(N);											if NodeIsTerminal(sister) then												begin													N^.upA := -2; {send signal that sister was terminal}													N^.upB := GetContinuousMin(sister^.name, icont);  {store observed state in sister}												end											else												begin													N^.upA := sister^.downA;													N^.upB := sister^.downB;												end;					{now we add to finals the contribution from below}											AddABDown(N^.finalC, N^.finalD, sister, BranchWeight(R));  {contribution across root}										end;								end							else  {Nanc is not Root; internal node}								begin									if Nanc^.upA < -1.5 then {receive signal that sister at root was terminal and unrooted}										begin  {TRANSFER:}{v3.05: had been error here, namely N^.upA := 1 / (BranchWeight(R) + 1)}											N^.upA := 1 / (BranchWeight(R));  {contribution from N^.anc; from terminal sister across unroot}											N^.upB := -2.0 * (Nanc^.upB) / BranchWeight(R); {upB contained temporarily state in sister across unroot}										end									else										begin											N^.upA := Nanc^.upA / (Nanc^.upA * BranchWeight(Nanc) + 1);  {contribution from N^.anc}											N^.upB := Nanc^.upB / (Nanc^.upA * BranchWeight(Nanc) + 1);										end;									N^.upA := N^.upA + Nanc^.downA - (N^.downA / (N^.downA * BranchWeight(N) + 1));{contribution from sisters}									N^.upB := N^.upB + Nanc^.downB - (N^.downB / (N^.downA * BranchWeight(N) + 1));  {see comments above (**)}									with N^ do  {adding contribution from below to N's final}										begin											finalC := finalC + upA / (upA * BranchWeight(N) + 1);											finalD := finalD + upB / (upA * BranchWeight(N) + 1);										end;								end;							with N^ do  {NOW we find most parsimonious state}								begin									if finalC = 0 then										NewError(142, icont)									else										finalC := finalD / (-2.0 * finalC);{finalD := finalC;}									if TooBigTooSmall(finalC) and not Errorposted(51) then										NewError(314, 0);								end;						end;					squarefinal(N^.lf);					squarefinal(N^.rt);				end			else  {Terminal node, assign observed state}				begin					N^.finalC := GetContinuousMin(N^.name, icont);{N^.finalD := N^.finalC;}					if TooBigTooSmall(GetContinuousMin(N^.name, icont)) then						NewError(51, icont);					if GetContinuousMax(N^.name, icont) >= -0.5 then						NewError(315, 0);				end;{$IFC DEVELOPMENT}			N^.lengthmean := N^.finalD;  {saving for comparison with other}{$ENDC}		end;{...............}	begin		if (R^.name <> 0) then			InstantError(176)		else if not (continuousmode in [sqFelsX, sqFelsContrast, sqFelsContrastSTD]) then			begin{rooted}				if rooted then					begin						SquareDown(R);{now need to calculate squared length}						if R^.downA = 0 then							minSQlength := 0						else							minSQlength := R^.finalC - sqr(R^.downB) / 4.0 / R^.downA					end{unrooted}				else					begin						SquareDown(R^.lf); {note don't calculate down for root}						SquareDown(R^.rt);{now need to calculate squared length}						if (NodeIsInternal(R^.lf)) then  {Note: R^.lf can't be null with unrooted}							begin								tA := 0;								tB := 0;								tC := 0;								AddABCAllDescendants(tA, tB, tC, R^.lf);								AddABCdown(tA, tB, tC, R^.rt, BranchWeight(R));								if tA = 0 then									minSQlength := 0								else									minSQlength := tC - sqr(tB) / 4.0 / tA;							end						else if NodeIsInternal(R^.rt) then  {Note: R^.rt can't be null with unrooted}							begin								tA := 0;								tB := 0;								tC := 0;								AddABCAllDescendants(tA, tB, tC, R^.rt);								AddABCdown(tA, tB, tC, R^.lf, BranchWeight(R));								if tA = 0 then									minSQlength := 0								else									minSQlength := tC - sqr(tB) / 4.0 / tA;							end						else {Only a two taxon tree; squared length for unrooted is just square of difference}							minSQLength := sqr(R^.rt^.finalC - R^.lf^.finalC);					end;				SquareFinal(R);{$IFC FALSE}				SQlengthchecked := 0;				SQlengthcheckedWt := 0;				CheckSQlength(R);{$ENDC}{$IFC CONTRASTS}			end		else {sqFelsX or contrasts}			begin				SquareDown(R);  {do downpass}				FelsXFinal(R);				minSQLength := 0;				if continuousmode in [sqFelsContrast, sqFelsContrastSTD] then					begin						if continuousmode = sqFelsContrastSTD then							FelsVariances(R);						FelsContrastsFinal(R);{ResetVariances(R); }					end;{$ENDC}			end;{$IFC DEVELOPMENT}		SQbyAverages(rooted);{$ENDC}	end;{-------------------------------------------------------------}{-----------------------------------------------------------------------------}	procedure ReconstructContinuous;{reconstructs the continuous ancestral states, according to specified options}	begin		case continuousmode of			manhattan: 				NYReconstruct;			manhatmin: 				begin					NYReconstruct;					FirstResInContinuous(R);				end;			manhatmax: 				begin					NYReconstruct;					LastResInContinuous(R);				end;			sqrooted: 				begin					minSQReconstruct(true);				end;			squnrooted: 				begin					if NodeisPolytomous(R) then						begin							NewError(86, 0);							continuousmode := sqrooted;							minSQReconstruct(true)						end					else						minSQReconstruct(false);				end;{$IFC CONTRASTS}			sqFelsX, sqFelsContrast, sqFelsContrastSTD: 				minSQReconstruct(true);{$ENDC}			otherwise				;		end;		if Errorposted(51) then			TurnoffContinuous(true);	end;{============================================================}{============================================================}{================ Control and editorOpen procedures ====================}	procedure TurnOnContinuous;{Turns on continuous character trace}	begin		SetCursor(clockCursor);		if (traceshown = traceDiscrete) then			TurnoffTrace(i, true, false, true);		if (traceshown = traceAllChanges) then			TurnOffShowChg(true);		if (traceshown = traceAllStates) then			TurnOffAllStates;{$IFC PROBRECONSTRUCT}		if (traceshown = traceProbability) then			turnOffProbReconstruct;{$ENDC}		traceshown := traceContinuous;		curTrace := traceContinuous;		ShowCHLegIfHidden;{FROZEN 3.0}		gomask := gomask + [GOcontinuous];		golist := golist + [GOcontinuous];  {do continuous calculations}		DefineTWClip;		FixTreeShadingMenus;		CheckPixelDepth(treewindow);	end;{-----------------------------------------------------------------------------}	function ContinuousComplete (ic: integer; intree: boolean): boolean;		var			it: integer;			okk: boolean;	begin		okk := true;		if ic > numcontinuous then			okk := false		else			for it := 1 to numtaxa do				if (not treeopen | not intree) | (TaxonIntree(it)) then					begin						if toobigtoosmall(GetContinuousMin(it, ic)) then							begin								okk := false;								leave;							end;					end;		Continuouscomplete := okk;	end;{-----------------------------------------------------------------------------}	function FirstEmptyCont(var icont: integer): boolean;	begin		if numContinuous< mncontinuous then			begin				icont := numContinuous+1;				numContinuous := numContinuous+1;				FirstEmptyCont := true;			end		else			FirstEmptyCont := false;	end;{-----------------------------------------------------------------------------}	function NextCompleteCont (ic: integer; intree: boolean): integer;{.....}		function LastCompleteCont: integer;			var				ij: integer;		begin			ij := numcontinuous;			while (ij >= 1) & not Continuouscomplete(ij, intree) do				ij := ij - 1;			LastCompleteCont := ij;		end;{.....}	begin		if (ic > numcontinuous) then			ic := LastCompleteCont		else			begin				if (ic < 1) then					ic := 1;				while (ic <= numcontinuous) & not Continuouscomplete(ic, intree) do					ic := ic + 1;				if (ic > numcontinuous) then					ic := LastCompleteCont;			end;		NextCompleteCont := ic;	end;{-----------------------------------------------------------------------------}	function PrevCompleteCont (ic: integer; intree: boolean): integer;{.....}		function FirstCompleteCont: integer;			var				ij: integer;		begin			ij := 1;			while (ij <= numcontinuous) & not Continuouscomplete(ij, intree) do				ij := ij + 1;			FirstCompleteCont := ij;		end;{.....}	begin		if (ic < 1) then			ic := FirstCompleteCont		else			begin				if (ic > numcontinuous) then					ic := numcontinuous;				while (ic >= 1) & not Continuouscomplete(ic, intree) do					ic := ic - 1;				if (ic < 1) then					ic := FirstCompleteCont;			end;		PrevCompleteCont := ic;	end;{-----------------------------------------------------------------------------}	procedure checkcontchar (thedialog: Dialogptr; ic: integer);{Checks continuous character to see that no missing data or too big data in terminal taxa}	begin		if ContinuousComplete(ic, false) then			SetDLOGText(theDialog, 10, '(Complete)', false)		else			SetDLOGText(theDialog, 10, '(Incomplete)', false);	end;{-----------------------------------------------------------------------------}	procedure ShowContState (TheDialog: dialogptr);{gets states from list in Edit Continuous and places into Enter box}		var			onefound: boolean;			j, datalen: integer;			thecell: point;			box: RECT;			ds: str255;	begin		SetPt(thecell, 0, 0);		onefound := false;		j := 0;		ds := '';		while j < numtaxa do			begin				thecell.v := j;				if LGetSelect(false, theCell, contlist) then					begin						if onefound then							begin								ds := '';								j := numtaxa;							end						else							begin								datalen := 128;								ds := '                                                                                                                                ';								onefound := true;								LGetCell(Pointer(ord4(@ds) + 1), datalen, thecell, contlist);								if pos(':', ds) > 0 then									begin										delete(ds, 1, pos(':', ds));										StripBlanks(ds);										while (length(ds) > 0) & (ds[1] = ' ') do											delete(ds, 1, 1);									end								else									ds := '';							end;					end;				j := j + 1;			end;		SetDLOGText(theDialog, 4, ds, true);	end;{-----------------------------------------------------------------------------}	function GetContString (contmin, contmax: single): str255;		var			rs, ds: str255;	begin		if not toobigtoosmall(contmin) then			begin				RealTostring(contmin, ds, 10000, 4, true);				if not toobigtoosmall(contmax) then					begin						RealTostring(contmax, rs, 10000, 4, true);						ds := concat(ds, ' to ', rs);					end;				GetContString := ds;			end		else			GetContString := '';	end;{-----------------------------------------------------------------------------}	procedure ComposeContListItem (tname: str255; contmin, contmax: single; var ds: str255);{prepares continuous list}		var			rs: str255;			addblanks: integer;	begin		ds := tname;		UnderLineToBlanks(ds);		if not toobigtoosmall(contmin) then			begin				addblanks := (140 - stringwidth(ds)) div 4;				ds := concat(ds, ':     ', GetContString(contmin, contmax));				if addblanks > 0 then					insert(CopyString('                                                                                                ', 1, addblanks), ds, pos(':', ds) + 1)				else if pos(':', ds) > 16 then					delete(ds, 16, pos(':', ds) - 16);			end;	end;{-----------------------------------------------------------------------------}	procedure FullStripNewLinesAndTabs (var stripstr: str255);{strips blanks from the end of the string stripstr}		var			ir: integer;	begin		ir := length(stripstr);		if ir > 0 then			while ((stripstr[ir] = chr(13)) | (stripstr[ir] = chr(10)) | (stripstr[ir] = chr(9))) & (ir >= 1) do				begin					delete(stripstr, ir, 1);					ir := ir - 1;				end;	end;{-----------------------------------------------------------------------------}	procedure SetContinuousToGCBias;	var it: integer;		TaxonHdl: thdl;		icont: integer;		value: single;		dL, dL2: longint;	begin		if not FirstEmptyCont(icont) then			begin				SysBeep(2);				Exit(SetContinuousToGCBias);			end;		for it := 1 to numTaxa do			begin				TaxonHdl := gettaxonHdl(it);				dL := NumOfStateInTaxon(it,1,false)+NumOfStateInTaxon(it,2,false);				dL2 := (TotalNumStateCells(it,false));				 if dL2 > 0 then				 	begin				 		value := 1.0* dL/dL2; 						TaxonHdl^^.contsmin[icont] := value;						//TaxonHdl^^.contsmax[icont] := 0.5;				 	end;			end;	end;{-----------------------------------------------------------------------------}	procedure SetContState (ds: str255; var badcEnter: boolean);{used when ENTER or TAB hit, to enter requested states}		var			TaxonHdl: thdl;			co, iww, j: integer;			locto: integer;			thecell: point;			contmin, contmax, c: single;			rs: str255;			tname: str128;	begin		badcEnter := false;		if length(ds) > 0 then			begin				if ds = '?' then					begin						contmin := -1;						contmax := -1;					end				else					begin						ds := MakeCaps(ds);						locto := pos('TO', ds);						if locto > 0 then							begin								contmin := tokentoReal(CopyString(ds, 1, locto - 1));								contmax := tokentoReal(CopyString(ds, locto + 2, length(ds)));							end						else if (pos('e', ds) > 0) | (pos('E', ds) > 0) then							begin								co := 0;								for iww := 1 to length(ds) do									if ds[iww] in ['e', 'E'] then										co := co + 1;								if co > 1 then									Beep								else									begin										contmin := tokenToReal(ds);										contmax := -1;									end;							end						else							begin								locto := pos('-', ds);								if locto > 0 then									begin										contmin := tokentoReal(CopyString(ds, 1, locto - 1));										contmax := tokentoReal(CopyString(ds, locto + 1, length(ds)));									end								else									begin										contmin := tokenToReal(ds);										contmax := -1;									end;							end;						if contmin = contmax then							contmax := -1;						if (contmax >= 0) and (contmax < contmin) then {switching if typed larger then smaller}							begin								c := contmax;								contmax := contmin;								contmin := c;							end;					end;				if (ds = '?') or not toobigtoosmall(contmin) then					begin						SetPt(thecell, 0, 0);						j := 0;						while j < numtaxa do							begin								thecell.v := j;								if LGetSelect(false, theCell, contlist) then									begin										TaxonHdl := gettaxonHdl(j + 1);										tname := taxonHdl^^.name;										ComposeContListItem(tname, contmin, contmax, ds);										LSetCell(Pointer(ord4(@ds) + 1), length(ds), thecell, contlist);										taxonHDL^^.contsmin[icontedit] := contmin;										taxonHDL^^.contsmax[icontedit] := contmax;									end;								j := j + 1;							end;						badcEnter := false;					end				else					begin						badcEnter := true;						Beep;					end;			end;	end;{-----------------------------------------------------------------------------}	procedure SetContStateEntered (TheDialog: dialogptr; var badcEnter: boolean);{used when ENTER or TAB hit, to enter requested states}		var			TaxonHdl: thdl;			co, iww, j: integer;			locto: integer;			thecell: point;			contmin, contmax, c: single;			ds, rs: str255;			tname: str128;	begin		ds := GetEditText(theDialog, 4);		StripBlanks(ds);		FullStripNewLinesAndTabs(ds);		 		 SetContState(ds,badcEnter);	end;{----------------------------------------------------------------------------}	procedure ContinuousEnter (theDialog: DialogPtr; var badcEnter: boolean);{called when ENTER or TAB hit, to enter requested states}	begin		if icontedit > numcontinuous then			numcontinuous := icontedit;		SetContStateEntered(theDialog, badcEnter);		CheckContChar(theDialog, icontedit);{FROZEN 3.0}		if icontedit = icont then			golist := golist + [GOcontinuous];{traced char edited; redo continuous calculations}		dirtyfile := true;	end;{----------------------------------------------------------------------------}	procedure ContinuousDeleteData (theDialog: DialogPtr);	var badCEnter: boolean;	begin		if icontedit > numcontinuous then			numcontinuous := icontedit;		SetContState('?', badcEnter);		CheckContChar(theDialog, icontedit);{FROZEN 3.0}		if icontedit = icont then			golist := golist + [GOcontinuous];{traced char edited; redo continuous calculations}		dirtyfile := true;	end;{----------------------------------------------------------------------------}	var		ContinuousScroll: ControlRef;		isContOptions: boolean;{-----------------------------------------------------------------------------}	procedure DrawContNumber;{draws character number beside scrollbar}		var			box: rect;			ds: str255;			ic: integer;	begin		box := myGetControlRect(ContinuousScroll);		Offsetrect(box, -25, 0);		box.right := box.left + 25;		Eraserect(box);		if isContOptions then			icont := GetControlValueLong(ContinuousScroll)		else			icontedit := GetControlValueLong(ContinuousScroll);{$IFC TRUE}		if isContOptions & not Continuouscomplete(icont, true) then			begin				ic := icont;				if not scrollup then					begin						repeat							ic := ic + 1;						until (ic > mncontinuous) | ContinuousComplete(ic, true);						if ic > mncontinuous then							repeat								ic := ic - 1;							until (ic = 1) or ContinuousComplete(ic, true);					end				else					begin						repeat							ic := ic - 1;						until (ic < 1) | ContinuousComplete(ic, true);						if ic < 1 then							repeat								ic := ic + 1;							until (ic > mncontinuous) | ContinuousComplete(ic, true);					end;				if ic <= mncontinuous then  {v3.05}					icont := ic;				SetControlValueLong(ContinuousScroll, icont);			end;{$ENDC}		if isContOptions then			NumToString(icont, ds)		else			NumToString(icontedit, ds);		TETextBox(Pointer(ord4(@ds) + 1), length(ds), box, teJustCenter);	end;{----------------------------------------------------------------------------}	procedure ContinuousSBar (whichControl: ControlRef; theCode: INTEGER);{scroll bar function}	begin		if scrollup then			begin				if theCode = kControlUpButtonPart then					begin						SetControlValueLong(whichControl, GetControlValueLong(whichControl) - 1);						DrawContNumber					end			end		else if theCode = kControlDownButtonPart then			begin				SetControlValueLong(whichControl, GetControlValueLong(whichControl) + 1);				DrawContNumber			end;		Delay(8, ticks);	end;{----------------------------------------------------------------------------}	procedure setEditToNewContChar (theDialog: DialogPtr; var theCell: point);		var			j: integer;			TaxonHdl: thdl;			tname: str128;			ds: str255;	begin		SetDLOGText(theDialog, 4, '', false);		thecell.h := 0;		thecell.v := 0;		for j := 1 to numtaxa do			begin				TaxonHdl := gettaxonHdl(j);				tname := taxonHdl^^.name;				ComposeContListItem(tname, taxonHDL^^.contsmin[icontedit], taxonhdl^^.contsmax[icontedit], ds);				LSetCell(Pointer(ord4(@ds) + 1), length(ds), thecell, contlist);				thecell.v := thecell.v + 1;			end;		LSetDrawingMode(TRUE, contlist);	end;{----------------------------------------------------------------------------}	procedure DoContinuousScroll (where: point; whichWindow: WindowPtr; whichControl: ControlRef);		var			t: integer;	begin		case code of			kControlUpButtonPart: 				begin					scrollup := true;					t := myTrackControl(continuousScroll, where, ScrollContinuousUpDownUPP);				end;			kControlDownButtonPart: 				begin					scrollup := false;					t := myTrackControl(continuousScroll, where, ScrollContinuousUpDownUPP);				end;			kControlPageUpPart: 				repeat					GetMouse(wh);					if TestControl(continuousScroll, wh) = code then						begin							SetControlValueLong(continuousScroll, GetControlValueLong(continuousScroll) - 5);							DrawContNumber;						end				until not StillDown;			kControlPageDownPart: 				repeat					GetMouse(wh);					if TestControl(continuousScroll, wh) = code then						begin							SetControlValueLong(continuousScroll, GetControlValueLong(continuousScroll) + 5);							DrawContNumber						end				until not StillDown;			kControlIndicatorPart: 				begin					t := myTrackControl(continuousScroll, where, nil);					DrawContNumber;				end;			otherwise				;		end;	end;{----------------------------------------------------------------------------}	function ContEditFilter (theDialog: DialogPtr; var Event: EventRecord; var localItemHit: INTEGER): BOOLEAN;{filter for list in continuous editor dialog box}		var			MouseLoc: Point;			WindoLoc, MyControl, testctl, t, j, lastsel, ib, oldi: integer;			dbc: boolean;			trect: Rect;			thecell: point;			whichList, otherlist: integer;			badcEnter: boolean;	begin		MouseLoc := Event.Where;		WindoLoc := FindWindow(MouseLoc, Whichwindow);		ContEditFilter := FALSE;		if (Event.what = keyDown) | (Event.what = autoKey) then			{if ((event.message mod 256) = 13) then  				begin					localItemHit := PressButton(theDialog, 1);					ContEditFilter := true;				end			else }if ((event.message mod 256) = 9) | ((event.message mod 256) = 13) then				begin					ContinuousEnter(theDialog, badcEnter);					if not badcEnter then						begin							thecell.h := 0;							for j := 0 to numtaxa - 1 do								begin									thecell.v := j;									if LGetSelect(false, theCell, contlist) then										begin											LSetSelect(false, thecell, contList);											lastsel := j;										end;								end;							if lastsel < numtaxa - 1 then								begin									thecell.v := lastsel + 1;									LSetSelect(true, thecell, contList);									SelectDialogItemText(thedialog, 4, 0, 32000);									LAutoScroll(contList);								end							else								Beep;													end;					localItemHit := NotInDialog;					ContEditFilter := TRUE;				end			else if ((event.message mod 256) = 3) then				begin					ContinuousEnter(theDialog, badcenter);					localItemHit := NotInDialog;					ContEditFilter := TRUE;				end;		if (Event.what = mouseDown) then			begin				GlobalToLocal(Event.where);				trect := myGetControlRect(ContinuousScroll);				if PtinRect(Event.where, trect) then					begin						oldi := icontedit;						code := FindControl(Event.where, whichWindow, whichControl);						localItemHit := NotinDialog;						ContEditFilter := TRUE;						if whichControl<> nil then DoContinuousScroll(Event.where, whichwindow, whichControl);						if oldi <> icontedit then							begin								SetEdittoNewContChar(theDialog, theCell);								CheckContChar(TheDialog, icontedit);							end;					end				else if PtInRect(Event.where, fullrect) or PtInRect(Event.where, fullrect) then					begin						dbc := LClick(Event.where, event.modifiers, contlist);						if PtinRect(Event.where, contrect) then							begin								SetPt(thecell, 0, 0);								ShowContState(theDialog);							end;						ContEditFilter := TRUE;						localItemHit := NotInDialog;					end;				LocaltoGlobal(Event.where);			end;	end;{-----------------------------------------------------------------------------}	procedure DrawContList (theDialog: DialogPtr; itemNo: INTEGER);	begin		{FrameButton(theDialog, 1);}		Lupdate(myGetVisRgn(myGetWindowPtrForDialog(theDialog)), contlist);		DrawContNumber;		FrameRect(contrect);	end;{-----------------------------------------------------------------------------}	procedure ContinuousEdit;{Edits states of continuous characters}		label			1;		var			TaxonHdl: thdl;			theDialog: DialogPtr;			itemtype: integer;			tempP: WindowPtr;			tempH: Handle;			box: rect;			cellsize, thecell, tocell: point;			databounds: rect;			nexttax, firstrow, j, di, k, it: integer;			ds, rs: str255;			datalen: integer;			tname: str128;			badcenter: boolean;			localItemHit: integer;UserItemUProcP: UniversalProcPtr;DLOGFilterUPP: UniversalProcPtr;	begin		isContOptions := false;		StartDLOG(700, theDialog, tempP);		SetRect(box, 269, 5, 362, 21);		ContinuousScroll := NewControl(myGetWindowPtrForDialog(theDialog), box, ' ', true, icont, 1, mncontinuous, scrollBarProc, 5);		icontedit := icont;		contrect := GetDLOGItemBox(theDialog, 5);{SetRect(contrect, 16, 47, 343, 184);}		fullrect := contrect;		fullrect.right := fullrect.right + 15;		cellsize.h := contrect.right - contrect.left;		cellsize.v := 15;		SetRect(databounds, 0, 0, 1, 0);		contlist := LNew(contrect, databounds, cellsize, 0, myGetWindowPtrForDialog(theDialog), false, false, false, true);		InsetRect(contrect, -1, -1);		LSetDrawingMode(FALSE, contlist);		firstrow := LAddRow(numtaxa, 0, contlist);		thecell.h := 0;		thecell.v := 0;		for j := 1 to numtaxa do			begin				TaxonHdl := gettaxonHdl(j);				tname := taxonHdl^^.name;				ComposeContListItem(tname, taxonHDL^^.contsmin[icontedit], taxonhdl^^.contsmax[icontedit], ds);				LSetCell(Pointer(ord4(@ds) + 1), length(ds), thecell, contlist);				thecell.v := thecell.v + 1;			end;		CheckContChar(theDialog, icontedit);		LSetDrawingMode(TRUE, contlist);		SetDLOGText(theDialog, 4, '', false);UserItemUProcP := MyNewUserItemUPP(@DrawContList);  tempH := Handle(UserItemUProcP);		SetDialogItem(theDialog, 5, UserItem, tempH, contrect);		myShowDialog(theDialog);		ShowControl(ContinuousScroll);		DoActivateControl(ContinuousScroll);		DLOGFilterUPP := MyNewModalFilterUPP(@ContEditFilter);  1:		repeat			myModalDialog(DLOGFilterUPP, localItemHit);			case localItemHit of				6: 	{enter}					ContinuousEnter(theDialog, badcenter);				9:    {deselect}					begin						for j := 0 to numtaxa - 1 do							begin								thecell.v := j;								LSetSelect(false, thecell, contList);							end;					end;				11: 					begin						ContinuousDeleteData(theDialog);						SetDLOGText(theDialog, 4, '', false);					end;				otherwise					;			end;		until localItemHit = 1;		if localitemhit = 1 then			ContinuousEnter(theDialog, badcenter);  		LDispose(contlist);MyDisposeModalFilterUPP(DLOGFilterUPP);MyDisposeUserItemUPP(UserItemUProcP);		EndDLOG(theDialog, tempP);		AdjustAllNexusBlockWillWrites;	end;{----------------------------------------------------------------------------}	function ContOptionsFilter (theDialog: DialogPtr; var Event: EventRecord; var localItemHit: INTEGER): BOOLEAN;{filter for list in continuous options dialog box}		var			MouseLoc: Point;			WindoLoc, MyControl, testctl, t, j, lastsel, ib, oldi: integer;			dbc: boolean;			trect: Rect;			thecell: point;			whichList, otherlist: integer;			badcEnter: boolean;	begin		MouseLoc := Event.Where;		WindoLoc := FindWindow(MouseLoc, Whichwindow);		ContOptionsFilter := FALSE;		if (Event.what = keyDown) then			if ((event.message mod 256) = 13) then   {only return key, not enter}				begin					localItemHit := PressButton(theDialog, 1);					ContOptionsFilter := true;				end;		if (Event.what = mouseDown) then			begin				GlobalToLocal(Event.where);				trect := myGetControlRect(ContinuousScroll);				if PtinRect(Event.where, trect) then					begin						oldi := icont;						code := FindControl(Event.where, whichWindow, whichControl);						localItemHit := NotinDialog;						ContOptionsFilter := TRUE;						if whichControl<> nil then DoContinuousScroll(Event.where, whichWindow, whichControl);						if oldi <> icont then							begin								if not ContinuousComplete(icont, true) then									begin   {Wayne: disable some items - I suspect this is not needed as can't scroll here}									end;							end;					end;				LocaltoGlobal(Event.where);			end;	end;{-----------------------------------------------------------------------------}	procedure CheckContinuousOptions (theDialog: DialogPtr);	begin		ItemCheckMark(theDialog, 5, continuousmode = sqrooted);		ItemCheckMark(theDialog, 6, continuousmode = squnrooted);{$IFC CONTRASTS}		ItemCheckMark(theDialog, 18, continuousmode = sqFelsX);		ItemCheckMark(theDialog, 20, continuousmode = sqFelsContrast);		ItemCheckMark(theDialog, 21, continuousmode = sqFelsContrastSTD);		ItemCheckMark(theDialog, 19, contweighted);{$ENDC}		ItemCheckMark(theDialog, 7, continuousIsManhattan);		ItemCheckMark(theDialog, 4, not continuousIsManhattan);		ItemCheckMark(theDialog, 8, continuousmode = manhattan);		ItemCheckMark(theDialog, 9, continuousmode = manhatmin);		ItemCheckMark(theDialog, 10, continuousmode = manhatmax);		EnableDisableDLOGItem(theDialog, 1, ContinuousLegal(false), false);		EnableDisableDLOGItem(theDialog, 5, not continuousIsManhattan, true);		EnableDisableDLOGItem(theDialog, 6, not continuousIsManhattan, true);		EnableDisableDLOGItem(theDialog, 8, continuousIsManhattan, false);		EnableDisableDLOGItem(theDialog, 9, continuousIsManhattan, false);		EnableDisableDLOGItem(theDialog, 10, continuousIsManhattan, false);{$IFC CONTRASTS}		EnableDisableDLOGItem(theDialog, 18, not continuousIsManhattan, true);		EnableDisableDLOGItem(theDialog, 19, not continuousIsManhattan, true);		EnableDisableDLOGItem(theDialog, 20, not continuousIsManhattan, true);		EnableDisableDLOGItem(theDialog, 21, not continuousIsManhattan, true);{$ENDC}	end;{-----------------------------------------------------------------------------}	procedure ContinuousOptions;{Trace continuous dialog box; chooses options, character and turns on trace}		label			1;		var			theDialog: DialogPtr;			oldicont, oldcontinuousmode, oldsigcontinuous: integer;			oldweighted: boolean;			tempP, tport: WindowPtr;			box: rect;			H: Handle;			ir: integer;			itemtype, tempsig: integer;			localItemHit: integer;DLOGFilterUPP: UniversalProcPtr;{.....}		procedure GrabContinuousText;		begin			tempsig := EditTextInt(thedialog, 12,true);			if (tempsig < 1) or (tempsig > 4) then				begin					InstantError(249);					goto 1;				end			else				sigcontinuous := tempsig;		end;{.....}	begin		isContOptions := true;		oldicont := icont;		oldcontinuousmode := continuousmode;		oldweighted := contweighted;		oldsigcontinuous := sigcontinuous;		if continuousIsManhattan & nullson then			continuousmode := sqrooted;		StartDLOG(569, theDialog, tempP);		SetDLOGText(theDialog, 12, StringFromNum(sigcontinuous), true);		SelectDialogItemText(theDialog, 12, 0, 32767);		SetRect(box, 319, 5, 412, 21);		ContinuousScroll := NewControl(myGetWindowPtrForDialog(theDialog), box, ' ', true, icont, 1, mncontinuous, scrollBarProc, 5);		CheckContinuousOptions(theDialog);		myShowDialog(theDialog);		DrawContNumber;		ShowControl(ContinuousScroll);		DoActivateControl(ContinuousScroll);1:		FrameButton(theDialog, 1);		DLOGFilterUPP := MyNewModalFilterUPP(@ContOptionsFilter);  		repeat			myModalDialog(DLOGFilterUPP, localItemHit);			case localItemHit of				4: 					if continuousismanhattan then						continuousmode := sqrooted;				5: 					continuousmode := sqrooted;				6: 					continuousmode := squnrooted;				7: 					if not continuousismanhattan then						continuousmode := manhattan;				8:  {full range}					continuousmode := manhattan;				9:  {smallest from root}					continuousmode := manhatmin;				10:  {largest from root}					continuousmode := manhatmax;				17: 					begin						GrabContinuousText;						SetDialogValuesAsDefaults(theDialog, continuousid, 0, 0);					end;{$IFC CONTRASTS}				18: 					continuousmode := sqFelsX;  {Felsenstein's X's}				19: 					contweighted := not contweighted;				20:   {Felsenstein's contrasts}					continuousmode := sqFelsContrast;				21:   {Felsenstein's contrasts}					continuousmode := sqFelsContrastSTD;{$ENDC}				otherwise					;			end;			CheckContinuousOptions(theDialog);		until localItemHit in [1, 2, 14];		if localitemhit in [1, 14] then			GrabContinuousText;		MyDisposeModalFilterUPP(DLOGFilterUPP);		EndDLOG(theDialog, tempP);		InvalidateWindow(chlegwindow, true);		if localItemHit = 2 then			begin				continuousmode := oldcontinuousmode;				contweighted := oldweighted;				icont := oldicont;				sigcontinuous := oldsigcontinuous;			end		else			begin				if (oldsigcontinuous <> sigcontinuous) and showconttracelabels then					godraw := true;				if localItemHit = 1 then					begin						if not (traceshown = traceContinuous) then							TurnOnContinuous;{FROZEN 3.0}						if (continuousmode <> oldcontinuousmode) or (oldicont <> icont) or (oldweighted <> contweighted) then {ввв}							golist := golist + [GOcontinuous];{do continuous calculations}					end				else if localItemHit = 14 then					begin						if (traceshown = traceContinuous) then							turnoffcontinuous(true);					end;			end;	end;end.