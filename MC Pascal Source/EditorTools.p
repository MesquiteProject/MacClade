unit EditorTools;{ееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, 		Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, 		Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, 		WindowUtil, ErrorUtil, EventUtil, GenUtil, 		StrUtil, BoxUtil, TaxonCHUtil, CharUtil, MenuUtil, 		SymbolsNames, TreeUtil, Fill, SpreadUtil, Footnote, DrawSpread, RowColumn, 		StatesWindow, ScrollSpread, CopyPaste, MCWindows, ToolPalette, 		MoveData, BlockMoveTool, StampPasteTool, EditorUndo, AutoAlign, MoveInfoRows,EditorCellEntry;			procedure PopUpStatesMenu(wh: point; clickTaxon,clickChar: integer);	procedure ShiftSelection(direction, amount: integer);	function MouseInAAPartofNucleotideCell(wh: point): boolean;	procedure StandardClickInSingleCell(Event: EventRecord; oldTL, oldBR: point);	procedure ToolInDataEditor(whichTool, clickTaxon,clickChar: integer; clickCell: point; Event: EventRecord);{$SETC PUSHEXPAND=TRUE}	var		shimmerBlockOn: boolean;{ееееееееееееееееееееее}implementation {е$S EditControl}{-----------------------------------------------------------------------------}	procedure FillCellBlockWithState (fillStates: largestSetChars; st, et, sc, ec: integer; fillMode: integer; restrictFill: boolean; stateOfCellsToFill: largestSetChars; fillFraction: integer);{fills the selected block in the spreadsheet with the char fillchar}		var			charHdl: chHdl;			it, ic, ist, maxist: integer;			okchar: boolean;			newset, tsts: largestsetchars;	begin		okchar := true;		if st < 1 then st := 1;		if sc < 1 then sc := 1;		{if (fillFraction=defaultFillFraction)|(RandomBetween(1, defaultFillFraction)<=fillFraction) then ;}		case fillMode of			paintBucketNormalMode:				begin										if fillStates = [MSl] then						for it := st to et do							for ic := sc to ec do								begin									if CellMatchesStateToFill(it,ic,stateOfCellsToFill) then										if (fillFraction=defaultFillFraction)|(RandomBetween(1, defaultFillFraction)<=fillFraction) then											settaxonstsLargestOverwriteCase(it, ic, [MSl]);								end					else if fillStates = [msl,gal] then						for it := st to et do							for ic := sc to ec do								begin									if CellMatchesStateToFill(it,ic,stateOfCellsToFill) then										if (fillFraction=defaultFillFraction)|(RandomBetween(1, defaultFillFraction)<=fillFraction) then											settaxonstsLargestOverwriteCase(it, ic, [MSl, GAl]);								end					else if fillStates = [] then			{fill with same state as first taxon}						begin							for ic := sc to ec do								begin									tsts := gettaxonstsLargest(editorPaintReferenceTaxon, ic);									for it := st to et do										if it <> editorPaintReferenceTaxon then											if CellMatchesStateToFill(it,ic,stateOfCellsToFill) then												if (fillFraction=defaultFillFraction)|(RandomBetween(1, defaultFillFraction)<=fillFraction) then													settaxonstsLargestOverwriteCase(it, ic, tsts);								end;						end					else						begin							for ic := sc to ec do								begin									if not MakeLegalSet(fillStates, newset, ic) then										cycle;									Maxist := Maxlg(newset);									charHdl := getchHdl(ic);									if charHdl^^.maxst < Maxist then										charHdl^^.maxst := Maxist;									for it := st to et do										if CellMatchesStateToFill(it,ic,stateOfCellsToFill) then											if (fillFraction=defaultFillFraction)|(RandomBetween(1, defaultFillFraction)<=fillFraction) then												settaxonstsLargestOverwriteCase(it, ic, newset);								end						end;				end;			paintBucketRandomMode:				FillBlockWithRandom(st, et, sc, ec, restrictFill,stateOfCellsToFill,fillFraction);			paintBucketFillObservedStatesMode:				begin					RandomStatesH := RandomObservedFillH;					RandomMax := RandomObservedFillMax;					FillRandomWithObsStates(st, et, sc, ec,restrictFill,stateOfCellsToFill,fillFraction);				end;			paintBucketFillObservedFreqMode:				begin					RandomStatesH := RandomObservedFillH;					RandomMax := RandomObservedFillMax;					FillRandomWithObsFreq(st, et, sc, ec,restrictFill,stateOfCellsToFill,fillFraction);				end;			otherwise;		end;					if okchar then			SetDirtyEditor(true);		CheckRedrawFullCharactersInEditor(st,et,sc,ec,true);	end;{----------------------------------------------------------------------------}	procedure PopUpStatesMenu(wh: point; clickTaxon,clickChar: integer);		var			menucode: longint;			ItemNo, currentsel, row,column: integer;			st,et,sc,ec: integer;			TempMHdl: MenuHandle;			success, inPaletteWindow, isCharacterName, isTaxonName, doStatesMenu: boolean;			is: integer;			theSpot, TL, BR: Point;			ds: str255;			totalItems: integer;			stateSet: LargestSetChars;			inFillOptions: boolean;			oldState: SignedByte;	begin		inPaletteWindow:= clickChar = -2;		inFillOptions := clickChar = -3;		isCharacterName := false;		isTaxonName := false;		doStatesMenu := false;		theSpot := wh;		TempMHdl := nil;		TempMHdl := NewMenu(TemporaryMenu, 'Temp');		if TempMHdl= nil then			begin				InstantInfo('Problems creating pop-up menu');				 Exit(PopUpStatesMenu);			end;		InsertMenu(TempMHdl, -1);		currentsel := 1;		if inFillOptions or  inPaletteWindow then			begin				if inFillOptions then					begin						if paintBucketFillCellsWithState=[] then							currentSel := 1						else if paintBucketFillCellsWithState = [MSl] then							currentsel := maxstate+1						else if paintBucketFillCellsWithState = [MSl,GAl] then							currentsel := maxstate+2						else if paintBucketFillCellsWithState = [ERl] then							currentsel := maxstate+3						else							currentsel := MinLg(paintBucketFillCellsWithState)+1;					end;				doStatesMenu := true;				for is := 0 to maxstate do					AppendLiteralMenuItem(TempMHdl, symbols[is+1]);			end		else   {it's the data editor}			begin				RowColumnFromTaxonCharacter(clickTaxon,clickChar,row,column);				{if ((clickTaxon = 0) &  (clickChar > 0)) & editorSelected & CellInSelection(row,column)  then 					begin						isCharacterName := true;					end				else} if ((clickTaxon > 0) &  (clickChar = 0)) & editorSelected & CellInSelection(row,column)  then { taxon name}					begin						isTaxonName := true;						AppendLiteralMenuItem(TempMhdl,'A,B,C,...');						AppendLiteralMenuItem(TempMhdl,'taxon 1, taxon 2,...');						AppendLiteralMenuItem(TempMhdl,'This cannot be undone!');						SetItemStyle(TempMhdl,3,[italic]);						myDisableItem(TempMhdl,3);					end				else if IsDataCell(clickTaxon,clickChar) | ((clickTaxon > 0) &  (clickChar = -1)) | ((clickTaxon =-1) &  (clickChar> 0))  then					begin						doStatesMenu := true;						if editorSelected & (CharOfCell(editorSelectionTopLeft)<>CharOfCell(editorSelectionBotRight)) then							begin								for is := 0 to maxstate do									AppendLiteralMenuItem(TempMHdl, symbols[is+1]);							end							else							for is := 0 to maxstate do								begin									ds:= CharStateName(clickChar, is);									if ds <> '' then										AppendLiteralMenuItem(TempMHdl, concat(symbols[is+1],': ',ds))									else										AppendLiteralMenuItem(TempMHdl, symbols[is+1]);								end;					end;			end;		if doStatesMenu then			begin				AppendLiteralMenuItem(TempMHdl, gap);				AppendLiteralMenuItem(TempMHdl, missing);				if inFillOptions then					AppendLiteralMenuItem(TempMHdl, concat('not (',missing,' or ',gap,')'));			end;		totalItems:= myCountMenuItems(TempMHdl) ;		LocalToGlobal(thespot);		menucode := PopUpMenuSelect(TempMHdl, thespot.v + 5, thespot.h, currentsel);		ItemNo := LowWord(menucode);		if doStatesMenu then			begin				stateSet := [];				if (ItemNo = totalItems) then					if inFillOptions then						stateSet := [ERl]					else						stateSet := [MSl]				else if ItemNo = totalItems-1 then					if inFillOptions then						stateSet := [MSl]					else						stateSet := [MSl, GAl]				else if inFillOptions & (ItemNo = totalItems-2) then					stateSet := [MSl, GAl]				else if ItemNo > 0 then					stateSet := [ItemNo-1];			end;		 if ItemNo > 0 then			if inFillOptions then				begin					paintBucketFillCellsWithState := stateSet;				end			else if  inPaletteWindow then				begin					paintBucketPaint := stateSet;					InvalidateWindow(toolPaletteWindow[editorTools], false);				end			else 				begin					if isTaxonName then						begin							if CWarning('Filling names cannot be undone. Do you want to proceed?','Proceed','Cancel') then								if itemNo = 1then									FillTaxonNames(TaxonOfCell(editorSelectionTopLeft),TaxonOfCell(editorSelectionBotRight), true,'',false,0,false)								else									FillTaxonNames(TaxonOfCell(editorSelectionTopLeft),TaxonOfCell(editorSelectionBotRight), false, 'taxon ',true,TaxonOfCell(editorSelectionTopLeft),false);						end					else if doStatesMenu then						begin							st := clickTaxon;							et := clickTaxon;							sc := clickChar;							ec := clickChar;							if editorSelected & CellInSelection(row,column) then								begin									sc := CharOfCell(editorSelectionTopLeft);									ec := CharOfCell(editorSelectionBotRight);									st := TaxonOfCell(editorSelectionTopLeft);									et := TaxonOfCell(editorSelectionBotRight);									if SingleCell then										begin											StoreSelectedSingleCellForUndo;											settaxonstsLargestOverwriteCase(st, sc, stateSet);											LockHandle(editorCellTE, oldState);											FillsTE(editorCellTE, CellString);											MovesTE;											EndSetUpEdit(editorCellTE);											ResetHandle(editorCellTE, oldState);											dirtymaxst := true;											SetDirtyEditor(true);											{TEUpdate(editorSelectionRect, editorCellTE);}										end									else										begin											if not StoreCellBlockForUndo(st,et,sc,ec, false,false,false) then Exit(PopUpStatesMenu);											FillCellBlockWithState (stateSet,st,et,sc,ec,paintBucketNormalMode,false,[],1000);											DrawDataCellsBetweenCorners(editorSelectionTopLeft,editorSelectionBotRight,selectionModeAsIs);										end;								end							else if clickTaxon = -1 then								begin									st := 1;									et := numtaxa;									if not StoreCellBlockForUndo(st,et,sc,ec, false,false,false) then Exit(PopUpStatesMenu);									FillCellBlockWithState (stateSet,1,numTaxa,clickChar,clickChar,paintBucketNormalMode, false,[],1000);									RowColumnFromTaxonCharacter(1,clickChar,TL.v,TL.h);									RowColumnFromTaxonCharacter(numtaxa,clickChar,BR.v,BR.h);									DrawDataCellsBetweenCorners(TL,BR,selectionModeAsIs);								end							else if clickChar = -1 then								begin									sc := 1;									ec := numchars;									if not StoreCellBlockForUndo(st,et,sc,ec, false,false,false) then Exit(PopUpStatesMenu);									FillCellBlockWithState (stateSet,clickTaxon,clickTaxon,1,numChars,paintBucketNormalMode, false,[],1000);									RowColumnFromTaxonCharacter(clickTaxon,1,TL.v,TL.h);									RowColumnFromTaxonCharacter(clickTaxon,numChars,BR.v,BR.h);									DrawDataCellsBetweenCorners(TL,BR,selectionModeAsIs);								end							else								begin									if not StoreCellBlockForUndo(st,et,sc,ec, false,false,false) then Exit(PopUpStatesMenu);									FillCellBlockWithState (stateSet,clickTaxon,clickTaxon,clickChar,clickChar,paintBucketNormalMode, false,[],1000);									WriteTaxonCharacterCell(clickTaxon,clickChar,false,writeStandardCells,selectionModeAsIs);								end;								CheckRedrawFullCharactersInEditor(st,et,sc,ec,true);							{RedrawAATranslationBlock(st,et,sc,ec);}						end;					end;		DeleteMenu(TemporaryMenu);		DisposeMenu(TempMHdl);	end;{----------------------------------------------------------------------------}	function WandDifferentFromOriginal(it,ic: integer; tsts: LargestSetChars; treatMissingAsGaps: boolean): boolean;	begin		if tsts = [MSl,GAl] then			WandDifferentFromOriginal := IsGapLike(it,ic,treatMissingAsGaps)		else			WandDifferentFromOriginal := gettaxonStsLargest(it,ic) <> tsts;	end;{----------------------------------------------------------------------------}	procedure FindSequencePiece(it,icOriginal: integer; var icstart, icend: integer; selectEntireSequence, treatMissingAsGaps: boolean);	var ic: integer;		tsts : largestSetChars;	begin		ic:= icOriginal;		icStart := ic;		icEnd := ic;				 if IsGapLike(it, icOriginal,treatMissingAsGaps) then			begin				if (ic > 1) & IsGapLike(it,ic-1,treatMissingAsGaps) then					begin 						repeat							ic := ic-1;						until (ic < 1) | not IsGapLike(it,ic,treatMissingAsGaps);						ic := ic+1;						icStart := ic;					end;				if (ic < numchars) & IsGapLike(it,ic+1,treatMissingAsGaps) then					begin 						repeat							ic := ic+1;						until (ic >numchars) | not IsGapLike(it,ic,treatMissingAsGaps);						ic := ic-1;						icEnd := ic;					end;			end		else if selectEntireSequence then			begin				for ic := 1 to numchars do					if not IsGapLike(it,ic,treatMissingAsGaps) then						begin							icstart := ic;							leave;						end;				for ic := numchars downto 1 do					if not IsGapLike(it,ic,treatMissingAsGaps) then						begin							icend := ic;							leave;						end;			end		else  			begin				if editorMagicWandExactMatch then 					tsts := gettaxonstslargest(it,icOriginal)				else 					tsts := [MSL, GAl];				if (ic > 1) & not WandDifferentFromOriginal(it,ic-1,tsts,treatMissingAsGaps) then					begin 						repeat							ic := ic-1;						until (ic < 1) | WandDifferentFromOriginal(it,ic,tsts,treatMissingAsGaps);						ic := ic+1;						icStart := ic;					end;				if (ic < numchars) & not WandDifferentFromOriginal(it,ic+1,tsts,treatMissingAsGaps) then					begin 						repeat							ic := ic+1;						until (ic >numchars) | WandDifferentFromOriginal(it,ic,tsts,treatMissingAsGaps);						ic := ic-1;						icEnd := ic;					end;			end;			end;{----------------------------------------------------------------------------}	procedure PaintBucketInEditor;	var st,et,sc,ec: integer;		db: boolean;	begin		CalcSelectedTaxaCharacters(st, et, sc, ec,true);		if not StoreSelectedCellBlockForUndo(false,false,true) then Exit(PaintBucketInEditor);		FillCellBlockWithState (paintBucketPaint, st, et, sc, ec,paintBucketMode, true,paintBucketFillCellsWithState,paintBucketFillFraction);		CheckRedrawFullCharactersInEditor(st,et,sc,ec,true);		{RedrawAATranslationBlock(st, et, sc, ec);}	end;{----------------------------------------------------------------------------}	procedure TrackEditorPaintBrush(clickTaxon,clickChar: integer; Event: EventRecord);	var wh: point;		it,ic: integer;		oldit,oldic: integer;		st,et,sc,ec: integer;		firstChange: boolean;		cell: point;		lockTaxon,lockCharacter: integer;		constrainedTaxon, constrainedCharacter, db: boolean;	begin				if StillDown then			begin				if not StoreCellBlockForUndo(1, numtaxa, 1, numchars, false,false,false) then					Exit(TrackEditorPaintBrush);				st := clickTaxon;				et := clickTaxon;				sc := clickChar;				ec := clickChar;				FillCellBlockWithState (paintBucketPaint, clickTaxon, clickTaxon, clickChar, clickChar,paintBucketNormalMode, false,[],1000);				WriteTaxonCharacterCell(clickTaxon,clickChar,false,writeStandardCells,selectionModeAsIs);				 RedrawAATranslation(clickTaxon,clickChar);				 				 oldit := clickTaxon;				 oldic := clickChar;				 firstChange := true;				 lockTaxon := clickTaxon;				 lockCharacter := clickChar;				 constrainedTaxon := false;				 constrainedCharacter := false;				 repeat				 	GetMouse(wh);				 	FindTaxonCharacterInEditor(wh,it,ic);					If IsDataCell(it,ic) then 						if (it<>oldit) or (ic<>oldic) then							begin								if firstChange then									begin										if ShiftEvent(Event) then											begin												if ic<>oldic then													constrainedTaxon := true												else													constrainedCharacter := true;											end;										firstChange := false;									end;								if constrainedtaxon then it := lockTaxon;								if constrainedCharacter then ic := lockCharacter;								if (it<>oldit) or (ic<>oldic) then									begin										FillCellBlockWithState (paintBucketPaint,it,it,ic,ic,paintBucketNormalMode, false,[],1000);										if it < st then st := it else if it > et then et := it;										if ic < sc then sc := ic else if ic > ec then ec := ic;										WriteTaxonCharacterCell(it,ic,false,writeStandardCells,selectionModeAsIs);										RedrawAATranslation(it,ic);										{if AAAutoTranslationVisible then											begin												if editorTransposed then													begin														cell.v := ic;														cell.h := it;													end												else													begin														cell.v := it;														cell.h := ic;													end;												DrawAAfromDNACell(cell);											end;}									end;							end;					oldit := it;					oldic := ic;				 until not StillDown;				CheckRedrawFullCharactersInEditor (st,et,sc,ec,true);		 	end		 else		 	begin		 		StoreSelectedSingleCellForUndo;				FillCellBlockWithState (paintBucketPaint, clickTaxon, clickTaxon, clickChar, clickChar,paintBucketNormalMode, false,[],1000);				WriteTaxonCharacterCell(clickTaxon,clickChar,false,writeStandardCells,selectionModeAsIs);				RedrawAATranslation(clickTaxon,clickChar);				CheckRedrawFullCharactersInEditor ( clickTaxon, clickTaxon, clickChar, clickChar,true);		 	end;	end;{----------------------------------------------------------------------------}	procedure DoSelectToEnd(selectToEndOfTaxa,useOptTool: boolean; pinCell: point);	var st,et,sc,ec: longint;		lasttaxon, lastcharacter: longint;		selectWhole: boolean;	begin		selectWhole := false;		if selectToEndOfTaxa then			begin				st := 1;				et := numtaxa;				if not selectToEndIncludeTerminalGaps then					begin						sc := CharOfCell(editorSelectionTopLeft);						ec := CharOfCell(editorSelectionBotRight);						if (ec<=0) then  // we've touched on a taxon name or taxon number							begin								sc := 1;								ec := numChars;								selectWhole := true;							end;						if not editorTransposed then							lasttaxon := pinCell.v						else							lasttaxon := pinCell.h;						while (st <= lasttaxon) & CheckIfAllGaps(st,st,sc,ec, editorToolsTreatmissingAsGaps) do							st := st+1;						while (et >= lasttaxon) & CheckIfAllGaps(et,et,sc,ec, editorToolsTreatmissingAsGaps) do							et := et-1;					end;				if not editorTransposed then					begin						if useOptTool then							editorSelectionTopLeft.v := st						else							editorSelectionBotRight.v := et;						if selectWhole then							begin								editorSelectionTopLeft.h := 1;								editorSelectionBotRight.h := numChars;							end;											end				else 					begin						if useOptTool then							editorSelectionTopLeft.h := st						else							editorSelectionBotRight.h := et;						if selectWhole then							begin								editorSelectionTopLeft.v := 1;								editorSelectionBotRight.v := numChars;							end;					end;			end		else 			begin				sc := 1;				ec := numchars;				if not selectToEndIncludeTerminalGaps then					begin						st := TaxonOfCell(editorSelectionTopLeft);						et := TaxonOfCell(editorSelectionBotRight);						if (et<=0) then							begin								st := 1;								et := numTaxa;								selectWhole :=true;							end;						if not editorTransposed then							lastcharacter := pinCell.h						else							lastcharacter := pinCell.v;						while (sc <= lastcharacter) & CheckIfAllGaps(st,et,sc,sc, editorToolsTreatmissingAsGaps) do							sc := sc+1;						while (ec >= lastcharacter) & CheckIfAllGaps(st,et,ec,ec, editorToolsTreatmissingAsGaps) do							ec := ec-1;					end;				if not editorTransposed then					begin						if useOptTool then							editorSelectionTopLeft.h := sc						else							editorSelectionBotRight.h := ec;						if selectWhole then							begin								editorSelectionTopLeft.v:= 1;								editorSelectionBotRight.v := numTaxa;							end;					end				else 						begin						if useOptTool then							editorSelectionTopLeft.v := sc						else							editorSelectionBotRight.v := ec;						if selectWhole then							begin								editorSelectionTopLeft.h := 1;								editorSelectionBotRight.h := numTaxa;							end;					end;			end;	end;{----------------------------------------------------------------------------}	procedure TrackSelectionRect(pinCell,newCell: point; selectToEnd, selectToEndOfTaxa,useOptTool: boolean);	var oldRegion, newRegion, differentRegion: RgnHandle;		tport: WindowPtr;		oldClip: RgnHandle;	begin		genericGetPort(tport);		genericSetPort(editorWindow);		oldClip := newRgn;		GetClip(oldClip);		oldRegion := NewRgn;		newRegion := NewRgn;		differentRegion := NewRgn;		RectRgn(oldRegion,editorSelectionRect);	{	if newCell.v >= pinCell.v then			begin				ClipRect(WindowPortRect(editorWindow));				InvertRect(editorSelectionRect);				InvertRgn(oldRegion);			end;}		if newCell.v >= pinCell.v then			begin				editorSelectionTopLeft.v := pinCell.v;				editorSelectionBotRight.v := newCell.v;			end		else if newCell.v < pinCell.v then			begin				editorSelectionTopLeft.v := newCell.v;				editorSelectionBotRight.v := pinCell.v;			end;		if newCell.h >= pinCell.h then			begin				editorSelectionBotRight.h := newCell.h;				editorSelectionTopLeft.h := pinCell.h;			end		else if newCell.h < pinCell.h then			begin				editorSelectionTopLeft.h := newCell.h;				editorSelectionBotRight.h := pinCell.h;			end;		if editorSelectionBotRight.v = -1 then			editorSelectionBotRight.v := editorTotalRows		else if editorSelectionBotRight.h = -1 then			editorSelectionBotRight.h := editorTotalColumns;		if selectToEnd then			DoSelectToEnd(selectToEndOfTaxa,useOptTool, pinCell);		CalcEditorSelectionRect(editorSelectionTopLeft,editorSelectionBotRight);		RectRgn(newRegion, editorSelectionRect);		DiffRgn(newRegion,oldRegion,differentRegion);	{	if newCell.v >= pinCell.v then			begin				ClipRect(WindowPortRect(editorWindow));				InvertRect(editorSelectionRect);				InvertRgn(newRegion);				InvertRgn(differentRegion);							end;}		SetClip(differentRegion);		DrawDataCellsInRgn(differentRegion,selectionModeAsIs);  		{if EmptyRgn(differentRegion) then}		DiffRgn(oldRegion,newRegion,differentRegion);		{SetClip(differentRegion);}		SetClip(differentRegion);		DrawDataCellsInRgn(differentRegion,selectionModeAsIs); 		ZapRegion(oldRegion);		ZapRegion(newRegion);		ZapRegion(differentRegion);		SetClip(oldClip);		ZapRegion(oldClip);		genericSetPort(tport);	end;{----------------------------------------------------------------------------}	procedure TrackEditorSelectionTool(clickTaxon,clickChar: integer; allowNameCellSelection, selectToEnd, useOptTool,allowSingleCellSelection: boolean; var success: boolean);	var wh: point;		it,ic: integer;		oldit,oldic, row,column, icScrolled: integer;		pointMoved: point;		ClickIsDataCell, didScroll: boolean;		pinCell, newCell: point;		oldClip: RgnHandle;		tport: WindowPtr;	begin		genericGetPort(tport);		genericSetPort(editorWindow);		oldClip := newRgn;		GetClip(oldClip);		ClipRect(WindowPortRect(editorWindow));		ClickIsDataCell := IsDataCell(clickTaxon,clickChar); 		success := false;		if not allowNameCellSelection & ((clickTaxon=0) | (clickChar=0)) then			Exit(TrackEditorSelectionTool);				success := true;		editorSelected := true;		RowColumnFromTaxonCharacter(clickTaxon,clickChar,row,column);		pinCell.v := row;		pinCell.h := column;		editorSelectionTopLeft := pinCell;		editorSelectionBotRight := pinCell;		if editorSelectionBotRight.v = -1 then			editorSelectionBotRight.v := editorTotalRows		else if editorSelectionBotRight.h = -1 then			editorSelectionBotRight.h := editorTotalColumns;		if selectToEnd then			DoSelectToEnd((clickTaxon>=1)&((clickChar<=0)|(selectToEndMode=selectToLastTaxonMode)|(selectToEndMode=selectToFirstTaxonMode)),useOptTool, pinCell);		CalcEditorSelectionRect(editorSelectionTopLeft,editorSelectionBotRight);		DrawDataCellsBetweenCorners(editorSelectionTopLeft,editorSelectionBotRight,selectionModeAsIs);			{	InvertSelRect(editorSelectionTopLeft,editorSelectionBotRight);}		oldit := clickTaxon;		oldic := clickChar;		 while StillDown do		 	begin			 	GetMouse(wh);			 	ScrollEditorToMouse(wh,nil,pinCell.h>=1, pinCell.v>=1,didScroll, icScrolled, pointMoved);			 	FindTaxonCharacterInEditor(wh,it,ic);				If (ClickIsDataCell & IsDataCell(it,ic)) | (((clickTaxon=0) & (it=0))|((clickTaxon=-1) & (it=-1))|((clickChar=0) & (ic=0))|((clickChar=-1) & (ic=-1))) then 					if (it<>oldit) or (ic<>oldic) then						begin							RowColumnFromTaxonCharacter(it,ic,row,column);							newCell.v := row;							newCell.h := column;							if pinCell.v = -1 then 								begin									newCell.v := -1;									if newCell.h < 1 then newCell.h := 1;								end;							if pinCell.h = -1 then 								begin									newCell.h := -1;									if newCell.v < 1 then newCell.v := 1;								end;							TrackSelectionRect(pinCell,newCell, selectToEnd,(clickTaxon>=1)&((clickChar<=0)|(selectToEndMode=selectToLastTaxonMode)|(selectToEndMode=selectToFirstTaxonMode)),useOptTool);						end;				oldit := it;				oldic := ic;			end;		 if SingleCell & not allowSingleCellSelection then		 	begin		 		DrawDataCellsBetweenCorners(editorSelectionTopLeft,editorSelectionBotRight,selectionModeOff);		 		ZeroSelection;		 		success := false;		 	end;{		DrawDataCellsBetweenCorners(editorSelectionTopLeft,editorSelectionBotRight,selectionModeAsIs);}	{	InvertSelRect(editorSelectionTopLeft,editorSelectionBotRight);}		SetClip(oldClip);		ZapRegion(oldClip);		genericSetPort(tport);	end;{----------------------------------------------------------------------------}	procedure TrackSplitMultiBlockSelection(originalwh: point; clickTaxon,clickChar: integer; var splitTaxonStart,splitTaxonEnd,splitCharacter: integer; var success: boolean);    {}	var it,ic, icScrolled: integer;		didscroll: boolean;		pointMoved: point;	begin		success := true;		 repeat		 	GetMouse(wh);		 	if not editorTransposed then		 		wh.h := originalwh.h		 	else		 		wh.v := originalwh.v;		 	ScrollEditorToMouse(wh,nil,true,true,didScroll,icScrolled, pointMoved);		 				PenMode(patXor);			PenSize(3, 3);			PenPat(QDGray);			moveto(originalwh.h,originalwh.v);			lineto(wh.h,wh.v);			Delay(3, ticks);			lineto(originalwh.h,originalwh.v);			PenNormal;		 until not StillDown;		 FindTaxonCharacterInEditor(wh,it,ic);		 if it < 1 then it := 1;		 if it < clicktaxon then		 	begin		 		if NearCellLineInEditor(editorTransposed,originalwh) & justAboveCellLine(editorTransposed,originalwh) & (clicktaxon<numtaxa) then  		 			clickTaxon := clickTaxon-1;		 		if  NearCellLineInEditor(editorTransposed,wh) & not JustAboveCellLine(editorTransposed,wh) then  {just below}		 			it := it+1;		 	end		 else if (it > clickTaxon) then		 	begin		 		if NearCellLineInEditor(editorTransposed,wh) & justAboveCellLine(editorTransposed,wh) & (it<numtaxa) then		 			it := it-1;		 		if  NearCellLineInEditor(editorTransposed,originalwh) & not JustAboveCellLine(editorTransposed,originalwh) then  {just below}		 			clickTaxon := clickTaxon+1;		 		if (it>numtaxa) then it:= numtaxa;		 	end;		 if (it<clickTaxon) then		 	begin		 		splitTaxonStart := it;		 		splitTaxonEnd := clickTaxon;		 		splitCharacter := clickChar;		 	end		 else if (it > clickTaxon) then		 	begin		 		splitTaxonStart := clickTaxon;		 		splitTaxonEnd := it;		 		splitCharacter := clickChar;		 	end		else		 	begin		 		success := false;		 		splitTaxonStart := 0;		 		splitTaxonEnd := 0;		 		splitCharacter := 0;		 	end	end;	{----------------------------------------------------------------------------}	procedure StandardClickInSingleCell(Event: EventRecord; oldTL, oldBR: point);	begin		if not EqualPt(editorSelectionTopLeft, oldTL) or not EqualPt(editorSelectionBotRight, oldBR) then			SetUpCellEdit		else			begin				genericSetPort(editorWindow);				TEClick(Event.where, ShiftEvent(Event), editorCellTE);			end;	end;{----------------------------------------------------------------------------}	function UpperLeftPoint(p1,p2: point): point;	begin		if p1.h < p2.h then 			UpperLeftPoint.h := p1.h		else			UpperLeftPoint.h := p2.h;		if p1.v < p2.v then 			UpperLeftPoint.v := p1.v		else			UpperLeftPoint.v := p2.v;	end;{----------------------------------------------------------------------------}	function LowerRightPoint(p1,p2: point): point;	begin		if p1.h > p2.h then 			LowerRightPoint.h := p1.h		else			LowerRightPoint.h := p2.h;		if p1.v > p2.v then 			LowerRightPoint.v := p1.v		else			LowerRightPoint.v := p2.v;	end;{----------------------------------------------------------------------------}	function RectBetweenCornersContainsData(TL,BR: point): boolean;	label 1;	var itstart,itend,icstart,icend: integer;		it,ic: integer;	begin		RectBetweenCornersContainsData := false;		GetTaxonCharacterFromDataCell(itstart,icstart,TL,false);		GetTaxonCharacterFromDataCell(itend,icend,BR,false);		for it := itstart to itend do			for ic := icstart to icend do				if not IsGapLike(it,ic,editorToolsTreatMissingAsGaps) then					begin						RectBetweenCornersContainsData := true;						goto 1;					end;		1:	end;{----------------------------------------------------------------------------}	procedure FindBoundaryCharacter(itstart,itend: integer; icinitial: integer; var icboundary: integer; firstBoundary, gapBounded: boolean);	var ic: integer;	begin		if firstBoundary then			begin				ic := icinitial-1;				while (ic>=1) do					if CheckIfAllGaps(itstart,itend,ic,ic,editorToolsTreatMissingAsGaps) = gapBounded then						begin							ic := ic+1;							leave;						end					else						ic := ic-1;				if ic = 0 then icboundary := 1				else icboundary := ic;			end		else			begin				ic := icinitial+1;				while (ic<=numchars) do					if CheckIfAllGaps(itstart,itend,ic,ic,editorToolsTreatMissingAsGaps)  = gapBounded  then						begin							ic := ic-1;							leave;						end					else						ic := ic+1;				if ic > numchars then icboundary := numchars				else icboundary := ic;			end;	end;{----------------------------------------------------------------------------}	function ExpandCornersSoBoundedByGaps(var TL, BR: point; clickChar: integer; gapBounded: boolean): boolean;	var itstart,itend,icstart,icend: integer;		ic: integer;	begin		ExpandCornersSoBoundedByGaps := true;		if editorTransposed then			begin				icstart := TL.v;				icend := BR.v;				itstart := TL.h;				itend := BR.h;				FindBoundaryCharacter(itstart,itend,icstart, TL.v, true,gapBounded);				FindBoundaryCharacter(itstart,itend,icend, BR.v, false,gapBounded);			end		else			begin				icstart := TL.h;				icend := BR.h;				itstart := TL.v;				itend := BR.v;				FindBoundaryCharacter(itstart,itend,icstart, TL.h, true,gapBounded);				FindBoundaryCharacter(itstart,itend,icend, BR.h, false,gapBounded);			end;		if not gapBounded & RectBetweenCornersContainsData(TL,BR) then			begin				ExpandCornersSoBoundedByGaps := false;				if CheckIfAllGaps(itstart,itend,clickChar,clickChar,editorToolsTreatMissingAsGaps) then  {can have an all-gap selection}					begin						if editorTransposed then							begin								TL.v := clickChar;								BR.v := clickChar;							end						else							begin								TL.h := clickChar;								BR.h := clickChar;							end;						for ic := clickChar-1 downto 1 do							if CheckIfAllGaps(itstart,itend,ic,ic,editorToolsTreatMissingAsGaps) then								begin									if editorTransposed then										TL.v := ic									else										TL.h := ic;								end							else								leave;						for ic := clickChar+1 to numchars do							if CheckIfAllGaps(itstart,itend,ic,ic,editorToolsTreatMissingAsGaps) then								begin									if editorTransposed then										BR.v := ic									else										BR.h := ic;								end							else								leave;						ExpandCornersSoBoundedByGaps := true;					end;			end	end;{----------------------------------------------------------------------------}	function CheckIfNoGaps(itstart,itend,icstart,icend: integer; treatMissingAsGaps: boolean): boolean;	var it, ic: integer;	begin		CheckIfNoGaps := true;		for ic := icstart to icend do			for it := itstart to itend do				if IsGapLike(it,ic,treatMissingAsGaps) then					begin						CheckIfNoGaps := false;						leave;					end;	end;{----------------------------------------------------------------------------}	procedure GetRangeOfSimilarCharacters (clickTaxon, clickChar: integer; var icstart,icend: integer; doGaps,treatMissingAsGaps: boolean);	var ic: integer;		foundBoundary: boolean;	begin		icstart := clickChar;		icend := clickChar;		foundBoundary:= false;		for ic := clickChar+1 to numchars do			if not IsGapLike(clickTaxon,ic,treatMissingAsGaps)=doGaps then				begin					icend := ic-1;					foundBoundary:= true;					leave;				end;		if not foundboundary then icend := numchars;		foundBoundary:= false;		for ic := clickChar-1 downto 1 do			if not IsGapLike(clickTaxon,ic,treatMissingAsGaps)=doGaps then				begin					icstart := ic+1;					foundBoundary:= true;					leave;				end;		if not foundboundary then icstart := 1;	end;{----------------------------------------------------------------------------}	procedure GetRangeOfSimilarTaxa (clickTaxon, clickChar: integer; var itstart,itend: integer; doGaps,treatMissingAsGaps: boolean);	var it: integer;		foundBoundary: boolean;	begin		itstart := clickTaxon;		itend := clickTaxon;		foundBoundary:= false;		for it := clickTaxon+1 to numtaxa do			if not IsGapLike(it,clickChar,treatMissingAsGaps)=doGaps then				begin					itend := it-1;					foundBoundary:= true;					leave;				end;		if not foundboundary then itend := numtaxa;		foundBoundary:= false;		for it := clickTaxon-1 downto 1 do			if not IsGapLike(it,clickChar,treatMissingAsGaps)=doGaps then				begin					itstart := it+1;					foundBoundary:= true;					leave;				end;		if not foundboundary then itstart := 1;	end;{----------------------------------------------------------------------------}	function CheckIfAllOpposite(itstart,itend,icstart,icend: integer; doGaps,treatMissingAsGaps: boolean): boolean;	var it, ic: integer;	begin		CheckIfAllOpposite := true;		for ic := icstart to icend do			for it := itstart to itend do				if IsGapLike(it,ic,treatMissingAsGaps)=doGaps then					begin						CheckIfAllOpposite := false;						leave;					end;	end;{----------------------------------------------------------------------------}	procedure ExpandToMixedBlock(var TL,BR: point; doGaps: boolean);	var itstart,itend,icstart,icend: integer;		it,ic: integer;		newicstart,newicend, newitstart, newitend : integer;		foundboundary: boolean;		oldTL,oldBR: point;	begin		GetTaxonCharacterFromDataCell(itstart,icstart,TL,false);		GetTaxonCharacterFromDataCell(itend,icend,BR,false);		newicstart := icstart;		newicend := icend;		newitstart := itstart;		newitend := itend;				repeat			oldTL := TL;			oldBR := BR;			foundboundary:= false;			for ic := newicstart-1 downto 1 do				if CheckIfAllOpposite(newitstart,newitend,ic,ic,doGaps, editorToolsTreatMissingAsGaps) then  {looking}					begin						newicstart := ic+1;						foundBoundary:= true;						leave;					end;			if not foundboundary then newicstart := 1;			foundboundary:= false;			for ic := newicend+1 to numchars do				if CheckIfAllOpposite(newitstart,newitend,ic,ic,doGaps, editorToolsTreatMissingAsGaps) then					begin						newicend := ic-1;						foundBoundary:= true;						leave;					end;			if not foundboundary then newicend := numchars;						foundboundary:= false;			for it := newitstart-1 downto 1 do				if CheckIfAllOpposite(it,it,newicstart,newicend,doGaps, editorToolsTreatMissingAsGaps) then					begin						newitstart := it+1;						foundBoundary:= true;						leave;					end;			if not foundboundary then newitstart := 1;			foundboundary:= false;			for it := newitend+1 to numtaxa do				if CheckIfAllOpposite(it,it,newicstart,newicend,doGaps, editorToolsTreatMissingAsGaps) then					begin						newitend := it-1;						foundBoundary:= true;						leave;					end;			if not foundboundary then newitend := numtaxa;			RowColumnFromTaxonCharacter(newitstart,newicstart,TL.v,TL.h);			RowColumnFromTaxonCharacter(newitend,newicend,BR.v,BR.h);		until  EqualPt(oldTL,TL) & EqualPt(oldBR,BR);	end;{----------------------------------------------------------------------------}{	procedure ExpandToMixedBlock(clickTaxon,clickChar: integer; var TL,BR: point; doGaps: boolean);	var itstart,itend,icstart,icend: integer;		it,ic: integer;		foundboundary: boolean;	begin		if (magicWandMode=magicWandExtendCharactersBlockMode)  then			GetRangeOfSimilarCharacters(clickTaxon,clickChar,icstart,icend, doGaps)		else			GetRangeOfSimilarTaxa(clickTaxon,clickChar,itstart,itend, doGaps);		RowColumnFromTaxonCharacter(itstart,icstart,TL.v,TL.h);		RowColumnFromTaxonCharacter(itend,icend,BR.v,BR.h);	end;}{----------------------------------------------------------------------------}	procedure ExpandToBiggestBlock(clickTaxon,clickChar: integer; var TL,BR: point; doGaps: boolean);	var itstart,itend,icstart,icend: integer;		it,ic: integer;		foundboundary: boolean;	begin		icstart := clickChar;		icend := clickChar;		itstart := clickTaxon;		itend := clickTaxon;{=== finding maximal extent of gap/non gap in that single character====}		if (magicWandMode=magicWandExtendCharactersBlockMode) then			begin				GetRangeOfSimilarCharacters(clickTaxon,clickChar,icstart,icend, doGaps, editorToolsTreatMissingAsGaps);		{=== now that the extent of gap/non-gap has been found, find how extend of this in different characters ====}				foundBoundary:= false;				for it := clickTaxon + 1 to numtaxa do					if doGaps then 						begin							if not CheckIfAllGaps(it,it,icstart,icend,editorToolsTreatMissingAsGaps) then								begin									itend := it-1;									foundBoundary:= true;									leave;								end;						end					else						begin							if not CheckIfNoGaps(it,it,icstart,icend, editorToolsTreatMissingAsGaps) then								begin									itend := it-1;									foundBoundary:= true;									leave;								end;						end;									if not foundboundary then itend := numtaxa;				foundBoundary:= false;				for it := clickTaxon - 1 downto 1 do					if doGaps then						begin							if not CheckIfAllGaps(it,it,icstart,icend,editorToolsTreatMissingAsGaps) then								begin									itstart := it+1;									foundBoundary:= true;									leave;								end;						end					else						begin							if not CheckIfNoGaps(it,it,icstart,icend,editorToolsTreatMissingAsGaps) then								begin									itstart := it+1;									foundBoundary:= true;									leave;								end;						end;										if not foundboundary then itstart := 1;			end		else			begin				GetRangeOfSimilarTaxa(clickTaxon,clickChar,itstart,itend, doGaps, editorToolsTreatMissingAsGaps);		{=== now that the extent of gap/non-gap has been found, find how extend of this in different characters ====}				foundBoundary:= false;				for ic := clickChar + 1 to numchars do					if doGaps then 						begin							if not CheckIfAllGaps(itstart,itend,ic,ic,editorToolsTreatMissingAsGaps) then								begin									icend := ic-1;									foundBoundary:= true;									leave;								end;						end					else						begin							if not CheckIfNoGaps(itstart,itend,ic,ic,editorToolsTreatMissingAsGaps) then								begin									icend := ic-1;									foundBoundary:= true;									leave;								end;						end;									if not foundboundary then icend := numchars;				foundBoundary:= false;				for ic := clickChar - 1 downto 1 do					if doGaps then						begin							if not CheckIfAllGaps(itstart,itend,ic,ic,editorToolsTreatMissingAsGaps) then								begin									icstart := ic+1;									foundBoundary:= true;									leave;								end;						end					else						begin							if not CheckIfNoGaps(itstart,itend,ic,ic,editorToolsTreatMissingAsGaps) then								begin									icstart := ic+1;									foundBoundary:= true;									leave;								end;						end;										if not foundboundary then icstart := 1;			end;		RowColumnFromTaxonCharacter(itstart,icstart,TL.v,TL.h);		RowColumnFromTaxonCharacter(itend,icend,BR.v,BR.h);	end;{----------------------------------------------------------------------------}	procedure MagicWand(clickTaxon,clickChar: integer; clickCell: point; oldSelCellTL,oldSelCellBR: point; useOptTool: boolean);	var oldSelectionWithData: boolean;		icstart,icend: integer;		BR,TL: point;	begin 		if (clickCell.v = -1) | (clickCell.h=-1) then Exit(MagicWand);		editorSelectionTopLeft := clickCell;		editorSelectionBotRight := clickCell; {****}		if clickCell.v = 0 then			begin				editorSelectionTopLeft.h := 1;				editorSelectionBotRight.h := editorTotalColumns;			end		else if clickCell.h = 0 then			begin				editorSelectionTopLeft.v := 1;				editorSelectionBotRight.v := editorTotalRows;			end		else if IsDataCell(clickTaxon,clickChar) then			begin				FindSequencePiece(clickTaxon,clickChar, icstart,icend, magicWandEntireSequence, editorToolsTreatMissingAsGaps);				if editorTransposed then					begin						editorSelectionTopLeft.v := icstart;						editorSelectionBotRight.v := icend;					end				else					begin						editorSelectionTopLeft.h := icstart;						editorSelectionBotRight.h := icend;					end;				if (magicWandMode<>magicWandNormalMode) then					begin						ExpandToBiggestBlock(clickTaxon,clickChar,TL,BR,IsGapLike(clickTaxon,clickChar,editorToolsTreatMissingAsGaps));						if (magicWandMode=magicWandMixedBlockMode) then							ExpandToMixedBlock(TL,BR,IsGapLike(clickTaxon,clickChar,editorToolsTreatMissingAsGaps));						editorSelectionTopLeft := TL;						editorSelectionBotRight :=BR;					end				else if (oldSelCellBR.v>0) & (oldSelCellBR.h>0) & ShiftEvent(Event) then  {need to extend selection}					begin						oldSelectionWithData := RectBetweenCornersContainsData(oldSelCellTL,oldSelCellBR);						if oldSelectionWithData <> IsGapLike(clickTaxon,clickChar,editorToolsTreatMissingAsGaps) then {either both all gaps or both with data}							begin								TL := UpperLeftPoint(oldSelCellTL, editorSelectionTopLeft);								BR := LowerRightPoint(oldSelCellBR, editorSelectionBotRight);								if ExpandCornersSoBoundedByGaps(TL,BR,clickChar,oldSelectionWithData) then									begin										editorSelectionTopLeft := TL;										editorSelectionBotRight :=BR;									end;							end;					end;				if singleCell then					begin						editorSelectionTopLeft := oldSelCellTL;						editorSelectionBotRight :=oldSelCellBR;						Exit(MagicWand);					end;			end;		if not EqualPt(OldSelCellTL, editorSelectionTopLeft) or not EqualPt(OldSelCellBR, editorSelectionBotRight) then			begin				CleanOldCell(OldSelCellTL, OldSelCellBR);				if badcellentry then					Exit(MagicWand);				FixNewCell(editorSelectionTopLeft, editorSelectionBotRight);			end;	end;{----------------------------------------------------------------------------}	procedure QueryDeleteSelectedBlock(shiftFromLeft,saveSelection: boolean);	var st,et,sc,ec: integer;		it,ic: integer;		TL,BR: point;		db: boolean;	begin		if WholeTaxonSel & ClearSelected(true) then			begin			end		else if not WholeTaxonSel & (AllGapsSelected(editorToolsTreatMissingAsGaps) | not editorScissorsWarn | CWarning('Excise selected block?','Excise','Cancel')) then			begin				CalcSelectedTaxaCharacters(st,et,sc,ec,true);				if not StoreCellBlockForUndo(st, et, sc, ec, true,false,saveSelection) then Exit (QueryDeleteSelectedBlock);				for it := st to et do					for ic := sc to ec do						if molecular then							settaxonstsLargestOverwriteCase(it, ic, [MSl, GAl])						else							settaxonstsLargestOverwriteCase(it, ic, [MSl]);				if ((ec = numchars) & not shiftFromLeft) |  ((sc = 1) & shiftFromLeft) then					begin						CheckRedrawFullCharactersInEditor(st,et,sc,ec,true);						{if ConsensusSequenceVisible then							WriteAllConsensesForCharacters(sc,ec,writeStandardCells,selectionModeAsIs);						if UpdateAsSensitiveToFirstTaxonChange(st) then							MatchCharUpdate(sc, ec);}						SetDirtyEditor(true);					end				else 					begin						{if not StoreCellBlockForUndo(st, et, sc, ec, true,false,saveSelection) then Exit (QueryDeleteSelectedBlock);}						if shiftFromLeft then							DoMoveCells(st,et,1,sc-1,st,et,(ec-sc+1)+1,ec)						else							DoMoveCells(st,et,ec+1,numchars,st,et,sc,numchars-(ec-sc+1));					end;				ZeroSelection;				InvalidateWindow(editorWindow,true);			end		else			begin				TL := editorSelectionTopLeft;				BR := editorSelectionBotRight;				ZeroSelection;				DrawDataCellsBetweenCorners(TL,BR,selectionModeAsIs);			end;	end;{----------------------------------------------------------------------------}	procedure FlashSplitBlockOptionLine (wh: point; clickTaxon: integer);	var taxstart,taxend: integer;		top,bottom, left,right: integer;		linegap: integer;	begin		PenMode(patXor);		PenSize(3, 3);		PenPat(QDltGray);		if not editorTransposed then			begin				linegap := editorLineWidth div 2;				CellVer(clickTaxon,top,bottom,true);				moveto(wh.h, editorTitleLineWidth + 3);				lineto(wh.h, top-linegap);				moveto(wh.h, bottom+linegap);				lineto(wh.h, editorMatrixRect.bottom);				Delay(3, ticks);				moveto(wh.h, editorTitleLineWidth + 3);				lineto(wh.h, top-linegap);				moveto(wh.h, bottom+linegap);				lineto(wh.h, editorMatrixRect.bottom);			end		else			begin				linegap := editorColumnWidth div 2;				CellHor(clickTaxon,left,right,true);				moveto(editorRowNameStart+3,wh.v);				lineto(left-linegap,wh.v);				moveto(right+linegap,wh.v);				lineto(editorMatrixRect.right,wh.v);				Delay(3, ticks);				moveto(editorRowNameStart+3,wh.v);				lineto(left-linegap,wh.v);				moveto(right+linegap,wh.v);				lineto(editorMatrixRect.right,wh.v);			end;		PenNormal;	end;{----------------------------------------------------------------------------}	procedure TrackMoveAllElse(Event: EventRecord; clickTaxon,clickChar: integer);	var wh: point;		it,dropic: integer;		quantity, oldnumchars: integer;		oldCV, icScrolled: integer;		db: boolean;		didScroll: boolean;		pointMoved: point;	begin		repeat			GetMouse(wh);			ScrollEditorToMouse(wh,nil,true,true,didScroll, icScrolled, pointMoved);			if didScroll then				UpdateMovedTaxa(clickTaxon,clickTaxon,false,false);			FlashSplitBlockOptionLine(wh,clickTaxon);		until not StillDown;		if FindTaxChar(wh,it,dropic) then			begin				if not StoreCellBlockForUndo(clickTaxon, clickTaxon, 1, numchars, true,false,false) then Exit(TrackMoveAllElse);				lastChangeInEditor := lastChangeInsertCharAndCellBlock;				if dropic < clickChar-1 then  {pushing to left}					begin						{clickChar := clickChar-1;}						quantity := clickChar - dropic-1;						InsertNewCharacters(quantity,clickChar,true);						DoMoveCells(clickTaxon,clickTaxon,1,clickChar,clickTaxon,clickTaxon,quantity+1,clickChar+quantity-1);					{	InsertNewCharacters(quantity,dropic+1,true);						DoMoveCells(clickTaxon,clickTaxon,clickChar,numchars,clickTaxon,clickTaxon,dropic+1,numchars-quantity);}						ZeroSelection;												if editorTransposed then							begin								oldCV := GetControlValueLong(editorVScroll);								SetControlValueLong(editorVScroll,oldCV+quantity);								editorOrigin.v := editorOrigin.v + quantity;							end						else							begin								oldCV := GetControlValueLong(editorHScroll);								SetControlValueLong(editorHScroll,oldCV+quantity);								editorOrigin.h:= editorOrigin.h + quantity;							end;						InvalidateWindow(editorWindow,true);						ReCalcMaxstAndStates(1,clickchar);					end				else if dropic > clickChar then  {pushing to right}					begin						quantity := dropic - clickChar;						oldNumChars := numchars;						InsertNewCharacters(quantity,clickchar,true);						DoMoveCells(clickTaxon,clickTaxon,dropic,numchars,clickTaxon,clickTaxon,clickChar,numchars-quantity);						ZeroSelection;						InvalidateWindow(editorWindow,true);						ReCalcMaxstAndStates(clickChar,numchars);					end;			end;	end;	{----------------------------------------------------------------------------}	function TaxonCharacterCellInSelection(it,ic: integer): boolean;	begin		TaxonCharacterCellInSelection := (editorTransposed & CellInSelection(ic,it))|(not editorTransposed & CellInSelection(it,ic));	end;	{----------------------------------------------------------------------------}	function MouseInAAPartofNucleotideCell(wh: point): boolean;	var clickCell: point; 		box: rect;	begin		MouseInAAPartofNucleotideCell := false;		if nucleotides & AAAutoTranslationVisible then			begin				clickCell := FindCell(wh, true, false);				box := CellRect(clickCell.h,clickCell.v);				if editorTransposed then 					box.left := box.left + editorColumnWidth div 2				else 					box.top := box.top + editorLineWidth div 2; 				MouseInAAPartofNucleotideCell := PtInRect(wh,box);			end;	end;{----------------------------------------------------------------------------}	procedure CalcSelectedStateFreq(var freq: stateFreqType);	var 	j : integer;		ic, sc,ec,st,et, it: integer;		tsts: LargestSetChars;	begin		CalcSelectedTaxaCharacters(st, et, sc, ec, true);		CalcStateFreq(freq, st,et,sc,ec);	end;{----------------------------------------------------------------------------}	procedure PopUpShowCellContents(clickTaxon,clickChar: integer; wh: point);	var 	freq: stateFreqType;		ds: str255;		tsts: largestSetChars;		newWh: point;		is, partNumber: integer;	begin		ds := '';		if (clickTaxon>0) & (clickChar>0) then			begin				if ShiftEvent(Event) then					begin						CalcSelectedStateFreq(freq);						ds := 'Frequencies in selected block:';						ds := concat(ds,chr(13));						for is := 0 to maxstate do							begin								ds := concat(ds,symbols[is+1],': ', StringFromNum(freq[is]),chr(13));							end;					end				else if MouseInAAPartofNucleotideCell(wh) then					begin						PrepareAAfromDNA(clickTaxon,clickChar,clickChar,tsts,false,writeStandardCells);						ds := AASymbolsInAAwithDNACell(clickChar,tsts);						ds := concat('State: ', ds);					end				else					begin						ds := TaxonCharacterCellEntry(clickTaxon,clickChar,tsts);						if molecular then							ds := concat('State: ', ds);					end;				if molecular then					begin						ds := concat(ds, char(13), '-----', char(13),'Non-gaps:',char(13), '<-');						ds := concat(ds, StringFromNum(numNonGaps(clickTaxon,clickTaxon,1,clickChar, editorToolsTreatMissingAsGaps)));						ds := concat(ds,char(13),'  ');						ds := concat(ds, StringFromNum(numNonGaps(clickTaxon,clickTaxon,clickChar,numChars, editorToolsTreatMissingAsGaps)));						ds := concat(ds, '->');					end;			end		else if (clickChar > 0) then {let's give some info about the character}			begin				ds := AvailCharName(clickChar);				partNumber := CharPartition(clickChar);				if partNumber > 1 then					ds := concat(ds, chr(13), 'Group: ', NameOfCharPartNameFromNumber(partNumber));			end		else if (clickTaxon > 0) then {let's give some info about the character}			begin				ds := AvailTaxonName(clickTaxon);			end;		if ds <> '' then			begin				newWh.h := wh.h+5;				newWh.v := wh.v+5;				PlaceTextWhileButtonDown(ds, newWh, true);			end;	end;{----------------------------------------------------------------------------}	procedure GoToFirstNonGap(it: integer);	var characterGoTo, ic: integer;	begin		characterGoTo := 0;		for ic := 1 to numchars do			if not IsGapLike(it,ic,editorToolsTreatMissingAsGaps) then				begin					characterGoTo := ic;					leave;				end;		if (characterGoTo > 0) then			if editorTransposed then				ScrolltoRectangle(characterGoTo,characterGoTo,it,it,true,true)			else				ScrollToRectangle(it,it,characterGoTo,characterGoTo,true,true);	end;{----------------------------------------------------------------------------}	procedure ToolInDataEditor(whichTool, clickTaxon,clickChar: integer; clickCell: point; Event: EventRecord);	var			moveOK: boolean;			oldst, oldet, oldsc, oldec, st, et, sc, ec: integer;			icstart, icend: integer;			mustDeSelectEditor: boolean;			success, wasSelected, useOptTool: boolean;			consensusNumber, oldSelected: integer;			d: integer;			wh: point;			oldSelCellTL, oldSelCellBR: point;			ds: str255;			B: rect;			tsts: largestsetchars;	begin		genericSetPort(editorWindow);		success := false;		if not editorSelected then			begin				SetPt(oldSelCellTL, 0, 0);				SetPt(oldSelCellBR, 0, 0);			end		else			begin				oldSelCellTL := editorSelectionTopLeft;				oldSelCellBR := editorSelectionBotRight;			end;		case whichTool of			selectedBlockMoveT: {UNDO done}				if (IsDataCell(clickTaxon,clickChar) & not (editorSelected & (SelectedBlockMoveMode = selectedBlockMoveClickMode))) & not  PtInRect(Event.where, editorSelectionRect) & (Event.where.v > editorFirstRowTop) & (Event.where.h > editorFirstColumnLeft)  then 					begin							CleanOldCell(OldSelCellTL, OldSelCellBR);						if badcellEntry then							Exit(ToolInDataEditor);						TrackEditorSelectionTool(clickTaxon,clickChar,true, false,UseOptionTool(editorTools,selectedBlockMoveT,OptionEvent(Event)),false,success);    {UseOptionTool(editorTools,selectedBlockMoveT,OptionEvent(Event))}						if success then							begin								{if SingleCell then									begin										WriteTaxonCharacterCell (clickTaxon,clickChar, false,writeStandardCells,selectionModeOff);										ZeroSelection;									end								else}									editorSelected := true;  							end;					end				else if (IsDataCell(clickTaxon,clickChar) | (SelectedBlockMoveMode= selectedBlockMoveClickMode)) & editorSelected & not SingleCell & (PtInRect(Event.where, editorSelectionRect)| (SelectedBlockMoveMode= selectedBlockMoveClickMode)) & not WholeTaxonSel & (CharOfCell(editorSelectionTopLeft) > 0) & (Event.where.v > editorFirstRowTop) & (Event.where.h > editorFirstColumnLeft) & StillDown & someDataSel then					begin						case SelectedBlockMoveMode of							selectedBlockMoveNormalMode: 								TrackBlockMove(Event.where, success, moveOK, selectedBlockMove, selectedBlockMoveT,oldst, oldet, oldsc, oldec, oldSelCellTL, oldSelCellBR, clickChar);							selectedBlockMoveSpecifiedMode:								SpecifySelectedBlockMove(editorToolsTreatMissingAsGaps, false, 0);							selectedBlockMoveClickMode:								SpecifySelectedBlockMove(editorToolsTreatMissingAsGaps, true, clickChar);							otherwise;						end;						CalcEditorSelectionRect(editorSelectionTopLeft,editorSelectionBotRight);					end;			closeGapsT: {UNDO done}				if IsDataCell(clickTaxon,clickChar) & not  PtInRect(Event.where, editorSelectionRect) & (Event.where.v > editorFirstRowTop) & (Event.where.h > editorFirstColumnLeft)  then 					begin							CleanOldCell(OldSelCellTL, OldSelCellBR);						if badcellEntry then							Exit(ToolInDataEditor);						TrackEditorSelectionTool(clickTaxon,clickChar,true, false,UseOptionTool(editorTools,closeGapsT,OptionEvent(Event)),false,success);    						if success then							begin								{if SingleCell then									begin										WriteTaxonCharacterCell (clickTaxon,clickChar, false,writeStandardCells,selectionModeOff);										ZeroSelection;									end								else}									editorSelected := true;  							end;					end				else if IsDataCell(clickTaxon,clickChar) & editorSelected & not SingleCell & SomeDataSel & PtInRect(Event.where, editorSelectionRect) & (not WholeTaxonSel | (closeGapsMode<>closeGapsNormalMode)) {& (CharOfCell(editorSelectionTopLeft) > 0)} & (Event.where.v > editorFirstRowTop) & (Event.where.h > editorFirstColumnLeft)  & someDataSel then					begin						MoveSelectedBlockAsFarAsPossible(UseOptionTool(editorTools,closeGapsT,OptionEvent(Event)),editorToolsTreatMissingAsGaps,closeGapsMode);					end;			splitBlockT:{UNDO done}				 if IsDataCell(clickTaxon,clickChar)  & PtInRect(event.where,editorMatrixRect)  & (Event.where.h > editorFirstColumnLeft)   & (Event.where.v > editorFirstRowTop) then 					 if UseOptionTool(editorTools,splitBlockT,OptionEvent(Event)) then  {multi-character split}						begin							 {if turnMultiSplitFlashBackOn then							 	begin							 		curFlashPattern := 1;							 		editorFlashOn := true;							 		TurnOnFlash;							 		PaintFlash;							 	end;}							 if NearSplitMultiBlockLine(not editorTransposed,event.where) then								begin  									UnselectAll;									if badcellEntry then										Exit(ToolInDataEditor);									TrackBlockMove(Event.where, success, moveOK, splitMultiBlockMove, splitBlockT,oldst, oldet, oldsc, oldec, oldSelCellTL, oldSelCellBR, clickChar);									ZeroSplitFlash;									if not success then										Exit(ToolInDataEditor);																	end							else if NearCellLineInEditor(not editorTransposed, event.where) then								begin										ZeroSplitFlash;									CleanOldCell(OldSelCellTL, OldSelCellBR);									if badcellEntry then										Exit(ToolInDataEditor);									wh := event.where;									if JustAboveCellLine(not editorTransposed,wh) then clickChar := clickChar-1;									if editorTransposed then										CellVer(clickChar,d,wh.v,false)									else										CellHor(clickChar,d,wh.h,false);									TrackSplitMultiBlockSelection(wh,clickTaxon,clickChar,splitTaxonStart,splitTaxonEnd,splitCharacter,success);    {}									if success then										begin											CalcSplitMultiFlashRegion;											TurnOnFlash;											UnselectAll; 										end;								end						end					else						if NearCellLineInEditor(not editorTransposed,event.where) & not IsGapLike(clickTaxon,clickChar,editorToolsTreatMissingAsGaps) then								begin  									UnselectAll;									if badcellEntry then										Exit(ToolInDataEditor);									TrackBlockMove(Event.where, success, moveOK, splitBlockMove, splitBlockT,oldst, oldet, oldsc, oldec, oldSelCellTL, oldSelCellBR, clickChar);									if not success then										Exit(ToolInDataEditor);								end;									splitBlockOtherT:   {UNDO done}				if IsDataCell(clickTaxon,clickChar) & not IsGapLike(clickTaxon,clickChar,editorToolsTreatMissingAsGaps) & NearCellLineInEditor(not editorTransposed,event.where) & PtInRect(event.where,editorMatrixRect) & (Event.where.h > editorFirstColumnLeft)   & (Event.where.v > editorFirstRowTop) then					begin						UnselectAll;						if badcellEntry then							Exit(ToolInDataEditor);						if not JustAboveCellLine(not editorTransposed,Event.where) then							TrackMoveAllElse(Event,clickTaxon,clickChar+1)						else							TrackMoveAllElse(Event,clickTaxon,clickChar);					end;			blockMoveT: {UNDO done}				if blockMoveSplitBlockToo & IsDataCell(clickTaxon,clickChar) & NearCellLineInEditor(not editorTransposed,event.where) & not IsGapLike(clickTaxon,clickChar,editorToolsTreatMissingAsGaps) & PtInRect(event.where,editorMatrixRect) & (Event.where.h > editorFirstColumnLeft)   & (Event.where.v > editorFirstRowTop) & (editorColumnWidth>=columnIncrement) then					begin 						UnselectAll;						if badcellEntry then							Exit(ToolInDataEditor);						TrackBlockMove(Event.where, success, moveOK, splitBlockMove, blockMoveT,oldst, oldet, oldsc, oldec, oldSelCellTL, oldSelCellBR, clickChar);						if not success then							Exit(ToolInDataEditor);					end				else if IsDataCell(clickTaxon,clickChar) & not IsGapLike(clickTaxon,clickChar,editorToolsTreatMissingAsGaps) & PtInRect(event.where,editorMatrixRect) & (Event.where.h > editorFirstColumnLeft)  & (Event.where.v > editorFirstRowTop) then					begin  						UnselectAll;						if badcellEntry then							Exit(ToolInDataEditor);						TrackBlockMove(Event.where, success, moveOK, unselectedBlockMove, blockMoveT, oldst, oldet, oldsc, oldec, oldSelCellTL, oldSelCellBR, clickChar);						if not success then							Exit(ToolInDataEditor);					end;			magicWandT:{UNDO not needed}				MagicWand(clickTaxon,clickChar,clickCell,OldSelCellTL, OldSelCellBR, UseOptionTool(editorTools,magicWandT,OptionEvent(Event)));			stampPasteT: {UNDO done}				if (EWScrapBlockP^.ntax + EWScrapBlockP^.nchar > 0) and (EWScrapBlockP^.ntax <= numtaxa) and (EWScrapBlockP^.nchar <= numchars) then					begin						if (clickTaxon>=1) & (clickChar >= 1) then							StampPaste(clickCell);					end;			editorSortT:  				if (clickTaxon<0) & (clickChar>0) then					SortByStateOrName(taxinfo,clickChar,UseOptionTool(editorTools,editorSortT,OptionEvent(Event)))				else if (clickTaxon>0) & (clickChar<0) then					SortByStateOrName(charinfo,clickTaxon,UseOptionTool(editorTools,editorSortT,OptionEvent(Event)))				else if (clickTaxon=0) & (clickChar>0) then {it is in the character names}					SortByStateOrName(charinfo,0,UseOptionTool(editorTools,editorSortT,OptionEvent(Event)))				else if (clickTaxon>0) & (clickChar=0) then {it is in the taxon names}					SortByStateOrName(taxinfo,0,UseOptionTool(editorTools,editorSortT,OptionEvent(Event)))				else					InstantInfo('Tool only works on row or column numbers and names.');			showPictureT: {UNDO not needed}				if (clickTaxon>=0) & (clickChar >= 0) then					begin						//genericSetPort(editorWindow);						if showPicturesMode=showPicturesPopUpMode then							begin								if GetFootPict(clickTaxon,clickChar) then									PlaceFramedPictureWhileButtonDown(grabpicture, Event.where);							end						else							ShowFootPict(clickTaxon, clickChar,0,0);					end;			editorPaintBrushT:  				if IsDataCell(clickTaxon,clickChar) then					begin						{CleanOldCell(OldSelCellTL, OldSelCellBR);						if badcellentry then							Exit(ToolInDataEditor);}						UnselectAll;						if badcellEntry then							Exit(ToolInDataEditor);						TrackEditorPaintBrush(clickTaxon,clickChar,Event);					end;			editorBucketT:  {UNDO done}				if IsDataCell(clickTaxon,clickChar) & editorSelected  & PtInRect(Event.where, editorSelectionRect) & someDataSel then					PaintBucketInEditor				else					begin							CleanOldCell(OldSelCellTL, OldSelCellBR);						if badcellEntry then							Exit(ToolInDataEditor);						TrackEditorSelectionTool(clickTaxon,clickChar,false,false,UseOptionTool(editorTools,editorBucketT,OptionEvent(Event)),true,success);    {}						if success then							begin								editorSelected := true; 								PaintBucketInEditor;								if SingleCell then									begin										WriteTaxonCharacterCell (clickTaxon,clickChar, false,writeStandardCells,selectionModeOff);										ZeroSelection;									end;							end;					end;			eyedropperT:  {no UNDO needed}				begin					if IsDataCell(clickTaxon,clickChar) then						paintBucketPaint := gettaxonstsLargest(clickTaxon,clickChar)					else if  (clickChar<=0) & (clickTaxon>=1) & (clickTaxon<=numtaxa) then						begin							paintBucketPaint := [];							editorPaintReferenceTaxon := clickTaxon;						end;					InvalidateWindow(toolPaletteWindow[editorTools], false);				end;			selectToEndT: {no UNDO needed}				begin					CleanOldCell(OldSelCellTL, OldSelCellBR);					if badcellEntry then						Exit(ToolInDataEditor);					TrackEditorSelectionTool(clickTaxon,clickChar,true, true,UseOptionTool(editorTools,selectToEndT,OptionEvent(Event)),true,success); 					if success then						begin							editorSelected := true;  							{FixNewCell(editorSelectionTopLeft, editorSelectionBotRight);  }							if SingleCell then								StandardClickInSingleCell(Event, OldSelCellTL,OldSelCellBR);						end;				end;			editorSelectionT:  {no UNDO needed}				begin						CleanOldCell(OldSelCellTL, OldSelCellBR);					if badcellEntry then						Exit(ToolInDataEditor);					TrackEditorSelectionTool(clickTaxon,clickChar,true, false,UseOptionTool(editorTools,editorSelectionT,OptionEvent(Event)),true,success);    {}					if success then						begin							editorSelected := true;  							{FixNewCell(editorSelectionTopLeft, editorSelectionBotRight);  }							if SingleCell then								StandardClickInSingleCell(Event, OldSelCellTL,OldSelCellBR);						end;				end;			editorScissorsT:  {UNDO done}				begin					if (clickTaxon<>0) and (clickChar<>0) then						SetCursID(284);					{check for wholecharselected, wholetaxonselected}					if editorSelected & TaxonCharacterCellInSelection(clickTaxon,clickChar) then						QueryDeleteSelectedBlock(UseOptionTool(editorTools,editorScissorsT,OptionEvent(Event)), true)					else						begin								CleanOldCell(OldSelCellTL, OldSelCellBR);							if badcellEntry then								Exit(ToolInDataEditor);							TrackEditorSelectionTool(clickTaxon,clickChar,false,false,UseOptionTool(editorTools,editorScissorsT,OptionEvent(Event)),true,success);    {}							if success then								begin									editorSelected := true; 									QueryDeleteSelectedBlock(UseOptionTool(editorTools,editorScissorsT,OptionEvent(Event)), false);								end;						end;				end;			autoAlignT:  {UNDO done}				begin					if autoAlignSelected & TaxonCharacterCellInSelection(clickTaxon,clickChar) & not SingleCell & SomeDataSel then						AlignSelectedBlock(clickTaxon)					else if (ClickTaxon>=1) & (ClickTaxon<=numtaxa) & StillDown then						begin							AutoAlignSequences(clickTaxon);						end;				end;			popUpStatesT:				if not UseOptionTool(editorTools,popUpStatesT,OptionEvent(Event)) then					PopUpStatesMenu(Event.where,ClickTaxon,clickChar)				else					PopUpShowCellContents(clickTaxon,clickChar, Event.where);			editorArrowT:				begin			{===== extending selection =====}					{if editorShowConsensusSequences & ((editorTransposed & (Event.where.h<editorFirstColumnLeft))| (not editorTransposed & (Event.where.v<editorFirstRowTop))) then						begin							ConsensusSequenceFromRowColumn(consensusNumber,clickTaxon);							if dblclick then								begin									if ConsensusDialog(consensusNumber) then										begin											InvalidateWindow(editorWindow, true);											ReSizeEditorWindow;										end;								end							else								begin									wasSelected := SomeConsensusSelected(oldSelected);									if ConsensusSelected(consensusNumber) then										SelectConsensus(consensusNumber,false)									else										SelectConsensus(consensusNumber,true);									if wasSelected then										DrawConsensusSequence(oldSelected,selectionModeAsIs);									DrawConsensusSequence(consensusNumber,selectionModeAsIs);								end;													end					else }					if Locked(lockData) then						begin							if (clickChar >=0) & (clickTaxon >= 0) then								begin									if GetFootString(foottext, clickTaxon, clickChar, ds) then										PopUpStringMenu(Event.where, ds);								end;						end					else if (clickTaxon>0)&(clickChar<0) & OptionEvent(Event) & ControlEvent(Event) then						GoToFirstNonGap(ClickTaxon)					else if (clickTaxon<0)&(clickChar>0) & OptionEvent(Event) & ControlEvent(Event) then						PopUpStatesMenu(Event.where,ClickTaxon,clickChar)					else						begin							if editorSelected and ShiftEvent(Event) then								begin									if (editorSelectionTopLeft.h = -1) then {it's already full rows}										begin				{next statement makes it so that you don't select both whole rows and column names}											if (ClickCell.v <= 0) then												ClickCell.v := 1;											if ClickCell.v < editorSelectionTopLeft.v then												editorSelectionTopLeft.v := ClickCell.v											else if (ClickCell.v > editorSelectionTopLeft.v) and (ClickCell.v <> editorSelectionBotRight.v) then												editorSelectionBotRight.v := ClickCell.v;										end									else if (editorSelectionTopLeft.v = -1) then {it's already full columns}										begin				{next statement makes it so that you don't select both whole columns and rownames}											if (ClickCell.h <= 0) then												ClickCell.h := 1;											if ClickCell.h < editorSelectionTopLeft.h then												editorSelectionTopLeft.h := ClickCell.h											else if (ClickCell.h > editorSelectionTopLeft.h) and (ClickCell.h <> editorSelectionBotRight.h) then												editorSelectionBotRight.h := ClickCell.h;										end									else										begin											if ClickCell.v < editorSelectionTopLeft.v then												editorSelectionTopLeft.v := ClickCell.v											else if (ClickCell.v > editorSelectionTopLeft.v) and (ClickCell.v <> editorSelectionBotRight.v) then												editorSelectionBotRight.v := ClickCell.v;											if ClickCell.h < editorSelectionTopLeft.h then												editorSelectionTopLeft.h := ClickCell.h											else if (ClickCell.h > editorSelectionTopLeft.h) and (ClickCell.h <> editorSelectionBotRight.h) then												editorSelectionBotRight.h := ClickCell.h;											if editorSelectionTopLeft.h = -1 then												editorSelectionBotRight.h := editorTotalColumns;											if editorSelectionTopLeft.v = -1 then												editorSelectionBotRight.v := editorTotalRows;										end;								end				{========= normal selection =========}							else								begin									SetRect(B, editorSelectionTopLeft.h, editorSelectionTopLeft.v, editorSelectionBotRight.h + 1, editorSelectionBotRight.v + 1);									if not ((WholeCharSel or WholeTaxonSel) and PtInRect(clickCell, B)) or ((TaxonOfCell(clickCell) >= 0) and (CharOfCell(clickCell) >= 0)) then										begin											editorSelectionTopLeft := clickCell;											editorSelectionBotRight := clickCell;											if clickCell.v = -1 then												editorSelectionBotRight.v := editorTotalRows											else if clickCell.h = -1 then												editorSelectionBotRight.h := editorTotalColumns;										end;								end;				{========== now that new selection has been established, process old cell =========}						if not EqualPt(OldSelCellTL, editorSelectionTopLeft) or not EqualPt(OldSelCellBR, editorSelectionBotRight) then							begin								CleanOldCell(OldSelCellTL, OldSelCellBR);								if badcellentry then									Exit(ToolInDataEditor);								FixNewCell(editorSelectionTopLeft, editorSelectionBotRight);							end;						if (ClickCell.v = -1) and StillDown then							begin								MoveColumns;							end						else if (ClickCell.h = -1) and StillDown then							MoveRows						else if OptionEvent(Event) and dblclick and SingleCell and (((editorSelectionTopLeft.v = 0) and not editorTransposed) or ((editorSelectionTopLeft.h = 0) and editorTransposed)) then							begin								statesWindowCharacter := clickChar;								OpenStatesWindow(false, 0,0);							end				{|||||||||||||||||||||| click on one cell |||||||||||||||||||}						else if SingleCell then							begin								if CommandEvent(Event) and (((editorSelectionTopLeft.v = 0) and not editorTransposed) or ((editorSelectionTopLeft.h = 0) and editorTransposed)) then									PopUpStateNames(Event.where, CharOfCell(editorSelectionTopLeft));								StandardClickInSingleCell(Event, OldSelCellTL,OldSelCellBR);							end;					end;				end;			otherwise;		end;			end;end.