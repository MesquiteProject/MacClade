unit ImpOldMacClade;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, TaxonCHUtil, SymbolsNames, TypeUtil, InfoWindows, Thermos, RowColumn, CharUtil, TreeUtil, ReadWriteUtil, ReadUtil, CHUNK, LinkUtil, SpreadUtil, Windows;	procedure ReadOldFile (var tempP: WindowPtr);{еееееееееееееееееееееее}implementation {е$S ImpOldMacClade}	var		charloc: array[1..200] of integer;		sd: INTEGER;						{} {----------------------------------------------------------------------------} 	procedure ReadLineIntoString(var ds: str255); 	begin		ds := ''; 		repeat 			next := anynextchar; 			if next <> chr(13) then 				ds := concat(ds,next); 		until (next = chr(13)) | (fpos>=mcFileLength) | errorflag; 	end; {----------------------------------------------------------------------------}	procedure ReadLineFromFile (var ds: str255);		var			found: boolean;	begin		found := false;		if (fpos>=mcFileLength) then			ds := '"еее'		else			while not found and not (fpos>=mcFileLength) and not errorflag do				begin					ReadLineIntoString(ds);					StripBlanks(ds);					if (ds <> '') and (ds <> ' ') then						found := (ds[1] <> '"');					UpdateThermo(iothermo, 0, fpos, mcFileLength, false);					if abortedthermo then						errorflag := true;				end;	end;{----------------------------------------------------------------------------}	procedure ReadGenMatrix (ds: str255; var dummy: str255; var readnext: Boolean);		var			isto, isfrom, max, ia, ib, ie: INTEGER;			tempdist: distancetype;			thp: typeHdlPtr;	begin		isfrom := 0;		max := 0;		repeat			ReadLineIntoString(dummy);			if isfrom = 0 then				begin					Stripblanks(dummy);					max := length(dummy) - 1;				end;			if dummy <> '' then				if ((dummy[1] >= '0') and (dummy[1] <= '9')) or (dummy[1] = '░') then					begin						for isto := 0 to max do							begin								if ((dummy[isto + 1] >= '0') and (dummy[isto + 1] <= '9')) then									tempdist[isfrom, isto] := ord(dummy[isto + 1]) - 48								else if dummy[isto + 1] = '░' then									tempdist[isfrom, isto] := infinity;							end;						isfrom := isfrom + 1;					end;		until (pos('.', dummy) > 0) or (dummy = '') or (isfrom > max) or (((dummy[1] < '0') or (dummy[1] > '9')) and (dummy[1] <> '░'));		if (((dummy[1] < '0') or (dummy[1] > '9')) and (dummy[1] <> '░')) or (pos('.', dummy) > 0) then			readnext := false;		AddCHUNKs(typeCHUNKs, 1, Sizeof(typeRecord));		if badmemory then			Exit(ReadGenMatrix);		numtypes := numtypes + 1;		thp := typeHdlPtr(GetMaster(typeCHUNKs) + GetHandleSize(typeCHUNKs) - HdlSize);		typeHdl := thp^;		typeHdl^^.dist := tempdist;		if max >= 10 then			max := 9;		typeHdl^^.max := max;		typeHdl^^.setdefined := [0..max];		ds := CopyString(ds, 2, 1);		typeHdl^^.name := ds;		typeHdl^^.root := -1;		typeHdl^^.isreal := false;		CheckPolarity(numtypes);	end;{----------------------------------------------------------------------------}	procedure ReadMatrix (var ds: str255);		var			charHdl: chHdl;			it, il, ic: integer;			dummy: str255;	begin		it := 0;		while (ds[1] <> '@') and (ds[1] <> '*') and not (fpos>=mcFileLength) and not errorflag do			begin				if ds[1] = '"' then					it := it				else if ds[1] = '&' then					begin						for ic := 1 to numchars do							begin								il := charloc[ic];								if il <= length(ds) then									if ds[il] <> ' ' then										begin											ist := ord(ds[il]) - 48;											if ist <> 15 then												begin													SetTaxonstsLargest(it, ic, GetTaxonStsLargest(it, ic) + [ist]);													if (MSl in GetTaxonStsLargest(it, ic)) then														SetTaxonstsLargest(it, ic, GetTaxonStsLargest(it, ic) - [MSl]);												end;											charHdl := GetchHdl(ic);											if (ist > charHdl^^.maxst) and (ist <> 15) then												charHdl^^.maxst := ist;										end;							end;					end				else					begin						it := it + 1;						for ic := 1 to numchars do							begin								il := charloc[ic];								ist := ord(ds[il]) - 48;								if not (((ist >= 0) & (ist <= 15)) | (ds[il] = '?')) then									begin										errorflag := true;										InstantErrorPlus(108, Concat(' Taxon: ', StringFromNum(it), ' Character: ', Stringfromnum(ic), ' Offending Symbol: ''', ds[il], ''''));										Exit(ReadMatrix);									end								else if ist <> 15 then									SetTaxonstsLargest(it, ic, [ist])								else									SetTaxonstsLargest(it, ic, [MSl]);								charHdl := GetchHdl(ic);								if (ist > charHdl^^.maxst) and (ist <> 15) then									charHdl^^.maxst := ist;								dummy := CopyString(ds, 1, sd);								Stripblanks(dummy);								BlanksToUnderLine(dummy);								SetTaxonName(it, dummy);							end;					end;				ReadLineFromFile(ds);			end;	end; {----------------------------------------------------------------------------}	procedure ConvertOldTree (ts: str255; dhdl: Handle; var numterminals: integer);		var			typefound, bynumbers: boolean;			taxnum: integer;			tok: str255;			ik, it: integer;			dL, offset: longint;			startP: ptr;			oldState: SignedByte;			taxafound: set of 0..80;{   ((1   2  3 ;  get converted to   ((1 , 2) , 3);   }{   ((first ,  second),  third);  get converted to   ((1 , 2) , 3);   }		{-------}		procedure addToBuff (ds: str255);		begin			offset := GetHandleSize(dhdl);			ReplaceEndOfHandle(dhdl, offset, Pointer(ord4(@ds) + 1), length(ds));   {sticking tree into buffer}		end;		{-------}		procedure addIntegerToBuff (ib: integer);			var				tib: integer;		begin			tib := ib;			offset := GetHandleSize(dhdl);			ReplaceEndOfHandle(dhdl, offset, @ib, 2);   {sticking tree into buffer}		end;		{-------}		procedure deleteSqBrackStr (tstr: str255);		begin			while (pos('[', tstr) > 0) or (pos(']', tstr) > 0) do				begin					if pos('[', tstr) < pos(']', tstr) then						begin							if pos('[', tstr) = 0 then								delete(tstr, 1, Pos(']', tstr))							else								delete(tstr, Pos('[', tstr), Pos(']', tstr) - Pos('[', tstr) + 1);						end					else						begin							if pos(']', tstr) = 0 then								delete(tstr, Pos('[', tstr), length(tstr) - Pos('[', tstr) + 1)							else								delete(tstr, 1, Pos(']', tstr));						end;				end;		end;		{-------}		function getStringToken: str255;			label				1;			var				dsr: str255;				done: boolean;				ik2: integer;		begin			dsr := ')';			repeat				ik := ik + 1;				if (ik > length(ts)) then					begin						ReadLineFromFile(ts);						if ts = '"еее' then							goto 1;						DeleteSqBrackStr(ts);						ik := 1;					end;				if ts[ik] = ':' then					repeat						ik := ik + 1;						if (ik > length(ts)) then							begin								ReadLineFromFile(ts);								if ts = '"еее' then									goto 1;								DeleteSqBrackStr(ts);								ik := 1;							end;					until ts[ik] in [',', ')', ';'];				if ts[ik] = ')' then					repeat						ik := ik + 1;						if (ik > length(ts)) then							begin								ReadLineFromFile(ts);								if ts = '"еее' then									goto 1;								DeleteSqBrackStr(ts);								ik := 1;							end;					until ts[ik] in [',', ';'];				if ts[ik] = '(' then					NewError(352, 0);			until not (ts[ik] in [chr(13), chr(10), chr(9), ' ', ')', ',']);			if ts[ik] in ['(', ';'] then				dsr := concat(dsr, ts[ik])			else				begin					ik2 := 1;					repeat						dsr := concat(dsr, ts[ik]);						ik := ik + 1;						ik2 := ik2 + 1;						done := (ik > length(ts));						if not done then							done := (ts[ik] in [chr(13), chr(10), ' ', chr(9), ')', '(', ',', ':', ';']);						if not done then							if ik2 = 3 then								if ts[ik - 2] in ['0'..'9'] then  {note change}									done := true;					until done;					ik := ik - 1;				end;			delete(dsr, 1, 1);1:			GetStringToken := dsr;		end;		{-------}		procedure ConvertNode;			var				ir: integer;		begin			tok := GetStringToken;			if tok = '(' then				begin					AddIntegerToBuff(0);  { ( }					ConvertNode;					ConvertNode;				end			else if tok = ';' then				begin				end			else				begin					if not typefound then						begin							bynumbers := true;							for ir := 1 to length(tok) do								begin									if not (tok[ir] in ['0'..'9']) then										bynumbers := false;								end;						end;					if bynumbers then						begin							taxnum := tokentointeger(tok, true);  {Wayne: check out this section, and NewError handling}							addintegertobuff(taxnum);							if (taxnum <= 0) | (taxnum > numtaxa) | (taxnum in taxafound) then  {v3.02:}								begin									LockHandle(dhdl, oldstate);									startP := ptr(getmaster(dhdl));									DeletePackedTaxon(startP, GetHandleSize(dhdl) div 2, GetHandleSize(dhdl) div 2);									HUnlock(dhdl);									sethandleSize(dhdl, gethandlesize(dhdl) - 4);									ResetHandle(dhdl, oldstate);									if taxnum in taxafound then   {v3.02}										NewError(115, 0)									else										NewError(27, 0);								end							else								begin									numterminals := numterminals + 1;									taxafound := taxafound + [taxnum];  {v3.02:}								end;						end					else						begin							it := 0;							repeat								it := it + 1							until (taxonname(it) = tok) or (it = numtaxa);							if (taxonname(it) = tok) & not (it in taxafound) then  {v3.02:}								begin									AddIntegerToBuff(it);									numterminals := numterminals + 1;									taxafound := taxafound + [it];   {v3.02:}								end							else								begin									AddIntegerToBuff(it);									LockHandle(dhdl, oldstate);									startP := ptr(getmaster(dhdl));									DeletePackedTaxon(startP, GetHandleSize(dhdl) div 2, GetHandleSize(dhdl) div 2);									HUnLock(dhdl);									sethandleSize(dhdl, gethandlesize(dhdl) - 4);									ResetHandle(dhdl, oldstate);									if (it in taxafound) then										NewError(115, 0)									else										NewError(27, 0);								end;						end;				end;		end;	begin		DeleteSqBrackStr(ts);		numterminals := 0;		bynumbers := true;		ik := 0;		typefound := false;		taxafound := [];		ConvertNode;	end; {----------------------------------------------------------------------------}	procedure ReadOldFile (var tempP: WindowPtr);		label			1;		var			TaxonHdl: thdl;			ic, it, ir, j, lds: INTEGER;			lir, dL: longint;			dummy, ds, tn: str255;			chrn: char;			readnext, done: boolean;			ctypP, cwtP: IP;			packinhereH: handle;			os: OSErr;			dhp: HdlPtr;			numterminals: integer;			oldState, oldState1, oldState2: SignedByte;			amountneeded: longint;	begin		currentIOPosition := 72;   {v3.05}{======== Scanning Data File ===========}		fpos := kInitialReadPos;		it := 0;		noundo := true;		fixlostbyundo := false;		justundid := false;		ReadLineFromFile(ds);		SetCursID(amoeba);  {READING UNTIL FIRST LINE IN DATA MATRIX}		repeat			ReadLineFromFile(ds);		until ((ds[1] <> '%') and not ((ds[1] >= '0') and (ds[1] <= '9')) and (ds[1] <> '░')) or errorflag;		if errorflag then   {v3.05: this added, as well as errorflag on previous line}			begin				NewError(208, 0);				goto 1;			end;		StripBlanks(ds);  {FINDING WIDTH OF TAXON NAMES}		repeat			it := it + 1		until (((ds[it] >= '0') and (ds[it] <= '9')) or (ds[it] = '?'));		sd := it - 1;  {FINDING CHARLOCS & NUMCHARS}		ic := 1;		repeat			if (ds[it] <> ' ') then				if ((ds[it] >= '0') & (ds[it] <= '9')) | (ds[it] = '?') then					begin						charloc[ic] := it;						ic := ic + 1;					end				else					begin						errorflag := true;						InstantErrorPlus(108, Concat(' Taxon: 1  Character: ', Stringfromnum(ic), ' Offending Symbol: ''', ds[it], ''''));						goto 1;					end;			it := it + 1;		until it > length(ds);		numchars := ic - 1;  {FINDING NUMTAXA}		numtaxa := 0;		while (ds[1] <> '@') and (ds[1] <> '*') and not (fpos>=mcFileLength) and not errorflag do			begin				if not (ds[1] in ['"', '&']) then					numtaxa := numtaxa + 1;				ReadLineFromFile(ds);			end;		if errorflag then			begin				NewError(208, 0);				Exit(ReadOldFile);			end;		SetDataFormat(standard, true);		if not EnoughMemory(FullMemoryNeeded(numtaxa, numchars), amountneeded) then			begin				InstantErrorPlus(268, concat(StringFromNum(amountneeded div 1024), 'K'));				errorflag := true;				goto 1;			end;		if not CreateTaxonCharMemory then			begin				CleanUpFailedTaxonCharacterMemory;				goto 1;			end;		SetCursID(amoeba);		EndThermo(iothermo, tempP, false);		StartThermo(iothermo, tempP, 0, mcFileLength, 'Second Pass', 'percent', true);{======== Reading Data File ===========}				fpos := kInitialReadPos;		ReadLineFromFile(ds);		readnext := true;		dummy := ' ';		repeat			if readnext then				ReadLineFromFile(ds)			else				ds := dummy;			readnext := true;{READING CHARACTER NAMES}			if (ds[1] >= '0') and (ds[1] <= '9') then				begin					dummy := CopyString(ds, 1, pos('.', ds) - 1);					StringToNum(dummy, lir);					ir := LowWord(lir);					if (ir > 0) and (ir <= numchars) then						begin							AddDotsToStateNames(ir);{next 2 while loops to clean out illegal characters}							while pos(',', ds) > 0 do								ds[pos(',', ds)] := ' ';							while pos('=', ds) > 0 do								ds[pos('=', ds)] := ' ';							if pos(':', ds) = 0 then								begin									dummy := CopyString(ds, pos('.', ds) + 1, length(ds) - pos('.', ds));									if length(dummy) > 1 then										if dummy[1] = ' ' then											delete(dummy, 1, 1);									setcharname(ir, dummy);								end							else								begin									dummy := CopyString(ds, pos('.', ds) + 1, pos(':', ds) - pos('.', ds) - 1);									if length(dummy) > 1 then										if dummy[1] = ' ' then											delete(dummy, 1, 1);									setcharname(ir, dummy);									delete(ds, 1, pos(':', ds));									j := 0;									while pos(';', ds) <> 0 do										begin											dummy := CopyString(ds, 1, pos(';', ds) - 1);											if length(dummy) > 1 then												if dummy[1] = ' ' then													delete(dummy, 1, 1);											SetCharStateName(ir, j, dummy);											j := j + 1;											delete(ds, 1, pos(';', ds));										end;								end;						end;					ds := '0';				end			else if (ds[1] = '%') and (ds[2] >= 'a') and (ds[2] <= 'z') then				begin					SetCursID(trilobite);					ReadGenMatrix(ds, dummy, readnext);				end;		until (ds[1] <> '"') and (ds[1] <> '%') and not ((ds[1] >= '0') and (ds[1] <= '9')) or errorflag;		if errorflag then			goto 1;{READING MATRIX}		SetCursID(carabid);		ReadMatrix(ds);		if errorflag then     {if exit here, is taxonchptr memory cleaned up}			goto 1;{READING Type WEIGHTS TREES}		SetCursID(amoeba);		UserLinks[typeSetChain] := 0;		UserLinks[wtSetChain] := 0;		UserLinks[treeChain] := 0;		UserLinks[charPartitionChain] := 0;		for ir := 1 to numtaxa do			begin				TaxonHdl := GetTaxonHdl(ir);				LockHandle(taxonHdl, oldstate);				TaxonHdl^^.labl := StringFromNum(ir);				ResetHandle(taxonHdl, oldstate);			end;		repeat			done := (fpos>=mcFileLength);			case ds[1] of				'*': 					begin						SetCursID(anemone);						LockHandle(chstoretypH, oldstate);						ctypP := IP(GetMaster(chstoretypH));						for ic := 1 to numchars do							begin								ctypP^ := unordered;								if length(ds) >= charloc[ic] then									if ds[charloc[ic]] <> ' ' then										case ds[charloc[ic]] of											'u': 												ctypP^ := unordered;											'r': 												ctypP^ := unordered;											'o': 												ctypP^ := ordered;											'i': 												ctypP^ := irreversible;											'd': 												ctypP^ := dollo;											otherwise												ctypP^ := converttotype(ds[charloc[ic]]);										end;								ctypP := IP(ord4(ctypP) + chtb);							end;						ResetHandle(chstoretypH, oldstate);						ds := CopyString(ds, 2, charloc[1] - 2);						Stripblanks(ds);						if ds = '' then							ds := ' ';						BlanksToUnderline(ds);						SaveLinkToChain(typesetchain, ds, false,false);					end;				'$': 					begin						SetCursID(mouse);						LockHandle(chstorewtH, oldstate);						cwtP := IP(GetMaster(chstorewtH));						for ic := 1 to numchars do							begin								cwtP^ := 1;								if length(ds) >= charloc[ic] then									if ds[charloc[ic]] <> ' ' then										cwtP^ := ord(ds[charloc[ic]]) - 48;								cwtP := IP(ord4(cwtP) + chwb);							end;						ResetHandle(chstorewtH, oldstate);						ds := CopyString(ds, 2, charloc[1] - 2);						Stripblanks(ds);						if ds = '' then							ds := ' ';						BlanksToUnderline(ds);						SaveLinkToChain(wtsetchain, ds, false,false);					end;				'@': 					;				otherwise {Read  tree}					begin						SetCursID(tree);						if ds[1] = '#' then							delete(ds, 1, 1);						Stripblanks(ds);						BlanksToUnderLine(ds);						tn := ds;						ReadLineIntoString(ds);						AddCHUNKs(strCHUNKs[treeChain], 1, SLB);						if badmemory then							begin								badmemory := false;								cycle;							end;						UserLinks[treeChain] := UserLinks[treeChain] + 1;						packinhereH := newhandle(0);						ConvertOldTree(ds, packinhereH, numterminals);						InsertLinkStart(packinhereH, tn);						SetNumtaxaInPackedTree(packinhereH, numterminals);						SetLink(treeChain, EndUserLink(treechain), packinhereH);						ZapHandle(packinhereH);					end;			end;			ReadLineFromFile(ds);		until done or (fpos>=mcFileLength) or errorflag;		if errorflag then			goto 1;		LockHandle(chtypH, oldstate1);		LockHandle(chwtH, oldstate2);		ctypP := IP(GetMaster(chtypH));		cwtP := IP(GetMaster(chwtH));		for ic := 1 to numchars do			begin				ctypP^ := unordered;				ctypP := IP(ord4(ctypP) + chtb);				cwtP^ := 1;				cwtP := IP(ord4(cwtP) + chwb);			end;		ResetHandle(chtypH, oldstate1);		ResetHandle(chwtH, oldstate2);		CopyHandles(chtypH, chstoretypH);		CopyHandles(chwtH, chstorewtH);		ntscreen := 1;  {not needed; just here for test}{to remove underlines from taxon names:}		for it := 1 to numtaxa do			begin				ds := TaxonName(it);				UnderLineToBlanks(ds);				SetTaxonName(it, ds);			end;		newfile := true;		datachanged := true;		ReCalcMaxstAndStates(1,numchars);		fileSaved := false;		filename^^ := 'Untitled';		{SetMenuItemText(FileMHdl, AboutFileItem, 'About Untitled...');}		SetDataFormat(standard, false);1:	end;end.