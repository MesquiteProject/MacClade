unit StatesWindowUtil;{ееееееееееееееееееееее}interface	uses		QuickDraw, 		Types, Events, QuickDrawText, Controls, Menus, OSUtils, TextUtils, Windows, Sound, Dialogs, 		TextEdit, Lists, ToolUtils, Memory, Fonts, Resources, Scrap, 		Globals, MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, 		BoxUtil, TaxonCHUtil, CharUtil, SymbolsNames, TrackThumb;	function StatesRowHeightBottom (rowNumber: integer): integer;	function StatesRowHeightTopFromBottom (bottomHeight: integer): integer;	function StatesRowHeightTop (rowNumber: integer): integer;	function StateNameBoxLeft(theState: integer): integer;	function StateNameBox (theState: integer): Rect;	function CalcStatesWindowHeight: integer;	procedure SetStatesLW;	procedure ResetStatesScroll;	procedure AdjustStatesVScrolls;	procedure MoveStatesTE (theState: integer);	procedure ShrinkWrapStatesWindow (var height: integer);	procedure CalcStatesWindowCharNameBoxStart;	procedure SizeStatesWindow;		procedure UpdateStatesWindowIfCharactersChanged;	const		kCharNameRow=-1;		SWTitleExtraWidth = 3;		SWGridLineWidth=1;		var charNameBoxStart: integer;		stateBeingEdited: integer;		symbolBeingEdited: integer;		maxStateRows: integer;{ееееееееееееееееееееее}implementation {е$S StatesWindow}{-----------------------------------------------------------------------------}	function StatesRowHeightBottom (rowNumber: integer): integer;	{this returns the vertical height of the BOTTOM of the row for row rowNumber,		which corresponds to state rowNumber-1}	begin		StatesRowHeightBottom := statesWindowTitleWidth + statesWindowLineWidth * longint(rowNumber - statesWindowTop + 1);	end;{-----------------------------------------------------------------------------}	function StatesRowHeightTopFromBottom (bottomHeight: integer): integer;	begin		StatesRowHeightTopFromBottom := bottomHeight - statesWindowLineWidth + swGridLineWidth;	end;{-----------------------------------------------------------------------------}	function StatesRowHeightTop (rowNumber: integer): integer;	{this returns the vertical height of the TOP of the row for row rowNumber,		which corresponds to state rowNumber-1}	begin		StatesRowHeightTop := StatesRowHeightTopFromBottom(StatesRowHeightBottom(rowNumber));	end;{-----------------------------------------------------------------------------}{----------------------------------------------------------------------------}	function StateNameBoxLeft(theState: integer): integer;	{theState is the state, not the rownumber}	begin		if theState = kCharNameRow then			StateNameBoxLeft:= charNameBoxStart		else			StateNameBoxLeft:= statesnameStart + 1;	end;{----------------------------------------------------------------------------}	function StateNameBox (theState: integer): Rect;	{theState is the state, not the rownumber}		var			box: rect;	begin		SetRect(box, StateNameBoxLeft(theState), StatesRowHeightTop(theState+1), WindowPortRect(stateswindow).right - scrollwidth - 1, StatesRowHeightBottom(theState+1));		StateNameBox := box;	end;{----------------------------------------------------------------------------}	function CalcStatesWindowHeight: integer;	begin		CalcStatesWindowHeight := statesWindowRows * statesWindowLineWidth + statesWindowTitleWidth+1 + scrollwidth;	end;{-----------------------------------------------------------------------------}	procedure SetStatesLW;		var			tport: windowptr;	begin		genericGetPort(tport);		genericSetPort(statesWindow);		TextFont(statesFont);		TextSize(statesFontSize);		CalcLineWidthDescent(statesTE,statesFont,statesWindowLineWidth,statesFontDescent,statesFontAscent);		statesWindowTitleWidth := statesWindowLineWidth{+SWTitleExtraWidth};		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	procedure ResetStatesScroll;		var			tport: windowptr;	begin		genericGetPort(tport);		genericSetPort(statesWindow);		ClipRect(WindowPortRect(stateswindow));		SizeControl(statesWindowVScroll, scrollwidth + 1, WindowPortRect(stateswindow).bottom - statesWindowTitleWidth - scrollwidth + 2);		MoveControl(statesWindowVScroll, WindowPortRect(stateswindow).right - scrollwidth, statesWindowTitleWidth - 2);		ShowControl(statesWindowVScroll);		if maxStateRows > statesWindowRows then			SetControlMaximumLong(statesWindowVScroll, maxStateRows - statesWindowRows + 1)		else			SetControlMaximumLong(statesWindowVScroll, 1);		SizeControl(statesWindowHScroll, WindowPortRect(stateswindow).right - scrollwidth - statesNameStart, scrollwidth + 1);		MoveControl(statesWindowHScroll, statesNameStart, WindowPortRect(stateswindow).bottom - scrollwidth);		ShowControl(statesWindowHScroll);		SetControlMaximumLong(statesWindowHScroll, numchars);		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	procedure AdjustStatesVScrolls;		var			top: integer;	begin		if maxStateRows > statesWindowRows then   {more characters than can fit in whichinfo at once}			begin				top := maxStateRows - statesWindowRows + 1;				if statesWindowTop > top then					statesWindowTop := top;				SetControlMaximumLong(statesWindowVScroll, top)			end		else	{maxStateRows <= statesWindowRowsthen, characters can all fit onto window at once}			begin				if maxStateRows < statesWindowRows then					begin						statesWindowRows := maxStateRows;						SizeStatesWindow;					end;				SetControlMaximumLong(statesWindowVScroll, 1);			end;	end;{----------------------------------------------------------------------------}	procedure MoveStatesTE (theState: integer);		var			box: rect;	begin		box := StateNameBox(theState);		box.left := box.left + 4;		box.right := box.right - 1;{insetrect(box, 2, 1);}		statesTE^^.destRect := box;		statesTE^^.viewRect := box;	end;{----------------------------------------------------------------------------}	procedure ShrinkWrapStatesWindow (var height: integer);	begin		statesWindowRows := ((height + 1-scrollwidth-statesWindowTitleWidth) div statesWindowLineWidth);		if maxStateRows < statesWindowRows then			begin				statesWindowTop := 1;				statesWindowRows := maxStateRows;			end;		if (statesWindowRows < maxStateRows) & (maxStateRows >= 1) & (maxStateRows <= 4) then			statesWindowRows := maxStateRows;		height := CalcStatesWindowHeight;	end;{-----------------------------------------------------------------------------}	procedure CalcStatesWindowCharNameBoxStart;	var 		tport: WindowPtr;	begin		genericGetPort(tport);		genericSetPort(statesWindow);		TextFace([bold]);		charNameBoxStart := statesNameStart+StringWidth(StringFromNum(numchars))+StringWidth('. ')+8;		TextFace([]);		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	procedure UpdateStatesWindowIfCharactersChanged;	begin		if statesWindowOpen then			begin				CalcStatesWindowCharNameBoxStart;				if stateBeingEdited=kCharNameRow then					MoveStatesTE(stateBeingEdited);				InvalidateWindow(statesWindow,true);			end;	end;{-----------------------------------------------------------------------------}	procedure SizeStatesWindow;		var			width, height: integer;			tport: windowptr;	begin		maxStateRows := maxstate + 1;		genericGetPort(tport);		genericSetPort(statesWindow);		SetStatesLW;		height := WindowPortRect(stateswindow).bottom;		width := WindowPortRect(stateswindow).right;		statesSymbolWidth := StringWidth(StringFromNum(maxStateRows)) + 8;		statesNameStart := 2 * statesSymbolWidth;		CalcStatesWindowCharNameBoxStart;				ShrinkWrapStatesWindow(height);		if statesEditing then			MoveStatesTE(stateBeingEdited);		HideControl(statesWindowHScroll);		HideControl(statesWindowVScroll);		SizeWindow(statesWindow, width, height, false);		ResetStatesScroll;		InvalidateWindowRect(statesWindow,WindowPortRect(stateswindow),false);		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}end.