unit ImportAlignment;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, 		Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, 		EventUtil, GenUtil, StrUtil, TaxonCHUtil, MenuUtil, SymbolsNames, Footnote, Thermos, 		CharUtil, InfoWindows, TypeUtil, ReadWriteUtil, ReadUtil, CHUNK, ReadTreeFile, LinkUtil, 		Windows, RowColumn;	function ChooseImportAlignment(fileformat: integer): boolean;{еееееееееееееееееееееее}implementation {е$S ImportAlignment}{-----------------------------------------------------------------------------}	function TaxonNumberFromHandle (fileformat: integer; H: Handle): integer;		var			c: char;			ds: str255;			db: boolean;			icProt: longint;	begin		TaxonNumberFromHandle := 0;		case fileformat of			nbrf:				begin					db := FindRawFileChar(';',false);					if not db then Exit(TaxonNumberFromHandle);					next := anynextchar;					ds := GetFileToken(tnw+1);					UnderLineToBlanks(ds);  {this is taxon name}					TaxonNumberFromHandle := GetTaxonNumber(ds);				end;			otherwise;		end;	end;{-----------------------------------------------------------------------------}	function ForeignSequenceLength (fileformat: integer;H: Handle): longint;		var			c: char;			ds: str255;			db: boolean;			icProt: longint;	begin		icProt := 0;		case fileformat of			nbrf:				begin					db := FindRawFileChar(';',false);					if not db then Exit(ForeignSequenceLength);					next := anynextchar;					ds := GetFileToken(tnw+1);					UnderLineToBlanks(ds);  {this is taxon name}					if not NewLineChar(next) then						repeat						until NewLineChar(anynextchar) or (fpos >= mcFileLength);   {skipping to end of line}					next := anynextchar;					{skipping to new line}					if not NewLineChar(next) then						repeat							c := anynextchar;						until NewLineChar(c) or (fpos >= mcFileLength);   {skipping comment line}					if  (fpos < mcFileLength) then						c := nextDarkChar;					repeat						icProt := icProt + 1;						c := nextDarkChar;					until (fpos >= mcFileLength) | (c = '*') | errorflag | badfile;				end;			otherwise;		end;		ForeignSequenceLength := icProt;	end;{-----------------------------------------------------------------------------}{-----------------------------------------------------------------------------}	procedure TransferStateFromImportCellBlock (it,ic: integer; var icStored: integer; cellBlock: cellBlockPtr; var tooMuchData: boolean);		var			tsts: largestsetchars;			smallSymbol: boolean;	begin		if not tooMuchData & (ic<= numchars) & (icStored<= cellBlock^.nchar) then 			begin				tsts := CellBlockStates(cellBlock,1,icStored,icStored, smallSymbol);				if tsts=[MSl,GAl] then					repeat						icStored := icStored+1;						if icStored<= cellBlock^.nchar then  tsts := CellBlockStates(cellBlock,1,icStored,icStored, smallSymbol);					until (tsts <> [MSl,GAl]) | (icStored> cellBlock^.nchar);				if icStored<= cellBlock^.nchar then 					SettaxonStsLargest(it, ic, tsts)				else tooMuchData := true;			end		else tooMuchData := true;	end;{-----------------------------------------------------------------------------}	procedure AlignNucToProtNBRFHandle (H: Handle; it: integer; cellBlock: cellBlockPtr);		var			c: char;			ds: str255;			ic, icStored,furtheric, theTaxon: integer;			tsts: largestsetchars;			db: boolean;			oldFPos, dL, oldFileLength, icProt: longint;			smallSymbol: boolean;			anyMissing , tooMuchData: boolean;	begin		db := FindRawFileChar(';',false);		if not db then Exit(AlignNucToProtNBRFHandle);		next := anynextchar;		ds := GetFileToken(tnw+1);		UnderLineToBlanks(ds);  {this is taxon name}		theTaxon := it;		if not NewLineChar(next) then			repeat			until NewLineChar(anynextchar) or (fpos >= mcFileLength);   {skipping to end of line}		next := anynextchar;					{skipping to new line}		if not NewLineChar(next) then			repeat				c := anynextchar;			until NewLineChar(c) or (fpos >= mcFileLength);   {skipping comment line}		if  (fpos < mcFileLength) then			c := nextDarkChar		else			begin				NewError(460,0);				Exit(AlignNucToProtNBRFHandle);			end;		icProt := 0;		ic := 0;		icStored := 0;		anyMissing := false;		tooMuchData := false;		repeat			icProt := icProt + 1;			ic := ic+1;   {this is the number in the nucleotide sequence}			if (c = '-') or  (c = '~') then   {put three gaps}				begin					SettaxonStsLargest(it, ic, [MSl,GAl]);					ic := ic+1;					if ic<= numchars then SettaxonStsLargest(it, ic, [MSl,GAl]);					ic := ic+1;					if ic<= numchars then SettaxonStsLargest(it, ic, [MSl,GAl]);				end			else 					{get next three non-gaps}				begin					if  ((c='N') |(c='n') |(c='X') |(c='x')) then						anyMissing := true;					icStored := icStored+1;					TransferStateFromImportCellBlock (it,ic,icStored,cellBlock, tooMuchData);					ic := ic+1;					icStored := icStored+1;					TransferStateFromImportCellBlock (it,ic,icStored,cellBlock, tooMuchData);					ic := ic+1;					icStored := icStored+1;					TransferStateFromImportCellBlock (it,ic,icStored,cellBlock, tooMuchData);					if tooMuchData then						begin							if anyMissing then								NewError(459,0)							else								NewError(458,0);							ic := numchars;  // to signal end of sequence						end;									end;			c := nextDarkChar;		until (fpos >= mcFileLength) | (c = '*') | errorflag | (ic>=numchars);//		if (c='*') & (ic<numchars) then//			errorflag := true;	end;{-----------------------------------------------------------------------------}	procedure ImportProteinAlignment (fileformat: integer);		label 1;		var			c: char;			ds: str255;			itProt,it,maxic,ic, furtheric: integer;			originalNumChars: integer;			tsts: largestsetchars;			H: Handle;			newNumChars : integer;			db,foundStop, success: boolean;			oldFPos, dL, oldFileLength, oldReadBufferP, oldreadBufLength: longint;			oldnext: char;			BR,TL: point;			cellBlock: cellBlockPtr;			lineEmpty: boolean;	begin		if editorSelected and editorOpen and SingleCell then  			begin				ReturnValue(editorSelectionTopLeft,false);				if badcellentry then					if BadCellEntryQuery then						badcellentry := false					else						Exit(ImportProteinAlignment);				ZeroSelection;			end;		if not StoreCellBlockForUndo(1, numtaxa, 1, numchars, true,true,false) then Exit(ImportProteinAlignment);		itProt := 1;		originalNumChars:= numchars;		CreateCellBlock(cellBlock);		lineEmpty := false;		repeat		//	if ShowIOThermo then UpdateThermo(iothermo, 0, fpos, mcFileLength,true);			H:= NewHandle(0);			case fileFormat of 				nbrf: 					LineToHandle(H,'*',false,false,foundStop, lineEmpty,3);				genbank:					LineToHandle(H,'//',true,false,foundStop, lineEmpty,0);				simpletext:					LineToHandle(H,'',false,false,foundStop, lineEmpty,0);				sequenceOnly:					LineToHandle(H,'',false,false,foundStop, lineEmpty,0);				fastA:					begin						if itProt = 1 then  {we are on first one; need to skip over leading stop character}							Skipper(['>'],false);						LineToHandle(H,'>',true,false,foundStop, lineEmpty,0);						if fpos >= mcFileLength then foundStop := true;  {since it doesn't end with a stop character...}					end;				otherwise;			end;			if lineEmpty then				begin					ZapHandle(H);					leave;				end;			if not foundStop  then				begin					NewError(460,0);					ZapHandle(H);					leave;				end;							if badmemory then				begin					errorflag := true;					ZapHandle(H);					leave;				end;						if itProt = 1 then				begin					StartReadingFromHandle(H,oldFPos, oldFileLength, oldReadBufferP, oldreadBufLength,oldnext);					newNumChars := ForeignSequenceLength(fileFormat,H)*3;					if newNumChars > numchars then						AddNewCharacters(newNumChars-numchars,true);					EndReadingFromHandle(H,oldFPos, oldFileLength, oldReadBufferP, oldreadBufLength,oldnext);				end;			StartReadingFromHandle(H,oldFPos, oldFileLength, oldReadBufferP, oldreadBufLength,oldnext);			it := TaxonNumberFromHandle(fileFormat,H);			EndReadingFromHandle(H,oldFPos, oldFileLength, oldReadBufferP, oldreadBufLength,oldnext);						if (it<1) then				begin					//errorflag := true;					goto 1;				end			else if (it>numtaxa) then				begin					//errorflag := true;					goto 1;				end;			if editorTransposed then				begin					TL.h := it;					BR.h := it;					TL.v := 1;					BR.v := numchars;				end			else				begin					TL.v := it;					BR.v := it;					TL.h := 1;					BR.h := numchars;				end;							if StoreDataIntoCellBlock(cellBlock, BR,TL, true,true,true,false, false,false) then				for ic := 1 to numChars do   {set to all gaps}					SettaxonStsLargest(it, ic, [MSl,GAl]);							StartReadingFromHandle(H,oldFPos, oldFileLength, oldReadBufferP, oldreadBufLength,oldnext);			case fileFormat of 				nbrf: 					AlignNucToProtNBRFHandle(H,it, cellBlock);				otherwise;			end;			EndReadingFromHandle(H,oldFPos, oldFileLength, oldReadBufferP, oldreadBufLength,oldnext);				1:		itProt := itProt + 1;			ZapHandle(H);		until (fpos >= mcFileLength) | errorflag;		DestroyCellBlock(cellBlock);		if errorflag then			UndoCellBlock(true)		else			SetCodonPositions(1, newNumChars, 1, true, false);		end;{----------------------------------------------------------------------------}	function ImportAlignmentFromFile(fileformat: integer) : boolean;		var			j: integer;			oldNumChars: longint;			theFile,command: str255;			db: boolean;			tempP: WindowPtr;	begin		FDI^[readFileFDI].fs:= FDI^[extraIOFileFDI].fs;		ImportAlignmentFromFile := false;						fpos := kInitialReadPos;		FDI^[readFileFDI].fs := FDI^[extraIOFileFDI].fs;		ioFileFDI := extraIOFileFDI;		SetFileLength(FDI^[readFileFDI].fs);		if errorFlag then Exit(ImportAlignmentFromFile);		if MakeCaps(GetFileToken(maxtok)) = '#NEXUS' then			begin				NewError(441,0);				errorFlag := true;				Exit(ImportAlignmentFromFile);			end		else			fpos := kInitialReadPos;		if errorFlag then Exit(ImportAlignmentFromFile);		//DisableWindowUpdates(editorwindow);		//DisableWindowUpdates(infowindow[charinfo]);		SetCursor(clockCursor);		oldNumChars:= numchars;		ImportProteinAlignment(fileformat);		InvalidateWindow(editorWindow,true);		InvalidateAllWindowsMarkedUnupdatable;		ImportAlignmentFromFile := true;	//	SetLastChangeInEditor(lastChangeCantUndo);	end;{----------------------------------------------------------------------------}	function ChooseImportAlignment(fileformat: integer): boolean;		label			1;		var			typeList: SFTypelist;  {typelist::}			j: integer;			oldNumChars: longint;			theFile,command: str255;			db: boolean;			tempP: WindowPtr;	begin		typeList[0] := 'TEXT';		typeList[1] := '????';		ChooseImportAlignment := false;		if ChooseFile(2, @typeList, nil, theFile, FDI^[extraIOFileFDI].fs,false,false,false) then			begin				FDI^[readFileFDI].fs:= FDI^[extraIOFileFDI].fs;				ChooseImportAlignment := ImportAlignmentFromFile(fileformat);			end;1:	end;end.