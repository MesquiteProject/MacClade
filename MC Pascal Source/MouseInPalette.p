unit MouseInPalette;{본본본본본본본본본본본볗{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{본본본본본본본본본본본볗interface	uses		QuickDraw, Printing,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, 		Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap, 		 Globals, SetLibInterface, UtilLibInterface,  BoxUtil, MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil,		  ErrorUtil, EventUtil, GenUtil, StrUtil, Coloring, Continuous, EditMenu, EditUtilMenu, FootNote, 		TaxonCHUtil, MenuUtil, SpreadUtil, CharUtil, DrawSpread, EditControl, 		InfoWindows, TreeDrawer, Windows, MouseInTree,  TraceAllChangesCalc, TraceMenu;	procedure MouseInPaletteWindow(whichToolPalette: integer; mouseLoc: point);{본본본본본본본본본본본볗implementation {-----------------------------------------------------------------------------}	procedure DropFillStatePopUp (box:rect);	var	ds: str255;	begin		if paintBucketFillCellsWithState=[] then			ds := symbols[1]		else if paintBucketFillCellsWithState = [MSl] then			ds := missing		else if paintBucketFillCellsWithState = [MSl,GAl] then			ds := gap		else if paintBucketFillCellsWithState = [ERl] then			ds := concat('not (',missing,' or ',gap,')')		else			ds := symbols[MinLg(paintBucketFillCellsWithState)+1];		DrawPopUpRect(box, ds);	end; {-----------------------------------------------------------------------------}	procedure RestrictFillOptionsUser (theDialog: DialogPtr; itemNo: Integer);	var box: rect;	begin		FrameButton(theDialog, 1);		box := GetDLOGItemBox(theDialog, 5);		DropFillStatePopUp(box);	end;{----------------------------------------------------------------------------}	procedure RestrictFillOptions;		label			1;		var			theDialog: DialogPtr;			tempP: WindowPtr;			ds: str255;			localItemHit: integer;			box: rect;			H: Handle;			oldFillFraction: integer;			restrictFillState: boolean;			oldStateToFill: largestSetChars;UserItemUProcP: UniversalProcPtr; {.....}		procedure GrabFillFraction;		begin			ds := GetEditText(theDialog, 7);			if (ds = '') or (ds = ' ') then				paintBucketFillFraction := defaultFillFraction			else				begin					paintBucketFillFraction := RoundValue(TokenToReal(ds)*defaultFillFraction);					if (paintBucketFillFraction <= 0) | (paintBucketFillFraction > defaultFillFraction) then						begin							paintBucketFillFraction := defaultFillFraction;							SetDLOGText(theDialog, 7, '1.0', true);							Beep;							LocalItemHit := notInDialog;						end;				end;		end; {.....}	begin		oldFillFraction := paintBucketFillFraction;		oldStateToFill := paintBucketFillCellsWithState;		restrictFillState := paintBucketFillCellsWithState<>[];		StartDLOG(168, theDialog, tempP);		RealToString((1.0* paintBucketFillFraction/defaultFillFraction), ds, 10, 3, false);		SetDLOGText(theDialog, 7, ds, true);UserItemUProcP := MyNewUserItemUPP(@RestrictFillOptionsUser);  H := Handle(UserItemUProcP);		box := GetDLOGItemBox(theDialog, 5);		SetDialogItem(theDialog, 5, UserItem, H, box);		ItemCheckMark (theDialog,4,restrictFillState);		myShowDialog(theDialog);1:		repeat			ModalDialog(nil, localItemHit);			case localItemHit of				4:					begin						restrictFillState := not restrictFillState;						if restrictFillState & (paintBucketFillCellsWithState= []) then							paintBucketFillCellsWithState:= [0];						ItemCheckMark (theDialog,4,restrictFillState);					end;				5:					begin						PopUpStatesMenu(box.topleft,0,-3);						restrictFillState := paintBucketFillCellsWithState<>[];						box := GetDLOGItemBox(theDialog, 5);						DropFillStatePopUp(box);					end;				otherwise					;			end;			ItemCheckMark (theDialog,4,restrictFillState);		until localItemHit in [1, 2];		if (localItemHit = 1) then			begin				GrabFillFraction;				if localItemHit = notInDialog then					goto 1;			end;MyDisposeUserItemUPP(UserItemUProcP);		EndDLOG(theDialog, tempP);		if localItemHit = 2 then			begin				paintBucketFillFraction := oldFillFraction;				paintBucketFillCellsWithState := oldStateToFill;			end		else if localitemhit=1 then			begin				if not restrictFillState & (paintBucketFillCellsWithState<>[]) then					paintBucketFillCellsWithState:= [];				InvalidateTool(editorTools,editorBucketT);			end;	end;{-----------------------------------------------------------------------------}	procedure GapCostsDialog;		label			1;		var			theDialog: DialogPtr;			tempP: WindowPtr;			ds: str255;			LI: longint;			localItemHit: integer;			theCost: integer;			OldterminalGapStartCost, OldterminalGapExtensionCost: integer;			OldgapStartCost, OldgapExtensionCost: integer;			{...............}	procedure GetEditValuesGapCosts(itemNumber: integer; var cost: integer);	begin		ds := GetEditText(theDialog, itemNumber);		if StringIsLongint(ds) then			begin				StringToNum(ds, LI);				if LI<0 then 					begin						Beep;						goto 1;					end				else					cost := LI;			end		else			begin				Beep;				goto 1;			end;	end;{...............}	begin		oldterminalGapStartCost := terminalGapStartCost;		OldterminalGapExtensionCost :=terminalGapExtensionCost;		OldgapStartCost := gapStartCost;		OldgapExtensionCost := gapExtensionCost;		StartDLOG(153, theDialog, tempP);		SetDLOGText(theDialog,3, StringFromNum(terminalGapStartCost), true);		SetDLOGText(theDialog,4, StringFromNum(terminalGapExtensionCost), false);		SetDLOGText(theDialog,5, StringFromNum(gapStartCost), false);		SetDLOGText(theDialog,6, StringFromNum(gapExtensionCost), false);		SetDLOGText(theDialog,12, StringFromNum(alignmentChangeCost), false);		SetDLOGText(theDialog,14, StringFromNum(alignmentInnerCodonCost), false);		myShowDialog(theDialog);		FrameButton(theDialog, 1);1:		repeat			ModalDialog(nil, localItemHit);			{if localItemHit in [3,4,5,6,12] then				begin					GetEditValuesGapCosts(localItemHit, theCost);					if localitemHit = 				end;}		until localItemHit in [1, 2];		if localItemHit = 1 then			begin				GetEditValuesGapCosts(3, terminalGapStartCost);				GetEditValuesGapCosts(4,terminalGapExtensionCost);				GetEditValuesGapCosts(5, gapStartCost);				GetEditValuesGapCosts(6, gapExtensionCost);				GetEditValuesGapCosts(12, alignmentChangeCost);				GetEditValuesGapCosts(14, alignmentInnerCodonCost);				if (terminalGapStartCost + terminalGapExtensionCost)<=0 then					begin						InstantInfo('The Terminal Gap Opening Cost and the Terminal Gap Extension Cost cannot both be equal to 0'); 						terminalGapStartCost := OldterminalGapStartCost;						terminalGapExtensionCost :=OldterminalGapExtensionCost;						goto 1;					end;				if (gapStartCost + gapExtensionCost)<=0 then					begin						InstantInfo('The Gap Opening Cost and the Gap Extension Cost cannot both be equal to 0'); 						gapStartCost := OldgapStartCost;						gapExtensionCost :=OldgapExtensionCost;						goto 1;					end;			end;		EndDLOG(theDialog, tempP);	end;{-----------------------------------------------------------------------------}	procedure CodonCostsDialog;		label			1;		var			theDialog: DialogPtr;			tempP: WindowPtr;			ds: str255;			LI: longint;			localItemHit: integer;			{...............}	procedure GetEditValuesCodonCosts(itemNumber: integer; var cost: integer);	begin		ds := GetEditText(theDialog, itemNumber);		if StringIsLongint(ds) then			begin				StringToNum(ds, LI);				cost := LI;			end		else			begin				Beep;				goto 1;			end;	end;{...............}	begin		StartDLOG(151, theDialog, tempP);		SetDLOGText(theDialog,3, StringFromNum(alignmentCodonCosts[1]), true);		SetDLOGText(theDialog,4, StringFromNum(alignmentCodonCosts[2]), false);		SetDLOGText(theDialog,5, StringFromNum(alignmentCodonCosts[3]), false);		SetDLOGText(theDialog,6, StringFromNum(alignmentCodonCosts[-1]), false);		SetDLOGText(theDialog,7, StringFromNum(alignmentCodonCosts[0]), false);		myShowDialog(theDialog);		FrameButton(theDialog, 1);1:		repeat			ModalDialog(nil, localItemHit);		until localItemHit in [1, 2];		if localItemHit = 1 then			begin				GetEditValuesCodonCosts(3, alignmentCodonCosts[1]);				GetEditValuesCodonCosts(4, alignmentCodonCosts[2]);				GetEditValuesCodonCosts(5, alignmentCodonCosts[3]);				GetEditValuesCodonCosts(6, alignmentCodonCosts[-1]);				GetEditValuesCodonCosts(7, alignmentCodonCosts[0]);			end;		EndDLOG(theDialog, tempP);	end;{----------------------------------------------------------------------------}	procedure PopUpToolPaletteMenu (whichPalette, whichTool: integer; Event: EventRecord);		var			menucode: longint;			ItemNo, currentsel, j: integer;			TempMHdl: MenuHandle;			success, oldUseOpt: boolean;			newNodeItem, curItem: integer;			clearNodeItem: integer;			it: integer;			ds: str255;			theSpot: point;	begin		theSpot:= Event.where;		oldUseOpt := UseOptionTool(whichPalette,whichTool,OptionEvent(Event));		TempMHdl := nil;		TempMHdl := NewMenu(TemporaryMenu, 'Tool Options');		if TempMHdl= nil then			begin				InstantInfo('Problems creating pop-up menu');				 Exit(PopUpToolPaletteMenu);			end;				if whichPalette=editorTools then			case whichTool of				blockMoveT: 					begin						AppendMenu(tempMHdl,'Allow Matrix Edges to Expand');						myCheckMenuItem(tempMHdl,1,blockMovePushBoundaries);						AppendMenu(tempMHdl,'Move Entire Sequence');						myCheckMenuItem(tempMHdl,2,blockMoveEntireSequence);						AppendMenu(tempMHdl,'Accumulate Sticky Blocks');						myCheckMenuItem(tempMHdl,3,blockMoveAccumulate);						AppendMenu(tempMHdl,'Allow Block Splitting');						myCheckMenuItem(tempMHdl,4,blockMoveSplitBlockToo);					end;				splitBlockT: 					begin						AppendMenu(tempMHdl,'Multiple Sequence Selection Mode');						myCheckMenuItem(tempMHdl,1,splitBlockMultiSequence);						AppendMenu(tempMHdl,'Move All Blocks on Side');						myCheckMenuItem(tempMHdl,2,splitBlockEntireSequence);						AppendMenu(tempMHdl,'Allow Matrix Edges to Expand');						myCheckMenuItem(tempMHdl,3,splitBlockPushBoundaries);					end;				selectedBlockMoveT:					begin						AppendMenu(tempMHdl,'Normal Mode');						myCheckMenuItem(tempMHdl,1,selectedBlockMoveMode=selectedBlockMoveNormalMode);						AppendMenu(tempMHdl,'Shift Specified Amount');						myCheckMenuItem(tempMHdl,2,selectedBlockMoveMode=selectedBlockMoveSpecifiedMode);						AppendMenu(tempMHdl,'Shift to Clicked Position');						myCheckMenuItem(tempMHdl,3,selectedBlockMoveMode=selectedBlockMoveClickMode);					end;				popUpStatesT:					begin						AppendMenu(tempMHdl,'Enter Data');						myCheckMenuItem(tempMHdl,1,popUpEnterStates);						AppendMenu(tempMHdl,'Show Cell Info');						myCheckMenuItem(tempMHdl,2,not popUpEnterStates);					end;				magicWandT:					begin						AppendMenu(tempMHdl,'Normal Mode');						myCheckMenuItem(tempMHdl,1,magicWandMode=magicWandNormalMode);						AppendMenu(tempMHdl,'Block Mode, Taxon Priority');						myCheckMenuItem(tempMHdl,2,magicWandMode=magicWandExtendTaxaBlockMode);						AppendMenu(tempMHdl,'Block Mode, Character Priority');						myCheckMenuItem(tempMHdl,3,magicWandMode=magicWandExtendCharactersBlockMode);						AppendMenu(tempMHdl,'Mixed Block Mode');						myCheckMenuItem(tempMHdl,4,magicWandMode=magicWandMixedBlockMode);												AppendMenu(tempMHdl,'(-');						AppendMenu(tempMHdl,'Select Entire Sequence');						myCheckMenuItem(tempMHdl,6,magicWandEntireSequence);						EnableDisableItem(tempMHdl,6,magicWandMode=magicWandNormalMode);					end;				editorBucketT: 					begin						AppendMenu(tempMHdl,'Fill with Paint');						myCheckMenuItem(tempMHdl,1,paintBucketMode=paintBucketNormalMode);						AppendMenu(tempMHdl,'Fill with Random [Set Frequencies]');						myCheckMenuItem(tempMHdl,2,paintBucketMode=paintBucketRandomMode);						AppendMenu(tempMHdl,'Fill with Random [Observed States, Equal Frequencies]');						myCheckMenuItem(tempMHdl,3,paintBucketMode=paintBucketFillObservedStatesMode);						AppendMenu(tempMHdl,'Fill with Random [Observed States, Observed Frequencies]');						myCheckMenuItem(tempMHdl,4,paintBucketMode=paintBucketFillObservedFreqMode);						AppendMenu(tempMHdl,'(-');						AppendMenu(tempMHdl,'Restrict Fill...');					end;				showPictureT:					begin						AppendMenu(tempMHdl,'Pop Up Picture');						myCheckMenuItem(tempMHdl,1,showPicturesMode=showPicturesPopUpMode);						AppendMenu(tempMHdl,'Show Picture in Separate Window');						myCheckMenuItem(tempMHdl,2,showPicturesMode=showPicturesWindowMode);					end;				editorSortT:					begin						AppendMenu(tempMHdl,'Sort Descending');						myCheckMenuItem(tempMHdl,1,not editorSortAscending);					end;									selectToEndT:					begin						AppendMenu(tempMHdl,'Select To Last Character');						myCheckMenuItem(tempMHdl,1,selectToEndMode=selectToLastCharacterMode);						AppendMenu(tempMHdl,'Select To First Character');						myCheckMenuItem(tempMHdl,2,selectToEndMode=selectToFirstCharacterMode);						AppendMenu(tempMHdl,'Select To Last Taxon');						myCheckMenuItem(tempMHdl,3,selectToEndMode=selectToLastTaxonMode);						AppendMenu(tempMHdl,'Select To First Taxon');						myCheckMenuItem(tempMHdl,4,selectToEndMode=selectToFirstTaxonMode);						InvalidateWindow(toolPaletteWindow[editorTools], false);						AppendMenu(tempMHdl,'(-');						if (selectToEndMode=selectToLastCharacterMode) | (selectToEndMode=selectToLastTaxonMode) then							AppendMenu(tempMHdl,'Select Trailing Gaps')						else							AppendMenu(tempMHdl,'Select Leading Gaps');						myCheckMenuItem(tempMHdl,6, selectToEndIncludeTerminalGaps);											end;									autoAlignT:					begin						AppendMenu(tempMHdl,'Substitution and Gap Costs...');						//AppendMenu(tempMHdl,'Codon Position Cost...');						AppendMenu(tempMHdl, 'Treat Terminal Missing as Gaps');						myCheckMenuItem(tempMHdl,2,alignTreatsTerminalMissingAsGaps);						AppendMenu(tempMHdl, 'Slow Method Using Less Memory');						myCheckMenuItem(tempMHdl,3,not useGotohIfPossible);						AppendMenu(tempMHdl, 'Align Selected Blocks if Touched');						myCheckMenuItem(tempMHdl,4,autoAlignSelected);						AppendMenu(tempMHdl,'(-');						AppendMenu(tempMHdl,'unordered');						myCheckMenuItem(tempMHdl,6,alignmentCostMatrix=unordered);						curItem := 7;						for j := usedef to numtypes do	{adding user-defined types to menu}							begin								typeHdl := gettypeHdl(j);								if not typeHdl^^.polar & (typeHdl^^.root<0) then									begin										AppendMenu(tempMHdl, ' ');										ds := typeHdl^^.name;										SetMenuItemText(tempMHdl, curItem, ds);  										myCheckMenuItem(tempMHdl,curItem,alignmentCostMatrix=j);										curItem := curItem+1;									end;							end;					end;									closeGapsT:					begin						AppendMenu(tempMHdl,'Move as Far Toward End as Possible');						myCheckMenuItem(tempMHdl,1,closeGapsTowardEnd);						AppendMenu(tempMHdl,'Move as Far Toward Start as Possible');						myCheckMenuItem(tempMHdl,2,not closeGapsTowardEnd);						AppendMenu(tempMHdl,'(-');						AppendMenu(tempMHdl,'Move Block, Normal Mode');						myCheckMenuItem(tempMHdl,4,closeGapsMode=closeGapsNormalMode);						AppendMenu(tempMHdl,'Only Collapse All Contained Gaps');						myCheckMenuItem(tempMHdl,5,closeGapsMode=closeGapsCloseAllMode);						if nucleotides then							AppendMenu(tempMHdl,'Shift One Base if Gaps on Edge')						else if datatype=protein then							AppendMenu(tempMHdl,'Shift One AA if Gaps on Edge')						else							AppendMenu(tempMHdl,'Shift One Cell if Gaps on Edge');						myCheckMenuItem(tempMHdl,6,closeGapsMode=closeGapsSingleBaseMode);						if nucleotides then							AppendMenu(tempMHdl,'Shift Exactly One Base')						else if datatype=protein then							AppendMenu(tempMHdl,'Shift Exactly One AA')						else							AppendMenu(tempMHdl,'Shift Exactly One Cell');						myCheckMenuItem(tempMHdl,7,closeGapsMode=closeGapsExactlyOneBaseMode);						InvalidateWindow(toolPaletteWindow[editorTools], false);					end;									editorScissorsT:					begin						AppendMenu(tempMHdl,'Excise and shift toward start');						myCheckMenuItem(tempMHdl,1,editorScissorsShiftsToStart);						AppendMenu(tempMHdl,'Excise and shift toward end');						myCheckMenuItem(tempMHdl,2,not editorScissorsShiftsToStart);						AppendMenu(tempMHdl,'(-');						AppendMenu(tempMHdl,'Warn before excising data');						myCheckMenuItem(tempMHdl,4,editorScissorsWarn);						InvalidateWindow(toolPaletteWindow[editorTools], false);					end;									otherwise					;			end		else if whichPalette=treeTools then			case whichTool of 				evolveSegmentsT:					begin						AppendMenu(tempMHdl,'Normal Mode');						myCheckMenuItem(tempMHdl,1,evolveSegmentsToolMode=evolveSegmentsNormalMode);						AppendMenu(tempMHdl,'Assign 1');						myCheckMenuItem(tempMHdl,2,evolveSegmentsToolMode=evolveSegmentsAllOneMode);						AppendMenu(tempMHdl,'Assign Random');						myCheckMenuItem(tempMHdl,3,evolveSegmentsToolMode=evolveSegmentsRandomMode);						{AppendMenu(tempMHdl,'Assign Ultrametric');						myCheckMenuItem(tempMHdl,3,evolveSegmentsToolMode=evolveSegmentsUltraMetricMode);}					end;				treePictureT:					begin						AppendMenu(tempMHdl,'Pop Up Picture');						myCheckMenuItem(tempMHdl,1,showPicturesMode=showPicturesPopUpMode);						AppendMenu(tempMHdl,'Show Picture in Separate Window');						myCheckMenuItem(tempMHdl,2,showPicturesMode=showPicturesWindowMode);					end;				rerootT:					begin						AppendMenu(tempMHdl,'Reroot entire visible tree');						myCheckMenuItem(tempMHdl,1,rerootToolRootsDrawR);						AppendMenu(tempMHdl,'Reroot within clade');						myCheckMenuItem(tempMHdl,2, not rerootToolRootsDrawR);						InvalidateWindow(toolPaletteWindow[treeTools], false);					end;									scissorsT:					begin						AppendMenu(tempMHdl,'Exclude all above branch');						myCheckMenuItem(tempMHdl,1,scissorsCutAbove);						AppendMenu(tempMHdl,'Exclude all visible below branch');						myCheckMenuItem(tempMHdl,2, not scissorsCutAbove);						InvalidateWindow(toolPaletteWindow[treeTools], false);					end;								collapseAllT:					begin						AppendMenu(tempMHdl,'Collapse above clade');						myCheckMenuItem(tempMHdl,1,collapseAllCollapsesAbove);						AppendMenu(tempMHdl,'Collapse all visible below branch');						myCheckMenuItem(tempMHdl,2, not collapseAllCollapsesAbove);						InvalidateWindow(toolPaletteWindow[treeTools], false);					end;								SwapT:					begin						AppendMenu(tempMHdl,'Search above branch');						myCheckMenuItem(tempMHdl,1,swapAbove);						AppendMenu(tempMHdl,'Search below branch');						myCheckMenuItem(tempMHdl,2, not swapAbove);						AppendMenu(tempMHdl,'(-');						AppendMenu(tempMHdl,'SPR+NNI combination search');						myCheckMenuItem(tempMHdl,4, fancySearch);						AppendMenu(tempMHdl,'Multiple Rearrangements');						myCheckMenuItem(tempMHdl,5, multipleSwaps);						//AppendMenu(tempMHdl,'Quickest Descent');						//myCheckMenuItem(tempMHdl,5, quickestdescent);						AppendMenu(tempMHdl,'Search for longer trees');						myCheckMenuItem(tempMHdl,6, searchForLongTrees);						AppendMenu(tempMHdl,'(-');						AppendMenu(tempMHdl,'Show new trees during search');						myCheckMenuItem(tempMHdl,8, showNewTreeWhileSearching);						AppendMenu(tempMHdl,'Show rearrangements considered');						myCheckMenuItem(tempMHdl,9, showbranchswappath);						AppendMenu(tempMHdl,'Slow search');						myCheckMenuItem(tempMHdl,10, slowbranchswap);						InvalidateWindow(toolPaletteWindow[treeTools], false);					end;												ladderT:					begin						AppendMenu(tempMHdl,'Ladderize right');						myCheckMenuItem(tempMHdl,1,ladderizeRight);						AppendMenu(tempMHdl,'Ladderize left');						myCheckMenuItem(tempMHdl,2, not ladderizeRight);						InvalidateWindow(toolPaletteWindow[treeTools], false);					end;								paintT:					begin						AppendMenu(tempMHdl,'Fix state of branch');						myCheckMenuItem(tempMHdl,1, not paintToolTriesAllStates);						AppendMenu(tempMHdl,'Try all states on branch');						myCheckMenuItem(tempMHdl,2, paintToolTriesAllStates);						InvalidateWindow(toolPaletteWindow[treeTools], false);					end;				ancT:					begin						AppendMenu(tempMHdl,'Normal Mode');						myCheckMenuItem(tempMHdl,1, ancestorToolMode = ancestorToolNormalMode);						AppendMenu(tempMHdl,'Search Mode');						myCheckMenuItem(tempMHdl,2, ancestorToolMode = ancestorToolSearchHeuristicMode);						AppendMenu(tempMHdl,'(-');						AppendMenu(tempMHdl,'Search Options...');					end;				queryT:					begin						AppendMenu(tempMHdl,'Separate Window Mode');						if (traceshown<>traceAllChanges) & (traceshown<>traceAllStates) then							myDisableItem(tempMHdl,1)						else							myCheckMenuItem(tempMHdl,1, not queryToolsPopUp);						if  (traceshown=traceAllStates) then							begin								AppendMenu(tempMHdl,'(-');								AppendMenu(tempMHdl,'All States Options...');								//myCheckMenuItem(tempMHdl,3, (BLSWhat = BLSstatesum) | queryToolsPopUp);								//AppendMenu(tempMHdl,'States in Each Character');								//if queryToolsPopUp then								//	myDisableItem(tempMHdl,4)								//else								//	myCheckMenuItem(tempMHdl,4, (BLSWhat = BLSstates));							end;					end;								traceTickT:					begin						AppendMenu(tempMHdl,'Temporary Trace Mode');						if TickNamesVisible then							myCheckMenuItem(tempMHdl,1, traceTickToolTemporary)						else							myDisableItem(tempMHdl,1);					end;								otherwise;			end;		InsertMenu(TempMHdl, -1);		LocalToGlobal(thespot);		if theSpot.v < (ScreenRectangle.bottom-ScreenRectangle.top) div 2 then			currentsel := 0		else			currentsel := myCountMenuItems(TempMHdl);		menucode := PopUpMenuSelect(TempMHdl, thespot.v + 5, thespot.h+5, currentsel);		ItemNo := LowWord(menucode);		if ItemNo > 0 then 			GetMenuItemText(tempMHdl,ItemNo, ds);		DeleteMenu(TemporaryMenu);		DisposeMenu(TempMHdl);				if ItemNo > 0 then			if whichPalette=editorTools then			case whichTool of				selectedBlockMoveT:					case ItemNo of							1: selectedBlockMoveMode:= selectedBlockMoveNormalMode;							2: selectedBlockMoveMode:= selectedBlockMoveSpecifiedMode;							3: selectedBlockMoveMode:= selectedBlockMoveClickMode;						otherwise;					end;				popUpStatesT:					case ItemNo of							1: popUpEnterStates := true;							2: popUpEnterStates := false;						otherwise;					end;				blockMoveT: 					case ItemNo of							1:  blockMovePushBoundaries := not blockMovePushBoundaries;							2:  blockMoveEntireSequence := not blockMoveEntireSequence;							3:  blockMoveAccumulate := not blockMoveAccumulate;							4:  blockMoveSplitBlockToo := not blockMoveSplitBlockToo;						otherwise;					end;				splitBlockT: 					case ItemNo of							1:  								begin									splitBlockMultiSequence := not splitBlockMultiSequence;									InvalidateTool (editorTools,splitBlockT);								end;							2:  splitBlockEntireSequence := not splitBlockEntireSequence;							3:  splitBlockPushBoundaries := not splitBlockPushBoundaries;						otherwise;					end;				magicWandT:					case ItemNo of							1:  magicWandMode := magicWandNormalMode;							2:  magicWandMode := magicWandExtendTaxaBlockMode;							3:  magicWandMode := magicWandExtendCharactersBlockMode;							4:  magicWandMode := magicWandMixedBlockMode;							6:  magicWandEntireSequence := not magicWandEntireSequence;						otherwise;					end;				editorBucketT:					case itemNo of 							1: paintBucketMode := paintBucketNormalMode;							2: paintBucketMode := paintBucketRandomMode;							3: paintBucketMode := paintBucketFillObservedStatesMode;							4: paintBucketMode := paintBucketFillObservedFreqMode;							6: RestrictFillOptions;						otherwise;					end;				showPictureT:					case itemNo of 							1: showPicturesMode := showPicturesPopUpMode;							2: showPicturesMode := showPicturesWindowMode;						otherwise;					end;				editorSortT:					case itemNo of 							1: editorSortAscending := not editorSortAscending;						otherwise;					end;				selectToEndT:					case itemNo of 							1: selectToEndMode := selectToLastCharacterMode;							2: selectToEndMode := selectToFirstCharacterMode;							3: selectToEndMode := selectToLastTaxonMode;							4: selectToEndMode := selectToFirstTaxonMode;							6 : selectToEndIncludeTerminalGaps := not selectToEndIncludeTerminalGaps;						otherwise;					end;									closeGapsT:					case itemNo of 							1: closeGapsTowardEnd := true;							2: closeGapsTowardEnd := false;							4 : closeGapsMode := closeGapsNormalMode;							5: closeGapsMode := closeGapsCloseAllMode;							6: closeGapsMode := closeGapsSingleBaseMode;							7: closeGapsMode := closeGapsExactlyOneBaseMode;							otherwise;					end;									autoAlignT:					case ItemNo of							1:	GapCostsDialog;							//2: 	CodonCostsDialog;							2 : 	alignTreatsTerminalMissingAsGaps := not alignTreatsTerminalMissingAsGaps;							3:    	useGotohIfPossible := not useGotohIfPossible;							4:    	autoAlignSelected := not autoAlignSelected;							6: 	alignmentCostMatrix := unordered;						otherwise							begin								alignmentCostMatrix := GetTypNum(ds);								if alignmentCostMatrix <1 then alignmentCostMatrix := unordered;							end;					end;								editorScissorsT:					case itemNo of 							1: editorScissorsShiftsToStart := true;							2: editorScissorsShiftsToStart := false;							4: editorScissorsWarn := not editorScissorsWarn;						otherwise;					end;				otherwise					;			end		else if whichPalette=treeTools then			case whichTool of 				evolveSegmentsT:					case itemNo of 							1: evolveSegmentsToolMode:= evolveSegmentsNormalMode;							2: evolveSegmentsToolMode:=evolveSegmentsAllOneMode;							3: evolveSegmentsToolMode:=evolveSegmentsRandomMode;							{4: evolveSegmentsToolMode:=evolveSegmentsUltraMetricMode;}						otherwise;					end;				treePictureT:					case itemNo of 							1: showPicturesMode := showPicturesPopUpMode;							2: showPicturesMode := showPicturesWindowMode;						otherwise;					end;				rerootT:					case itemNo of 							1: rerootToolRootsDrawR := true;							2: rerootToolRootsDrawR := false;						otherwise;					end;									scissorsT:					case itemNo of 							1: scissorsCutAbove := true;							2: scissorsCutAbove := false;						otherwise;					end;								collapseAllT:					case itemNo of 							1: collapseAllCollapsesAbove := true;							2: collapseAllCollapsesAbove := false;						otherwise;					end;								swapT:					case itemNo of 							1: swapAbove := true;							2: swapAbove := false;							4 : fancySearch := not fancySearch;							5 : multipleSwaps := not multipleSwaps;							//5: quickestdescent := not quickestdescent;							6 : searchForLongTrees := not searchForLongTrees;							8 : showNewTreeWhileSearching := not showNewTreeWhileSearching;							9: showbranchswappath := not showbranchswappath;							10: slowbranchswap := not slowbranchswap;						otherwise;					end;									ladderT:					case itemNo of 							1: ladderizeRight := true;							2: ladderizeRight := false;						otherwise;					end;								paintT:					case itemNo of 							1: paintToolTriesAllStates := false;							2: paintToolTriesAllStates := true;						otherwise;					end;				ancT:					case itemNo of 							1: ancestorToolMode := ancestorToolNormalMode;							2: ancestorToolMode := ancestorToolSearchHeuristicMode;							4: SearchAncestorOptions;						otherwise;					end;				queryT:					case itemNo of 							1: queryToolsPopUp := not queryToolsPopUp;							3: TraceAllStatesBranchListOptions;							{3: BLSWhat := BLSstatesum;}							//4: BLSWhat := BLSStates;						otherwise;					end;				traceTickT:					case itemNo of 							1: traceTickToolTemporary := not traceTickToolTemporary;						otherwise;					end;				otherwise;			end;		if oldUseOpt <> UseOptionTool(whichPalette,whichTool,OptionDown)			then InvalidateTool (whichPalette,whichTool);		InvalidateToolPaletteMessage(whichPalette);			end;{-----------------------------------------------------------------------------}	procedure MouseInPaletteWindow(whichToolPalette: integer; mouseLoc: point);	label 1;	var box: rect;		j: integer;		DragArea: rect;		tPort: WindowPtr;		wh: point;		inBox: boolean;		downTime,currentTime: longint;	begin{		genericSetPort(treewindow);		ClipRect(WindowPortRect(treeWindow));		FrameRect(visTWR);		InvertRect(drawTWR);}		downTime := TickCount;		genericGetPort(tPort);		genericSetPort(toolPaletteWindow[whichToolPalette]);		GlobalToLocal(Event.where);		if useOldFloatingWindows & (Event.where.v<12) then			begin				SetRect(box, 3, 2, 10, 9);				if PtInRect(Event.where, box) then					begin						InsetRect(box, 1, 1);						InvertRect(box);						inbox:= true;						repeat							GetMouse(wh);							if inBox & not PtInRect(wh,box) then								begin									InvertRect(box);									inBox := false;								end							else if not inBox & PtInRect(wh, box) then								begin									InvertRect(box);									inBox := true;								end;						until not StillDown;						if inBox then							begin								ClosePaletteWindow(whichToolPalette);							end;					end				else if Event.where.v < 12 then					begin						DragArea := ScreenBoundsRect;						InsetREct(DragArea, 4, 4);						DragArea.top := DragArea.top + 12;						DragWindow(toolPaletteWindow[whichToolPalette], mouseLoc, @DragArea);						SelectWindow(toolPaletteWindow[whichToolPalette]);					end			end		else if PtInRect(Event.where,paletteExtraMessageBox[whichToolPalette]) then			begin				if whichToolPalette=editorTools then					begin						PopUpStatesMenu(Event.where,-2,-2);					end;			end		else			begin				for j := 0 to numTools[whichToolPalette] do					if PTINRECT(Event.where, tool^[whichToolPalette,j].R) and tool^[whichToolPalette,j].enabled then						begin							SetTool(whichToolPalette,j);							if tool^[whichToolPalette,j].hasPopUpMenu then								repeat									currentTime := TickCount;									if currentTime - downTime >=20 then										begin											PopUpToolPaletteMenu(whichToolPalette,j,Event);										end;								until not StillDown;							goto 1;						end;1:				if dblclick then					if (whichToolPalette=treeTools) then						if PTINRect(Event.where, tool^[treeTools,paintT].R) then							begin								if not (traceshown = traceDiscrete) then									if charincluded(i) then										TurnOnTrace(i, i);							end						else if PTINRect(Event.where, tool^[treeTools,turpentineT].R) then							begin								if (traceshown = traceDiscrete) and fixon then									Offfix(true);							end						else if PTINRect(Event.where, tool^[treeTools,scissorsT].R) then							OpenOrSelectInfoWindow(taxinfo);			end;		genericSetPort(tPort);	end;end.