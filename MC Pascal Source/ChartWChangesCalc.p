unit ChartWChangesCalc;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, 		Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  UtilLibInterface, SetLibInterface,   		MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, BoxUtil, CharUtil, 		typeutil, SymbolsNames, CalcUtil, Thermos, GenChar, ChartWWrite, SetStates, CHUNK, 		ReadWriteUtil, ReadUtil, ReadTreeFile, StrUtil, MenuUtil, TreeUtil, Count, TreeCycle, 		TaxonCHUtil, TreeMaker, TraceAllChangesCalc, InfoWindows, equivocal, ChartWUtil;	function CheckIfAbortedChart: boolean;	procedure ChangesinClade (N: Nptr; var aborted: boolean);	procedure CharChanges;	var		writeEveryCharacter: boolean;{еееееееееееееееееееееее}implementation {е$S ChartWChangesCalc}	var	TransversionAvgChar,		TransitionAvgChar,		ChangesSpecifiedAvgChar: double;		TransversionChar,		TransitionChar,		ChangesSpecifiedChar : longint;				TVThisTerminal,TIThisTerminal,changesSpecifiedThisTerminal: longint;	var	leftSquare,rightSquare:Ptr;		squareTotal1,		squareTotal2,		squareChar: Ptr;{-----------------------------------------------------------------------------}	function CheckIfAbortedChart: boolean;	begin		CheckIfAbortedChart := abortedthermo;	end;{-----------------------------------------------------------------------------}	procedure InitChangesSummaryNumbersSingleChar(doMinimum: boolean);	begin		TransversionAvgChar :=0.0;		TransitionAvgChar :=0.0;		ChangesSpecifiedAvgChar :=0.0;		if doMinimum then			begin				TransversionChar := maxlongint;				TransitionChar := maxlongint;				ChangesSpecifiedChar := maxlongint;			end		else			begin				TransversionChar := 0;				TransitionChar := 0;				ChangesSpecifiedChar := 0;			end;	end;{-----------------------------------------------------------------------------}	procedure CharAverageSummaryToTotal;	begin		TransversionAvg := TransversionAvg + TransversionAvgChar;		TransitionAvg := TransitionAvg + TransitionAvgChar;		ChangesSelAvg := ChangesSelAvg + ChangesSpecifiedAvgChar;	end;{-----------------------------------------------------------------------------}	procedure CharMinMaxSummaryToTotal(doMinimum: boolean);	begin		if doMinimum then			begin				TransversionMin := TransversionMin + TransversionChar;				TransitionMin :=TransitionMin +TransitionChar;				ChangesSelMin := ChangesSelMin + ChangesSpecifiedChar;			end		else			begin				TransitionMax := TransitionMax + TransitionChar;				TransversionMax := TransversionMax + TransversionChar;				ChangesSelMax := ChangesSelMax + ChangesSpecifiedChar;			end;	end;{-----------------------------------------------------------------------------}	procedure InitChangesSummaryNumbers;	begin		ChangesSelMin := 0;		ChangesSelMax := 0;  {initialize sum over all characters of max of selected changes}				ChangesSelAvg := 0.0;		TransRatio := 0.0;  {setting transition transversion ratio to 0; not really needed since set at end of procedure}		TransversionMin := 0;  {initialize sum over all characters of min of transversions}		TransitionMin := 0;  {initialize sum over all characters of min of transitions}		TransitionMax := 0;  {initialize sum over all characters of max of transitions}		TransversionMax := 0;  {initialize sum over all characters of max of transversions}	end;{-----------------------------------------------------------------------------}	procedure ZeroSquare (square: Ptr; squareIsDouble: boolean);	var iFrom,iTo: integer;	begin		if squareIsDouble then			for iFrom := 0 to maxMPRState do				for iTo := 0 to maxMPRState do					CMDDoublePtr(square)^[iFrom,iTo]:= 0.0		else	for iFrom := 0 to maxMPRState do				for iTo := 0 to maxMPRState do					CMDPtr(square)^[iFrom,iTo]:= 0;	end;{-----------------------------------------------------------------------------}	procedure ZeroCMDPtrFull(square: CMDPtr);	var iFrom, iTo: integer;	begin		for iFrom := 0 to absmaxstate do			for iTo := 0 to absmaxstate do				square^[iFrom,iTo]:= 0;	end;{-----------------------------------------------------------------------------}	procedure WriteCalcSquareChanges (square: Ptr; squareIsDouble: boolean);	var iFrom,iTo: integer;	begin		if squareIsDouble then			begin				for iFrom := 0 to maxMPRState do					for iTo := 0 to maxMPRState do						if (iFrom<>iTo) | CWShowConstant then							CheckWriteReal(CMDDoublePtr(square)^[iFrom,iTo],ChartLogSigDigits);			end								else			for iFrom := 0 to maxMPRState do				for iTo := 0 to maxMPRState do					if (iFrom<>iTo) | CWShowConstant then						CheckWriteCalc(CMDPtr(square)^[iFrom,iTo]);	end;{-----------------------------------------------------------------------------}	procedure TransferDoublesToMeanStorage (square: CMDDoublePtr;  averages:CMDPtr);	var iFrom,iTo: integer;	begin		for iFrom := 0 to maxMPRState do			for iTo := 0 to maxMPRState do				averages^[iFrom,iTo] := RoundValue(meanChangesInflate*square^[iFrom,iTo]);	end;{-----------------------------------------------------------------------------}	procedure TransferLongintSquares (FromSquare, ToSquare:CMDPtr);	var iFrom,iTo: integer;	begin		for iFrom := 0 to maxMPRState do			for iTo := 0 to maxMPRState do				ToSquare^[iFrom,iTo] := FromSquare^[iFrom,iTo];	end;{-----------------------------------------------------------------------------}	procedure SumRootDoubles (MPRReal: genRealTypePtr; MPRSet: lgSetChars; cube: Ptr; square: CMDDoublePtr);	var iFrom,iTo: integer;		totalMPRs : double;		fraction: double;		iState: integer;	begin		totalMPRs := MPRTotalAbove(MPRReal,MPRSet,maxMPRState);		for iState := 0 to maxMPRState do			begin				fraction:= MPRReal^[iState]/totalMPRs;				if EnSet(iState,MPRSet) then					for iFrom := 0 to maxMPRState do						for iTo := 0 to maxMPRState do							square^[iFrom,iTo] := square^[iFrom,iTo]  + CubeValueDouble(cube,iState,iFrom,iTo)*fraction;			end;	end;{-----------------------------------------------------------------------------}	procedure SetSquareToMaximumLongint(square: univ Ptr);	var iFrom,iTo: integer;	begin		for iFrom := 0 to maxMPRState do			for iTo := 0 to maxMPRState do				CMDPtr(square)^[iFrom,iTo]:= maxlongint;		end;{-----------------------------------------------------------------------------}	procedure ZeroCube(cube: Ptr);	var iState,iFrom,iTo: integer;	begin		for iState := 0 to maxMPRState do			for iFrom := 0 to maxMPRState do				for iTo := 0 to maxMPRState do					SetCubeValueLongint(cube,iState,iFrom,iTo,0);		end;{-----------------------------------------------------------------------------}	procedure SetCubeToMaximum(cube: Ptr);	var iState,iFrom,iTo: integer;	begin		for iState := 0 to maxMPRState do			for iFrom := 0 to maxMPRState do				for iTo := 0 to maxMPRState do					SetCubeValueLongint(cube,iState,iFrom,iTo,maxlongint);		end;{-----------------------------------------------------------------------------}	procedure PlaceMinMaxRootLongintsIntoSquare (MPRSet: lgSetChars; cube: Ptr; square: Ptr; doMinimum:boolean);	var iFrom,iTo: integer;		iState: integer;		value: longint;	begin		if doMinimum then 			SetSquareToMaximumLongint(square)		else			ZeroSquare(square,false);		for iState := 0 to maxMPRState do			if EnSet(iState,MPRSet) then				for iFrom := 0 to maxMPRState do					for iTo := 0 to maxMPRState do						begin							value:= CubeValueLongint(cube,iState,iFrom,iTo);							if doMinimum = (CMDPtr(square)^[iFrom,iTo]>value) then								CMDPtr(square)^[iFrom,iTo] := value;						end;	end;{-----------------------------------------------------------------------------}	procedure SumSquaresPlaceIntoCube (cube: Ptr; state: integer; square1,square2: Ptr);	var iFrom,iTo: integer;	begin		if chartchangesmode=meanMode then			for iFrom := 0 to maxMPRState do				for iTo := 0 to maxMPRState do					SetCubeValueDouble(cube,state,iFrom,iTo,CMDDoublePtr(square1)^[iFrom,iTo]+CMDDoublePtr(square2)^[iFrom,iTo])		else			for iFrom := 0 to maxMPRState do				for iTo := 0 to maxMPRState do					SetCubeValueLongint(cube,state,iFrom,iTo,CMDPtr(square1)^[iFrom,iTo]+CMDPtr(square2)^[iFrom,iTo]);	end;{-----------------------------------------------------------------------------}	procedure CountChangeDouble (averageSquare: CMDDoublePtr; statebelow, stateabove: integer; fraction: double);	begin		averageSquare^[statebelow,stateabove]:= averageSquare^[statebelow,stateabove]+fraction;		if (statebelow <> stateabove) then			begin				{if (nucleotides) then					if ((stateabove in purine) & (statebelow in pyrim)) | ((stateabove in pyrim) & (statebelow in purine)) then						TransversionAvgChar := TransversionAvgChar + fraction					else						TransitionAvgChar := TransitionAvgChar + fraction;				if (not changesRestricted) | (changesSel^[statebelow, stateabove]) then					ChangesSpecifiedAvgChar := ChangesSpecifiedAvgChar + fraction;}			end;	end;{-----------------------------------------------------------------------------}	function IsTransversion(ancstate,descstate: integer):boolean;	begin		IsTransversion := (ancState in purine) <> (descstate in purine);	end;{-----------------------------------------------------------------------------}	function IsTransition(ancstate,descstate: integer):boolean;	begin		IsTransition := ((ancState in purine) = (descstate in purine)) & (ancState<>descstate);	end;{-----------------------------------------------------------------------------}	procedure ZeroTerminalSpecifiedChanges(doMinimum: boolean);	begin		{if doMinimum then			begin				TVThisTerminal:= maxlongint;				TIThisTerminal:= maxlongint;				changesSpecifiedThisTerminal:= maxlongint;			end		else}			begin				TVThisTerminal:= 0;				TIThisTerminal:= 0;				changesSpecifiedThisTerminal:= 0;			end;	end;{-----------------------------------------------------------------------------}	procedure AddToSpecifiedTerminalChanges(statebelow,stateAbove: integer);	begin		if (nucleotides) then			if IsTransversion(statebelow,stateAbove) then				TVThisTerminal := TVThisTerminal + 1			else if IsTransition(statebelow,stateAbove) then				TIThisTerminal := TIThisTerminal + 1;		if (statebelow<>stateabove)& ((not changesRestricted) | (changesSel^[statebelow, stateabove])) then 			changesSpecifiedThisTerminal := changesSpecifiedThisTerminal+1;	end;{-----------------------------------------------------------------------------}	procedure CountChangeLongint (square: Ptr; statebelow, stateabove: integer);  {only used for changes within terminals}	begin	       {N^.MPR2 - specified changes		N^.MPR3 - transversions		N^.MPR4 - transitions}		CMDPtr(square)^[statebelow,stateabove]:= CMDPtr(square)^[statebelow,stateabove]+1;		if (statebelow <> stateabove) then			AddToSpecifiedTerminalChanges(statebelow,stateAbove);	end;{-----------------------------------------------------------------------------}	procedure CountTerminalChangesNew(N: Nptr; ic,ctyp: integer; traced: boolean; statebelow: integer; square : Ptr; fraction: double);	var			termset: largestsetchars;			stateabove, lastfound, ir, irr: integer;				begin		termset := gettaxonstsLargest(N^.name, ic); {v4: beware ic is for loop variable; will not work in TML}		if ((MultipleStatesLg(termset)) | (traced & N^.fix)) & not (ucL in termset) then{terminal is polymorphic or fixed }			begin				case ctyp of					unordered: 						begin		{FOR UNORDERED: Count change to each of other states in terminal taxon}		{e.g., if states in terminal are 0, 2 and 3, with 2 resolved at node, }		{then changes 2 to 0 and 2 to 3 are counted even though could have }		{gone 2 to 0 to 3.  This is convention chosen, and error is posted to warn user.}							for ir := 0 to CharMaxstOBS(ic) do								if (ir <> statebelow) & (ir in termset) then									if chartChangesMode=meanmode then										CountChangeDouble (CMDDoublePtr(square),statebelow,ir,fraction)									else										CountChangeLongint(square,statebelow,ir);							if MultipleStatesLg(termset - [statebelow]) then								NewError(63, ic);  {more than one alternative to go to; warn that only one chosen}						end;					ordered, Dollo, irreversible: 						begin		{FOR ORDERED TYPES: Count changes to other states in terminal taxon}		{stretching in sequence both ways from resolved state}		{e.g., if states in terminal are 0, 2 and 3 and 4, with 2 resolved at node, }		{then changes 2 to 0 and 2 to 3 and 3 to 4 are counted ( 0 <- 2 -> 3 -> 4).}							lastfound := statebelow;							for ir := statebelow + 1 to CharMaxstOBS(ic) do								if ir in termset then									begin										if chartChangesMode=meanmode then											CountChangeDouble (CMDDoublePtr(square),lastfound,ir,fraction)										else											CountChangeLongint(square,lastfound,ir);										lastfound := ir;									end;							lastfound := statebelow;							for ir := statebelow - 1 downto 0 do								if ir in termset then									begin										if chartChangesMode=meanmode then											CountChangeDouble (CMDDoublePtr(square),lastfound,ir,fraction)										else											CountChangeLongint(square,lastfound,ir);										lastfound := ir;										if ctyp = irreversible then											newerror(20, ic);									end;						end;					fisher: 						Newerror(361, ic);					otherwise {user-defined}						begin		{FOR USER-DEFINED TYPES: if exactly one state in terminal taxon}		{other than that resolved, then count change as being to this other state;}		{otherwise post error since too difficult to figure out changes}							termset := termset - [statebelow];  {get state remaining aside from resolved}							if MultipleStatesLg(termset) then								NewError(92, ic)							else								begin									stateabove := minlg(termset);									if stateabove <> ERl then										if chartChangesMode=meanmode then											CountChangeDouble (CMDDoublePtr(square),statebelow,stateabove,fraction)										else											CountChangeLongint(square,statebelow,stateabove);								end;						end;				end;			end		else if (traced & N^.fix) & (ucL in termset) then			NewError(80, ic);	end;{-----------------------------------------------------------------------------}	procedure AddToSpecifiedChanges(descendentN: Nptr; statebelow,stateAbove: integer; var TI,TV,specified: longint; doMinimum: boolean);	var matchesSpecifiedChange: boolean;	begin		matchesSpecifiedChange := (statebelow<>stateabove)& ((not changesRestricted) | (changesSel^[statebelow, stateabove]));		if matchesSpecifiedChange & (doMinimum = (specified > descendentN^.MPR2[stateAbove]+1))  then			specified := descendentN^.MPR2[stateAbove]+1		else if not matchesSpecifiedChange  & (doMinimum = (specified > descendentN^.MPR2[stateAbove]))  then			specified := descendentN^.MPR2[stateAbove];		if (nucleotides) then			begin				if IsTransversion(statebelow,stateAbove) & (doMinimum = (TV>descendentN^.MPR3[stateAbove]+1))  then {it's a transversion below}					TV := descendentN^.MPR3[stateAbove]+1				else if not IsTransversion(statebelow,stateAbove) & (doMinimum = (TV>descendentN^.MPR3[stateAbove])) then					TV := descendentN^.MPR3[stateAbove];				if IsTransition(statebelow,stateAbove) & (doMinimum = (TI>descendentN^.MPR4[stateAbove]+1))  then					TI := descendentN^.MPR4[stateAbove]+1				else if not IsTransition(statebelow,stateAbove) & (doMinimum = (TI>descendentN^.MPR4[stateAbove])) then					TI := descendentN^.MPR4[stateAbove];			end;	end;{-----------------------------------------------------------------------------}	procedure CheckMinMaxSpecifiedChanges(N: Nptr;state:integer; doMinimum: boolean);	begin	       {N^.MPR2 - specified changes		N^.MPR3 - transversions		N^.MPR4 - transitions}				if doMinimum = (changesSpecifiedThisTerminal<N^.MPR2[state])  then			N^.MPR2[state] := changesSpecifiedThisTerminal;		if (nucleotides) then			begin				if doMinimum = (TVThisTerminal<N^.MPR3[state])  then					N^.MPR3[state] := TVThisTerminal;				if doMinimum = (TIThisTerminal<N^.MPR4[state])  then					N^.MPR4[state] := TIThisTerminal;			end;	end;{-----------------------------------------------------------------------------}	procedure InitNodeMPRs123(N: Nptr; iNodeState: integer; doMinimum: boolean);	begin		if doMinimum then			begin				N^.MPR2[iNodeState] := maxlongint;  {specified changes}				N^.MPR3[iNodeState] := maxlongint;  {transversions}				N^.MPR4[iNodeState] := maxlongint;  {transitions}			end		else			begin				N^.MPR2[iNodeState] := 0;  {specified changes}				N^.MPR3[iNodeState] := 0;  {transversions}				N^.MPR4[iNodeState] := 0;  {transitions}			end;	end;{-----------------------------------------------------------------------------}	procedure CheckMinMaxLongints (descendentN: Nptr; MPRSet: lgSetChars; cube: Ptr; square: Ptr;  ic,ctyp,ancState: integer; traced,addterminal,doMinimum:boolean; var TI,TV,specified: longint);	{TI, TV, specified will house the number of each of these kinds of change (transition, transversion, specified) from descendentN^.anc to descendentN and above given that the	state at descendentN^.anc is ancstate}		var iFrom,iTo: integer;		descendentState: integer;		value,valueWithBranchChange: longint;		totalWithin: longint;		firstThru : boolean;		terminalSquare: CMDPtr;	begin		terminalSquare := CMDPtr(NewPtrClear(SizeOf(CMDArray)));		firstThru := true;		if doMinimum then 			SetSquareToMaximumLongint(square)		else			ZeroSquare(square,false);		if doMinimum then			begin				TV := maxlongint;				TI := maxlongint;				specified := maxlongint;			end		else			begin				TV := 0;				TI := 0;				specified := 0;			end;		for descendentState := 0 to maxMPRState do			if EnSet(descendentState,MPRSet) then				begin					ZeroSquare(Ptr(terminalSquare),false);					if NodeIsTerminal(descendentN) & addTerminal then						begin							//if firstThru then								InitNodeMPRs123(descendentN,descendentState,doMinimum);							firstThru :=false;							ZeroTerminalSpecifiedChanges(doMinimum);							CountTerminalChangesNew(descendentN, ic,ctyp,traced,descendentState,Ptr(terminalSquare),0.0);							CheckMinMaxSpecifiedChanges(descendentN,descendentState,doMinimum);						end;					AddToSpecifiedChanges(descendentN,ancState,descendentState,ti,tv,specified,doMinimum);    {checks to see if ti,tv,specified need to be updated to be min or max}					{here calculate what's expected in terminals if descendent state}					for iFrom := 0 to maxMPRState do						for iTo := 0 to maxMPRState do							begin								value:= CubeValueLongint(cube,descendentState,iFrom,iTo);								if (ancState=iFrom) & (descendentState=iTo) & ((ancState<>descendentState) | CWShowConstant) then									valueWithBranchChange := value + 1 + terminalSquare^[iFrom,iTo]								else									valueWithBranchChange := value + terminalSquare^[iFrom,iTo];																if doMinimum = (CMDPtr(square)^[iFrom,iTo]>valueWithBranchChange) then									CMDPtr(square)^[iFrom,iTo] := valueWithBranchChange;							end;					//if NodeIsTerminal(descendentN) & addterminal then						//CountTerminalChangesNew(descendentN, ic,ctyp,traced,descendentState,square,0.0);				end;		ZapPointer(terminalSquare);		{if NodeIsTerminal(DescendentN) then			ZeroMaxLongintMPR(DescendentN);		if TV = maxlongint then TV := 0;		if TI = maxlongint then TI := 0;		if specified = maxlongint then specified := 0;		}	end;{-----------------------------------------------------------------------------}	procedure AverageCube (N: Nptr; MPRFreq:genRealTypePtr;cube: Ptr; averageSquare: Ptr ; MPRSet: lgSetChars; ic,ctyp,ancState: integer; traced,addterminal: boolean);	{MPRFreq is the number of MPRs above the node for various states at that node	MPRSet is the MPR set for that node	cube stores the average changes above that node for various states at that node	average square is the }	var 	descendentState,iFrom,iTo: integer;		totalMPRs: double;		fraction,changeOnBranch,valueAboveForThisState: double;		totalWithin: longint;	begin		ZeroSquare(averageSquare,true);		totalMPRs := MPRTotalAbove(MPRFreq,MPRSet,maxMPRState);		for descendentState := 0 to maxMPRState do			if EnSet(descendentState,MPRSet) then				begin					fraction := MPRFreq^[descendentState]/totalMPRs;					for iFrom := 0 to maxMPRState do						for iTo := 0 to maxMPRState do							begin								valueAboveForThisState := CubeValueDouble(cube,descendentState,iFrom,iTo);								CMDDoublePtr(averageSquare)^[iFrom,iTo]:= CMDDoublePtr(averageSquare)^[iFrom,iTo]+ (valueAboveForThisState)*fraction;								if (ancState=iFrom) & (descendentState=iTo) & ((ancState<>descendentState) | CWShowConstant) then									CountChangeDouble (CMDDoublePtr(averageSquare),ancState, descendentState,fraction);							end;					if NodeIsTerminal(N) & addterminal then						CountTerminalChangesNew(N, ic,ctyp,traced,descendentState,averageSquare,fraction);				end;	end;{-----------------------------------------------------------------------------}	procedure AddToSingleMPRChanges(statebelow,stateAbove: integer);	var matchesSpecifiedChange: boolean;	begin		matchesSpecifiedChange := (statebelow<>stateabove)& ((not changesRestricted) | (changesSel^[statebelow, stateabove]));		if matchesSpecifiedChange then			ChangesSpecifiedChar := ChangesSpecifiedChar+1;		if (nucleotides) then			begin				if IsTransversion(statebelow,stateAbove)  then {it's a transversion below}					TransversionChar := TransversionChar+1;				if IsTransition(statebelow,stateAbove)  then					TransitionChar := TransitionChar+1;			end;	end;{-----------------------------------------------------------------------------}	procedure CountChangesinSingleMPR (N: Nptr; ic, ctyp: integer; squareChar: Ptr; addterminal,traced: boolean);{FROZEN 3.0}{procedure moves through tree counting changes in resolution.  Straightforward}{except for polymorphic terminal taxa, for which a few rules were chosen for}{how to count changes within these taxa}		var			statebelow, stateabove, lastfound, ir, irr: integer;			terminalSquare: CMDPtr;	begin	//	terminalSquare := CMDPtr(NewPtrClear(SizeOf(CMDArray)));		if (N <> R) and BranchExists(N) then  { v3.02}			begin				statebelow := MinG(N^.anc^.original);				stateabove := MinG(N^.original);				if (statebelow <> stateabove) or CWShowConstant then					begin						if chartChangesMode=meanMode then							CMDDoublePtr(squareChar)^[statebelow,stateabove] := CMDDoublePtr(squareChar)^[statebelow,stateabove]+1						else							CMDPtr(squareChar)^[statebelow,stateabove] := CMDPtr(squareChar)^[statebelow,stateabove]+1;						AddToSingleMPRChanges(statebelow,stateAbove);					end;			end;		if NodeIsInternal(N) then			begin				CountChangesinSingleMPR(N^.lf,ic,ctyp,squareChar,addterminal,traced);				CountChangesinSingleMPR(N^.rt,ic,ctyp,squareChar,addterminal,traced);			end		else if addterminal and BranchExists(N) then  { v3.02}			CountTerminalChangesNew(N, ic,ctyp,traced,MinG(N^.original),squareChar,1.0);//		ZapPointer(terminalSquare);	end;{-----------------------------------------------------------------------------}	procedure NewMinAverageMaxChangesCharacter (baseN: Nptr; squareChar: Ptr; ic: integer; traced,doMinimum,writeCharNumber: boolean);{DRM method:  uses the same principle as user-defined types}	label 1;		var			ir, ij, cardTstsOld: longint;			ctyp: integer;			tstsLeft, tstsRight: lgsetchars;			tstsOld : largestsetchars;			leftRes, rightRes: longint;			useDouble,doaddterminalchanges: boolean;			res: Double;			numRes: longint;			TVLeft,TILeft,SpecifiedLeft,TVRight,TIRight,SpecifiedRight: longint;						dL: longint;{...............................}		procedure MinAverageMaxChangesAbove (N: Nptr); 			var				iNodeState,iChangeFrom,iChangeTo: integer;		begin			if NodeIsInternal(N) & not errorflag then				begin					MinAverageMaxChangesAbove(N^.lf);					MinAverageMaxChangesAbove(N^.rt);					for iNodeState := 0 to maxMPRState do						begin							if doMinimum then								begin									N^.MPR2[iNodeState] := maxlongint;  {specified changes}									N^.MPR3[iNodeState] := maxlongint;  {transversions}									N^.MPR4[iNodeState] := maxlongint;  {transitions}								end							else								begin									N^.MPR2[iNodeState] := 0;  {specified changes}									N^.MPR3[iNodeState] := 0;  {transversions}									N^.MPR4[iNodeState] := 0;  {transitions}								end;							if EnSet(iNodeState, N^.original) then  {iNodeState is in the MPR set of N}								begin									if MonomorphG(N^.original) then										begin											tstsLeft := OriginalNodeAssignment(N^.lf,iNodeState,ic);											tstsRight := OriginalNodeAssignment(N^.rt,iNodeState,ic);										end									else										begin											tstsLeft := CalcDescendentPolymStates(N^.lf, iNodeState, ic, ctyp);											tstsRight := CalcDescendentPolymStates(N^.rt, iNodeState, ic, ctyp);										end;{we now know that if iNodeState is the state at node N, then the left and right descendent states are tstsLeft & tstsRight}									if ErrorFlag then goto 1;									if chartchangesmode = meanmode then										begin											AverageCube(N^.lf, @N^.lf^.MPRReal,N^.lf^.MPRCube,leftSquare,tstsLeft,ic,ctyp,iNodeState,traced,doaddterminalchanges);											AverageCube(N^.rt, @N^.rt^.MPRReal,N^.rt^.MPRCube,rightSquare,tstsRight,ic,ctyp,iNodeState,traced,doaddterminalchanges);											SumSquaresPlaceIntoCube(N^.MPRCube,iNodeState,rightSquare,leftSquare);										end									else  										begin											CheckMinMaxLongints (N^.lf,tstsLeft,N^.lf^.MPRCube, leftSquare, ic,ctyp,iNodeState,traced,doaddterminalchanges,doMinimum,TiLeft,TvLeft,SpecifiedLeft);  											CheckMinMaxLongints (N^.rt,tstsRight,N^.rt^.MPRCube, rightSquare, ic,ctyp,iNodeState,traced,doaddterminalchanges,doMinimum,TiRight,TvRight,SpecifiedRight); 											SumSquaresPlaceIntoCube(N^.MPRCube,iNodeState,rightSquare,leftSquare);											N^.MPR2[iNodeState] := SpecifiedLeft+SpecifiedRight;											N^.MPR3[iNodeState] := TVLeft + TVRight;											N^.MPR4[iNodeState] := TILeft+TIRight;										end;								end;						end;				end			else				for iNodeState := 0 to maxMPRState do					begin								N^.MPR2[iNodeState] := 0;  {specified changes}								N^.MPR3[iNodeState] := 0;  {transversions}								N^.MPR4[iNodeState] := 0;  {transitions}					end;		end;{...............................}	begin		if TypeOfChar(ic) = fisher then  {changes not counted in stratigraphic characters}			Newerror(361, ic)		else if not CWShowConstant & (CharConstant(ic) & not (traced & fixon)) then{Character is constant, therefore skip calculations, as wouldn't find anything, }{but record as another character examined "(tracedonlystorage & fixon)" added above and below }{because calculations could find something even if character was constant as long as using character tracing with fixed states}			numCWChars := numCWChars + 1		else if (CWShowConstant | (not CharConstant(ic) | (traced & fixon))) then			begin				if ChartCalcToText & writeEveryCharacter & writeCharNumber then   {v3.02}					begin						ChartWriteChar(chr(13));						ChartWriteString(StringFromNum(ic));						ChartWriteChar(chr(9));					end;								doaddterminalchanges := addpolychanges & (MSTaxaInCharTree(ic) | (traced & fixon)); {only need to add changes within terminal taxa if taxon has multistate taxa or if states might}				InitChangesSummaryNumbersSingleChar(doMinimum);				//CalcMaxMPRStateChar(ic);  This procedure requires that maxMPRstate be calculated before hand!				PrepareForMPRRecursion(ic,traced, ctyp);				if SingleMPR(ic,traced,true) then					begin						TransversionChar := 0;						TransitionChar := 0;						ChangesSpecifiedChar := 0;						CountChangesinSingleMPR(baseN,ic,ctyp,squareChar,doaddterminalchanges,traced);						TransversionAvgChar := TransversionChar;						TransitionAvgChar := TransitionChar;						ChangesSpecifiedAvgChar := ChangesSpecifiedChar;					end				else					begin						numRes := NumberOfResolutions(baseN,ic,traced,useDouble,res);  {used just to fill MPRReal}						MinAverageMaxChangesAbove(baseN);						if chartchangesMode=meanmode then							SumRootDoubles (@R^.MPRReal,R^.original,R^.MPRCube,CMDDoublePtr(squareChar))						else							begin								PlaceMinMaxRootLongintsIntoSquare (R^.original,R^.MPRCube,squareChar, doMinimum); 								for ir := 0 to maxMPRState do									if Enset(ir,R^.original) then										begin											if doMinimum = (ChangesSpecifiedChar>R^.MPR2[ir])  then												ChangesSpecifiedChar := R^.MPR2[ir];											if (nucleotides) then												begin													if doMinimum = (TransversionChar>R^.MPR3[ir])  then														TransversionChar := R^.MPR3[ir];													if doMinimum = (TransitionChar>R^.MPR4[ir])  then														TransitionChar := R^.MPR4[ir];												end;										end;							end;					end;				numCWChars := numCWChars + 1;				if chartchangesMode=meanmode then					CharAverageSummaryToTotal				else					CharMinMaxSummaryToTotal(doMinimum);								if writeEveryCharacter then					WriteCalcSquareChanges(squareChar,chartchangesMode=meanmode);			end;1: 	end;{-----------------------------------------------------------------------------}	function AllocateChangesStorage(baseN: NPtr): boolean;	begin		AllocateChangesStorage := false;		rightSquare := nil;		leftSquare := nil;		squareTotal1 := nil;		squareTotal2 := nil;		squareChar := nil;		rightSquare := NewPtrClear(MPRSquareSize);		if (rightSquare = nil) |  not OSSuccessful(MemError) then			Exit(AllocateChangesStorage);		leftSquare := NewPtrClear(MPRSquareSize);		if (leftSquare = nil) |  not OSSuccessful(MemError) then			Exit(AllocateChangesStorage);		squareTotal1 := NewPtrClear(MPRSquareSize);		if (squareTotal1 = nil) |  not OSSuccessful(MemError) then			Exit(AllocateChangesStorage);		if not CWTraced then			begin				squareChar := NewPtrClear(MPRSquareSize);				if (squareChar = nil) |  not OSSuccessful(MemError) then					Exit(AllocateChangesStorage);			end;		if chartchangesMode = minmaxmode then			begin				squareTotal2 := NewPtrClear(MPRSquareSize);				if (squareTotal2 = nil) |  not OSSuccessful(MemError) then					Exit(AllocateChangesStorage);			end;		AllocateChangesStorage := AllocateAllCubePointers(baseN);	end;{-----------------------------------------------------------------------------}	procedure DestroyChangesStorage(baseN: Nptr);	begin		DestroyAllCubePointers(baseN);		ZapPointer(leftSquare);		ZapPointer(rightSquare);		ZapPointer(squareTotal1);		ZapPointer(squareTotal2);		ZapPointer(squareChar);	end;{-----------------------------------------------------------------------------}	procedure CountSummaryAverages (square: CMDDoublePtr);	var iFrom,iTo: integer;	begin		TransversionAvg := 0.0;		TransitionAvg := 0.0;		ChangesSelAvg := 0.0;		for iFrom := 0 to maxMPRState do			for iTo := 0 to maxMPRState do				if (iFrom <> iTo) then					begin						if (nucleotides) then							if ((iTo in purine) & (iFrom in pyrim)) | ((iTo in pyrim) & (iFrom in purine)) then								TransversionAvg := TransversionAvg + square^[iFrom,iTo]							else								TransitionAvg := TransitionAvg + square^[iFrom,iTo];						if (not changesRestricted) | (changesSel^[iFrom, iTo]) then							ChangesSelAvg := ChangesSelAvg + square^[iFrom,iTo];					end;		TransRatio := transitionAvg/transversionAvg;	end;{-----------------------------------------------------------------------------}	procedure AddCharacterSquareToTotal (squareNew,squareSum: Ptr; squareIsDouble: boolean);	var iFrom,iTo: integer;	begin		if squareNew<> nil then			if squareIsDouble then				for iFrom := 0 to maxMPRState do					for iTo := 0 to maxMPRState do						CMDDoublePtr(squareSum)^[iFrom,iTo]:= CMDDoublePtr(squareSum)^[iFrom,iTo]+ CMDDoublePtr(squareNew)^[iFrom,iTo]			else for iFrom := 0 to maxMPRState do				for iTo := 0 to maxMPRState do					CMDPtr(squareSum)^[iFrom,iTo]:= CMDPtr(squareSum)^[iFrom,iTo]+ CMDPtr(squareNew)^[iFrom,iTo];	end;{-----------------------------------------------------------------------------}	procedure NewMinAverageMaxChanges (minima,averages,maxima: CMDPtr; var aborted: boolean);	var ic,ist,iend: integer;		amountNeeded: longint;		dL: longint;		theDialog: DialogPtr;		tempP: WindowPtr;	begin		InitChangesSummaryNumbers;		if CWTraced then			CalcMaxMPRStateChar(i)		else 			CalcMaxMPRStateAll;		if not EnoughMemory((2*numTaxaIn-1)*CubeSize+4*MPRSquareSize, amountneeded) then			InstantErrorPlus(414, concat(StringFromNum(amountneeded div 1024), 'Kb'))		else			begin				if AllocateChangesStorage(R) then					begin						if CWTraced then							begin								if CWTrees[CWChart] <> CWCurrentTree then									begin										DisableWindowUpdates(tlegwindow);										DisableWindowUpdates(chlegwindow);										DisableWindowUpdates(chartwindow);										DisableWindowUpdates(treewindow);									end;								if chartchangesMode = meanmode then									NewMinAverageMaxChangesCharacter (R,squareTotal1, i,CWTrees[CWChart] = CWCurrentTree,true, true)								else									begin										NewMinAverageMaxChangesCharacter (R,squareTotal1, i,CWTrees[CWChart] = CWCurrentTree,true, true);										NewMinAverageMaxChangesCharacter (R,squareTotal2, i,CWTrees[CWChart] = CWCurrentTree,false, false);									end;							end						else 							begin								DisableWindowUpdates(tlegwindow);								DisableWindowUpdates(chlegwindow);								DisableWindowUpdates(chartwindow);								DisableWindowUpdates(treewindow);								SetTaxaDnsts(1, numchars);								reconstructChars(1, numchars, true);								StartThermo(theDialog, tempP, 0, numchars, 'Chart: Calculating changes', 'characters', false);								for ic := 1 to numchars do									if CharIncluded(ic) then										begin											if CheckIfAbortedChart then												if not checkifcontinueaBit then													begin														aborted := true;														leave;													end;											ZeroSquare(squareChar,chartchangesmode=meanmode);											if chartchangesmode = meanmode then												begin																										NewMinAverageMaxChangesCharacter (R,squareChar,ic,false,false,true);  													AddCharacterSquareToTotal(squareChar,squareTotal1,true);												end											else												begin													NewMinAverageMaxChangesCharacter(R,squareChar,ic,false,true,true);  {do minimum}													AddCharacterSquareToTotal(squareChar,squareTotal1,false);													ZeroSquare(squareChar,chartchangesmode=meanmode);													NewMinAverageMaxChangesCharacter(R,squareChar,ic,false,false, false);  {do maximum}													AddCharacterSquareToTotal(squareChar,squareTotal2,false);												end;											UpdateThermo(theDialog, 0, ic, numchars,false);																					end;								dL := changesSelMin;								dL := changesSelMax;								EndThermo(theDialog, tempP, true);							end;						if chartchangesmode = meanmode then							begin								TransferDoublesToMeanStorage (CMDDoublePtr(squareTotal1),averages);								CountSummaryAverages(CMDDoublePtr(squareTotal1));							end						else 							begin								TransferLongintSquares (CMDPtr(squareTotal1),minima);								TransferLongintSquares (CMDPtr(squareTotal2),maxima);							end;					end;				DestroyChangesStorage(R);			end;	end;{ееееееееееееееееее OLD METHOD еееееееееееееееее}{-----------------------------------------------------------------------------}	procedure CountSingleChange (statebelow, stateabove: integer; var  numchanges, numTransversions, numTransitions,numChangesSel: longint);	begin		numchanges := numchanges + 1;		if (statebelow <> stateabove) then			begin				if (nucleotides) then					if ((stateabove in purine) & (statebelow in pyrim)) | ((stateabove in pyrim) & (statebelow in purine)) then						numTransversions := numTransversions + 1					else						numTransitions := numTransitions + 1;				if (not changesRestricted) | (changesSel^[statebelow, stateabove]) then					numChangesSel := numChangesSel + 1;			end;	end;{-----------------------------------------------------------------------------}	procedure CountTerminalChanges(N: Nptr; ic,ctyp: integer; traced: boolean; statebelow: integer; thisResolution : CMDPtr; var numTransversions, numTransitions, numChangesSel: longint);	var			termset: largestsetchars;			stateabove, lastfound, ir, irr: integer;	begin		termset := gettaxonstsLargest(N^.name, ic); {v4: beware ic is for loop variable; will not work in TML}		if ((MultipleStatesLg(termset)) | (traced & N^.fix)) & not (ucL in termset) then{terminal is polymorphic or fixed }			begin				case ctyp of					unordered: 						begin		{FOR UNORDERED: Count change to each of other states in terminal taxon}		{e.g., if states in terminal are 0, 2 and 3, with 2 resolved at node, }		{then changes 2 to 0 and 2 to 3 are counted even though could have }		{gone 2 to 0 to 3.  This is convention chosen, and error is posted to warn user.}							for ir := 0 to CharMaxstOBS(ic) do								if (ir <> statebelow) & (ir in termset) then									CountSingleChange(statebelow, ir,thisResolution^[statebelow,ir],numTransversions, numTransitions, numChangesSel);							if MultipleStatesLg(termset - [statebelow]) then								NewError(63, ic);  {more than one alternative to go to; warn that only one chosen}						end;					ordered, Dollo, irreversible: 						begin		{FOR ORDERED TYPES: Count changes to other states in terminal taxon}		{stretching in sequence both ways from resolved state}		{e.g., if states in terminal are 0, 2 and 3 and 4, with 2 resolved at node, }		{then changes 2 to 0 and 2 to 3 and 3 to 4 are counted ( 0 <- 2 -> 3 -> 4).}							lastfound := statebelow;							for ir := statebelow + 1 to CharMaxstOBS(ic) do								if ir in termset then									begin										CountSingleChange(lastfound, ir,thisResolution^[lastfound,ir],numTransversions, numTransitions, numChangesSel);										lastfound := ir;									end;							lastfound := statebelow;							for ir := statebelow - 1 downto 0 do								if ir in termset then									begin										CountSingleChange(lastfound, ir,thisResolution^[lastfound,ir],numTransversions, numTransitions, numChangesSel);										lastfound := ir;										if ctyp = irreversible then											newerror(20, ic);									end;						end;					fisher: 						Newerror(361, ic);					otherwise {user-defined}						begin		{FOR USER-DEFINED TYPES: if exactly one state in terminal taxon}		{other than that resolved, then count change as being to this other state;}		{otherwise post error since too difficult to figure out changes}							termset := termset - [statebelow];  {get state remaining aside from resolved}							if MultipleStatesLg(termset) then								NewError(92, ic)							else								begin									stateabove := minlg(termset);									if stateabove <> ERl then										CountSingleChange(statebelow, stateabove,thisResolution^[statebelow,stateabove],numTransversions, numTransitions, numChangesSel);								end;						end;				end;			end		else if (traced & N^.fix) & (ucL in termset) then			NewError(80, ic);	end;{-----------------------------------------------------------------------------}		procedure setchangesmatrix (var mx: CMDArray; dL: longint);{FROZEN 3.0}{initializes matrix to 0's or ChartInfinity's}			var				ir, irr: integer;		begin			for ir := 0 to maxChangesState do				for irr := 0 to maxChangesState do					mx[ir, irr] := dL;		end;{-----------------------------------------------------------------------------}	procedure countMaxMinChanges (var sumMax, sumMin: CMDArray; var aborted: boolean);{FROZEN 3.0}{procedure uses Equivocal cycling to find all resolutions; over all resolutions,}{counts maximum, minimum and mean number of changes of each sort in tree.}{Also along the way figures out total numbers of transitions, transversions or changes selected by user}{NOTE: there are two modes, minmaxmode in which minimum and maximum are calculated,}{and meanmode in which mean is calculated.  There are only two sorts of storage, those for minima}{and those for maxima.  Thus when meanmode is in effect, the storage used is that originally}{intended for maxima.}{Thus depending upon the context, a variable like TransitionMaxInChar either stores the maximum}{or the mean number of transitions in the character}		label			1;		var			singleTree, db: boolean;			ic, ctyp, ist, iend: integer;			numresolutions: longint;			doaddterminalchanges: boolean;			TracedOnlyStorage: boolean;			thisresolution: CMDPtr; {matrix of changes in resolution}			onecharMax, oneCharmin: CMDPtr; {max(sum)/min matrices of numbers of changes in current character}			theDialog, hiddenDialog: DialogPtr;			tempP: WindowPtr;{These variables record transitions/transversions/selected changes in current resolution}			ntransitionsInRes, ntransversionsInRes: longint;			nChangesSelInRes: longint;{These variables record min/max/mean of transitions/transversions/selected changes in current character}			TransversionMaxInChar, TransversionMinInChar, TransitionMaxInChar, TransitionMinInChar: longint;			TransversionSumInChar, TransitionSumInChar, ChangesSelSumInChar: longint;			ChangesSelMinInChar, ChangesSelMaxInChar: longint;{These variables record sum over all characters of mean transitions/transversions per char over all resolutions}			ctransitions, ctransversions: double;			totalResolutions : longint;			useDouble: boolean;			res: Double;{.......}		procedure InitializeTransChangesInChar;{FROZEN 3.0}		begin			if nucleotides then				begin					TransitionMaxInChar := 0;  {note that init of zero serves both for max storage, and for sum storage used when meanmode}					TransversionMaxInChar := 0;					TransitionSumInChar := 0;					TransversionSumInChar := 0;					if Chartchangesmode = minmaxmode then{note these ones only used for minmaxmode; if only one value called for, it is Max values}						begin							TransitionMinInChar := ChartInfinity; {init min number of transit/transversions to infinity}							TransversionMinInChar := ChartInfinity;						end;				end;			ChangesSelMinInChar := ChartInfinity; {only needed if minmaxmode but more expensive to ask}			ChangesSelMaxInChar := 0;			ChangesSelSumInChar := 0;		end;{.......}		procedure CountChangesinResolution (N: Nptr);{FROZEN 3.0}{procedure moves through tree counting changes in resolution.  Straightforward}{except for polymorphic terminal taxa, for which a few rules were chosen for}{how to count changes within these taxa}			var				statebelow, stateabove, lastfound, ir, irr: integer;		begin			if (N <> R) and BranchExists(N) then  { v3.02}				begin					statebelow := minG(N^.anc^.resolved);{Recall ^.resolved stores resolved state at node }					stateabove := minG(N^.resolved);					if (statebelow <> stateabove) or CWShowConstant then						CountSingleChange(statebelow, stateabove,thisResolution^[statebelow,stateabove], ntransversionsInRes, ntransitionsInRes, nChangesSelInRes);				end;			if NodeIsInternal(N) then				begin					CountChangesinResolution(N^.lf);					CountChangesinResolution(N^.rt);				end			else if doaddterminalchanges and BranchExists(N) then  { v3.02}				CountTerminalChanges(N, ic,ctyp,TracedOnlyStorage, minG(N^.resolved),thisResolution, ntransversionsInRes, ntransitionsInRes, nChangesSelInRes);		end;{.......}		procedure comparemaxmin;{FROZEN 3.0}{for MINMAXMODE only.  Compares elements of matrix of changes in resolution to }{maxima and minima in all resolutions; also other max and mins}			var				ir, irr: integer;		begin			for ir := 0 to maxChangesState do				for irr := 0 to maxChangesState do					begin						ReplaceIfMinimumLong(onecharMin^[ir, irr], thisresolution^[ir, irr]);						ReplaceIfMaximumLong(onecharMax^[ir, irr], thisresolution^[ir, irr]);					end;			if nucleotides then				begin					ReplaceIfMinimumLong(TransitionMinInChar, ntransitionsInRes);					ReplaceIfMaximumLong(TransitionMaxInChar, ntransitionsInRes);					ReplaceIfMinimumLong(TransversionMinInChar, ntransversionsInRes);					ReplaceIfMaximumLong(TransversionMaxInChar, ntransversionsInRes);				end;			ReplaceIfMinimumLong(ChangesSelMinInChar, nChangesSelInRes);			ReplaceIfMaximumLong(ChangesSelMaxInChar, nChangesSelInRes);		end;{.......}		procedure AddResToSumsForMean;{FROZEN 3.0}{for MEANMODE only.  Adds matrix of changes in resolution to sum of such changes;}{Also transitions etc.  Note that although these variables say MAX, they are really used}{to store SUMS}			var				ir, irr: integer;		begin			for ir := 0 to maxChangesState do				for irr := 0 to maxChangesState do					onecharMax^[ir, irr] := onecharMax^[ir, irr] + thisresolution^[ir, irr];			if nucleotides then				begin					ReplaceIfMaximumLong(TransitionMaxInChar, ntransitionsInRes);					ReplaceIfMaximumLong(TransversionMaxInChar, ntransversionsInRes);					TransitionSumInChar := TransitionSumInChar + ntransitionsInRes;					TransversionSumInChar := TransversionSumInChar + ntransversionsInRes;				end;			ReplaceIfMaximumLong(ChangesSelMaxInChar, nChangesSelInRes);			ChangesSelSumInChar := ChangesSelSumInChar + nChangesSelInRes;		end;{.......}		procedure AddCharacterToSums;{FROZEN 3.0}{Once all resolutions of character surveyed, matrix of changes (min, max or sum) are}{added into sum over all characters}			var				ir, irr: integer;				meanChanges: longint;		begin			if chartchangesmode = minmaxmode then				for ir := 0 to maxChangesState do					for irr := 0 to maxChangesState do						begin							sumMax[ir, irr] := sumMax[ir, irr] + onecharMax^[ir, irr];							sumMin[ir, irr] := sumMin[ir, irr] + onecharMin^[ir, irr];							if (ir <> irr) or CWShowConstant then								{if CWTrees[CWChart] = CWCurrentTree then}  {v3.02}									begin										CheckWriteCalc(onecharMin^[ir, irr]);										CheckWriteCalc(onecharMax^[ir, irr]);									end;						end			else {meanmode}				for ir := 0 to maxChangesState do					for irr := 0 to maxChangesState do  {recall that in meanmode, the max storages store the sums}						begin							meanChanges := (onecharMax^[ir, irr] * meanchangesinflate + numresolutions div 2) div numresolutions;							sumMax[ir, irr] := sumMax[ir, irr] + meanChanges; {sum of means, inflated by meanchangesinflate}							if (ir <> irr) or CWShowConstant then								{if CWTrees[CWChart] = CWCurrentTree then } {v3.02}									begin										CheckWriteReal(1.0000000* MeanChanges / meanchangesinflate,ChartLogSigDigits);										{CheckWriteCalc(MeanChanges);  }									end;						end;{v4:  (e.g. numresolutons div 2) added before div to make like RoundValue- not exactly accurate}		end;{.................................................................................................}	begin		SetCursor(clockCursor);		theDialog := nil;		setChangesMatrix(sumMax, 0);		setChangesMatrix(sumMin, 0);		numCWChars := 0;  {initializing count of number of characters examined}		TracedOnlyStorage := CWTraced & (CWTrees[CWChart] = CWCurrentTree);		if CWTraced then			begin				ist := i;				iend := i;			end		else			begin				ist := 1;				iend := numchars;			end;		thisresolution := CMDPtr(NewPtr(SizeOf(CMDarray)));{  note that min, max storages used differently for meanmode than minmaxmode.  If minmaxmode, min stores}{minimum and max stores maximum.  If meanmode, then min stores nothing and max stores sum; mean for character is}{obtained by dividing max by numresolutions.  Note that all max storages (for transitions, transversions, changessel, as well}{as simple thisresolution matrix) are used for the respective sorts of sums for means.  In the end, sumMin is passed}{back nothing, while sumMax is passed back mean of means, each inflated by 100.}		onecharMax := CMDPtr(NewPtr(SizeOf(CMDarray)));		ChangesSelMax := 0;  {initialize sum over all characters of max of selected changes}		ChangesSelAvg := 0.0;		if chartchangesmode = minmaxmode then			begin				oneCharmin := CMDPtr(NewPtr(SizeOf(CMDarray)));				ChangesSelMin := 0;  {initialize sum over all characters of min of selected changes}			end;		if nucleotides then			begin				TransRatio := 0.0;  {setting transition transversion ratio to 0; not really needed since set at end of procedure}				ctransitions := 0.0;  {initializing sum of mean transitions; only for meanmode}				ctransversions := 0.0;  {initializing sum of mean transversions only for meanmode}				if Chartchangesmode = minmaxmode then					begin{note these ones only used for minmaxmode; if only one value called for, it is Max values}						TransversionMin := 0;  {initialize sum over all characters of min of transversions}						TransitionMin := 0;  {initialize sum over all characters of min of transitions}					end;				TransitionMax := 0;  {initialize sum over all characters of max of transitions}				TransversionMax := 0;  {initialize sum over all characters of max of transversions}			end;		singleTree:= false;		totalResolutions := 0;		if not cwtraced | (CWTrees[CWChart]<>CWCurrentTree) then			begin				DisableWindowUpdates(tlegwindow);				DisableWindowUpdates(chlegwindow);				DisableWindowUpdates(chartwindow);				DisableWindowUpdates(treewindow);				//SetTaxaDnsts(1, numchars);				//reconstructChars(1, numchars, true);			end;		if not cwtraced then			begin				StartThermo(theDialog, tempP, 0, iend - ist + 1, 'Chart: Checking for changes', 'characters', false);			end		else if CWTrees[CWChart] = CWCurrentTRee then			begin				totalResolutions := NumberOfResolutions(R, i, true, useDouble,res);				if useDouble then					begin						totalResolutions := maxLongint;					end;				StartThermo (theDialog,tempP,0,totalResolutions,'Cycling through MPRs','',false);				singleTree:= true;			end;		for ic := ist to iend do			if charincluded(ic) then				if TypeOfChar(ic) = fisher then  {changes not counted in stratigraphic characters}					Newerror(361, ic)				else if not CWShowConstant & (CharConstant(ic) & not (tracedonlystorage & fixon)) then		{Character is constant, therefore skip calculations, as wouldn't find anything, }		{but record as another character examined}		{"(tracedonlystorage & fixon)" added above and below }		{because calculations could find something even if character was constant}		{as long as using character tracing with fixed states}					numCWChars := numCWChars + 1				else if (CWShowConstant | (not CharConstant(ic) | (tracedonlystorage & fixon))) then					begin			{only need to add changes within terminal taxa if taxon has multistate taxa or if states might}			{be fixed away from observed and if addpolychanges is on}						doaddterminalchanges := addpolychanges & (MSTaxaInCharTree(ic) | (tracedonlystorage & fixon));						if ChartCalcToText & writeEveryCharacter then   {v3.02}							begin								ChartWriteChar(chr(13));								ChartWriteString(StringFromNum(ic));								ChartWriteChar(chr(9));							end;						InitializeTransChangesInChar;						if CheckIfAbortedChart then							if not checkifcontinueaBit then								begin									aborted := true;									goto 1;								end;						numCWChars := numCWChars + 1;						ctyp := typeofchar(ic);						setChangesMatrix(onecharMax^, 0);						if Chartchangesmode = minmaxmode then							setChangesMatrix(onecharMIn^, ChartInfinity);						Equiv_MakeFirstResolution(R, ic, TracedOnlyStorage);												numresolutions := 0;						if ErrorPosted(8) or ErrorPosted(7) then  { errors 7 and 8 are MacClade problem errors since signify prohibition broke down}							begin								aborted := true;								goto 1;							end;						equivocalCycleCalculation := true;						repeat  {CYCLING THROUGH RESOLUTIONS}							if numResolutions = maxLongint then								begin									NewError(443,ic);									leave;								end;							if (numresolutions mod cancelCheckFreq = 0) & (numresolutions > 0) then								begin									if singleTree  & (theDialog<>nil) then										UpdateThermo (TheDialog,0,numresolutions,totalResolutions,false)									else db := ThermoWasAborted(theDialog);																	if abortedThermo then										if  not checkifcontinueabit then   {= 1 to avoid each char}											begin												aborted := true;												goto 1;											end										else											abortedThermo := false;								end;							if (numresolutions mod 10 = 0) & not singleTree then								EquivocalCursor(True);							numresolutions := numresolutions + 1;							setChangesMatrix(thisresolution^, 0); {initialize changes matrix before counting in resolution}							if nucleotides then								begin									ntransitionsInRes := 0; {initialize num transitions, transv, etc. before counting in resolution}									ntransversionsInRes := 0;								end;							nChangesSelInRes := 0;							CountChangesInResolution(R);    {this counts changes according to resolved}			{now that changes in resolution counted, need to check minima, maxima, and add to sums for character}							if Chartchangesmode = minmaxmode then								Comparemaxmin							else  {it's meanmode}								AddResToSumsForMean;  {accumulates sums over all resolutions for this character}						until (uniqueresolution) | Equiv_NextResInClade(R, R, ic, ctyp, TracedOnlyStorage);			{NextResInClade places next resolution in resolved and returns true if it is already at last resolution}						AddCharacterToSums;{now that character checked, need to add to sums for all characters}						if nucleotides then							begin								if chartchangesmode = minmaxmode then									begin										TransitionMin := TransitionMin + TransitionMinInChar;  {add min transitions in char to sum over all chars}										TransversionMin := TransversionMin + TransversionMinInChar;{add max transitions in char to sum over all chars}										TransitionMax := TransitionMax + TransitionMaxInChar;										TransversionMax := TransversionMax + TransversionMaxInChar;									end								else  {meanmode}									begin										ctransitions := ctransitions + TransitionSumInChar / numresolutions;										ctransversions := ctransversions + TransversionSumInChar / numresolutions;										TransitionMax := TransitionMax + TransitionMaxInChar;										TransversionMax := TransversionMax + TransversionMaxInChar;									end;							end;						if chartchangesmode = minmaxmode then							ChangesSelMin := ChangesSelMin + ChangesSelMinInChar;						ChangesSelMax := ChangesSelMax + ChangesSelMaxInChar;						if chartchangesmode = meanmode then							ChangesSelAvg := ChangesSelAvg + ChangesSelSumInChar / numresolutions;						if not cwtraced then							UpdateThermo(theDialog, 0, ic - ist + 1, iend - ist + 1,false);						if CheckIfAbortedChart then							begin								if not checkifcontinueabit then									begin										aborted := true;										goto 1;									end;							end;					end; {for ic:=ist to iend}1:		equivocalCycleCalculation := false;		EndThermo(theDialog, tempP, true);		if nucleotides and (ChartChangesMode = meanmode) then			begin				if ctransversions < 0.001 then					transRatio := 0.0				else					transRatio := ctransitions / ctransversions;				TransitionAvg := ctransitions;				TransversionAvg := ctransversions;			end;		ZapPointer(thisresolution);		ZapPointer(onecharMax);		if chartchangesmode = minmaxmode then			ZapPointer(oneCharmin);	end;{-----------------------------------------------------------------------------}{-----------------------------------------------------------------------------}	procedure ChangesinCladeUnamb (N: Nptr; var aborted: boolean);{FROZEN 3.0}{counts unambiguous changes in the clade above N}		label			3;		var			statebelow, stateabove: integer;			setbelow, setabove: largestsetchars;			CMD: CMDArray;			theCMkind: integer;			j, k: integer;			TracedOnlyStorage: boolean;			ist, iend: integer;			aN: Nptr;			NstsP, aNstsP: Ptr;			CtypP: IP;			clenP: LIP;			oldState1, oldState2, oldState3: SignedByte;{.........}		procedure AddChangeToList (statebelow, stateabove: integer);{FROZEN 3.0}{check transversion transitions and changes of selected class}		begin			if nucleotides & (statebelow <> stateabove) then				if ((statebelow in purine) & (stateabove in pyrim)) | ((stateabove in purine) & (statebelow in pyrim)) then					TransversionMin := TransversionMin + 1				else					TransitionMin := TransitionMin + 1;			if (not changesRestricted) | changesSel^[statebelow, stateabove] then				changesSelMin := changesSelMin + 1;			CMD[statebelow][stateabove] := CMD[statebelow][stateabove] + 1;		end;{.........}		procedure CheckChangeAndAdd (setbelow, setabove: largestsetchars);{FROZEN 3.0}		begin			if (MonomorphLg(setbelow)) & (MonomorphLg(setabove)) then				begin					statebelow := minLg(setbelow);					stateabove := minLg(setabove);					if (statebelow <> stateabove) or CWShowConstant then						AddChangeToList(statebelow, stateabove);				end;		end;{.........}		procedure CheckChangeINPolymorph (tset, termset: largestsetchars; ic: integer; fixed: boolean);{FROZEN 3.0}			var				lastfound, ir: integer;		begin			if (MultipleStatesLg(termset) & MonomorphLG(tset) & not (UCl in termset)) | fixed then	{count change in terminal only when polymorphic or fixed}				begin					if UCL in termset then {must be fixed at uncertain terminal}						begin							if typeofchar(ic) in [ordered, irreversible, dollo] then								begin									termset := spanLg(termset);									if not (minLg(tset) in termset) then										begin											stateabove := MinLg(closestinAtoB(termset, tset, ordered));											statebelow := minLg(tset);											AddChangeToList(statebelow, stateabove);										end;								end							else if typeofchar(ic) >= usedef then								if not (minlg(tset) in termset) then									NewError(50, ic);						end					else  {polymorphic terminal or fixed terminal against polymorphic or monomorphic taxon}						begin							termset := termset - tset;							if cardlg(termset) > 0 then								if (MonomorphLG(termset)) then {just two states in terminal taxon, one of which placed at node}									begin										statebelow := minLg(tset);										stateabove := minLg(termset);										AddChangeToList(statebelow, stateabove);									end								else if typeofchar(ic) in [ordered, irreversible, dollo] then  {polymorphic, ordered type}									begin				{if ordered type character, then presume changes within terminal taxon from}				{assigned state left and right to states observed}										statebelow := minLg(tset);										lastfound := statebelow;										for ir := statebelow + 1 to CharMaxstOBS(ic) do											if ir in termset then												begin													AddChangeToList(lastfound, ir);													lastfound := ir;												end;										lastfound := statebelow;										for ir := statebelow - 1 downto 0 do											if ir in termset then												begin													AddChangeToList(lastfound, ir);													lastfound := ir;												end;									end								else if typeofchar(ic) = fisher then									Newerror(361, ic)								else if typeofchar(ic) <> unordered then									NewError(50, ic);						end;				end;		end;{.........}		procedure ChangesInCladeRec (var N: Nptr);{Counts changes below node N, from N's ancestor to N; also, for terminal}{taxa, counts changes within polymorphisms}			var				ic: integer;		begin			if NodeIsInternal(N) then				begin					ChangesInCladeRec(N^.lf);					ChangesInCladeRec(N^.rt);				end;			if BranchExists(N) then { v.3.02}				begin					aN := NotNullAnc(N);					if TracedOnlyStorage then  {changes counted on tracing itself======}						begin							if not nodeispolytomous(aN) or polyreal then {if AN is polytomous, then should only count changes if polyreal}								CheckChangeAndAdd(aN^.final, N^.final);							if addpolychanges & NodeIsTerminal(N) then  {seeing if need to add terminal changes}								if N^.fix | MSTaxaInCharTree(i) then									CheckChangeINPolymorph(N^.final, gettaxonstsLargest(N^.name, i), i, N^.fix);						end					else if ist <> iend then  {changes counted on all characters ======}						begin							if not nodeispolytomous(aN) or polyreal then {if AN is polytomous, then should only count changes if polyreal}								begin									LockHandle(N^.stsH, oldstate1);									LockHandle(aN^.stsH, oldstate2);									LockHandle(chtypH, oldstate3);									NstsP := ptr(ord4(GetMaster(N^.stsH)));									aNstsP := ptr(ord4(GetMaster(aN^.stsH)));									CtypP := IP(ord4(GetMaster(chtypH)));									for ic := ist to iend do										begin											if ctypP^ = fisher then												Newerror(361, ic)											else if (ctypP^ < excluded) then												CheckChangeAndAdd(ZeroHighBitsLg(GetLargestFromPtr(aNstsP)), ZeroHighBitsLg(GetLargestFromPtr(NstsP)));											NstsP := Ptr(ord4(NstsP) + tcb);											aNstsP := Ptr(ord4(aNstsP) + tcb);											CtypP := IP(ord4(ctypP) + chtb);										end;									ResetHandle(N^.stsH, oldstate1);									ResetHandle(aN^.stsH, oldstate2);									ResetHandle(chtypH, oldstate3);								end;							if addpolychanges & (NodeIsTerminal(N)) then								for ic := ist to iend do									if CharIncluded(ic) & MSTaxaInCharTree(ic) & (typeofchar(ic) <> fisher) then										CheckChangeINPolymorph(GetStsLargest(N, ic), gettaxonstsLargest(N^.name, ic), ic, false);						end					else {ist=iend}						if (typeofchar(i) <> fisher) then							begin								setabove := getstsLargest(N, i);								if not nodeispolytomous(aN) or polyreal then									CheckChangeAndAdd(getstsLargest(aN, i), setabove);								if addpolychanges & (NodeIsTerminal(N)) & MSTaxaInCharTree(i) then  {never fixed since not traced storage}									CheckChangeINPolymorph(setabove, gettaxonstsLargest(N^.name, i), i, false);							end;				end;		end;{.........}	begin		SetCursID(countchange);		TracedOnlyStorage := CWTraced & (CWTrees[CWChart] = CWCurrentTree);		if CWTraced then			begin				ist := i;				iend := i;			end		else			begin				ist := 1;				iend := numchars;			end;		if CWTrees[CWChart] <> CWCurrentTree then {we will be storing results in CMextra}			begin				theCMKind := CMextra;				for j := 0 to maxChangesState do					for k := 0 to maxChangesState do						ChartMatrixData[theCMkind]^[j][k] := 0;			end		else			theCMKind := CMstandard;		CMD := ChartMatrixData[theCMkind]^;		if nucleotides then  {initializing}			begin				TransversionMin := 0;				TransitionMin := 0;			end;		changesSelMin := 0;		ChangesInCladeRec(N^.lf);  {recursing to count changes}		ChangesInCladeRec(N^.rt);		ChartMatrixData[theCMkind]^ := CMD;3:	end;{-----------------------------------------------------------------------------}	procedure CompareReportSquares(ds: str255; square1,square2: CMDPtr; exact: boolean);	{if exact, then min max, and no meanchangesinflate}	{if not exact, then doing average}	var iFrom,iTo: integer;		totalDiff: longint;		avgDiff: double;		dss: str255;	begin		totalDiff := 0;		for iFrom := 0 to maxChangesState do			for iTo := 0 to maxChangesState do				if square1^[iFrom,iTo]>square2^[iFrom,iTo] then					totalDiff := totalDiff + (square1^[iFrom,iTo]-square2^[iFrom,iTo])				else if square1^[iFrom,iTo]<square2^[iFrom,iTo] then					totalDiff := totalDiff + (square2^[iFrom,iTo]-square1^[iFrom,iTo]);		if (exact& (TotalDiff > 0)) then			InstantInfo(concat(ds,' old and new methods give different results; total difference: ', StringFromNum(totalDiff), chr(13),'Report this to clade@arizona.edu.'))		else if not exact then			begin				avgDiff := 1.0* totalDiff / meanChangesInflate;				 if  (avgDiff > ( maxMPRState+1) * (1+maxMPRState) * 0.01) then					begin												RealToString(avgDiff,dss,1000,3,false);						InstantInfo(concat(ds,' old and new methods give different results; total difference: ', dss, chr(13),'Report this to clade@arizona.edu.'));					end;			end;	end;{-----------------------------------------------------------------------------}	procedure ChangesinClade (N: Nptr; var aborted: boolean);{FROZEN 3.0}{central control procedure for counting changes in the clade}{called by CharChanges and by ChartTreeCycle}	label 1;	var extraCMD1, extraCMD2: CMDPtr;	begin		extraCMD1 := nil;		extraCMD2 := nil;		if CWTraced and (typeofchar(i) = fisher) then			begin				NewError(363, 0);				PleaseOffChart := true;			end		else			begin				if MPRCalculationsMode=MPRDualMode then					begin						extraCMD1 := CMDPtr(NewPtrClear(SizeOf(CMDArray)));						extraCMD2 := CMDPtr(NewPtrClear(SizeOf(CMDArray)));						if (extraCMD1=nil) | (extraCMD2=nil) then							begin								aborted := true;								goto 1;							end;					end;				aborted := false;{in countMaxMinChanges, the two values passed are the storage locations for results of any}{calculations on the current tree.  For minmax mode, both a min and a max storage location are used;}{for mean mode, both arguments are passed, but only the first storage location is used}				case Chartchangesmode of					minmaxmode: 						begin							case MPRCalculationsMode of								MPRDualMode:									begin										if CWTrees[CWChart] <> CWCurrentTree then											begin												//ZeroCMDPtrFull(Chartmatrixdata[CMextraMax]);												//ZeroCMDPtrFull(Chartmatrixdata[CMextramin]);												countMaxMinChanges(Chartmatrixdata[CMextraMax]^, Chartmatrixdata[CMextramin]^, aborted);												if not aborted then													NewMinAverageMaxChanges(extraCMD1, nil,extraCMD2, aborted);												if not aborted then													begin														CompareReportSquares('Minima: ',Chartmatrixdata[CMextramin],extraCMD1,true);														CompareReportSquares('Maxima: ',Chartmatrixdata[CMextraMax],extraCMD2,true);													end;											end										else											begin												//ZeroCMDPtrFull(Chartmatrixdata[CMmax]);												//ZeroCMDPtrFull(Chartmatrixdata[CMmin]);												countMaxMinChanges(Chartmatrixdata[CMmax]^, Chartmatrixdata[CMmin]^, aborted);												if not aborted then 													NewMinAverageMaxChanges(extraCMD1, nil,extraCMD2, aborted);												if not aborted then													begin														CompareReportSquares('Minima: ',Chartmatrixdata[CMmin],extraCMD1,true);														CompareReportSquares('Maxima: ',Chartmatrixdata[CMmax],extraCMD2,true);													end;											end									end;								MPROldMode:									begin										if CWTrees[CWChart] <> CWCurrentTree then											countMaxMinChanges(Chartmatrixdata[CMextraMax]^, Chartmatrixdata[CMextramin]^, aborted)										else											countMaxMinChanges(Chartmatrixdata[CMmax]^, Chartmatrixdata[CMmin]^, aborted);									end;								MPRNewMode:									begin										if CWTrees[CWChart] <> CWCurrentTree then											NewMinAverageMaxChanges(Chartmatrixdata[CMextraMin], nil,Chartmatrixdata[CMextramax], aborted)										else											NewMinAverageMaxChanges(Chartmatrixdata[CMmin], nil,Chartmatrixdata[CMmax], aborted);									end;								otherwise;							end;						end;					meanmode: 						begin							case MPRCalculationsMode of								MPRDualMode:									begin										if CWTrees[CWChart] <> CWCurrentTree then											begin												countMaxMinChanges(Chartmatrixdata[CMextra]^, Chartmatrixdata[CMextraMin]^, aborted) ; {second argument not used}												if not aborted then													NewMinAverageMaxChanges(nil,extraCMD1, nil,aborted) ;												if not aborted then													CompareReportSquares('',Chartmatrixdata[CMextra],extraCMD1,false);											end										else											begin												countMaxMinChanges(Chartmatrixdata[CMstandard]^, Chartmatrixdata[CMextraMin]^, aborted);  {second argument not used}												if not aborted then													NewMinAverageMaxChanges(nil,extraCMD1,nil,  aborted); 												if not aborted then													CompareReportSquares('',Chartmatrixdata[CMstandard],extraCMD1,false);											end									end;								MPROldMode:									begin										if CWTrees[CWChart] <> CWCurrentTree then											countMaxMinChanges(Chartmatrixdata[CMextra]^, Chartmatrixdata[CMextraMin]^, aborted)  {second argument not used}										else											countMaxMinChanges(Chartmatrixdata[CMstandard]^, Chartmatrixdata[CMextraMin]^, aborted);  {second argument not used}									end								MPRNewMode:									if CWTrees[CWChart] <> CWCurrentTree then										NewMinAverageMaxChanges(nil,Chartmatrixdata[CMextra], nil,aborted) 									else										NewMinAverageMaxChanges(nil,Chartmatrixdata[CMstandard],nil,  aborted); 								otherwise;							end;						end;					unambigmode: 						ChangesInCladeUnamb(N, aborted);					otherwise						;				end;1:				if MPRCalculationsMode=MPRDualMode then					begin						ZapPointer(extraCMD1);						ZapPointer(extraCMD2);					end;				if aborted then					begin						NewError(72, 0);						PleaseOffChart := true;					end;			end;	end;{-----------------------------------------------------------------------------}	procedure CharChanges;{calculates character changes for one tree}		var			current: longint;			stateabove, statebelow: integer;			aborted: boolean;{...........}		procedure checkCharChanges (CMstorage, theCMmin, theCMmax, theCMmean: integer);{CMstorage is the value calculated for the current tree, either min, max, mean, or just value}		begin			current := ChartMatrixData[CMstorage]^[statebelow, stateabove];			if chartchangesmode <> meanmode then				CheckWriteCalc(current)			else				CheckWriteReal(1.00000 * current / MeanChangesInflate,ChartLogSigDigits);			ReplaceifMinimumLong(ChartMatrixData[theCMmin]^[statebelow, stateabove], current);			ReplaceifMaximumLong(ChartMatrixData[theCMmax]^[statebelow, stateabove], current);			ChartMatrixData[theCMmean]^[statebelow, stateabove] := ChartMatrixData[theCMmean]^[statebelow, stateabove] + current;		end;{...........}	begin		writeEveryCharacter := not CWTraced & (CWTrees[CWChart] = CWCurrentTree);		ChangesInClade(R, aborted);{this section checks to see if the value or values calculated for this one tree compare to }{mins and maxes calculated for previous trees, and adds calculated value to mean}		if not aborted then			for statebelow := 0 to maxChangesState do				for stateabove := 0 to maxChangesState do					if (stateabove <> statebelow) or CWShowConstant then						case chartchangesmode of							minmaxmode: 								begin									checkCharChanges(CMextraMin, CMminmin, CMminmax, CMminmean);									checkCharChanges(CMextraMax, CMmaxmin, CMmaxmax, CMmaxmean);								end;							meanmode: 								begin									checkCharChanges(CMextra, CMmin, CMmax, CMstandard);								end;							unambigmode: 								checkCharChanges(CMextra, CMmin, CMmax, CMstandard);							otherwise								;						end;		if nucleotides then			begin				if (chartchangesmode = unambigmode) then  {for unambigmode, only min variables used}					begin						CheckWriteCalc(TransitionMin);						CheckWriteCalc(TransversionMin);					end				else if (chartChangesMode = minmaxmode) then					begin						CheckWriteCalc(TransitionMin);						CheckWriteCalc(TransitionMax);						CheckWriteCalc(TransversionMin);						CheckWriteCalc(TransversionMax);					end				else					begin						CheckWriteReal(TransitionAvg,ChartLogSigDigits);						CheckWriteReal(TransversionAvg,ChartLogSigDigits);					end;				if (Chartchangesmode = meanmode) then   {note: currently only calculated for meanmode}					begin						CheckWriteReal(transRatio * 1.00000,ChartLogSigDigits);						transRatioTotal := transRatioTotal + transRatio;						if transRatio < transRatioMin then							TransRatioMin := transRatio;						if transRatio > transRatioMax then							TransRatioMax := transRatio;					end;			end;		//if ChartCalcToText then		//	ChartWriteChar(chr(13));	end;{-----------------------------------------------------------------------------}end.