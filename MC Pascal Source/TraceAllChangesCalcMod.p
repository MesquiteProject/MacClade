unit TraceAllChangesCalc;{еееееееееееееееееееееее}interface	uses		QuickDraw, Printing,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, 		Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  UtilLibInterface, SetLibInterface,   MemoryUtil, 		SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, Thermos, BoxUtil, SetStates, 		typeutil, Settings, CharUtil, TreeUtil, taxonchutil, Legends, BranchListWindow, Calc, CalcUtil, 		Equivocal, Count, TraceControl, TreeMaker, TreeDrawer, TreeMover, InfoWindows;	procedure CountBranchLengths (ist, iend, changesmode: integer; weighted: boolean; var aborted: boolean);{еееееееееееееееееееееее}implementation {е$S TraceAllChangesCalc}{-----------------------------------------------------------------------------}		procedure MakeChangeStorage (N: Nptr);	{allocates memory for bits to store what classes of changes found}		begin			N^.bset1 := newptr(86); {26*26/8}		end;{-----------------------------------------------------------------------------}		procedure ClearChange (N: Nptr; ij, ik: integer);	{clears bit ij,ik in preparation for storing sorts of changes found}		begin			BitClr(N^.bset1, ij * absmaxstate + ik)		end;{-----------------------------------------------------------------------------}		procedure SetChange (N: Nptr; ij, ik: integer);	{sets bit ij,ik to store that this sort of changes found}		begin			BitSet(N^.bset1, ij * absmaxstate + ik)		end;{-----------------------------------------------------------------------------}		function IsChange (N: Nptr; ij, ik: integer): boolean;	{asks whether bit ij,ik is set to indicate that this sort of changes found}		begin			IsChange := Bittst(N^.bset1, ij * absmaxstate + ik)		end;{-----------------------------------------------------------------------------}		procedure ZeroTotalLengths (N: Nptr; changesMode: integer);{FROZEN 3.0}		begin			N^.length1 := 0;			if changesmode = minmaxmode then				begin					N^.length2 := 0;					N^.lengthmean := 0.0;					if (meanByMode = meanbychangeclass) then						MakeChangeStorage(N);				end;			N^.chg := 0;			if NodeIsInternal(N) then				begin					ZeroTotalLengths(N^.lf,changesMode);					ZeroTotalLengths(N^.rt,changesMode);				end;		end;{-----------------------------------------------------------------------------}{###################===TRACE ALL CHANGES====#######################################}{This unit deals with procedures which trace on the current tree a summary of changes}{in all characters.  It therefore counts changes on each branch according to current }{criteria.}{STORAGE:}{in node record, }{N^. length1 stores the total (over all characters) amount of change according to the current criteria (may be weighted), except in}{	minmaxmode in which case it stores the minimum amount}{N^. length2 stores the maximum total amount of change in minmaxmode (may be weighted)}{N^. lengthmean stores the mean total amount of change in minmaxmode (a real variable, averaged over}{	alternative resolutions over entire tree or over alternative classes of change/stasis on branch itself}{NOTE that length1 and length2 may be inflated if there are realtypes or realweights.  Lengthmean}{	is never inflated, always giving the actual mean.}{N^.chg stores the number of changes counted}{N^.int1,int2 are used as temporary stores of min and max lengths at branch in currently}{	examined character}{N^.real1 is used as temporary store of summed changes at branch over various equivocal cycling resolutions, used}{	for mean in minmaxmode}{MODES:}{Changesmode:  }{	unambigmode - unambiguous changes only considered; if sets non-overlapping}{	ambigmode - change counted if set above and below branch are not equal}{	maxmode - change counted if there exists some resolution with change}{	minmaxmode - unambiguous and all possible changes reconstructed by equivocal cycling; mean over all resolutions}{		or over distinct classes of changes}{Weighted:}{	yes - changes are weighted both by cost in steps and by weight of character}{	no - changes are unweighted; only number of changes counted}{-----------------------------------------------------------------------------}	procedure changepassC (numbytes: integer; modde: integer; NstsP, aNstsP: ptr; CtypP: IP; numchars: integer; Nchg: ptr);	external;	procedure changepassASM (numbytes: integer; modde: integer; NstsP, aNstsP: ptr; CtypP: IP; numchars: integer; Nchg: ptr);{FROZEN 3.0}	begin	{Wayne: v3.5 DELETE}	end;{This calculates chg (#changes on node N) for all character types except fisher (which are ignored)}{for both ambigmode and unambigmode as long as amounts of change are not weighted and as long}{as N is not participating in a soft polytomy.}{-----------------------------------------------------------------------------}	procedure CheckDiffMinMax(N: Nptr; changesMode: integer; var diff: longint; var chCount: single);	begin		if diff > N^.int2 then {current change is bigger than previous max; thus use this as new max}			N^.int2 := diff;		if (changesmode = minmaxmode) then			begin				chcount := diff;				if diff < N^.int1 then  {for minmaxmode, checking if new minimum}					N^.int1 := diff;			end;			end;{-----------------------------------------------------------------------------}	procedure AddChangeToNode(N: Nptr; statebelow,stateabove,ctyp, changesMode,ic: integer; weighted: boolean; var diff: longint; var chCount: single; fraction: double);	begin		chcount := 0.0;  {will be used for minmaxmode to add to real1 for mean}		//statebelow := minG(N^.anc^.resolved);  {recall polytomies not allowed with equivocal cycling}		//stateabove := minG(N^.resolved);		diff := statebelow - stateabove; {checking to see if sets are same}		if diff < 0 then			diff := -diff;		if diff <> 0 then  {CHANGE FOUND IN RECONSTRUCTION}			begin  {sets different}				if (ctyp = unordered) | not weighted then	{if not weighted, then the change is counted as 1; likewise if unordered}					begin						N^.int2 := 1; {must be maximum, since any change is 1 unit}						if changesmode = minmaxmode then {sum of change cost for mean}							begin								chcount := 1.0;								if N^.int1 > 1 then   {new minimum change?}									N^.int1 := 1;							end;					end				else if ctyp < usedef then {weighted, ordered, irrev, dollo}	{for ordered, irrev, dollo, the states are ordered and diff can be used directly as cost if weighted}					CheckDiffMinMax(N,changesMode,diff,chcount)				else  {weighted, user-defined}					begin						diff := ddist[statebelow, stateabove];  {sets different, find cost of transformation}						if diff = infinity then							Newerror(54, ic)						else							CheckDiffMinMax(N,changesMode,diff,chcount);					end;				SetStsLargest(n, ic, GetstsliteralLargest(N, ic) + [FTl]); {recording that this character changed}			end		else {sets same;  NO CHANGE IN RECONSTRUCTION}			begin				if weighted & (ctyp >= usedef) then  {check if stasis cost}					begin						diff := ddist[statebelow, stateabove]; {doing this in case it costs to stay still}						CheckDiffMinMax(N,changesMode,diff,chcount);					end				else					N^.int1 := 0; {no change was observed; thus must be minimum}			end;		if (changesmode = minmaxmode) then  {do sum for mean}			if (meanBymode = meanBychangeclass) then {sum of change cost for mean}				begin					if not IsChange(N, statebelow, stateabove) then  { count only if new class of change}						begin							N^.real1 := N^.real1 + chcount;							//N^.lengthmean := N^.real1;							setChange(N, statebelow, stateabove); {is new class, record that it has been found}						end;				end			else if (meanBymode = meanByresolutions) then				begin					N^.real1 := N^.real1 + chcount;					//N^.lengthmean := N^.real1				end;	end;{-----------------------------------------------------------------------------}{================================================================}{===========================  NEW CODE  ============================}{================================================================}{-----------------------------------------------------------------------------}	function MPRStateBelowFromAbove(aboveN: Nptr; aboveState,ic,ctyp: integer): lgsetchars;	{given state aboveState at the node aboveN, this tells you all of the members of the MPR set 	in aboveN's ancestor that would give abovestate in aboveN's MPR set}	var ik: integer;		belowN: Nptr;		aboveTestMPRset: lgsetchars;		tsts : largestSetChars;	begin		belowN:= NotNullAnc(aboveN);		tsts := [];		for ik := 0 to maxstate do			begin				if EnSet(ik, belowN^.original) then  {ik is in the MPR set of N}					begin						if MonomorphG(belowN^.original) then							aboveTestMPRset := OriginalNodeAssignment(aboveN,ik,ic)						else							aboveTestMPRset := CalcDescendentPolymStates(aboveN, ik, ic, ctyp);						if EnSet(aboveState,aboveTestMPRSet) then							tsts := tsts+[ik];					end;			end;		MPRStateBelowFromAbove := NewSetFromOld(tsts);	end;{-----------------------------------------------------------------------------}	procedure NumberOfResolutionsUpPass (N: Nptr; ic: integer);{DRM method:  uses the same principle as user-defined types}		var			ir, ij: longint;			ctyp: integer;			tstsSis, tstsBelow,tsts: lgsetchars;			sisResDouble,belowResDouble: double;{...............................}		procedure NumberResOutside (N: Nptr); 			var				iUp, ik: integer;				sisN, ancN: Nptr;		begin			if NodeIsInternal(N) then				begin					for ik := 0 to maxstate do						begin							N^.MPRrealUp[ik] :=1.0;							if N <> R then								begin									ancN := NotNullAnc(N);									sisN := Sis(N);									if EnSet(ik, N^.original) then										begin											if MonomorphG(N^.original) then												begin													tstsSis := OriginalNodeAssignment(sisN,ik,ic);													tstsBelow := OriginalNodeAssignment(ancN,ik,ic);												end											else												begin													tstsSis := CalcDescendentPolymStates(sisN, ik, ic, ctyp);													//tstsBelow := CalcDescendentPolymStates(ancN, ik, ic, ctyp);													tstsBelow := MPRStateBelowFromAbove(N,ik,ic,ctyp);												end;		{we now know that if ik is the state at node N, then the left and right descendent states are tstsSis & tstsBelow}																																sisResDouble := 0.0;											for iUp := 0 to maxstate do												if EnSet(iUp, tstsSis) then													sisResDouble := sisResDouble + sisN^.MPRreal[iUp];											belowResDouble := 0.0;											for iUp := 0 to maxstate do												if EnSet(iUp, tstsBelow) then													if (ancN=R) & (ancN^.lf=N) then {we are on the left side of the root}														belowResDouble := belowResDouble + ancN^.MPRreal[iUp]/ancN^.MPRrealUp[iUp]													else														belowResDouble := belowResDouble + ancN^.MPRrealUp[iUp];											N^.MPRrealUp[ik] :=sisResDouble*belowResDouble;										end;								end;							{by convention, MPRRealUP at the root stores the number of resolutions up the left side of the tree if ik is at the root; this							is calculated in the downpass, so we don't need to recalculate it here}						end;					NumberResOutside(N^.lf);					NumberResOutside(N^.rt);				end			else				begin					 for ik := 0 to maxstate do						if EnSet(ik, N^.original) then							N^.MPRrealUp[ik] := 1.0						else							N^.MPRrealUp[ik] := 0.0;				end;		end;{...............................}	begin		//PrepareForMPRRecursion(ic,traced, ctyp);		NumberResOutside(N);	end;{-----------------------------------------------------------------------------}	function FractionOfMPRsWithStateAtNode(startN: NPtr; startState,ic,ctyp: integer): double;	var 	fraction,totalMPRsAboveAncNode,relevantMPRsAboveAncNode: double;		N : Nptr;		ancState,theState: integer;		nodeMPRSet: lgsetchars;	begin(*		N := startN;		theState := startState;		fraction := 1.0;		nodeMPRSet := NewSetFromOld([theState]);		repeat 			ancN := NotNullAnc(N);			ancMPRSet := MPRStateBelowFromAbove(N, theState, ic,ctyp);   {ancestor's MPR Set given theState in N}			totalMPRsAboveAncNode := MPRTotalAbove(@ancN^.MPRReal,ancN^.original,maxstate); {total MPRs above that ancestor, for ALL MPRs}			relevantMPRsAboveAncNode := MPRTotalAbove(@ancN^.MPRReal,ancMPRSet,maxstate);  {total MPRs above that ancestor, for just those MPRs in the ancset determined by having the state in Descendent}			ancFractionRelevant:= relevantMPRsAboveAncNode/totalMPRsAboveAncNode;   {fraction of total MPRs at ancestor that are possible given assignment of the State to descendent}			ancFraction := 0.0;			for ancState := 0 to maxState do				if EnSet(ancState,ancMPRSet) then					begin						descendentMPRSet := CalcDescendentPolymStates(N, ancState, ic, ctyp);						totalMPRsAboveDescNode := MPRTotalAbove(@N^.MPRReal,descendentMPRSet,maxstate);						//ancFraction := ancFraction+ancN^.MPRReal[ancstate]/totalMPRsAboveAncNode;						ancMPRSet := MPRStateBelowFromAbove(ancN, ancState, ic,ctyp);					end;			ancMPRSet := ;			fractionAtNode:= N^.MPRReal[ancState]/totalMPRsAboveNode;  // this fraction of MPRs have the state ancState at ancN		until ancN=R;		*)	end;{-----------------------------------------------------------------------------}	procedure CalcMinMaxTraceAll(ancN,N: Nptr; ancState: integer; ancMPRSet,descendentMPRSet: lgsetchars;ctyp, changesMode,ic: integer; weighted: boolean; var diff: longint; var chCount: single; numResDouble: double);	var descendentState: integer;		fraction : double;		oldLength: double;	begin		oldLength := N^.real1;		for descendentState := 0 to maxstate do			if EnSet(descendentState,descendentMPRSet) then				begin					fraction:= (N^.MPRReal[descendentState]*ancN^.MPRRealUp[ancState])/numResDouble;					AddChangeToNode(N,ancState,descendentState,ctyp,changesMode,ic,weighted,diff,chcount,fraction);				end;	//	N^.lengthMean := N^.real1;		//if oldLength<>N^.real1 then N^.chg := N^.chg+1;	end;{-----------------------------------------------------------------------------}	procedure CalcLengthsNew(baseN: NPtr; ic,ctyp,changesMode: integer; var numresolutions: double; var diff: longint; var aborted:boolean; weighted: boolean;theDialog: DialogPtr);{DRM method:  uses the same principle as user-defined types}		var			ir, ij, cardTstsOld: longint;			{hiddenDLOG: DialogPtr;}			tempP: WindowPtr;			tstsLeft, tstsRight,tsts: lgsetchars;			tstsOld : largestsetchars;			leftRes, rightRes: longint;			chCount: single;{...............................}		procedure TraceChangesAbove (N: Nptr); 			var				iUp, ik: integer;		begin			if NodeIsInternal(N) then				begin					TraceChangesAbove(N^.lf);					TraceChangesAbove(N^.rt);					for ik := 0 to maxstate do						begin							if EnSet(ik, N^.original) then  {ik is in the MPR set of N}								begin									if MonomorphG(N^.original) then										begin											tstsLeft := OriginalNodeAssignment(N^.lf,ik,ic);											tstsRight := OriginalNodeAssignment(N^.rt,ik,ic);										end									else										begin											tstsLeft := CalcDescendentPolymStates(N^.lf, ik, ic, ctyp);											tstsRight := CalcDescendentPolymStates(N^.rt, ik, ic, ctyp);										end;{we now know that if ik is the state at node N, then the left and right descendent states are tstsLeft & tstsRight}									CalcMinMaxTraceAll(N,N^.lf,ik,N^.original,tstsLeft,ctyp,changesMode,ic,weighted,diff,chcount,numresolutions);									CalcMinMaxTraceAll(N,N^.rt,ik,N^.original,tstsRight,ctyp,changesMode,ic,weighted,diff,chcount,numresolutions);								end;						end;				end;		end;{...............................}	begin		//PrepareForMPRRecursion(ic,false, ctyp);		ZeroTotalLengths(baseN,changesMode);		NumMPRs(ic,numResolutions);   {do downPass so MPRReal stored}		NumberOfResolutionsUpPass(baseN,ic);  {do up pass so MPRRealUp stored}		TraceChangesAbove(baseN);//		baseN^.real1 := 0.0;//		baseN^.lengthMean := 0.0;//		baseN^.chg := 0;	end;		{-----------------------------------------------------------------------------}{=============================================================================}{=================== below is primarily old code, except for main loop  ====================}{=============================================================================}{-----------------------------------------------------------------------------}		procedure DisposeChangeStorage (N: Nptr);	{disposes memory for bits to store what classes of changes found}		begin			ZapPointer(N^.bset1);		end;{-----------------------------------------------------------------------------}	procedure CountBranchLengths (ist, iend, changesmode: integer; weighted: boolean; var aborted: boolean);{FROZEN 3.0}{Counts amounts of change on branches in tree for characters ist through iend; }{Places results in node record's field length1 and chg.  }{Chg indicates whether any changes were recorded, length 1 indicates amounts of change;}{This is used for branch length printing and the Trace All Changes display}{THIS PROC IS CALLED ONLY IN LASERPRINT AND MACCLADE.}		label			1, 2;		var			diff: longint;			ic, ctyp: integer;			CtypP: IP;			increm: longint;			NstsP, aNstsP: Ptr;			longlen: longint;			theDialog: DialogPtr;			tempP: WindowPtr;			ddist: distancetype;			an: Nptr;			numresolutions: longint;			numResolutionsDouble: double;{...................................UNAMBIGMODE/AMBIGMODE SECTION ...................................}		procedure CountEasyLengths (N: Nptr);{FROZEN 3.0}{For unambiguous, ambigious, this calculates the amounts of change. Generally easy since only needs to compare state}{sets above and below branch}			var				icc: integer;				oldState1, oldState2, oldState3: SignedByte;		begin			aN := NotNullAnc(N);			if (N <> R) & BranchExists(N) & (not PartofPolytomy(N) or polyreal) then				begin{If Weighted, then only unambiguous allowed and therefore needs to just count distance between sets and}{add to weighted to sum}					if weighted then {thus unambigmode only allowed}						begin							if changesmode = unambigmode then								begin									for icc := ist to iend do										if CharIncluded(icc) & not (TypeOfChar(icc) = fisher) then											begin												if GetStsLargest(an, icc) * GetStsLargest(N, icc) = [] then													N^.chg := N^.chg + 1;{store whether change found on branch}						{Find unweighted distance between sets}												diff := 0;  {variable to absorb distance from below to above}												AddDistBetweenSets(GetSTSLargest(aN, icc), GetSTSLargest(N, icc), icc, diff);												if diff = infinity then													NewError(54, 0)												else if diff <> 0 then													begin														longlen := diff; {convert distance on branch below N to longint and add  to N's length1}														if AddToLength(N^.length1, longlen, charweight(icc), typeofchar(icc)) = false then															NewError(309, 0);													end;											end;								end							else								NewError(66, 0);  {ambigmode not allowed with weighting}						end{If Unweighted, we are counting only numbers of changes;  either ambiguous or unambiguous.  }{For ambiguous we count a change if state sets above and below are not identical}{For unambiguous we count a change if state sets do not overlap}					else {not weighted}						begin							LockHandle(N^.stsH, oldstate1);							LockHandle(aN^.stsH, oldstate2);							LockHandle(chtypH, oldstate3);							increm := ord4(ist - 1);							NstsP := ptr(ord4(GetMaster(N^.stsH)) + tcb * increm);							aNstsP := ptr(ord4(GetMaster(aN^.stsH)) + tcb * increm);							CtypP := IP(ord4(GetMaster(chtypH)) + chtb * increm);{This asm procedure goes through, and depending on changesmode, adds 1 to length1 for}{every character whose sets above and below are either different or disjunct.}{It Can work for all types of characters because it is not calculating distances, only changes.}							changepassC(tcb, changesmode, NstsP, aNstsP, CtypP, iend - ist + 1, @N^.length1);{changesmode 0 = unambigmode; 1= ambigmode}							ResetHandle(chtypH, oldstate3);							ResetHandle(N^.stsH, oldstate1);							ResetHandle(aN^.stsH, oldstate2);							N^.chg := N^.length1;  {For unweighted, length1 is number of changes so use it for chg}						end;				end;			if NodeIsInternal(N) then				begin					CountEasyLengths(N^.lf);					CountEasyLengths(N^.rt);				end;		end;{...................................MAXMODE:    SIMPLE MAX LENGTH SECTION ...................................}		procedure CountMaxLengthSimple (N: Nptr; icc: integer);{FROZEN 3.0}{Counts Maximum amount of change for unordered and ordered characters; used for maxmode}			var				lent: longint;				tempset: largestsetchars;		begin			if (N <> R) then {nulls and fixanc not allowed with maxmode}				begin{Maximum length is distance between preferences from above and below branches, that is between}{N's Upst and Dnst.  Imagine rerooting just below N; what was N^.upst now becomes R^.lf^.dnst; what was N^.dnst becomes}{R^.rt^.dnst.  If left dnst and right dnst overlap, then root must have state in overlap.  }{left and right must also be assigned states in this overlap since}{there is no point going outside it; a state outside is guaranteed to make either left's clade or right's clade unhappy.}{If left dnst and right dnst don't overlap, then the length on branch must be the distance between left and right dnst, since}{one of the most parsimonious solutions is to assign left the nearest state in its dnst to right's dnst, and}{vice versa, since any closer states will cost to left or right's clade.  It can't help to assign left and right}{any further state,since it won't save anything within clade but will cost between.  Thus maximum distance under}{parsimony reconstruction is distance between left dnst and right dnst, that is, before rerooting, N^.upst and N^.dnst}					lent := 0;					if (NodeIsInternal(N)) then {for internal nodes, already have node's upst and dnst}						AddDistBetweenSets(GetupstLargest(N, icc), GetdnstLargest(N, icc), icc, lent)   {distance between upst and dnst}					else {for terminal nodes, need to calculate upstate }						begin {note do not have to deal with polytomies or fixanc since they are not allowed with maxmode}							if N^.anc = R then								tempset := getdnstlargest(sis(N), icc)							else								stSetOpLargest(tempset, getupstlargest(N^.anc, icc), getdnstlargest(sis(N), icc), typeofchar(icc), lent);							lent := 0;							AddDistBetweenSets(tempset, GetdnstLargest(N, icc), icc, lent) {distance between upst and dnst}						end;					if weighted then						begin							if not AddToLength(N^.length1, lent, charweight(icc), typeofchar(icc)) then								NewError(309, 0);						end					else if lent > 0 then{if there is distance between upst and dnst but chgs not weighted, just add 1 to length}						N^.length1 := N^.length1 + 1;					if lent <> 0 then						begin							N^.chg := N^.chg + 1;  {store whether change found on branches}							SetStsLargest(n, icc, GetstsliteralLargest(N, icc) + [FTl]);  {Setting FT bit to indicate change found}						end;				end;			if NodeIsInternal(N) then				begin					CountMaxLengthSimple(N^.lf, icc);					CountMaxLengthSimple(N^.rt, icc);				end;		end;{.................................}		procedure StartCharLengths (N: Nptr);{FROZEN 3.0}			var				ij, ik: integer;{initializes min and max lengths for one character on branches;}{int1 will store the smallest amount of change among any reconstruction for the character}{on the branch; int2 will store the largest }		begin			N^.int1 := 32767;			N^.int2 := 0;			if changesmode = minmaxmode then				begin					N^.real1 := 0.0;					if meanBymode = meanBychangeclass then  {zeroing list of classes of changes found on branch}						begin							for ij := 0 to maxstate do								for ik := 0 to maxstate do									ClearChange(N, ij, ik);						end;				end;			if NodeIsInternal(N) then				begin					StartCharLengths(N^.lf);					StartCharLengths(N^.rt);				end;		end;{.......}		procedure CheckLengthsOfReconstruction (N: Nptr);{FROZEN 3.0}{For particular reconstruction found under equivocal cycling, finds change on branch implied, and}{since equiv cycling only done for minmaxmode and maxmode, determines whether it is the largest}{or smalles change found under any reconstruction }			var				statebelow, stateabove: integer;				chcount: single;		begin			if N <> R then				AddChangeToNode(N,minG(N^.anc^.resolved),minG(N^.resolved),ctyp,changesMode,ic,weighted,diff,chcount,1.0);			if NodeIsInternal(N) then				begin					CheckLengthsOfReconstruction(N^.lf);					CheckLengthsOfReconstruction(N^.rt);				end;		end;{.......}		procedure AddToRealLength (var renth: double; radd: double; cwt, ctyp: integer);{adds radd length to sum accumulated for branch}			var				toadd: single;		begin			toadd := radd * cwt;			if realwt then				toadd := toadd / wtinflate;			if realtypes & TypeIsReal(ctyp) then				toadd := toadd / typeinflate;			renth := renth + toadd;		end;{.......}		procedure AddToTotalBranchLength (N: Nptr; ic: integer);{FROZEN 3.0}			var				numclasses, ij, ik: integer;		begin			if N <> R then				begin					if changesmode = minmaxmode then						longlen := N^.int1  {min stored in length1 for minmaxmode}					else						longlen := N^.int2;  {max stored in length1 for maxmode}					if weighted then						begin							if AddToLength(N^.length1, longlen, charweight(ic), typeofchar(ic)) = false then								NewError(309, 0); {note placing result in length1}						end					else						N^.length1 := N^.length1 + longlen;					if changesmode = minmaxmode then						begin		{About to calculate total maximum and mean length under various reconstruction.  }		{For the Mean: The average length, over various}		{reconstructions or classes of change, is calculated for the character as, for example N^.real1/numclasses,}		{and is added to the running total lengthmean}							longlen := N^.int2;							if meanBymode = meanbychangeclass then  {finding out how many classes of changes were found on node}								begin									numclasses := 0;  {v4: could use cardfrom here}									for ij := 0 to maxstate do										for ik := 0 to maxstate do											if IsChange(N, ij, ik) then												numclasses := numclasses + 1;								end;							if weighted then								begin									if AddToLength(N^.length2, longlen, charweight(ic), typeofchar(ic)) = false then										NewError(309, 0);									if meanBymode = meanbychangeclass then										AddToRealLength(N^.lengthmean, (N^.real1 / numclasses), charweight(ic), typeofchar(ic))									else										AddToRealLength(N^.lengthmean, (N^.real1 / numresolutionsDouble), charweight(ic), typeofchar(ic));								end {note placing result in length2}							else								begin									N^.length2 := N^.length2 + longlen;									if meanBymode = meanbychangeclass then										N^.lengthmean := N^.lengthmean + (N^.real1 / numclasses)									else										N^.lengthmean := N^.lengthmean + (N^.real1 / numresolutionsDouble);								end;						end;					if longlen <> 0 then						N^.chg := N^.chg + 1;			{store whether change or length found on branches (if no change but stasis cost,}			{chg will register one more if weighted but FTl will not be set in the sts storage}				end;			if NodeIsInternal(N) then				begin					AddToTotalBranchLength(N^.lf, ic);					AddToTotalBranchLength(N^.rt, ic);				end;		end;{.........................End equiv cycling section................................................................................}		procedure DisposeChSt (N: Nptr);		begin			DisposeChangeStorage(N);			if NodeIsInternal(N) then				begin					DisposeChSt(N^.lf);					DisposeChSt(N^.rt);				end;		end;{.........................................................................................................}	function CalcUsingOldEquivocal: boolean;	begin		CalcUsingOldEquivocal := true;		Equiv_MakeFirstResolution(R, ic, tracedfalse); {first resolution of equivocal cycling}		numresolutions := 0;		numResolutionsDouble := 1.0;		if ErrorPosted(8) or ErrorPosted(7) then			begin				aborted := true;				CalcUsingOldEquivocal := false;				Exit(CalcUsingOldEquivocal);			end;		equivocalCycleCalculation := true;		repeat			if (numResolutions > maxlongint -1) then				begin					NewError(442,ic);					aborted := true;					CalcUsingOldEquivocal := false;					Exit(CalcUsingOldEquivocal);				end;			if (numresolutions mod cancelCheckFreq = 0) & ThermoWasAborted(theDialog) then   {= 1 to avoid each character}				begin					aborted := true;					CalcUsingOldEquivocal := false;					Exit(CalcUsingOldEquivocal);				end;			if numresolutions mod 10 = 0 then 				EquivocalCursor(True);{resolution obtained; now see lengths of branches in this reconstruction}			numresolutions := numresolutions + 1;			CheckLengthsOfReconstruction(R);{now go to next resolution, unless flag already set that resolution was unique}		until (uniqueresolution) | Equiv_NextResInClade(R, R, ic, ctyp, tracedfalse);{stop cycling when Equiv_NextResInClade returns true (i.e., that equiv cycling ended)}		numResolutionsDouble := numResolutions*1.0;	end;{.........................................................................................................}	begin		if Anytype([fisher]) then			NewError(361, 0);		if nullson and not polyreal then			NewError(335, 0); {zerolength on polytomies because not calculated}		aborted := false;		SetCursor(clockCursor);		ZeroTotalLengths(R,changesMode);{=== MINMAXmode/MAXmode======}		if (changesmode = maxmode) or (changesmode = minmaxmode) then {or (changesmode = minmaxmode) {this does min and max; MINMAXIN}			begin{first option: maximum number of changes required, in which case equivocal cycling may be needed}				DisableWindowUpdates(treewindow);								StartThermo(theDialog, tempP, 0, iend - ist + 1, 'Trace All: checking for changes', 'characters', false);				for ic := ist to iend do					if charincluded(ic) & not charConstant(ic) & (TypeOfChar(ic) <> fisher) then						begin							ctyp := typeofchar(ic); {get type of character}							if (ctyp <= ordered) and (changesmode = maxmode) then								begin {ordered or unordered, maxlength simple can be used}									SetCursor(clockCursor);									CountMaxLengthSimple(R, ic);									UpdateThermo(theDialog, 0, ic - ist + 1, iend - ist + 1,false);									if abortedthermo then										goto 1;								end							else {either complex type, or minmaxmode requested}								begin									if (changesmode = minmaxmode) & (meanbymode = meanbychangeclass) then										begin											if (2 * numtaxain - 1) * 86 > MemAvail then												begin													NewError(374, 0);													aborted := true;													goto 2;												end;										end;									if ctyp >= usedef then										begin											typehdl := getTypeHdl(ctyp);											ddist := TypeHdl^^.dist; {getting type matrix}										end;									StartCharLengths(R); {initialize length of branches for this char to zero}									case MPRCalculationsMode of										MPROldMode:											if not CalcUsingOldEquivocal then												goto 1;										MPRNewMode:											CalcLengthsNew(R,ic, ctyp,changesMode,numResolutionsDouble,diff,aborted,weighted,theDialog);										MPRDualMode:											if not CalcUsingOldEquivocal then												goto 1;										otherwise;									end;				{now add min or max amounts of change found in CheckLengthsOfRec. to total for all chars}									AddToTotalBranchLength(R, ic);									UpdateThermo(theDialog, 0, ic - ist + 1, iend - ist + 1,false);								end;						end;1:				if (changesmode = minmaxmode) & (meanByMode = meanbychangeclass) then					DisposeChSt(R);2:				equivocalCycleCalculation := false;				EndThermo(theDialog, tempP, true);			end		else{=== AMBIGmode/UNAMBIGmode (=MINmode)=====}			begin				if allowCursorChange then SetCursID(countchange);				CountEasyLengths(R); {count lengths along branches}			end;		if aborted then			NewError(73, 0);	end;end.