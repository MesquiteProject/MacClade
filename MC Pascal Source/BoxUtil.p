unit BoxUtil;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, 		Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, 		Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, 		TaxonCHUtil, TreeUtil;	procedure DressUpBox(box: rect);	procedure DrawRowColumnNumber(box: rect; number: integer);{$IFC SHADOWTREE}	procedure ShadowBox (box: rect);{$ENDC}	procedure DrawToolBox(box: rect;boldEdges: boolean);	procedure InvalidateBox (windP: WindowPtr; box: rect);	procedure DrawPopUpRect (var box: rect; ds: str255);	procedure InvertHiliteRect (box: rect);	procedure HiliteDataBox (box: rect; it, ic: integer);	procedure FlashBox (box: rect);	procedure DimBox (box: rect);	procedure SetDimDrawing;	procedure UnDimDrawing;	procedure GrayOutline (box: rect; mode: integer);	procedure FRAMEShadowRECT (B: RECT);	procedure WriteB (B: RECT; str: str255);	procedure DrawGrowBox (whichwindow: WindowPtr);	procedure LoadCursor (var thecursor: cursor; cursID: integer);	procedure DropCursor (theCursor: Cursor; left, top: integer; mode: integer);	procedure DropCursorH (cursH: twocursors; left, top: integer; mode: integer);	procedure DropCursorID (ID: integer; left, top: integer; mode: integer);	procedure DrawLock2 (originalBox: rect; doErase, drawLockifUnlocked,locked: boolean);	procedure DrawLock (wh: point; doErase, drawLockifUnlocked,locked: boolean);	procedure DefineTWClip;	procedure SetDataBoxesClip;	procedure SetUpRect;	procedure ResetTop;	procedure ResetRects;	procedure ReCalcBoxes;	procedure ResetForNextTree;{$IFC TINKERTOY}	function GetTinkerBox (N: Nptr): rect;{$ENDC}	{function commWindowStart: integer;	procedure ShrinkCommWindowHeight (var height: integer);	procedure SizeCommWindowText (adjustDestRect, calcNLines, resetOrigin: boolean);	procedure SetCommTextBox;	procedure DrawCommWindow;}{еееееееееееееееееееееее}implementation {е$S BoxUtil}{-----------------------------------------------------------------------------}	procedure DrawToolBox(box: rect;boldEdges: boolean);	var  oldFore, oldBack: RGBColor;	begin		if ColorPort & (PixelDepth>8) then			SetGrayBackground(oldBack,grayPalest)		else			GetBackColor(oldBack);		InsetRect(box,1,1);		Eraserect(box);		InsetRect(box,-1,-1);		GetForeColor(oldFore);		PenNormal;		RGBForeColor(GrayScale(5,2));		moveTo(box.left+1,box.bottom-2);		lineTo(box.right-2,box.bottom-2);		lineto(box.right-2,box.top+1);		RGBForeColor(whiteRGB);		moveto(box.left+1,box.bottom-3);		lineto(box.left+1,box.top+1);		lineto(box.right-3,box.top+1);		{RGBForeColor(GrayScale(5, 3));		lineto(box.right-2,box.bottom-2);}		{lineto(box.left+1,box.bottom-2);}		RGBForeColor(GrayScale(5,4));		if boldEdges then			FrameRect(box);		RGBForeColor(oldFore);		SetRGBBackground(oldBack);	end;{-----------------------------------------------------------------------------}	procedure DressUpBox(box: rect);	var  oldFore, oldBack, paleGray: RGBColor;	begin		if ColorPort then			begin				SetGrayBackground(oldBack,grayPlain);				GetForeColor(oldFore);			end;		Eraserect(box);				{FrameRect(box);}		moveTo(box.left,box.bottom-1);		lineTo(box.right-1,box.bottom-1);		lineto(box.right-1,box.top);		if ColorPort then			begin				paleGray := GrayScale(6, 1);				RGBForeColor(paleGray);				moveto(box.left,box.bottom-2);				lineto(box.left,box.top+1);				lineto(box.right-2,box.top+1);				RGBForeColor(GrayScale(5, 3));				lineto(box.right-2,box.bottom-2);				{lineto(box.left+1,box.bottom-2);}				RGBForeColor(oldFore);				SetRGBBackground(oldBack);			end;	end;{-----------------------------------------------------------------------------}	procedure DrawRowColumnNumber(box: rect; number: integer);	begin	end;{-----------------------------------------------------------------------------}{||||||||||||||||||||||||||||| Box Utilities ||||||||||||||||||||||||||||}{$IFC SHADOWTREE}{-----------------------------------------------------------------------------}	procedure ShadowBox (box: rect);	begin		if ColorPort then			begin				Pensize(1, 1);				RGBForeColor(GrayScale(4, 3));				MoveTo(box.left + 1, box.bottom);				LineTo(box.right, box.bottom);				LineTo(box.right, box.top + 1);				RGBForeColor(GrayScale(6, 2));				MoveTo(box.left + 2, box.bottom + 1);				LineTo(box.right + 1, box.bottom + 1);				LineTo(box.right + 1, box.top + 2);				RGBForeColor(blackRGB);			end;	end;{$ENDC}{-----------------------------------------------------------------------------}	procedure InvalidateBox (windP: WindowPtr; box: rect);	begin		InvalidateWindowRect(windP,box,true);	end;{-----------------------------------------------------------------------------}	procedure DrawPopUpRect (var box: rect; ds: str255);{Drawing shadowed rectangle for pop up menus, complete with string and triangle}		var			thePoly: PolyHandle;	begin		box.right := box.right + 2;		box.bottom := box.bottom + 2;		EraseRect(box);		Box.right := Box.left + StringWidth(ds) + 29;		box.right := box.right + 2;		FrameShadowRect(box);		box.right := box.right - 2;		box.bottom := box.bottom - 2;		MoveTo(box.left + 10, box.bottom - 3);		DrawString(ds);{=== triangle ===}		thePoly := OpenPoly;		MoveTo(box.right - 15, box.top + 6);		Line(12, 0);		Line(-6, 6);		Line(-6, -6);		ClosePoly;		FillPoly(thePoly, QDBlack);		KillPoly(thePoly);	end;{-----------------------------------------------------------------------------}	procedure InvertHiliteRect (box: rect);	begin		{BitClr(Ptr($938), pHiliteBit);  }{$938} {v4: use constant}		InvertRect(box);	end;{-----------------------------------------------------------------------------}	procedure HiliteDataBox (box: rect; it, ic: integer);{this procedure hilites a databox as appropriate}	begin		if not printon then			begin				PenSizeOrient(1, 1);				if footpresent(it, ic) then					begin						InsetRectOrient(box, -1, -1);						PenPat(QDGray);						FrameRectOrient(box);						PenPat(QDBlack);					end;				if footpictpresent(it, ic) then					begin						InsetRectOrient(box, -1, -1);						FrameRectOrient(box);					end;			end;	end;{-----------------------------------------------------------------------------}	procedure FlashBox (box: rect);{this flashes a rectangle: used for controls}		var			j: integer;	begin		for j := 1 to 2 do			begin				InvertRect(box);				delay(3, ticks);				InvertRect(box);				delay(3, ticks);			end;	end;{-----------------------------------------------------------------------------}	procedure DimBox (box: rect);{turns QDBlack elements into QDGray by bopping down a QDGray pattern on top}{of course, does not work for output to PostScript devices}		var			pnState: PenState;	begin{$IFC NOT ALWAYSENABLED}		GetPenState(pnState);		if WindowInColor(myGetWindowFromPort(QDThePort)) then			begin				PenMode(37); {v4:  adMax constant, see IM V}				RGBForeColor(GrayScale(5, 2));				PenPat(QDBlack);				PaintRect(box);				RGBForeColor(blackRGB);			end		else			begin				PenMode(patBic);				PenPat(QDGray);				PaintRect(box);			end;		SetPenState(pnState);{$ENDC}	end;{--------------------------------------------------------------------------}	procedure SetDimDrawing;	begin		OpColor(GrayScale(4, 2));		PenMode(blend);{TextMode(TextOr);}	end;{--------------------------------------------------------------------------}	procedure UnDimDrawing;	begin		PenMode(srccopy);{TextMode(TextOr);}		OpColor(blackRGB);	end;{-----------------------------------------------------------------------------}	procedure GrayOutline (box: rect; mode: integer);{draws a QDGray box outline - used in LaserTree DLOG}		var			pnState: PenState;	begin		GetPenState(pnState);		PenMode(mode);		PenPat(QDGray);		FrameRect(box);		PenNormal;		SetPenState(pnState);	end;{-----------------------------------------------------------------------------}	procedure FRAMEShadowRECT (B: rect);  								{to make shadowed rect}	begin		PenSize(1, 1);		B.top := B.top + 1;		B.left := B.left + 1;		OffsetRect(B, -1, -1);		FRAMERECT(B);		moveto(B.left + 1, B.bottom);		Lineto(B.right, B.bottom);		LineTo(B.right, B.top + 1);	end;{-----------------------------------------------------------------------------}	procedure WriteB (B: RECT; str: str255);{writes str into box B; used in legends}		var			oldClip: RgnHandle;	begin		oldClip := NewRgn;		GetClip(OldClip);		ERASERECT(B);		FRAMERECT(B);		MOVETO(B.left + 3, B.top + 9);		ClipRect(B);		DrawString(str);		SetClip(OldClip);		ZapRegion(oldClip);	end;{-----------------------------------------------------------------------------}	procedure DrawGrowBox (whichwindow: WindowPtr);		var			box: rect;			dR: RgnHandle;	begin		dR := NewRgn;		GetClip(dR);		SetRect(box, 0, 0, 16, 16);		with WindowPortRect(whichwindow) do			OffSetRect(box, right - scrollwidth, bottom - scrollwidth);		ClipRect(box);		if (frontwindow = whichwindow) | (IsTreeWindow(whichwindow) and IsTreeWindow(frontwindow)) | (IsEditorWindow(whichwindow) and IsEditorWindow(frontwindow)) then			DrawGrowIcon(whichWindow)		else			begin				InsetRect(box, 1, 1);				EraseRect(box);			end;		SetClip(dR);		ZapRegion(dR);	end;{||||||||||||||||||||||||||||||||||   Cursors   |||||||||||||||||||||||||||||||||||}{===========================================}	procedure LoadCursor (var thecursor: cursor; cursID: integer);		var			CursorHdl: CursHandle;	begin		CursorHdl := GetCursor(cursID);		theCursor := CursorHdl^^;		ReleaseResource(Handle(CursorHdl));	end;{-----------------------------------------------------------------------------}	procedure DropCursor (theCursor: Cursor; left, top: integer; mode: integer);		var			box: rect;	begin		SetRect(box, left, top, left + 16, top + 16);		cursormap.baseAddr := @theCursor.mask;		CopyBits(cursormap, myGetPortBits(QDThePort), cursormap.bounds, box, srcBic, nil);		cursormap.baseAddr := @theCursor.data;		CopyBits(cursormap, myGetPortBits(QDThePort), cursormap.bounds, box, mode, nil);	end;{-----------------------------------------------------------------------------}	procedure DropCursorH (cursH: twocursors; left, top: integer; mode: integer);		var			dropcurs: cursor;	begin		if cursH.H = nil then  {v4: have it drop color cursor if available}			dropcurs := ArrowCursor		else			dropcurs := cursH.H^^;		DropCursor(dropcurs, left, top, mode);	end;{-----------------------------------------------------------------------------}	procedure DropCursorID (ID: integer; left, top: integer; mode: integer);		var			dropcurs: cursor;	begin		if ID = arrowID then			dropcurs := ArrowCursor		else			LoadCursor(dropcurs, ID);		DropCursor(dropcurs, left, top, mode);	end;{-----------------------------------------------------------------------------}	procedure DrawLock2 (originalBox: rect; doErase, drawLockifUnlocked,locked: boolean);		var			oldBack: RGBColor;			box: rect;	begin		box:= originalBox;		if doErase then			begin				InsetRect(box, 1, 1);				EraseRect(box);				InsetRect(box, -1, -1);			end;		with box do			if locked then				DropCursorID(161, left, top, srcor)  			else if drawLockifUnlocked then				DropCursorID(162, left, top, srcor); 	end;{-----------------------------------------------------------------------------}	procedure DrawLock (wh: point; doErase, drawLockifUnlocked,locked: boolean);		var			oldBack: RGBColor;			box: rect;	begin		SetRect(box,wh.h,wh.v,wh.h+lockBoxWidth,wh.v+lockBoxWidth);		if doErase then			begin				InsetRect(box, 1, 1);				EraseRect(box);				InsetRect(box, -1, -1);			end;		with box do			if locked then				DropCursorID(161, left, top, srcor)   			else if drawLockifUnlocked then				DropCursorID(162, left, top, srcor);  	end;{|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	procedure DefineTWClip;		var			dClip: RgnHandle;	begin		RectRgn(TWClip, visTWR);		dClip := NewRgn;		GetClip(dClip);		if TWScrolling then			SectRgn(TWClip, dClip, TWClip);		ZapRegion(dClip);	end;{-----------------------------------------------------------------------------}	procedure SetDataBoxesClip;{sets cliprect for drawing tree}	begin		if nex7on then			ClipRectOrient(treerect)		else			SetClip(TWClip);	end;{-----------------------------------------------------------------------------}	procedure SetUpRect;   {setting boxes}	begin		SETRECT(treenameB, 0, 0, WindowPortRect(tlegwindow).right, 13);		SETRECT(charnameB, 0, 0, WindowPortRect(chlegwindow).right, 13);		SETRECT(chlengthB, 0, 13, WindowPortRect(chlegwindow).right, 26);		SETRECT(chlegtypeB, 0, 25, WindowPortRect(chlegwindow).right, 37);		DefineTWClip;	end;{-----------------------------------------------------------------------------}	procedure ResetTop;	begin{    if topmargin = -1 then then just opened file topmargin := nattop - TWOrigin . v else}		topmargin := nattop + displace7 - TWOrigin.v;{topmargin is the vertical position of the top of the tree}	{that is, below the taxon name and taxon box}{nattop is the natural value of topmargin, before any scrolling or impact of databoxes}{displace7 is the adjustment to nattop caused by nex7on being expanded beyond typical position}{	- this is typically 0}{TWOrigin.v is the adjustment caused by scrolling}		if nex7on then			treerect.top := dataBoxB.bottom + 1		else			treerect.top := 0;	end;{-----------------------------------------------------------------------------}	procedure ResetRects;	begin		ResetTop;		SetUpRect;	end;{-----------------------------------------------------------------------------}	procedure ReCalcBoxes;{calculates some aspects of the databoxes}	begin{$IFC FLIPTREE}		if treeflipped then			begin				dataBoxB.bottom := databoxB.top + numboxes * n7LW + 4;				SetRect(claspRect, visTWR.Right - (dataBoxB.bottom + 1), 0, visTWR.Right - (dataBoxB.bottom - n7splitW), WindowPortRect(treeWindow).bottom);				dataBoxB.left := WindowPortRect(treeWindow).top;				dataBoxB.right := myGetControlRect(databoxScroll).top - 1;			end		else			begin				dataBoxB.bottom := databoxB.top + numboxes * n7LW + 4;				SetRect(claspRect, 0, dataBoxB.bottom - n7splitW, WindowPortRect(treeWindow).right, dataBoxB.bottom + 1);				dataBoxB.right := myGetControlRect(databoxScroll).left - 1;			end;{$ELSEC}		dataBoxB.bottom := databoxB.top + numboxes * n7LW + 4;		SetRect(claspRect, 0, dataBoxB.bottom - n7splitW, WindowPortRect(treeWindow).right, dataBoxB.bottom + 1);		dataBoxB.right := myGetControlRect(databoxScroll).left - 1;{$ENDC}		natnumboxes := numboxes;	end;{-----------------------------------------------------------------------------}	procedure ResetForNextTree;	begin		CalcEdw(ntscreen);		firsttx := firsttx - TWOrigin.h;{    nattop := nattop - TWOrigin.v;}		ResetRects;	end;{-----------------------------------------------------------------------------}{$IFC TINKERTOY}{-----------------------------------------------------------------------------}	function GetTinkerBox (N: Nptr): rect;		var			box: rect;	begin{$IFC SQUAREBRANCHES}		if squareBranches then			begin			end;{$ENDC}		setrect(box, 0, 0, tinkerWidth, tinkerWidth);		if N^.slant = slantRight then			OffSetRect(box, N^.loc.h - 2, N^.loc.v - edw div 2 - 1)		else if N^.slant = slantLeft then			OffSetRect(box, N^.loc.h, N^.loc.v - edw div 2 - 1);		if NodeIsTerminal(N) then			if N^.slant = slantRight then				OffSetRect(box, -1, edw div 2 - 1)			else if N^.slant = slantLeft then				OffSetRect(box, 1, edw div 2 - 1);		GetTinkerBox := box;	end;{$ENDC}end.