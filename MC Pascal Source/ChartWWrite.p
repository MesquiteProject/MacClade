unit ChartWWrite;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, BoxUtil, CharUtil, typeutil, ChartWText, WriteUtil, SymbolsNames, StrUtil, MenuUtil, TreeUtil, Count, TreeCycle, TaxonCHUtil, ChartWUtil;	procedure CheckWriteError;	procedure InitChartWriting;	procedure ChartWriteInteger (value: longint);	procedure ChartWriteReal (value: double; totdig, decdig: integer);	procedure ChartWriteChar (c: char);	procedure ChartWriteString (ds: str255);	procedure CheckWriteReal (value: double; decdig: integer);	procedure CheckWriteCalc (value: longint);	procedure WriteCalcHeadings (whichCycle: integer);	procedure ChartSummaryToText;	procedure ChartToText;	var		chartwritefile: text;		writeError: integer;{еееееееееееееееееееееее}implementation {е$S ChartWWrite}{-----------------------------------------------------------------------------}	procedure InitChartWriting;	begin		writeError := 0;		{IOCheck(false);}	end;{-----------------------------------------------------------------------------}	procedure CheckWriteError;		var			oldErrorFlag: boolean;	begin	{	writeError := IOResult;		oldErrorFlag := errorFlag;		currentIOPosition := 40;  		if not IOSuccessful(writeError) then			begin				errorFlag := oldErrorFlag;   				ChartCalcToText := false;				if not CWarning('The text file will no longer be written to disk.  Do you want to continue calculating the chart?', 'Continue', 'Cancel') then					begin						PleaseOffChart := true;						errorFlag := true;					end;			end;}	end;{-----------------------------------------------------------------------------}	procedure ChartWriteInteger (value: longint);	begin		if writeError = 0 then			begin				putSimpleLongint(value);				CheckWriteError;			end;	end;{-----------------------------------------------------------------------------}	procedure ChartWriteReal (value: double; totdig, decdig: integer);	var ds: str255;	begin		if writeError = 0 then			begin				RealToString(value, ds, 10000.0, decdig, WriteExpon);				putToken(ds);				CheckWriteError;			end;	end;{-----------------------------------------------------------------------------}	procedure ChartWriteChar (c: char);	begin		if writeError = 0 then			begin				putSingleChar( c);				CheckWriteError;			end;	end;{-----------------------------------------------------------------------------}	procedure ChartWriteString (ds: str255);	begin		if writeError = 0 then			begin				putToken(ds);				CheckWriteError;			end;	end;{-----------------------------------------------------------------------------}	procedure CheckWriteReal (value: double; decdig: integer);		var			ds: str255;	begin		if ChartCalcToText then			begin				if (CWChart = CWCSteps) and (CWStepsShow in [CWStepsCI, CWSTepsRC, CWStepsRI]) then					RealToString(value, ds, 10000.0, sigindices, WriteExpon)				else					RealToString(value, ds, 10000.0, decdig, WriteExpon);				ChartWriteString(ds);				ChartWriteChar(chr(9));			end;	end;{-----------------------------------------------------------------------------}	procedure CheckWriteCalc (value: longint);	begin		if ChartCalcToText then			begin				if (CWChart = CWCSteps) and (CWStepsShow in [CWStepsCI, CWStepsRI, CWSTepsRC]) then					ChartWriteReal(value / 100.0, 3, 2)				else					ChartWriteInteger(value);				ChartWriteChar(chr(9));			end;	end;{----------------------------------------------------------------------------}	function TreeSource: str255;		var			oldstate: SignedByte;			ds: str255;	begin		case CWTrees[CWChart] of			CWCurrentTree: 				ds := CurrentTreeStamp;			CWStoredTrees: 				begin					if treefile then						begin							LockHandle(treefilename, oldstate);							ds := concat(' trees in tree file ', treefilename^^, ' examined.');							ResetHandle(treefilename, oldstate);						end					else						ds := ' trees in data file examined.';					if not chartbeingcalculated then						ds := concat(StringFromNum(numcwtrees), ds);				end;			CWRandomTrees: 				begin					case RTKind of						RTpartition: 							ds := ' random partition trees';						RTjoining: 							ds := ' random joining trees';						RTequiprobable: 							ds := ' random equiprobable trees';						RTResolve: 							begin								if (treename^^ = UnStoredLink) or dirtytree then									ds := ' random resolutions of current tree'								else									begin										LockHandle(treename, oldstate);										ds := concat(' random resolutions of tree ', treename^^);										ResetHandle(treename, oldstate);									end;							end;						otherwise							;					end;					if not chartbeingcalculated then						ds := concat(StringFromNum(numcwtrees), ds);				end;			CWTreeFile: 				begin					LockHandle(extratreefilename[1], oldstate);					ds := concat(' trees in tree file ', extratreefilename[1]^^, ' examined.');					ResetHandle(extratreefilename[1], oldstate);					if not chartbeingcalculated then						ds := concat(StringFromNum(numcwtrees), ds);				end;			otherwise				;		end;		TreeSource := ds;	end;{-----------------------------------------------------------------------------}	procedure WriteCalcHeadings (whichCycle: integer);{writes headings of text files written during the chart calculations}		var			j, isfrom, isto, ic: integer;			oldState: SignedByte;{...............}		procedure WriteTreeHeading;		begin			ChartWriteString('TreeNumber');  {v3.02: added #}			ChartWriteChar(chr(9));			if CWTrees[CWChart] = CWStoredTrees then				begin					ChartWriteString('TreeName');					ChartWriteChar(chr(9));				end;			if (CWTrees[CWChart] = CWRandomTrees) and (RTkind <> RTResolve) then				begin					ChartWriteString('seed');					ChartWriteChar(chr(9));				end;		end;{...............}		procedure WriteRestrictions;			var				j, k: integer;		begin			ChartWriteString('Changes restricted to the following:');			ChartWriteChar(chr(13));			LockHandle(CWClassName, oldstate);			ChartWriteString(CWClassName^^);			ChartWriteChar(chr(13));			ResetHandle(CWClassName, oldstate);			for j := 0 to maxChangesState do				for k := 0 to maxChangesState do					if changesSel^[j, k] then						begin							ChartWriteString(concat(CharOfNum(j), '->', CharOfNum(k)));							ChartWriteChar(chr(13));						end;			ChartWriteChar(chr(13));		end;{...............}	begin		ChartWriteString(MacCladeStamp);		ChartWriteChar(chr(13));		ChartWriteString(UserStamp(true, true, false));		ChartWriteChar(chr(13));		ChartWriteString(TimeStamp);		ChartWriteChar(chr(13));		ChartWriteChar(chr(13));		ChartWriteString(DataFileStamp);		ChartWriteChar(chr(13));		ChartWriteChar(chr(13));		ChartWriteString(ChartTitle);		ChartWriteChar(chr(13));		ChartWriteChar(chr(13));		if (CWChart <> CWCC2T) and (CWChart <> CWCC2TF) then			begin				ChartWriteString('Tree source: ');				ChartWriteString(treeSource);				ChartWriteChar(chr(13));				ChartWriteChar(chr(13));			end;		case WhichCycle of			lengthCycle: 				begin					WriteTreeHeading;					ChartWriteString('length');				end;			tracedStepCycle: 				begin					if (CWStepsShow = CWStepsChanges) and changesRestricted then						WriteRestrictions;					WriteTreeHeading;					if CWStepsShow = CWStepsRC then						begin							ChartWriteString(StepsChartUnits(CWStepsCI, false));							ChartWriteChar(chr(9));							ChartWriteString(StepsChartUnits(CWStepsRI, false));							ChartWriteChar(chr(9));							ChartWriteString(StepsChartUnits(CWStepsRC, false));						end					else						ChartWriteString(StepsChartUnits(CWStepsShow, false));					if writeRootStates then						begin							ChartWriteChar(chr(9));							ChartWriteString('States at Roots');							ChartWriteChar(chr(13));						end;				end;			sequencecycle: 				begin					if (CWStepsShow = CWStepsChanges) and changesRestricted then						WriteRestrictions;					ChartWriteString(concat('One column per ', CharStateTerm(false, false, false), '; one row per tree'));					ChartWriteChar(chr(13));					ChartWriteChar(chr(13));					WriteTreeHeading;					if CWStepsShow = CWStepsChanges then						begin							for ic := 1 to numchars do								if charincluded(ic) then									begin										ChartWriteInteger(ic);										ChartWriteString('(min)');										ChartWriteChar(chr(9));										ChartWriteInteger(ic);										ChartWriteString('(max)');										ChartWriteChar(chr(9));									end						end					else						for ic := 1 to numchars do							if charincluded(ic) then								begin									ChartWriteInteger(ic);									ChartWriteChar(chr(9));								end;				end;			positioncycle: 				begin					if (CWStepsShow = CWStepsChanges) and changesRestricted then						WriteRestrictions;					ChartWriteString('One column per position; one row per tree');					ChartWriteChar(chr(13));					WriteTreeHeading;					if CWStepsShow = CWStepsChanges then						for j := 0 to 2 do							begin								ChartWriteInteger(j + 1);								ChartWriteString('(min)');								ChartWriteChar(chr(9));								ChartWriteInteger(j + 1);								ChartWriteString('(max)');								ChartWriteChar(chr(9));							end					else						for j := 0 to 2 do							begin								ChartWriteInteger(j + 1);								ChartWriteChar(chr(9));							end;				end;			changescycle: 				begin					if addPolychanges then						ChartWriteString('If polymorphic terminal taxa exist in tree, changes within them included in results.')					else						ChartWriteString('If polymorphic terminal taxa exist in tree, changes within them NOT included in results.');					ChartWriteChar(chr(13));					ChartWriteChar(chr(13));{$IFC FALSE}					if resolveoption = acctran then						ChartWriteString('ACCTRAN reconstructions')					else if resolveoption = deltran then						ChartWriteString('DELTRAN reconstructions');					ChartWriteChar(chr(13));{$ENDC}					if CWTrees[CWChart] = CWCurrentTree then   {v3.02}						begin							ChartWriteString('CharNumber');							ChartWriteChar(chr(9));						end					else						begin							WriteTreeHeading;							ChartWriteChar(chr(9));						end;					if (not CWTraced &  (CWTrees[CWChart] = CWCurrentTree) & (Chartchangesmode = minmaxmode)) then						begin							for isfrom := 0 to maxChangesState do								for isto := 0 to maxChangesState do									if (isto <> isfrom) or CWShowConstant then										begin											ChartWriteString(concat(CharOfNum(isfrom), '->', CharOfNum(isto), ' (min)'));											ChartWriteChar(chr(9));										end;							for isfrom := 0 to maxChangesState do								for isto := 0 to maxChangesState do									if (isto <> isfrom) or CWShowConstant then										begin											ChartWriteString(concat(CharOfNum(isfrom), '->', CharOfNum(isto), ' (max)'));											ChartWriteChar(chr(9));										end;						end					else						for isfrom := 0 to maxChangesState do							for isto := 0 to maxChangesState do								if (isto <> isfrom) or CWShowConstant then									begin										if Chartchangesmode = minmaxmode then											begin												ChartWriteString(concat(CharOfNum(isfrom), '->', CharOfNum(isto), ' (min)'));												ChartWriteChar(chr(9));												ChartWriteString(concat(CharOfNum(isfrom), '->', CharOfNum(isto), ' (max)'));												ChartWriteChar(chr(9));											end										else											begin												ChartWriteString(concat(CharOfNum(isfrom), '->', CharOfNum(isto)));												ChartWriteChar(chr(9));											end;									end;					if CWTrees[CWChart] <> CWCurrentTree then  {v3.02}						if nucleotides then							begin								if chartchangesmode = unambigmode then									begin										ChartWriteString('transition(min)');										ChartWriteChar(chr(9));										ChartWriteString('transversion(min)');										ChartWriteChar(chr(9));									end								else if chartchangesmode = minmaxmode then									begin										ChartWriteString('transition(min)');										ChartWriteChar(chr(9));										ChartWriteString('transition(max)');										ChartWriteChar(chr(9));										ChartWriteString('transversion(min)');										ChartWriteChar(chr(9));										ChartWriteString('transversion(max)');										ChartWriteChar(chr(9));									end								else									begin										ChartWriteString('transition(avg)');										ChartWriteChar(chr(9));										ChartWriteString('transversion(avg)');										ChartWriteChar(chr(9));									end;								if chartchangesmode = meanmode then									begin{ChartWriteString('(max transition)/(max tranversion)') else}										ChartWriteString('transition/tranversion');										ChartWriteChar(chr(9));									end;							end;				end;			otherwise				;		end;		ChartWriteChar(chr(13));		ChartWriteChar(chr(13));	end;{----------------------------------------------------------------------------}	procedure PutRestrictions;		var			j, k: integer;	begin		putTokenReturn('Only the following changes counted:');		for j := 0 to maxChangesState do			for k := 0 to maxChangesState do				if changesSel^[j, k] then					begin						puttoken(CharOfNum(j));						puttoken('->');						puttoken(CharOfNum(k));						putreturn;					end;		putreturn;	end;{----------------------------------------------------------------------------}	procedure PutChartMatrix (theCMkind: integer);{writes out one of the Matrix Kinds to file, specifically info about theCMKind matrix}		var			dodivide: BOOLEAN;			ds: str255;			divide: double;			rowtotal: longint;			j, isto, isfrom: integer;	begin		dodivide := MeanSpotBar(theCMKind) or InflatedChanges;		divide := ChangesDivide(theCMKind);		putreturn;		puttoken('numbers');		putreturn;		for isfrom := 0 to maxChartMatrixCat do			begin				for isto := 0 to maxChartMatrixCat do					if (isto = isfrom) & not CWShowConstant then						begin							putSingleChar('-');							putTab;						end					else						begin							if dodivide then								RealToString(1.0 * ChartMatrixData[theCMkind]^[isfrom][isto] / divide, ds, 1000, 3, writeexpon)							else								NumToString(ChartMatrixData[theCMkind]^[isfrom][isto], ds);							puttoken(ds);							putTab;						end;				putReturn;			end;		putreturn;		putTokenReturn('frequencies, whole matrix normed');		for isfrom := 0 to maxChartMatrixCat do			begin				for isto := 0 to maxChartMatrixCat do					if (isto = isfrom) & not CWShowConstant then						begin							putSingleChar('-');							putTab;						end					else						begin							if totalChartMatrix = 0 then								ds := '0.0'							else								RealToString(1.0 * ChartMatrixData[theCMkind]^[isfrom][isto] / totalChartMatrix, ds, 1000, 3, writeexpon);							puttoken(ds);							putTab;						end;				putReturn;			end;		putreturn;		putTokenReturn('frequencies, rows normed');		for isfrom := 0 to maxChartMatrixCat do			begin				for isto := 0 to maxChartMatrixCat do					if (isto = isfrom) & not CWShowConstant then						begin							putSingleChar('-');							putTab;						end					else						begin							rowtotal := 0;							for j := 0 to maxChartMatrixCat do								rowtotal := rowtotal + ChartMatrixData[theCMkind]^[isfrom][j];							if rowtotal = 0 then								ds := '0.0'							else								RealToString(1.0 * ChartMatrixData[theCMkind]^[isfrom][isto] / rowtotal, ds, 1000, 3, writeexpon);							puttoken(ds);							putTab;						end;				putReturn;			end;	end;{-----------------------------------------------------------------------------}	procedure LinearColumnTitles (numtoshow: integer; settoCalc: set15);{used for saving chart as text}		var			m: integer;			oldstate1, oldstate2: SignedByte;			ds: str255;{.........}		procedure putCatTitle;		begin			putreturn;			puttoken(CategoryTitle);{$IFC FALSE}			if (catwid > 1) or CIRICategory then				begin					putToken(' range');					putReturn;					putToken('min');					putTab;					putToken('max');				end;{$ENDC}		end;{.........}	begin		putreturn;		case CWChart of			CWCSteps: 				begin					if (sequencechart or positionchart) and (numtoshow > 1) then						begin							putTokenReturn('Columns:');							for m := 1 to numtoshow do								begin									putSingleChar(chr(ord('A') - 1 + m));									putSingleChar(':');									puttab;									putTokenReturn(SpotBarName(GetSpotBarKind(settoCalc, m), true));								end;							putCatTitle;							for m := 1 to numtoshow do								begin									putTab;									putSingleChar(chr(ord('A') - 1 + m));								end;						end					else						begin							putCatTitle;							puttab;							if (sequencechart or positionchart) then								putToken(StepsChartUnits(CWStepsShow, true))							else if CWTraced then								putToken('#Trees')							else								putToken('#Characters');						end;				end;			CWCStates: 				begin					putCatTitle;					puttab;					putToken('Frequency');				end;			CWCCTAll: 				begin					putCatTitle;					puttab;					putToken('#Trees');				end;			CWCC2T: 				begin					putToken('Positive numbers indicate number of steps by which ');					putToken(LinkNameFromChain(treechain, twotrees[1]));					putToken(' is shorter than ');					putTokenReturn(LinkNameFromChain(treechain, twotrees[0]));					putToken('Negative numbers indicate number of steps by which ');					putToken(LinkNameFromChain(treechain, twotrees[0]));					putToken(' is shorter than ');					putTokenReturn(LinkNameFromChain(treechain, twotrees[1]));					putCatTitle;					puttab;					putToken('Minimum Difference');				end;			CWCC2TF: 				begin					LockHandle(extratreefilename[1], oldstate1);					LockHandle(extratreefilename[2], oldstate2);					putToken('Positive numbers indicate number of steps by which all trees in ');					putToken(extratreefilename[2]^^);					putToken(' are shorter than all trees in ');					putTokenReturn(extratreefilename[1]^^);					putToken('Negative numbers indicate number of steps by which all trees in ');					putToken(extratreefilename[1]^^);					putToken(' are shorter than all trees in ');					putTokenReturn(extratreefilename[2]^^);					ResetHandle(extratreefilename[1], oldstate1);					ResetHandle(extratreefilename[2], oldstate2);					putcatTitle;					puttab;					putToken('Minimum Difference');				end;{$IFC PROBSTEPCHART}			CWCProbSteps: 				begin					putTokenReturn('For binary character, with probability of changes being');					putToken('0->0: ');					RealToString(probchangeRec[0, 0], ds, 10, 4, false);					putTokenReturn(ds);					putToken('0->1: ');					RealToString(probchangeRec[0, 1], ds, 10, 4, false);					putTokenReturn(ds);					putToken('1->0: ');					RealToString(probchangeRec[1, 0], ds, 10, 4, false);					putTokenReturn(ds);					putToken('1->1: ');					RealToString(probchangeRec[1, 1], ds, 10, 4, false);					putTokenReturn(ds);					putTokenReturn('');					putTokenReturn('');					putToken('Steps');					puttab;					putToken('Probability');				end;{$ENDC}			otherwise				;		end;		putreturn;	end;{----------------------------------------------------------------------------}	procedure ChartSummaryToText;		var			box: rect;			numlines: integer;	begin		SetRect(box, 0, 0, 0, 0);		putToken('Chart: ');		putTokenReturn(ChartTitle);		putReturn;		putToken('Tree source: ');		putTokenReturn(treeSource);		if polytomiesWereBlasted then			begin				putReturn;				putTokenReturn('Polytomies were arbitrarily resolved in some trees.');			end;		putReturn;		putTokenReturn('Summary information from chart:');		putReturn;		DrawChartText(box);	end;{----------------------------------------------------------------------------}	procedure ChartToText;{writes the chart in the current chart window to a file, when Save Chart To Text is chosen}		var			realvalue: double;			rowtotal: longint;			j, isto, isfrom, k, theKind, numtoshow: integer;			settoCalc: set15;			oldState: SignedByte;	begin{note that file stamped with version number, etc., before this procedure called}		putTokenReturn(ChartTitle);		putReturn;		if (CWChart <> CWCC2T) and (CWChart <> CWCC2TF) then			begin				putToken('Tree source: ');				putTokenReturn(treeSource);			end;		if polytomiesWereBlasted then			begin				putReturn;				putTokenReturn('Polytomies were arbitrarily resolved in some trees.');			end;		settocalc := SpotBarSetToCalc;		numtoshow := NumSpotBar(settoCalc);{======= Linear Charts ========}		if CWLinear then			begin				putreturn;				if (CWChart = CWCSteps) and (CWStepsShow = CWStepsChanges) and changesRestricted then					begin						putToken('Changes restricted to the following class: ');						LockHandle(CWClassName, oldstate);						putTokenReturn(CWClassName^^);						ResetHandle(CWClassName, oldstate);						putRestrictions;					end;				LinearColumnTitles(numtoshow, settocalc);				for j := 0 to numIntervals[CLkind] - 1 do					begin						if CIRICategory then							Puttoken(CategoryString(j, 4, true, true))						else							Puttoken(CategoryString(j, 0, true, true));						for k := 1 to numtoshow do							begin								putTab;								if not IntervalLegal(j) then									putSingleChar('-')								else									begin										theKind := GetSpotBarKind(settoCalc, k);										puttoken(CLDataString(theKind, j, false));									end;							end;						putreturn;					end;				putreturn;			end{======= matrix Charts ========}		else			begin				if addPolychanges then					putTokenReturn('If polymorphic terminal taxa exist in tree, changes within them included in results.')				else					putTokenReturn('If polymorphic terminal taxa exist in tree, changes within them NOT included in results.');				putreturn;				puttoken('Format of following matrices:');				putreturn;				putTab;				putTab;				puttoken('To:');				putreturn;				putTab;				putTab;				for isfrom := 0 to maxChartMatrixCat do					begin						putTab;						putSingleChar(CharOfNum(isfrom));					end;				putreturn;				puttoken('From:');				for isfrom := 0 to maxChartMatrixCat do					begin						putTab;						putTab;						putSingleChar(CharOfNum(isfrom));						putTab;						for isto := 0 to maxChartMatrixCat do							begin								if (isto = isfrom) & not CWShowConstant then									putSingleChar('-')								else									putSingleChar('.');								putTab;							end;						putReturn;					end;				for k := 1 to numtoshow do					begin						putReturn;						putReturn;						putTab;						theKind := GetSpotBarKind(settoCalc, k);						puttoken(SpotBarName(theKind, false));						PutChartMatrix(theKind);					end;			end;	end;end.