unit Legends;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, 		GenUtil, StrUtil, BoxUtil, ToolPalette, TaxonCHUtil, SymbolsNames, Footnote, CharUtil, TreeUtil, TypeUtil, Prohibitions, MenuUtil,		CharPartitions;	procedure SetMaxGrayScale;	procedure SetLockLegPts (legwindow: WindowPtr; height: integer);	procedure SizeTWMessWindow;	procedure WriteTWMessageB;	procedure DrawTWMessWindow;	procedure ShowMemory;	function LegendBox (b: rect; ds: str255): rect;	procedure WriteTitleBar (bx: rect; ds: str255; dogray, withgoaway: boolean); {NOT USED OUTSIDE THIS UNIT}	procedure WriteLegendTitles;	procedure DrawLegNumber (thescroll: ControlRef);	function TlegString (valueR: double; valueL: longint; addasterisk: boolean; valuename: str255; tlegNum: integer): str255;	procedure SizeTreeLeg (erase: boolean);	procedure DrawTreeLeg;	procedure DrawBranchLength (N: Nptr);	procedure DrawAsterisksEtc (states: largestsetchars; ic: integer; flashchar: char);	procedure EraseAsterisksEtc;	function LegendTickClassBox(tickClass,legBoxShift,endBox: integer): rect;	function CalcLegendStates (ic: integer): LargestSetChars;	function NumberLegendStates (ic: integer): longint;	procedure ShowChLegIfHidden;	procedure CalcNumChLegBoxes (var boxestoshow: integer; numstates: integer);	procedure CalcChLegRects (legBoxShift: integer);	procedure DrawCHLegBoxes (legBoxShift: integer);	procedure DrawchLeg;	procedure BrSelectLegs (N: Nptr);	procedure DrawFancyTick(r: rect;pat: pattern; tickClass:integer);{$IFC SCALEWINDOW}	procedure SizeScaleWindow;	procedure DrawScaleWindow;{$ENDC}{еееееееееееееееееееееее}implementation {е$S Legends}	const		numTickClasses = 7;	var		uncertB: rect;{$IFC NOT USETRACEMODE}		this := means * nothing;{this is here to generate an error, to remind us that in most place traceshown is implemented}{not using compiler directives but rather with direct substitution ("if traceon" becoming "if traceshown=tracediscrete")}{because otherwise would be too twisted} {$ENDC}{-----------------------------------------------------------------------------}	procedure SetMaxGrayScale;	begin		GrayScaleStates := CalcLegendStates(i);	end;{-----------------------------------------------------------------------------}	procedure SetLockLegPts (legwindow: WindowPtr; height: integer);{for each of the legend windows (toolPaletteWindow[treeTools], twmesswindow, tlegwindow, chlegwindow),}{there is a standard position of the topleft corner of the window, }{(for all but the toolPaletteWindow[treeTools], this is the position the window will take if locked to the tree window}{this procedure calculates the values of the global variable points recording that position}		var			tempP: WindowPtr;			useheight: integer;	begin		genericGetPort(tempP);		if height = -1 then    {pass -1 to indicate legend height = current window height}			useheight := WindowPortRect(legWindow).bottom - WindowPortRect(legWindow).top		else			useheight := height;		if legwindow<> toolPaletteWindow[editorTools] then			begin				genericSetPort(treewindow);				if legwindow = tlegwindow then					begin		{$IFC FLIPTREE}						if treeflipped then							begin								tlegpt.h := visTWR.left + 120;								tlegpt.v := visTWR.top + 20;							end						else		{$ENDC}							begin								tlegpt.h := visTWR.right - 184;  {was 200}								tlegpt.v := visTWR.bottom - useheight + twmessW;							end;						LocalToGlobal(tlegpt);					end				else if legwindow = chlegwindow then					begin		{$IFC FLIPTREE}						if treeflipped then							begin								chlegpt.h := visTWR.left + 15;								chlegpt.v := visTWR.top + 20;							end						else		{$ENDC}							begin								if traceshown = tracediscrete then									chlegpt.h := visTWR.right - 86								else									chlegpt.h := visTWR.right - 88;								chlegpt.v := visTWR.bottom - useheight + twmessW;							end;						LocalToGlobal(chlegpt);					end				else if legwindow = twmesswindow then					begin						messspot.h := 0;						messspot.v := visTWR.bottom - useheight;						LocalToGlobal(messspot);					end				else if legwindow = toolPaletteWindow[treeTools] then					begin						toolPalettePoint[treeTools].h := visTWR.left + 3;						toolPalettePoint[treeTools].v := visTWR.bottom - useheight - 16;						LocalToGlobal(toolPalettePoint[treeTools]);					end;			end		else 			begin				genericSetPort(editorWindow);				toolPalettePoint[editorTools].h := editorRowNameStart+8;				toolPalettePoint[editorTools].v := editorBoundaryRect.bottom - useheight - 8;				LocalToGlobal(toolPalettePoint[editorTools]);			end;		genericSetPort(tempP);	end;{|||||||||||||||||||||||||||||||||||||||||||||||||||||  TWMessageWindow  ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	procedure SizeTWMessWindow;{resized twmesswindow according to currently shown icons}		const			width = 14;		var			j, lastend, oldend: integer;	begin		oldend := WindowPortRect(twMessWindow).right;		lastend := twmesswidth + 1;		for j := 0 to maxTWmessIcons do			with TWMessIcon[j] do				begin					left := lastend;					if show then						right := left + width					else						right := left;					lastend := right;				end;		SizeWindow(twmesswindow, lastend, width, false);{    if oldend <> WindowPortRect(twMessWindow).right then  dontCancelUpdate := true;}	end;{-----------------------------------------------------------------------------}	procedure WriteTWMessageB;{writes message stored in the global string twmessage into twmesswindow}		var			B: rect;			oldstate: penstate;			tport: windowptr;	begin		genericGetPort(tport);		genericSetPort(TWmessWindow);		getpenstate(oldstate);		TextFont(maccladesmall);		penNormal;		InsetRect(TWMessageB, -1, -1);		Framerect(TWMessageB);		InsetRect(TWMessageB, 1, 1);		B := TWMessageB;		Insetrect(B, 1, 1);		Offsetrect(B, 0, 1);		ClipRect(B);		eraserect(B);		TETextBox(Pointer(ord4(@TWmessage) + 1), length(TWmessage), B, teJustCenter);		Setpenstate(oldstate);		TextFont(TWFont);		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	procedure DrawTWMessWindow;		var			curcurs, j: integer;			tport: windowptr;			box: rect;	begin		genericGetPort(tport);		genericSetPort(twmesswindow);		TWMessIcon[TWmessFix].show := ((traceshown = tracediscrete) and fixon);		TWMessIcon[TWmessExpd].show := expd;		TWMessIcon[TWmessRoot].show := anydirected;		TWMessIcon[TWmessTaxExc].show := (numtaxain <> numtaxa);		TWMessIcon[TWmessCharExc].show := (numcharin <> numchars);		TWMessIcon[TWmessEquiv].show := (traceshown = tracediscrete) & (resolveoption <> allpossible);		TWMessIcon[TWmessPolyT].show := nullson;		SizeTWmessWindow;		WriteTWMessageB;		ClipRect(WindowPortRect(twMessWindow));		for j := 0 to maxTWmessIcons do			begin				curcurs := 0;				if ((j = TWmessEquiv) and (resolveoption = acctran)) or ((j = TWmessPolyT) and (polyreal)) then					curcurs := 1;				with TWMessIcon[j] do					if show then						begin							setrect(box, left, 0, right, 14);							Eraserect(box);							InsetRect(box, -1, -1);							Framerect(box);							DropCursorID(cursid[curcurs], left + 1, 1, srccopy);						end;			end;		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	procedure ShowMemory;{writes memory available into twmesswindow}	begin{$IFC DEVELOPMENT}		TWMessage := concat('Memory left: ', StringFromNum(myFreeMem), ' b');{$ELSEC}		if isMacOSX then			TWMessage := concat('(Memory not calculated)')		else			TWMessage := concat('Memory left: ', StringFromNum(myFreeMem div 1024), 'K');{$ENDC}		WriteTWMessageB;	end;{||||||||||||||||||||||||||||||||||||||||||||||||||||||||  TreeLegend and character Legend |||||||||||||||||||||||||||||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	procedure DrawLegNumber (theScroll: ControlRef);{draws the number of the current tree or character near the scroll bar in chleg or tleg}		var			box: rect;			ds: str255;			theValue: longint;	begin		Box := myGetControlRect(thescroll);		Box.left := Box.right;		if theScroll = chlegScroll then			Box.right := WindowPortRect(chlegwindow).right		else			Box.right := WindowPortRect(tlegwindow).right;		InsetRect(Box, 1, 1);		Eraserect(Box);		theValue := GetControlValueLong(theScroll);		NumToString(theValue, ds);		if (theValue >= 1000) & (StringWidth(ds) > box.right - box.left) then			ds := concat(StringFromNum(RoundValue(theValue / 1000.0)), 'K');		TETextBox(Pointer(ord4(@ds) + 1), length(ds), Box, teJustCenter);	end;{-----------------------------------------------------------------------------}	function LegendBox (b: rect; ds: str255): rect;		var			box: rect;	begin		SetRect(box, B.left + ((B.right - B.left) - StringWidth(ds)) div 2 - 2, -8, 0, 2);		Box.right := Box.left + Stringwidth(ds) + 4;		if Box.left < B.left then  {if too long to center, then left-justified}			Box.left := B.left;		LegendBox := box;	end;{-----------------------------------------------------------------------------}	procedure CenterInBox (b: rect; height: integer; ds: str255);{draws ds into the rectangle B}		var			box: rect;			oldClip: RgnHandle;	begin		if ds <> ';' then   {ds = ';' is the signal to do nothing}			begin				oldClip := NewRgn;				GetClip(OldClip);				ClipRect(B);{note: if change dimensions of this then need to change in mouseintree}				box := LegendBox(b, ds);				OffSetRect(box, 0, height);				eraserect(box);				MOVETO(Box.left + 2, height);				if ds <> ',' then   {ds = ',' is the signal to erase box but draw nothing}					DrawString(ds);   {v4: use TETextBox}				SetClip(OldClip);				ZapRegion(oldClip);			end;	end;{-----------------------------------------------------------------------------}	procedure WriteTitleBar (bx: rect; ds: str255; dogray, withgoaway: boolean);{writes title bars of the chlegend and tleg}		var			j: integer;			box: rect;	begin		if not isforeground | not IsTreeWindow(frontwindow) then			EraseRect(bx);		if legendTitleIsWindowTitle then			begin				if withgoaway then					begin						SetRect(box, 2, 3, 9, 10);						FrameRect(box);						bx.left := bx.left + 11;					end;				if dogray then					PenPat(QDGray);				if isforeground & IsTreeWindow(frontwindow) then					for j := 0 to 3 do						begin							moveto(bx.left, bx.top + 3 + 2 * j);							if locklegends then								lineto(bx.right - 9, bx.top + 3 + 2 * j)							else								lineto(bx.right - 1, bx.top + 3 + 2 * j);						end;				PenPat(QDBlack);			end;		if locklegends then			DropCursorID(6000, bx.right - 8, 1, srcor);		InsetRect(bx, 5, 0);		CenterInBox(bx, bx.top + 10, ds);	end;{-----------------------------------------------------------------------------}	procedure WriteTraceChLegTitle;		var			ds: str255;	begin		ds := AvailCharName(i);		if not printon & footpictpresent(0, i) then			ds := concat(ds, footPictFlag);		if not printon & footpresent(0, i) then			ds := concat(ds, footTextFlag);		WriteTitleBar(charnameB, ds, true, true);	end;{-----------------------------------------------------------------------------}	procedure WriteLegendTitles;		var			tport: windowptr;	begin		genericGetPort(tport);		genericSetPort(tlegwindow);		ClipRect(WindowPortRect(tlegwindow));		HLock(Handle(treename));		if not dirtytree and (treename^^ <> UnstoredLink) then			WriteTitleBar(treenameB, treename^^, not treefile, false)		else			WriteTitleBar(treenameB, '(unstored)', not treefile, false);		HUnLock(Handle(treename));						genericSetPort(chlegwindow);		ClipRect(WindowPortRect(chlegwindow));		if traceshown = tracediscrete then			WriteTraceChLegTitle		else if traceshown = traceallchanges then			WriteTitleBar(charnameB, ';', true, true)		else if traceshown = tracecontinuous then			WriteTitleBar(charnameB, concat('Continuous ', stringfromnum(icont)), true, true);{$IFC PROBRECONSTRUCT}		else if traceshown = traceProbability then			WriteTitleBar(charnameB, 'Probability', true, true); {$ENDC}		if toolPaletteOpen[treeTools] & useOldFloatingWindows then			DrawPaletteTitleBar(treeTools);		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	procedure SizeTreeLeg (erase: boolean);{resized tlegwindow}		var			j: INTEGER;			tport: windowPtr;			tleglines, tlegheight, namewidth: integer;	begin		genericGetPort(tport);		tleglines := 0;		tlegStats[tlegTreeLength].show := count;		tlegStats[tlegChg].show := count and calctreechanges;		tlegStats[tlegCI].show := count and calcCI;		tlegStats[tlegRI].show := count and calcRI;		tlegStats[tlegRC].show := count and calcRC;		tlegStats[tlegMin].show := showMinSteps;		tlegStats[tlegMax].show := showMaxSteps;		for j := 0 to maxtlegstats do			if tlegStats[j].show then				begin					tlegStats[j].linesabove := tleglines;					tleglines := tleglines + tlegStats[j].lines;				end;		tlegheight := treenameB.bottom + tleglines * tlegline + scrollwidth;		genericSetPort(treewindow);		TextFont(TWFont);		TextSize(TWFontSize);		if locklegends then			namewidth := standtlegW		else			begin				namewidth := StringWidth('Treelength: ');				textface([bold]);				nameWidth := namewidth + StringWidth(LengthString(treelength, true)) + CharWidth('+');				textface([]);				if namewidth < standtlegW then					namewidth := standtlegW;			end;		SizeWindow(tlegwindow, namewidth, tlegheight, false);		SetLockLegPts(tlegwindow, -1);		if locklegends then			MoveWindow(tlegwindow, tlegpt.h, tlegpt.v, false);		genericSetPort(tlegwindow);		if erase then			EraseRect(WindowPortRect(tlegwindow));		myValidRect(tlegWindow,WindowPortRect(tlegWindow));		Movecontrol(tlegscroll, 0, WindowPortRect(tlegwindow).bottom - scrollwidth);		SetUpRect;		genericSetPort(treewindow);		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}{ (Do not erase this note.)  The following is a summary of the status of warnings/etc. indicated when there are problems}{in calculations.  I have strengthened the +/-/* system in the tree legend but not by much.  Note that for}{all problems except the underestimate of treelength in soft polytomies, a NewError is posted.  There are some problems}{with building a complete +/-/* system which stores and indicates all problems encountered, namely:}{1. Do we indicate +/-/* for the treelength only?  In the character legend for a tracing? In the Character status window}{for every steps listed for each character?  In trace all changes legend for branchlength?  The treelength is not important}{enough, I don't think, to warrant such special work (see next comment) unless complete system is built}{2.  For some of these calculation problems, such as poly3trouble and soft polytomies, it is easy to check for them}{when the legend is built.  For one, FixAnc taxon being polymorphic, I have built a global boolean that is updated when}{ancon is, and it is relatively easy to keep updated.  For other problems, the calculation problems can only}{easily be discovered during the course of the calculations.  Here the problem is distinguishing between calculations done}{on the current tree versus chart trees, calculations done on the current tree for tracing versus chart versus treelength.}{Depending on the context, the +/-/* would be placed in a different legend.  One could scan for posted NewErrors,}{but you could be finding a NewError, posted in an earlier calculation, that has not yet been used up by display to user.}{As things stand, In calculations such as CountTree I don't know who or why is calling for them, and I don't want}{to try to find out.   Things could be arranged, the best system probably being having every calculation procedure}{be a boolean function returning an error message, like OSerrors.}{}{As it stands I would rather let NewErrors warn the user for the rarer problems, and only give +/-/* in the}{tree legend for some of the more prominent problems}{This is the current +/-/* system}{+ to Treelength added if :}{е Poly3trouble: NewError 25. Polymorphic taxon of more than 2 states in user-defined type character.  Trace may be incorrect; count will be.}{е tree has soft polytomies}{* to Treelength added if :}{е FixAncPolymorph:  NewError 90. Taxon made ancestral is polymorphic in some chars.  Tracing and number of steps may be incorrect!}{* to CI/RI/RC added if :}{е CI/RI/RC excludes characters of fisher, Dollo and user defined types. (NewError 83)}{* to RI/RC added if :}{е RI/RC excludes characters of irreversible, fisher, Dollo and user defined types. (newError 84)}{Other calculation problems which could deserve +/-/* in treelegend or character legend or chart}{but no systems built to handle them (listed by their newError messages)}{14. Infinite tree length; user-defined type may be misdefined!}{16. Infinite length required in polymorphic terminal taxon! Type may be misdefined!}{19. Too many multi-state taxa for unordered character; CI, RI or RC may be miscalculated!}{20. Irreversibility of character violated by fixing ancestral states or fixing taxon as ancestor!}{26. Transformation type definition violates the triangle inequality.  Proceed at your own risk.}{30. Stratigraphic character has ancestor and descendant in same stratum.}{31.Taxon with multiple states in Dollo character fixed as ancestor;trace and countmay be incorrect . }{54. Infinite branch length found.}{64.	Warning!  Routines to handle this case not yet implemented.}{94. Too many nodes in polytomy for unordered character.  Character evolution will be reconstructed incorrectly.}{110. Treelength overflow; avoid using decimal weights and types.}{Calculation problems in restricted to charts only}{92. Changes within terminal taxa polymorphic for 3 or more states in user-defined character not included within chart.}{50. Some unambiguous changes within terminal polymorphisms may not have been counted in chart.}{-----------------------------------------------------------------------------}	function TlegString (valueR: double; valueL: longint; addasterisk: boolean; valuename: str255; tlegNum: integer): str255;		var			ds: str255;	begin		if tlegnum in [tlegCI, tlegRI, tlegRC] then			RealToString(valueR, ds, 10.0, sigindices, true)		else			ds := LengthString(valueL, true);		ds := concat(valuename, ds);		if addasterisk then			ds := concat(ds, '*');		tlegString := ds;	end;{-----------------------------------------------------------------------------}	procedure DrawTreeLeg;	 {draws tree legend boxes, to left}		var			ic: INTEGER;			polyplus: boolean;			OldRgn: RgnHandle;			ds: str255;			box: rect;			tport: windowPtr;{...........}		procedure WriteTlegString (ds: str255; tlegNum: integer);		begin			SetRect(box, 0, treenameB.bottom + tlegStats[tlegNum].linesabove * tlegline, WindowPortRect(tlegwindow).right, treenameB.bottom + tlegStats[tlegNum].linesabove * tlegline + tlegline * tlegStats[tlegNum].lines);			InsetRect(box, -1, 0);			CenterInBox(box, treenameB.bottom + tlegStats[tlegNum].linesabove * tlegline + 9, ds);		end;{...........}	begin		genericGetPort(tport);		OldRgn := NewRgn;		GetClip(oldRgn);{==== preparing legend box  ====}{    myShowWindow(tlegWindow);}		genericSetPort(tlegwindow);		SizeTreeLeg(true);		TextFont(TWFont);		TextSize(TWFontSize);		ClipRect(WindowPortRect(tlegwindow));{====Tree Name ====}		HLock(Handle(treename));		if not dirtytree and (treename^^ <> UnstoredLink) then			WriteTitleBar(treenameB, treename^^, not treefile, false)		else			WriteTitleBar(treenameB, '(unstored)', not treefile, false);		HUnLock(Handle(treename));{==== Tree length  ====}		if count then			begin				if tlegStats[tlegTreeLength].show then					begin						SetRect(box, -1, treenameB.bottom + tlegStats[tlegTreeLength].linesabove * tlegline, WindowPortRect(tlegwindow).right + 1, treenameB.bottom + tlegStats[tlegTreeLength].linesabove * tlegline + tlegline * tlegStats[tlegTreeLength].lines);						WriteB(box, 'Treelength: ');						textface([bold]);						if treelength < 0 then							Drawchar('░')						else							DrawString(LengthString(treelength, true));						textface([]);						if TreeLengthPlus then							DrawChar('+');						if TreeLengthMinus then  {v4: this is not yet effective}							DrawChar('-');						if FixancPolymorph then							DrawChar('*');					end;			end;{==== Other Calcs. ====}		if tlegStats[tlegCI].show or tlegStats[tlegMin].show or tlegStats[tlegRI].show or tlegStats[tlegRC].show or tlegStats[tlegMax].show then			begin  {NOW:}				if MinMaxLenLegal(false, minlength) then					begin						if tlegStats[tlegCI].show then							WriteTlegString(TlegString(ci, 0, AnyType([usedef, dollo, fisher]), ' CI: ', tlegCI), tlegCI);						if MinMaxLenLegal(false, maxlength) then							begin								if tlegStats[tlegRI].show then									WriteTlegString(TlegString(ri, 0, AnyType([usedef, dollo, fisher, irreversible]), ' RI: ', tlegRI), tlegRI);								if tlegStats[tlegRC].show then									WriteTlegString(TlegString(ci * ri, 0, AnyType([usedef, dollo, fisher, irreversible]), ' RC: ', tlegRC), tlegRC);							end						else if tlegStats[tlegRI].show or tlegStats[tlegRC].show or tlegStats[tlegMax].show then  {NOW:}							if MinMaxLenLegal(true, maxlength) then								;						if tlegStats[tlegMin].show then							WriteTlegString(TlegString(0, mintreelength, AnyType([usedef, dollo, fisher]), ' ╖ Min: ', tlegMin), tlegMin);						if tlegStats[tlegMax].show & MinMaxLenLegal(false, maxlength) then							WriteTlegString(TlegString(0, maxtreelength, AnyType([usedef, dollo, fisher, irreversible]), ' ╖ Max: ', tlegMax), tlegMax);					end				else{NOW:}					if MinMaxLenLegal(true, minlength) then  {reporting problem and turning off calculations}						;			end;  {NOW:}		if tlegStats[tlegchg].show then			begin				ds := StringFromnum(treechangesMIN);				if treechangesMIN = treechangesMAX then					ds := concat(ds, ' changes')				else					ds := concat(ds, '-', StringFromnum(treechangesMAX), ' changes');				if TerminalPolymorphisms then					ds := concat(ds, '*');				WriteTlegString(ds, tlegChg);			end;{==== number of taxa and characters ====}		if tlegStats[tlegTaxChar].show then			begin				SetRect(box, 0, treenameB.bottom + tlegStats[tlegTAXCHAR].linesabove * tlegline, WindowPortRect(tlegwindow).right, treenameB.bottom + tlegStats[tlegTAXCHAR].linesabove * tlegline + tlegline * tlegStats[tlegTAXCHAR].lines);				InsetRect(box, -1, 0);				FrameRect(box);				Numtostring(numtaxain, ds);				if numtaxa <> numtaxain then					ds := (concat(ds, ' Taxa in tree'))				else					ds := (concat(ds, ' Taxa'));				CenterInBox(box, box.top + 9, ds);				numtostring(numcharin, ds);				if numchars <> numcharin then					ds := (concat(ds, ' Chars included'))				else					ds := (concat(ds, ' Chars.'));				CenterInBox(box, box.top + 20, ds);			end;{==== scrolls and stuff ====}		genericSetPort(tlegwindow);		ClipRect(WindowPortRect(tlegwindow));{if (linknumber[treechain] < StartUserLink(treechain)) or (UserLinks[treechain] < 1) then}		SetControlMaximumLong(tlegScroll, UserLinks[treechain]);		if dirtytree or (linknumber[treechain] < StartUserLink(treechain)) then			begin				SetControlMinimumLong(tlegScroll, 0);				SetControlValueLong(tlegScroll, 0);			end		else			begin				SetControlMinimumLong(tlegScroll, 1);				SetControlValueLong(tlegScroll, linknumber[treechain] - StartUserLink(treechain) + 1);			end;		if (UserLinks[treechain] = 0) then			DoDeactivateControl(tlegScroll)		else			begin				if equivcycle or not IsTreeWindow(frontwindow) or not isforeground then					DoDeactivateControl(tlegScroll)				else					DoActivateControl(tlegScroll);				DrawLegNumber(tlegscroll);			end;		DrawControls(tlegwindow);		myValidRect(tlegwindow,WindowPortRect(tlegwindow));{=========== menu updating stuff =================}		if not noundo then			FixTreeUndoItem;		genericSetPort(tport);		SetClip(oldRgn);		ZapRegion(oldRgn);	end;{||||||||||||||||||||||||||| chLeg |||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	procedure ShowChLegIfHidden;	begin		if not WindowVisible(chlegwindow) then			begin				StoreFrontWindows;				myShowWindow(chlegWindow);				if MacCladeWindow(frontwindow) then					begin						SelectWindow(chlegwindow);						if BranchListon then							SelectWindow(BranchListwindow);						RestoreFrontWindows;					end;			end;	end;{-----------------------------------------------------------------------------}	procedure DrawBranchLength (N: Nptr);		var			dms: str255;	begin		if BranchExists(N) then			begin				if (PartofPolytomy(N) and not polyreal) then					Drawstring('Not Calculated')   {3.02: }				else if N = R then					Drawstring('Root: no changes')				else					begin						Drawstring(LengthString(N^.length1, branchlengthsWeighted));{$IFC MINMAXIN}						if BranchListmode = minmaxmode then							begin								if N^.length2 <> N^.length1 then									begin										Drawchar('-');										RealToString(N^.lengthmean, dms, 1000, 4, true);										DrawString(dms);										Drawchar('-');										Drawstring(LengthString(N^.length2, branchlengthsWeighted));									end;							end;{$ENDC}					end;			end;	end;{-----------------------------------------------------------------------------}	procedure DrawAsterisksEtc (states: largestsetchars; ic: integer; flashchar: char);{Draws * ? etc. in chleg beside state boxes}		var			useset: largestsetchars;			ir: integer;	begin		EraseAsterisksEtc;		states := states - [ucL, MSl,GAl];  {Wayne: v3.5: I added GAl to this.  Why was it not here before?}		useset := states * legendstates;		if useset <> states then  {there are states in requested set which are outside of legendstates; complain}			NewError(11, 0);		if cardlg(useset) > 0 then			for ir := 0 to CharMaxstDISPLAY(ic) do				if ir in useset then					begin						MOVETO(strect[ir + 1].right + 1, strect[ir + 1].bottom);						Drawchar(flashchar);					end;		asteriskset := useset;		asteriskchar := flashchar;	end;{-----------------------------------------------------------------------------}	procedure EraseAsterisksEtc;{erases * ? etc. in chleg beside state boxes}		var			ir: integer;			tport: windowptr;	begin		if asteriskset <> [] then			begin				genericGetPort(tport);				genericSetPort(chlegwindow);				TEXTMODE(srcbic);				asteriskset := asteriskset - [ucL, MSl];				asteriskset := asteriskset * legendstates;				if cardlg(asteriskset) > 0 then					for ir := 0 to absmaxstate do						if ir in asteriskset then							begin								MOVETO(strect[ir + 1].right + 1, strect[ir + 1].bottom);								Drawchar(asteriskchar);							end;				asteriskset := [];				TEXTMODE(srcOR);				genericSetPort(tport);			end;	end;{-----------------------------------------------------------------------------}	function CalcLegendStates (ic: integer): LargestSetChars;{only for (traceshown = tracediscrete)}	begin		if nucleotides then   {DNAformat or RNAformat}			CalcLegendStates := [0, 1, 2, 3]		else if cardLg(charstatesLargest(ic)) = 0 then			begin				if datatype = protein then  {NOW:}					CalcLegendStates := [0..maxproteinstate]				else					CalcLegendStates := [0, 1]			end		else if (typeofchar(ic) >= usedef) then			CalcLegendStates := StatesDistDefined(typeofchar(ic))		else if (typeofchar(ic) = unordered) then			CalcLegendStates := charstateslargest(ic)		else			CalcLegendStates := spanLg(charstatesLargest(ic));			{it is ordered, irrev, dollo, fisher}	end;{-----------------------------------------------------------------------------}	function numberLegendStates (ic: integer): longint;{only for (traceshown = tracediscrete)}	begin		numberLegendStates := cardLg(CalcLegendStates(ic));	end;{-----------------------------------------------------------------------------}	procedure CalcNumChLegBoxes (var boxestoshow: integer; numstates: integer);	begin		boxestoshow := numstates;		if polyon then			boxestoshow := boxestoshow + 1;		if uncertpres then			boxestoshow := boxestoshow + 1;		if equivpres then			boxestoshow := boxestoshow + 1;	end;{-----------------------------------------------------------------------------}	const		chLegFoundation = 2;{-----------------------------------------------------------------------------}	procedure CalcChLegRects (legBoxShift: integer);{this calculates the rectangles in the chlegwindow}		var			irdrawn, ir, it: INTEGER;			extralines: integer;			box: rect;			start: integer;{.............}		procedure ShiftExtraBox (var basebox, shiftbox: rect);		begin			OffSetRect(basebox, 0, legBoxShift);			shiftbox := basebox;		end;{.............}	begin		if printon then			start := 0		else			begin				start := chlegtypeB.bottom - 1;				SetRect(patternBox, 3, 0, 23, legBoxShift - 2);			end;{============= Character Trace Legend ===============|}		if (traceshown = tracediscrete) then			begin				CheckPolyUncert;				legendStates := CalcLegendStates(i);				box := patternBox;  {initializing first box}				OffSetRect(box, 0, start + legBoxShift);				irdrawn := 0;				for ir := 1 to mnsts do					if ((ir - 1) in legendstates) then  {in set to draw legend for}						begin							strect[ir] := patternBox;							OffSetRect(strect[ir], 0, start + 3 + irdrawn * legBoxShift);							box := strect[ir];							irdrawn := irdrawn + 1;						end					else    {not in set}						strect[ir] := box;{    box := strect[mnsts];}				OffSetRect(box, 0, 1);				if polyon then					ShiftExtraBox(box, polyB);				if uncertpres then					ShiftExtraBox(box, uncertB);				if equivpres then					ShiftExtraBox(box, equivB);			end{=============== ShowChanges Legend ===============}		else if (traceshown = traceallchanges) then			begin				for ir := 1 to absmaxnumstates do   { v3.02: changed to absmaxnumstates}					begin						strect[ir] := patternBox;						if showbranchlengths & squarebranches & (summaryview = aspattern) & (branchlistmode = minmaxmode) & not printon then							extralines := 1						else							extralines := 0;						if showbranchlengths & squarebranches & (branchlistmode = minmaxmode) & branchlengthsweighted & not printon then							extralines := extralines + 1;{$IFC COLORTICKS}						if (summaryview = asticks) & (colorTicksClass=colorTicksIndex) then							extralines := extralines + 1; {$ENDC}						OffSetRect(strect[ir], 0, chLegFoundation + (4 + extralines) * legLineheight + (ir + 1) * legBoxShift);					end;				if AnyNulls(ScreenR) and not polyreal then					begin						box := strect[maxchg + 1];						ShiftExtraBox(box, equivB);					end;			end;	end;{-----------------------------------------------------------------------------}	function LegendStateString (ic, is: integer): str255;	begin		if not chlegbynames then			LegendStateString := (CharOfNum(is))		else			begin				if showtracelabels & not tracelabelsbyname & (CharStateName(ic, is) <> '') then					LegendStateString := (concat(CharOfNum(is), ': ', AvailCharStateName(ic, is)))				else					LegendStateString := (AvailCharStateName(ic, is));			end;	end;{-----------------------------------------------------------------------------}	procedure SizechLeg;         {character legend, on right side}		label			1;		var			ir, it, ic, boxestoshow: INTEGER;			H, W: INTEGER;   {height and width of chlegwindow}			box: rect;			tport: windowptr;			oldchlegpt: point;			nameW, oldW, aW, thetaxon, newW: INTEGER;			thisPart, maxLength: integer;			ds: str255;{.............}	begin		oldchlegpt := WindowPortRect(chlegwindow).topleft;		legboxheight := 11;		genericGetPort(tport);		genericSetPort(chlegwindow);		LocalToGlobal(oldchlegpt);{====== calculate Width =======}		oldW := WindowPortRect(chlegwindow).right;		W := standchlegW;		if not locklegends then			if (traceshown = tracediscrete) then				begin					W := StringWidth(AvailCharName(i)) + 5;					if footpictpresent(0, i) then						W := W + CharWidth(footPictFlag);					for ir := 1 to mnsts do						if ((ir - 1) in legendstates) then  {in set to draw legend for}							begin								nameW := StringWidth(LegendStateString(i, ir - 1));{v4:    if StatePicture(i, ir - 1, thetaxon) then nameW := nameW + CharWidth(footPictFlag) + 1;}								if nameW > W then									W := nameW;							end;					W := patternbox.right + W + 8;				end			else if (traceshown = traceallchanges) then				begin					W := standchlegW;					if branchlistmode = minmaxmode then						begin							W := W + 20;							if realtypes then								W := W + 30;							if realwt then								W := W + 30;						end;{$IFC COLORTICKS}					if (summaryview = asticks) &TicksAreColored then						case colorTicksClass of								colorTicksIndex:  W := W + 1;								colorTicksPartition:									begin										for thisPart := 1 to numCharPartNames do 											SetPartNameInPartition(thisPart,false);										for ic := 1 to numchars do											SetPartNameInPartition(CharPartition(ic),true);										maxlength := 0;										for thisPart := 1 to numCharPartNames do 											if GetPartNameInPartition(thisPart) then 												begin													ds := NameOfCharPartNameFromNumber(thisPart);													if StringWidth(ds)>maxlength then														maxLength := StringWidth(ds);												end;										if maxLength+patternbox.right + 8 > W then 											W := maxLength+patternbox.right + 12;									end;								otherwise;							end; {$ENDC} 					if (summaryView= asticks) & showTickClass then 						begin 							newW := patternbox.right + StringWidth('homoplasy above and outside') + 12; 							if W < newW then W := newW; 						end;				end			else if (traceshown = traceContinuous) then				begin					W := 0;					for ir := 1 to 10 do						begin							RealToString(realcategories[ir - 1], ds, 1000, sigcontinuous, true);							aW := StringWidth(ds) + CharWidth('-');							if ir = 10 then								RealToString(maxcont, ds, 1000, sigcontinuous, true)							else								RealToString(realcategories[ir], ds, 1000, sigcontinuous, true);							aW := aW + StringWidth(ds);							if aW > W then								W := aW;						end;					W := patternBox.right + W + 8;				end			else if traceshown = traceProbability then				begin					W := 60;				end;		if W < standchlegW then			W := standchlegW;		if W <> oldW then			EraseRect(WindowPortRect(chlegwindow));{======= calculate heights =======}1:		CalcChLegRects(legboxheight);		if (traceshown = tracediscrete) then			begin				CalcNumChLegBoxes(boxestoshow, cardLg(legendstates));				H := chlegtypeB.bottom + boxestoshow * legboxheight + 3 + scrollwidth;			end		else if (traceshown = traceallchanges) then			begin			{here is the default height; change below if different}				H := 2 + legLineheight * 4 + legboxheight * 2;  {this to accommodate single line for print chleg}				if showbranchlengths & squarebranches & (branchlistmode = minmaxmode) & branchlengthsweighted & not printon then					H := H + legLineHeight;{$IFC COLORTICKS}				if (summaryview = asticks) then					begin						H := strect[1].bottom;						if TicksAreColored then							begin 								case colorTicksClass of									colorTicksIndex:										begin											if ColorPort then												H := strect[ticksIndexColorLevels+1].bottom + 3											else												H := strect[TicksIndexPatLevels+1].bottom + 3;											H := H + legboxheight;  {for white box}											if AnyType([usedef, dollo, fisher]) or (Anytype([irreversible]) & (colorTicksIndexClass in [colorTicksRI, colorTicksRC])) then												H := H + legboxheight;				{for uncalculable index box}										end;									colorTicksCodPos:										begin											H := strect[5].bottom + 3;										end;									colorTicksTiTv:										begin											H := strect[3].bottom + 3;										end;									colorTicksPartition:										begin											boxestoshow:= NumGroupsInCurrentPartition;											if boxesToShow > absmaxnumstates then												boxesToShow := absmaxnumstates;											H := strect[boxesToShow].bottom + 3;										end;									otherwise;								end;							end;						if ShowTickClass then							begin								H := H + legboxheight* numTickClasses;							end;					end				else{$ENDC}					if summaryview = aspattern then						begin							H := strect[maxchg + 1].bottom + 3;							if AnyNulls(screenR) and not polyreal then								H := H + legboxheight;						end;			end		else if (traceshown = traceContinuous) then   {ввв}			begin				if ContinuousisManhattan then					H := 11 * legboxheight + legLineheight * 4 + 38  {one more box for equivocal}				else if not (continuousmode in [sqFelsX, sqFelsContrast, sqFelsContrastSTD]) then					H := 10 * legboxheight + legLineheight * 5 + 38 {one more line for weighted vs not}				else					H := 10 * legboxheight + legLineheight * 4 + 38;			end		else if traceshown = traceProbability then			H := 125;{====== calculating chlegpts =========}		if locklegends then			SetLockLegPts(chlegwindow, H)		else			begin				genericSetPort(chlegWindow);				chlegpt := WindowPortRect(chlegwindow).topleft;				LocalToGlobal(chlegpt);{    chlegpt.v := chlegpt.v + (WindowPortRect(chlegwindow).bottom - H);}			end;		if H > ScreenBoundsRect.bottom - GetMBarHeight - 10 then			begin				legboxheight := legboxheight - 1;				goto 1;			end;{======= moving and resizing of window =========}		if not EqualPt(oldchlegpt, chlegpt) then			MoveWindow(chlegwindow, chlegpt.h, chlegpt.v, false);		with WindowPortRect(chlegwindow) do			begin				if (H <> (bottom - top)) or (W <> (right - left)) then					SizeWindow(chlegWindow, W, H, false);				MoveControl(chlegScroll, 0, WindowPortRect(chlegwindow).bottom - scrollwidth);			end;		genericSetPort(chlegWindow);		myValidRect(chlegWindow,WindowPortRect(chlegWindow));		genericSetPort(tport);		SetupRect;	end;{-----------------------------------------------------------------------------}	procedure ExtrachLegBox (box: rect; boxPat: pattern; ds: str255);	begin		FILLRECT(box, boxPat);		FRAMERECT(box);{$IFC SHADOWTREE}		if shadowTree then			shadowBox(box);{$ENDC}		if printon then			MOVETO(box.right + 8, box.bottom - 1)  {v3.02}		else			MOVETO(box.right + 3, box.bottom - 1);		Drawstring(ds);	end;{-----------------------------------------------------------------------------}	procedure FillLegendBox (box: rect; usepat: pattern; usecolor: RGBColor; mustUseColor: boolean);	begin		if ((branchShades[curTrace] = branchPatterns) & not mustUseColor) | not ColorPort then  			FILLRECT(box, usepat)		else			begin				RGBForeColor(usecolor);				FillBlackRect(box);				RGBForeColor(blackRGB);			end;		FRAMERECT(box);{$IFC SHADOWTREE}		if shadowTree then			shadowBox(box);{$ENDC}	end;{-----------------------------------------------------------------------------}	procedure DrawLegendTickBox (tickClass, legBoxShift, endBox: integer; ds: str255);	var r: rect;	begin		PenNormal;		if TicksAreColored then			RGBForeColor(GrayScale(5,2))		else			RGBForeColor(blackRGB);		r := LegendTickClassBox(tickClass,legBoxShift,endBox);		DrawFancyTick(r,QDBlack,tickClass);		RGBForeColor(blackRGB);		if (ambigDistinguish & (tickClass=tickAmbiguous)) then			if ColorPort then				RGBForeColor(faintTextRGB);		MoveTo(strect[1].right+8, r.bottom);		if tickClass = tickUnique then			TextFace([bold]);		DrawString(ds);		RGBForeColor(blackRGB);		TextFace([]);		PenNormal;	end;{-----------------------------------------------------------------------------}	function LegendTickClassBox(tickClass,legBoxShift,endBox: integer): rect;	var r: rect;	begin		SetRect(r,strect[endbox].left,strect[endbox].bottom+3,strect[endbox].right,strect[endbox].bottom+3+legboxheight);		r.right := r.left+edw + tickOverHang*2;		r.bottom := r.top + colorTicksBarWidth;		if endbox > 1 then			OffSetRect(r,(strect[1].right-strect[1].left - (edw + tickOverHang*2)) div 2,(strect[1].bottom-strect[1].top - colorTicksBarWidth) div 2+legboxheight)		else			OffSetRect(r,(strect[1].right-strect[1].left - (edw + tickOverHang*2)) div 2,- legboxheight);		OffSetRect(r,0,legBoxShift*tickClass);		LegendTickClassBox := r;	end;{-----------------------------------------------------------------------------}	procedure DrawCHLegBoxes (legBoxShift: integer);		var			decpos, ir, it, cnumst, H: INTEGER;			ds, ds2: str255;			indexReal: Real;			leadingzeros: boolean;			box,r: rect;			thetaxon: integer;			usepat: pattern;			usecolor: rgbcolor;			ic: integer;			numParts: longint;			thisPart: integer;	begin{===============| Character Trace Legend ===============}		if (traceshown = tracediscrete) then			begin {==in legendstates put the  states will have boxes shown==}				legendStates := CalcLegendStates(i);				GrayScaleStates := legendStates;				for ir := 1 to mnsts do					if ((ir - 1) in legendstates) then  {in set to draw legend for}						begin{findpat used here to ensure uniformity of pattern/color choice}							Findpat(usepat, usecolor, [ir - 1], i, curTrace);							FillLegendBox(strect[ir], usepat, usecolor,false);							if (currentTool[treeTools] = paintT) and not printon then								if ir - 1 in brushset then									TextFace([bold]);							MOVETO(strect[ir].right + 8, strect[ir].bottom - 1);							Drawstring(legendStateString(i, ir - 1));							if not printon then								begin{v4:    if StatePicture(i, ir - 1, thetaxon) then DrawChar(footPictFlag);}									TextFace([]);								end;						end;				if polyon then					ExtraCHLegBox(polyB, polym, 'polymorphic');				if uncertpres then					ExtraCHLegBox(uncertB, uncert, 'uncertain');				if equivpres then					ExtraCHLegBox(equivB, equivocalPattern, 'equivocal');				polyon := false;			end{=============== ShowChanges Legend ===============}		else if (traceshown = traceallchanges) then			if (summaryview = asticks) then				begin					numCharLegendBoxes := 1;					if  TicksAreColored then						begin							case colorTicksClass of								colorTicksIndex:									begin										if ColorPort then											begin												for ir := 1 to ticksIndexColorLevels do													begin														FillLegendBox(strect[ir], QDBlack, ColorScaleForTicks(1.0*(ir-1)/ticksIndexColorLevels),true);														MOVETO(strect[ir].right + 8, strect[ir].bottom);														indexReal := 1.0 / (ticksIndexColorLevels);														RealToString(indexReal * (ir - 1), ds, 10, 2, false);														RealToString(indexReal * (ir) - 0.01, ds2, 10, 2, false);														DrawString(concat(ds, '-', ds2));													end;												FillLegendBox(strect[ticksIndexColorLevels+1], QDBlack, ColorScaleForTicks(1.0),true);												MOVETO(strect[ticksIndexColorLevels+1].right + 8, strect[ticksIndexColorLevels+1].bottom);												DrawString('1.0');												numCharLegendBoxes := ticksIndexColorLevels + 1;											end										else											begin												FillLegendBox(strect[1], QDWhite, blackRGB,false);												MOVETO(strect[1].right + 8, strect[1].bottom);												DrawString('0.00-0.249');												FillLegendBox(strect[2], QDltGray, blackRGB,false);												MOVETO(strect[2].right + 8, strect[2].bottom);												DrawString('0.25-0.499');												FillLegendBox(strect[3], QDGray, blackRGB,false);												MOVETO(strect[3].right + 8, strect[3].bottom);												DrawString('0.50-0.749');												FillLegendBox(strect[4], QDdkGray, blackRGB,false);												MOVETO(strect[4].right + 8, strect[4].bottom);												DrawString('0.75-0.99');												FillLegendBox(strect[5], QDBlack, blackRGB,false);												MOVETO(strect[5].right + 8, strect[5].bottom);												DrawString('1.0');												numCharLegendBoxes := TicksIndexPatLevels + 1;											end;										if AnyType([usedef, dollo, fisher]) or (Anytype([irreversible]) & (colorTicksIndexClass in [colorTicksRI, colorTicksRC])) then											begin												with strect[numCharLegendBoxes + 1] do													begin														MoveTo(left, top + (bottom - top) div 2);														PenSize(1, 1);														LineTo(right - 1, top + (bottom - top) div 2);														MOVETO(right + 6, bottom);													end;												DrawString('uncalculated');											end;									end;								colorTicksCodPos:										begin											FillLegendBox(strect[1], QDBlack,CodPosRGB(1),true);											MOVETO(strect[1].right + 8, strect[1].bottom);											DrawString('1st position');											FillLegendBox(strect[2], QDBlack,CodPosRGB(2),true);											MOVETO(strect[2].right + 8, strect[2].bottom);											DrawString('2nd position');											FillLegendBox(strect[3], QDBlack,CodPosRGB(3),true);											MOVETO(strect[3].right + 8, strect[3].bottom);											DrawString('3rd position');											FillLegendBox(strect[4], QDBlack,CodPosRGB(codeNotSet),true);											MOVETO(strect[4].right + 8, strect[4].bottom);											DrawString('not set');											FillLegendBox(strect[5], QDBlack,blackRGB,true);											MOVETO(strect[5].right + 8, strect[5].bottom);											DrawString('non-coding');											numCharLegendBoxes := 5;										end;								colorTicksTiTv:										begin											FillLegendBox(strect[1], QDBlack,blackRGB,true);											MOVETO(strect[1].right + 8, strect[1].bottom);											DrawString('transversion');											FillLegendBox(strect[2], QDBlack,GrayScale(10,0),true);											MOVETO(strect[2].right + 8, strect[2].bottom);											DrawString('transition');											FillLegendBox(strect[3], QDBlack,GrayScale(2,1),true);											MOVETO(strect[3].right + 8, strect[3].bottom);											DrawString('uncertain');											numCharLegendBoxes := 3;										end;								colorTicksPartition:										begin											numCharLegendBoxes:= NumGroupsInCurrentPartition;											if numCharLegendBoxes > absmaxnumstates then												numCharLegendBoxes := absmaxnumstates;											for thisPart := 1 to numCharPartNames do 												SetPartNameInPartition(thisPart,false);											for ic := 1 to numchars do												SetPartNameInPartition(CharPartition(ic),true);											numParts := 0;											for thisPart := 1 to numCharPartNames do 												if GetPartNameInPartition(thisPart) then 													begin														numParts := numParts+1;														FillLegendBox(strect[numParts], QDBlack,GetPartNameColor(thisPart),true);														MOVETO(strect[numParts].right + 8, strect[numParts].bottom);														DrawString(NameOfCharPartNameFromNumber(thisPart));													end;										end;								otherwise;							end;						end;					if showTickClass then						begin							DrawLegendTickBox(tickUnique, legBoxShift, numCharLegendBoxes,'unique, uniform above');							DrawLegendTickBox(tickChangedAbove, legBoxShift, numCharLegendBoxes, 'changed above, not outside');							DrawLegendTickBox(tickPointUp, legBoxShift, numCharLegendBoxes, 'homoplasy above');							DrawLegendTickBox(tickPointDown, legBoxShift, numCharLegendBoxes, 'homoplasy outside');							DrawLegendTickBox(tickPointBoth, legBoxShift, numCharLegendBoxes, 'homoplasy above and outside');							DrawLegendTickBox(tickAmbiguous, legBoxShift, numCharLegendBoxes, 'ambiguous change');							DrawLegendTickBox(tickDerivedUnclear, legBoxShift, numCharLegendBoxes, 'derived state unclear');						end;				end			else				begin					for ir := 1 to maxchg + 1 do						begin							FindSummaryPat(usepat, usecolor, maxchg, ir - 1);							FillLegendBox(strect[ir], usepat, usecolor,false);							MOVETO(strect[ir].right + 8, strect[ir].bottom);							if (branchlistmode <> minmaxmode) then								ds := LengthString(categories[ir - 1], branchlengthsWeighted)							else								begin {move decimal over three spaces}									NumToString(categories[ir - 1], ds);									decpos := length(ds);									leadingzeros := false;									if decpos < 4 then  {not enough room to move to left}										begin											leadingzeros := true;											decpos := decpos + 3;											ds := concat('000', ds);										end;									Insert('.', ds, decpos - 2);{kludge}									if leadingzeros then										delete(ds, 1, pos('.', ds) - 2);								end;							Drawstring(ds);							if (ir <> maxchg + 1) & ((categories[ir - 1]) <> categories[ir]) & ((categories[ir - 1] + 1) <> categories[ir]) then								begin									drawchar('-');									if (branchlistmode <> minmaxmode) then										ds := LengthString(categories[ir] - 1, branchlengthsWeighted)									else										begin {move decimal over three spaces}											NumToString(categories[ir] - 1, ds);											decpos := length(ds);											leadingzeros := false;											if decpos < 4 then  {not enough room to move to left}												begin													leadingzeros := true;													decpos := decpos + 3;													ds := concat('000', ds);												end;											Insert('.', ds, decpos - 2);{kludge}											if leadingzeros then												delete(ds, 1, pos('.', ds) - 2);										end;									DrawString(ds);								end;							if ir = maxchangesshown + 1 then  {Maxchangesshown is currently set at 9}								drawstring(' or more');						end;					if AnyNulls(ScreenR) and not polyreal then						ExtraCHLegBox(equivB, equivocalPattern, 'not calc.');				end{=============== Continuous Legend ===============}		else if (traceshown = traceContinuous) then			begin{v4: change continuous characters so use same system of drawing the legend as everything else}				box := patternBox;				if ContinuousIsManhattan or (Continuousmode in [sqFelsX, sqFelsContrast, sqFelsContrastSTD]) then  {ввв}					OffSetRect(box, 0, legBoxShift * 4)				else					OffSetRect(box, 0, legBoxShift * 5);				offsetrect(box, -1, 0);				for ir := 1 to continuousBoxes do					begin						FindSummaryPat(usepat, usecolor, continuousBoxes - 1, ir - 1);						FillLegendBox(box, usepat, usecolor,false);						MOVETO(box.right + 2, box.bottom);						RealToString(realcategories[ir - 1], ds, 1000, sigcontinuous, true);						Drawstring(ds);						drawchar('-');						if ir = 10 then							RealToString(maxcont, ds, 1000, sigcontinuous, true)						else							RealToString(realcategories[ir], ds, 1000, sigcontinuous, true);						Drawstring(ds);						offsetrect(box, 0, legBoxShift);					end;				if ContinuousisManhattan then					begin						FILLRECT(box, equivocalPattern);						FRAMERECT(box);{$IFC SHADOWTREE}						if shadowTree then							shadowBox(box);{$ENDC}						MOVETO(box.right + 8, box.bottom);						Drawstring('equivocal');					end;			end;	end;{-----------------------------------------------------------------------------}	procedure DrawchLeg;{draws character legend}		var			ds: str255;			cprect, box: rect;			tport: windowptr;	begin		asteriskset := [];{    if not PaintedBranches then   exit(DrawCHLeg);  - for some showchanges , need to have legend}{but not painted branches!}		CheckPixelDepth(treewindow);		genericGetPort(tport);		genericSetPort(chlegwindow);		TextFont(TWFont);		TextSize(TWFontSize);		SizeChLeg;		ShowCHLegIfHidden;		ClipRect(WindowPortRect(chlegwindow));		EraseRect(WindowPortRect(chlegwindow));{||||||||||||||||||||||||||||||||||||| Character Trace Legend ||||||||||||||||||||||||||||||||||}		if (traceshown = tracediscrete) then			begin{=========== menu fixing ===============}				if fixon then					begin						SetFixon;						if not fixon then							begin								InvalidateWindow(twmesswindow, false);{$IFC FALSE}								if (currentTool[treeTools] = turpentineT) then									SetTool(treeTools,arrowT);								DropTool(treeTools,turpentineT);{$ENDC}							end;					end;				EnableDisableItem(TraceMHdl, UnfixAllItem, fixon);				WriteTraceChLegTitle;				ds := CharStepsString(isteps, i);				if (TypeOfChar(i) >= usedef) & poly3inchar(i) then					ds := concat(ds, '*');				if isteps = 1 then					ds := concat(ds, ' step')				else					ds := concat(ds, ' steps');				WriteB(chlengthB, ds);				WriteB(chlegtypeB, TypeName(TypeOfChar(i)));				cprect := WindowPortRect(chlegwindow);				insetrect(cprect, 1, 1);				cliprect(cprect);				DrawCHLegBoxes(legboxheight);				SetControlValueLong(chlegscroll, i);				DrawLegNumber(chlegscroll);				ClipRect(WindowPortRect(chlegwindow));				if equivcycle then					HideControl(chlegscroll)				else					ShowControl(chlegscroll);								if not IsTreeWindow(frontwindow) or not isforeground then					DoDeActivateControl(chlegscroll)				else					DoActivateControl(chlegscroll);				DrawControls(chlegwindow);			end{||||||||||||||||||||||||||||||||||||| ShowChanges Legend ||||||||||||||||||||||||||||||||||}		else if (traceshown = traceallchanges) then			begin				myDisableItem(TraceMHdl, UnfixAllItem);				HideControl(chlegscroll);				WriteTitleBar(charnameB, ';', true, true);				if branchlengthsweighted then					ds := concat('Weighted amount', chr(13), 'of change')				else					begin						ds := 'Chars. Changing';						if summaryview <> asticks then							ds := concat('#', ds);					end;				case branchlistmode of					unambigmode: 						if branchlengthsweighted then							ds := concat(ds, chr(13), '(Minimum)')						else							ds := concat(ds, chr(13), 'Unambiguously on branch');					ambigmode: 						ds := concat(ds, chr(13), '(Almost All Poss.) on branch');					maxmode: 						if branchlengthsweighted then							ds := concat(ds, chr(13), '(Maximum)')						else							ds := concat(ds, chr(13), '(All Possible) on branch');{$IFC MINMAXIN}					minmaxmode: 						begin							ds := concat(ds, chr(13), '(Min.-Avg.-Max.)');							if summaryview = aspattern then								ds := concat(ds, chr(13), '[shaded by avg.]');						end;{$ENDC}					otherwise						;				end;{$IFC COLORTICKS}			{	if (summaryview = asticks) & (colorTicksClass=colorTicksIndex) then					begin						if colorTicksIndexClass = colorTicksRI then							ds := concat(ds, chr(13), '(bar shading: RI)')						else if colorTicksIndexClass = colorTicksCI then							ds := concat(ds, chr(13), '(bar shading: CI)')						else							ds := concat(ds, chr(13), '(bar shading: RC)');					end;} {$ENDC}				if showbranchlengths & squarebranches & (branchlistmode = minmaxmode) then					ds := concat(ds, chr(13), '[br. length-max]');				SetRect(Box, 0, legtitleW - 6, WindowPortRect(chlegwindow).right, strect[1].top - 16);  { 5 to 6;  17 to 16}				TETextBox(Pointer(ord4(@ds) + 1), length(ds), box, teJustleft);{$IFC COLORTICKS}				if (summaryview = asticks) & (colorTicksClass=colorTicksIndex) then					begin						if colorTicksIndexClass = colorTicksRI then							ds := 'Bar shading: RI'						else if colorTicksIndexClass = colorTicksCI then							ds :=  'Bar shading: CI'						else							ds := 'Bar shading: RC';						SetRect(box, 2, strect[1].top - 15, WindowPortRect(chlegwindow).right - 2, strect[1].top - 2);						TETextBox(Pointer(ord4(@ds) + 1), length(ds), box, teJustleft);						SetRect(legMessageBox, 2, strect[1].top - 17-legLineheight, WindowPortRect(chlegwindow).right - 2, strect[1].top - legLineheight-4);					end				else					SetRect(legMessageBox, 2, strect[1].top - 15, WindowPortRect(chlegwindow).right - 2, strect[1].top - 2);{$ELSEC}				SetRect(legMessageBox, 2, strect[1].top - 15, WindowPortRect(chlegwindow).right - 2, strect[1].top - 2);{$ENDC}				Eraserect(legMessageBox);				framerect(legMessageBox);{$IFC COLORTICKS}				if (summaryview = aspattern) | ((summaryview = asticks) & TicksHaveLegend) then{$ELSEC}					if (summaryview = aspattern) then{$ENDC}						DrawCHLegBoxes(legboxheight);			end{||||||||||||||||||||||||||||||||||||| Continuous Legend ||||||||||||||||||||||||||||||||||}		else if (traceshown = traceContinuous) then			begin				myDisableItem(TraceMHdl, UnfixAllItem);				HideControl(chlegscroll);				WriteTitleBar(charnameB, concat('Continuous ', stringfromnum(icont)), true, true);				case continuousmode of					manhattan: 						ds := 'Linear (full)';					manhatmin: 						ds := 'Linear (min.)';					manhatmax: 						ds := 'Linear (max.)';					sqrooted: 						ds := 'Squared (rooted)';					squnrooted: 						ds := 'Squared (unroot.)';{$SETC CONTRASTS=FALSE}{$IFC CONTRASTS}					sqFelsX: 						ds := 'Felsenstein''s X'; {ввв}					sqFelsContrast: 						ds := 'Fels. Contrasts'; {ввв}					sqFelsContrastSTD: 						ds := 'Fels. Contr. (Std.)'; {ввв}{$ENDC}					otherwise						;				end;				moveto(3, 21);				Drawstring(ds);				if not ContinuousIsManhattan then {ввв}					begin						Moveto(3, 33);						if contweighted then							ds := 'Weighted branches'						else							ds := 'Unwtd. branches';						Drawstring(ds);					end;				if not (continuousmode in [sqFelsX, sqFelsContrast, sqFelsContrastSTD]) then {ввв}					begin						if ContinuousIsManhattan then							begin								moveto(0, 24);								lineto(WindowPortRect(chlegwindow).right, 24);								Moveto(3, 33);							end						else							begin								moveto(0, 36);								lineto(WindowPortRect(chlegwindow).right, 36);								Moveto(3, 45);							end;						drawstring('Lgth: ');						if ContinuousIsManhattan then							RealToString(NYlength, ds, 10000, sigcontinuous, true)						else							RealToString(minSQLength, ds, 10000, sigcontinuous, true);						Drawstring(ds);					end;				if continuousisManhattan or (Continuousmode in [sqFelsX, sqFelsContrast, sqFelsContrastSTD]) then					begin						moveto(0, 36);						lineto(WindowPortRect(chlegwindow).right, 36);					end				else					begin						moveto(0, 48);  {was 36}						lineto(WindowPortRect(chlegwindow).right, 48);   {was 36}					end;				DrawCHLegBoxes(legboxheight);				SetRect(box, 0, WindowPortRect(chlegwindow).bottom - 33, WindowPortRect(chlegwindow).right, WindowPortRect(chlegwindow).bottom);				Framerect(box);			end;{$IFC PROBRECONSTRUCT}		else if traceshown = traceProbability then			begin				myDisableItem(TraceMHdl, UnfixAllItem);				HideControl(chlegscroll);				WriteTitleBar(charnameB, 'Probability', true, true);				case probRecitem of					stateexact: 						begin							moveto(3, 21);							Drawstring('that state at node');							moveto(3, 32);							Drawstring('is reconstructed');							moveto(3, 43);							Drawstring('correctly,');							moveto(3, 54);							Drawstring('given model:');						end;					statenotwrong: 						begin							moveto(3, 21);							Drawstring('that MPR set');							moveto(3, 32);							Drawstring('includes true');							moveto(3, 43);							Drawstring('state at node,');							moveto(3, 54);							Drawstring('given model:');						end;					changecorrect: 						begin							moveto(3, 21);							Drawstring('that change along');							moveto(3, 32);							Drawstring('branch is');							moveto(3, 43);							Drawstring('reconstructed');							moveto(3, 54);							Drawstring('correctly,');							moveto(3, 65);							Drawstring('given model:');						end;					numchangeUnamb: 						begin							moveto(3, 21);							Drawstring('that unambiguous');							moveto(3, 32);							Drawstring('change is');							moveto(3, 43);							Drawstring('reconstructed');							moveto(3, 54);							Drawstring('along branch,');							moveto(3, 65);							Drawstring('given model:');						end;					numchangeAllowed: 						begin							moveto(3, 21);							Drawstring('that allowed');							moveto(3, 32);							Drawstring('change is');							moveto(3, 43);							Drawstring('reconstructed');							moveto(3, 54);							Drawstring('along branch,');							moveto(3, 65);							Drawstring('given model:');						end;					otherwise						;				end;				moveto(3, 77);				if seglistenProb then					DRAWstring('Prob. ╞/segment')				else					DRAWstring('Prob. ╞/branch');				RealToString(probChangeRec[0, 0], ds, 1000, 4, true);				moveto(3, 88);				Drawstring(concat('0->0:   ', ds));				RealToString(probChangeRec[0, 1], ds, 1000, 4, true);				moveto(3, 99);				Drawstring(concat('0->1:   ', ds));				RealToString(probChangeRec[1, 0], ds, 1000, 4, true);				moveto(3, 110);				Drawstring(concat('1->0:   ', ds));				RealToString(probChangeRec[1, 1], ds, 1000, 4, true);				moveto(3, 121);				Drawstring(concat('1->1:   ', ds));			end;{$ENDC}		genericSetPort(chlegwindow);		myValidRect(chlegWindow,WindowPortRect(chlegWindow));		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	procedure BrSelectLegs (N: Nptr);		var			tport: windowptr;	begin		genericGetPort(tport);		genericSetPort(treewindow);		if N^.fixanc or not (traceshown = tracediscrete) or (brushset = []) then			DimTool(treeTools,paintT);		if not (traceshown = tracediscrete) or not N^.fix then			DimTool(treeTools,turpentineT);		DimTool(treeTools,treePictureT);		genericSetPort(toolPaletteWindow[treeTools]);		InsetRect(tool^[treeTools,currentTool[treeTools]].R, 1, 1);		InvertRect(tool^[treeTools,currentTool[treeTools]].R);		InsetRect(tool^[treeTools,currentTool[treeTools]].R, -1, -1);		DimTool(treeTools,handT);		DimTool(treeTools,polyflipT);		if not ((N <> ScreenR) and (N^.anc <> ScreenR) and not IsTerminalFixanc(N)) or OptionIsDown then			DimTool(treeTools,rerootT);{note: if option is down, the reroot tool requires ScanDrop, cannot be used in BRSelectLegs}		if NodeIsInternal(N) then			begin				DimTool(treeTools,ancT);  {disable anc fixing}				textmode(srcOr);				if (N <> ScreenR) then					begin						if ancon or AnyType([irreversible, fisher, dollo, usedef]) then							begin								DimTool(treeTools,collapseT);   {disable collapse}								DimTool(treeTools,collapseAllT);							end;					end				else					DimTool(treeTools,collapseT); {disable collapse branch}				if (OptionIsDown & (N^.lf^.name * N^.rt^.name > 0)) | (not OptionIsDown & ((N = R) | (N^.anc = R)))  then					DimTool(treeTools,swapT);			end		else    {is terminal node}			begin				DimTool(treeTools,statsTestT);				DimTool(treeTools,ladderT);				DimTool(treeTools,expandT);				DimTool(treeTools,collapseT);				DimTool(treeTools,collapseallT);				DimTool(treeTools,rotateT);				if not OptionIsDown | N^.fixanc then						DimTool(treeTools,SwapT);				if N^.fixanc then   {terminal fixanced node}					begin						DimTool(treeTools,scissorsT);						DimTool(treeTools,arrowT);					end;				if not N^.fixanc & (IsTerminalFixanc(sis(N)) or AnyType([dollo, usedef])) then					DimTool(treeTools,ancT);  {disable anc fixing}			end;		if not ((traceshown = traceallchanges) or (traceshown = traceallstates)) then			begin				DimTool(treeTools,queryT);				DimTool(treeTools,traceTickT);			end;		genericSetPort(tport);	end;{---------------------------------------------------------------------}	procedure DrawFancyTick(r: rect;pat: pattern; tickClass:integer);	var box: rect;		thePoly: PolyHandle;	begin		box := r;		case tickClass of			tickUnique:				begin					InsetRect(box,-1,-1);					FillRect(OrientRect(r), pat);					if colorTicksFramed then						RGBForeColor(blackRGB);					PenSize(2,2);					FrameRectOrient(box);				end;			tickChangedAbove:				begin					FillRect(OrientRect(r), pat);					if colorTicksFramed then						RGBForeColor(blackRGB);					FrameRectOrient(box);				end;			tickPointUp:				begin					thePoly := OpenPoly;					MoveToOrient(box.left, box.bottom);					LineToOrient(box.right, box.bottom);					LineToOrient(box.left+(box.right-box.left) div 2 , box.top);					LineToOrient(box.left, box.bottom);					ClosePoly;					FillPoly(thePoly, pat);					if colorTicksFramed then						RGBForeColor(blackRGB);					FramePoly(thePoly);					KillPoly(thePoly);				end;			tickPointDown:				begin					thePoly := OpenPoly;					MoveToOrient(box.left, box.top);					LineToOrient(box.right, box.top);					LineToOrient(box.left+(box.right-box.left) div 2 , box.bottom);					LineToOrient(box.left, box.top);					ClosePoly;					FillPoly(thePoly, pat);					if colorTicksFramed then						RGBForeColor(blackRGB);					FramePoly(thePoly);					KillPoly(thePoly);				end;			tickPointBoth:				begin					thePoly := OpenPoly;					MoveToOrient(box.left+(box.right-box.left) div 2 , box.bottom);					LineToOrient(box.right, box.top + (box.bottom-box.top) div 2);					LineToOrient(box.left+(box.right-box.left) div 2 , box.top);					LineToOrient(box.left, box.top + (box.bottom-box.top) div 2);					LineToOrient(box.left+(box.right-box.left) div 2 , box.bottom);					ClosePoly;					FillPoly(thePoly, pat);					if colorTicksFramed then						RGBForeColor(blackRGB);					FramePoly(thePoly);					KillPoly(thePoly);				end;			tickAmbiguous:				begin					if not TicksAreColored then						RGBForeColor(faintTextRGB);					FillOval(OrientRect(r), pat);					if colorTicksFramed | ambigDistinguish then						if ColorPort then							RGBForeColor(faintTextRGB)						else							RGBForeColor(blackRGB);					FrameOval(OrientRect(r));					RGBForeColor(blackRGB);				end;			tickDerivedUnclear:				begin					FillRect(OrientRect(r), pat);					if colorTicksFramed then						if ColorPort then							RGBForeColor(faintTextRGB)						else							RGBForeColor(blackRGB);					FrameRect(OrientRect(r));					RGBForeColor(blackRGB);				end;			otherwise				begin					FillRect(OrientRect(r), pat);					if colorTicksFramed then						RGBForeColor(blackRGB);					FrameRectOrient(box);				end;		end;	end;end.