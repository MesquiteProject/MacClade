unit CharUtil;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, 		ErrorUtil, EventUtil, GenUtil, StrUtil, TaxonCHUtil, TypeUtil;	function SetToString (inset: largestsetchars): str255;	function addUCLtoSet (fset: largestsetchars; NN: Nptr; ic: integer): largestsetchars;	function TreatAsUncertainty (fset: largestsetchars; NN: Nptr; ic: integer): boolean;	function CharStepsString (steps: longint; ic: integer): str255;	procedure ZeroCharExtra;	procedure SetCharExtraToTrue (ic: integer);	function IsCharExtra (ic: integer): boolean;	procedure ZeroUnused1;	procedure SetUnused1 (ic: integer; setTo: boolean);	function IsUnused1 (ic: integer): boolean;	procedure ZeroUnused2;	procedure SetUnused2 (ic: integer; setTo: boolean);	function IsUnused2 (ic: integer): boolean;	procedure CheckConstantCharacters(icstart,icend: integer);	function CharConstant (ic: integer): boolean;	procedure CalcNumCharIncluded;	function Allexcluded: boolean;	function NextIncludedChar (ic: integer): integer;	function CharMaxstDISPLAY (ic: integer): SignedByte;	function CharMaxstDEF (ic: integer): SignedByte;	function GetCellColor(ic: integer; tsts: largestSetChars): RGBColor;	function GetStateColor(maximumState, stateNumber: integer): RGBColor;	function GetStateSetColor(maximumState: integer; tsts: largestSetChars): RGBColor;	function PrevIncludedChar (ic: integer): integer;	function Qtaxon (N: Nptr; ic: integer): BOOLEAN;	function Poly3InChar (ic: integer): boolean;	function TaxonPolyFixancBeware (it: integer): boolean;	function MStaxon (N: Nptr; ic: integer): BOOLEAN;	function terminalFixancing (N: Nptr): Nptr;	function FixancedByMissing (N: Nptr; ic: integer): boolean;	function FixancedByUncertain (N: Nptr; ic: integer): boolean;	function FixancedByPolymorphic (N: Nptr; ic: integer): boolean;	procedure MaxMin (stset: ptr; slen: integer; var mins, maxs: INTEGER);	{procedure MaxMinLg (stset: largestsetchars; var mins, maxs: INTEGER);}	function SpanLg (stset: largestsetchars): largestsetchars;	function FisherDistance (spanset: largestsetchars; countfirst: boolean): longint;	function CharSteps (ic: integer): longint;	function CharPolymorphLength (ic: integer): longint;	procedure FindPat (var usepat: PATTERN; var usecolor: RGBColor; stc: largestsetchars; ic: integer; theTrace: integer);	procedure FindSummaryPat (var usepat: PATTERN; var usecolor: RGBColor; maxvalue, ir: integer);	procedure SetFixon;	procedure OffFix (zapfixdata: boolean);	function CharInCharInfo (ic: integer): BOOLEAN;	function CellVisible (cellTL, cellBR: point): boolean;	procedure MaxStCalc (icstart, icend: integer);	procedure ReCalcEditorStatesH (icstart, icend: integer);	procedure ReCalcMaxstAndStates(icstart,icend: integer);	function CheckAAInMatrix (theAAs: aaset; calcTotal: boolean; var AAsFound: largestSetChars): boolean;	procedure CheckPolyUncert;	function AddToLength (var lenth: longint; clen: longint; cwt, ctyp: integer): boolean;	function TreeLengthPlus: boolean;	function TreeLengthMinus: boolean;	procedure CalcStateFrequencies (itstart, itend, icstart, icend, topstate: integer);	function ColorCharInChartsLegal: boolean;	function ColorCodPosLegal: boolean;	procedure CheckForCodPos (checkForAll: boolean);	procedure PostCodPosChanged;	procedure SetCodonPositions (icstart, icend, firstcodpos: integer; blastNonCode, restartAt1: boolean);	procedure QuerySetCodPos;	procedure SetLengths (cladeN: Nptr; mode: integer);  {This is called in EditMenu and in ToolOnBranch}{$IFC TRUE}  {was IFC THINK_PASCAL}	procedure ZeroHighBitsP (s: ptr);{ptr based min/max/card}{these take a pointer to the set as argument, and slength=15 or 31 to indicate numbytes}{minP finds lowest element in set, maxP the highest element, and cardP the number of elements in set}{	function MinP (s: ptr; slength: integer): integer;	function MaxP (s: ptr; slength: integer): integer;	function cardP (s: ptr; slength: integer): integer;}{largestsetchars  based min/max/card}{these look over largest setchars from elements 0 to 25 to find minimum, maximum and cardinality of set}	{function MinLg (s: largestsetchars): integer;	function MaxLg (s: largestsetchars): integer;}	{function cardfrom (cset: ptr; upto: integer): integer;}{$ELSEC}	procedure ZeroHighBitsP (s: ptr);	external;	{function MinP (s: ptr; slength: integer): integer;	external;	function MaxP (s: ptr; slength: integer): integer;	external;}	{function MinLg (s: largestsetchars): integer;	external;	function MaxLg (s: largestsetchars): integer;	external;}	{function cardP (s: ptr; slength: integer): integer;	external;}{$ENDC}{еееееееееееееееееееееее}implementation {е$S CharUtil}{$IFC  TRUE}  {was IFC THINK_PASCAL}	{function MinP;	external;	function MaxP;	external;	function cardP;	external;}{	function MinLg;	external;	function MaxLg;	external;}{	function cardfrom;	external;}{$ENDC}{-----------------------------------------------------------------------------}	function SetToString (inset: largestsetchars): str255;{FROZEN 3.0}{converts set to a string, eg. [0,1] goes to "[0,1,]"}{To user used in SaveFixRec in StringSave; also possibly in ScanPick }{NOTE: if this changes, e.g., whether or not commas are produced, then this will crash fixdataH}		var			stst: str255;			ir: integer;	begin		stst := '[';		for ir := 0 to absmaxstate do			if ir in inset then				stst := concat(stst, chr(ir + 48), ',');		SetToString := concat(stst, ']');	end;{-----------------------------------------------------------------------------}	function TreatAsUncertainty (fset: largestsetchars; NN: Nptr; ic: integer): boolean;{This function determines whether a state set reconstructed at a node is to be listed with}{and separator separating multiple states or or separator (uncertainty)}{Rule is that uncertainty in all cases except possibly fixanced polymorphic.}		var			termf: Nptr;	begin		if MultipleStatesLg(fset) then			begin				if NN^.fixanc & (NN^.name = 0) then {observed taxon fixed as ancestor}					begin						if (NN^.rt^.name > 0) & (NN^.rt^.fixanc) then							termf := NN^.rt						else							termf := NN^.lf;						TreatAsUncertainty := (([UCl, MSl] * GettaxonstsLargest(termf^.name, ic) <> []) | (typeofchar(ic) = fisher));					end				else					TreatAsUncertainty := true;			end		else			TreatAsUncertainty := false;	end;{-----------------------------------------------------------------------------}	function addUCLtoSet (fset: largestsetchars; NN: Nptr; ic: integer): largestsetchars;{This function determines whether a state set reconstructed at a node is to be listed with}{and separator separating multiple states or or separator (uncertainty)}{Rule is that uncertainty in all cases except possibly fixanced polymorphic.}	begin		if TreatAsUncertainty(fset, NN, ic) then			addUCLtoSet := fset + [UCl]		else			addUCLtoSet := fset;	end;{-----------------------------------------------------------------------------}{v4: eventually in assembly}	procedure ZeroHighBitsP (s: ptr);{FROZEN 3.0}{ takes pointer to set of current set size, and zeros high bits which only contain info re footnotes, uncertainty, etc.}	begin		if maxbit = 15 then			setpointer15(s)^ := setpointer15(s)^ * [0..9]		else			setpointer31(s)^ := setpointer31(s)^ * [0..25];	end;{-----------------------------------------------------------------------------}	procedure MaxMin (stset: ptr; slen: integer; var mins, maxs: INTEGER);{FROZEN 3.0}{returns min & max elements in stateset, using pointer to stateset as input and slen=15 or 31 to indicate maxbit}	begin		mins := minP(stset, slen);		maxs := maxP(stset, slen);		if (mins = ERb) or (maxs = ERb) then {ERb is error value returned by assembly minP, maxP (e.g., when set empty}			NewError(2, 0);	end;{-----------------------------------------------------------------------------}{	procedure MaxMinLg (stset: largestsetchars; var mins, maxs: INTEGER);	EXTERNAL;}{returns min & max elements in stset; uses 4-byte sets (largestsetchars)}{-----------------------------------------------------------------------------}{v4: in assembly}	function SpanLg (stset: largestsetchars): largestsetchars;{FROZEN 3.0}{returns set from min to max of stset}		var			minL, maxL: integer;	begin		MaxMinLg(stset, minL, maxL);		SpanLg := [minL..maxL];	end;{----------------------------------------------------------------------------}	procedure ZeroCharExtra;		var			ic: integer;			charHdl: chHdl;	begin		for ic := 1 to numchars do			begin				charHdl := GetChHdl(ic);				charHdl^^.extra := false;			end;	end;{----------------------------------------------------------------------------}	procedure SetCharExtraToTrue (ic: integer);		var			charHdl: chHdl;	begin		charHdl := GetChHdl(ic);		charHdl^^.extra := true;	end;{----------------------------------------------------------------------------}	function IsCharExtra (ic: integer): boolean;		var			charHdl: chHdl;	begin		charHdl := GetChHdl(ic);		IsCharExtra := charHdl^^.extra;	end;{-----------------------------------------------------------------------------}	procedure ZeroUnused1;	var ic: integer;	begin		for ic := 1 to numchars do			getChHdl(ic)^^.unused1 := false;	end;{-----------------------------------------------------------------------------}	procedure SetUnused1 (ic: integer; setTo: boolean);	begin		getChHdl(ic)^^.unused1 := setTo;	end;{----------------------------------------------------------------------------}	function IsUnused1 (ic: integer): boolean;	begin		IsUnused1 := getChHdl(ic)^^.unused1;	end;{-----------------------------------------------------------------------------}	procedure ZeroUnused2;	var ic: integer;	begin		for ic := 1 to numchars do			getChHdl(ic)^^.unused2 := false;	end;{-----------------------------------------------------------------------------}	procedure SetUnused2 (ic: integer; setTo: boolean);	begin		getChHdl(ic)^^.unused2 := setTo;	end;{----------------------------------------------------------------------------}	function IsUnused2 (ic: integer): boolean;	begin		IsUnused2 := getChHdl(ic)^^.unused2;	end;{-----------------------------------------------------------------------------}	function FisherDistance (spanset: largestsetchars; countfirst: boolean): longint;{FROZEN 3.0}{used in SetStates, CalcUtil,Count}		var			len: longint;			ir, fromstate, tostate: integer;	begin		typeHdl := gettypehdl(fisher);		MaxMinLg(spanset, fromstate, tostate);{calculate cost of skipping states in each of strata spanned by input set}		len := 0;		if countfirst then			len := typeHdl^^.dist[fromstate, fromstate + 1];		if fromstate <= tostate - 2 then			for ir := fromstate + 1 to tostate - 1 do				if not (ir in spanset) then					len := len + typeHdl^^.dist[ir, ir + 1];{dist[ir,ir+1] contains the cost of skipping stratum ir.  Thus we add all costs from fromstate to}{tostate-1; whether or not fromstate is counted as skipped depends on boolean countfirst.}{See CountFisher in Count for precise uses of this function}		FisherDistance := len;	end;{-----------------------------------------------------------------------------}	function AddToLength (var lenth: longint; clen: longint; cwt, ctyp: integer): boolean;{FROZEN 3.0}{for use with treelength or mintreelength - adds character length clen to total length, intelligently}{dealing with weights and inflations due to real types and weights}{ADDITION ONLY; cwt cannot be negative}{RETURNS true if no overflow; false if overflowed}{(MacClade's infinity does not count as overflow; only integer overflow counts)}		var			tcwt: longint;	begin		tcwt := cwt;		if lenth = infinity then			AddTolength := true		else if clen = infinity then			begin				if cwt <> 0 then					lenth := infinity;				AddToLength := true;			end		else			begin				if realtypes & not TypeIsReal(ctyp) then					lenth := multaddC(lenth, clen, tcwt * TypeInflate)				else					lenth := multaddC(lenth, clen, tcwt);				AddToLength := lenth >= 0;			end;	end;{-----------------------------------------------------------------------------}	function CharSteps (ic: integer): longint;{FROZEN 3.0}{returns the unweighted number of steps in a character}	begin		CharSteps := LIP(GetMaster(chLenH) + chlb * longint(ic - 1))^;    {don't need to lock}	end;{-----------------------------------------------------------------------------}	function CharStepsString (steps: longint; ic: integer): str255;{this function returns a string for the steps given character; it automatically}{adjusts if realtypes is true by deflating, and also aware of infinity}		var			dds: str255;	begin		if steps = infinity then			dds := '░'		else if typeisreal(typeofchar(ic)) then			dds := RealToIntegerString(steps, TypeInflate)		else			numtostring(steps, dds);		CharStepsString := dds;	end;{-----------------------------------------------------------------------------}	function CharPolymorphLength (ic: integer): longint;{FROZEN 3.0}{returns length due to polymorphism for character; only valid if predefined type}	begin		CharPolymorphLength := LIP(GetMaster(chpLH) + chpb * ord4(ic - 1))^;   {don't need to lock}	end;{-----------------------------------------------------------------------------}	function TreeLengthMinus: boolean;{THIS IS NOT USED IN VERSION 3}{returns true if current treelength is an overestimate}		var			minus: boolean;	begin		minus := false;{v4: flesh this out}{ if  poly2 & triangle ineq violated; see proc. StatusNotes}		TreeLengthMinus := minus;	end;{-----------------------------------------------------------------------------}	function TreeLengthPlus: boolean;{FROZEN 3.0}{returns true if current treelength is an underestimate}		var			plus: boolean;			ic: integer;	begin		plus := nullson and not polyreal;		if not plus then			for ic := 1 to numchars do				if (TypeOfChar(ic) >= usedef) & CharIncluded(ic) & Poly3InChar(ic) & (CharWeight(ic) > 0) then					begin						plus := true;						leave;					end;		TreeLengthPlus := plus;	end;{-----------------------------------------------------------------------------}	function terminalFixancing (N: Nptr): Nptr;{FROZEN 3.0}{returns the node that is fixanced onto N; if none returns N itself}	begin		if (N^.name = 0) & (N^.fixanc) then			begin				if N^.lf^.fixanc & (N^.lf^.name <> 0) then					terminalfixancing := N^.lf				else					terminalfixancing := N^.rt;			end		else			terminalfixancing := N;	end;{-----------------------------------------------------------------------------}	function MStaxon (N: Nptr; ic: integer): BOOLEAN;{FROZEN 3.0}{asks if taxon is terminal and had multistate data for char#ic}	begin		MStaxon := (N^.name > 0) & (MultipleStatesLg(GetTaxonStsLargest(N^.name, ic))); {recall cardlg ignores highbits}	end;{-----------------------------------------------------------------------------}	function FixancedByMissing (N: Nptr; ic: integer): boolean;{FROZEN 3.0}{returns true if node is internal and is fixanced by a terminal taxon whose state is missing}	begin		FixancedByMissing := ((N^.name = 0) & (N^.fixanc)) & (Qtaxon(TerminalFixancing(N), ic));	end;{------------------------------------------------------}	function FixancedByUncertain (N: Nptr; ic: integer): boolean;{FROZEN 3.0}{returns true if node is internal and is fixanced by a terminal taxon whose state is uncertain}	begin		FixancedByUncertain := ((N^.name = 0) & (N^.fixanc)) & (UCL in GetTaxonStsLargest(TerminalFixancing(N)^.name, ic))	end;{------------------------------------------------------}	function FixancedByPolymorphic (N: Nptr; ic: integer): boolean;{FROZEN 3.0}{returns true if node is internal and is fixanced by a terminal taxon whose state is polymorphic}		var			fs: largestsetchars;	begin		if (N^.name = 0) & (N^.fixanc) then			begin				fs := GetTaxonStsLargest(TerminalFixancing(N)^.name, ic);				FixancedByPolymorphic := not (UCL in fs) & (MultipleStatesLg(fs));			end		else			FixancedByPolymorphic := false;	end;{-----------------------------------------------------------------------------}	function Qtaxon;  {(N : Nptr; ic : integer) : BOOLEAN}{FROZEN 3.0}{asks if taxon is terminal and had missing data for char#ic; relies upon current set size}	begin		Qtaxon := (N^.name > 0) & (BitTst(Pointer(GetMaster(HdlPtr(GetMaster(TaxstsCHUNKs) + HdlSize * ord4(N^.name - 1))^)), longint(Maxbit + 1) * longint(ic - 1)));	end;{-----------------------------------------------------------------------------}	procedure CheckPolyUncert;{FROZEN 3.0}{checks to see if currently traced character has uncertainty or polymorphisms in terminal taxa}		var			it: integer;			tempset: largestsetchars;	begin		uncertpres := false;		polyon := false;		for it := 1 to numtaxa do			if TaxonInTree(it) then				begin					tempset := GetTaxonStsLargest(it, i);					if MultipleStatesLg(tempset) then						begin							if UCl in tempset then								uncertpres := true							else								polyon := true;						end;					if polyon and uncertpres then						leave;				end;	end;{-----------------------------------------------------------------------------}	function Poly3InChar; {(ic : integer) : boolean}{FROZEN 3.0}{returns true if character has a polymorphism of 3 or more states in any included taxa.}{Used for user-defined types for warning messages and polyplus}		label			1;		var			it: integer;			tsts: LargestSetChars;	begin		poly3inchar := false;		for it := 1 to numtaxa do			if TaxonInTree(it) then				begin					tsts := GetTaxonStsLargest(it, ic);					if (cardLg(tsts) > 2) & not (UCl in tsts) then						begin							poly3inchar := true;							goto 1;						end;				end;1:	end;{-----------------------------------------------------------------------------}	function TaxonPolyFixancBeware (it: integer): boolean;{FROZEN 3.0}{This is only to be used for checking whether fixanc might give problems!!!!!!!!}		label			1;		var			ir: integer;			polys: boolean;			useset: largestsetchars;	begin		Polys := false;		for ir := 1 to numchars do			if CharIncluded(ir) then				begin					useset := gettaxonstsLargest(it, ir); { fisher added}					if (MultipleStatesLg(useset)) & not (UCl in useset) & (typeofchar(ir) <> fisher) then						begin							polys := true;							goto 1;						end;				end;1:		TaxonPolyFixancBeware := polys;	end;{==================================================================}{------------SHADING UTILITIES--------------------------------------------------}{-----------------------------------------------------------------------------}	procedure FindGrayScale (var usecolor: RGBColor; var cfound: boolean; var patsize, ir: integer);		var			position, j: integer;	begin{v4: give user the option to do it either way}		if GrayScaleStates <> [] then   {need to find out which element in GrayScaleStates ir is}			begin				position := -1;				for j := 0 to patsize - 1 do					if j in GrayScaleStates then						begin							position := position + 1;							if j = ir then								leave;						end;				if position >= 0 then					ir := position				else					begin						ir := 0;						newError(143, 0);						cfound := false;					end;				usecolor := GrayScale(CardLg(GrayScaleStates) - 1, ir)			end		else			usecolor := GrayScale(patsize, ir);	end;{-----------------------------------------------------------------------------}	procedure FindPat (var usepat: PATTERN; var usecolor: RGBColor; stc: largestsetchars; ic: integer; theTrace: integer); 			{finds color for stateset}			{if stateset has only one element}		var			ir: INTEGER;			patsize: integer;	begin		if ucl in stc then			usepat := uncert		else			usepat := polym;		usecolor := defcolor;		cfound := false;		if MonomorphLG(stc) then			begin				ir := minLg(stc);				if molecular then					patsize := maxstate+1				else if sameStateColorsForAllCharacters then					begin						if useMOSForSameColorsForAll then							patsize := MOS + 1   						else 							patsize := maxstate + 1    					end				else					patsize := CharMaxstDISPLAY(ic) + 1;				if patsize < 2 then					patsize := 2;				if ir >= patsize then					newError(1, 0)				else					begin						cfound := true;						if branchShades[theTrace] = branchGrayScale then							FindGrayScale(usecolor, cfound, patsize, ir)						else							usecolor := GetStateColor(patsize,ir);						if printon & printDataBoxesInColor then							usepat := QDBlack						else if (branchShades[theTrace] = branchPatterns) | not ColorPort then							usepat := pat[patkey^[patsize, ir]]						else							usepat := QDBlack;					end;			end;	end;{-----------------------------------------------------------------------------}	procedure FindSummaryPat (var usepat: PATTERN; var usecolor: RGBColor; maxvalue, ir: integer);	begin		if branchShades[curTrace] = branchPatterns then			usepat := pat[summarypat^[ir]]		else			usepat := QDBlack;		if branchShades[curTrace] = branchGrayScale then			usecolor := GrayScale(maxvalue, ir)		else			usecolor := summarycolors^[ir];	end;{==================================================================}{-----------------------------------------------------------------------------}	procedure SetFixon;		var			oldfixon: boolean;{FROZEN 3.0}{checks if there is fixed node}{called in TreeUtil (collapse clade)}		procedure InCheckFix (N: Nptr);		begin			if N^.fix then				fixon := true;			if not fixon & (N^.name = 0) then				begin					InCheckFix(N^.lf);					InCheckFix(N^.rt);				end;		end;	begin		oldfixon := fixon;		fixon := false;		InCheckFix(R);		if not fixon and oldfixon then			begin				FixLostByUndo := false;				StringToH('0', fixdataH);				dirtyfix := true;				myDisableItem(TraceMHdl, UnfixAllItem);			end;{no need to zap fixdataH since tree previously saved as default (with charfixedbit set) will get overwritten}{if we save again, thistime without charfixedbit set; tree previously saved for going to editor will not suffer change in fixing;}{tree saved for treecycling will not get changed by change in fixing; tree saved for undo will }	end;{-----------------------------------------------------------------------------}	procedure OffFix (zapfixdata: boolean); {FROZEN 3.0}{undoes fixing}{..............}		procedure inOffFix (var N: Nptr);		begin			N^.fix := FALSE;			if N^.name = 0 then				begin					inOffFix(N^.lf);					inOffFix(N^.rt);				end;		end;{..............}	begin		if fixon then			begin				godraw := true;				FixStateGoList;			end;		fixon := FALSE;		dirtyfix := true;		myDisableItem(TraceMHdl, UnfixAllItem);		if zapfixdata then			StringToH('0', fixdataH);		FixLostByUndo := false;		inOffFix(R);		InvalidateWindow(twmesswindow, false);	end;{-----------------------------------------------------------------------------}	procedure CheckConstantCharacters(icstart,icend: integer);{FROZEN 3.0}{scans through characters to see which ones are all missing or have all the same single state}{editor-based in editor; tree-based in tree}		var			charHdl: chHdl;			ic: integer;			charsts: LargestSetChars;	begin		for ic := icstart to icend do			begin				charsts := CharStatesLargest(ic);				charHdl := chHdlPtr(GetMaster(chCHUNKs) + HdlSize * longint(ic - 1))^;				charhdl^^.constant := (charsts = []) | (MonomorphLG(charsts));			end;	end;{-----------------------------------------------------------------------------}	function CharConstant (ic: integer): boolean;{FROZEN 3.0}		var			charHdl: chHdl;	begin		charHdl := chHdlPtr(GetMaster(chCHUNKs) + HdlSize * longint(ic - 1))^;		CharConstant := charHdl^^.constant;	end;{-----------------------------------------------------------------------------}	function CharMaxstDISPLAY (ic: integer): SignedByte;		var			charHdl: chHdl;			typnum: integer;	begin  {here max defined according to ic's type if is user-defined; otherwise use maxst}		typnum := typeofchar(ic);		if nucleotides then			CharMaxstDISPLAY := maxDNAstate		else if (typnum > dollo) & (typnum <= numtypes) then			CharMaxstDISPLAY := MaxStateDefined(typnum)		else			begin				charHdl := chHdlPtr(GetMaster(chCHUNKs) + HdlSize * longint(ic - 1))^;				CharMaxstDISPLAY := charHdl^^.maxst;			end;	end;{-----------------------------------------------------------------------------}	function CharMaxstDEF (ic: integer): SignedByte;		var			charHdl: chHdl;			typnum: integer;	begin  {here max defined according to ic's type if is user-defined; otherwise use maxst}		typnum := typeofchar(ic);		if (typnum > dollo) & (typnum <= numtypes) then			CharMaxstDEF := MaxStateDefined(typnum)		else if nucleotides then			CharMaxstDEF := maxDNAstate		else			begin				charHdl := chHdlPtr(GetMaster(chCHUNKs) + HdlSize * longint(ic - 1))^;				CharMaxstDEF := charHdl^^.maxst;			end;	end; {----------------------------------------------------------------------------}	function GetStateColor(maximumState, stateNumber: integer): RGBColor;	begin		 if nucleotides then			GetStateColor:= nucleotideColorKey^[stateNumber]		else if datatype=protein then			GetStateColor:= proteinColorKey^[stateNumber]		else			GetStateColor:= colorKey^[maximumState,stateNumber];	end; {----------------------------------------------------------------------------}	function GetStateSetColor(maximumState: integer; tsts: largestSetChars): RGBColor;	begin		GetStateSetColor:=GetStateColor(maximumState,MinLg(tsts));	end; {----------------------------------------------------------------------------}	function GetCellColor(ic: integer; tsts: largestSetChars): RGBColor;	var maximumState: integer;	begin		if molecular then			maximumState := maxstate+1		else if sameStateColorsForAllCharacters then			begin				if useMOSForSameColorsForAll then					maximumState := MOS + 1   				else 					maximumState := maxstate + 1    			end		else			maximumState := CharMaxstDISPLAY(ic)+1;		GetCellColor := GetStateSetColor(maximumState,tsts);	end; {-----------------------------------------------------------------------------}	procedure CalcNumCharIncluded;      			 {calculates how many characters included}{FROZEN 3.0}		var			ic: integer;	begin		numcharin := numchars;		for ic := 1 to numchars do			if not CharIncluded(ic) then				numcharin := numcharin - 1;	end;{--------------------------------------------------}	function Allexcluded: boolean;{FROZEN 3.0}	begin		AllExcluded := (numcharin = 0);	end;{-----------------------------------------------------------------------------}	function NextIncludedChar (ic: integer): integer;{FROZEN 3.0}{.....}		function LastIncludedChar: integer;			var				ij: integer;		begin			ij := numchars;			while (ij >= 1) & not CharIncluded(ij) do				ij := ij - 1;			LastIncludedChar := ij;		end;{.....}	begin		if (ic > numchars) then			ic := LastIncludedChar		else			begin				if (ic < 1) then					ic := 1;				while (ic <= numchars) & not CharIncluded(ic) do					ic := ic + 1;				if (ic > numchars) then					ic := LastIncludedChar;			end;		NextIncludedChar := ic;	end;{-----------------------------------------------------------------------------}	function PrevIncludedChar (ic: integer): integer;{FROZEN 3.0}{.....}		function FirstIncludedChar: integer;			var				ij: integer;		begin			ij := 1;			while (ij <= numchars) & not CharIncluded(ij) do				ij := ij + 1;			FirstIncludedChar := ij;		end;{.....}	begin		if (ic < 1) then			ic := FirstIncludedChar		else			begin				if (ic > numchars) then					ic := numchars;				while (ic >= 1) & not CharIncluded(ic) do					ic := ic - 1;				if (ic < 1) then					ic := FirstIncludedChar;			end;		PrevIncludedChar := ic;	end;{----------------------------------------------------------------------------}	procedure MaxStCalc (icstart, icend: integer);{FROZEN 3.0}{zeros high bits in cstatesP and finds maxst for each char; also updated MOS for whole file}		var			oldState: SignedByte;			charHdl: chHdl;			ic, tmaxst, tempMOS: INTEGER;			cstatesP: Ptr;			recalcAll: boolean;	begin		LockHandle(chstatesH, oldState);		if icstart < 1 then icstart := 1;		if icend > numchars then icend := numchars;		cstatesP := Ptr(GetMaster(chstatesH) + chsb * ord4(icstart - 1));		recalcAll := (icstart = 1) & (icend=numchars);		if recalcAll then  MOS := 1;		for ic := icstart to icend do			begin				ZeroHighBitsP(cstatesP);{David- Shouldn't maxst record the actual observed highest?  This gave me conniptions when}{I tried to apply Dollo characters in DNA data set.  Currently it is simply illegal, but not by design; since maxst is}{always 3, CharMaxstObs returns 3 and Dollo characters with two byte data files cannot be applied to character}{with more than 2 states.  Why not be honest at this stage, and later when asking other questions have functions}{that consider that nucleotide data files, for instance, must have all four states in legend?}{At any rate, perhaps I should prohibit Dollo characters for nucleotide files??}{Wayne- I would say just be honest here, as one could imagine applying a 2x2 usedef matrix to a position}{with just A and G}{David- Ok, but before getting rid of it, please try to remember if you did this out of principle or as a patch}{to prevent certain things from happening, etc.?}{Wayne- I can't remember what it was. sigh.  The only thing I can think of is that it had something to do with,}{say, chartwindow where we always want to show 4x4 matrix for changes & stasis, or traceon, where we always}{want to have all 4 elements in chleg, or something like that.  But I checked this out, and the only thing}{I could find this affected was the states chart, in which it will always show A C G T if this is enabled, otherwise}{only show those states present.  I suggest we leave this commented out until further notice.}				if nucleotides & (cardP(cstatesP, maxbit) = 0) then   {NOW:}					tmaxst := maxDNAstate				else if (datatype = protein) & (cardP(cstatesP, maxbit) = 0) then					tmaxst := maxproteinstate				else					begin						tmaxst := maxP(cstatesP, maxbit);						if (tmaxst < 1) or (tmaxst > maxstbit) then							tmaxst := 1;					end;				charHdl := getchHdl(ic);				charHdl^^.maxst := tmaxst;				if recalcAll then					if tmaxst > MOS then						MOS := tmaxst;				cstatesP := ptr(ord4(cstatesP) + chsb);			end;		ResetHandle(chstatesH, oldState);		if recalcAll then			dirtymaxst := false;		if infoOpen[charinfo] then			InvalidateWindow(infoWindow[charinfo], false);	end;{----------------------------------------------------------------------------}	procedure ReCalcEditorStatesH (icstart, icend: integer);{FROZEN 3.0}{this accumulates the observed states in all taxa in matrix into array; much like procedures in SetStates which differ}{in being tree-based}		var			it, ic: integer;			CstatesP: ptr;			taxstsHdl: Handle;			oldState: SignedByte;			tsts: largestsetchars;	begin		if icstart=icend then			begin				tsts := [];				for it := 1 to numtaxa do					tsts := tsts + gettaxonstslargest(it,icstart);  {high bits are removed}				LockHandle(chstatesH, oldState);				TransferStatesFromLargest(Ptr(GetMaster(chstatesH) + chsb * ord4(icstart - 1)), ZeroHighBitsLg(tsts));				ResetHandle(chstatesH, oldState);			end		else			begin				TaxStsHdl := gettaxstshdl(1);				CopyHandles(TaxStsHdl, chstatesH);				for it := 2 to numtaxa do					begin						TaxStsHdl := gettaxstshdl(it);						MergeHandles(TaxStsHdl, chstatesH, srcor);					end;				LockHandle(chstatesH, oldState);				cstatesP := Ptr(GetMaster(chstatesH));  {Now get rid of high bits}				for ic := 1 to numchars do					begin						ZeroHighBitsP(CstatesP);						cstatesP := Ptr(ord4(cstatesP) + chsb);					end;				ResetHandle(chstatesH, oldState);			end;	end;{----------------------------------------------------------------------------}	procedure ReCalcMaxstAndStates(icstart,icend: integer);{FROZEN 3.0}	begin		if icstart < 1 then icstart := 1;		if icend > numchars then icend := numchars;		ReCalcEditorStatesH(icstart,icend);		MaxstCalc(icstart, icend);		CheckConstantCharacters(icstart, icend);	end;{-----------------------------------------------------------------------------}	function CheckAAInMatrix (theAAs: aaset; calcTotal: boolean; var AAsFound: largestSetChars): boolean;		var			ic: integer;			CstatesP: ptr;			oldState: SignedByte;			sts: LargestSetChars;			found: boolean;	begin		if dirtymaxst then			ReCalcMaxstAndStates(1,numchars);		found := false;		AAsFound := [];				LockHandle(chstatesH, oldState);		cstatesP := Ptr(GetMaster(chstatesH));		for ic := 1 to numchars do			begin				sts := SetPointer31(cstatesP)^;				if theAAs * sts <> [] then					begin						found := true;												if calcTotal then 							AAsFound := AAsFound + theAAs*sts						else							leave;					end;				cstatesP := Ptr(ord4(cstatesP) + chsb);			end;		ResetHandle(chstatesH, oldState);		CheckAAInMatrix := found;	end;{-----------------------------------------------------------------------------}	procedure CalcStateFrequencies (itstart, itend, icstart, icend, topstate: integer);		var			TaxonHdl: thdl;			it, ic, k: integer;			tempset: largestsetchars;	begin		SetCursor(clockCursor);		for it := itstart to itend do			if TaxonInTree(it) then				begin					taxonHdl := gettaxonHdl(it);					HLock(Handle(taxonHdl));					with taxonHdl^^ do						begin							for k := 0 to maxstate do  {v3.01 changed from topstate to maxstate}								TipNumbers[k] := 0;							for ic := icstart to icend do								if charIncluded(ic) then									begin										tempset := GetTaxonStsLargest(it, ic);										if not (UCl in Tempset) then											for k := 0 to topstate do												if k in tempset then													TipNumbers[k] := TipNumbers[k] + 1;									end;						end;					HUnLock(Handle(taxonHdl));				end;	end;{----------------------------------------------------------------------------}	function CellVisible; {(cellTL,cellBR : point) : boolean}		var			cellB, visB: Rect;	begin		SetRect(CellB, cellTL.h, cellTL.v, cellBR.h + 1, cellBR.v + 1);		if ((cellTL.h = 0) or (cellTL.h = -1)) then			SetRect(visB, -1, editorOrigin.v, 1, editorOrigin.v + editorRows)		else if ((cellTL.v = 0) or (cellTL.v = -1)) then			SetRect(visB, editorOrigin.h, -1, editorOrigin.h + editorColumns, 1)		else			SetRect(visB, editorOrigin.h, editorOrigin.v, editorOrigin.h + editorColumns, editorOrigin.v + editorRows);		CellVisible := SectRect(cellB, visB, cellB);	end;{-----------------------------------------------------------------------------}	function ColorCharInChartsLegal: boolean;	begin		ColorCharInChartsLegal :=  ((sequencechart & (CWChart = CWCSteps)) | (CWChart = CWCC2T) | (CWChart = CWCC2TF)) & (catwid = 1) & ColorPort; {& ColorPort}	end;{-----------------------------------------------------------------------------}	function ColorCodPosLegal: boolean;	begin		ColorCodPosLegal := nucleotides & ColorCharInChartsLegal; {& ColorPort}	end;{-----------------------------------------------------------------------------}	procedure CheckForCodPos (checkForAll: boolean);{ if checkForAll is true, then checks for all booleans}{if false, then only checks for included booleans}		var			charHdl: chHdl;			ic, codpos: integer;	begin		if checkForAll then			begin				someCodPosSet := false;				someCoding := false;			end;		someCodPosSetIncluded := false;		someCodingIncluded := false;		for ic := 1 to numchars do			begin				charHdl := getchHdl(ic);				codpos := charHdl^^.codpos;				if checkForAll then					begin						if not someCoding then							if (codpos = 1) or (codpos = 2) or (codpos = 3) then								someCoding := true;						if not someCodPosSet then							if (codpos = 1) or (codpos = 2) or (codpos = 3) or (codpos = nonCoding) then								someCodPosSet := true;					end;				if not charhdl^^.deleted then					begin						if (codpos = 1) or (codpos = 2) or (codpos = 3) then							someCodingIncluded := true;						if (codpos = 1) or (codpos = 2) or (codpos = 3) or (codpos = nonCoding) then							someCodPosSetIncluded := true;					end;				if (not checkForAll | (someCoding & someCodPosSet)) & someCodingIncluded & someCodPosSetIncluded then					leave;			end;	end;{-----------------------------------------------------------------------------}	procedure PostCodPosChanged;	begin		codonPositionsChanged := true;		{InvalidateWindow(infoWindow[charinfo], false);		if ColorPort & SomeCodePosPartToColor & nucleotides then			InvalidateWindow(editorWindow, true);		if charton then			if ColorCodPosLegal then				InvalidateWindow(chartwindow, true)			else if positionchart and (CWChart = CWCSteps) then				ChangeCodonsGoList;		CheckForCodPos(true);		}	end;{-----------------------------------------------------------------------------}	procedure SetCodonPositions (icstart, icend, firstcodpos: integer; blastNonCode, restartAt1: boolean);		var			charHdl: chHdl;			startcodon, startcodpos, latercodpos, ic, oldic, cp: integer;	begin{v4: have option to base firstcodpos on codpos of character icstart-1}		if nucleotides then			begin				SetCursorToArrow;				startcodon := icstart;				cp := 0;				ic := icstart - 1;				while ic < icend do					begin						oldic := ic;						repeat							ic := ic + 1;							charHdl := GetchHdl(ic);							if not charHdl^^.coding then								if blastNonCode then									begin										charHdl^^.codpos := codeNotSet;{31March99 codonPos change: was codeNotSet}										charHdl^^.coding := true;									end								else									charHdl^^.codpos := nonCoding;						until (ic >= icend) | IsCoding(ic);						if (ic = oldic) or not IsCoding(ic) then  {how can ic = oldic?}							leave						else if (oldic + 1) <> ic then		{we must have skipped over one or more non-coding characters}							begin								startcodon := ic;								latercodpos := cp + 1;								if latercodpos > 3 then									latercodpos := latercodpos mod 3;							end;						charHdl := GetchHdl(ic);						if startcodon = icstart then							startcodpos := firstcodpos						else if restartAt1 then							startcodpos := 1						else							startcodpos := latercodpos;						cp := (ic - startcodon) mod 3 + startcodpos;						if cp > 3 then							cp := cp mod 3;						charHdl^^.codpos := cp;					end;				PostCodPosChanged;			end;	end;{$IFC FALSE}{-----------------------------------------------------------------------------}	procedure QuerySetCodPos;{Codon positions are set as follows: when a new nucleotide character is created, the global}	{boolean doQueryCodPos is set to true.  At the same time, the charHdl^^.codpos of this character}	{is set to codToQuery.  In the main event loop, if doQueryCodPos is true, then MacClade queries}	{the user as to what to do about these virgin nucleotides, by calling this procedure.}{a new nucleotide is created when AddNewCharacters or InsertNewCharacters is called (basically,}	{whenever FillCharacters is called), which also happens when a new data file is requested or }	{an old data file is read in, also when a data file is switched to a nucleotide format}{doQueryCodPos is set to false in the main event loop and when a CODONS block is read in.}		var			theDialog: DialogPtr;			tempP: WindowPtr;			prevCodPos, firstcodpos: integer;			forcecoding: boolean;			icend, icstart: integer;			singleblock: boolean;			ic: integer;			charHdl: chHdl;			doCalculate, doCoding, doNonCoding, restartAt1: boolean;			localItemHit: integer;{.........}		procedure CheckQueryCodPos;		begin			ItemCheckMark(theDialog, 3, firstcodpos = 1);			ItemCheckMark(theDialog, 4, firstcodpos = 2);			ItemCheckMark(theDialog, 5, firstcodpos = 3);			ItemCheckMark(theDialog, 6, doNonCoding);			ItemCheckMark(theDialog, 7, doCoding);			ItemCheckMark(theDialog, 8, doCalculate);		end;{.........}	begin		doCalculate := false;		doCoding := false;		doNonCoding := true;		singleblock := true;		icstart := -1;		icend := -1;		for ic := 1 to numchars do			begin				charHdl := getchHdl(ic);				if (icstart = -1) & (CharHdl^^.codpos = codToQuery) then  {start of first block that does not have codpos set}					icstart := ic				else if (icstart > -1) & (icend = -1) & (CharHdl^^.codpos <> codToQuery) then  {end of first block that does not have codpos set}					icend := ic - 1				else if (icstart > -1) and (icend > -1) and (CharHdl^^.codpos = codToQuery) then  {a new block!}					begin						singleblock := false;						leave;					end;			end;		if icend = -1 then			icend := numchars;		if SingleBlock then			begin				Beep;				dontCancelUpdate := true;				forcecoding := false;				firstcodpos := 0;				if (icstart = 1) and (icend = numchars) then					ParamText('All', '', '', '')				else					ParamText(StringFromNum(icend - icstart + 1), '', '', '');				if (icstart > 1) & CodPosSet(icstart - 1) then					begin						prevCodPos := CharCodPos(icstart - 1);						if prevCodPos = 3 then							firstcodpos := 1						else							firstcodPos := prevCodPos + 1;					end;				StartDLOG(128, theDialog, tempP);				CheckQueryCodPos;				myShowDialog(theDialog);				FrameButton(theDialog, 1);				repeat					ModalDialog(nil, localItemHit);					if localItemHit in [3, 4, 5] then						firstCodPos := localItemHit - 2;					if localItemHit in [3..9] then						begin							doNonCoding := localItemHit = 6;							doCoding := localItemHit = 7;							doCalculate := localItemHit in [3, 4, 5, 8, 9];							if doCalculate and (firstcodpos = 0) then								firstcodpos := 1;						end;					CheckQueryCodPos;				until localItemHit = 1;				EndDLOG(theDialog, tempP);				if doCalculate then					SetCodonPositions(icstart, icend, firstcodPos, true, false)				else					begin						if doCoding then							for ic := icstart to icend do								begin									charHdl := getchhdl(ic);									charHdl^^.codpos := codeNotSet;{31March99 codonPos change: was codeNotSet}									charHdl^^.coding := true;								end						else if doNonCoding then							for ic := icstart to icend do								begin									charHdl := getchhdl(ic);									charHdl^^.codpos := nonCoding;									charHdl^^.coding := false;								end;						if doCoding or doNonCoding then							CheckForCodPos(true);					end;			end		else			NewError(152, 0);	end;{$ENDC}{-----------------------------------------------------------------------------}	procedure SetLengths (cladeN: Nptr; mode: integer);  {This is called in ToolOnBranch}{..............}		procedure inSetLengths (var N: Nptr);		begin			case mode of				evolveSegmentsAllOneMode:					N^.setLength := 1;				evolveSegmentsRandomMode:					N^.setLength := RandomBetween(1, maxBranchLength);				evolveSegmentsUltraMetricMode:					N^.setLength := 2;				otherwise					N^.setLength := 1;			end;			if N^.name = 0 then				begin					inSetLengths(N^.lf);					inSetLengths(N^.rt);				end;		end;{..............}	begin		inSetLengths(cladeN);		if treeopen then			godraw := true;		if contweighted then			golist := golist + [GOcontinuous];		if (seglistenProb) then			begin{$IFC PROBRECONSTRUCT}				if traceshown = traceprobability then					golist := golist + [GOProbability];{$ENDC}{$IFC PROBSTEPCHART}				if charton and (CWChart = CWCProbSteps) then					golist := golist + [goProbStepsChart];{$ENDC}			end;	end;{-----------------------------------------------------------------------------}end.