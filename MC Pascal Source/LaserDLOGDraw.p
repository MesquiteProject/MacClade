unit LaserDLOGDraw;{еееееееееееееееееееееее}interface	uses		Printing, QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, TreeGet, Fonts, CharUtil, PrintingUtil, PrintingMisc, LaserTreeUtil, LaserDraw;	procedure DrawNoteIcons;	procedure DrawAngleBar;	procedure DrawAngleControl;	procedure DrawBullets (width: integer);	procedure WriteBottom (theDialog: DialogPtr; ds: str255);	procedure LaserUser (theDialog: DialogPtr; itemNo: INTEGER);	const		BWInterval = 8;{еееееееееееееееееееееее}implementation {е$S LaserDLOGDraw}	const		txspleft = 360;		txsptop = 50;{-----------------------------------------------------------------------------}	procedure DrawAngleBar;	begin		if laser^.treeshape[circletree] then			begin				PenSize(2, 2);				moveto(anglehor, anglever);				line(0, 30);				PenSize(1, 1);			end		else			begin				PenSize(2, 2);				moveto(anglehor, anglever);				line(20, 0);				PenSize(1, 1);			end;	end;{-----------------------------------------------------------------------------}	procedure DrawAngleControl;		var			box: rect;			angleToWrite: integer;	begin		SetRect(box, 14, 68 - 13, 14 + 26, 68);		if laser^.treeshape[circletree] then			begin				PenSize(2, 2);				moveto(anglehor, anglever);				lineto(anglehor - laser^.circleAnglePt.h, anglever - laser^.circleAnglePt.v);{ + 1}				angleToWrite := CalcAngle(laser^.circleanglept);			end		else			begin				PenSize(2, 2);				moveto(anglehor, anglever);				lineto(anglehor + laser^.nameAnglePt.h, anglever + laser^.nameAnglePt.v);{ - 1}				angleToWrite := 90 - CalcAngle(laser^.nameanglept);			end;		PenSize(1, 1);		FillOval(angleB, QDWhite);		FrameOval(angleB);		EraseRect(box);		moveto(box.left, box.bottom);		DrawString(StringFromNum(angleToWrite));		DrawChar('б');	end;{-----------------------------------------------------------------------------}	procedure DrawBullets (width: integer);		const			L = 30;			adj = 6;		var			box: rect;	begin		TextMode(srcxor);		with BranchWidthB do			begin				SetRect(box, left - 6, top - 2, left, otherBranchWidthB.bottom);				EraseRect(box);				if width <= 5 then					MoveTo(left - 6, top + BWInterval * width + adj)				else					MoveTo(otherBranchWidthB.left - 8, otherBranchWidthB.bottom - 2);				DrawChar('е');				SetRect(box, right, top - 2, right + 7, otherBranchWidthB.bottom);				EraseRect(box);				if width <= 5 then					MoveTo(right - 1, top + BWInterval * width + adj)				else					MoveTo(otherBranchWidthB.right + 1, otherBranchWidthB.bottom - 2);				DrawChar('е');				TextMode(srccopy);			end;	end;{-----------------------------------------------------------------------------}	procedure DrawBranchWidth (width: integer);		const			L = 30;	begin		with BranchWidthB do			begin {draw 1}{draw hairline}				PenPat(QDGray);				MoveTo(left + 7, top + 5);				Line(L, 0);{draw 1}				Move(-L, BWInterval);				PenPat(QDBlack);				Line(L, 0);{draw 2}				Move(-1, BWInterval);				PenSize(2, 2);				Line(-L + 1, 0);{draw 3}				Move(0, BWInterval);				PenSize(3, 3);				Line(L - 2, 0);{draw 4}				Move(-1, BWInterval);				PenSize(4, 4);				Line(-L + 3, 0);{draw 5}				Move(0, BWInterval);				PenSize(5, 5);				Line(L - 4, 0);{draw 6}				Move(-1, BWInterval);				PenSize(6, 6);				Line(-L + 5, 0);{draw 7+}				Move(0, BWInterval);				PenSize(6, 6);				Line(L - 5, 0);				PenSize(10, 6);				PenPat(QDWhite);				Move(-L div 2 + 1, 0);				Line(0, 3);				PenPat(QDBlack);				TextMode(srccopy);				Move(2, 3);				TextFont(kFontIDGeneva);				TextSize(9);				TextFace([bold]);				DrawChar('+');				TextFace([]);				TextFont(systemfont);				TextSize(0);				PenSize(1, 1);			end;		DrawBullets(width);	end;{----------------------------------------------------------------------------}	procedure WriteBottom (theDialog: DialogPtr; ds: str255);		var			box: rect;	begin		box := previewB;		box.bottom := WindowPortRect(myGetWindowPtrForDialog(theDialog)).bottom;		box.top := previewB.bottom + 6;		EraseRect(box);		MoveTo(previewB.left + 30, WindowPortRect(myGetWindowPtrForDialog(theDialog)).bottom);		TextFont(kFontIDGeneva);		TextSize(9);		DrawString(ds);		TextFont(SystemFont);		TextSize(0);	end;{-----------------------------------------------------------------------------}	procedure LaserUser (theDialog: DialogPtr; itemNo: INTEGER);		var			box: rect;			j: integer;			gRgn, pRgn: RgnHandle;			ds: str255;	begin		gRgn := NewRgn;		pRgn := NewRgn;		if PaintedBranches then			DrawBullets(laser^.tracewidth)		else			DrawBullets(laser^.width);		if PrinterOK or not LaserTreePrint then			FrameButton(theDialog, 1)		else			FrameButton(theDialog, 3);		if closeupon then			drawbox := previewb		else			drawbox := pictB;		InsetRect(previewB, -6, -6);		RectRgn(pRgn, drawbox);		RectRgn(gRgn, previewB);		DiffRgn(gRgn, pRgn, gRgn);		if WindowInColor(myGetWindowPtrForDialog(theDialog)) then			begin				RGBForeColor(GrayScale(5, 2));				FillRgn(gRgn, QDBlack);				RGBForeColor(blackRGB);			end		else			FillRgn(gRgn, QDGray);		FrameShadowRect(previewB);		InsetRect(previewB, 6, 6);		DrawAngleBar;		DrawAngleControl;{    DrawCommandIcons;}		box := GetDLOGITemBox(theDialog, LOptionsItem);		DrawPopUpRect(box, 'Options');		for j := 1 to numLaserCursors do			begin				InsetRect(LaserCursorR[j], -1, -1);				FrameRect(LaserCursorR[j]);				InsetRect(LaserCursorR[j], 1, 1);				EraseRect(LaserCursorR[j]);			end;		DropCursorH(tool^[treeTools,expandT].curs, LaserCursorR[laserMag].left + 2, LaserCursorR[laserMag].top + 3, srcOr);		DropCursor(ArrowCursor, LaserCursorR[laserarrow].left + 4, LaserCursorR[laserarrow].top + 3, srcOr);		DropCursorID(23847, LaserCursorR[laserruler].left + 3, LaserCursorR[laserruler].top + 3, srcOr);		DropCursorID(1499, LaserCursorR[laserFonts].left + 2, LaserCursorR[laserFonts].top + 3, srcOr);		InvertRect(LaserCursorR[LaserCursor]);		ClipRect(WindowPortRect(myGetWindowPtrForDialog(theDialog)));		if not (laser^.postscripton or laser^.treeshape[circletree]) then				begin		{dim taxon angle control}					SetRect(box, anglehor - 10, anglever - 45, anglehor + 40, anglever + 24);					DimBox(box);				end;		for j := 0 to numtreeshapes do			begin				InsetRect(laser^.treeshapeB[j], -1, -1);				FrameRect(laser^.treeshapeB[j]);				InsetRect(laser^.treeshapeB[j], 1, 1);				if laser^.treeshape[j] then					InvertRect(laser^.treeshapeB[j]);			end;		if (laser^.printbranchlengths) then			begin				DimBox(laser^.treeshapeB[slanttree]);				DimBox(laser^.treeshapeB[eurotree]);			end;		if ((traceshown = traceAllChanges) or (traceshown = traceDiscrete) or (traceshown = traceContinuous) or (traceshown = traceProbability)) then			DimBox(laser^.treeshapeB[circletree]);		ClipRect(WindowPortRect(myGetWindowPtrForDialog(theDialog)));		SetCursor(clockCursor);		if (frontwindow = myGetWindowPtrForDialog(theDialog)) then			begin				DrawTreePicture(fulltreeframe, true, false);				ClipRect(WindowPortRect(myGetWindowPtrForDialog(theDialog)));				if closeupon then					begin						ClipRect(drawbox);						box := fulltreeframe;						OffsetRect(box, pictB.left - closeuppt.h + (pictB.right - pictB.left) div 2, pictB.top - closeuppt.v + (pictB.bottom - pictB.top) div 2);						EraseRect(box);						FrameRect(box);						RectRgn(pRgn, box);						InsetRect(drawbox, 1, 1);						RectRgn(gRgn, drawbox);						InsetRect(drawbox, -1, -1);						DiffRgn(gRgn, pRgn, gRgn);						DrawPicture(treepicture, box);						if WindowInColor(myGetWindowPtrForDialog(theDialog)) then							begin								RGBForeColor(GrayScale(6, 2));								FillRgn(gRgn, QDBlack);								RGBForeColor(blackRGB);							end						else							FillRgn(gRgn, QDltGray);						FrameShadowRect(drawbox);					end				else					begin						EraseRect(drawbox);						DrawPicture(treepicture, pictB);						FrameShadowRect(drawbox);					end;			end;		TextFont(systemfont);		TextSize(0);		PenNormal;		ClipRect(drawbox);		if not closeupon then			begin				SetTreeSizeB(true);				for j := 0 to numlaserB do					if ReallyShowLegend(j) then						GrayOutline(LaserBoxes^[j].R, pator);			end;		ClipRect(WindowPortRect(myGetWindowPtrForDialog(theDialog)));		ZapRegion(pRgn);		ZapRegion(gRgn);		SetCursorToArrow;		if pleaseWriteBottom then			begin				with LaserBoxes^[treeB].R do					WriteBottom(theDialog, concat('width: ', StringFromNum(right - left), '  height: ', StringFromNum(bottom - top)));				pleaseWriteBottom := false;			end;	end;end.