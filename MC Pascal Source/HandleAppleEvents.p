unit HandleAppleEvents;{본본본본본본본본본본본볗interface	uses		Printing, QuickDraw, SegLoad, 		Types, Events, QuickDrawText, OSUtils, TextUtils, Errors, Finder, Controls, Menus, Files, 		Windows, Sound, Dialogs, TextEdit, Lists, ToolUtils, Memory, Fonts, Resources, Scrap, SegLoad, 		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, 		EventUtil, GenUtil, InfoWindows, GenOpenFile, DoPrint, MCWindows, GenCloseFile, FileMenu,		TaxaMenu;	procedure PostSettings;	procedure InstallAEEventHandlers;	procedure CreateAEEventHandlersUPPs;	procedure DestroyAEEventHandlersUPPs;	procedure DoHighLevelEvent (Event: EventRecord);	var{		HandleOAPPUPP: AEEventHandlerUPP;		HandleODOCUPP: AEEventHandlerUPP;		HandlePDOCUPP: AEEventHandlerUPP;		HandleQUITUPP: AEEventHandlerUPP;		HandleMacCladeCommandUPP: AEEventHandlerUPP;}		HandleOAPPUPP: AEEventHandlerUPP;		HandleODOCUPP: AEEventHandlerUPP;		HandlePDOCUPP: AEEventHandlerUPP;		HandleQUITUPP: AEEventHandlerUPP;{$SETC UseCarbonEvents = false}{$IFC UseCarbonEvents}		HandleEventUPP: EventHandlerUPP;{$ENDC}				AEEventUPPsCreated: boolean;{$SETC MCCommand=FALSE}{$IFC MCCommand}	const		kMacCladeClass = 'CLAD';    {0x434C4144}		KMacCladeCommandID = 'CLDc';   {0x434C4463}	var		HandleMacCladeCommandUPP: UniversalProcPtr;{$ENDC}{본본본본본본본본본본본볗implementation{$IFC REQAPPLEEVENTS}{-----------------------------------------------------------------------------}	procedure PostSettings;	begin		SetDataFormat(datatype, false);		if not twfullscreen then			WindowPop(true,true);		{if toolPaletteOpen[treeTools] then			SetLockLegPts(toolPaletteWindow[treeTools], -1);}	end;{----------------------------------------------------------------------------}	procedure ProcessAppleEventError (myErr: OsErr);		var			db: boolean;	begin		if myErr <> -1708 then  {it is not just an unsupported appleevent}			db := IOSuccessful(myErr);	end;{-----------------------------------------------------------------------------}	function MyGotRequiredParams (theAppleEvent: AppleEvent): OsErr;		var			returnedType: DescType;			actualSize: Size;			myErr: OSErr;	begin  {see p 6-47}		myErr := AEGetAttributePtr(theAppleEvent, keyMissedKeywordAttr, typeWildCard, returnedType, nil, 0, actualSize);		if myErr = errAEDescNotFound then			MyGotRequiredParams := noErr		else if myErr = noErr then			MyGotRequiredParams := errAEParamMissed		else			MyGotRequiredParams := noErr	end;{-----------------------------------------------------------------------------}	function HandleOpenFromFinder (docList: AEDescList): OSErr;		var			myerr: OsErr;			fileType: OSType;			theInfo: FInfo;			db: boolean;			myFSS: FSSpec;			index, itemsInList, numTextFiles: Longint;			actualSize: Size;			{helpIncluded: boolean;}			keywd: AeKeyword;			success:boolean;			returnedType: DescType;			localItemHit: integer;			importFileType : integer;			wasFileOpen,warnMultipleFiles,OKToImportSequences: boolean;			addAsNewSequences, saveCharSet,nameAsFile: boolean;			charSetName: str255;			userCancelled: boolean;	begin		wasFileOpen := fileOpen;		success := true;		addAsNewSequences:= true;		userCancelled := false;		saveCharSet:= false;		nameAsFile:= true;		charSetName := '';		importFileType := notAFileType;		warnMultipleFiles := true;		OKToImportSequences := true;		currentIOPosition := 110;		myErr := AECountItems(docList, itemsInList);		if myErr <> noErr then			ProcessAppleEventError(myErr);		numtextfiles := 0;		{helpIncluded := false;}		for index := 1 to itemsInList do			begin{see 6-78 for next procedure}				myErr := AEGetNthPtr(docList, index, typeFSS, keywd, returnedType, @myFSS, SizeOf(myFSS), actualSize);				currentIOPosition := 102;				if myErr <> noErr then					ProcessAppleEventError(myErr);				myErr := FSpGetFInfo(myFSS, theInfo);				fileType := theInfo.fdType;				if fileType = 'pref' then					begin						if not fileopen then							begin								FDI^[preferencesFDI].fs := myFSS;								if ReadNexusPreferencesFile then									PostSettings;							end						else							InstantError(426);					end				else if fileType = 'PICT' then					InstantError(167)				else if fileType = 'TEXT' then					begin						badfile := false;						if fileopen & not treeopen & molecular & OKToImportSequences & not errorFlag & (not FSpCreatorIsMacClade(myFSS) | allowCLADImportFromFinder) then							begin								if (importFileType=notAFileType) then									if not ImpSequenceFileTypeQuery(importFileType)then										OKToImportSequences := false									else if  not ((importFileType=sequenceOnly) |  QueryImportSequencesDLOG(importFileType, addAsNewSequences, saveCharSet,nameAsFile,  charSetName)) then										OKToImportSequences := false;																		if OKToImportSequences then									begin										FDI^[extraIOFileFDI].fs := myFSS;										if not ImportSequences(importFileType,addAsNewSequences, saveCharSet,nameAsFile,  charSetName) then											OKToImportSequences := false										else											warnMultipleFiles := false;									end;								if not errorflag then									numtextfiles := numtextfiles + 1;								errorFlag := false;							end						else if (numtextfiles = 0) then							begin								if not fileopen | (CWarning('MacClade allows only one data file open at once.  Do you want to close the currently open file and open the requested one?', 'Yes', 'Cancel') & QueryCloseFile(false)) then									begin										wasfileopen := false;										FDI^[datafileFDI].fs :=myFSS;										filename^^ := myFSS.name;										fileSaved := true;										currentIOPosition := 47;   {v3.05}										fileopen := true;										BeginFile(itemsInList=index,success, userCancelled);										if success then											numtextfiles := 1;									end;							end;					end;{myErr := OpenFSSpecFile(@myFSS);}{    currentIOPosition:= 103; if myErr <> noErr then ProcessAppleEventError(myErr);}			end;		if warnMultipleFiles then			if wasfileopen & (numtextfiles >= 1) then				InstantError(425)  			else if (numtextfiles > 1) then				localItemHit := DoAlert(FinderAlertID, StopA);		{if helpIncluded then			begin				if (numtextfiles = 0) and not fileopen then					InitValues;				ShowHelp(1);			end		else }		if (numtextfiles = 0) & not fileopen & isforeground & not userCancelled then			GetFile(userCancelled);		HandleOpenFromFinder := noErr;	end;{-----------------------------------------------------------------------------}	function HandleODOC (var theAppleEvent, reply: AppleEvent; handlerRefCon: longint): OsErr;{open document}		var			myerr: OsErr;			docList: AEDescList;	begin		myErr := AeGetParamDesc(theAppleEvent, keyDirectObject, typeAEList, docList);		currentIOPosition := 100;		if myErr <> noErr then			ProcessAppleEventError(myErr)		else 			begin				myErr := MyGotRequiredParams(theAppleEvent);				currentIOPosition := 101;				if myErr <> noErr then					HandleODOC := myErr				else					begin						HandleODOC := HandleOpenFromFinder(docList);					end;				myErr := AEDisposeDesc(docList);			end;	end;{-----------------------------------------------------------------------------}	function HandlePDOC (var theAppleEvent, reply: AppleEvent; handlerRefCon: longint): OsErr;{printing document}		var			myerr: OsErr;	begin		InstantInfo('MacClade cannot print files requested from the Finder.  Please first open the file in MacClade and then ask to print.');		HandlePDOC := noErr;{		myErr := MyGotRequiredParams(theAppleEvent);		currentIOPosition := 104;		if myErr <> noErr then			begin				ProcessAppleEventError(myErr);				HandlePDOC := myErr;			end		else			begin				InstantInfo('MacClade cannot print files requested from the Finder.  Please first open the file in MacClade and then ask to print.');				HandlePDOC := noErr;			end;}	end;{-----------------------------------------------------------------------------}	function HandleOAPP (var theAppleEvent, reply: AppleEvent; handlerRefCon: longint): OsErr;{open application}		var			myerr: OsErr;			{docList: AEDescList;}			userCancelled: boolean;	begin		myErr := MyGotRequiredParams(theAppleEvent);		currentIOPosition := 111;		if myErr <> noErr then			begin				ProcessAppleEventError(myErr);				HandleOAPP := myErr;			end		else			begin				GetFile(userCancelled);				HandleOApp := noErr; {HandleOpenFromFinder(docList)}			end;		{myErr := AEDisposeDesc(docList);}	end;{-----------------------------------------------------------------------------}	function HandleQUIT (var theAppleEvent, reply: AppleEvent; handlerRefCon: longint): OsErr;{quit application}		var			myerr: OsErr;			userCanceled: boolean;	begin		myErr := MyGotRequiredParams(theAppleEvent);		currentIOPosition := 105;		if myErr <> noErr then			begin				HandleQUIT := myErr;				//InstantInfo(StringFromNum(noErr));{error messages}			end		else			begin				if CheckQuitfromAppleEvent then					HandleQUIT := noErr				else					HandleQUIT := userCanceledErr			end;	end;{$IFC UseCarbonEvents}{-----------------------------------------------------------------------------}	function HandleModifierKeysChanged (inHandlerCallRef: EventHandlerCallRef; theAppleEvent: EventRef; handlerRefCon: longint): OsErr;	var		modifiers: UInt32;		result: OSStatus;    		optionWasDown : boolean;    		outtype, outsize: UInt32;	begin		result := eventNotHandledErr;		optionWasDown := false;		result := GetEventParameter(theAppleEvent,  kEventParamKeyModifiers, typeUInt32, outtype,  sizeof(UInt32), outsize, modifiers);			if result <> noErr then			begin				ProcessAppleEventError(result);				HandleModifierKeysChanged := result;			end		else			begin				Sysbeep(2);				HandleModifierKeysChanged := noErr; {HandleOpenFromFinder(docList)}			end;	end;{$ENDC}{$IFC FALSE}        if( ((modifiers & optionKey) == optionKey)            && (! optionWasDown) )        {            SpeakString( "\pdown" );            optionWasDown = true;        }        else if( optionWasDown )        {            SpeakString( "\pup" );            optionWasDown = false;        }    }	    return result;}{$ENDC}{$IFC MCCommand}{-----------------------------------------------------------------------------}	function HandleMacCladeCommand (var theAppleEvent, reply: AppleEvent; handlerRefCon: longint): OsErr;		var			ds: str255;			myErr: OSErr;			returnedType: DescType;			actualSize: Size;			found, db: boolean;			commandID: integer;			theResult: AEDesc;	begin		myErr := AEGetParamPtr(theAppleEvent, keyDirectObject, typeChar, returnedType, ptr(ord4(@ds) + 1), sizeof(str255), actualSize);{$R-}		if actualSize <= 255 then			ds[0] := chr(actualSize)		else			ds[0] := chr(255);		currentIOPosition := 1130;		if myErr = noErr then			begin				ProcessAppleEventError(myErr);				myErr := MyGotRequiredParams(theAppleEvent);				if myErr <> noErr then					ProcessAppleEventError(myErr);				{StringToCommandID(ds, commandID, found);				if found then					begin						AddNewCommand(commandID, nil);						DoWrittenCommands;					end;				}								InstantInfo(ds);				db := true;				myErr := AEPutParamPtr(reply, keyDirectObject, typeBoolean, @db, SizeOf(boolean));			end;		HandleMacCladeCommand := myErr;	end;{$ENDC}{-----------------------------------------------------------------------------}	function DoAEIsFileOpen (var theResult: AEDesc): OSErr;		var			descValue: integer;	begin		if fileopen then			descValue := 1		else			descValue := 0;		DoAEIsFileOpen := AECreateDesc('shor', @descValue, 2, theResult);	end;{-----------------------------------------------------------------------------}	procedure CreateAEEventHandlersUPPs;	begin  		HandleOAPPUPP := nil;		HandleODOCUPP := nil;		HandlePDOCUPP := nil;		HandleQUITUPP := nil;{$IFC UseCarbonEvents}		HandleEventUPP	:= nil;{$ENDC}{$IFC MCCommand}		HandleMacCladeCommandUPP := nil;{$ENDC}		{		HandleOAPPUPP := NewAEEventHandlerProc(@HandleOAPP);		HandleODOCUPP := NewAEEventHandlerProc(@HandleODOC);		HandlePDOCUPP := NewAEEventHandlerProc(@HandlePDOC);		HandleQUITUPP := NewAEEventHandlerProc(@HandleQUIT);		HandleMacCladeCommandUPP := NewAEEventHandlerProc(@HandleMacCladeCommand);}		HandleOAPPUPP := AEEventHandlerUPP(MyNewAEEventHandlerUPP(@HandleOAPP));		HandleODOCUPP := AEEventHandlerUPP(MyNewAEEventHandlerUPP(@HandleODOC));		HandlePDOCUPP := AEEventHandlerUPP(MyNewAEEventHandlerUPP(@HandlePDOC));		HandleQUITUPP := AEEventHandlerUPP(MyNewAEEventHandlerUPP(@HandleQUIT));{$IFC UseCarbonEvents}		HandleEventUPP := NewEventHandlerUPP(EventHandlerProcPtr(@HandleModifierKeysChanged));{$ENDC}{$IFC MCCommand}		HandleMacCladeCommandUPP := MyNewAEEventHandlerUPP(@HandleMacCladeCommand);{$ENDC}		AEEventUPPsCreated := true;	end;{-----------------------------------------------------------------------------}	procedure DestroyAEEventHandlersUPPs;	begin  		if AEEventUPPsCreated then			begin				MyDisposeAEEventHandlerUPP(UniversalProcPtr(HandleOAPPUPP));				MyDisposeAEEventHandlerUPP(UniversalProcPtr(HandleODOCUPP));				MyDisposeAEEventHandlerUPP(UniversalProcPtr(HandlePDOCUPP));				MyDisposeAEEventHandlerUPP(UniversalProcPtr(HandleQUITUPP));{$IFC UseCarbonEvents}				MyDisposeAEEventHandlerUPP(UniversalProcPtr(HandleEventUPP));{$ENDC}{$IFC MCCommand}				MyDisposeAEEventHandlerUPP(HandleMacCladeCommandUPP);{$ENDC}			end;	end;{-----------------------------------------------------------------------------}	procedure InstallAEEventHandlers;		var			myErr: osErr;{$IFC UseCarbonEvents}			eventHandlerReference:  EventHandlerRef;   			eventTypes : EventTypeSpec;          			theTarget :  EventTargetRef;{$ENDC}	begin  		myErr := AEInstallEventHandler(kCoreEventClass, KAEOpenApplication,HandleOAPPUPP, 0, false);		currentIOPosition := 106;		if myErr <> noErr then			ProcessAppleEventError(myErr);		myErr := AEInstallEventHandler(kCoreEventClass, KAEOpenDocuments,HandleODOCUPP, 0, false);		currentIOPosition := 107;		if myErr <> noErr then			ProcessAppleEventError(myErr);		myErr := AEInstallEventHandler(kCoreEventClass, KAEPrintDocuments, HandlePDOCUPP, 0, false);		currentIOPosition := 1071;		if myErr <> noErr then			ProcessAppleEventError(myErr);		myErr := AEInstallEventHandler(kCoreEventClass, KAEQuitApplication, HandleQUITUPP, 0, false);		currentIOPosition := 108;		if myErr <> noErr then			ProcessAppleEventError(myErr);			{$IFC UseCarbonEvents}		theTarget := GetApplicationEventTarget;		eventTypes.eventClass := kEventClassKeyboard;                eventTypes.eventClass := kEventRawKeyModifiersChanged;		myErr := 	InstallEventHandler(theTarget,HandleEventUPP,1,eventTypes, nil,nil);		currentIOPosition := 1081;		if myErr <> noErr then			ProcessAppleEventError(myErr);{$ENDC}{$IFC MCCommand}		currentIOPosition := 1091;		myErr := AEInstallEventHandler(kMacCladeClass, KMacCladeCommandID, HandleMacCladeCommandUPP, 0, false);		currentIOPosition := 1092;		if myErr <> noErr then			ProcessAppleEventError(myErr);		currentIOPosition := 1093;{$ENDC}	end;	{----------------------------------------------------------------------------}	procedure DoHighLevelEvent (Event: EventRecord);		var			myErr: OsErr;	begin		myErr := AEProcessAppleEvent(Event);  	{this determines the type of event and passes off to the procedures }													{defined in InstallAEEventHandlers}		currentIOPosition := 1091;		if (myErr <> noErr) & (myErr <> userCanceledErr) then			ProcessAppleEventError(myErr);	end;{$ENDC}end.