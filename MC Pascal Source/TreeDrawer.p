unit TreeDrawer;{еееееееееееееееееееееее}interface	uses		QuickDraw, Printing,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, 		Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, 		EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, SymbolsNames, CharUtil, MenuUtil, TreeUtil, 		SpreadUtil, Legends, Coloring, N7on, InfoWindows, BranchListWindow;	procedure OutlinePoly (N: Nptr);	procedure Nex7OnOff (turnonnex7: boolean);	procedure DrawTree;	procedure DrawTreeWindow;{еееееееееееееееееееееее}implementation {е$S TreeDrawer} // var drawTaxonNamesInTree: boolean;{$IFC SHADOWTREE}{-----------------------------------------------------------------------------}	procedure ShadowPoly (N, aN: Nptr); {v4: not converted to fliptree}	begin		if ColorPort then			begin				Pensize(1, 1);				RGBForeColor(GrayScale(4, 3));				if NodeSlantsRight(N) then					begin						if N = ScreenR then							begin								MOVETO(aN^.loc.h, aN^.loc.v + 1);								LINETO(aN^.loc.h + edw, aN^.loc.v + 1);							end						else							MOVETO(aN^.loc.h + edw, aN^.loc.v);						LINETO(N^.loc.h + edw, N^.loc.v);						RGBForeColor(GrayScale(6, 2));						if N = ScreenR then							begin								MOVETO(aN^.loc.h + 1, aN^.loc.v + 2);								LineTo(aN^.loc.h + edw - 1, aN^.loc.v + 2);							end						else							MOVETO(aN^.loc.h + edw + 1, aN^.loc.v);						Pensize(2, 1);						LINETO(N^.loc.h + edw + 1, N^.loc.v);					end				else					begin						if N = ScreenR then							begin								RGBForeColor(GrayScale(6, 2));								MOVETO(aN^.loc.h + edw - 1, aN^.loc.v + 1);								LineTo(aN^.loc.h, aN^.loc.v + 1);								RGBForeColor(GrayScale(4, 3));							end						else							MOVETO(aN^.loc.h - 1, aN^.loc.v);						LINETO(N^.loc.h, N^.loc.v + 1);					end;				RGBForeColor(blackRGB);			end;	end;{$ENDC}{-----------------------------------------------------------------------------}	procedure OutlinePoly (N: Nptr);		var			aN: Nptr;	begin		aN := NotNullanc(N);{$IFC SQUAREBRANCHES}		if squarebranches then			begin				PenSizeOrient(1, 2);				MoveToOrient(aN^.loc.h, aN^.loc.v - 1);				LineToOrient(N^.loc.h, aN^.loc.v - 1);{$IFC FLIPTREE}				if not treeflipped then {$ENDC}					MoveOrient(0, 1);			end		else			MoveToOrient(aN^.loc.h, aN^.loc.v);{$ELSEC}		MoveToOrient(aN^.loc.h, aN^.loc.v);{$ENDC}		if not N^.fixanc or (NodeIsInternal(N)) then			{if (traceShown=traceAllChanges) & (summaryview=asticks) then				PenSizeOrient(1,1)			else				}PenSizeOrient(edw, 1);		LineToOrient(N^.loc.h, N^.loc.v);		Penpat(QDBlack);{$IFC SHADOWTREE}		if shadowTree then			ShadowPoly(N, aN);{$ENDC}		PenSizeOrient(1, 1);		if (NodeIsTerminal(N)) then			begin				MoveToOrient(N^.loc.h, N^.loc.v);				LineToOrient(N^.loc.h + edw - 1, N^.loc.v);			end;	end;{-----------------------------------------------------------------------------}	procedure CondenseTreeOnScreen (N: Nptr);{adjusts positions to take into account null nodes}		var			aN: Nptr;			minNodes,maxNodes: longint;	begin		if NodeIsInternal(N) then			begin				CondenseTreeOnScreen(N^.lf);				CondenseTreeOnScreen(N^.rt);								if N^.null then					aN := NotNullAnc(N) 				else					aN := N;				NodesFromTop(aN, minnodes, maxnodes,false);				if treeScaleVert<> 1.0 then 					N^.loc.v := longint(topmargin)+RoundValue(vertTxsp*(maxnodes)*treeScaleVert)				else					N^.loc.v := longint(topmargin)+vertTxsp*(maxnodes);			end;				end;{-----------------------------------------------------------------------------}	procedure CalcNodeLocs (N: Nptr);	begin		if NodeIsInternal(N) then			begin				CalcNodeLocs(N^.lf);				CalcNodeLocs(N^.rt);{$IFC SQUAREBRANCHES}				if squareBranches & (treeScaleVert <> 1.0) then					begin						N^.loc.h := RoundValue((N^.lf^.loc.h + N^.rt^.loc.h + (N^.rt^.loc.v - N^.lf^.loc.v) / treeScaleVert) / 2);						N^.loc.v := RoundValue(((-N^.lf^.loc.h + N^.rt^.loc.h) * treeScaleVert + N^.lf^.loc.v + N^.rt^.loc.v) / 2);					end				else{$ENDC}					begin						N^.loc.h := (N^.lf^.loc.h + N^.rt^.loc.h - N^.lf^.loc.v + N^.rt^.loc.v) div 2;						N^.loc.v := (-N^.lf^.loc.h + N^.rt^.loc.h + N^.lf^.loc.v + N^.rt^.loc.v) div 2;					end;			end;	end;{-----------------------------------------------------------------------------}	procedure AdjustBranch (N, ancN: Nptr; theLength: longint);	var dL : longint;	begin		if N^.null then			N^.loc.v := NotNullAnc(N)^.loc.v		else			N^.loc.v := ancN^.loc.v - RoundValue(theLength * branchLengthSpacing) - screenExtraBranchLength;	end;{-----------------------------------------------------------------------------}	procedure AdjustBranchLengths (var N: Nptr);{adjusts vertical positions of nodes if branch lengths shown}	begin		if NodeIsInternal(N) then			begin				AdjustBranch(N^.lf, N, BranchLengthLongint(N^.lf, branchLengthsWeighted));				AdjustBranch(N^.rt, N, BranchLengthLongint(N^.rt, branchLengthsWeighted));				AdjustBranchLengths(N^.lf);				AdjustBranchLengths(N^.rt);			end		else			AdjustBranch(N, NotNullAnc(N), BranchLengthLongint(N, branchLengthsWeighted))	end;{-----------------------------------------------------------------------------}	var		branchLengthsAdjuster: longint;{-----------------------------------------------------------------------------}	procedure HighestTerminalTaxon (var N: Nptr);{adjusts vertical positions of nodes if branch lengths shown}		var			it: integer;			topTaxon: longint;			taxNode: Nptr;	begin		topTaxon := N^.loc.v;		for it := 1 to numtaxa do			begin				taxNode := GetTaxonHdl(it)^^.N;				if TaxonInTree(it) & IsAnc(screenR, taxNode) then					begin						if topTaxon > taxNode^.loc.v then							topTaxon := taxNode^.loc.v;					end;			end;		branchLengthsAdjuster := topTaxon - topmargin;	end;{-----------------------------------------------------------------------------}	procedure AdjustBranchPositions (var N: Nptr);{adjusts vertical positions of nodes if branch lengths shown}	begin		if NodeIsInternal(N) then			begin				AdjustBranchPositions(N^.lf);				AdjustBranchPositions(N^.rt);			end;		N^.loc.v := N^.loc.v - branchLengthsAdjuster;	end;{$IFC TRUE}{-----------------------------------------------------------------------------}	procedure AdjustNodeLocs (N: Nptr);	begin		if NodeIsInternal(N) then			begin				AdjustNodeLocs(N^.lf);				AdjustNodeLocs(N^.rt);				N^.loc.h := (farthestright(N) + farthestleft(N)) div 2;			end;	end;{-----------------------------------------------------------------------------}	function CalcLeftOfClade (N: Nptr): integer;{Calculates leftmost position in clade, for a clade in which N^.locs have not yet been set}		label			1;		var			numLeft: integer;{........}		procedure TaxaToTheLeft (pN: Nptr);		begin			if pN = N then				goto 1;			if NodeIsTerminal(pN) then				numLeft := numLeft + 1			else				begin					TaxaToTheLeft(pN^.lf);					TaxaToTheLeft(pN^.rt);				end;		end; {............}	begin		numLeft := 0;		TaxaToTheLeft(screenR);1:		CalcLeftOfClade := firstTx + txsp * numLeft;	end;{$ENDC}{-----------------------------------------------}	procedure GoUpDrawDownRec (N: Nptr);	begin		if NodeIsInternal(N) then			begin				GoUpDrawDownRec(N^.lf);				GoUpDrawDownRec(N^.rt);				if not N^.lf^.null then					OutlinePoly(N^.lf);				if not N^.rt^.null then					OutlinePoly(N^.rt);			end;	end;{-----------------------------------------------}	procedure GoUpDrawDown (N: Nptr);  {tree traversal to draw edges}	begin		if SquareBranches & centerSquareBranches then			AdjustNodeLocs(N);		GoUpDrawDownRec(N);		treedrawn := true;	end;{-----------------------------------------------------------------------------}{$IFC FALSE}	procedure TerminalTaxaLocs (N: Nptr);		var			TaxonHdl: thdl;			trect: rect;{........}		procedure TermTaxaRec (N: Nptr);			{tree traversal to find locations}		begin			if NodeIsTerminal(N) then				begin					N^.loc.h := lasttx;					lasttx := txsp + lasttx;					N^.loc.v := topmargin;					TaxonHdl := gettaxonHdl(N^.name);					SETRECT(trect, N^.loc.h, N^.loc.v - 8, N^.loc.h + boxedw, N^.loc.v - 1);					taxonHdl^^.B := trect;				end			else				begin					TermTaxaRec(N^.lf);					TermTaxaRec(N^.rt);				end;		end; {............}	begin		lasttx := firstDrawTx;		TermTaxaRec(N);	end;{$ENDC}{-----------------------------------------------------------------------------}	procedure TerminalTaxaLocs (N: Nptr);{........}		procedure TermTaxaRec (N: Nptr);			{tree traversal to find locations}		begin			if NodeIsTerminal(N) then				begin					N^.loc.h := lasttx;					lasttx := txsp + lasttx;					N^.loc.v := topmargin;				end			else				begin					TermTaxaRec(N^.lf);					TermTaxaRec(N^.rt);				end;		end; {............}	begin		lasttx := firstDrawTx;		TermTaxaRec(N);	end;{-----------------------------------------------------------------------------}	procedure ReorderTaxa (cladeN: Nptr);  {just draws taxon names}		var			TaxonHdl: thdl;			taxname: strTaxName;			it: integer;			dL: longint;			dh, dv: longint;			box: rect;			oldState1, oldState2: SignedByte;	begin		lasttx := firstDrawTx;		TextFont(treetaxafont);		TextSize(treetaxafontsize);		TextFace(treetaxastyle);		LockHandle(taxonCHUNKs, oldstate1);		dL := GetMaster(taxonCHUNKs);		for it := 1 to numtaxa do			begin				TaxonHdl := THdlPtr(dL + HdlSize * (it - 1))^;				LockHandle(TaxonHdl, oldstate2);				with TaxonHdl^^ do					if (numtaxa = numtaxain) | not deleted then						begin							if (cladeN = R) | IsAnc(cladeN, N) then   {it's in clade}								begin									if (tiplabel = tipState) and (traceshown = traceDiscrete) then										taxname := CopyString(StsToString(GetTaxonStsLargest(it, i), i, true,true), 1, tnw - 1)									else if tipLabel = tipTaxNum then										taxname := StringFromNum(it)									else										begin											taxname := name;											if footPict then												if length(taxname) = tnw then													taxname[tnw] := FootPictFlag												else													taxname := concat(taxname, FootPictFlag);											if footText then {| ((traceshown = traceDiscrete) & footpresent(it, i))}												if length(taxname) = tnw then													if footPict then														taxname[tnw - 1] := FootTextFlag													else														taxname[tnw] := FootTextFlag												else													taxname := concat(taxname, FootTextFlag);										end;									if isItalic & (tipLabel = tipTaxa) then										TextFace(treetaxastyle + [italic]);{$SETC HORIZTEXT=FALSE}{$IFC HORIZTEXT}									if horizTaxNames then										begin																						MoveToOrient(N^.loc.h + edw - StringWidth(taxname) div 2 - 2, N^.loc.v - 10);											DrawString(taxname);  {orient: note not oriented}										end									else										begin											MoveToOrient(N^.loc.h + edw - 2, N^.loc.v - 10);											VerticalStringOrient(taxname);										end;{$ELSEC}									dh := N^.loc.h;									dv := N^.loc.v;									MoveToOrient(N^.loc.h + edw - 2, N^.loc.v - 10);//									if drawTaxonNamesInTree then										VerticalStringOrient(taxname);//CallWaitNextEventForDrawing;{$IFC FALSE}									if InfoRowSelected (taxinfo, it) then										begin											SetRect(box,N^.loc.h - 2, N^.loc.v - 10-StringWidth(taxname)-2,N^.loc.h + FontHeight-1,  N^.loc.v - 8);											InvertRect(box);										end;{$ENDC}{$ENDC}									TextFace(treetaxastyle);								end;						end;				ResetHandle(TaxonHdl, oldstate2);			end;		ResetHandle(taxonCHUNKs, oldstate1);	end;{-----------------------------------------------------------------------------}	procedure PutBackTaxa;  {when CharInfo or next 7 turned off, this redraws the taxa}	begin		nex7on := false;		databoxB.bottom := dataBoxB.bottom + 1;		eraserectOrient(dataBoxB);		eraserect(claspRect);		databoxB.bottom := dataBoxB.bottom - 1;		ResetForNextTree;		TerminalTaxaLocs(screenR);		TerminalTaxaBoxes(screenR, false);		ReorderTaxa(ScreenR);		textfont(TWFont);		textsize(TWFontSize);	end;{-----------------------------------------------------------------------------}	procedure Nex7OnOff (turnonnex7: boolean);		var			tport: windowptr;	begin		genericGetPort(tport);		genericSetPort(treewindow);		if (turnonnex7 <> nex7on) then			begin				nex7on := turnonnex7;				if nex7on then					begin						CheckPixelDepth(treewindow);    {v3.02: this makes sure nex7on does not come up in wrong branchshades}						if OptionEvent(Event) or (i7 = 0) then							begin								i7 := i;								if i7 < 1 then									i7 := 1;							end;						if (traceshown = traceAllChanges) & squarebranches & showbranchlengths then							godraw := true;   {v3.02: }						InitNumBoxes;						ResetRects;						if numchars <= numboxes then							i7 := 1;						NextSevenChars;						databoxBHeight := (databoxB.bottom - TWorigV);						genericSetPort(treewindow);						myValidRect(treeWindow,WindowPortRect(treeWindow));					end				else					begin						if (displace7 <> 0) or (TWOrigin.v <> 0) or PaintedBranches then  {painted branches as might be some boxes to redraw}							begin								godraw := true;							end;						displace7 := 0;						databoxBHeight := 0;						TWOrigin.v := 0;						ResetTop;						if not godraw then							PutBackTaxa;{    if (currentTool[treeTools] = handt) and ((GetControlMaximumLong(hTWScroll) = GetControlMinimumLong(hTWScroll)) and (GetControlMaximumLong(vTWScroll) = GetControlMinimumLong(vTWScroll))) then SetTool(treeTools,arrowT);}					end;				SetTWScrollMax;				VertTWScrollPosition;				DropTool(treeTools,handT);			end;		genericSetPort(tport);		myCheckMenuItem(ShowMHdl, Nex7OnItem, nex7on);	end;{-----------------------------------------------------------------------------}	procedure EraseClade;		var			txright: integer;			cladepoly: Polyhandle;			theInfo: FontInfo;{$IFC SQUAREBRANCHES}			box: rect;			adj: integer;{$ENDC}	begin{firstDrawTx now calculated in DrawTree}		Textsize(treetaxafontsize);		TEXTFONT(treetaxafont);		GetFontInfo(theInfo);		Textsize(TWFontSize);		TEXTFONT(TWFont);{$IFC SQUAREBRANCHES}		if squarebranches then			begin				if theInfo.ascent > 10 then					adj := (edw - theInfo.ascent - 2)				else					adj := -2;				SetRect(box, firstDrawTx + adj, 0, RightEdgeOfClade(DrawR,false, false), DrawRloc.v + 1);				if drawR = screenR then					box.bottom := WindowPortRect(treeWindow).bottom;   {v3.02: this takes care of problems with showbranchlengths trees}				EraseRectOrient(box);			end		else			begin				txright := DrawRloc.h + DrawRloc.v - topmargin + natedw;				CladePoly := Openpoly;				MoveToOrient(DrawRloc.h - 1, DrawRloc.v);				LineToOrient(firstDrawTx - 2, topmargin);				if theInfo.ascent > 10 then					begin						LineToOrient(firstDrawTx + (edw - theInfo.ascent - 2), topmargin);   {lineto(firstDrawTx - 2, topmargin)}						LineToOrient(firstDrawTx + (edw - theInfo.ascent - 2), 0);					end				else if nex7on then					begin						LineToOrient(firstDrawTx - 1, topmargin);						LineToOrient(firstDrawTx - 1, 0);					end				else					LineToOrient(firstDrawTx - 2, 0);				LineToOrient(txright + theInfo.descent, 0);{was +2}				LineToOrient(txright + theInfo.descent, topmargin);{was +2}				LineToOrient(DrawRloc.h + natedw + 2, DrawRloc.v);				ClosePoly;				ErasePoly(cladepoly);				KillPoly(cladepoly);			end;{$ELSEC}		txright := DrawRloc.h + DrawRloc.v - topmargin + natedw;		CladePoly := Openpoly;		MoveToOrient(DrawRloc.h - 1, DrawRloc.v);		LineToOrient(firstDrawTx - 2, topmargin);		if theInfo.ascent > 10 then			begin				LineToOrient(firstDrawTx + (edw - theInfo.ascent - 2), topmargin);   {lineto(firstDrawTx - 2, topmargin)}				LineToOrient(firstDrawTx + (edw - theInfo.ascent - 2), 0);			end		else if nex7on then			begin				LineToOrient(firstDrawTx - 1, topmargin);				LineToOrient(firstDrawTx - 1, 0);			end		else			LineToOrient(firstDrawTx - 2, 0);		LineToOrient(txright + theInfo.descent, 0);{was +2}		LineToOrient(txright + theInfo.descent, topmargin);{was +2}		LineToOrient(DrawRloc.h + natedw + 2, DrawRloc.v);		ClosePoly;		ErasePoly(cladepoly);		KillPoly(cladepoly);{$ENDC}	end;{-----------------------------------------------------------------------------}	procedure ZeroBoxes (N: Nptr);{zeros size and location of boxes for all terminal taxa which are in}{tree but which are outside of screenR}		var			TaxonHdl: thdl;			trect: rect;	begin		if (NodeIsInternal(N)) then			begin				if (N <> ScreenR) then					begin						ZeroBoxes(N^.lf);						ZeroBoxes(N^.rt);					end;			end		else			begin				TaxonHdl := gettaxonHdl(N^.name);				SETRECT(trect, 0, 0, 1, 1);				taxonHdl^^.B := trect;			end;	end;{-----------------------------------------------------------------------------}{-----------------------------------------------------------------------------}	procedure DrawTree;		var			aN: Nptr;			dClip: RgnHandle;			oldDrawRlocV, extraRoot: longint;			box: rect;	begin	//		drawTaxonNamesInTree := not (OptionDown & ControlDown);				if (DrawR <> ScreenR) & (((traceshown = traceAllChanges) & squarebranches & showbranchlengths) | showEvolveSegments | (squarebranches & (centerSquareBranches|condensedBranches)) | ((traceshown = traceAllChanges) & (summaryview in [asticks, asLengthNum])) | (((traceshown = traceDiscrete) & showtracelabels) | ((traceshown = traceContinuous) & showconttracelabels)) | ((traceshown = traceProbability) & 			showProbtracelabels) | ((traceshown = traceDiscrete) & (fixon & showfix))) then			begin				DrawR := ScreenR; {always redraw whole screen when asticks or aslengthnum}				DrawRloc := DrawR^.loc;			end;		ResetForNextTree;{==== calculate node positions ====}		if DrawR = ScreenR then			firstDrawTx := firstTx		else{$IFC SQUAREBRANCHES}			if squareBranches & (centerSquareBranches | condensedBranches | ((traceshown = traceAllChanges) & showbranchlengths)) then				firstDrawTx := CalcLeftOfClade(DrawR)				else if squareBranches & (treeScaleVert <> 1.0) then					firstDrawTx := DrawRloc.h - RoundValue((DrawRloc.v - topmargin) / treeScaleVert)				else					firstDrawTx := DrawRloc.h - (DrawRloc.v - topmargin);{$ELSEC}		firstDrawTx := DrawRloc.h - (DrawRloc.v - topmargin);{$ENDC}		ZeroBoxes(R);		TerminalTaxaLocs(DrawR);		CalcNodeLocs(DrawR);		if (traceshown = traceAllChanges) & showbranchLengths & squarebranches then			begin				oldDrawRlocV := screenR^.loc.v;{    CalcBranchLengthSpacing;}				AdjustBranchLengths(ScreenR);				HighestTerminalTaxon(ScreenR);{    branchLengthsAdjuster := screenR^.loc.v - (treeChangeHeight(screenExtraBranchLength) * branchLengthSpacing - topmargin);}				AdjustBranchPositions(screenR);{    Treeheight := IntegerMax(80, taxonheight + 22) + screenR^.loc.v - topmargin + screenR^.length1 * branchLengthSpacing + 20;}{    SetControlMaximumLong(vTWScroll, GetControlMaximumLong(vTWScroll) + DrawR^.loc.v - oldDrawRlocV);}{drawTWR.bottom := drawTWR.top + treeheight;}				SetTWScrollMax;			end		else if SquareBranches & condensedBranches then			CondenseTreeOnScreen(screenR);		TerminalTaxaBoxes(DrawR, false);		{==== prepare clips and erase old subtree ====}		SetClip(TWClip);		dClip := NewRgn;		RectRgn(dClip, OrientRect(treerect));		SectRgn(dClip, TWClip, dClip);		SetClip(dClip);		if DrawR = ScreenR then			begin				box := visTWR;  {//\\ changed from drawTWR: check for issues}				box.bottom := WindowPortRect(treeWindow).bottom;  {v3.02: for showbranchlengths}				EraseRectOrient(box);			end		else			EraseClade;		if nex7on then			SetClip(dClip);{====  draw taxon names ====}		ReorderTaxa(DrawR);		if nex7on then			SetClip(dClip)		else			SetClip(TWClip);{==== draw branches ====}		Textsize(TWFontSize);		TEXTFONT(TWFont);		GoUpDrawDown(DrawR);		aN := NotNullAnc(DrawR);		if squarebranches & (traceshown = traceAllChanges) & showbranchlengths then			if screenR^.length1 <= 0 then				rootsize := screenExtraBranchLength			else if branchlistmode = minmaxmode then				rootsize := screenR^.length2 * branchLengthSpacing			else				rootsize := screenR^.length1 * branchLengthSpacing		else{    if ScreenR <> R then    rootsize := 400 else}			rootsize := defRootSize;		if DrawR = ScreenR then			begin				aN^.loc.v := ScreenR^.loc.v + rootsize;{$IFC SQUAREBRANCHES}				if squarebranches then					aN^.loc.h := ScreenR^.loc.h				else if NodeSlantsRight(ScreenR) then					aN^.loc.h := ScreenR^.loc.h - rootsize				else					aN^.loc.h := ScreenR^.loc.h + rootsize;{$ELSEC}				if NodeSlantsRight(ScreenR) then					aN^.loc.h := ScreenR^.loc.h - rootsize				else					aN^.loc.h := ScreenR^.loc.h + rootsize;{$ENDC}			end;		OutlinePoly(DrawR);{$IFC TRUE}		if (screenR <> R) & (drawR = screenR) then {v3.02: added}{squarebranches & (traceshown = traceAllChanges) & showbranchlengths &}			begin				PenSize(1, 1);				if squarebranches then					PenPat(QDGray)				else					PenPat(QDltGray);				MoveToOrient(aN^.loc.h, aN^.loc.v);{$IFC FLIPTREE}				if treeflipped then					extraroot := WindowPortRect(treeWindow).right - aN^.loc.v				else{$ENDC}					extraroot := WindowPortRect(treeWindow).bottom - aN^.loc.v;				if extraroot < 0 then					extraroot := 0;				if squarebranches then{$IFC FLIPTREE}					if treeflipped then						LineToOrient(aN^.loc.h, WindowPortRect(treeWindow).right)					else{$ENDC}						LineToOrient(aN^.loc.h, WindowPortRect(treeWindow).bottom)				else if NodeSlantsRight(ScreenR) then					LineToOrient(aN^.loc.h - extraroot * 2, aN^.loc.v + extraroot * 2)				else					LineToOrient(aN^.loc.h + extraroot * 2, aN^.loc.v + extraroot * 2);{    LineTo(aN^.loc.h, WindowPortRect(treeWindow).bottom);}				MoveToOrient(aN^.loc.h + edw - 1, aN^.loc.v);				if squarebranches then{$IFC FLIPTREE}					if treeflipped then						LineToOrient(aN^.loc.h + edw - 1, WindowPortRect(treeWindow).right)					else{$ENDC}						LineToOrient(aN^.loc.h + edw - 1, WindowPortRect(treeWindow).bottom)				else if NodeSlantsRight(ScreenR) then					LineToOrient(aN^.loc.h + edw - 1 - extraroot * 2, aN^.loc.v + extraroot * 2)				else					LineToOrient(aN^.loc.h + edw - 1 + extraroot * 2, aN^.loc.v + extraroot * 2);{    LineTo(aN^.loc.h + edw - 1, WindowPortRect(treeWindow).bottom);}				PenPat(QDBlack);			end;  {$ENDC}{$IFC FALSE}		for extraRoot := 1 to 10 do   {for debugging purposes}			begin				MoveTo(0, extraroot * 50);				LineTo(100, extraroot * 50);				DrawString(StringFromNum(extraRoot * 50));			end; {$ENDC}		ZapRegion(dClip);		justchanc := false;	end;{-----------------------------------------------------------------------------}	procedure DrawTreeWindow;		var			tpmain: windowptr;			oldRgn: RgnHandle;	begin		SetCursor(clockCursor);		OldRgn := newRgn;		genericGetPort(tpmain);		genericSetPort(treewindow);		GetClip(oldRgn);		dontCancelUpdate := dontCancelUpdate & (drawR <> screenR);		Cliprect(WindowPortRect(treeWindow));		MoveTo(VisTWR.left, VisTWR.bottom);		LineTo(VisTWR.right, VisTWR.bottom);		if equivcycle then			TWMessage := concat('MPR number ', StringFromNum(equivcyclenum), '.')		else if twfullscreen then			TWMessage := filename^^		else			TWMessage := ' ';		DrawTWMessWindow;		ClipRect(WindowPortRect(treeWindow));		DrawTree;		treeonscreen := true;		godraw := false;		ReShadeTree;		if nex7on and not TWScrolling then			NextSevenChars;		DrawR := ScreenR;{=====stuff below strictly legends=====}		Cliprect(WindowPortRect(treeWindow));		if isforeground then			begin//				if IsTreeWindow(frontwindow) then//					begin//						ShowControl(vTWScroll);//						ShowControl(hTWScroll);//					end;				DrawControls(treeWindow);				DrawGrowIcon(treeWindow);			end;		FixAssumpMenu;		SetCursorToArrow;		genericSetPort(treewindow);		SetClip(oldRgn);		ZapRegion(oldRgn);		genericSetPort(tpmain);	end;end.