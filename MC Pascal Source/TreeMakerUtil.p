unit TreeMakerUtil;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, CharUtil, MenuUtil, TreeUtil, LinkUtil;	function MemoryForTree (numterminals, numcharacters: longint): longint;	function NewNode (num: longint): Nptr;	procedure AddTaxon (taxnum: integer; var W: Nptr);	procedure DeleteClade (var N: nptr);	procedure PruneTree (var addsubtax: boolean);	procedure MakeDefaultTree (var N: Nptr; ancN: Nptr; ladder: boolean);{еееееееееееееееееееееее}implementation {е$S TreeMakerUtil}	function MemoryForTree (numterminals, numcharacters: longint): longint;	begin		Memoryfortree := longint(numterminals) * (468 + 6 * ord4(numcharacters) * numbytes) + 1468	end;{-----------------------------------------------------------------------------}	function NewNode (num: longint): Nptr;		label			3;		var			tN: Nptr;			it: integer;			found: boolean;	begin		if num = 0 then			begin  {look for next}				tN := Nptr(ord4(treeblock) + 3 * sizeof(Ntype));				found := false;				for it := 4 to (numtaxa * 2 + 2) do					begin						if (tN^.name = -1) then							begin								found := true;								goto 3;							end;						tN := Nptr(ord4(tN) + sizeof(Ntype));					end;3:				if not found then					NewError(18, 0);			end		else			tN := Nptr(ord4(treeblock) + (num - 1) * sizeof(Ntype));		tN^.name := 0;		newnode := tn;	end;{-----------------------------------------------------------------------------}	procedure AddTaxon (taxnum: integer; var W: Nptr);{adds taxon # taxnum below W}		var			TaxonHdl: thdl;			N, V, tV: Nptr;			fillingfailed: boolean;			wasright: boolean;	begin		dirtyTreeTaxNames := true;		numtaxain := numtaxain + 1;		TaxonHdl := GetTaxonHdl(taxnum);		taxonhdl^^.deleted := false;{New terminal node will be N; it will be attached to new internal node V}{which is inserted on branch below W}{First, make the internal node}		V := newnode(0);		V^.slant := W^.slant;		V^.anc := W^.anc;		wasright := NodeSlantsRight(W);		if wasright then			begin				V^.rt := W;				V^.anc^.rt := V;			end		else			begin				V^.lf := W;				V^.anc^.lf := V;			end;		W^.anc := v;		V^.name := 0;		fillingfailed := not FillNode(V);{Now make terminal node N}		n := newnode(0);		N^.slant := -W^.slant;		N^.anc := V;		if not FillNode(N) then			fillingfailed := true;		N^.name := taxnum;		TaxonHdl := GetTaxonHdl(N^.name);		taxonHdl^^.N := N;		if wasright then			V^.lf := N		else			V^.rt := N;		if R = W then {exchange R and V}			begin				tV := R;				R := V;				V := tV;				SubR^.rt := R;			end;		V^.null := false;		R^.null := false;		N^.null := false;		if fillingfailed then			begin				ExciseTaxonFromCurrentTree(W);				NewError(135, 0);			end;	end;{-----------------------------------------------------------------------------}	procedure DeleteClade; {(var N: nptr);}		var			Nn: Nptr;			rslant: boolean;	begin		if NodeIsTerminal(N) then			ExciseTaxonFromCurrentTree(N)		else			begin				Nn := N^.anc;				rslant := NodeSlantsRight(N);				DeleteClade(N^.lf);				if rslant then					DeleteClade(Nn^.rt)				else					DeleteClade(Nn^.lf);			end;		EmptyAssociatedTreeHandles;	end;{-----------------------------------------------------------------------------}	function TaxonInMemTree (taxnum: integer; var fN: Nptr): boolean;{returns true if terminal taxon with number taxnum is in the tree}		var			taxfound: boolean;		procedure FindTaxon (N: Nptr);		begin			if N^.name = taxnum then				begin					taxfound := true;					fn := N;				end			else if NodeIsInternal(N) then				begin					FindTaxon(N^.rt);					FindTaxon(N^.lf);				end;		end;	begin		taxfound := false;		FindTaxon(R);		TaxonInMemTree := taxfound;	end;{-----------------------------------------------------------------------------}	procedure PruneTree; {(var addsubtax: boolean)}{adds and subtracts taxa as necessary to match tree description to data matrix }		var			ir: integer;			fn: Nptr;	begin		AddSubTax := false;		for ir := numtaxa + 1 to numtaxa + taxcount do			if TaxonInMemTree(ir, fn) then				begin					ExciseTaxonFromCurrentTree(fn);					AddSubTax := true;				end;		if AddSubTax then			EmptyAssociatedTreeHandles;	end;{-----------------------------------------------------------------------------}	procedure MakeDefaultTree; {(var N : Nptr; ancN : Nptr; ladder : boolean);}		var			TaxonHdl: thdl;			nextnode: longint;{.................}		procedure InMakeDefaultTree (var N: Nptr; ancN: Nptr; ladder: boolean);			procedure MakeTT (var pN: Nptr; panc: Nptr);			begin				pN := newnode(nextnode);				pN^.rt := nil;				pN^.lf := nil;				nextnode := nextnode + 1;				pN^.slant := -1;				pN^.anc := panc;				pN^.name := taxcount;				TaxonHdl := GetTaxonHdl(pN^.name);				taxonhdl^^.deleted := false;				taxonHdl^^.N := pN;				if not FillNode(pN) then					treemakingfailed := true;				taxcount := taxcount + 1;			end;		begin			N := newnode(nextnode);			N^.rt := nil;			N^.lf := nil;			nextnode := nextnode + 1;			N^.slant := 1;			N^.anc := ancN;			if not FillNode(N) then				treemakingfailed := true;			if taxcount < numtaxa then				begin					N^.null := not ladder;					N^.name := 0;					MakeTT(N^.lf, N);					InMakeDefaultTree(N^.rt, N, ladder);				end			else				begin					N^.null := false;					N^.name := taxcount;					TaxonHdl := GetTaxonHdl(N^.name);					taxonhdl^^.deleted := false;					taxonHdl^^.N := N;				end;		end;	begin		nextnode := 4;		InMakeDefaultTree(N, ancN, ladder);	end;end.