unit DoPrint;{еееееееееееееееееееееее}interface	uses		Printing, QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, 		Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, 		Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  		MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, 		InfoWindows, GeneticCode, WriteUtil, SpreadUtil, Continuous, BranchListWindow,		 MenuUtil, StatusNotes, Fonts, TreeUtil, CharUtil, FootNote, TypeUtil, StrUtil, 		 SymbolsNames, TaxonCHUtil, PrintingUtil, PrintingMisc, PrintSpreadSheet, LaserTree, 		 ChartWUtil, ChartWindow, TypeDLOGUtil, TypeDLOGDraw, CSTreeUtil, CharStateTree,		 TextWindows, StatesWindow;	procedure DoPrintAllNames;	procedure DoPrint(whichWindow: WindowPtr);	procedure DoPrintOtherMenu (ItemNo: Integer);{еееееееееееееееееееееее}implementation {е$S Printing}{-----------------------------------------------------------------------------}	procedure DoPrintContinuous (var it: integer; numLines, lineW, maxlength, maxcontlength: integer);		var			currentline: integer;			ir: integer;			taxonHdl: tHdl;			ds: str255;	begin		currentline := 0;		repeat			it := it + 1;			if it > numtaxa then				leave;			currentLine := currentLine + 1;			MoveTo(20, currentline * LineW + 22);			DrawString(TaxonName(it));			taxonHdl := getTaxonHdl(it);			for ir := 1 to numcontinuous do				begin					MoveTo(20 + maxlength + 20 + (ir - 1) * (maxcontlength + 20), currentline * LineW + 22);					ds := GetContString(taxonHdl^^.contsmin[ir], taxonHdl^^.contsmax[ir]);					if ds = '' then						DrawChar('?')					else						DrawString(ds);				end;			currentLine := currentLine + 1;		until (currentLine >= NumLines) or (it >= numtaxa);	end;{-----------------------------------------------------------------------------}	function NamesToPrint (ic: integer; var numnames: integer): boolean;		var			ds: str255;	begin		if molecular then    {don't print state names}			numnames := 0		else			numnames := numstatenames(ic);		ds := CharName(ic);		NamesToPrint := ((ds <> '') and (ds <> ' ')) or (numnames > 0);	end;{-----------------------------------------------------------------------------}	procedure DoPrintNamesPage (var ic: integer; numLines, lineW: integer);		var			numnames, currentline: integer;			ir: integer;			ds: str255;	begin{$IFC PRINTSTAMP}		if printStampLine then			currentline := 1		else {$ENDC}			currentline := 0;		repeat			ic := ic + 1;			if ic > numchars then				leave;			currentLine := currentLine + 1;			if not NamesToPrint(ic, numnames) then				cycle;			if (currentline + 1 + numnames > numlines) & (currentline > 2) then  {v3.02}				begin					ic := ic - 1;					leave;				end;			MoveTo(10, currentline * LineW + 22);			DrawString(StringFromNum(ic));			DrawString('. ');			ds := AvailCharName(ic);			DrawString(ds);			currentLine := currentLine + 1;			if numnames > 0 then				if not molecular then					for ir := 0 to maxstate do						if CharStateName(ic, ir) <> '' then							begin								MoveTo(26, currentline * LineW + 22);								DrawString(Concat(StringFromNum(ir), ':  ', charstatename(ic, ir)));								currentLine := currentLine + 1;							end;		until (currentLine >= NumLines) or (ic >= numchars);	end;{----------------------------------------------------------}	function CSTDepth (var highestCSTBall: integer): integer;{calculates height of character state tree figures}		var			ir, it: integer;			deepestCSTBall: integer;	begin		deepestCSTBall := -10000;		highestCSTBall := 10000;		ir := -1;		repeat			ir := ir + 1;			if (CurTypeHdl^^.nbors[ir] <> []) then				begin					if highestCSTBall > crect[ir].top then						highestCSTBall := crect[ir].top;					if deepestCSTBall < crect[ir].bottom then						deepestCSTBall := crect[ir].bottom;				end;		until (ir = maxCS) or ((CurTypeHdl^^.nbors[ir] = []) and (ir > maxstate));		it := deepestCSTBall - highestCSTBall;		if it < FontHeight then			it := FontHeight;		CSTDepth := it;	end;{-----------------------------------------------------------------------------}	procedure PrintNodeLists (numlines, lineW: integer);		var			currentline: longint;			 numchanges: integer;			nodenum: integer;			ds: str255;	begin		nodenum := 0;		pg := 1;		repeat			if OpenPrinterPage then				begin					SetPrintFonts;					currentLine := 1;					if pg = 1 then						DrawNodeListHeading(currentline, lineW);					repeat						nodenum := nodenum + 1;						if BranchExists(NodeOfNumber(nodenum)) then							DrawNodeInfo(NodeOfNumber(nodenum), nodenum, lineW, numlines, currentLine, pg);					until (PrinterError) or (currentLine > numlines) or (nodenum >= (2 * ntscreen) - 1); {v4: have totalnodes in case polytomies?}					ClosePrinterPage;					pg := pg + 1;				end;		until (PrinterError) or (nodenum >= (2 * ntscreen) - 1);  {v4: have totalnodes in case polytomies?}	end;{-----------------------------------------------------------------------------}	procedure DoPrintStatusNotes;	begin		if OpenPrinterPage then			begin				SetPrintFonts;				DrawTime(myGetWindowFromPort(QDThePort));				StatusNotes;			end;		ClosePrinterPage;	end;	{-----------------------------------------------------------------------------}	procedure DoPrintDataBoxes;	var taxaperpage, itend, oldN7LW,it,ic: integer;	begin{v4: problem if more than data boxes go over more than one page - vertically -}{it prints VERY slowly}{v4: users choose color or pattern}		oldN7LW := n7LW;		n7LW := FontHeight;		it := 1;		txsp := FontHeight + 4;		CalcPgSizes(pgWidth, pgHeight);		taxaperpage := (pgwidth - 44) div txsp - 2;  {44 is firsttx constant in PrintDataBoxesPage}		repeat		{taxa loop}			ic := 1;			itend := it + taxaperpage;			if itend > numtaxa then				itend := numtaxa;			repeat  	{characters loop}				if NoPrinterError then					PrintDataBoxesPage(ic, it, itend, pg, pgheight, pgwidth);			until ((PrinterError) or (ic > numchars));			it := itend + 1;		until ((PrinterError) or (it > numtaxa));		oldN7LW := n7LW;	end;{-----------------------------------------------------------------------------}	procedure DoPrintNames(numLines,lineW: integer);	var ic, numnames: integer;	begin		ic := 0;		repeat			ic := ic + 1;			if NamesToPrint(ic, numnames) then				leave;		until ic >= numchars;		if ic < numchars then			begin				ic := ic - 1;				repeat					if NoPrinterError then						begin							if OpenPrinterPage then								begin{$IFC PRINTSTAMP}									if printStampLine then										DrawStampLine(CurrentDrawingPortRect, false);{$ENDC}									textfont(statesFont);									textSize(statesFontSize);									DoPrintNamesPage(ic, numLines, lineW);								end;							ClosePrinterPage;						end;					pg := pg + 1;				until ((PrinterError) or (ic >= numchars));			end;	end;	{-----------------------------------------------------------------------------}	procedure DoPrintTypes;	var 		ic, theLeft,theTop,k: integer;			oldCurType, lines,qsum,shift: integer;			 highestCSTBall: integer;			 box: rect;			fisherprinted: boolean;	begin		fisherprinted := false;		ic := usedef;		oldCurType := curType; {v3.01}		theleft := 20;		maxTypeEditMat := absmaxstate;		repeat			if OpenPrinterPage then				begin					SetPrintFonts;					SetRect(box, 0, 0, 0, 0);{$IFC PRINTSTAMP}					if printStampLine then						thetop := 15 + printStampWidth					else{$ENDC}						thetop := 15;					typeBoundaryRect := CurrentDrawingPortRect;					if NoPrinterError then						begin{$IFC PRINTSTAMP}							if printStampLine then								DrawStampLine(CurrentDrawingPortRect, false);{$ENDC}							if fisheredited and not fisherprinted then{v4: should worry about new page?}								begin									ClipRect(CurrentDrawingPortRect);									CurTypeHdl := gettypeHdl(fisher);									MoveTo(theleft, thetop);									DrawString('Cost of skipping strata:');									thetop := thetop + fontheight;									for k := 0 to MaxStateDefined(fisher) - 1 do										begin											moveto(theleft, thetop);											DrawString('Stratum ');											DrawChar(CharOfNum(k));											DrawChar(':');											moveto(theleft + 20 + StringWidth('Stratum M:'), thetop);											if (CurTypeHdl^^.dist[k, k + 1] = infinity) then												DrawString('infinite')											else												begin													qsum := CurTypeHdl^^.dist[k, k + 1];													DrawString(concat(StringFromNum(qsum div TypeInflate), '.', StringFromNum(qsum mod TypeInflate)))												end;											thetop := thetop + FontHeight;											fisherprinted := true;										end;									thetop := thetop + FontHeight;								end;							repeat								PenSize(1, 1);								ClipRect(CurrentDrawingPortRect);								CurType := ic;								CurTypeHdl := gettypeHdl(ic);{v4: give them the option of drawing cstrees as a matrix}								if CurTypeHdl^^.root < 0 then			{it's a matrix type}									begin										StepCellHeight := FontHeight + 4;										if curtypeHdl^^.isreal then											StepCellWidth := StringWidth('00.0') + 4										else											StepCellWidth := StringWidth('00') + 6;										maxMat := MaxStateDefined(CurType);										CheckMaxMat;										CalcSpecRect(ic, theleft, thetop, box);										if box.bottom + fontheight > CurrentDrawingPortRect.bottom then											leave;										MoveTo(theleft, thetop);										DrawString(TypeName(ic));										OffSetRect(box, StringWidth('From: M'), FontHeight * 2);										DrawTypeMatrixBox(ic, box);										FillTypeMatrix(ic, box, false);										thetop := box.bottom + fontheight * 2;									end								else									{it's a cstree}									begin										GetCSTree;										shift := CSTDepth(highestCSTBall);										if thetop + shift > CurrentDrawingPortRect.bottom then											leave;										MoveTo(theleft, thetop);										DrawString(TypeName(ic));										thetop := thetop + fontheight;										DrawCSTree(thetop - highestCSTBall + 3);  {remember, it's already shifted down in typeDLOG}										thetop := thetop + shift + fontheight * 2;									end;								ic := ic + 1;							until (ic > numtypes);						end;					ClosePrinterPage;				end;			pg := pg + 1;		until ((PrinterError) or (ic > numtypes));		maxTypeEditMat := 9;		curType := oldCurType;	end;{-----------------------------------------------------------------------------}	function FootLines (it, ic: integer; box: rect; footTE:TEHandle): integer;		var			ds: str255;			db: boolean;	begin		footlines := 0;		if footpresent(it, ic) then			begin				db := GetFootString(footText, it, ic, ds);				if db then					begin						TESetText(Ptr(ord4(@ds) + 1), length(ds), footTE);						SetRect(footTE^^.destrect, 20, 0, box.right, box.bottom);						TECalText(footTE);						footlines := footTE^^.nlines;					end;			end;	end;{-----------------------------------------------------------------------------}	procedure FootTextPrint (it, ic: integer; var currentLine: integer; lineW: integer; box: rect; footTE: TEHandle);		var			ds: str255;			db: boolean;			tbox: rect;			lines: integer;	begin		if footpresent(it, ic) then			begin				MoveTo(20, currentline * LineW + 22);				DrawString(FootCellTitle(it, ic));				DrawString(':   ');				SetRect(tbox, 20, currentline * lineW + 26, box.right, box.bottom);  {v4: 26 should be 22 + linedescent}				currentLine := currentLine + 1;				db := GetFootString(footText, it, ic, ds);				TETextBox(Pointer(ord4(@ds) + 1), length(ds), tbox, teJustLeft);				currentLine := currentLine + footlines(it, ic, box,footTE) + 1;			end;	end;{-----------------------------------------------------------------------------}	procedure DoPrintFootNotes( numLines, lineW: integer);	label 1;	var 		ic, it: integer;			footTE: TEHandle;			itset, icset: boolean;			charfootdone, taxafootdone: Boolean;			box: rect;			currentLine, lines: integer;	begin		charfootdone := false;		taxafootdone := false;		it := 1;		ic := 0;		itset := false;		icset := false;		repeat			if OpenPrinterPage then				begin					SetPrintFonts;					box := CurrentDrawingPortRect;					//box := currentClassicPrinterPort^.gPort.portrect;{$IFC PRINTSTAMP}					if printStampLine then						box.top := box.top + printStampWidth;{$ENDC}					footTE := TENew(box, box);					if NoPrinterError then						begin{$IFC PRINTSTAMP}							if printStampLine then								begin									DrawStampLine(CurrentDrawingPortRect, false);									currentline := 2;								end							else{$ENDC}								currentline := 1;{......  printing taxa FootTexts .........}							if not taxafootdone then								begin									lines := footlines(it, ic, box,footTE);									while (it <= numtaxa) & (currentline + lines + 1 <= numlines) do										begin											FootTextPrint(it, ic,currentLine,lineW, box,footTE);											it := it + 1;										end;									taxafootdone := (it > numtaxa);									if (currentline + lines + 1 > numlines) then										goto 1;								end;{......  printing character FootTexts .........}							if not charfootdone then								begin									it := 0;									ic := 1;									lines := footlines(it, ic, box,footTE);									while (ic <= numchars) & (currentline + lines + 1 <= numlines) do										begin											FootTextPrint(it, ic,currentLine,lineW, box,footTE);											ic := ic + 1;											lines := footlines(it, ic, box,footTE);										end;									charfootdone := (ic > numchars);									if (currentline + lines + 1 > numlines) then										goto 1;								end;							if charfootdone & taxafootdone then								begin									if not itset then										begin											it := 1;											ic := 1;											itset := true;										end;									lines := footlines(it, ic, box,footTE);									while (it <= numtaxa) & (currentline + lines + 1 <= numlines) do										begin											lines := footlines(it, ic, box,footTE);											while (ic <= numchars) & (currentline + lines + 1 <= numlines) do												begin													FootTextPrint(it, ic,currentLine,lineW, box,footTE);													ic := ic + 1;													lines := footlines(it, ic, box,footTE);												end;											if (currentline + lines + 1 > numlines) then												begin													goto 1;												end;											if (ic > numchars) and (it < numtaxa) then												ic := 1;											it := it + 1;										end;									if (currentline + lines + 1 > numlines) then										goto 1;								end;						end;1:					TEDispose(footTE);					ClosePrinterPage;				end;			pg := pg + 1;		until ((PrinterError) or ((ic >= numchars) and (it >= numtaxa)));	end;{-----------------------------------------------------------------------------}	procedure FootPictPrint (it, ic: integer);	begin		if OpenPrinterPage then			begin				SetPrintFonts;{$IFC PRINTSTAMP}				if printStampLine then					DrawStampLine(CurrentDrawingPortRect, false);{$ENDC}				MoveTo(20, 15+FontHeight);  				DrawString(FootCellTitle(it, ic));				//SetOrigin(0, -30); {this seems to be OK with sideways printing!}				ShowFootPict(it, ic,20,20+2*FontHeight);				//SetOrigin(0, 0);			end;		ClosePrinterPage;		pg := pg + 1;	end;{-----------------------------------------------------------------------------}	procedure DoPrintFootPicts;	var it, ic: integer;	begin		for it := 1 to numtaxa do			if footpictpresent(it, 0) then				if NoPrinterError then					FootPictPrint(it, 0)				else					leave;		if NoPrinterError then			for it := 0 to numtaxa do				for ic := 1 to numchars do					if footpictpresent(it, ic) then						if NoPrinterError then							FootPictPrint(it, ic)						else							leave;	end;{-----------------------------------------------------------------------------}	procedure DoPrintGeneticCode;	begin		if OpenPrinterPage then			begin				SetPrintFonts;{$IFC PRINTSTAMP}				if printStampLine then					DrawStampLine(CurrentDrawingPortRect, false);{$ENDC}				PrintDrawGenCode;			end;		ClosePrinterPage;	end;{-----------------------------------------------------------------------------}	procedure DoPrintAllContinuous (numLines, lineW: integer);	var				maxlength, contlength, maxcontlength: integer;		it,ir: integer;		taxonHdl: tHdl;	begin		SetPrintFonts;		maxlength := MaxTaxNameLength(true);		maxcontlength := 0;		for it := 1 to numtaxa do			begin				taxonHdl := getTaxonHdl(it);				for ir := 1 to numcontinuous do					begin						contlength := StringWidth(GetContString(taxonHdl^^.contsmin[ir], taxonHdl^^.contsmax[ir]));						if contlength > maxcontlength then							maxcontlength := contlength;					end;			end;		it := 0;		repeat			if OpenPrinterPage then				begin					SetPrintFonts;{$IFC PRINTSTAMP}					if printStampLine then						DrawStampLine(CurrentDrawingPortRect, false);{$ENDC}					DoPrintContinuous(it, numLines, lineW, maxlength, maxcontlength);					ClosePrinterPage;				end;			pg := pg + 1;		until ((PrinterError) or (it >= numtaxa));	end;{-----------------------------------------------------------------------------}	procedure DoPrintAllNames;		var 				myStRec: TPPrStatusRef;			{%%%pgWidth, pgHeight, }			NumLines,  LineW: Integer;	begin		printon := true;		if OpenPrinter(true) then			begin				if StartPrinting(true) then					begin						textfont(statesFont);						textSize(statesFontSize);						textFace([]);						CalcPgSizes(pgWidth, pgHeight);						lineW := FontHeight;						NumLines := (pgHeight div LineW) - 4;						if PrepareDocument then							DoPrintNames(numLines,lineW);						EndPrint;					end;				PrintCancelOff;				ClosePrinter;			end;		printon := false;	end;{-----------------------------------------------------------------------------}	procedure DoPrintOtherMenu (ItemNo: integer);		var 				{%%%pgWidth, pgHeight,}currentLine, NumLines,  LineW: Integer;	begin		if not ChooseFontDLOG then			Exit(DoPrintOtherMenu);		printon := true;		if OpenPrinter(true) then			begin				if StartPrinting(true) then					begin						SetPrintFonts;						CalcPgSizes(pgWidth, pgHeight);						lineW := FontHeight;						NumLines := (pgHeight div LineW) - 4;						SetPrintFonts;						if PrepareDocument then							case ItemNo of								PtNotesItem: 									DoPrintStatusNotes;								PtDataBoxesItem: 									begin										printDataBoxesInColor := CWarning('Print data boxes in color or black and white?','Color', 'B & W');										DoPrintDataBoxes;										printDataBoxesInColor := false;									end;								{PtNamesItem: 									DoPrintNames(myPrPort,numLines,lineW);}								PtTypesItem: 									DoPrintTypes;								PtFootTextItem: 									DoPrintFootNotes(numLines, lineW);								PtFootPictsItem: 									DoPrintFootPicts;								PtGenCodeItem: 									if molecular then										DoPrintGeneticCode;								PtNodeListItem: 									PrintNodeLists(numlines, lineW);								PtContinuousItem: 									DoPrintAllContinuous(numLines,lineW);																	otherwise									;							end;						EndPrint;					end;				PrintCancelOff;				ClosePrinter;			end;		printon := false;	end;{-----------------------------------------------------------------------------}	procedure PrintPictWindow;	var 			tempP: WindowPtr;		box: rect;	begin		genericGetPort(tempP);		if OpenPrinter(true) then			begin				if StartPrinting(true) then					begin						if PrepareDocument & OpenPrinterPage then							begin								SetPrintFonts;								box := grabpicture^^.picFrame;{$IFC PRINTSTAMP}								if printStampLine then									begin										DrawStampLine(CurrentDrawingPortRect, false);										OffSetRect(box, 0, printStampWidth);									end;{$ENDC}								DrawPicture(grabpicture, box);								ClosePrinterPage;							end;						EndPrint;					end;				PrintCancelOff;				ClosePrinter;			end;		genericSetPort(tempP);	end;{-----------------------------------------------------------------------------}	procedure PrintTextWindow(whichWindow: windowPtr);	var 			tempP: WindowPtr;		box: rect;		whichText,NumLines,currentLine, numpages, theStart,theEnd: integer;	begin		whichText := WhichTextWindow(whichWindow);		genericGetPort(tempP);		if OpenPrinter(true) then			begin				if StartPrinting(true) then					begin						CalcPgSizes(pgWidth, pgHeight);						textfont(textWindowInfo[whichText]^.font);						textSize(textWindowInfo[whichText]^.size);						textFace(textWindowInfo[whichText]^.face);												NumLines := (pgHeight div FontHeight) - 2;						numPages := textWindowInfo[whichText]^.TE^^.nlines div NumLines;						if textWindowInfo[whichText]^.TE^^.nlines mod NumLines <> 0 then							numPages := numPages + 1;						box := textWindowInfo[whichText]^.box;						currentLine := 0;						box.top := 0;						box.bottom := pgHeight;						OffSetRect(box, 0, FontHeight);						HLock(Handle(textWindowInfo[whichText]^.TE^^.hText));						if PrepareDocument then							repeat								theStart := textWindowInfo[whichText]^.TE^^.lineStarts[currentLine];								currentLine := currentLine + numLines;								if currentLine > textWindowInfo[whichText]^.TE^^.nLines then									theEnd := textWindowInfo[whichText]^.TE^^.lineStarts[textWindowInfo[whichText]^.TE^^.nLines]								else									theEnd := textWindowInfo[whichText]^.TE^^.lineStarts[currentLine];								if OpenPrinterPage then									begin										textfont(textWindowInfo[whichText]^.font);										textSize(textWindowInfo[whichText]^.size);										textFace(textWindowInfo[whichText]^.face);										ClipRect(CurrentDrawingPortRect);	{$IFC PRINTSTAMP}										if printStampLine then											begin												DrawStampLine(CurrentDrawingPortRect, false);												currentLine := currentLine + 1;												box.top := box.top + FontHeight;											end;	{$ENDC}										TETextBox(Pointer(GetMaster(textWindowInfo[whichText]^.TE^^.hText) + theStart), theEnd - theStart, box, teJustLeft);										ClosePrinterPage;									end;								pg := pg + 1;							until ((PrinterError) or (pg > numPages));						HUnLock(Handle(textWindowInfo[whichText]^.TE^^.hText));						EndPrint;					end;				PrintCancelOff;				ClosePrinter;			end;	end;	{-----------------------------------------------------------------------------}	procedure PrintChartWindow;	var 			tempP, tempP2: WindowPtr;		box: rect;		oldCWTableTop, oldCWTableRows: longint;		oldchartorigin: longint;		adj: integer;	begin		oldCWTableTop := CWTableTop;		oldCWTableRows := CWTableRows;		oldchartorigin := chartorigin;		tempP2 := nil;		genericGetPort(tempP);		genericGetPort(tempP2);		if OpenPrinter(true) then			begin				if StartPrinting(true) then					begin						chartorigin := 0;						if PrepareDocument then							repeat								CWTableTop := chartorigin;								if NoPrinterError then									begin										if OpenPrinterPage then											begin												//SetPort(printerPort);												genericGetPort(tempP2);		{$IFC PRINTSTAMP}												if printStampLine & ((cwview = tableview) | (cwview = infoview)) then													begin														DrawStampLine(CurrentDrawingPortRect, false);														adj := printStampWidth;													end												else		{$ENDC}													adj := 0;												if CWfullprint | (cwview = tableview) then													box := CurrentDrawingPortRect												else													box := WindowPortRect(chartWindow);												box.top := box.top + adj;												//ClipRect(box);												Textsize(CWfontsize);												TextFont(CWfont);												TextFace(CWstyle);												CalcCWBoxes(box);												//												DrawChartWindow(box);												ClosePrinterPage;											end;									end;								if CWLinear then									chartorigin := chartorigin + chartintervals;								pg := pg + 1;							until (PrinterError) | ((not CWLinear) | (CWView = infoview) | (chartorigin >= numIntervals[CLkind]));						EndPrint;					end;				PrintCancelOff;				ClosePrinter;			end;		genericGetPort(tempP2);		genericSetPort(tempP);		CalcCWBoxes(WindowPortRect(chartWindow));		chartorigin := oldchartorigin;		CWTableTop := oldCWTableTop;		CWTableRows := oldCWTableRows;	end;{-----------------------------------------------------------------------------}	procedure PrintInfoWindow(whichWindow: windowPtr);	var 			tempP: WindowPtr;		box: rect;		whichinfo: integer;		numElements: longint;		adj: integer;		numLines: integer;		ic, currentLine: longint;	begin		whichinfo := WhichInfoWindow(whichWindow);		numElements := MaximumInfoRows(whichinfo);		genericGetPort(tempP);		if OpenPrinter(true) then			begin				if StartPrinting(true) then					begin						CalcPgSizes(pgWidth, pgHeight);						if printStampLine then							adj := 24						else							adj := 0;						NumLines := ((pgHeight-adj) div infoLW[whichinfo]) - 4;						ic := 1;						if PrepareDocument then							repeat								if OpenPrinterPage then									begin										textfont(infoFont[whichinfo]);										textSize(infoFontSize[whichinfo]);										ClipRect(CurrentDrawingPortRect);										currentline := 1;	{$IFC PRINTSTAMP}										if printStampLine then												DrawStampLine(CurrentDrawingPortRect, false);	{$ENDC}										DrawInfoTitle(whichinfo, adj,infoLW[whichinfo] + adj, true);										currentLine := currentLine + 1;										repeat											DrawInfoLine(whichinfo, ic, currentline * infoLW[whichinfo] + 2+adj, true);											ic := ic + 1;											currentLine := currentLine + 1;										until (currentLine > NumLines) or (ic > numElements);										ClosePrinterPage;									end;								pg := pg + 1;							until ((PrinterError) | (ic > numElements));						EndPrint;					end;				PrintCancelOff;				ClosePrinter;			end;		genericSetPort(tempP);	end;{-----------------------------------------------------------------------------}	procedure PrintStatesWindow;	var  		tempP: WindowPtr;		box: rect;		whichinfo: integer;		numElements: longint;		adj: integer;		numLines: integer;		ic, currentLine: longint;	begin		genericGetPort(tempP);		numElements := LastStateName(statesWindowCharacter);		if (numElements >= 0) & OpenPrinter(true) then			begin				if StartPrinting(true) then					begin						CalcPgSizes(pgWidth, pgHeight);						NumLines := (pgHeight div statesWindowLineWidth) - 4;						ic := 1;						if PrepareDocument then							repeat								if OpenPrinterPage then									begin										TextFont(statesFont);										TextSize(statesFontSize);										//ClipRect(CurrentDrawingPortRect);										ClipRect(printPageR);										currentline := 1;	{$IFC PRINTSTAMP}										if printStampLine then											begin												DrawStampLine(CurrentDrawingPortRect, false);												currentLine := currentLine + 2;												adj := 24;											end										else	{$ENDC}											adj := 0;										DrawStatesTitle(adj,statesWindowTitleWidth+adj);										currentLine := currentLine + 1;										repeat											DrawStatesLine(ic, StatesRowHeightBottom(ic)+adj, true);											ic := ic + 1;											currentLine := currentLine + 1;										until (currentLine > NumLines) or (ic > numElements+1);										ClosePrinterPage;									end;								pg := pg + 1;							until ((PrinterError) | (ic > numElements + 1));						EndPrint;					end;				PrintCancelOff;				ClosePrinter;			end;		genericSetPort(tempP);	end;{-----------------------------------------------------------------------------}	procedure DoPrint(whichWindow: WindowPtr);	begin{$IFC DEMO}		if not IsTreeWindow(whichWindow) then			begin				InstantInfo('You cannot print with this demonstration version of MacClade.');				Exit(DoPrint);			end;{treewindow restriction enforced in LaserTree}{$ENDC}		pg := 1;		printon := true;		SetCursorToArrow;		if whichWindow = nil then			Beep		else if IsEditorWindow(whichWindow) then			PrintData		else if LockedToTreeWindow(whichWindow) then			LaserTree(treeOutputToPrinter)		else if whichWindow = pictwindow then			PrintPictWindow		else if whichWindow = Chartwindow then			PrintChartWindow		else if IsInfoWindow(whichWindow) then			PrintInfoWindow(whichWindow)		else if IsTextWindow(whichWindow) then			PrintTextWindow(whichWindow)		else if whichwindow=stateswindow then			PrintStatesWindow		else			Beep;		printon := false;	end;end.