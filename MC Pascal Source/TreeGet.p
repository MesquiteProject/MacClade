unit TreeGet;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, 		Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, 		EventUtil, GenUtil, StrUtil, SetStates, BoxUtil, TaxonCHUtil, CharUtil, Prohibitions, 		MenuUtil, IncExcTaxa, ReadTreeFile, TreeCycle, TreeUtil, CHUNK, Count, LinkUtil, 		TreeMaker, TreeDrawer, MCWindows, Legends;	procedure NewStoreTree;   {///}	procedure OpenFirstUserTree;	function GoToTree (treenumber: integer): boolean;	procedure GoToSingleInfoTree(whichRow: longint);	function StartTree: boolean;	procedure CheckNewTaxa;	var		numtreeschosen: integer;		curtreechosen: boolean;{еееееееееееееееееееееее}implementation {е$S TreeGet}{-----------------------------------------------------------------------------}	procedure NewStoreTree;   {///}	begin		SaveLinkToChain(treeChain, DefaultInfoObjectName(treeinfo), false,false);		EnableDisableItem(TreeMHdl, TransferTreeItem, TransferTreesAvailable);		linknumber[treeChain] := EndUserLink(treeChain);		dirtytree := false;		dirtyfix := false;		ChangeStoredTreesGoList;		InvalidateWindow(tlegwindow, true);		AddOpenEditLastInfoRowName(treeinfo, true);	end;{-----------------------------------------------------------------------------}	function CheckUnsavedTree: boolean;{warnIfUnstoredTreeWillDisappear & }	begin		CheckUnsavedTree := true;		if warnIfUnstoredTreeWillDisappear & dirtyTree then			case DoAlert(175,CautionA) of				1:  {proceed};				2: {cancel}					CheckUnsavedTree := false;				3: {proceed and don't warn again}					begin						warnIfUnstoredTreeWillDisappear:= false;					end;				5:  {cancel and store}					begin						CheckUnsavedTree := false;						NewStoreTree;					end;				otherwise;			end;	end;{-----------------------------------------------------------------------------}	function OpenTheTree(treeLink: longint; QueryDirty: boolean): boolean;	{treelink is not the usernumber, it is the actual link number in the chain, so it considers the predefined links}		var			status, querycyclepoly: boolean;			olddirtytree: boolean;	begin		OpenTheTree:= false;				if (not QueryDirty | CheckUnsavedTree) & (treeLink>= 0) & (treeLink<=LinksInChain(treeChain)) then			begin				OpenTreeMenus;				linknumber[treeChain] := treeLink;				if treeopen then					begin						myDisableItem(ShowMHdl, ShrinkItem);						expd := FALSE;						noundo := false;						myEnableItem(EditMHdl, UndoItem);						genericSetPort(treeWindow);						if nodes then							fixlostbyundo := fixon; {when later undone fix will be lost}					end				else					begin						noundo := true;						fixlostbyundo := false;						OpenTreeWindow;					end;				undotype := justgot;				justundid := false; {getting tree can't be an undoing}				olddirtytree := dirtytree;				dirtytree := false;				dirtyfix := false;				ChooseLink(treeChain, true);				ancon := false; {so that PolytomiesLegal does not squawk because of fixanc in current tree}		{don't need to say nullson because subR is passed to fixancLegal}				status := true;				querycyclepoly := false;				Maketree(status, querycyclepoly, false, PolytomiesLegal(false), FixancLegal(subR, false),true,true);				if not status then					dirtytree := olddirtytree;				InvalidateWindow(tlegwindow, false);				genericSetPort(treewindow);				myValidRect(treeWindow,WindowPortRect(treeWindow));		{v3.02: removed:	CalcTaxonHeight;}				SetDrawTWRControls;				FullTreeOnScreenGoList; {requesting all calculations having to do with changing tree on screen}				if infoOpen[taxinfo] then					InvalidateWindow(infoWindow[taxinfo], false);				godraw := true;				nomove := false;				if not treemakingfailed then					FixTreeShadingMenus;				OpenTheTree := true;			end;	end;{-----------------------------------------------------------------------------}	procedure GoToSingleInfoTree(whichRow: longint);	var 	oldLink: longint;	begin		if treeopen and nodes then			begin				StoreOldTreeForUndo;  {undotype etc set in Openthetree}			end;		oldLink := oldTreeLinkNumber;		oldtreelinknumber := linknumber[treechain];		if not OpenTheTree(LinkNumberFromInfoRow(treeChain,whichRow), true) then			oldTreeLinkNumber := oldLink;	end;{-----------------------------------------------------------------------------}	function GoToTree (treenumber: integer): boolean;	var 	oldLink: longint;  {called only once in mouseintree }	begin		GoToTree := true;		oldLink := oldtreelinknumber;		oldtreelinknumber := linkNumber[treeChain];		if treeopen and nodes then			StoreOldTreeForUndo;		if not OpenTheTree(treenumber, true) then 			begin				oldtreelinknumber := oldLink;				GoToTree := false;			end;	end;{-----------------------------------------------------------------------------}	function MakeOneRandomTree: boolean;{makes one random tree - really intended only for DoFirstTree}		var			status, querycyclepoly: boolean;			oldRTAllTaxa: boolean;	begin		status := false;		numtaxain := numtaxa;  {required!}		querycyclepoly := false;		oldRTAllTaxa := RTallTaxa;		RTAllTaxa := true;		BuildTree(nil, RTequiprobable, status, Querycyclepoly, false, true, true);		RTAllTaxa := oldRTallTaxa;		if treemakingfailed then			NewError(381, 0);		if status then			begin{    SaveLinkToChain(treeChain, 'Random Tree', false);}				if treefile then					dirtytreefile := true				else					dirtyfile := true;			end;		MakeOneRandomTree := status;	end;{----------------------------------------------------------------------------}	procedure CheckNewTaxa;{checks to see if new taxa added to matrix while in editor, asks if user wants to add these to include at base of tree}{note that will not work if user saves file in editor after adding taxa then reopens}		var			it: integer;			somenew: boolean;	begin		somenew := false;		for it := 1 to numtaxa do			if IsNewTaxon(it) then				begin					somenew := true;					leave;				end;		if somenew then			begin				if CWarning('Some new taxa have been added to the matrix. Do you wish to include them at the base of the tree?', 'Include', 'Exclude') then					IncNewTaxa;				for it := 1 to numtaxa do					ClearNewTaxon(it);			end;	end;{-----------------------------------------------------------------------------}	procedure OpenFirstUserTree;	begin		if treeopen and nodes then			StoreOldTreeForUndo;		if OpenTheTree(StartUserLink(treechain), false) then			begin				CheckNewTaxa;				SelectWindow(tlegwindow);				{infoWasOpen[treeinfo]:= true;}				OpenOrSelectInfoWindow(treeinfo);			end;	end;{-----------------------------------------------------------------------------}	procedure DoFirstTree (var chosen: boolean);		var			db: boolean;	begin		chosen := true;		case DoAlert(131, NoteA) of			1: 				db := GoToTree(0);			2: 				db := GoToTree(1);			3: 				begin					GetTreeFile;					if not errorflag and (userlinks[treechain] > 0) then						OpenFirstUserTree;						{begin							ParamText('Select Tree:', '', '', '');							db := GetTree(GTSingle);						end;}				end;			6: 				begin					chosen := false;				end;			4: 				if MakeOneRandomTree then					begin						fixlostbyundo := false;						OpenTreeWindow;						noundo := true;				{note that no tree in memory, therefore can't undo}						justundid := false;						godraw := true;						nomove := false;						myDisableItem(EditMHdl, UndoItem);						FixTreeShadingMenus;					end;			otherwise				;		end;	end;{-----------------------------------------------------------------------------}	function StartTree: boolean;  {this procedure is used to start the treewindow off}		var			it: integer;			db: boolean;			chosen: boolean;	begin		oldtreelinknumber := 0;		chosen := true;		if DefaultLink[treeChain] >= 0 then			begin				if treeopen and nodes then					StoreOldTreeForUndo;				if OpenTheTree(DefaultLink[treeChain], false) then  {note: this contains setting of undotype etc.}					begin						ExciseDefaultLink(treechain);						CheckNewTaxa;						if dirtytree then							linknumber[treechain] := StartUserLink(treechain);					end				else chosen := false;			end		else if (UserLinks[treeChain] > 0) then			begin				 OpenFirstUserTree;				{ParamText('Select Tree:', '', '', '');				db := GetTree(GTsingle);}			end		else			DoFirstTree(chosen);		if chosen then			for it := 1 to numtaxa do				ClearNewTaxon(it);		StartTree := chosen;	end;{-----------------------------------------------------------------------------}end.