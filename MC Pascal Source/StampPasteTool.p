unit StampPasteTool;{ееееееееееееееееееееее}interface	uses		QuickDraw,  		Types, Events, QuickDrawText, OSUtils, TextUtils,Controls, Menus, Files,  Windows, 		Sound, Dialogs, TextEdit, Lists, ToolUtils, Memory, Fonts, Resources, Scrap, 		Globals, WindowUtil, GenUtil, StrUtil, BoxUtil, SetLibInterface, TaxonCHUtil,		CharUtil, MenuUtil, SymbolsNames, TreeUtil, Fill, SpreadUtil, Footnote, DrawSpread, 		RowColumn, StatesWindow, ScrollSpread, CopyPaste, ToolPalette,AlignmentUtil, MoveData, EditorUndo;		procedure DrawStampPasteBlock;	procedure HideStampPasteBlock;	procedure ShimmerStampPasteBlock (cellBlock: CellBlockPtr; wh: point);	procedure StampPaste(ClickCell: point);				{ееееееееееееееееееееее}implementation {е$S StampPasteTool}{-----------------------------------------------------------------------------}	procedure CalcSelOutlineLeftRight (cellBlock: CellBlockPtr; cell: point; var leftcell, rightcell: integer);{calculates left and right columns of magic paste rectangle}		var			HorCells: integer;			cellPt: point;	begin		if ((cellBlock^.starttaxa > 0) and editorTransposed) or ((cellBlock^.startchars > 0) and not editorTransposed) then{then right and left bounds within data cells proper}			begin				if not editorTransposed then					HorCells := cellBlock^.nchar				else					HorCells := cellBlock^.ntax;				leftcell := cell.h;				if leftcell < 1 then					leftcell := 1;				rightcell := leftcell + HorCells - 1;				if rightcell > editorTotalColumns then					rightcell := editorTotalColumns;				leftcell := rightcell - HorCells + 1;			end		else   {bound to left as column 0 or -1 selected}			begin				leftcell := 1;				if ((cellBlock^.starttaxa = -1) and editorTransposed) or ((cellBlock^.startchars = -1) and not editorTransposed) then					rightcell := editorTotalColumns				else if ((cellBlock^.starttaxa = 0) and editorTransposed) then					rightcell := cellBlock^.ntax				else if ((cellBlock^.startchars = 0) and not editorTransposed) then					rightcell := cellBlock^.nchar;			end;	end;{-----------------------------------------------------------------------------}	procedure CalcSelOutlineTopBottom (cellBlock: CellBlockPtr; cell: point; var topcell, bottomcell: integer);{calculates top and bottom rows of magic paste rectangle}{if hangUpperLeft is true, then cell is the cell containing the mouse}{if hangUpperLeft is false, then cell is the mouseloc}		var			vertCells: integer;			cellPt: point;	begin		if ((cellBlock^.starttaxa > 0) and not editorTransposed) or ((cellBlock^.startchars > 0) and editorTransposed) then{then top and bottom bounds within data cells proper}			begin				if not editorTransposed then					VertCells := cellBlock^.ntax				else					VertCells := cellBlock^.nchar;				topcell := cell.v;				if topcell < 1 then					topcell := 1;				bottomcell := topcell + VertCells - 1;				if bottomcell > editorTotalRows then					bottomcell := editorTotalRows;				topcell := bottomcell - VertCells + 1;			end		else   {bound to top as column 0 or -1 selected}			begin				topcell := 1;				if ((cellBlock^.starttaxa = -1) and not editorTransposed) or ((cellBlock^.startchars = -1) and editorTransposed) then					bottomcell := editorTotalRows				else if ((cellBlock^.starttaxa = 0) and not editorTransposed) then					bottomcell := cellBlock^.ntax				else if ((cellBlock^.startchars = 0) and editorTransposed) then					bottomcell := cellBlock^.nchar;			end;	end;{-----------------------------------------------------------------------------}	procedure CalcSelOutline (cellBlock: CellBlockPtr; wh: point);{calculates cellBlock^.SelOutline for the editors "magic paste" feature}		var			topcell, bottomcell, d: integer;			left, right, top, bottom: integer;			cell: point;			leftcell, rightcell: integer;	begin		cell := FindCell(wh, true, false);		if editorTransposed then			begin				cellBlock^.currentStartChars := cell.v;				cellBlock^.currentStartTaxa := cell.h;			end		else			begin				cellBlock^.currentStartChars := cell.h;				cellBlock^.currentStartTaxa := cell.v;			end;		cellBlock^.currentEndChars := cellBlock^.currentStartChars+cellBlock^.nchar-1;		cellBlock^.currentEndTaxa :=cellBlock^.currentStartTaxa+cellBlock^.ntax-1;		CalcSelOutlineLeftRight(cellBlock, cell, leftcell, rightcell);		CellHor(leftcell, left, d, true);		CellHor(rightcell, d, right, true);		if left < editorFirstColumnLeft then			left := editorFirstColumnLeft;		if right > editorMatrixRect.right then			right := editorMatrixRect.right;		if right < left then			right := left;		CalcSelOutlineTopBottom(cellBlock, cell, topcell, bottomcell);		CellVer(topcell, top, d, true);		CellVer(bottomcell, d, bottom, true);		if top < editorFirstRowTop then			top := editorFirstRowTop;		if bottom > editorMatrixRect.bottom then			bottom := editorMatrixRect.bottom;		if bottom < top then			bottom := top;					SetRect(cellBlock^.visibleRect, left, top, right, bottom);	end;{----------------------------------------------------------------------------}	procedure DrawShimmerBox;	var tport: WindowPtr;	 begin		{ genericGetPort(tport);		 genericSetPort(editorWindow);		PenMode(patXor);		PenSize(3, 3);		FrameRect(editorShimmerRect);		PenNormal;		 genericSetPort(tport);}	 end;{----------------------------------------------------------------------------}	procedure InvalidateEditorSelectionRect(erase:boolean);	var tport: WindowPtr;		oldClip: RgnHandle;	 begin		 genericGetPort(tport);		 genericSetPort(editorWindow);		if erase then 			begin				oldClip := NewRgn;				GetClip(oldClip);				SetClip(EWClip);				EraseRect(editorSelectionRect);				SetClip(oldClip);				ZapRegion(oldClip);			end;		InvalidateWindowRect(editorWindow,editorSelectionRect,false);		 genericSetPort(tport);	 end;{----------------------------------------------------------------------------}	procedure DrawStampPasteBlock;	var tport: WindowPtr;	 begin		 genericGetPort(tport);		 genericSetPort(editorWindow);		{PenMode(patXor);		PenSize(3, 3);		FrameRect(editorShimmerRect);}		EWCurrentDrawBlockP:= EWScrapBlockP;		DrawAndCopyCellBlockImage(editorShimmerRect, -1, -1, -1, -1,writeClipBoard);				EWCurrentDrawBlockP := nil;		PenNormal;		 genericSetPort(tport);	 end;{----------------------------------------------------------------------------}	procedure HideStampPasteBlock;	var tPort: WindowPtr;	 begin	 	if not EmptyRect(editorShimmerRect) & editorOpen then	 		begin	 			genericGetPort(tport);			 	genericSetPort(editorWindow);				EraseRect(editorShimmerRect);				InvalidateWindowRect(editorWindow,editorShimmerRect,false);				if editorSelected then					InvalidateEditorSelectionRect(true);				{DrawStampPasteBlock;}				DrawShimmerBox;				SetRect(editorShimmerRect,0,0,0,0);				genericSetPort(tport);			end;	 end;{----------------------------------------------------------------------------}	procedure ShimmerStampPasteBlock (cellBlock: CellBlockPtr; wh: point);	var erased: boolean;		exposedRgn, oldShimmerRgn, newShimmerRgn: RgnHandle;		wasEmptyRect: boolean;		didScroll: boolean;		oldicstart,oldicend,icScrolled: integer;		pointMoved: point;	begin		if not CellBlockHasDataOfLegalSize(cellBlock) then			Exit(ShimmerStampPasteBlock);		erased := false;		wasEmptyRect := EmptyRect(editorShimmerRect);		oldicstart := cellBlock^.currentstartchars;		oldicend := cellBlock^.currentendchars;		CalcSelOutline(cellBlock,wh);		if not EmptyRect(editorShimmerRect) & not EqualRect(editorShimmerRect,cellBlock^.visibleRect) then  {it previously was calculated}			begin				oldShimmerRgn := NewRgn;				newShimmerRgn := NewRgn;				exposedRgn := NewRgn;				RectRgn(oldShimmerRgn, editorShimmerRect);				RectRgn(newShimmerRgn, cellBlock^.visibleRect);				DiffRgn(oldShimmerRgn,newShimmerRgn,exposedRgn);				DrawDataCellsInRgn(exposedRgn,selectionModeAsIs);				{InvalRgn(exposedRgn);				EraseRgn(exposedRgn);}				{DrawStampPasteBlock; }				DrawShimmerBox;				erased:= true;				ZapRegion(exposedRgn);				ZapRegion(newShimmerRgn);				ZapRegion(oldShimmerRgn);			end;		ScrollEditorToMouse(wh,cellBlock,true,true,didScroll, icScrolled, pointMoved);		CalcSelOutline(cellBlock, wh);		editorShimmerRect:= cellBlock^.visibleRect;		if erased  | wasEmptyRect then			begin				if wasEmptyRect then					InvalidateEditorSelectionRect(true);				DrawStampPasteBlock;				DrawShimmerBox;				if not wasEmptyRect then					begin						EWCurrentDrawBlockP:= cellBlock;						DrawConsensusBlock(cellBlock,oldicstart,oldicend);						EWCurrentDrawBlockP:= nil;					end;			end;	end;{----------------------------------------------------------------------------}	procedure StampPaste(ClickCell: point);	var db: boolean;	begin		UnselectAll;		if badcellEntry then			Exit(StampPaste);		HideStampPasteBlock;		CalcSelOutlineLeftRight(EWScrapBlockP, Clickcell, editorSelectionTopLeft.h, editorSelectionBotRight.h);		CalcSelOutlineTopBottom(EWScrapBlockP, Clickcell, editorSelectionTopLeft.v, editorSelectionBotRight.v);		{if not EqualPt(OldSelCellTL, editorSelectionTopLeft) or not EqualPt(OldSelCellBR, editorSelectionBotRight) then			begin				CleanOldCell(OldSelCellTL, OldSelCellBR);				if badcellentry then					Exit(ToolInDataEditor);				FixNewCell(editorSelectionTopLeft, editorSelectionBotRight);			end;}		FixNewCell(editorSelectionTopLeft, editorSelectionBotRight);		if StoreSelectedCellBlockForUndo(false,false,true) then			DoEWPaste;		{EraseRect(editorSelectionRect);		InvalidateWindowRect(editorWindow,editorSelectionRect,false);}	end;end.