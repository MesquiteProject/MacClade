unit MCEvents;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}interface	uses		QuickDraw, Printing,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  BoxUtil, MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, Coloring, Continuous, EditMenu, EditUtilMenu, FootNote, ChartWUtil, TraceControl, ScrollTree, TaxonCHUtil, MenuUtil, SpreadUtil, CharUtil, DrawSpread, EditControl, 		InfoWindows, TreeDrawer, Windows, BranchListWindow, GenCloseFile, GenOpenFile, 		ClickInInfoWindow, MouseInTree, ProcessMenu, legends, ChartWindow, 		TraceAllChangesCalc, IncExcTaxa, Cursor, Equivocal, Activates, TreeGet, ScrollSpread,		TextWindows, MouseInPalette, StatesWindowUtil;	procedure DealwthMouseDowns (Event: EventRecord);	procedure DealwthKeyDowns (Event: EventRecord);{еееееееееееееееееееееее}implementation{-----------------------------------------------------------------------------}	procedure DrawWindowSize (WhichWindow: WindowPtr);		var			box: rect;	begin		box := WindowPortRect(whichWindow);		box.top := box.bottom - 12;		box.left := box.right - 150;		EraseRect(box);		if (whichwindow = chartwindow) & myIsControlVisible(CWScroll) then  {v3.04}			MoveTo(box.left + 2, box.bottom - scrollwidth - 1)		else			MoveTo(box.left + 2, box.bottom - 1);		with WindowPortRect(whichWindow) do			DrawString(concat('width: ', StringFromNum(right), ' height: ', StringFromNum(bottom)));	end;{-----------------------------------------------------------------------------}	procedure FixSpecialMenus;{==== Option Menus =====}{remember: if you add one here, then you must switch the menu back when Option is not down}{also, beware that some menus (e.g. TWDisplayMHdl) are not always present, and setting a}{menu item from an absent menu can lead to nasty things happening}	begin		if (frontWindow <> nil) & LockedToTreeWindow(frontWindow) then			myEnableItem(TWDisplayMHdl, TipLabelsItem)		else			myDisableItem(TWDisplayMHdl, TipLabelsItem);		if paupCommandCopyToClipBoard <> OptionEvent(Event) then			SetMenuItemText(EditMHdl, CopyPAUPSubmenuItem, 'Copy PAUP Command')		else			SetMenuItemText(EditMHdl, CopyPAUPSubmenuItem, 'Place PAUP Command');		if IsTreeWindow(frontWindow) then			if OptionEvent(Event) then				SetMenuItemText(EditMHdl, CopyItem, 'Copy Text Tree')			else				SetMenuItemText(EditMHdl, CopyItem, 'Copy...')		else if IsEditorWindow(frontWindow) then			begin				if OptionEvent(Event) & editorSelected & not SingleCell then					SetMenuItemText(EditMHdl, CopyItem, 'Copy as Text')				else					SetMenuItemText(EditMHdl, CopyItem, 'Copy...');			end		else			SetMenuItemText(EditMHdl, CopyItem, 'Copy');		if nucleotides & not (newfile & not dirtyfile) then			SetMenuItemText(xxDataFormatMHdl, proteinItem, 'Translate to Protein...')		else			SetMenuItemText(xxDataFormatMHdl, proteinItem, 'Protein');				if editorOpen then			if editorSelected & ((editorSelectionBotRight.v > 0) & (editorSelectionBotRight.h > 0)) then			  SetMenuItemText(EdUtilitiesMHdl, RandomFillItem, 'Fill Random...')			else			  SetMenuItemText(EdUtilitiesMHdl, RandomFillItem, 'Set Fill Frequencies...');		EnableDisableItem(CharactersMHdl, xxxxCodonPosItem, fileopen & nucleotides & not Locked(lockAssumptions));		EnableDisableItem(TaxaMHdl, ImportTaxaSubmenuItem, fileopen & editorOpen & not Locked(lockData)& (allowImportMoleculeIntoStandard | molecular| (newfile & not dirtyfile)));		if ControlEvent(Event) then			SetMenuItemText(FileMHdl, PreferenceItem, 'Restore Messages')		else if OptionEvent(Event) then			SetMenuItemText(FileMHdl, PreferenceItem, 'Save All Preferences')		else			SetMenuItemText(FileMHdl, PreferenceItem, 'Save Preferences...');					if editorOpen then				if OptionEvent(Event) then					begin						SetMenuItemText(EdUtilitiesMHdl, CondenseTaxonNamesItem, 'Hide Taxon Names in Translation File');						SetMenuItemText(EdUtilitiesMHdl, TranslateTaxonNamesItem, 'Make Taxon Names Unique');					end				else					begin						SetMenuItemText(EdUtilitiesMHdl, CondenseTaxonNamesItem, 'Condense Taxon Names...');						SetMenuItemText(EdUtilitiesMHdl, TranslateTaxonNamesItem, 'Translate Taxon Names...');					end;							if OptionEvent(Event) then			begin				SetMenuItemText(EditMHdl, TransferSelectionItem,'Deselect Same in List Window');				SetMenuItemText(EditMHdl, MoveSelectedRowsToTopItem, 'Move Selected Rows to Bottom');				//SetMenuItemText(FileMHdl, QuitItem, 'Restore Messages');				SetMenuItemText(FileMHdl, PageSetUpItem,'Default Print Settings');				if fileopen then					begin						SetMenuItemText(FileMHdl, SaveDataAsItem, 'Save Stationery As...');						if nucleotides & ControlEvent(Event) then							SetMenuItemText(EditMHdl, ContinuousEditItem, 'Set Next Conts to GC Bias');{$IFC MEGA}								{SetMenuItemText(ExpFileMHdl, HennigFileItem, 'MEGA 1...');}{$ENDC}					end;				if treeopen then					begin{$IFC PROBRECONSTRUCT}					//	SetMenuItemText(TraceMHdl, AllStatesOptionsItem, 'Trace Probabilities...');						SetMenuItemText(NewChartMHdl, sStatesItem, 'Probability of Steps...');{$ENDC}{$IFC DEBUG}						SetMenuItemText(TraceMHdl, TraceAllChangesItem, 'Consistency check...');{$ENDC}					end;				if editorOpen then					begin						{if editorSelected & not SingleCell then}						FixChangeAllSubmenuName(false);					{	if (TaxonOfCell(editorSelectionTopLeft)>0) then							SetMenuItemText(EdUtilitiesMHdl, FillItem, 'Condense Taxon Names...');}						if (AnyFeet(footText) or AnyFeet(footPict)) then							SetMenuItemText(EditMHdl, ClearItem, 'Remove All Selected Footnotes');					{	if nucleotides then							SetMenuItemText(EdUtilitiesMHdl, SearchAndReplaceItem, 'Remove Terminal Partial Triplets');}						if editorSelected then							SetMenuItemText(EdUtilitiesMHdl, SpeakMatrixItem, 'Speak Selected');{$IFC false}						SetMenuItemText(EdUtilitiesMHdl, RandomFillItem, 'Fill With Observed...');{$ENDC}					end;			end		else{==== non-Option Menus =====}			begin				SetMenuItemText(EditMHdl, TransferSelectionItem,'Select Same in List Window');				SetMenuItemText(EditMHdl, MoveSelectedRowsToTopItem, 'Move Selected Rows to Top');				SetMenuItemText(FileMHdl, PageSetUpItem,'Page Setup...');				//SetMenuItemText(FileMHdl, QuitItem, 'Quit');				if fileopen then					begin						SetMenuItemText(FileMHdl, SaveDataAsItem, 'Save File As...');						{SetMenuItemText(ExpFileMHdl, NBRFFileItem, 'NBRF...');}{$IFC MEGA}						{SetMenuItemText(ExpFileMHdl, HennigFileItem, 'HENNIG86 1.5...');}{$ENDC}						SetMenuItemText(EditMHdl, ContinuousEditItem, 'Edit Continuous...');					end;				if treeopen then					begin{$IFC PROBRECONSTRUCT}					//	SetMenuItemText(TraceMHdl, AllStatesOptionsItem, 'All States Options...');						SetMenuItemText(NewChartMHdl, sStatesItem, 'States...');{$ENDC}{SetMenuItemText(TWDisplayMHdl, CharInfoItem, 'Character Status');}{$IFC DEBUG}						SetMenuItemText(TraceMHdl, TraceAllChangesItem, 'Trace All Changes');{$ENDC}					end;				if editorOpen then					begin						FixChangeAllSubmenuName((editorSelected & not SingleCell & someDataSel));						//SetMenuItemText(EdUtilitiesMHdl, SearchAndReplaceItem, 'Search & Replace...');						if editorSelected then							SetMenuItemText(EditMHdl, ClearItem, 'Clear');						{SetMenuItemText(EdUtilitiesMHdl, FillItem, 'Fill...');}						SetMenuItemText(EdUtilitiesMHdl, SpeakMatrixItem, 'Speak Matrix');					end;			end;{=====================}	end;{-----------------------------------------------------------------------------}	procedure GrowInfoWindow (whichinfo, width, height: integer);		var			tempP: WindowPtr;	begin		genericGetPort(tempP);		genericSetPort(infoWindow[whichinfo]);{calc so height is div infoLW[whichinfo] }		ShrinkWrapInfoWindow(whichinfo, height,width);		SizeWindow(infoWindow[whichinfo], width, height, TRUE);		ClipRect(WindowPortRect(infowindow[whichInfo]));		EraseREct(WindowPortRect(infowindow[whichInfo]));		ResetInfoScroll(whichinfo);{    SizeControl(infoScroll[whichinfo], scrollwidth + 1, height - scrollwidth - infoLW[whichinfo] + 2);}{    ShowControl(infoScroll[whichinfo]);}		CalcInfoButtonRowBoxes(whichinfo);		AdjustInfoScrolls(whichinfo);		if infoEditing[whichinfo] then									MoveInfoTE(whichinfo, infoEditRow[whichinfo]);    {added to 4.01}		InvalidateWindowRect(infoWindow[whichinfo],WindowPortRect(infowindow[whichInfo]),false);		genericSetPort(tempP);	end;{-----------------------------------------------------------------------------}	procedure GrowTheWindow (whichWindow: WindowPtr; mouseLoc: Point);		var			pos: Point;			whichToolPalette: integer;			VandH, dL: longint;			Location, WindoLoc, j, Height, Width, oldHeight, oldwidth: Integer;			Limits, box: Rect;			wasfix, bounce: boolean;			whichInfo, whichText: integer;			minWidth, maxWidth: integer;	begin		if whichwindow = editorWindow then			SetRect(Limits, editorFirstColumnLeft + scrollwidth + editorColumnWidth, editorTitleLineWidth * 2 + scrollwidth + editorLineWidth + notewidth, ScreenBoundsRect.right - ScreenBoundsRect.left, ScreenBoundsRect.bottom - ScreenBoundsRect.top)		else if (whichWindow = treewindow) then			begin				if locklegends then					SetRect(Limits, 320 + scrollwidth, IntegerMax(databoxB.bottom + 4, 222) + scrollwidth, ScreenBoundsRect.right - ScreenBoundsRect.left, ScreenBoundsRect.bottom - ScreenBoundsRect.top)				else					SetRect(Limits, 135 + scrollwidth, IntegerMax(databoxB.bottom + 4, 120) + scrollwidth, ScreenBoundsRect.right - ScreenBoundsRect.left, ScreenBoundsRect.bottom - ScreenBoundsRect.top)			end		else if (whichWindow = pictwindow) then			SetRect(Limits, 80 + scrollwidth, 80 + scrollwidth, grabpicture^^.picframe.right - grabpicture^^.picframe.left + scrollwidth + pictmargin, grabpicture^^.picframe.bottom - grabpicture^^.picframe.top + scrollwidth + pictmargin)		else if (whichWindow = ChartWindow) then			SetRect(Limits, 280 + scrollwidth, 80 + scrollwidth, ScreenBoundsRect.right - ScreenBoundsRect.left, ScreenBoundsRect.bottom - ScreenBoundsRect.top)		else if IsInfoWindow(whichWindow) then			begin				whichInfo := WhichInfoWindow(whichWindow);				if infoWithToolRow[whichinfo] then					dL := longint(MaximumInfoRows(whichinfo) + infoTitleLines) * infoLW[whichInfo] + scrollwidth + 2 + infoButtonRowHeight				else					dL := longint(MaximumInfoRows(whichinfo) + infoTitleLines) * infoLW[whichInfo] + scrollwidth + 2;				if dL > 32000 then					dL := 32000;				if infoWithButtons[whichinfo] then					minWidth := (WindowPortRect(infowindow[whichInfo]).right - myGetControlRect(infoWindowButton[whichinfo]).left)+infoTools^[whichinfo,numInfoTools].R.right+2				else					minWidth := infoTools^[whichinfo,numInfoTools].R.right+2;				if MaximumInfoColumns(whichinfo) > 1 then					begin						if minWidth < InfoColumnRight(whichinfo, infoName) + 50 then							minWidth := InfoColumnRight(whichinfo, infoName) + 50;					end				else					begin						if minWidth < InfoColumnRight(whichinfo, infoName) + 2 then							minWidth := InfoColumnRight(whichinfo, infoName) + 2;					end;				maxWidth := InfoColumnRight(whichinfo, MaximumInfoColumns(whichInfo)) + scrollwidth + 1;				if maxWidth < minWidth then 					maxWidth := minWidth;				SetRect(Limits, minWidth, (infoRowsPreferredMinimum + infoTitleLines) * infoLW[whichInfo] + scrollwidth + 2, maxWidth, IntegerMin((ScreenBoundsRect.bottom - ScreenBoundsRect.top), dL));			end		else if IsPaletteWindow(whichWindow) then				SetRect(Limits,  (toolCellWidth-1)+2,  (toolCellWidth-1)+2, ScreenRectangle.right - ScreenRectangle.left, ScreenRectangle.bottom - ScreenRectangle.top)		{		SetRect(Limits,  (toolCellWidth-1)*3+2,  (toolCellWidth-1)+2, ScreenRectangle.right - ScreenRectangle.left, ScreenRectangle.bottom - ScreenRectangle.top)}		else if IsTextWindow(whichWindow) then			SetRect(Limits, 60 + scrollwidth, 60 + scrollwidth, ScreenRectangle.right - ScreenRectangle.left, ScreenRectangle.bottom - ScreenRectangle.top)		else if (whichWindow = stateswindow) then			SetRect(Limits, charNameBoxStart + scrollwidth+5, statesWindowTitleWidth + scrollwidth+statesWindowLineWidth+2, ScreenRectangle.right - ScreenRectangle.left, ScreenRectangle.bottom - ScreenRectangle.top)		else if whichWindow = BranchListwindow then			SetRect(Limits, 120 + scrollwidth, 12 + scrollwidth, ScreenBoundsRect.right - ScreenBoundsRect.left, ScreenBoundsRect.bottom - ScreenBoundsRect.top);		oldHeight := WindowPortRect(whichWindow).bottom - WindowPortRect(whichWindow).top;		oldwidth := WindowPortRect(whichWindow).right - WindowPortRect(whichWindow).left;		VandH := GrowWindow(whichwindow, mouseLoc, @Limits);		Height := HighWord(VandH);		Width := LowWord(VandH);		if (VandH <> 0) and ((oldHeight <> height) or (oldwidth <> width)) then			begin				if whichwindow = treewindow then					begin						genericSetPort(treewindow);						ClipRect(WindowPortRect(whichWindow));{next section tests to see if window grows beyond size of tree, if so, bounces tree down or to the}{right to fill the window}						bounce := false;						if (twOrigin.v + height > drawTWR.bottom) then							begin								TWOrigin.v := drawTWR.bottom - height;								if TWOrigin.v < 0 then									TWOrigin.v := 0;								bounce := true;							end;						if (twOrigin.h + width > drawTWR.right) then							begin								TWOrigin.h := drawTWR.right - width;								if TWOrigin.h < 0 then									TWOrigin.h := 0;								bounce := true;							end;						if bounce then							SetDrawTWRControls;						maxTWR.right := maxTWR.left + width;						maxTWR.bottom := maxTWR.top + height;						HideControl(vTWScroll);						HideControl(hTWScroll);						SizeWindow(whichWindow, width, height, true);						SizeTreeWindow;						genericSetPort(treewindow);						ClipRect(WindowPortRect(whichWindow));						EraseREct(WindowPortRect(whichWindow));						InvalidateWindowRect(whichwindow,WindowPortRect(whichWindow),false);						ClipRect(visTWR);					end				else if (whichwindow = pictwindow) or (whichwindow = ChartWindow) then					begin						genericSetPort(whichwindow);						ClipRect(WindowPortRect(whichWindow));						SizeWindow(whichWindow, width, height, TRUE);						ClipRect(WindowPortRect(whichWindow));						EraseREct(WindowPortRect(whichWindow));						InvalidateWindowRect(whichwindow,WindowPortRect(whichWindow),false);						if (Whichwindow = Chartwindow) and CWLinear then							begin								CalcCWBoxes(WindowPortRect(chartWindow));							end;						if OptionEvent(Event) then							if whichwindow = chartwindow then								DrawWindowSize(whichwindow);					end				else if IsPaletteWindow(whichWindow) then					begin						genericSetPort(whichwindow);						whichToolPalette := WhichPaletteWindow(whichWindow);						GetToolBoxArrangment(whichToolPalette,height,width,horizontalTools[whichToolPalette],verticalTools[whichToolPalette]);						ReSizeToolPalette(whichToolPalette,horizontalTools[whichToolPalette],verticalTools[whichToolPalette]);					end				else if whichwindow = editorWindow then					begin						maxEWR.right := maxEWR.left + width;						maxEWR.bottom := maxEWR.top + height;						ReSizeEditorWindow;					end				else if IsInfoWindow(whichwindow) then					GrowInfoWindow(WhichInfoWIndow(whichwindow), width, height)				else if whichwindow = BranchListwindow then					GrowBranchList(width, height)				else if whichwindow = stateswindow then  					begin						ShrinkWrapStatesWindow(height);						SizeWindow(statesWindow, width, height, TRUE);						if statesEditing then							MoveStatesTE(stateBeingEdited);						ClipRect(WindowPortRect(stateswindow));						EraseREct(WindowPortRect(stateswindow));						AdjustStatesVScrolls;						ResetStatesScroll;						InvalidateWindowRect(statesWindow,WindowPortRect(stateswindow),false);					end				else if IsTextWindow(whichwindow) then					begin						whichText := WhichTextWindow(whichWindow);						ClipRect(WindowPortRect(whichWindow));						EraseREct(WindowPortRect(whichWindow));						ReSizeTextWindow(whichText, height, width, true);						SizeTextWindowText(whichText, true, true, false);						InvalidateWindowRect(whichwindow,WindowPortRect(whichWindow),false);					end;			end;	end;{-----------------------------------------------------------------------------}	function FrontAndWhichBothTreeOrEdit(WP, FWP: WindowPtr): boolean;	var db: boolean;		db2: boolean;	begin		{if front window is a MacClade window, and if both the front window and		the window touched upon is a treewindow, or both are editwindows, then don't select it}		db:= MacCladeWindow(FrontWindow);{$IFC FALSE}		if MacCladeWindow(FrontWindow) then			writeln(tempFile, '   еее FrontWindow is MacClade window');		if (GetWindowType(FWP) <= TWLoose) then			writeln(tempFile, concat('   еее (GetWindowType(FWP) <= TWLoose): ',StringFromNum(GetWindowType(FWP))));		if (GetWindowType(WP) <= TWLoose) then			writeln(tempFile, concat('   еее (GetWindowType(WP) <= TWLoose): ',StringFromNum(GetWindowType(WP))));		if (IsEditorWindow(FWP)) then			writeln(tempFile, '   еее (IsEditorWindow(FWP))');		if (IsEditorWindow(WP)) then			writeln(tempFile, '   еее (IsEditorWindow(WP))');	writeln(tempFile, concat('      FWP: ',StringFromNum(longint(FWP))));	writeln(tempFile, concat('      WP: ',StringFromNum(longint(WP))));	writeln(tempFile, concat('      editorWindow: ',StringFromNum(longint(editorWindow))));	writeln(tempFile, concat('      chlegwindow: ',StringFromNum(longint(chlegwindow))));	writeln(tempFile, concat('      tlegwindow: ',StringFromNum(longint(tlegwindow))));	writeln(tempFile, concat('      treewindow: ',StringFromNum(longint(treewindow))));	writeln(tempFile, concat('      BranchListwindow: ',StringFromNum(longint(BranchListwindow))));	writeln(tempFile, concat('      stateswindow: ',StringFromNum(longint(stateswindow))));	if IsInfoWindow(FWP) then		writeln(tempFile, 'FWP is an infoWindow');	if IsTextWindow(FWP) then		writeln(tempFile, 'FWP is a textWindow');	if IsPaletteWindow(FWP) then		writeln(tempFile, 'FWP is a paletteWindow');	if IsInfoWindow(WP) then		writeln(tempFile, 'WP is an infoWindow');	if IsTextWindow(WP) then		writeln(tempFile, 'WP is a textWindow');	if IsPaletteWindow(WP) then		writeln(tempFile, 'WP is a paletteWindow');	writeln(tempFile, concat('      pictwindow: ',StringFromNum(longint(pictwindow))));	writeln(tempFile, concat('      ChartWindow: ',StringFromNum(longint(ChartWindow))));	writeln(tempFile, concat('      twmesswindow: ',StringFromNum(longint(twmesswindow))));{$ENDC}		FrontAndWhichBothTreeOrEdit:= MacCladeWindow(FrontWindow) and (((GetWindowType(FWP) <= TWLoose) and (GetWindowType(WP) <= twloose)) or (IsEditorWindow(FWP) and IsEditorWindow(WP)));	end;{-----------------------------------------------------------------------------}	procedure DealwthMouseDowns (Event: EventRecord);		label 1;		var			WhichWindow, tempP: WindowPtr;			WP, FWP: WindowPtr;			MouseLoc: Point;			horMove, vertMove: integer;			VandH, dL: longint;			Location, WindoLoc, j, Height, Width, oldHeight, oldwidth: Integer;			DragArea, Limits, box: Rect;			doselect, wasfix, bounce: boolean;			theRgn: RgnHandle;			whichToolPalette: integer;			gp: GrafPtr;	begin		doselect := false;		MouseLoc := Event.Where;		WindoLoc := FindWindow(MouseLoc, WhichWindow);		WP := WhichWindow;		FWP := frontwindow;		if ((Event.when - oldtime) < GetDblTime) then			dblclick := true;		case WindoLoc of			inMenuBar: 				begin					if IsInfoWindow(frontwindow) then						FixSelectMenu(WhichInfoWindow(frontWindow));					FixSpecialMenus;{EnableDisableAllMenus;}					FixTreeFlash;					cantear := true;					ProcessMenu(MenuSelect(mouseloc));				end;{$IFC NOT CARBON}			inSysWindow: 				SystemClick(Event, WhichWindow);{$ENDC}			inGoAway: 				if TrackGoAway(whichWindow, Event.where) then					if (whichWindow=chlegWindow) then						CharLegendGoAway					else						CloseWindowPtr(whichWIndow,true,true);			inContent: 				begin					if not FrontAndWhichBothTreeOrEdit(WP,FWP) and (whichWindow <> FrontWindow) then						begin							doselect := true;							if not IsPaletteWindow(whichWindow)  then								goto 1;						end;					if whichWindow = editorWindow then						MouseInEdit(Event)					else if (whichWindow = TreeWindow) then						begin							genericGetPort(tempP);							genericSetPort(treewindow);							MouseInTree;							genericSetPort(tempP);						end					else if IsInfoWindow(whichWindow) then						ClickInInfoWindow(WhichInfoWindow(whichWindow))					else if (whichWindow = BranchListWindow) then						MouseInBranchList					else if (whichWindow = statesWindow) then						ClickInStatesWindow(Event)					else if whichwindow = twmesswindow then						MouseInTWMessage					else if IsTextWindow(whichWindow) then						MouseInTextWindow(WhichTextWindow(whichWindow), Event)					else if (whichWindow = ChartWindow) then						MouseInChartWindow(Event.where)					else if IsPaletteWindow(whichwindow) then						begin							whichToolPalette := WhichPaletteWindow(whichWindow);							genericGetPort(tempP);							genericSetPort(whichWindow);							wh:= mouseLoc;							GlobalToLocal(wh);							genericSetPort(tempP);							if useOldFloatingWindows & PtInRect(wh,paletteGrowBox[whichToolPalette]) then								GrowTheWindow(whichWindow,mouseLoc)							else								MouseInPaletteWindow(whichToolPalette, mouseLoc);						end					else if (whichwindow = tlegwindow) then						MouseInTreeLeg					else if (whichwindow = chlegwindow) then						MouseInChLeg;				end; {in Content}			inGrow: 				if not FrontAndWhichBothTreeOrEdit(WP,FWP) and (whichwindow <> FrontWindow) then					doselect := true				else					GrowTheWindow(whichwindow, mouseLoc);			inDrag: 				if not FrontAndWhichBothTreeOrEdit(WP,FWP) and (whichwindow <> FrontWindow) then					doselect := true				else if StillDown then   {check to see that mouse is still down}					begin						DragArea := ScreenBoundsRect;						InsetREct(DragArea, 4, 4);						DragArea.top := DragArea.top + 12;{$IFC FALSE}						if MacCladeWindow(FrontWindow) and (GetWindowType(FWP) <= TWLoose) and (whichwindow = treewindow) then							begin								genericSetPort(treewindow);								box := WindowPortRect(treeWindow);								LocalToGlobal(box.topleft);								LocalToGlobal(box.botright);								box.top := box.top - 20; {for title bar}{$IFC NOT CARBON}								gp := GrafPtr(NewPtr(sizeof(GrafPort)));								OpenPort(gp);{$ELSEC}								gp := CreateNewPort;{$ENDC}																genericSetPort(myGetWindowFromPort(gp));								theRgn := NewRgn;								RectRgn(theRgn, box);								VandH := DragGrayRgn(theRgn, mouseloc, dragarea, dragarea, 0, nil);								if (VandH <> 0) and (VandH <> $80008000) then									begin										horMove := LowWord(VandH);										vertMove := HighWord(VandH);										MoveWindow(treewindow, box.left + horMove, box.top + 20 + vertMove, false);									end;								ZapRegion(theRgn);{$IFC NOT CARBON}								ClosePort(gp);								ZapPointer(gp);{$ELSEC}								DisposePort(gp);{$ENDC}																genericSetPort(treewindow);								SetLockLegPts(twmesswindow, -1);								MoveWindow(twmesswindow, messspot.h, messspot.v, false);								if locklegends then									begin										SetLockLegPts(tlegwindow, -1);										MoveWindow(tlegwindow, tlegpt.h, tlegpt.v, false);										if WindowVisible(chlegwindow) then											begin												SetLockLegPts(chlegwindow, -1);												MoveWindow(chlegwindow, chlegpt.h, chlegpt.v, false);											end;									end;							end						else {$ENDC}							if not (locklegends & ((whichWindow=chLegWindow)|(whichWindow=tLegWindow))) then							begin								DragWindow(whichwindow, mouseLoc, @DragArea);								if FrontAndWhichBothTreeOrEdit(WP,FWP) then									doselect := true;								if (whichWindow=treeWindow) then									begin										SetLockLegPts(twmesswindow, -1);										MoveWindow(twmesswindow, messspot.h, messspot.v, false);										if locklegends then											begin												SetLockLegPts(tlegwindow, -1);												MoveWindow(tlegwindow, tlegpt.h, tlegpt.v, false);												if WindowVisible(chlegwindow) then													begin														SetLockLegPts(chlegwindow, -1);														MoveWindow(chlegwindow, chlegpt.h, chlegpt.v, false);													end;											end;									end;							end;					end;			7: 				if not FrontAndWhichBothTreeOrEdit(WP,FWP) and (whichwindow <> FrontWindow) then					doselect := true				else if TrackBox(whichwindow, mouseLoc, 7) then					Zoom(whichwindow, 7);			8: 				if not FrontAndWhichBothTreeOrEdit(WP,FWP) and (whichwindow <> FrontWindow) then					doselect := true				else if TrackBox(whichwindow, mouseLoc, 8) then					Zoom(whichwindow, 8);			otherwise				if not FrontAndWhichBothTreeOrEdit(WP,FWP) and (whichwindow <> FrontWindow) then					doselect := true				;		end;1:		if doselect then			if (GetWindowType(WP) <= twloose)  then				begin					SelectTreeWindows;					if whichWindow=BranchListWindow then						SelectWindow(BranchListWindow);				end			else if IsEditorWindow(WP)  then				begin					SelectEditorWindows;				end			else 				begin					SelectWindow(whichWindow);				end;		dblclick := false;		oldtime := Event.when;{    if whichwindow = editorWindow then FlushEvents(mDownMask + keydownmask, 0);  prevents override of updating}	end;{-----------------------------------------------------------------------------}	procedure DealwthKeyDowns (Event: EventRecord);		var			theChar: CHAR;			code, extcode: integer;			newi, newicont, j: integer;			dotrees, success, db: boolean;			editcode, newLink: longint;			scrollMax: integer;			tempP: WindowPtr;			whichText, whichInfo: integer;	begin		editcode := BitShift(EditMenu, 16);		code := Event.message mod 256;		extcode := (Event.message div 256) mod 256;		theChar := CHR(code);{v4:  pgup - 74, pgdown - 79, end - 77}		if (frontwindow = nil) | MacCladeWindow(frontwindow) then  {this is done as DA's not under MF pass keydowns to MacClade}			{if extcode = $72 then				ShowHelp(1)			else }if extcode = $7A then				ProcessMenu(Editcode + UndoItem)			else if extcode = $73 then				ScrollHome			else if extcode = $78 then				ProcessMenu(Editcode + CutItem)			else if extcode = $63 then				ProcessMenu(Editcode + CopyItem)			else if extcode = $76 then				ProcessMenu(Editcode + PasteItem)			else if CommandEvent(Event) then				begin					FixTreeFlash;					ProcessMenu(MenuKey(theChar));				end			{else if frontwindow = commwindow then				begin					genericSetPort(commwindow);					TEKey(theChar, commentsTE[curcom]);					if curcom = treefilecom then						dirtytreefile := true					else						dirtyfile := true;					SizeCommWindowText(true, false, true);					FixEditMenu;   				end}			else if IsEditorWindow(frontwindow) then				KeyInEdit(theChar)			else if frontwindow = statesWindow then				KeyInStatesWindow(theChar, Event)			else if IsEditableTextWindow(frontwindow) then				begin					whichText := WhichTextWindow(frontWindow);					genericSetPort(textWindow[whichText]);					TEKey(theChar, textWindowInfo[whichText]^.TE);					if whichText = aboutTreeFileText then						dirtyTreeFile := true					else						dirtyfile := true;					SizeTextWindowText(whichText, false, false, true);  {was true false true}					FixEditMenu;   {v4: could this be reduced to a smaller version?}				end			else if IsInfoWindow(frontWindow) then				KeyInInfoWindow(WhichInfoWindow(frontwindow), theChar)		{	else if EscapeChar(theChar) then					begin				end}			else if treeopen & LockedToTreeWindow(frontwindow) then				begin					genericGetPort(tempP);					if not equivcycle then						if (theChar = char(upA)) then							begin								setcursor(clockCursor);								{oldtreelinknumber := linknumber[treechain];}								if dirtytree or (LinkNumber[treechain] < StartUserLink(treechain)) then									newLink := StartUserLink(treechain)								else									newLink := Linknumber[treechain] + 1;								if newLink > EndUserLink(treechain) then									Beep								else									db := GoToTree(NewLink);							end						else if (theChar = char(downA)) then							begin								setcursor(clockCursor);								{oldtreelinknumber := linknumber[treechain];}								newLink := Linknumber[treechain] - 1;								if dirtytree or (newLink < StartUserLink(treechain)) then									Beep								else									db := GoToTree(NewLink);							end						else if (traceshown = traceDiscrete) & (theChar = char(rightA)) then							begin								newi := NextIncludedChar(i + 1);								if i = newi then									Beep								else									TurnOnTrace(i, newi);							end						else if (traceshown = traceDiscrete) & (theChar = char(leftA)) then							begin								newi := PrevIncludedChar(i - 1);								if i = newi then									Beep								else									TurnOnTrace(i, newi);							end						else if (traceshown = traceContinuous) & (theChar = char(rightA)) then							begin								newicont := NextCompleteCont(icont + 1,true);								if icont = newicont then									Beep;								icont := newicont;{FROZEN 3.0}								golist := golist + [GOcontinuous];  {do continuous calculations}							end						else if (traceshown = traceContinuous) & (theChar = char(leftA)) then							begin								newicont := PrevCompleteCont(icont - 1,true);								if icont = newicont then									Beep;								icont := newicont;{FROZEN 3.0}								golist := golist + [GOcontinuous];  {do continuous calculations}							end;					genericSetPort(tempP);				end;{    if thewindow = editorWindow then FlushEvents(mDownMask + keydownmask, 0);  prevents override of updating}	end;end.