unit ChartWText;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, BoxUtil, CharUtil, StrUtil, MenuUtil, SymbolsNames, WriteUtil, TreeUtil, TypeUtil, TaxonCHUtil, ChartWUtil;	procedure DrawChartText (boundary: rect);{еееееееееееееееееееееее}implementation {е$S ChartWText}{-----------------------------------------------------------------------------}	function TotalLinear (theCLKind: integer; weighted: boolean): double;{if weighted is true, then we want the sum of the category value * data value}{	- used for traced steps, or generally when steps is on the horizontal axis}{if weighted is false, then we simply want the sum of the data values}		var			tot: double;			j: integer;			divvalue: double;	begin		tot := 0;		if MeanSpotBar(theCLKind) then			divvalue := 1.0 * MeanInflate * catwid		else			divvalue := 1.0;		if weighted then			for j := 0 to numIntervals[theCLkind] - 1 do				tot := tot + (GetChartLinearCategory(theCLkind, j) * GetChartLinearData(theCLkind, j)) / divvalue		else			for j := 0 to numIntervals[theCLkind] - 1 do				tot := tot + GetChartLinearData(theCLkind, j) / divvalue;		TotalLinear := tot;	end;{-----------------------------------------------------------------------------}	procedure DrawChartText (boundary: rect);		var			j, it, positive, negative, theData: integer;			posweighted, negweighted, totalhits: longint;			box: rect;			ds, ds2,setName: str255;			setToCalc: set15;			numtoshow: integer;			oldState: SignedByte;{...............................}		function TreeCompareName (whichT: integer): str255;			var				oldstate: SignedByte;		begin			if CWChart = CWCC2TF then				begin					LockHandle(extratreefilename[whichT + 1], oldstate);					TreeCompareName := concat('All trees in ', extratreefilename[whichT + 1]^^);					ResetHandle(extratreefilename[whichT + 1], oldstate);				end			else				TreeCompareName := LinkNameFromChain(treechain, twotrees[whichT]);		end;{...............................}		procedure DrawStatesText;			var				TaxonHdl: thdl;				j, it: integer;				min, max, tot, numDataTaxa: longint;				maxds, minds: str255;				minReal, maxReal, totReal, curReal: double;		begin{V4: don't actually need 2 separate listings if no missing or gaps}			DrawWriteStringLn('Average and ranges of frequencies');			DrawWriteStringLn(' across taxa in tree for states of all characters (missing data and gaps included):');			for j := 0 to maxChartLinearCat do				begin					min := numcharin;					max := 0;					tot := 0;					for it := 1 to numtaxa do						if TaxonInTree(it) then							begin								TaxonHdl := getTaxonHdl(it);								ReplaceIfMaximumLong(max, taxonHdl^^.tipNumbers[j]);								ReplaceIfMinimumLong(min, taxonHdl^^.tipNumbers[j]);								tot := tot + taxonHdl^^.tipNumbers[j];							end;					if CWTraced then						DrawWriteString(AvailCharStateName(i, j))					else if datatype = protein then						DrawWriteString(AminoAcidName(j))					else						DrawWriteString(CharOfNum(j));					RealToString(tot / numcharin / numtaxain, maxds, 100000, 3, not DrawToFile or writeexpon);					DrawWriteString(concat('      Average: ', maxds));					RealToString(min / numcharin, minds, 100000, 3, not DrawToFile or writeexpon);					RealToString(max / numcharin, maxds, 100000, 3, not DrawToFile or writeexpon);					DrawWriteStringLn(concat('      Range: ', minds, ' - ', maxds));				end;			DrawWriteStringLn(' ');  {v3.01}			DrawWriteStringLn('Average and ranges of frequencies');			DrawWriteStringLn(' across taxa in tree for states of all characters (missing data and gaps excluded):');			for j := 0 to maxChartLinearCat do				begin					minReal := 1.0;					maxReal := 0.0;					totReal := 0.0;					numDataTaxa := 0;					for it := 1 to numtaxa do						if TaxonInTree(it) then							begin								TaxonHdl := getTaxonHdl(it);								if taxonHdl^^.dataPoints > 0 then   {v3.01 number of data points calculated in ChartWCalc}									begin										curReal := taxonHdl^^.tipNumbers[j] / taxonHdl^^.dataPoints;										if maxReal < curReal then											maxReal := curReal;										if minReal > curReal then											minReal := curReal;										totReal := totReal + curReal;										numDataTaxa := numDataTaxa + 1;									end;							end;					if totReal = 0.0 then						minreal := 0.0;					if CWTraced then						DrawWriteString(AvailCharStateName(i, j))					else if datatype = protein then						DrawWriteString(AminoAcidName(j))					else						DrawWriteString(CharOfNum(j));					if numDataTaxa = 0 then						maxDs := '0.0'					else						RealToString(totReal / numDataTaxa, maxds, 100000, 3, not DrawToFile or writeexpon);					DrawWriteString(concat('      Average: ', maxds));					RealToString(minReal, minds, 100000, 3, not DrawToFile or writeexpon);					RealToString(maxReal, maxds, 100000, 3, not DrawToFile or writeexpon);					DrawWriteStringLn(concat('      Range: ', minds, ' - ', maxds));				end;		end;{...............................}		procedure DrawStepsText;			var				theKind: integer;				theInflation: longint;		begin			if sequencechart or positionchart then				theInflation := DataInflation			else				theInflation := CategoryInflation;			if CWTrees[CWCSteps] = CWCurrentTree then				begin					DrawWriteStringLn(concat('Treelength: ', LengthString(treelength, true)));					RealToString((treelength * 1.0) / lengthInflate / numcharin, ds, 100000, 3, not DrawToFile or writeexpon);{>>>>>>>>>>>>>>>>}					DrawWriteStringLn(concat('Average number of steps per character: ', ds));				end			else				DrawWriteStringLn(concat('Number of Trees: ', StringFromNum(numCWTrees)));			DrawWriteStringLn(' ');			if not CWTraced then				DrawWriteStringLn(concat('Number of Characters: ', StringFromNum(numCWChars)))			else				DrawWriteStringLn(' ');			if CatWid = 1 then				if CWStepsShow in [CwstepsSteps, CWStepsChanges] then					begin						for theKind := 0 to numCLkinds do							if theKind in setToCalc then								begin									ds := 'Total ';									if numtoshow > 1 then										ds := concat(ds, SpotBarName(theKind, true));									ds := concat(ds, ' of ', StepsChartUnits(CWStepsShow, true), ': ');									DrawWriteString(ds);									if theInflation = 1 then										ds := StringFromNum(RoundValue(TotalLinear(thekind, not (sequencechart or positionchart))))									else										RealToString((TotalLinear(thekind, not (sequencechart or positionchart)) * 1.0) / theInflation, ds, 100000, 3, not DrawToFile or writeexpon);									DrawWriteStringLn(ds);								end;					end				else if sequencechart then					begin{    DrawWriteStringLn(concat('Average ', StepsChartUnits(CWStepsShow, true), '  on tree(s):'));}						if numCWChars > 0 then							for theKind := 0 to numCLkinds do								if theKind in setToCalc then									begin										RealToString((TotalLinear(thekind, false) * 1.0) / numCWchars / 100.0, ds, 10, 4, not DrawToFile or writeexpon);										ds := concat(' of ', StepsChartUnits(CWStepsShow, true), ': ', ds);										if numtoshow > 1 then											ds := concat(SpotBarName(theKind, true), ds);										ds := concat('Average ', ds);										DrawWriteStringLn(ds);									end;					end;		end;{...............................}		procedure DrawProbStepsText;			var				theInflation: longint;				ss: integer;				mean: real;		begin			mean := 0.0;			for ss := 0 to numintervals[CLKind] - 1 do				mean := mean + ss * (GetChartLinearData(CLKind, ss) / DataInflation);			RealToString(mean, ds, 10, 4, not DrawToFile or writeexpon);			ds := concat('Mean number of steps: ', ds);			DrawWriteStringLn(ds);		end;{...............................}	begin		chartTextLines := 0;		drawWriteStringLines := 0;		SetMenuItemText(FileMHdl, PrintingItem, 'Print Text...');		setToCalc := SpotBarSetToCalc;		numtoshow := NumSpotBar(setToCalc);		moveto(marg, boundary.top + fontheight + 5 - fontheight * chartOrigin);		case CWChart of			CWCStates: 				if not CWTraced then					DrawStatesText				else					DrawWriteStringLn('No summary statistics');			CWCProbSteps: 				DrawProbStepsText;			CWCSteps: 				DrawStepsText;{|||||||||||||| changes ||||||||||||||||}			CWCChanges: 				begin					if CWTrees[CWChart] <> CWCurrentTree then						DrawWriteStringLn(concat('Number of Trees: ', StringFromNum(numCWTrees)));{include here the following: number of transitions, number of transversions}					if nucleotides then						begin {The following storage is used:}{	1. minmaxmode: TransitionMin and TransitionMax}{	2. meanmode: TransitionAvg}{	3. unambigmode: TransitionMin}{Ideally, we would change this so that, say TransitionMin was always used if only one was needed.  But at this}{point in the game I am not willing to do this.}							if Chartchangesmode = minmaxmode then								begin									if CWTrees[CWChart] <> CWCurrentTree then										begin											DrawWriteStringLn(concat('Number of transitions: ', StringFromNum(allTreesTransitionMin), '-', StringFromNum(allTreesTransitionMax)));											DrawWriteStringLn(concat('Number of transversions: ', StringFromNum(allTreesTransversionMin), '-', StringFromNum(allTreesTransversionMax)));										end									else										begin											DrawWriteStringLn(concat('Number of transitions: ', StringFromNum(TransitionMin), '-', StringFromNum(TransitionMax)));											DrawWriteStringLn(concat('Number of transversions: ', StringFromNum(TransversionMin), '-', StringFromNum(TransversionMax)));										end;								end							else if Chartchangesmode = meanmode then								begin									if CWTrees[CWChart] <> CWCurrentTree then										begin											RealToString(allTreesTransitionAvgMin, ds, 100000, 3, not DrawToFile or writeexpon);											RealToString(allTreesTransitionAvgMax, ds2, 100000, 3, not DrawToFile or writeexpon);											DrawWriteStringLn(concat('Sum (over sites) of average number (across MPRs) of transitions: ', ds, '-', ds2));											RealToString(allTreesTransversionAvgMin, ds, 100000, 3, not DrawToFile or writeexpon);											RealToString(allTreesTransversionAvgMax, ds2, 100000, 3, not DrawToFile or writeexpon);											DrawWriteStringLn(concat('Sum (over sites) of average number (across MPRs) of transversions: ', ds, '-', ds2));											RealToString(transRatioMin, ds, 100000, 5, not DrawToFile or writeexpon);											DrawWriteStringLn(concat('Transition/Transversion ratio minimum across trees: ', ds));											RealToString(transRatio, ds, 100000, 5, not DrawToFile or writeexpon);											DrawWriteStringLn(concat('Transition/Transversion ratio average across trees: ', ds));											RealToString(transRatioMax, ds, 100000, 5, not DrawToFile or writeexpon);											DrawWriteStringLn(concat('Transition/Transversion ratio maximum across trees: ', ds));											DrawWriteStringLn('     (Transition/Transversion ratio is');											DrawWriteStringLn('       ratio of sums [over sites] of average [across MPRs])');										end									else										begin											RealToString(TransitionAvg, ds, 100000, 3, not DrawToFile or writeexpon);											DrawWriteStringLn(concat('Sum (over sites) of average number (across MPRs) of transitions: ', ds));											RealToString(TransversionAvg, ds, 100000, 3, not DrawToFile or writeexpon);											DrawWriteStringLn(concat('Sum (over sites) of average number (across MPRs) of transversions: ', ds));											RealToString(transRatio, ds, 100000, 5, not DrawToFile or writeexpon);											DrawWriteStringLn(concat('Transition/Transversion ratio: ', ds));											DrawWriteStringLn('     (Transition/Transversion ratio is');											DrawWriteStringLn('       ratio of sums [over sites] of average [across MPRs])');										end								end							else  {Chartchangesmode=unambigmode}								begin									if CWTrees[CWChart] <> CWCurrentTree then										begin											DrawWriteStringLn(concat('Number of unambiguous transitions: ', StringFromNum(allTreesTransitionMin), '-', StringFromNum(allTreesTransitionMax)));											DrawWriteStringLn(concat('Number of unambiguous transversions: ', StringFromNum(allTreesTransversionMin), '-', StringFromNum(allTreesTransversionMax)));										end									else										begin											DrawWriteStringLn(concat('Number of unambiguous transitions: ', StringFromNum(TransitionMin)));											DrawWriteStringLn(concat('Number of unambiguous transversions: ', StringFromNum(TransversionMin)));										end;								end;							DrawWriteStringLn('');						end;					LockHandle(CWClassName, oldstate);					if changesRestricted then						setName := concat('changes in user-defined set "',CWClassName^^,'"')					else						setName := CWClassName^^;					if Chartchangesmode = minmaxmode then						if CWTrees[CWChart] <> CWCurrentTree then							DrawWriteStringLn(concat('Number of ',setName,': ', StringFromNum(allTreesChangesSelMin), '-', StringFromNum(allTreesChangesSelMax)))						else							DrawWriteStringLn(concat('Number of ',setName,': ', StringFromNum(ChangesSelMin), '-', StringFromNum(ChangesSelMax)))					else if Chartchangesmode = meanmode then						begin							if CWTrees[CWChart] <> CWCurrentTree then								begin									RealToString(allTreesChangesSelAvgMin, ds, 100000, 3, not DrawToFile or writeexpon);									RealToString(allTreesChangesSelAvgMax, ds2, 100000, 3, not DrawToFile or writeexpon);									if molecular then										DrawWriteStringLn(concat('Sum (over sites) of average number (across MPRs) of ',setName,': ', ds, '-', ds2))									else										DrawWriteStringLn(concat('Sum (over sites) of average number (across MPRs) of ',setName,': ', ds, '-', ds2))								end							else								begin									RealToString(ChangesSelAvg, ds, 100000, 3, not DrawToFile or writeexpon);									if molecular then										DrawWriteStringLn(concat('Sum (over sites) of average number (across MPRs) of ',setName,': ', ds))									else										DrawWriteStringLn(concat('Sum (over characters) of average number (across MPRs) of ',setName,': ', ds))								end;						end					else if CWTrees[CWChart] <> CWCurrentTree then						DrawWriteStringLn(concat('Number of unambiguous ',setName,': ', StringFromNum(allTreesChangesSelMin), '-', StringFromNum(allTreesChangesSelMax)))					else						DrawWriteStringLn(concat('Number of unambiguous ',setName,': ', StringFromNum(ChangesSelMin)));					ResetHandle(CWClassName, oldstate);				end;{|||||||||||||| tree length plot ||||||||||||||||}			CWCCTall: 				begin					DrawWriteStringLn(concat('Number of Trees: ', StringFromNum(numCWTrees)));					if numCWTrees > 0 then						RealToString((TotalLinear(CLStandard, true) * 1.0) / numCWTrees / lengthinflate, ds, 100000, 3, not DrawToFile or writeexpon);					DrawWriteStringLn(concat('Average Treelength: ', ds));{v4: include here skewness measure of Hillis}				end;{|||||||||||||| 2 tree, 2 TreeFile comparison ||||||||||||||||}			CWCC2T, CWCC2TF: 				begin					positive := 0;					posWeighted := 0;					negative := 0;					negWeighted := 0;					for j := 0 to numIntervals[CLkind] - 1 do						begin							theData := GetChartLinearData(CLkind, j);							if theData > 0 then								begin									posWeighted := posWeighted + theData;									positive := positive + 1;								end;							if theData < 0 then								begin									negWeighted := negWeighted + theData;									negative := negative + 1;								end;						end;					if C2TsayShorter then						begin							DrawWriteStringLn(concat(TreeCompareName(1), ' shorter for:'));							DrawWriteStringLn(concat('  ', StringFromNum(positive), ' character(s).'));							DrawWriteStringLn(concat('In these characters, ', TreeCompareName(1), ' shorter by:'));							DrawWriteStringLn(concat('  ', LengthString(posWeighted, true), ' weighted step(s).'));							DrawWriteStringLn(' ');							DrawWriteStringLn(concat(TreeCompareName(0), ' shorter for:'));							DrawWriteStringLn(concat('  ', StringFromNum(negative), ' character(s).'));							DrawWriteStringLn(concat('In these characters, ', TreeCompareName(0), ' shorter by:'));							DrawWriteStringLn(concat('  ', LengthString(-negWeighted, true), ' weighted step(s).'));						end					else						begin							DrawWriteStringLn(concat(TreeCompareName(1), ' longer for:'));							DrawWriteStringLn(concat('  ', StringFromNum(negative), ' character(s).'));							DrawWriteStringLn(concat('In these characters, ', TreeCompareName(1), ' longer by:'));							DrawWriteStringLn(concat('  ', LengthString(-negWeighted, true), ' weighted step(s).'));							DrawWriteStringLn(' ');							DrawWriteStringLn(concat(TreeCompareName(0), ' longer for:'));							DrawWriteStringLn(concat('  ', StringFromNum(positive), ' character(s).'));							DrawWriteStringLn(concat('In these characters, ', TreeCompareName(0), ' longer by:'));							DrawWriteStringLn(concat('  ', LengthString(posWeighted, true), ' weighted step(s).'));						end;				end;			otherwise				;		end;		chartTextLines := drawWriteStringLines;	end;end.