unit TraceMenu;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, 		Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, 		EventUtil, GenUtil, SetStates, Printing, Calcutil, BranchListWindow, UtilLibInterface, 		SetLibInterface,   CharUtil, Thermos, BoxUtil, StrUtil, MenuUtil, TypeUtil, TraceControl, 		Continuous, Prohibitions, TaxonCHUtil, TreeUtil, TreeMenu, Equivocal, ClickInInfoWindow, 		InfoWindows, Legends, TreeDrawer, Count, Coloring, Windows, TraceAllChangesCalc, TraceAllChangesOptions, 		ChartWindow, ProbReconstruct;	procedure TraceAllStatesBranchListOptions;		procedure DoEquivMenu (ItemNo: integer);	procedure DoTraceMenu (ItemNo: integer);{еееееееееееееееееееееее}implementation {е$S TraceMenu}{$IFC DEBUG}{-----------------------------------------------------------------------------}{$IFC false}	procedure CycleCheckReconstruct;		label			222;		const			numchtest = 1000;		var			icount: longint;			tempP: WindowPtr;			ctyp, lastcount: integer;			tnnn: integer;			irescount: longint;			b: boolean;			ddist: distancetype;			theDialog: DialogPtr;			it: integer;			dofirst: boolean;{.............}		function OneMoreToFix: boolean;			var				anymore: boolean;			procedure GoUpToFix (N: Nptr);			begin				if BranchExists(N) then					begin						if MultipleStatesLg(N^.final) then							begin								if dofirst then									N^.fixsts := [minLg(N^.final)]								else									N^.fixsts := [maxLg(N^.final)];								N^.fix := true;								anymore := true;								Exit(GoUpTofix);							end;					end;				if not anymore & (NodeIsInternal(N)) then					begin						GoUpToFix(N^.lf);						if not anymore then							GoUpToFix(N^.rt);					end;			end;		begin			anymore := false;			GoUpTofix(R);			OneMoreTofix := anymore;		end;{.............}		procedure CountLengthInRes (N: Nptr);			var				below, above: lgsetchars;		begin			if BranchExists(N) then				begin					below := N^.anc^.resolved;					above := N^.resolved;					case ctyp of						unordered: 							if below <> above then								irescount := irescount + 1;						ordered, irreversible, dollo: 							if below <> above then								irescount := irescount + abs(minG(above) - minG(below));						fisher: 							if below <> above then								irescount := irescount + FisherDistance([minG(above), minG(below)], true);						excluded: 							;						otherwise							irescount := irescount + ddist[minG(below), ming(above)];					end				end;			if NodeIsInternal(N) then				begin					CountLengthInRes(N^.lf);					CountLengthInRes(N^.rt);				end			else if branchExists(N) then				if ctyp >= usedef then					irescount := irescount + N^.gdnst[minG(above)];		end;{.............}		function GenerateSEt: Largestsetchars;			var				iset: Largestsetchars;		begin			iset := [];			if RandomBetween(1, 5) > 1 then				begin					iset := iset + [randombetween(0, 6)];					if RandomBetween(1, 5) > 2 then						begin							iset := iset + [randombetween(0, 6)];							if RandomBetween(1, 5) > 2 then								begin									iset := iset + [randombetween(0, 6)];									if RandomBetween(1, 5) > 2 then										begin											iset := iset + [randombetween(0, 6)];										end;								end;						end;					if MultipleStatesLg(iset) then						if RandomBetween(1, 10) > 5 then							iset := iset + [UCl];				end			else				iset := [MSl];			GenerateSEt := iset;		end;{.............}	begin		dodoublecheck := false;		StartThermo(theDialog, tempP, 0, numchtest, 'Test Characters', 'characters', false);		i := 1;		b := false;		for icount := 1 to numchtest do			begin				UpdateThermo(theDialog, 0, icount, numchtest,false);				for it := 1 to numtaxa do					SetTaxonStsLargest(it, 1, GenerateSet);				for tnnn := unordered to numtypes do					begin						settype(1, tnnn);						UseToTypeStorage(1);						ctyp := typeofchar(1);{CHECKING BY EQUIVOCAL CYCLING}						if not (nullson or ancon or (resolveoption <> allpossible)) then							begin								ReconstructTraced;								if ctyp >= usedef then									begin										typeHdl := gettypehdl(ctyp);										ddist := typeHdl^^.dist;									end;								lastcount := -9;								Equiv_MakeFirstResolution(R, 1, true);								repeat									EquivocalCursor(True);									irescount := 0;									if NodeIsInternal(R) then										begin											CountLengthInRes(R^.lf);											CountLengthInRes(R^.rt);										end;									if lastcount = -9 then										lastcount := irescount									else if irescount <> lastcount then										begin											InstantInfo('Error; equivcyclecount');											goto 222;										end;									if commandperiod then										b := true;								until b | (uniqueresolution) | Equiv_NextResInClade(R, R, 1, ctyp, true);								if b then									goto 222;							end;{InstantInfo('sf');}{CHECKING BY SUCCESSIVE FIXING}						b := false;						for dofirst := false to true do							begin								offfix(false);								ReconstructTraced;								lastcount := isteps;								while not b and OneMoreToFix do									begin										fixon := true;										ReconstructTraced;										if commandperiod then											b := true;										if isteps <> lastcount then											begin												InstantInfo('Error: successive fixing');												goto 222;											end;										lastcount := isteps;									end;								if b then									goto 222;							end;						offfix(false);					end;			end; {replicates}222:		offfix(false);		EndThermo(theDialog, tempP, true);		golist := golist + fullgotree;		dodoublecheck := true;	end;{$ENDC}{$IFC TRUE}{-----------------------------------------------------------------------------}	procedure CycleCheckReconstruct;		var			tempP: WindowPtr;			ctyp, ic: integer;			irescount: longint;			b, errorfound: boolean;			ds: str255;			ddist: distancetype;			theDialog: DialogPtr;			originali, it: integer;			CharFixedPoly, errorinchar: boolean;			dofirst: boolean;{.............}		function OneMoreToFix: boolean;			var				anymore: boolean;			procedure GoUpToFix (N: Nptr);			begin				if BranchExists(N) then					begin						if MultipleStatesLg(N^.final) then							begin								if dofirst then									N^.fixsts := [minLg(N^.final)]								else									N^.fixsts := [maxLg(N^.final)];								if N^.fixanc then									if FixancedByPolymorphic(N, i) then										CharFixedPoly := true;								N^.fix := true;								anymore := true;								Exit(GoUpTofix);							end;					end;				if not anymore & (NodeIsInternal(N)) then					begin						GoUpToFix(N^.lf);						if not anymore then							GoUpToFix(N^.rt);					end;			end;		begin			anymore := false;			GoUpTofix(R);			OneMoreTofix := anymore;		end;{.............}		procedure CountLengthInRes (N: Nptr; ic: integer);			var				below, above: lgsetchars;		begin			if BranchExists(N) then				begin					below := N^.anc^.resolved;					above := N^.resolved;					case ctyp of						unordered: 							if below <> above then								irescount := irescount + 1;						ordered, irreversible, dollo: 							if below <> above then								irescount := irescount + abs(minG(above) - minG(below));						fisher: 							if below <> above then								irescount := irescount + FisherDistance([minG(above), minG(below)], true);						excluded: 							;						otherwise							irescount := irescount + ddist[minG(below), ming(above)];					end				end;			if NodeIsInternal(N) then				begin					CountLengthInRes(N^.lf, ic);					CountLengthInRes(N^.rt, ic);				end			else if branchExists(N) then				if ctyp >= usedef then					irescount := irescount + N^.gdnst[minG(above)]				else if ctyp = unordered then					if Intersect2(N^.dnequiv, N^.resolved) = nil then  {done in case resolved to state not in original, i.e. to 1 with 0<-1->2}						irescount := irescount + 1;		end;{.............}		procedure MoveStsToBset1 (N: Nptr);		begin			if branchexists(N) then				N^.bset1 := NewSetFromOld(N^.final);			if NodeIsInternal(N) then				begin					MoveStsToBset1(N^.lf);					MoveStsToBset1(N^.rt);				end;		end;{.............}		procedure compareStstoBset1 (N: Nptr);		begin			if branchexists(N) then				if (N^.bset1 <> NewSetFromOld(N^.final)) then					errorinchar := true;			if NodeIsInternal(N) then				begin					compareStstoBset1(N^.lf);					compareStstoBset1(N^.rt);				end;		end;{.............}	begin		if (nullson or ancon or (resolveoption <> allpossible)) | not Cwarning('Equivocal cycling or Successive fixing?', 'Cycling', 'Fixing') then			begin				if not count then					if not CountTree then						NewError(110, 0);				b := false;				originali := i;				errorfound := false;				StartThermo(theDialog, tempP, 0, numchars, 'Examining characters', 'characters', false);				for ic := 1 to numchars do					begin						charfixedpoly := false;						errorinchar := false;						UpdateThermo(theDialog, 0, ic, numchars, false);						ctyp := typeofchar(ic);						if ctyp <> excluded then							begin								for dofirst := false to true do									begin										offfix(false);										i := ic;										ReconstructTraced;										while not b and OneMoreToFix do											begin												fixon := true;												ReconstructTraced;												if commandperiod then													b := true;												if isteps <> CharSteps(ic) then													begin														errorinchar := true;														errorfound := true;													end;											end;										if not b and (isteps <> CharSteps(ic)) then											begin												errorinchar := true;												errorfound := true;											end;										if b then											leave;									end; {not excluded}							end;						if errorinchar then							begin								if ctyp = fisher then									NewError(336, ic)								else if charfixedpoly then									NewError(111, ic)								else									NewError(129, ic);							end;					end;				EndThermo(theDialog, tempP, true);				if not errorfound then					InstantInfo('CHECK OK');				offfix(false);				golist := golist + igos;				i := originali;			end		else			begin				if not count then					if not CountTree then						NewError(110, 0);				ReconstructChars(1, numchars, true); {downpass, if not done before, done just above in countree}				b := false;				errorfound := false;				StartThermo(theDialog, tempP, 0, numchars, 'Examining characters', 'characters', false);				for ic := 1 to numchars do					begin						UpdateThermo(theDialog, 0, ic, numchars,false);						ctyp := typeofchar(ic);						if ctyp <> excluded then							begin								if ctyp >= usedef then									begin										typeHdl := gettypehdl(ctyp);										ddist := typeHdl^^.dist;									end;								Equiv_MakeFirstResolution(R, ic, false);								repeat									EquivocalCursor(True);									if ctyp < usedef then										irescount := CharPolymorphLength(ic)									else										irescount := 0;									if NodeIsInternal(R) then										begin											CountLengthInRes(R^.lf, ic);											CountLengthInRes(R^.rt, ic);										end;									if irescount <> CharSteps(ic) then										begin											NewError(129, ic);											errorfound := true;										end;									if commandperiod then										b := true;								until b | (uniqueresolution) | Equiv_NextResInClade(R, R, ic, ctyp, false);								if b then									leave;							end; {not excluded}					end;				EndThermo(theDialog, tempP, true);				if not errorfound then					InstantInfo('CHECK OK');			end;	end; {$ENDC}{$ENDC}{-----------------------------------------------------------------------------}	procedure NumberOfMPRsDuringCyclingOld(var dL: longint);	var		oldequivnum: longint;	begin		oldequivnum := equivcyclenum;		equivcyclenum := 1;		Equiv_RestoreSts(screenR, i, true);				dL := NumberofResolutionsOld(screenR, i, true,true);				if dL < 0 then			InstantInfo(concat('Number of Reconstructions:  at least ', StringFromNum(-dL)))		else			InstantInfo(concat('Number of Reconstructions: ', StringFromNum(dL)));{Don't need to restore since Number of Reconstructions doesn't corrupt ^.final}		Equiv_MakeFirstResolution(screenR, i, tracedtrue);		Equiv_TransferRestoSts(screenR, i, tracedtrue);		equivcyclenum := 1;		if oldequivnum <> equivcyclenum then			GoToResolutionNumber(oldequivnum);	end;{-----------------------------------------------------------------------------}	procedure ShowNumMPRs(storeEquivocal: boolean);	var ic: integer;		dL: longint;		useDouble: boolean;		res: Double;		ds: str255;	begin		useDouble := false;		dL := NumberofResolutionsDual(screenR, i, true, storeEquivocal, useDouble,res);		if useDouble then			begin				RealtoString (res,ds,10,5,true);				InstantInfo(concat('Number of Most Parsimonious Reconstructions: ', ds));			end		else if dL < 0 then			InstantInfo(concat('Number of Most Parsimonious Reconstructions:  at least ', StringFromNum(-dL)))		else			InstantInfo(concat('Number of Most Parsimonious Reconstructions: ', StringFromNum(dL)));	end;{-----------------------------------------------------------------------------}	procedure DoEquivMenu (ItemNo: integer);		var			dL, oldequivnum: longint;			success: boolean;	begin		case ItemNo of			EquivNextItem: 				NextResolutionInCycle;			EquivGoToItem: 				begin					dL := GetLongint('Go to reconstruction #: ', 1, 1, -1, success);					if success then						GoToResolutionNumber(dL);				end;			EquivNumberItem: 				ShowNumMPRs(true);			EquivOffItem: 				begin					StopEquivCycle;					TWMessage := '';					InvalidateWindow(twmesswindow, true);				end;		end;	end;{-----------------------------------------------------------------------------}	procedure CheckNumResolutions;	var ic: integer;		dL1, dL2: longint;		useDouble: boolean;		res: Double;	begin		dL1 := NumberOfResolutions(screenR, i, true,useDouble,res);		dL2 := NumberofResolutionsOld(screenR, i, true,true);		if dL1 <> dL2 then			begin				InstantInfo(concat('fast ', StringFromNum(dL1), ', slow ', StringFromNum(dL2)));			end;	end;{-----------------------------------------------------------------------------}	procedure MPRCalcOptionsDialog;		var			theDialog: DialogPtr;			oldMPRMode: integer;			tempP: WindowPtr;			localItemHit: integer;{..............}		procedure CheckMPRCalcOptionsDialog;		begin			ItemCheckMark(theDialog, 4, MPRCalculationsMode = MPRNewMode);			ItemCheckMark(theDialog, 5, MPRCalculationsMode = MPRDualMode);			ItemCheckMark(theDialog, 6, MPRCalculationsMode = MPROldMode);		end;	begin		oldMPRMode := MPRCalculationsMode;		StartDLOG(180, theDialog, tempP);		CheckMPRCalcOptionsDialog;		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			if localItemHit in [4, 5, 6] then				begin					case localItemHit of						4: 							MPRCalculationsMode := MPRNewMode;						5: 							MPRCalculationsMode := MPRDualMode;						6: 							MPRCalculationsMode := MPROldMode;						otherwise							;					end;					CheckMPRCalcOptionsDialog;				end			else if localitemhit = 7 then				SetDialogValuesAsDefaults(theDialog, MPRCalculationsID, 0, 0);		until localItemHit in [1, 2];		if localItemHit = 2 then			MPRCalculationsMode := oldMPRMode		else			ChangeExclusionsGolist;		EndDLOG(theDialog, tempP);	end;{-----------------------------------------------------------------------------}	procedure TraceAllStatesBranchListOptions;{option dialog to choose what shows in the branch list window if showallstates is on}		var			theDialog: DialogPtr;			oldBLSWhat: integer;			tempP: WindowPtr;			d1, d2: longint;			localitemHit: integer;	begin		oldBLSWhat := BLSWhat;		StartDLOG(586, theDialog, tempP);		ItemCheckMark(theDialog, 3, BLSWhat = BLSstates);		ItemCheckMark(theDialog, 4, BLSWhat = BLSstatesum);		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			if localItemHit = 3 then				BLSWhat := BLSStates			else if localItemHit = 4 then				BLSWhat := BLSStatesum;			ItemCheckMark(theDialog, 3, BLSWhat = BLSstates);			ItemCheckMark(theDialog, 4, BLSWhat = BLSstatesum);		until localItemHit in [1, 2];		if localItemHit = 2 then			BLSWhat := oldBLSWhat;		EndDLOG(theDialog, tempP);		if (BLSWhat <> oldBLSWhat) and BranchListOn then			MakeBranchList(BranchListN, d1, d2, 0, 0, listToWindow);	end;{-----------------------------------------------------------------------------}	procedure DoTraceMenu (ItemNo: integer);		label			1;		var			oldi: integer;			dL: longint;			wasfix: boolean;			ic: longint;	begin		case ItemNo of			TraceOnOffItem: 					begin						if (traceshown = traceDiscrete) then							begin								wasfix := fixon;								TurnoffTrace(i, true, true, true);								if infoOpen[charinfo] then InvalidateInfoWindow(charinfo);								CloseTraceMenus;							end						else							begin								if charincluded(i) then									TurnOnTrace(i, i)								else									begin   {i is not included, therefore find first included character}										for ic := 1 to numchars do											if charincluded(ic) then												begin													i := ic;													TurnOnTrace(i, i);													goto 1;												end;										NewError(36, 0);									end;							end;					end;								TraceSelectedItem:				begin					if (frontwindow=infoWindow[charinfo]) & FirstInfoRowSelected(charinfo,ic) then						begin							if charincluded(ic) then								begin									i := ic;									TurnOnTrace(i, i);								end							else								begin   {i is not included, therefore find first included character}									for ic := 1 to numchars do										if charincluded(ic) & InfoRowSelected(charinfo,ic) then											begin												i := ic;												TurnOnTrace(i, i);												goto 1;											end;									NewError(36, 0);								end;						end;				end;			TraceCharItem: 					if (fileopen) then						OpenOrSelectInfoWindow(charinfo);			TraceLastItem: 				if (i <> oldtracei) and CharIncluded(oldtracei) then					TurnOnTrace(i, oldtracei);			ResolveOptionItem: 				begin					AcctranDeltranDLOG;					FixTreeShadingMenus;				end;			EquivCycleItem: 				if typeofchar(i) = fisher then					NewError(369, 0)				else					begin						if nex7on then							Nex7OnOff(false);						godraw := true;						equivcycle := true;						FixTreeShadingMenus;						StartEquivCycle;					end;			NumberMPRsItem: 				if typeofchar(i) = fisher then					NewError(369, 0)				else					ShowNumMPRs(false);								MPRCalcOptions:				MPRCalcOptionsDialog;								UnfixAllItem: 				begin					setcursor(clockCursor);					OffFix(true);					FixStateGoList;				end;			TraceAllChangesItem: 				begin{$IFC DEBUG}					if OptionEvent(Event) then						CycleCheckReconstruct					else{$ENDC}						begin							equivpres := false;							if (traceshown = traceAllChanges) then								TurnOffShowChg(true)							else								TurnOnShowChanges;						end;				end;			AllChangesOptionsItem: 				SummaryModeOptions(false);			TraceAllStatesItem: 				begin					if not (traceshown = traceAllStates) then  {Turning On Trace All States}						begin							myEnableItem(TWDisplayMHdl, BranchPatternsAndColorsItem);							tool^[treeTools,queryT].enabled := true;{FROZEN 3.0}							if not (traceshown = traceAllChanges) then								golist := golist + [countall, reconstructall]; {if didn't just have show changes on, then re reconstruct}							if (traceshown = traceAllChanges) then								TurnOffShowChg(true)							else if (traceshown = traceDiscrete) then								TurnoffTrace(i, true, false, true)							else if (traceshown = traceContinuous) then								TurnOffContinuous(true);{$IFC PROBRECONSTRUCT}							else if (traceshown = traceProbability) then								TurnOffProbReconstruct;{$ENDC}							traceshown := traceAllStates;							ResetGoMask;							DropTool(treeTools,queryT);							FixTreeShadingMenus;							ReshadeTree;							SetTool(treeTools,queryT);						end					else						TurnOffAllStates;				end;						AllStatesOptionsItem:				TraceAllStatesBranchListOptions;							ContinuousOptionsItem: {$IFC PROBRECONSTRUCT}				if OptionDown then					DoProbReconstruct(true)				else{$ENDC}				ContinuousOptions;			otherwise				;		end;1:	end;end.