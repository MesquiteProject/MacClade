unit ReadAssumpBlock;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, TaxonCHUtil, SymbolsNames, MenuUtil, Thermos, TypeUtil, CharUtil, ReadWriteUtil, ReadUtil, CHUNK, LinkUtil, RowColumn, CSTreeUtil, ReadMisc;	procedure ReadMSTAXA;	procedure ReadIGNORE;	procedure ReadGAPMODE;	procedure ProcessUserTypeFormatToken (token: str255; var success: boolean; var format: integer);  {v3.05}	procedure ProcessUserType (format: integer; lastToken: str255; var typeHdl: typeHandle; typnum: integer);	procedure ReadUserType (var typename: str255);	procedure ReadLabels(theNexusBlock: NexusBlockPtr; firstCommand: str255);	procedure ReadSets(theNexusBlock: NexusBlockPtr; firstCommand: str255);	procedure ReadAssumptions(theNexusBlock: NexusBlockPtr; firstCommand: str255);	var		badtypeRead: boolean;	const		stepmatrix = 1;		realmatrix = 2;		cstree = 3;		strattype = 4;{еееееееееееееееееееееее}implementation {е$S ReadAssumpBlock}{-----------------------------------------------------------------------------}	procedure ReadCSTreeTypeSpecs (TH: typeHandle);		var			tokar, tokarafterlabel: char;			maxstar, root, mxs, j, oldik, ik, maxstateCSTREES: integer;			Neighbors: neighbortype;			tempdist: distancetype;			legalset: largestsetchars;			cst: str255;{---------}		function nextcstchar: char;		begin			repeat				ik := ik + 1			until cst[ik] <> ' ';			nextcstchar := cst[ik];		end;{---------}		function labelafterparens: char;			var				csc: char;		begin			repeat				csc := nextcstchar;				if csc = '(' then					csc := labelafterparens;			until csc = ')';			labelafterparens := nextcstchar;		end;{---------}		procedure MakeNeighborsRec (ic: integer);			var				icNB: integer;				done, labelafter: boolean;		begin			done := false;			repeat				labelafter := false;				repeat					tokar := nextcstchar;				until tokar <> ',';				if (tokar = '*') then					begin						MaxStar := MaxStar + 1;						icNB := MaxStar;					end				else if (tokar = '(') then					begin						oldik := ik;						tokarafterlabel := labelafterparens;						ik := oldik;						if tokarafterlabel in ['*', ',', ')', ';'] then							begin								MaxStar := MaxStar + 1;								icNB := MaxStar;								if tokarafterlabel = '*' then									labelafter := true;							end						else							begin{icNB := ord(tokarafterlabel) - 48;}								icNB := NumOfChar(tokarafterlabel, 0, 0);								labelafter := true;							end;					end				else					icNB := NumOfChar(tokar, 0, 0);{    icNB := ord(tokar) - 48;}				if ErrorPosted(88) or (icNB = MSl) then   {symbols list contains unknown symbols!!!}					begin						badTypeRead := true;						RemoveError(88);						NewError(98, 0);						Skipper([';'], true);						Exit(ReadCSTreeTypeSpecs);					end;				Neighbors[ic] := Neighbors[ic] + [icNB];				Neighbors[icNB] := [ic];				if tokar <> '(' then					tokar := nextcstchar;				if tokar = '(' then					begin						MakeNeighborsrec(icNB);						tokar := nextcstchar;					end;				if labelafter then					tokar := nextcstchar;				if (tokar in [')', ';']) then					begin						done := true;					end;			until done;		end;{---------}	begin{    if maxstate > 9 then maxstateCSTREES := 9 else}		maxstateCSTREES := maxstate;		MaxStar := maxstateCSTREES;		ik := 0;		for j := 0 to maxCS do			Neighbors[j] := [];		cst := ' ';		repeat			tokar := nextdarkchar;			cst := concat(cst, tokar)		until (tokar = ';') or (length(cst) = 255);		if length(cst) = 255 then			cst[255] := ';';		Tokar := nextcstchar;		if (tokar = '*') then			begin				maxstar := maxstar + 1;				root := maxstateCSTREES + 1;			end		else if (tokar = '(') then			begin				oldik := ik;				tokarafterlabel := labelafterparens;				ik := oldik;				if tokarafterlabel in ['*', ',', ')', ';'] then					begin						MaxStar := maxstar + 1;						root := maxstateCSTREES + 1;					end				else					begin{root := ord(tokarafterlabel) - 48;}						root := NumOfChar(tokarafterlabel, 0, 0);{    labelafter := true;}					end;			end		else			root := NumOfChar(tokar, 0, 0);		if ErrorPosted(88) or (root = MSl) then   {symbols list contains unknown symbols!!!}			begin				badTypeRead := true;				NewError(98, 0);				RemoveError(88);				Skipper([';'], true);				Exit(ReadCSTreeTypeSpecs);			end;		TH^^.root := root;		if tokar <> '(' then			Tokar := nextcstchar;		MakeNeighborsRec(root);		TH^^.maxstar := maxstar;		TH^^.nbors := Neighbors;		NborToDistance(neighbors, maxstar, tempdist, mxs, legalset);		tH^^.setdefined := legalset;		TH^^.dist := tempdist;		TH^^.max := mxs;	end;{-----------------------------------------------------------------------------}	function RealTypeEntry (ds: str255): integer;		var			td, iz: integer;			c: char;	begin		if ds = '.' then			{v3.05}			RealTypeEntry := 0		else			begin				td := 0;				iz := 1;{====  process numbers before decimal =====}				repeat					c := ds[iz];					iz := iz + 1;					if ((c >= '0') and (c <= '9')) then						td := (ord(c) - 48) + 10 * td					else if c in ['░', 'i', 'I'] then						td := infinity;				until (iz > length(ds)) or (c in ['░', 'i', 'I', '.']);{====  process number after decimal =====}				if (c = '.') and (iz <= length(ds)) then					begin						c := ds[iz];						if ((c >= '0') and (c <= '9')) then							td := (ord(c) - 48) + 10 * td;					end;				if td > MaxTypeInt * typeinflate then					begin						NewError(99, 0);						td := MaxTypeInt * typeInflate;					end;				RealTypeEntry := td;			end;	end;{-----------------------------------------------------------------------------}	procedure ReadFisherType (TH: typeHandle);		var			j, k, isto, maxm, temp: INTEGER;			ds: str255;			c: char;			tempdist: distancetype;	begin		ds := GetFileToken(maxtok);		maxm := TokenToInteger(ds, true);		if maxm > maxstate then			maxm := maxstate;		tH^^.setdefined := [0..maxstate];		for j := 0 to maxstate do			for k := 0 to maxstate do				if j = k then					tempdist[j, j] := 0				else					tempdist[j, k] := TypeInflate;		for isto := 0 to maxm - 1 do			begin				c := nextdarkchar;	{skips last symbol}				temp := RealTypeEntry(GetFileToken(maxtok));				if temp = 0 then					NewError(388, 0)				else					tempdist[isto, isto + 1] := temp;			end;		ds := GetFileToken(maxtok);  {skip over semi}		TH^^.dist := tempdist;		TH^^.max := maxstate;		TH^^.root := -1;		fisheredited := true;	end;{-----------------------------------------------------------------------------}	procedure InitializeTypeMatrix (maxm: integer; TH: typeHandle; var tempdist: distancetype);		var			j, k: integer;	begin		for j := 0 to maxm do			for k := 0 to maxm do				if not ((j in tH^^.setdefined) and (k in tH^^.setdefined)) then					tempdist[j, k] := infinity				else if j = k then					tempdist[j, j] := 0				else if tempdist[j, k] <> 0 then					if TH^^.isreal then						tempdist[j, k] := TypeInflate					else						tempdist[j, k] := 1;	end;{-----------------------------------------------------------------------------}	procedure InflateTypeMatrix (maxm: integer; var tempdist: distancetype);		var			j, k: integer;	begin		for j := 0 to maxm do			for k := 0 to maxm do				if tempdist[j, k] <> infinity then					tempdist[j, k] := tempdist[j, k] * TypeInflate;	end;{-----------------------------------------------------------------------------}	procedure ReadMatrixTypeSpecs (TH: typeHandle);		var			j, k, isto, isfrom, matsize, mm, maxm, td, iz, gapnum: INTEGER;			ds: str255;			qs: string[31];			c: char;			divideby, extradivide, origtd: integer;			dodivide: boolean;			tempdistsym: string[31];			tempdist: distancetype;{................}		procedure ReduceByTens;			var				jj, kk: integer;		begin			if td div Maxtypeint > 100 then				extradivide := 1000			else if td div Maxtypeint > 10 then				extradivide := 100			else				extradivide := 10;			for jj := 0 to isfrom - 1 do				for kk := 0 to maxm do					if ((isfrom <> GAl) & (isto <> GAl)) & ((jj in tH^^.setdefined) & (kk in tH^^.setdefined)) then						tempdist[jj, kk] := (tempdist[jj, kk] + (extradivide div 2)) div extradivide;			jj := isfrom;			for kk := 0 to isto do				if ((isfrom <> GAl) & (isto <> GAl)) & ((jj in tH^^.setdefined) & (kk in tH^^.setdefined)) then					tempdist[jj, kk] := (tempdist[jj, kk] + (extradivide div 2)) div extradivide;			td := (td + (extradivide div 2)) div extradivide;			dodivide := true;			divideby := divideby * extradivide;			NewError(99, 0);		end;{................}	begin		gapnum := -1;		dodivide := false;		divideby := 1;		ds := GetFileToken(maxtok);		matsize := TokenToInteger(ds, true);		tempdistsym := '';		maxm := 0;		tH^^.setdefined := [];		for j := 1 to matsize do			begin				c := nextdarkchar;	{gets symbol}				if c = gap then					begin						gapnum := j;						openAsUntitled := true;					end				else					begin						mm := NumOfChar(c, 0, 0);						if ErrorPosted(88) or (mm = MSl) then   {symbols list contains unknown symbols!!!}							begin								badTypeRead := true;								NewError(98, 0);								RemoveError(88);								Skipper([';'], true);								Exit(ReadMatrixTypeSpecs);							end;						tH^^.setdefined := tH^^.setdefined + [mm];						if mm > maxm then							maxm := mm;					end;				tempdistsym := concat(tempdistsym, c);			end;		InitializeTypeMatrix(maxm, TH, tempdist);		for j := 1 to matsize do			begin				if j = gapnum then					isfrom := GAl				else					isfrom := NumOfChar(tempdistsym[j], 0, 0);				if ErrorPosted(88) or (isfrom = MSl) then					begin						badfile := true;						errorflag := true;						leave;					end;				for k := 1 to matsize do					begin						if k = gapnum then							isto := GAl						else							isto := NumOfChar(tempdistsym[k], 0, 0);						if ErrorPosted(88) or (isto = MSl) then							begin								badfile := true;								errorflag := true;								Exit(ReadMatrixTypeSpecs);							end;						c := nextdarkchar;	{skips last symbol}						qs := GetFileToken(maxtok);						if not TH^^.isreal & ((pos('.', qs) > 0) & (length(qs) > 1)) then   {v3.05: this part of code has changed a fair bit,}																					{mainly to allow autodetection of real matrices}							begin								TH^^.isreal := true;								InflateTypeMatrix(maxm, tempdist);  {need to go back and inflate all old values}{Davidv4.1: this doesn't consider excessively large integers at the start.}							end;						if (isfrom <> GAl) & (isto <> GAl) then							if TH^^.isreal then								begin									td := RealTypeEntry(qs);									origtd := td;									if dodivide then										td := (td + (divideby div 2)) div divideby;									if td > MaxTypeInt then										ReduceByTens;									if (td = 0) and (origtd <> 0) then										NewError(355, 0);									tempdist[isfrom, isto] := td;								end							else								begin									td := 0;									iz := 1;									repeat										c := qs[iz];										iz := iz + 1;										if ((c >= '0') and (c <= '9')) then											td := (ord(c) - 48) + 10 * td										else if c in ['░', 'i', 'I'] then											td := infinity										else if c in ['.', '_', '-'] then											begin												if td > 0 then													NewError(42, 0);												td := 0;											end										else											begin												td := 0;												c := '.';												NewError(42, 0);											end;									until (iz > length(qs)) or (c in ['░', 'i', 'I', '.', '_', '-']);									origtd := td;									if dodivide then										td := (td + (divideby div 2)) div divideby;									if td > MaxTypeInt then										ReduceByTens;									if (td = 0) and (origtd <> 0) then										NewError(355, 0);									tempdist[isfrom, isto] := td;								end;					end;			end;		ds := GetFileToken(maxtok);  {skip over semi}		TH^^.dist := tempdist;		TH^^.max := maxm;		TH^^.root := -1;		if not passMetricity(TH) then			NewError(26, 0);	end;{-----------------------------------------------------------------------------}	procedure ProcessUserType (format: integer; lastToken: str255; var typeHdl: typeHandle; typnum: integer);	var ds: str255;	begin		ds := '=';		badTypeRead := false;		if (format = STEPMATRIX) then			begin				if lastToken <> '=' then					ds := GetFileToken(maxtok); 		{=}				ReadMatrixTypeSpecs(typeHdl);				CheckPolarity(typnum);			end		else if (format = REALMATRIX) then			begin				ds := GetFileToken(maxtok); 		{=}				typeHdl^^.isreal := true;				ReadMatrixTypeSpecs(typeHdl);				CheckPolarity(typnum);			end		else if (format = STRATTYPE) then			begin				if fisheredited then					NewError(356, 0);				ds := GetFileToken(maxtok); 		{=}				typeHdl := GetTypeHdl(fisher);				typeHdl^^.isreal := true;				typeHdl^^.polar := true;				typeHdl^^.name := 'stratigraphic';				ReadFisherType(typeHdl);				typeHdl^^.dist[0, 0] := -2			end		else if format = CSTREE then			begin				ds := GetFileToken(maxtok); 		{=}				ReadCSTreeTypeSpecs(typeHdl);				typeHdl^^.polar := false;			end;{    else if ds = '=' then begin ReadMatrixTypeSpecs(typeHdl); CheckPolarity(typnum);end}		if badtypeRead & (ds <> 'STRATTYPE') then   {it was a badtype - wrong symbols - delete!}			begin				DeleteCHUNKs(typeCHUNKs, typnum, 1);				numtypes := numtypes - 1;			end;	end;{----------------------------------------------------------------------------}{----------------------------------------------------------------------------}	procedure ProcessUserTypeFormatToken (token: str255; var success: boolean; var format: integer);  {v3.05}	begin		success := true;		if (token = 'STRATTYPE') then			format := strattype		else if (token = 'STEPMATRIX') or (token = '=') then			format := stepmatrix		else if (token = 'REALMATRIX') then			format := realmatrix		else if (token = 'CSTREE') then			format := cstree		else			begin				InstantErrorPlus(302, token);				if thermo1 then					DrawDialog(iothermo);				success := false;			end;	end;{-----------------------------------------------------------------------------}	procedure ReadUserType (var typename: str255);		var			thp: typeHdlPtr;			ds: str255;			success: boolean;			format: integer;			oldpunct: set of char;	begin		success := true;		format := 0;		if numtypes <= maxtypes then			begin				if typename = '*' then			{somebody has * the usertype - ignore *}					typename := GetFileToken(maxtok);				oldpunct := punctuation;				if not ('(' in punctuation) then					punctuation := punctuation+['(',')'];				ds := MakeCaps(GetFileToken(maxtok));  {this is either a format token, a (, or and =}				if ds = '(' then   {v3.05}{there is more than one token, or it is fullnexus1 format}					repeat						ds := MakeCaps(GetFileToken(maxtok));						if ds <> ')' then							ProcessUserTypeFormatToken(ds, success, format);					until not success or (ds = ')') or (fpos >= mcFileLength)				else					ProcessUserTypeFormatToken(ds, success, format);				punctuation := oldpunct;				if not success then					begin						Skipper([';'], true);						Exit(ReadUserType);					end;				if format <> strattype then					begin						AddCHUNKs(typeCHUNKs, 1, Sizeof(typeRecord));						if badmemory then							begin								Skipper([';'], true);								Exit(ReadUserType);							end;						numtypes := numtypes + 1;						thp := typeHdlPtr(GetMaster(typeCHUNKs) + GetHandleSize(typeCHUNKs) - HdlSize);						typeHdl := thp^;						UnderLineToBlanks(typeName);						typename := CopyString(typeName, 1, typesig);						typeHdl^^.name := typename;						typeHdl^^.isreal := false;					end				else					typeHdl := nil;				ProcessUserType(format, ds, typeHdl, numtypes);			end		else			begin				Skipper([';'], true);				NewError(97, 0);			end;	end;{----------------------------------------------------------------------------}	procedure ExtendTheLink (thechain, theLink: longint; var success: boolean);		label			1;		var			compactH, extendH: handle;			theName: str255;			compactToExtendedSuccess: boolean;	begin		realwt := false;		success := false;		compactToExtendedSuccess := false;		compactH := newHandle(0);		GetLink(theChain, thelink - 1, compactH, false);		if not MemoryOK then			Exit(ExtendTheLink);		extendH := newhandle(2);		if not MemoryOK then  {v3.05}			Exit(ExtendTheLink);		case theChain of			CharPartitionChain: 				CompactToExtendedLink(compactH, extendH, chpartb, defaultPartition, CharPartitionChain, theName, false,compactToExtendedSuccess);			wtSetChain: 				CompactToExtendedLink(compactH, extendH, chwb, 1, wtsetchain, theName, false,compactToExtendedSuccess);			typeSetChain: 				CompactToExtendedLink(compactH, extendH, chtb, deftype, typesetchain, theName, false,compactToExtendedSuccess);			exSetChain: 				CompactToExtendedLink(compactH, extendH, exb, 1, exsetchain, theName, false,compactToExtendedSuccess);			charSetChain: 				CompactToExtendedLink(compactH, extendH, exb, 1, charsetchain, theName, false,compactToExtendedSuccess);			taxSetChain: 				CompactToExtendedLink(compactH, extendH, exb, 1, taxsetchain, theName, false,compactToExtendedSuccess);			otherwise				;		end;		ZapHandle(compactH);		if not MemoryOK then			goto 1;  {v3.05}		SetLink(theChain, thelink - 1, extendH);		if not MemoryOK then			goto 1;  {v3.05}		success := compactToExtendedSuccess;1:		ZapHandle(extendH);	end;{-----------------------------------------------------------------------------}	procedure ReadTheLink (theChain: Integer);		var			oldUserLinks: integer;			success: boolean;	begin		oldUserLinks := UserLinks[theChain];		ReadstrCHUNK(theChain);		if olduserLinks < UserLinks[theChain] then  {it's not foreign}			begin				ExtendTheLink(thechain, EndUserLink(theChain) + 1, success);				if not success then					RemoveLink(thechain, EndUserLink(thechain));			end;	end;{-----------------------------------------------------------------------------}	procedure ReadPartNames;	var partNumber: integer;		token: str255;	begin		repeat			token := GetFileToken(maxtok);			if token <> ';' then				begin					partNumber := GetCharPartNameNumberFromString(token);					if partNumber <= 0 then						begin							UnderlinetoBlanks(token);							AddNewCharPartName(token);						end;				end;		until (token=';')	 | errorflag | (fpos >= mcFileLength);	end;{-----------------------------------------------------------------------------}	procedure ReadSets(theNexusBlock: NexusBlockPtr; firstCommand: str255);		label			1;		var			command, UpperCaseCommand, ds: str255;			c: char;			optionsread: boolean;			oldUserLinks: integer;	begin		optionsRead := false;		fullNexus1 := true;   {If there is a SETS, then use all NEXUS1 features}		{if next in whitespace then			next := nextdarkchar;}		command := firstCommand;		UpperCaseCommand := MakeCaps(command);		if not EndOfBlock(UpperCaseCommand) then			repeat				badmemory := false;				UpdateThermo(iothermo, 0, fpos, mcFileLength,true);				errorflag := abortedThermo;				if errorflag then					leave;				if UpperCaseCommand = 'CHARSET' then					begin						SetCursID(virus);						ReadTheLink(charSetChain);					end				else if UpperCaseCommand = 'TAXSET' then					begin						SetCursID(virus);						ReadTheLink(taxSetChain);					end				else if upperCaseCommand = 'CHARPARTITION' then					begin						SetCursID(bacteria);						ReadTheLink(CharPartitionChain);					end				else if UpperCaseCommand = 'CHARPARTNAMES' then					begin						SetCursID(bacteria);						ReadPartNames;					end				else if UpperCaseCommand <> ';' then					ReadForeignLine(setsBlock, command);1:				if next in whitespace then					next := nextdarkchar;				command := GetFileToken(maxtok);				UpperCaseCommand := MakeCaps(command);			until EndOfBlock(UpperCaseCommand) or (badmemory and optionsread) or errorflag or (fpos > mcFileLength);		Skipper(punctuation, true);	end;{----------------------------------------------------------------------------}	procedure ReadGroupColor(partNumber: integer);	var 	ds: str255;		theColor: RGBColor;	begin		ds := MakeCaps(GetFileToken(maxtok));		if ds = 'RGB' then			begin				ReadDecimalRGB(theColor);				SetPartNameColor(partNumber,theColor);			end;	end;{-----------------------------------------------------------------------------}	procedure ReadCharGroupLabel;	var partNumber: integer;		token: str255;	begin		token := GetFileToken(maxtok);		UnderlinetoBlanks(token);		AddNewCharPartName(token);		repeat			token := MakeCaps(GetFileToken(maxtok));			if (token = 'COLOR') |  (token = 'COLOUR')  then				begin					SkipEqual;					token := GetFileToken(maxtok);  {should be "("}					if token = '(' then						ReadGroupColor(numCharPartNames);					token := GetFileToken(maxtok);  {should be ")"}				end;		until (token=';')	 | errorflag | (fpos >= mcFileLength);	end;{-----------------------------------------------------------------------------}	procedure ReadLabels(theNexusBlock: NexusBlockPtr; firstCommand: str255);		label			1;		var			command, UpperCaseCommand, ds: str255;			c: char;			oldUserLinks: integer;	begin		command := firstCommand;		UpperCaseCommand := MakeCaps(command);		if not EndOfBlock(UpperCaseCommand) then			repeat				badmemory := false;				UpdateThermo(iothermo, 0, fpos, mcFileLength,true);				errorflag := abortedThermo;				if errorflag then					leave;				if UpperCaseCommand = 'CHARGROUPLABEL' then					begin						SetCursID(bacteria);						ReadCharGroupLabel;					end				else if UpperCaseCommand <> ';' then					ReadForeignLine(labelsBlock, command);1:				if next in whitespace then					next := nextdarkchar;				command := GetFileToken(maxtok);				UpperCaseCommand := MakeCaps(command);			until EndOfBlock(UpperCaseCommand) or (badmemory) or errorflag or (fpos > mcFileLength);		Skipper(punctuation, true);	end;{-----------------------------------------------------------------------------}	procedure ReadMSTAXA;		var			ds: str255;	begin		SkipEqual;		ds := MakeCaps(GetFileToken(maxtok));		if ds = 'UNCERTAIN' then			mstaxa := mstUncertain		else if ds = 'POLYMORPH' then			mstaxa := mstPolymorph		else if ds = 'VARIABLE' then			mstaxa := mstVariable		else			begin				InstantErrorPlus(264, ds);				DrawDialog(iothermo);			end;	end;{-----------------------------------------------------------------------------}	procedure ReadIGNORE;		var			ds: str255;	begin		SkipEqual;		ds := MakeCaps(GetFileToken(maxtok));		if ds = 'UNINFORM' then			ignore := uninform		else if ds = 'INVAR' then			ignore := invar		else if ds = 'NONE' then			ignore := ignorenone		else			begin				InstantErrorPlus(265, ds);				DrawDialog(iothermo);			end;	end;{-----------------------------------------------------------------------------}	procedure ReadGAPMODE;		var			ds: str255;	begin		SkipEqual;		ds := MakeCaps(GetFileToken(maxtok));		if ds <> 'MISSING' then			begin				InstantErrorPlus(266, ds);				DrawDialog(iothermo);			end;	end;{-----------------------------------------------------------------------------}	procedure ReadAssumptions(theNexusBlock: NexusBlockPtr; firstCommand: str255);		label			1;		var			command, upperCaseCommand, ds: str255;			c: char;			optionsread: boolean;			oldUserLinks: integer;	begin		{if next in whitespace then			next := nextdarkchar;}		optionsread := false;    {OPTIONS is only one of these that doesn't require memory}		command := firstCommand;		UpperCaseCommand := MakeCaps(command);		if not EndOfBlock(upperCaseCommand) then			repeat				badmemory := false;				UpdateThermo(iothermo, 0, fpos, mcFileLength,true);				errorflag := abortedThermo;				if errorflag then					leave;				if (upperCaseCommand = 'USERTYPE') then					begin						SetCursID(trilobite);						ds := GetFileToken(maxtok);						ReadUserType(ds);					end				else if upperCaseCommand = 'WTSET' then					begin						SetCursID(mouse);						ReadTheLink(wtSetChain);					end				else if upperCaseCommand = 'CHARPARTITION' then					begin						SetCursID(bacteria);						ReadTheLink(CharPartitionChain);					end				else if UpperCaseCommand = 'CHARPARTNAMES' then					begin						SetCursID(bacteria);						ReadPartNames;					end				else if upperCaseCommand = 'TYPESET' then					begin						SetCursID(anemone);						ReadTheLink(typeSetChain);					end				else if upperCaseCommand = 'EXSET' then					begin						SetCursID(planaria);						ReadTheLink(exSetChain);					end				else if upperCaseCommand = 'CHARSET' then					begin						SetCursID(virus);						ReadTheLink(charSetChain);					end				else if upperCaseCommand = 'TAXSET' then					begin						SetCursID(virus);						ReadTheLink(taxSetChain);					end				else if (upperCaseCommand = 'OPTIONS') or (upperCaseCommand = 'OPTION') then					begin						optionsread := true;						repeat							ds := MakeCaps(GetFileToken(maxtok));							if (ds = 'GAPMODE') then								ReadGAPMODE{else if (ds = 'IGNORE') then ReadIGNORE}							else if (ds = 'DEFTYPE') then								begin									SkipEqual;									deftype := ConvertToType(MakeSmall(GetFileToken(maxtok)));									if (DefaultLink[typeSetChain] = 0) and (deftype <= 2) then										DefaultLink[typeSetChain] := deftype - 1;								end							else if (ds = 'POLYTCOUNT') then								begin									SkipEqual;									ds := GetFileToken(maxtok);									polyreal := (ds = 'MAXSTEPS');								end{$IFC FALSE}							else if (ds = 'POLYMCOUNT') then								begin									SkipEqual;									ds := GetFileToken(maxtok);									if ds <> 'ADDSTEPS' then										NewError(90, 0);								end{$ENDC}							else if ds = ';' then								goto 1							else if (ds <> ',') then								begin									errorflag := CWarning(concat('MacClade does not support ', ds, '.'), 'Cancel', 'Continue');									if errorflag then										badfile := true;									SkipOption;								end;						until errorflag;					end				else if upperCaseCommand <> ';' then					ReadForeignLine(assumptionsBlock,command);1:				if next in whitespace then					next := nextdarkchar;				command := GetFileToken(maxtok);				UpperCaseCommand := MakeCaps(command);			until EndOfBlock(upperCaseCommand) or (badmemory and optionsread) or errorflag or (fpos > mcFileLength);		Skipper(punctuation, true);	end;end.