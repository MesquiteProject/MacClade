unit EditorGeneralUtil;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{ееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface, 		 UtilLibInterface, MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, 		 TypeUtil, CharUtil, TreeUtil, MenuUtil, SymbolsNames, FootNote, SpreadUtil, EditorCellEntry, EditorSelection,		 ConsensusSequences;	procedure SetScrollMax;	procedure AdjustFonts;	procedure ShrinkWrapEditWindow (var height, width: integer);	procedure SizeEditWindow;	procedure CheckNoteLength;	procedure ReSizeEditorWindow;	procedure SwitchEditorShowAAWithDNA;{ееееееееееееееееееееее}implementation {е$S SpreadUtil}{----------------------------------------------------------------------------}	procedure AdjustFonts;		var			info: FontInfo;			largeLetterNudge, extraAscent: integer;	begin		if editorOpen then			begin				mySetPortTextFont(editorWindow,editorFont);				mySetPortTextSize(editorWindow,editorFontSize);								CalcLineWidthDescent(editorCellTE,editorFont,editorLineWidth,editorFontDescent,editorFontAscent);				SetTELineWidthDescent(noteTE,editorLineWidth, editorFontDescent,editorFontAscent);								editorTitleLineWidth := editorLineWidth;				notewidth := footNoteLines * editorLineWidth + 4;				if AAAutoTranslationVisible then					editorLineWidth := editorLineWidth*2;				editorCellTE^^.txFont := editorFont;				editorCellTE^^.txSize := editorFontSize;				noteTE^^.txFont := editorFont;				noteTE^^.txSize := editorFontSize;{following dictates how far from bottom of editorSelectionRect letters get written by MacClade}			end		else			begin				editorLineWidth := editorFontSize + 3;				editorTitleLineWidth := editorFontSize + 3;				notewidth := footNoteLines * editorFontSize + 7;				editorFirstRow := 1;				editorFirstColumn := 1;			end;		editorTitlesWidth := editorTitleLineWidth * 2;		editorLineSensitivity:= defaultEditorLineSensitivity;		if editorLineSensitivity > editorColumnWidth div 2-1 then			editorLineSensitivity := 2;		{if editorTitlesWidth < transposewidth then			editorTitlesWidth := transposewidth;}		CheckConsensusSequences;		editorRowNameStart := editorTitlesWidth;		editorRowNameEnd := editorRowNameStart + editorRowNameWidth;		editorFirstRowTop:= editorTitlesWidth;		editorFirstColumnLeft:= editorRowNameEnd;		If ConsensusSequenceVisible then			if  not editorTransposed  then				editorFirstRowTop:= editorTitlesWidth + editorNumConsensusSequences*editorLineWidth+consensusBoundaryLineThickness			else				editorFirstColumnLeft := editorRowNameEnd+editorNumConsensusSequences*editorColumnWidth+consensusBoundaryLineThickness;	end;{----------------------------------------------------------------------------}	procedure SetScrollMax;		var			maxrows, maxcols, tempi: integer;			oldClip: RgnHandle;	begin		oldClip := NewRgn;		GetClip(oldClip);		ClipREct(WindowPortRect(editorWindow));		maxrows := editorTotalRows - 1;		if maxrows < 0 then			maxrows := 0;		if not editorTransposed and (maxrows > (mntaxa - editorRows + 1)) then			maxrows := (mntaxa - editorRows + 1)		else if editorTransposed and (maxrows > (mnchars - editorRows + 1)) then			maxrows := (mnchars - editorRows + 1);		if maxrows < 0 then			maxrows := 0;		tempi := GetControlValueLong(editorVScroll);		if tempi > maxrows then			begin				SetControlValueLong(editorVScroll, maxrows);				editorOrigin.v := maxrows + 1;			end;		SetControlMaximumLong(editorVScroll, maxrows);		maxcols := editorTotalColumns - 1;		if maxcols < 0 then			maxcols := 0;		if editorTransposed and (maxcols > (mntaxa - editorColumns + 1)) then			maxcols := (mntaxa - editorColumns + 1)		else if not editorTransposed and (maxcols > (mnchars - editorColumns) + 1) then			maxcols := (mnchars - editorColumns + 1);		if maxcols < 0 then			maxcols := 0;		tempi := GetControlValueLong(editorHScroll);		if tempi > maxcols then			begin				SetControlValueLong(editorHScroll, maxcols);				editorOrigin.h := maxcols + 1;			end;		SetControlMaximumLong(editorHScroll, maxcols);		SetClip(oldClip);		ZapRegion(oldClip);	end;{----------------------------------------------------------------------------}	procedure ShrinkWrapEditWindow (var height, width: integer);{doesn't actually change the size of the window; }{rather, it calculates the height and width of the window}{when shrink wrapped from the height and width passed to it}		var			tempP: WindowPtr;			HW: integer;	begin		genericGetPort(tempP);		genericSetPort(editorWindow);		AdjustFonts;		HW := width - scrollwidth - editorFirstColumnLeft;		editorColumns := HW div editorColumnWidth;		if editorColumns < 1 then			editorColumns := 1;		HW := height - scrollwidth - editorFirstRowTop - notewidth - notegap;		editorRows := HW div editorLineWidth;		if editorRows < 1 then			editorRows := 1;		width := editorFirstColumnLeft + editorColumns * editorColumnWidth + scrollwidth;		height := editorFirstRowTop + editorRows * editorLineWidth + scrollwidth + notewidth + notegap;		genericSetPort(tempP);	end;{----------------------------------------------------------------------------}	procedure SizeEditWindow;		var			H, W: Integer;			box: rect;	begin		CheckConsensusSequences;		W := maxEWR.right - maxEWR.left;		H := maxEWR.bottom - maxEWR.top;		ShrinkWrapEditWindow(H, W);		genericSetPort(editorWindow);		maxEWR.right := maxEWR.left + W;		maxEWR.bottom := maxEWR.top + H;		SetRect(editorFootNoteRect, 1, H - notewidth + 2, W - scrollwidth - 1, H);{$IFC EXPANDFEET}		notePullR := editorFootNoteRect;		notePullR.top := notePullR.top - 2;		notePullR.bottom := notePullR.top + 4;{$ENDC}		SizeWindow(editorWindow, W, H, TRUE);	{	MoveControl(editorVScroll, W - scrollwidth+1, editorTitlesWidth+1);		SizeControl(editorVScroll, scrollwidth + 1, H - scrollwidth - notewidth - notegap - editorTitlesWidth-2);		MoveControl(editorHScroll, editorRowNameEnd + 2, H - scrollwidth - notewidth - notegap+1);		SizeControl(editorHScroll, W - scrollwidth - editorRowNameEnd-2, scrollwidth + 1);}		MoveControl(editorVScroll, W - scrollwidth, editorTitlesWidth);		SizeControl(editorVScroll, scrollwidth + 1, H - scrollwidth - notewidth - notegap - editorTitlesWidth);		MoveControl(editorHScroll, editorRowNameEnd + 1, H - scrollwidth - notewidth - notegap);		SizeControl(editorHScroll, W - scrollwidth - editorRowNameEnd, scrollwidth + 1);		SetRect(edSelQueryRect, W - scrollwidth, H - scrollwidth - notewidth - notegap, W, H - scrollwidth);		box := editorFootNoteRect;		InsetRect(box, 1, 1);		noteTE^^.destRect := box;		noteTE^^.destRect.left := editorFootNoteRect.left + 9;{    noteTE^^.destRect.top := editorFootNoteRect.top + 1;}		noteTE^^.viewRect := noteTE^^.destRect;	end;{----------------------------------------------------------------------------}	procedure CheckNoteLength;	begin		if noteTE^^.teLength > 254 then			begin				SetHandleSize(noteTE^^.hText, 254);				noteTE^^.teLength := 254;				TECalText(noteTE);				TEUpDate(noteTE^^.viewRect, noteTE);				InstantError(118);			end;	end;{----------------------------------------------------------------------------}	procedure ReSizeEditorWindow;	begin		genericSetPort(editorwindow); {&&&}		FixTotNums;		HideControl(editorVScroll);   {hide scrolls so that they won't flash when being moved}		HideControl(editorHScroll);		SizeEditWindow;		SetScrollMax;		genericSetPort(editorWindow);		ClipRect(WindowPortRect(editorWindow));		EraseRect(WindowPortRect(editorWindow));		CalcEditorBoundaryRect;		CalcEditorMatrixRect;		EraseRect(editorMatrixRect);		InvalidateWindowRect(editorWindow,WindowPortRect(editorWindow),false);		if isforeground then			begin				ShowControl(editorVScroll);				ShowControl(editorHScroll);			end;		CalcEditorSelectionRect(editorSelectionTopLeft, editorSelectionBotRight);		MovesTE;{$IFC EXPANDFEET}		TECalText(noteTE);{$ENDC}	end;{----------------------------------------------------------------------------}	procedure SwitchEditorShowAAWithDNA;	begin 		editorShowAAwithDNA := not editorShowAAwithDNA;		InvalidateWindow(editorWindow, true);		ReSizeEditorWindow;		myCheckMenuItem(AATranslateMHdl,AATranslateShowItem, editorShowAAwithDNA);		EnableDisableItem(AATranslateMHdl,AATranslateDimNucItem, nucleotides & AAAutoTranslationVisible);		EnableDisableItem(AATranslateMHdl,AATranslateColorItem, nucleotides & AAAutoTranslationVisible);	end;end.