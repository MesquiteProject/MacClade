unit ChartToType;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, BoxUtil, CharUtil, StrUtil, TypeUtil, CHUNK, MenuUtil, TaxonCHUtil, LinkUtil, ChartWUtil;	procedure ChartToWeightsDLOG;	procedure ScatterToTypeDLOG;{еееееееееееееееееееееее}implementation {е$S ChartToType}	const		defScaleMin = 1;		defScaleMax = 10;	var		InfiniteToInfinite: boolean;{-----------------------------------------------------------------------------}	function NumToCreate (var settodo: set15): integer;{return how many weightsets are to be created; one for each in calculation set of current chart}	begin		settodo := SpotBarSetToCalc;		NumToCreate := cardP(@settodo, 15);	end;{-----------------------------------------------------------------------------}	function MinMaxSuffix (theKind: integer): str255;		var			ds: str255;	begin		if MinMaxOn then			begin				case theKind of					CMminmin, CMmaxmin: 						ds := ' min';					CMminmean, CMMaxmean: 						ds := ' avg';					CMminmax, CMmaxmax: 						ds := ' max';					otherwise						ds := '';				end;				case theKind of					CMminmin, CMminmax, CMminmean: 						ds := concat(ds, ' min');					CMmaxmin, CMMaxmean, CMmaxmax: 						ds := concat(ds, ' max');					otherwise						;				end;			end		else			case theKind of				CMmin: 					ds := ' min';				CMstandard: 					ds := ' avg';				CMmax: 					ds := ' max';				otherwise					ds := ''			end;		MinMaxSuffix := ds;	end;{-----------------------------------------------------------------------------}	procedure ChartToWeights (ScaleStart, ScaleEnd: double; integersonly: boolean; settodo: set15);		type			wts3 = array[0..2] of longint;		var			charHdl: chHdl;			numWtSets: integer;			ic, whichwt: integer;			theKind: integer;			minWt, maxWt: double;			towt: longint;			storageH: Handle;			oldrealwt: boolean;			theValue, obsR, minR, maxR: double;			towt3: wts3;			theData: longint;			ds: str255;			oldState: SignedByte;{...............}		procedure ScaleWtValue (var theValue: double; valueMin, valueMax, scaleMin, scaleMax: double);		begin			if (theValue > 0.000001) | CIRIData then				if valueMax = ValueMin then					theValue := scaleMin				else					theValue := scaleMin + (theValue - valueMin) * (scaleMax - scaleMin) / (valueMax - valueMin)			else				theValue := ScaleMax;		end;{...............}		function CalcUnscaledWtValue (obsR: double): double;			var				UnscaledValue: double;		begin			if obsR < 0.000001 then				unscaledValue := minWt			else				case SACWfunction of					SACWInverse: 						unscaledValue := 1 / obsR;					SACWSquareInverse: 						unscaledValue := 1 / sqr(obsR);					SACWCI, SACWRC, SACWRI: 						unscaledValue := obsR;					otherwise						;				end;			CalcUnscaledWtValue := unscaledValue;		end;{...............}	begin		storageH := NewHandle(0);		CopyHandles(chstorewtH, storageH);		oldrealwt := realwt;		realwt := not integersonly;		whichwt := 0;		numWtSets := NumToCreate(settodo);		for theKind := 0 to numCLkinds do			if theKind in settodo then				begin					whichwt := whichwt + 1;{==== calculating minR maxR values  =====}{calculates minimum non-zero values if not ci ri rc, but minimum values if ci ri rc}					minR := 1000000.0;					MaxR := 0.0;					for ic := 0 to numintervals[theKind] - 1 do						begin							theData := GetChartLinearData(theKind, ic);							if MeanSpotBar(theKind) then								obsR := 1.0 * theData / MeanInflate / catwid							else								obsR := 1.0 * theData;							if (MinR > obsR) & ((theData > 0) | CIRIData) then								MinR := obsR;							if (MaxR < obsR) then								MaxR := obsR;						end;{==== calculating unscaled minWt maxWt values  =====}					if CIRIData then						begin							maxWt := CalcUnscaledWtValue(maxR);							minWt := CalcUnscaledWtValue(minR);						end					else						begin							maxWt := CalcUnscaledWtValue(minR);							minWt := CalcUnscaledWtValue(maxR);						end;{==== calculating & scaling & assigning values  =====}					if sequencechart then						for ic := 1 to numchars do							if CharIncluded(ic) then								begin									if MeanSpotBar(theKind) then										obsR := 1.0 * GetChartLinearData(theKind, (ic - 1) div catwid) / MeanInflate / catwid									else										obsR := 1.0 * GetChartLinearData(theKind, (ic - 1) div catwid);									theValue := CalcUnscaledWtValue(obsR);									ScaleWtValue(theValue, minWt, maxWt, scaleStart, scaleEnd);									if not integersonly then										theValue := theValue * wtinflate;									SetWeight(ic, RoundValue(theValue));									UseToWtStorage(ic);								end							else								begin									SetWeight(ic, 0);									UseToWtStorage(ic);								end					else if positionchart then						begin							for ic := 0 to 2 do								begin									obsR := 1.0 * GetChartLinearData(theKind, ic);									if MeanSpotBar(theKind) then										obsR := obsR / MeanInflate / catwid;									theValue := CalcUnscaledWtValue(obsR);									ScaleWtValue(theValue, minWt, maxWt, scaleStart, scaleEnd);									if not integersonly then										theValue := theValue * wtinflate;									towt3[ic] := RoundValue(theValue);								end;							for ic := 1 to numchars do								if CodPosSet(ic) then									begin										SetWeight(ic, towt3[CharCodPos(ic) - 1]);										UseToWtStorage(ic);									end								else									begin										SetWeight(ic, 0);										UseToWtStorage(ic);									end						end;					LockHandle(ChartToWtName, oldstate);					ds := ChartToWtName^^;					if length(ds)>200 then ds := copy(ds, 1, 200);					ResetHandle(ChartToWtName, oldstate);					if numWtSets > 1 then						ds := concat(ds, MinMaxSuffix(theKind));					SaveLinkToChain(wtsetchain, ds, false,false);				end;		realwt := oldrealwt;		CopyHandles(storageH, chstorewtH);		for ic := 1 to numchars do			WtStorageToUse(ic);		ZapHandle(storageH);	end;{-----------------------------------------------------------------------------}	procedure ChartToWeightsDLOG;		label			1;		var			theDialog: DialogPtr;			tempP: WindowPtr;			numWTSETs: integer;			oldSACWfunction: integer;			integersonly, isreal: boolean;			scaleStart, ScaleEnd, treal: double;			tint: longint;			settodo: set15;			oldState: SignedByte;			localItemHit: integer;{...............}		procedure ChartWtChecks;		begin			if not (CWStepsShow in [CWStepsCI, CWStepsRI, CWStepsRC]) then				begin					ItemCheckMark(theDialog, 3, SACWfunction = SACWInverse);					ItemCheckMark(theDialog, 4, SACWfunction = SACWSquareInverse);				end;			ItemCheckMark(theDialog, 8, integersonly);		end;{...............}	begin		integersonly := false;		oldSACWfunction := SACWFunction;		LockHandle(ChartToWtName, oldstate);		if CWStepsShow in [CWStepsCI, CWStepsRI, CWStepsRC] then			begin				StartDLOG(588, theDialog, tempP);				SetDLOGText(theDialog, 12, ChartToWtName^^, true);			end		else			begin				StartDLOG(585, theDialog, tempP);				SetDLOGText(theDialog, 14, ChartToWtName^^, true);			end;		ResetHandle(ChartToWtName, oldstate);		case CWStepsShow of			CWStepsCI: 				begin					SACWFunction := SACWCI;					SetDLOGText(theDialog, 3, 'weight = CI', false)				end;			CWStepsRI: 				begin					SACWFunction := SACWRI;					SetDLOGText(theDialog, 3, 'weight = RI', false)				end;			CWStepsRC: 				begin					SACWFunction := SACWRC;					SetDLOGText(theDialog, 3, 'weight = RC', false)				end;			otherwise				if (SACWFunction = SACWCI) or (SACWFunction = SACWRI) or (SACWFunction = SACWRC) then					SACWFunction := SACWInverse;		end;		numWTsets := NumToCreate(settodo);		Paramtext(StringFromNum(numwtsets), '', '', '');		ChartWtChecks;		SetEditTextNum(theDialog, 9, defScaleMin, defScaleMin, not integersonly, true);		SetEditTextNum(theDialog, 10, defScaleMax, defScaleMax, not integersonly, false);		myShowDialog(theDialog);1:		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			case localItemHit of				3: 					SACWfunction := SACWInverse;				4: 					SACWfunction := SACWSquareInverse;				8: 					integersonly := not integersonly;				otherwise					;			end;			ChartWtChecks;		until localItemHit in [1, 2];		if localItemHit = 1 then			begin				if CWStepsShow in [CWStepsCI, CWStepsRI, CWStepsRC] then					ChartToWtName^^ := GetEditText(theDialog, 12)				else					ChartToWtName^^ := GetEditText(theDialog, 14);				EditTextNum(theDialog, 9, treal, tint, isreal);				if isreal then					ScaleStart := treal				else					ScaleStart := 1.0 * tint;				EditTextNum(theDialog, 10, treal, tint, isreal);				if isreal then					ScaleEnd := treal				else					ScaleEnd := 1.0 * tint;				if (ScaleStart >= ScaleEnd) | (integersonly & (ScaleEnd > MaxWtInt)) | (not integersonly & (ScaleEnd > MaxWtReal / wtinflate)) then					begin						SelectDialogItemText(theDialog, 9, 0, 32000);						Beep;						goto 1;					end;			end;		EndDLOG(theDialog, tempP);		if localItemHit = 2 then			SACWfunction := oldSACWFunction		else			begin				ChartToWeights(ScaleStart, ScaleEnd, integersonly, SetToDo);			end;	end;{-----------------------------------------------------------------------------}	procedure ScatterToType (ScaleStart, ScaleEnd: double; integersonly: boolean; settodo: set15);		type			realarray = array[0..absmaxstate] of double;		var			theDialog: DialogPtr;			tempP: WindowPtr;			ds: str255;			numTypesCreated: integer;			oldChartTypeFunction, whichtype: integer;			isfrom, isto, theKind: integer;			rowtot, rowscaleFactor, rowminR, rowmaxR, rowObsRange: realarray;			obsR, minR, maxR, matrixtot, divide: double;			value: double;			convertedValues: array[0..absmaxstate, 0..absmaxstate] of double;			tname: string[typesig];			oldState: SignedByte;{...............}		function CalcUnscaledValue (obsValue, minValue, maxValue, tot: double): double;			var				unscaledValue: double;		begin			if obsValue < 0.00001 then				unscaledValue := 0.0			else				begin					if MeanSpotBar(theKind) then						obsValue := obsValue / MeanInflate;					if InflatedChanges then						obsValue := obsValue / MeanChangesInflate;					case ChartTypeFunction of						ChartTypeInverse: 							unscaledValue := 1 / obsValue;						ChartTypeSquareInverse: 							unscaledValue := 1 / (sqr(obsValue));						ChartTypeLN, ChartTypeLNMatNorm: 							if obsValue = tot then								unscaledValue := scaleStart							else								unscaledValue := -ln(obsValue / tot);						otherwise							;					end;				end;			CalcUnscaledValue := unscaledValue;		end;{...............}		procedure ScaleValue (var theValue: double; valueMin, valueMax, scaleMin, scaleMax: double);		begin			if theValue > 0.000001 then				if valueMax = ValueMin then					theValue := scaleMin				else					theValue := scaleMin + (theValue - valueMin) * (scaleMax - scaleMin) / (valueMax - valueMin);		end;{...............}		procedure CalcGlobalMinMax;			var				isfrom, isto: integer;		begin			minR := 1000000.0;			MaxR := 0.0;			for isfrom := 0 to maxChartMatrixCat do				begin					if (rowminR[isfrom] > 0) & (rowminR[isfrom] < minR) then						minR := rowminR[isfrom];					if (rowmaxR[isfrom] > 0) & (maxR < rowmaxR[isfrom]) then						maxR := rowmaxR[isfrom];				end;		end;{...............}		procedure CalcTots;			var				isfrom, isto: integer;				divide: double;		begin			matrixtot := 0.0;			divide := ChangesDivide(theKind);			for isfrom := 0 to maxChartMatrixCat do				begin					rowtot[isfrom] := 0.0;					for isto := 0 to maxChartMatrixCat do						if isto <> isfrom then							rowtot[isfrom] := rowtot[isfrom] + ChartMatrixData[theKind]^[isfrom][isto] / divide;					matrixtot := matrixtot + rowtot[isfrom];				end;		end;{...............}	begin		whichtype := 0;		numTypesCreated := NumToCreate(settodo);		for theKind := 0 to numCLkinds do			if theKind in settodo then				begin					whichtype := whichtype + 1;					AddCHUNKs(typeCHUNKs, 1, Sizeof(typeRecord));					if badmemory then						leave;					numtypes := numtypes + 1;					typeHdl := gettypeHdl(numtypes);					typehdl^^.setdefined := [0..integer(maxChartMatrixCat)];   {note: has to be recast as an integer otherwise }																			{the Think Pascal compiler complains of a subrange error}					typeHdl^^.max := maxChartMatrixCat;					divide := ChangesDivide(theKind);{==============================================================}{===== calculating minimum and maximum value in each row of the matrix ======}{==============================================================}{note that minimum value is non-zero minimum value}					for isfrom := 0 to maxChartMatrixCat do						begin							rowminR[isfrom] := 1000000.0;							rowmaxR[isfrom] := 0.0;							for isto := 0 to maxChartMatrixCat do								if isto <> isfrom then									if (ChartMatrixData[theKind]^[isfrom][isto] > 0) then										begin											obsR := 1.0 * ChartMatrixData[theKind]^[isfrom][isto] / divide;											if (obsR < rowminR[isfrom]) then												rowminR[isfrom] := obsR;											if (obsR > rowmaxR[isfrom]) then												rowmaxR[isfrom] := obsR;										end;{    if rowMaxR[isfrom] = 0 then rowMaxR[isfrom] := 1;}							if rowminR[isfrom] > rowmaxR[isfrom] then								rowminR[isfrom] := rowmaxR[isfrom];						end;{==============================================================}{========  calculating global minimum and maximum values in matrix  =========}{==============================================================}					CalcGlobalMinMax;{calculates row and matrix totals}					if (ChartTypeFunction = ChartTypeLN) or (ChartTypeFunction = ChartTypeLNMatNorm) then						CalcTots;{==============================================================}{==================== calculating values ======================}{==============================================================}					for isfrom := 0 to maxChartMatrixCat do						for isto := 0 to maxChartMatrixCat do							if isfrom <> isto then								begin									obsR := 1.0 * ChartMatrixData[theKind]^[isfrom][isto];									if chartTypeFunction = ChartTypeLn then										convertedValues[isfrom, isto] := CalcUnscaledValue(obsR, rowMinR[isfrom], rowMaxR[isfrom], rowtot[isfrom])									else										convertedValues[isfrom, isto] := CalcUnscaledValue(obsR, minR, maxR, matrixtot);								end							else								convertedValues[isfrom, isto] := 0.0;{==============================================================}{============== calculating converted mins and maxs ====================}{==============================================================}					for isfrom := 0 to maxChartMatrixCat do						begin							rowminR[isfrom] := 1000000.0;							rowmaxR[isfrom] := 0.0;							for isto := 0 to maxChartMatrixCat do								if isto <> isfrom then									if (convertedValues[isfrom, isto] > 0) then										begin											if (convertedValues[isfrom, isto] < rowminR[isfrom]) then												rowminR[isfrom] := convertedValues[isfrom, isto];											if (convertedValues[isfrom, isto] > rowmaxR[isfrom]) then												rowmaxR[isfrom] := convertedValues[isfrom, isto];										end;{    if rowMaxR[isfrom] = 0 then rowMaxR[isfrom] := 1;}							if rowminR[isfrom] > rowmaxR[isfrom] then								rowminR[isfrom] := rowmaxR[isfrom];						end;{==============================================================}{========  calculating global minimum and maximum converted values  =========}{==============================================================}					CalcGlobalMinMax;{==============================================================}{==================== scaling values ======================}{==============================================================}					for isfrom := 0 to maxChartMatrixCat do						for isto := 0 to maxChartMatrixCat do							if isfrom <> isto then								begin									if chartTypeFunction = ChartTypeLn then										ScaleValue(convertedValues[isfrom, isto], rowMinR[isfrom], rowMaxR[isfrom], scaleStart, scaleEnd)									else										ScaleValue(convertedValues[isfrom, isto], minR, maxR, scaleStart, scaleEnd);								end;{====== calculating costs =====}					LockHandle(typeHdl, oldstate);					with typeHdl^^ do						for isfrom := 0 to maxChartMatrixCat do							for isto := 0 to maxChartMatrixCat do								if isfrom <> isto then									begin										if convertedValues[isfrom, isto] = 0.0 then											if infiniteToinfinite then												value := infinity											else												value := scaleEnd										else											value := convertedValues[isfrom, isto];										if value = infinity then											dist[isfrom][isto] := infinity										else if integersOnly then											dist[isfrom][isto] := RoundValue(value)										else											dist[isfrom][isto] := RoundValue(typeInflate * value);									end								else									dist[isfrom][isto] := 0;					ResetHandle(typeHdl, oldstate);					typeHdl^^.isreal := not integersonly;					typeHdl^^.polar := false;					LockHandle(ChartToTypeName, oldstate);					tname := CopyString(ChartToTypeName^^, 1, typesig);					ResetHandle(ChartToTypeName, oldstate);					if numtypesCreated > 1 then						begin							ds := MinMaxSuffix(theKind);							tname := CopyString(tname, 1, typesig - length(ds));							tname := concat(tname, ds);						end;					typeHdl^^.name := tname;					typeHdl^^.root := -1;					if not PassMetricity(typeHdl) then						NewError(26, 0);				end;	end;{-----------------------------------------------------------------------------}	procedure ScatterToTypeDLOG;		label			1;		var			theDialog: DialogPtr;			tempP: WindowPtr;			numTypesCreated: integer;			oldChartTypeFunction, whichtype: integer;			integersonly, isreal: boolean;			settodo: set15;			ScaleStart, ScaleEnd, treal: double;			tint: longint;			oldState: SignedByte;			localItemHit: integer;{...............}		procedure ChartTypeChecks;		begin			ItemCheckMark(theDialog, 3, ChartTypeFunction = ChartTypeInverse);			ItemCheckMark(theDialog, 4, ChartTypeFunction = ChartTypeSquareInverse);			ItemCheckMark(theDialog, 5, ChartTypeFunction = ChartTypeLN);			ItemCheckMark(theDialog, 6, ChartTypeFunction = ChartTypeLNMatNorm);			ItemCheckMark(theDialog, 10, integersonly);			ItemCheckMark(theDialog, 15, InfiniteToInfinite);		end;{...............}	begin		integersonly := false;		InfiniteToInfinite := true;		oldChartTypeFunction := ChartTypeFunction;		StartDLOG(584, theDialog, tempP);		LockHandle(ChartToTypeName, oldstate);		SetDLOGText(theDialog, 17, CharttoTypeName^^, true);		ResetHandle(ChartToTypeName, oldstate);		numTypesCreated := NumToCreate(settodo);		Paramtext(StringFromNum(numTypesCreated), '', '', '');		ChartTypeChecks;		SetEditTextNum(theDialog, 11, defScaleMin, defScaleMin, not integersonly, true);		SetEditTextNum(theDialog, 12, defScaleMax, defScaleMax, not integersonly, false);		myShowDialog(theDialog);1:		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			case localItemHit of				3: 					ChartTypeFunction := ChartTypeInverse;				4: 					ChartTypeFunction := ChartTypeSquareInverse;				5: 					ChartTypeFunction := ChartTypeLN;				6: 					ChartTypeFunction := ChartTypeLNMatNorm;				10: 					integersonly := not integersonly;				15: 					infiniteToInfinite := not InfiniteToInfinite;				otherwise					;			end;			ChartTypeChecks;		until localItemHit in [1, 2];		if localItemHit = 1 then			begin				ChartToTypeName^^ := GetEditText(theDialog, 17);				EditTextNum(theDialog, 11, treal, tint, isreal);				if isreal then					ScaleStart := treal				else					ScaleStart := 1.0 * tint;				EditTextNum(theDialog, 12, treal, tint, isreal);				if isreal then					ScaleEnd := treal				else					ScaleEnd := 1.0 * tint;				if (ScaleStart >= ScaleEnd) | (integersonly & (ScaleEnd > maxTypeInt)) | (not integersonly & (ScaleEnd > maxTypeReal / typeinflate)) then					begin						SelectDialogItemText(theDialog, 11, 0, 32000);						Beep;						goto 1;					end;			end;		EndDLOG(theDialog, tempP);		whichtype := 0;		if localItemHit = 2 then			ChartTypeFunction := oldChartTypeFunction		else			begin				ScatterToType(ScaleStart, ScaleEnd, integersonly, settodo);				ReBuildAssumpMenu;			end;	end;end.