unit CarbonUtil;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright David R. Maddison & Wayne P. Maddison 1986-2000}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{David or Wayne Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}{еееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееNOTE: ALL routines in this unit MUST be entirely self-sufficient, dependingupon NO other routines, even ones in this unit, although they can call routines in MemoryUtilеееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее}interface	uses		QuickDraw, Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound,		 Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, FP,		  Scrap,  Globals, MemoryUtil, 		   SetLibInterface, UtilLibInterface,   Script;{$IFC NOT CARBON}	function myGetWindowFromPort(thePort: CGrafPtr): WindowPtr;{$ELSEC}	function myGetWindowFromPort(thePort: CGrafPtr): WindowPtr;{$ENDC}	function myGetWindowPtrForDialog(theDialog: DialogPtr): WindowPtr;	function myGetDialogPtrForWindow(theWindow: WindowPtr): DialogPtr;	function myGetWindowPort(theWindow: WindowPtr): CGrafPtr;	function myGetWindowPtrFromEventMessage(Event: EventRecord): WindowPtr;		procedure myValidRect(theWindow: WindowPtr; box: rect);	function myGetVisRgnBounds(theWindow: WindowPtr): rect;	function myGetUpdateRgn(theWindow: WindowPtr): RgnHandle;	function myGetVisRgn(thePort: WindowPtr): RgnHandle;	function myGetWindowKind(theWindow: WindowPtr): integer;	procedure myShowDialog(theDialog: DialogPtr);	function myGrowWindow(theWindow: WindowPtr; thePoint: Point; var theRect: Rect): longint;	procedure myDragWindow(theWindow: WindowPtr; thePoint: Point; var theRect: Rect);	function myGetControlRect(theControl: ControlHandle): Rect;	function myGetPortBits(thePort: GrafPtr): BitMap;	function WindowPortRect(theWindow: univ WindowPtr): rect;	procedure myPortCopyBits(theSrcPort: GrafPtr; theDestPort: GrafPtr; var theSrcRect: Rect; var theDestRect: Rect; mode: integer; maskRgn: RgnHandle);	procedure myEnableItem(theMenu: MenuHandle; theItem: integer);	procedure myDisableItem(theMenu: MenuHandle; theItem: integer);	procedure myCheckMenuItem(theMenu: MenuHandle; theItem: integer; checked: boolean);	function myCountMenuItems(theMenu: MenuHandle):integer;		procedure genericGetPort(var theWindow: univ WindowPtr);	procedure genericSetPort(theWindow: univ WindowPtr);	function ScreenBoundsRect: rect;{$IFC NOT CARBON}	function QDThePort: GrafPtr;{$ELSEC}	function QDThePort: CGrafPtr;{$ENDC}	function QDThePortTextFont: integer;	function QDThePortTextSize: integer;	function QDThePortTextFace: style;	procedure setPortTextFont(theWindow: WindowPtr; theFont: integer);	procedure setPortTextSize(theWindow: WindowPtr; theSize: integer);	function QDdkGray: Pattern;	function QDltGray: Pattern;	function QDGray: Pattern;	function QDWhite: Pattern;	function QDBlack: Pattern;	procedure SetCursorToArrow;	procedure FillWhiteRect(box:rect);	procedure FillBlackRect(box: rect);	procedure InvalidateWindowRect(theWindow: univ WindowPtr; box: rect; restorePort: boolean);	procedure InvalidateWindowRegion(theWindow: univ WindowPtr; region: RgnHandle; restorePort: boolean);	function myGetNextWindow(theWindow: WindowPtr): WindowPtr;	function ArrowCursor: Cursor;	procedure myDateString(dateTime: LONGINT; longFlag: ByteParameter; VAR result: Str255);	procedure myTimeString(dateTime: LONGINT; wantSeconds: BOOLEAN; VAR result: Str255);	function MyNewUserItemUPP(theProc:Ptr): UniversalProcPtr;	procedure MyDisposeUserItemUPP(UPP:UniversalProcPtr);	function MyNewAEEventHandlerUPP(theProc:Ptr): UniversalProcPtr;	procedure MyDisposeAEEventHandlerUPP(UPP:UniversalProcPtr);	function MyNewControlActionUPP(theProc:Ptr): UniversalProcPtr;	procedure MyDisposeControlActionUPP(UPP:UniversalProcPtr);	function MyNewGrowZoneUPP(theProc:Ptr): UniversalProcPtr;	procedure MyDisposeGrowZoneUPP(UPP:UniversalProcPtr);	function MyNewDragGrayRgnUPP(theProc:Ptr): UniversalProcPtr;	procedure MyDisposeDragGrayRgnUPP(UPP:UniversalProcPtr);	function MyNewQDGetPicUPP(theProc:Ptr): UniversalProcPtr;	procedure MyDisposeQDGetPicUPP(UPP:UniversalProcPtr);	function MyNewQDPutPicUPP(theProc:Ptr): UniversalProcPtr;	procedure MyDisposeQDPutPicUPP(UPP:UniversalProcPtr);	function MyNewModalFilterUPP(theProc:Ptr): UniversalProcPtr;	procedure MyDisposeModalFilterUPP(UPP:UniversalProcPtr);	function MyNewDlgHookYDUPP(theProc:Ptr): UniversalProcPtr;	procedure MyDisposeDlgHookYDUPP(UPP:UniversalProcPtr);	function myIsControlVisible(theControl: ControlHandle): boolean;{еееееееееееееееееееееее}implementation {е$S genutils}{$IFC CARBON}{----------------------------------------------------------------------------}	function myGetWindowFromPort(thePort: CGrafPtr): WindowPtr;	begin		myGetWindowFromPort := GetWindowFromPort(thePort);	end;{$ELSEC}{----------------------------------------------------------------------------}	function myGetWindowFromPort(thePort: CGrafPtr): WindowPtr;	begin		myGetWindowFromPort := WindowPtr(thePort);	end;{$ENDC}{----------------------------------------------------------------------------}	function myGetWindowPtrForDialog(theDialog: DialogPtr): WindowPtr;	begin{$IFC CARBON}		myGetWindowPtrForDialog := GetDialogWindow(theDialog);{$ELSEC}		myGetWindowPtrForDialog := WindowPtr(theDialog);{$ENDC}	end;{----------------------------------------------------------------------------}	function myGetDialogPtrForWindow(theWindow: WindowPtr): DialogPtr;	begin{$IFC CARBON}		myGetDialogPtrForWindow := GetDialogFromWindow(theWindow);{$ELSEC}		myGetDialogPtrForWindow := DialogPtr(theWindow);{$ENDC}	end;{----------------------------------------------------------------------------}	function myGetWindowPtrFromEventMessage(Event: EventRecord): WindowPtr;	begin{$IFC CARBON}		myGetWindowPtrFromEventMessage := WindowPtr(Event.message);{$ELSEC}		myGetWindowPtrFromEventMessage := WindowPtr(Event.message);{$ENDC}	end;{----------------------------------------------------------------------------}	function myGetWindowPort(theWindow: WindowPtr): CGrafPtr;	begin{$IFC CARBON}		myGetWindowPort := GetWindowPort(theWindow);{$ELSEC}		myGetWindowPort := CGrafPtr(theWindow);{$ENDC}	end;{----------------------------------------------------------------------------}	procedure myShowDialog(theDialog: DialogPtr);	begin		ShowWindow(myGetWindowPtrForDialog(theDialog));	end;{----------------------------------------------------------------------------}	function myGrowWindow(theWindow: WindowPtr; thePoint: Point; var theRect: Rect): longint;		var			myRect: RectPtr;	begin		myRect := @theRect;		myGrowWindow := GrowWindow(theWindow, thePoint, myRect);	end;{----------------------------------------------------------------------------}	procedure myDragWindow(theWindow: WindowPtr; thePoint: Point; var theRect: Rect);		var			myRect: RectPtr;	begin		myRect := @theRect;		DragWindow(theWindow, thePoint, myRect);	end;{----------------------------------------------------------------------------}{$IFC NOT CARBON}	function myGetVisRgnBounds(theWindow: WindowPtr): rect;	begin		myGetVisRgnBounds := theWindow^.visRgn^^.rgnBBox;	end;{$ELSEC}	function myGetVisRgnBounds(theWindow: WindowPtr): rect;		var			myRgn: RgnHandle;			myRect: Rect;			myRectPtr: RectPtr;	begin		myRgn := NewRgn;		myRgn := GetPortVisibleRegion(CGrafPtr(theWindow), myRgn);		myRectPtr := GetRegionBounds(myRgn, myRect);		myGetVisRgnBounds := myRect;	end;{$ENDC}{----------------------------------------------------------------------------}{$IFC NOT CARBON}	function myGetVisRgn(thePort: WindowPtr): RgnHandle;	begin		myGetVisRgn := thePort^.visRgn;	end;{$ELSEC}	function myGetVisRgn(thePort: WindowPtr): RgnHandle;		var			myRgn: RgnHandle;	begin		myRgn := NewRgn;		myRgn := GetPortVisibleRegion(CGrafPtr(thePort), myRgn);		myGetVisRgn := myRgn;	end;{$ENDC}{----------------------------------------------------------------------------}{$IFC NOT CARBON}	function myGetPortBits(thePort: GrafPtr): BitMap;	begin		myGetPortBits := thePort^.portBits;	end;{$ELSEC}	function myGetPortBits(thePort: GrafPtr): BitMap;	begin		myGetPortBits := GetPortBitMapForCopyBits(thePort)^;	end;{$ENDC}{----------------------------------------------------------------------------}{$IFC NOT CARBON}	procedure myValidRect(theWindow: WindowPtr; box: rect);	begin		ValidRect(box);	end;{$ELSEC}	procedure myValidRect(theWindow: WindowPtr; box: rect);		var			os: OSStatus;	begin		os := ValidWindowRect(theWindow,box);	end;{$ENDC}{----------------------------------------------------------------------------}{$IFC NOT CARBON}	function myGetUpdateRgn(theWindow: WindowPtr): RgnHandle;	begin		myGetUpdateRgn := WindowPeek(theWindow)^.updateRgn;	end;{$ELSEC}	function myGetUpdateRgn(theWindow: WindowPtr): RgnHandle;		var			myRgn: RgnHandle;			os: OSStatus;	begin		myRgn := NewRgn;		os := GetWindowRegion(theWindow,kWindowUpdateRgn,myRgn);		if (os=noErr) then 			myGetUpdateRgn := myRgn		else			myGetUpdateRgn := nil;	end;{$ENDC}{----------------------------------------------------------------------------}	function myGetWindowKind(theWindow: WindowPtr): integer;	begin{$IFC NOT CARBON}		myGetWindowKind := WindowPeek(theWindow)^.windowKind;{$ELSEC}		myGetWindowKind := GetWindowKind(theWindow);{$ENDC}	end;{----------------------------------------------------------------------------}{$IFC NOT CARBON}	function myGetControlRect(theControl: ControlHandle): Rect;	begin		myGetControlRect := theControl^^.contrlRect;	end;{$ELSEC}	function myGetControlRect(theControl: ControlHandle): Rect;		var			myRect: Rect;			myRectPtr: RectPtr;	begin		myRectPtr := GetControlBounds(theControl, myRect);		myGetControlRect := myRect;	end;{$ENDC}{----------------------------------------------------------------------------}{$IFC NOT CARBON}	procedure myPortCopyBits(theSrcPort: GrafPtr; theDestPort: GrafPtr; var theSrcRect: Rect; var theDestRect: Rect; mode: integer; maskRgn: RgnHandle);	begin		CopyBits(GrafPtr(theSrcPort)^.portBits, GrafPtr(theDestPort)^.portBits, theSrcRect, theDestRect, mode, maskRgn);	end;{$ELSEC}	procedure myPortCopyBits(theSrcPort: GrafPtr; theDestPort: GrafPtr; var theSrcRect: Rect; var theDestRect: Rect; mode: integer; maskRgn: RgnHandle);	begin		CopyBits(BitMapPtr(GetPortPixMap(theSrcPort)^)^, BitMapPtr(GetPortPixMap(theDestPort)^)^, theSrcRect, theDestRect, mode, maskRgn);	end;{$ENDC}{----------------------------------------------------------------------------}{$IFC NOT CARBON}	function QDdkGray: Pattern;	begin		QDdkGray := qd.dkGray;	end;{$ELSEC}	function QDdkGray: Pattern;		var			myPat: Pattern;			myPatPtr: PatternPtr;	begin		myPatPtr := GetQDGlobalsDarkGray(myPat);		QDdkGray := myPat;	end;{$ENDC}{----------------------------------------------------------------------------}{$IFC NOT CARBON}	function QDltGray: Pattern;	begin		QDltGray := qd.ltGray;	end;{$ELSEC}	function QDltGray: Pattern;		var			myPat: Pattern;			myPatPtr: PatternPtr;	begin		myPatPtr := GetQDGlobalsLightGray(myPat);		QDltGray := myPat;	end;{$ENDC}{----------------------------------------------------------------------------}{$IFC NOT CARBON}	function QDGray: Pattern;	begin		QDGray := qd.gray;	end;{$ELSEC}	function QDGray: Pattern;		var			myPat: Pattern;			myPatPtr: PatternPtr;	begin		myPatPtr := GetQDGlobalsGray(myPat);		QDGray := myPat;	end;{$ENDC}{----------------------------------------------------------------------------}{$IFC NOT CARBON}	function QDWhite: Pattern;	begin		QDWhite := qd.white;	end;{$ELSEC}	function QDWhite: Pattern;		var			myPat: Pattern;			myPatPtr: PatternPtr;	begin		myPatPtr := GetQDGlobalsWhite(myPat);		QDWhite := myPat;	end;{$ENDC}{----------------------------------------------------------------------------}{$IFC NOT CARBON}	function QDBlack: Pattern;	begin		QDBlack := qd.black;	end;{$ELSEC}	function QDBlack: Pattern;		var			myPat: Pattern;			myPatPtr: PatternPtr;	begin		myPatPtr := GetQDGlobalsBlack(myPat);		QDBlack := myPat;	end;{$ENDC}{----------------------------------------------------------------------------}{----------------------------------------------------------------------------}{$IFC NOT CARBON}	procedure myEnableItem(theMenu: MenuHandle; theItem: integer);	begin		EnableItem(theMenu, theItem);	end;{$ELSEC}	procedure myEnableItem(theMenu: MenuHandle; theItem: integer);	begin		EnableMenuItem(theMenu, theItem);	end;{$ENDC}	{----------------------------------------------------------------------------}	procedure myDisableItem(theMenu: MenuHandle; theItem: integer);	begin{$IFC NOT CARBON}		DisableItem(theMenu, theItem);{$ELSEC}		DisableMenuItem(theMenu, theItem);{$ENDC}	end;{----------------------------------------------------------------------------}	function myCountMenuItems(theMenu: MenuHandle):integer;	begin{$IFC NOT CARBON}		myCountMenuItems := CountMItems(theMenu);{$ELSEC}		myCountMenuItems := CountMenuItems(theMenu);{$ENDC}	end;{----------------------------------------------------------------------------}	procedure myCheckMenuItem(theMenu: MenuHandle; theItem: integer; checked: boolean);	begin{$IFC NOT CARBON}		CheckItem(theMenu, theItem, checked);{$ELSEC}		CheckMenuItem(theMenu, theItem, checked);{$ENDC}	end;{----------------------------------------------------------------------------}	{$IFC NOT CARBON}	procedure genericGetPort(var theWindow: WindowPtr);	begin		GetPort(theWindow);	end;{$ELSEC}	procedure genericGetPort(var theWindow: WindowPtr);		var			myPort: CGrafPtr;	begin		GetPort(GrafPtr(myPort));		theWindow := GetWindowFromPort(myPort);	end;{$ENDC}{----------------------------------------------------------------------------}{$IFC NOT TARGET_CARBON}	procedure genericSetPort(theWindow: WindowPtr);	begin		SetPort(theWindow);	end;{$ELSEC}	procedure genericSetPort(theWindow: WindowPtr);	begin		SetPortWindowPort(theWindow);	end;{$ENDC}{----------------------------------------------------------------------------}	function ScreenBoundsRect: rect;{$IFC NOT CARBON}	begin		ScreenBoundsRect := qd.screenBits.bounds;	end;{$ELSEC}		var			myBitMap: BitMap;			myBitMapPtr: BitMapPtr;	begin		myBitMapPtr := GetQDGlobalsScreenBits(myBitMap);		ScreenBoundsRect := myBitMap.bounds;	end;{$ENDC}{----------------------------------------------------------------------------}{$IFC NOT CARBON}	function QDThePort: GrafPtr;	begin		QDThePort := qd.thePort;	end;{$ELSEC}	function QDThePort: CGrafPtr;	begin		QDThePort := GetQDGlobalsThePort;	end;{$ENDC}{----------------------------------------------------------------------------}	function QDThePortTextFont: integer;	begin{$IFC NOT CARBON}		QDThePortTextFont := qd.thePort^.txFont;{$ELSEC}		QDThePortTextFont := GetPortTextFont(GetQDGlobalsThePort);{$ENDC}	end;{----------------------------------------------------------------------------}	function QDThePortTextSize: integer;	begin{$IFC NOT CARBON}		QDThePortTextSize := qd.thePort^.txSize;{$ELSEC}		QDThePortTextSize := GetPortTextSize(GetQDGlobalsThePort);{$ENDC}	end;{----------------------------------------------------------------------------}	function QDThePortTextFace: style;	begin{$IFC NOT CARBON}		QDThePortTextFace := qd.thePort^.txFace;{$ELSEC}		QDThePortTextFace := Style(GetPortTextFace(GetQDGlobalsThePort));{$ENDC}	end;{----------------------------------------------------------------------------}	procedure setPortTextFont(theWindow: WindowPtr; theFont: integer);	var thePort: WindowPtr;	begin		genericGetPort(thePort);		genericSetPort(theWindow);		TextFont(theFont);		genericSetPort(thePort);	end;{----------------------------------------------------------------------------}	procedure setPortTextSize(theWindow: WindowPtr; theSize: integer);	var thePort: WindowPtr;	begin		genericGetPort(thePort);		genericSetPort(theWindow);		TextSize(theSize);		genericSetPort(thePort);	end;{----------------------------------------------------------------------------}	procedure SetCursorToArrow;{$IFC NOT CARBON}	begin		SetCursor(qd.arrow);	end;{$ELSEC}	var theArrow: Cursor;	begin		SetQDGlobalsArrow(theArrow);		SetCursor(theArrow);	end;{$ENDC}{----------------------------------------------------------------------------}	procedure FillBlackRect(box: rect);	begin		FillRect(box,QDBlack);	end;{----------------------------------------------------------------------------}	procedure FillWhiteRect(box: rect);	begin		FillRect(box,QDWhite);	end;{----------------------------------------------------------------------------}	procedure InvalidateWindowRegion(theWindow: univ WindowPtr; region: RgnHandle; restorePort: boolean);{$IFC NOT CARBON}	var tPort: WindowPtr;	begin		if restorePort then			begin				GetPort(tPort);				SetPort(theWindow);			end;		InvalRgn(region);		if restorePort then			SetPort(tPort);	end;{$ELSEC}		var			os: OSStatus;	begin		os := InvalWindowRgn(theWindow,region);	end;{$ENDC}{----------------------------------------------------------------------------}	procedure InvalidateWindowRect(theWindow: univ WindowPtr; box: rect; restorePort: boolean);{$IFC NOT CARBON}	var tPort: WindowPtr;	begin		if restorePort then			begin				GetPort(tPort);				SetPort(theWindow);			end;		InvalRect(box);		if restorePort then			SetPort(tPort);	end;{$ELSEC}		var			os: OSStatus;	begin		os := InvalWindowRect(theWindow,box);	end;{$ENDC}{----------------------------------------------------------------------------}{$IFC NOT CARBON}	function myGetNextWindow(theWindow: WindowPtr): WindowPtr;	begin		myGetNextWindow := WindowPtr(WindowPeek(theWindow)^.nextWindow);	end;{$ELSEC}	function myGetNextWindow(theWindow: WindowPtr): WindowPtr;	begin		myGetNextWindow := GetNextWindow(theWindow);	end;{$ENDC}{----------------------------------------------------------------------------}{$IFC NOT CARBON}	function WindowPortRect(theWindow: WindowPtr): rect;	begin		WindowPortRect := theWindow^.portRect;	end;{$ELSEC}	function WindowPortRect(theWindow: univ WindowPtr): rect;		var			myRectPtr: RectPtr;			myRect: Rect;	begin		myRectPtr := GetPortBounds(CGrafPtr(theWindow), myRect);  // check coersion		WindowPortRect := myRect;	end;{$ENDC}{----------------------------------------------------------------------------}{$IFC NOT TARGET_CARBON}	function ArrowCursor: Cursor;	begin		ArrowCursor := qd.arrow;	end;{$ELSEC}	function ArrowCursor: Cursor;		var			myCursor: Cursor;	begin		ArrowCursor := GetQDGlobalsArrow(myCursor)^;	end;{$ENDC}{----------------------------------------------------------------------------}	procedure myDateString(dateTime: LONGINT; longFlag: ByteParameter; VAR result: Str255);	begin{$IFC NOT CARBON}		IUDateString(dateTime,longFlag,result);{$ELSEC}		DateString(dateTime, longFlag, result, nil);{$ENDC}	end;{----------------------------------------------------------------------------}	procedure myTimeString(dateTime: LONGINT; wantSeconds: Boolean; VAR result: Str255);	begin{$IFC NOT CARBON}		IUTimeString(dateTime,wantSeconds,result);{$ELSEC}		TimeString(dateTime, wantSeconds, result, nil);{$ENDC}	end;{----------------------------------------------------------------------------}	function MyNewUserItemUPP(theProc:Ptr): UniversalProcPtr;	begin{$IFC NOT CARBON}		MyNewUserItemUPP :=  NewRoutineDescriptor(theProc, uppUserItemProcInfo, GetCurrentISA);  {$ELSEC}		MyNewUserItemUPP := NewUserItemUPP(theProc); {$ENDC}	end;{----------------------------------------------------------------------------}	procedure MyDisposeUserItemUPP(UPP:UniversalProcPtr);	begin{$IFC NOT CARBON}		DisposeRoutineDescriptor(UPP);{$ELSEC}		DisposeUserItemUPP(UPP);{$ENDC}	end;{----------------------------------------------------------------------------}	function MyNewAEEventHandlerUPP(theProc:Ptr): UniversalProcPtr;	begin{$IFC NOT CARBON}		MyNewAEEventHandlerUPP :=  NewRoutineDescriptor(theProc, uppAEEventHandlerProcInfo, GetCurrentISA);{$ELSEC}		MyNewAEEventHandlerUPP := NewAEEventHandlerUPP(AEEventHandlerProcPtr(theProc)); {$ENDC}	end;{----------------------------------------------------------------------------}	procedure MyDisposeAEEventHandlerUPP(UPP:UniversalProcPtr);	begin{$IFC NOT CARBON}		DisposeRoutineDescriptor(UPP);{$ELSEC}		DisposeAEEventHandlerUPP(UPP);{$ENDC}	end;{----------------------------------------------------------------------------}	function MyNewControlActionUPP(theProc:Ptr): UniversalProcPtr;	begin{$IFC NOT CARBON}		MyNewControlActionUPP :=  NewRoutineDescriptor(theProc,uppControlActionProcInfo, GetCurrentISA);{$ELSEC}		MyNewControlActionUPP := NewControlActionUPP(theProc); {$ENDC}	end;{----------------------------------------------------------------------------}	procedure MyDisposeControlActionUPP(UPP:UniversalProcPtr);	begin{$IFC NOT CARBON}		DisposeRoutineDescriptor(UPP);{$ELSEC}		DisposeControlActionUPP(UPP);{$ENDC}	end;{----------------------------------------------------------------------------}	function MyNewGrowZoneUPP(theProc:Ptr): UniversalProcPtr;	begin{$IFC NOT CARBON}		MyNewGrowZoneUPP :=  NewRoutineDescriptor(theProc,uppGrowZoneProcInfo, GetCurrentISA);{$ELSEC}		MyNewGrowZoneUPP := NewGrowZoneUPP(theProc); {$ENDC}	end;{----------------------------------------------------------------------------}	procedure MyDisposeGrowZoneUPP(UPP:UniversalProcPtr);	begin{$IFC NOT CARBON}		DisposeRoutineDescriptor(UPP);{$ELSEC}		DisposeGrowZoneUPP(UPP);{$ENDC}	end;{----------------------------------------------------------------------------}	function MyNewDragGrayRgnUPP(theProc:Ptr): UniversalProcPtr;	begin{$IFC NOT CARBON}		MyNewDragGrayRgnUPP :=  NewRoutineDescriptor(theProc,uppDragGrayRgnProcInfo, GetCurrentISA);{$ELSEC}		MyNewDragGrayRgnUPP := NewDragGrayRgnUPP(theProc); {$ENDC}	end;{----------------------------------------------------------------------------}	procedure MyDisposeDragGrayRgnUPP(UPP:UniversalProcPtr);	begin{$IFC NOT CARBON}		DisposeRoutineDescriptor(UPP);{$ELSEC}		DisposeDragGrayRgnUPP(UPP);{$ENDC}	end;{ееееееееееее}{----------------------------------------------------------------------------}	function MyNewQDGetPicUPP(theProc:Ptr): UniversalProcPtr;	begin{$IFC NOT CARBON}		MyNewQDGetPicUPP :=  NewRoutineDescriptor(theProc,uppQDGetPicProcInfo, GetCurrentISA);{$ELSEC}		MyNewQDGetPicUPP := NewQDGetPicUPP(theProc); {$ENDC}	end;{----------------------------------------------------------------------------}	procedure MyDisposeQDGetPicUPP(UPP:UniversalProcPtr);	begin{$IFC NOT CARBON}		DisposeRoutineDescriptor(UPP);{$ELSEC}		DisposeQDGetPicUPP(UPP);{$ENDC}	end;{----------------------------------------------------------------------------}	function MyNewQDPutPicUPP(theProc:Ptr): UniversalProcPtr;	begin{$IFC NOT CARBON}		MyNewQDPutPicUPP :=  NewRoutineDescriptor(theProc,uppQDPutPicProcInfo, GetCurrentISA);{$ELSEC}		MyNewQDPutPicUPP := NewQDPutPicUPP(theProc); {$ENDC}	end;{----------------------------------------------------------------------------}	procedure MyDisposeQDPutPicUPP(UPP:UniversalProcPtr);	begin{$IFC NOT CARBON}		DisposeRoutineDescriptor(UPP);{$ELSEC}		DisposeQDPutPicUPP(UPP);{$ENDC}	end;	{----------------------------------------------------------------------------}	function MyNewModalFilterUPP(theProc:Ptr): UniversalProcPtr;	begin{$IFC NOT CARBON}		MyNewModalFilterUPP :=  NewRoutineDescriptor(theProc,uppModalFilterProcInfo, GetCurrentISA);{$ELSEC}		MyNewModalFilterUPP := NewModalFilterUPP(theProc); {$ENDC}	end;{----------------------------------------------------------------------------}	procedure MyDisposeModalFilterUPP(UPP:UniversalProcPtr);	begin{$IFC NOT CARBON}		DisposeRoutineDescriptor(UPP);{$ELSEC}		DisposeModalFilterUPP(UPP);{$ENDC}	end;{----------------------------------------------------------------------------}	function MyNewDlgHookYDUPP(theProc:Ptr): UniversalProcPtr;	begin{$IFC NOT CARBON}		MyNewDlgHookYDUPP :=  NewRoutineDescriptor(theProc,uppDlgHookYDProcInfo, GetCurrentISA);{$ELSEC}		MyNewDlgHookYDUPP := nil; {$ENDC}	end;{----------------------------------------------------------------------------}	procedure MyDisposeDlgHookYDUPP(UPP:UniversalProcPtr);	begin{$IFC NOT CARBON}		DisposeRoutineDescriptor(UPP);{$ELSEC}		//DisposeDlgHookYDUPP(UPP);{$ENDC}	end;{----------------------------------------------------------------------------}	function myIsControlVisible(theControl: ControlHandle): boolean;	begin{$IFC NOT CARBON}		myIsControlVisible := theControl^^.contrlVis = 255;{$ELSEC}		myIsControlVisible := IsControlVisible(theControl);{$ENDC}	end;end.