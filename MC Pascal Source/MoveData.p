unit MoveData;{ееееееееееееееееееееее}interface	uses		QuickDraw,  		Types, Events, QuickDrawText, OSUtils, TextUtils,Controls, Menus, Files,  Windows, 		Sound, Dialogs, TextEdit, Lists, ToolUtils, Memory, Fonts, Resources, Scrap, 		Globals, WindowUtil, GenUtil, StrUtil, BoxUtil, SetLibInterface, TaxonCHUtil,		CharUtil, MenuUtil, SymbolsNames, TreeUtil, Fill, SpreadUtil, Footnote, DrawSpread, 		RowColumn, StatesWindow, ScrollSpread, CopyPaste, ToolPalette, EditorUndo, MoveInfoRows, InfoWindowsMisc;		function MoveWillEraseCharacters (oldst, oldet, oldsc, oldec, st, et, sc, ec: integer): boolean;	function MoveCell (scrollfirst: boolean; var OldSelCell: Point): boolean;	procedure MoveOver (direction: integer);	procedure DoMoveCells (oldst, oldet, oldsc, oldec, st, et, sc, ec: integer);	function CheckDataPushed (var oldst, oldet, oldsc, oldec, sc, ec: integer): boolean;	procedure ShiftMolecularDataInTaxon(it: integer; amount: integer);		procedure MoveRows;	procedure MoveColumns;	procedure ShiftMolecularDataOnDelete;		const		pushPullMove = 0;		selectedBlockMove = 1;		unselectedBlockMove = 2;  		splitBlockMove = 3;				allBlocksOnSideMove = 4;		insertAllBlocksOnSideMove = 5;		splitMultiBlockMove = 6;				{ееееееееееееееееееееее}implementation {е$S MoveData}{----------------------------------------------------------------------------}	function MoveCell (scrollfirst: boolean; var OldSelCell: Point): boolean;	begin		CleanOldCell(OldselCell, OldselCell);		if poorentry then			begin				editorSelectionTopLeft := oldselcell;				editorSelectionBotRight := oldselcell;								MoveCell := false;				SetEWClip(noscroll);				genericSetPort(editorWindow);				SetClip(EWClip);				Exit(MoveCell);			end		else			MoveCell := true;		FixNewCell(editorSelectionTopLeft, editorSelectionTopLeft);		if scrollfirst then			ScrollToSelection(false,true);		SetUpCellEdit;	end;{----------------------------------------------------------------------------}	procedure MoveOverClip (inName: boolean; whichclip: integer);	begin		if not trackcell then			if inName then				SetEWClip(noscroll)			else				SetEWClip(justdata)		else			SetEWClip(whichclip);		SetClip(EWClip);	end;{----------------------------------------------------------------------------}	procedure MoveOver (direction: integer);		label			1, 2;		var			oldSelCell: point;			tselcell: integer;			tport: WindowPtr;{...........}	begin		genericGetPort(tport);		genericSetPort(editorWindow);		oldSelCell := editorSelectionTopLeft;		if direction = upA then			begin				if editorSelectionTopLeft.v > 1 then					begin						tselcell := editorSelectionTopLeft.v - 1;						if (tselcell < editorOrigin.v) and (trackcell or (editorSelectionTopLeft.h = 0)) then							begin								SetControlValueLong(editorVScroll, GetControlValueLong(editorVScroll) - 1);								ScrollEditor(true,nil,true);							end						else							MoveOverClip(editorSelectionTopLeft.h=0,vertscroll);						editorSelectionTopLeft.v := tselcell;						editorSelectionBotRight.v := tselcell;												if not MoveCell(false, oldselcell) then							Exit(MoveOver);					end				else					goto 1;			end		else if direction = downA then			begin				if (editorSelectionTopLeft.v > 0) and (editorSelectionTopLeft.v < editorTotalRows) then					begin						tselcell := editorSelectionTopLeft.v + 1;						if (tselcell > editorOrigin.v + editorRows - 1) and (trackcell or (editorSelectionTopLeft.h = 0)) then							begin								SetControlValueLong(editorVScroll, GetControlValueLong(editorVScroll) + 1);								ScrollEditor(true,nil,true);							end						else							MoveOverClip(editorSelectionTopLeft.h=0,vertscroll);						editorSelectionTopLeft.v := tselcell;						editorSelectionBotRight.v := tselcell;												if not MoveCell(false, oldselcell) then							Exit(MoveOver);					end				else					goto 1;			end		else if direction = rightA then			begin				if (editorSelectionTopLeft.h > 0) and (editorSelectionTopLeft.h < editorTotalColumns) then					begin						tselcell := editorSelectionTopLeft.h + 1;						if (tselcell > editorOrigin.h + editorColumns - 1) and (trackcell or (editorSelectionTopLeft.v = 0)) then							begin								SetControlValueLong(editorHScroll, GetControlValueLong(editorHScroll) + 1);								ScrollEditor(true,nil,true);							end						else							MoveOverClip(editorSelectionTopLeft.v=0,horscroll);						editorSelectionTopLeft.h := tselcell;						editorSelectionBotRight.h := tselcell;												if not MoveCell(false, oldselcell) then							Exit(MoveOver);					end				else					goto 1;			end		else if direction = leftA then			begin				if (editorSelectionTopLeft.h > 1) then					begin						tselcell := editorSelectionTopLeft.h - 1;						if (tselcell < editorOrigin.h) and (trackcell or (editorSelectionTopLeft.v = 0)) then							begin								SetControlValueLong(editorHScroll, GetControlValueLong(editorHScroll) - 1);								ScrollEditor(true,nil,true);							end						else							MoveOverClip(editorSelectionTopLeft.v=0,horscroll);						editorSelectionTopLeft.h := tselcell;						editorSelectionBotRight.h := tselcell;												if not MoveCell(false, oldselcell) then							Exit(MoveOver);					end				else					goto 1;			end;		if (editorSelectionTopLeft.h = -1) or (editorSelectionTopLeft.v = -1) then			begin				Beep;				Beep;			end;		goto 2;1:		Beep;2:		ClipRect(WindowPortRect(editorWindow));		DrawFootText(true, true);		genericSetPort(tport);	end;{----------------------------------------------------------------------------}	function MoveWillEraseCharacters (oldst, oldet, oldsc, oldec, st, et, sc, ec: integer): boolean;	label 1;		var			it, ic: integer;			badmove: boolean;	begin  {currently only built for }		badmove := false;		if sc < oldsc then			for it := st to et do				for ic := sc to oldsc -1 do					if not IsGapLike(it,ic,editorToolsTreatMissingAsGaps)  then						begin							badmove := true;							InstantInfo('Move will not be performed as it will erase data');							goto 1;						end;		if oldsc < sc then			for it := st to et do				for ic := oldec+1 to ec do					if not IsGapLike(it,ic,editorToolsTreatMissingAsGaps) then						begin							badmove := true;							InstantInfo('Move will not be performed as it will erase data');							goto 1;						end;1:		MoveWillEraseCharacters:= badmove;end;{----------------------------------------------------------------------------}	procedure DoMoveCells (oldst, oldet, oldsc, oldec, st, et, sc, ec: integer);		var			it, ic, taxmove, charmove, itstart,itend, icstart,icend: integer;			tsts, oldTSTS: LargestSetChars;	begin		if st <= 0 then			st := 1;		if oldst <= 0 then			oldst := 1;		taxmove := st - oldst;		if (oldet - oldst) <> (et - st) then			if st = 1 then {moving taxa off top}				taxmove := et - oldet;		charmove := sc - oldsc;		if (oldec - oldsc) <> (ec - sc) then			if sc = 1 then {moving chars off top}				charmove := ec - oldec;		datachanged := true;		if (taxmove >= 0) and (charmove >= 0) then   {moving taxa up, and char up}			begin				for it := et downto st do					for ic := ec downto sc do						if (it > 0) & (it <= numtaxa) & (ic > 0) & (ic <= numchars) then							begin								tsts := gettaxonstsLargestCase(it - taxmove, ic - charmove);								settaxonstsLargestOverwriteCase(it, ic, tsts);							end;			end		else if (taxmove >= 0) and (charmove < 0) then   {moving taxa up, and char down}			begin				for it := et downto st do					for ic := sc to ec do						if (it > 0) & (it <= numtaxa) & (ic > 0) & (ic <= numchars) then							begin								tsts := gettaxonstsLargestCase(it - taxmove, ic - charmove);								settaxonstsLargestOverwriteCase(it, ic, tsts);							end;			end		else if (taxmove < 0) and (charmove >= 0) then   {moving taxa down, and char up}			begin				for it := st to et do					for ic := ec downto sc do						if (it > 0) & (it <= numtaxa) & (ic > 0) & (ic <= numchars) then							begin								tsts := gettaxonstsLargestCase(it - taxmove, ic - charmove);								settaxonstsLargestOverwriteCase(it, ic, tsts);							end;			end		else if (taxmove < 0) and (charmove < 0) then   {moving taxa down, and char down}			begin				for it := st to et do					for ic := sc to ec do						if (it > 0) & (it <= numtaxa) & (ic > 0) & (ic <= numchars) then							begin								tsts := gettaxonstsLargestCase(it - taxmove, ic - charmove);								settaxonstsLargestOverwriteCase(it, ic, tsts);							end;			end;		if molecular then   {set what the oldcells will be replaced with}			oldtsts := [MSl, GAl]		else			oldtsts := [MSl];		for it := oldst to oldet do			for ic := oldsc to oldec do				if (it < st) or (ic < sc) or (it > et) or (ic > ec) then					settaxonstsLargestOverwriteCase(it, ic, oldtsts);							if oldst < st then itstart := oldst else itstart := st;		if oldet > et then itend := oldet else itend := et;		if oldsc < sc then icstart := oldsc else icstart := sc;		if oldec > ec then icend := oldec else icend := ec;		CheckRedrawFullCharactersInEditor(itstart,itend,icstart,icend,true);					InvalidateWindowRect(editorWindow,editorSelectionRect,false);	end;{----------------------------------------------------------------------------}	function CheckDataPushed (var oldst, oldet, oldsc, oldec, sc, ec: integer): boolean;		label			2;		var			tsts: LargestSetChars;			dataOff: boolean;			it, ic: integer;			newChars, oldChars, expandChars: integer;			offsc, offec: integer;			charDiff: integer;			charOffStart, charOffEnd: boolean;	begin		CheckDataPushed := true;		dataOff := false;		expandChars := 0;		newChars := ec - sc + 1;		oldChars := oldec - oldsc + 1;		if (newChars < oldChars) then			begin				charOffEnd := false;				charOffstart := false;				offec := oldec;				offsc := oldsc;				if newChars < oldChars then					begin						charDiff := oldChars - newChars;						if ec = numchars then {pushed off end}							begin								charOffEnd := true;								offec := oldec;								offsc := oldec - charDiff + 1;							end						else if sc = 1 then							begin								charOffstart := true;								offsc := oldsc;								offec := oldsc + charDiff - 1;							end;					end;				if (charOffStart or charOffEnd) then					begin						if charOffEnd then							begin								for ic := offec downto offsc do									for it := oldst to oldet do										begin											tsts := getTaxonStsLargest(it, ic);											if not (tsts <= [MSl, GAl]) then												begin													expandChars := charDiff - (offec - ic);													goto 2;												end;										end;							end						else if charOffStart then							begin								for ic := offsc to offec do									for it := oldst to oldet do										begin											tsts := getTaxonStsLargest(it, ic);											if not (tsts <= [MSl, GAl]) then												begin													expandChars := charDiff - (ic - offsc);													goto 2;												end;										end;							end;2:						if (expandChars > 0) then							begin								if charOffEnd then {pushed off end}									begin										AddNewCharacters(expandChars, molecular);										lastChangeInEditor := lastChangeInsertCharAndCellBlock;										ec := numchars;									end								else if charOffStart then									begin										InsertNewCharacters(expandChars, 1, molecular);										lastChangeInEditor := lastChangeInsertCharAndCellBlock;										ec := sc + newChars + expandChars - 1;										oldsc := oldsc + expandChars;										oldec := oldec + expandChars;									end;								InvalidateWindow(editorWindow, true);								if not editorTransposed then									begin										editorSelectionTopLeft.h := sc;										editorSelectionBotRight.h := ec;									end								else									begin										editorSelectionTopLeft.v := sc;										editorSelectionBotRight.v := ec;									end;															end;					end;			end;		if not DataOff then			begin				genericSetPort(editorWindow);				SetEWClip(noscroll);				SetClip(EWClip);				EraseRect(editorSelectionRect);				InvalidateWindowRect(editorWindow,editorSelectionRect,false);			end;	end;{----------------------------------------------------------------------------}{	procedure GetContiguousBlock (isLower: boolean; it,icOriginal: integer; var theStart, theEnd: integer);	var ic: integer;	begin		if isLower then			begin				ic := icOriginal-1;				repeat 					ic := ic-1;				until (ic < 1) | isGap (it,ic);				if (ic<1) then ic:=1 else ic := ic+1;				theStart := ic;				theEnd := icOriginal;			end		else			begin				ic := icOriginal;				repeat 					ic := ic+1;				until (ic >numchars) | isGap (it,ic);				if (ic> numchars) then ic:=numchars else ic := ic-1;				theStart := icOriginal;				theEnd := ic;			end;	end;}{----------------------------------------------------------------------------}{	procedure PushPullAlignment (datacell: point; Position: integer; startpt: point);	var it,ic: integer;		icLowerStart, icLowerEnd, icUpperStart, icUpperEnd: integer;		pt: point;	begin		if not editorTransposed then			begin				it := datacell.v;				ic := datacell.h;			end		else			begin				ic := datacell.v;				it := datacell.h;			end;		if ic > 1 then 			if IsGap(it,ic-1) then				begin 					icLowerStart:= 0;					icLowerEnd := 0;				end			else 				GetContiguousBlock(true, it, ic, icLowerStart, icLowerEnd)		else			begin 				icLowerStart:= 0;				icLowerEnd := 0;			end;					if ic < numchars then 			if IsGap(it,ic) then				begin 					icUpperStart:= 0;					icUpperEnd := 0;				end			else 				GetContiguousBlock(false, it, ic, icUpperStart, icUpperEnd)		else			begin 				icUpperStart:= 0;				icUpperEnd := 0;			end;					if not editorTransposed then			begin				while StillDown do					begin						GetMouse(pt);					end;			end;	end;}{----------------------------------------------------------------------------}	procedure ShiftMolecularDataInTaxon(it: integer; amount: integer);	begin		if (amount > 0) & CheckIfAllGaps(it,it,numChars-amount+1,numchars,editorToolsTreatMissingAsGaps) then  {moving to the right}			DoMoveCells(it, it, 1, numchars-amount, it, it, amount+1, numchars)		else if (amount < 0) & CheckIfAllGaps(it,it,1,-amount,editorToolsTreatMissingAsGaps) then  {moving to the right}			DoMoveCells(it, it, -amount+1, numChars, it, it, 1, numchars+amount)	end;{----------------------------------------------------------------------------}	procedure ShiftMolecularDataOnDelete;	var it, st,et,sc,ec,oldst,oldet,oldsc,oldec, charnums: integer;	begin		CalcSelectedTaxaCharacters(st, et, sc, ec, false);		if ec < numchars then			begin				oldst := st;				oldet := et;				charnums := ec-sc+1;				oldsc := ec+1;				oldec := numchars;				ec := numchars-charnums;				QuickDeselectEditor;				DoMoveCells(oldst, oldet, oldsc, oldec, st, et, sc, ec);				for it := st to et do					InvalidateTaxChar(it,0, false);			end;			end;{----------------------------------------------------------------------------}	procedure MoveColumns;	var wh, drop: point;		left, right, top, bottom, xxx: integer;		B: rect;	begin		repeat			AutoHorScroll(false, true, false);		until not button;		GetMouse(wh);		if (wh.h > editorFirstColumnLeft) & (wh.h < editorBoundaryRect.right)  then			begin				CellHor(editorSelectionTopLeft.h, left, xxx, true);				CellHor(editorSelectionBotRight.h, xxx, right, true);				if wh.h > right then					wh.h := wh.h - editorColumnWidth div 2				else if wh.h < left then					wh.h := wh.h + editorColumnWidth div 2;				drop := FindCell(wh, true, false);				if not editorTransposed and (drop.h > numchars) then					drop.h := numchars				else if editorTransposed and (drop.h > numtaxa) then					drop.h := numtaxa				else if (drop.h < 1) then					drop.h := 1;				if ((drop.h < editorSelectionTopLeft.h) | (drop.h > editorSelectionBotRight.h)) {& WarnCantUndo} then					begin						SetCursor(clockCursor);						if not editorTransposed then							begin								SetUpBeforeRowMove(charinfo);								if  MoveCharacters(editorSelectionTopLeft.h, editorSelectionBotRight.h, drop.h) then									CleanUpAfterRowMove(charinfo,false)								else									begin										InvalidateAllWindowsMarkedUnupdatable;										Exit(MoveColumns);									end;							end						else							begin								SetUpBeforeRowMove(taxinfo);								MoveTaxa(editorSelectionTopLeft.h, editorSelectionBotRight.h, drop.h);								CleanUpAfterRowMove(taxinfo,false);							end;						CellHor(drop.h, left, right, true);						if editorTransposed & (matchcharon | (editorColorCellsMode=editorColorCellsMatchFirst)) & ((editorSelectionTopLeft.h = 1) | (drop.h <= 1)) then							B := WindowPortRect(editorWindow)						else							begin								B := editorSelectionRect;								if drop.h < editorSelectionTopLeft.h then									B.left := left								else									B.right := right;								if B.left < editorFirstColumnLeft then									B.left := editorFirstColumnLeft;							end;						EraseRect(B);						InvalidateWindowRect(editorWindow,B,false);						CalcEditorMatrixRect;						if drop.h > editorSelectionTopLeft.h then							begin								editorSelectionTopLeft.h := drop.h - (editorSelectionBotRight.h - editorSelectionTopLeft.h);								editorSelectionBotRight.h := drop.h;							end						else							begin								editorSelectionBotRight.h := drop.h + editorSelectionBotRight.h - editorSelectionTopLeft.h;								editorSelectionTopLeft.h := drop.h;							end;						CalcEditorSelectionRect(editorSelectionTopLeft, editorSelectionBotRight);					end;			end;	end;{----------------------------------------------------------------------------}	procedure MoveRows;	var wh, drop: point;		left, right, top, bottom, xxx: integer;		B: rect;	begin		repeat			AutoVertScroll(false, true, false);		until not button;		GetMouse(wh);		if (wh.v > editorFirstRowTop) & (wh.v < editorBoundaryRect.bottom)  then			begin				CellVer(editorSelectionTopLeft.v, top, xxx, true);				CellVer(editorSelectionBotRight.v, xxx, bottom, true);				if wh.v > bottom then					wh.v := wh.v - editorLineWidth div 2				else if wh.v < top then					wh.v := wh.v + editorLineWidth div 2;				drop := FindCell(wh, true, false);				if not editorTransposed and (drop.v > numtaxa) then					drop.v := numtaxa				else if editorTransposed and (drop.v > numchars) then					drop.v := numchars				else if (drop.v < 1) then					drop.v := 1;				if ((drop.v < editorSelectionTopLeft.v) | (drop.v > editorSelectionBotRight.v)) {& WarnCantUndo } then					begin						if not editorTransposed then							begin								SetUpBeforeRowMove(taxinfo);								MoveTaxa(editorSelectionTopLeft.v, editorSelectionBotRight.v, drop.v);								CleanUpAfterRowMove(taxinfo,false);							end						else							begin								SetUpBeforeRowMove(charinfo);								if  MoveCharacters(editorSelectionTopLeft.v, editorSelectionBotRight.v, drop.v) then									CleanUpAfterRowMove(charinfo,false)								else									begin										InvalidateAllWindowsMarkedUnupdatable;										Exit(MoveRows);									end;							end;						CellVer(drop.v, top, bottom, true);						if not editorTransposed & (matchcharon | (editorColorCellsMode=editorColorCellsMatchFirst)) & ((editorSelectionTopLeft.v = 1) | (drop.v <= 1)) then							B := WindowPortRect(editorWindow)						else							begin								B := editorSelectionRect;								if drop.v < editorSelectionTopLeft.v then									B.top := top								else									B.bottom := bottom;								if B.top < editorFirstRowTop then									B.top := editorFirstRowTop;							end;						EraseRect(B);						InvalidateWindowRect(editorWindow,B,false);						CalcEditorMatrixRect;						if drop.v > editorSelectionTopLeft.v then							begin								editorSelectionTopLeft.v := drop.v - (editorSelectionBotRight.v - editorSelectionTopLeft.v);								editorSelectionBotRight.v := drop.v;							end						else							begin								editorSelectionBotRight.v := drop.v + editorSelectionBotRight.v - editorSelectionTopLeft.v;								editorSelectionTopLeft.v := drop.v;							end;						CalcEditorSelectionRect(editorSelectionTopLeft, editorSelectionBotRight);					end;			end;	end;end.