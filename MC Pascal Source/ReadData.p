unit ReadData;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, 		Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, TaxonCHUtil, TypeUtil, 		BoxUtil, CharUtil, StatesWindow, SymbolsNames, Fonts, Thermos, ReadWriteUtil, ReadUtil, InfoWindows, 		ImpForeignFiles, CHUNK, ReadTreeFile, SpreadUtil, Windows, ImpOldMacClade, ReadMisc, 		ReadDataBlock, ReadMatrix, ReadAssumpBlock, ReadWriteMacCladeBlock, NexusBlocks, PrintingUtil;	procedure ReadFile;	var		fileformat: integer;{еееееееееееееееееееееее}implementation {е$S ReadData}{-----------------------------------------------------------------------------}	var		impfiletype: integer;{-----------------------------------------------------------------------------}	procedure NonNexusUser (theDialog: DialogPtr; itemNo: Integer);		var			box: rect;			ds: str255;			oldState: SignedByte;	begin		box := GetDLOGITemBox(theDialog, 4);		MoveTo(box.left, box.top - 4);		LockHandle(filename, oldState);		DrawString(fileName^^);		ResetHandle(filename, oldState);		box := GetDLOGITemBox(theDialog, 3);		GetMenuItemText(ImpFileMHdl, impfiletype, ds);		DrawPopUpRect(box, ds);		FrameButton(theDialog, 1);	end;{-----------------------------------------------------------------------------}	procedure PopUpImpM (theDialog: DialogPtr);		var			menucode: longint;			spot: point;			box: rect;	begin		box := GetDLOGITemBox(theDialog, 3);{$IFC READGENBANK}		//if OptionDown then		//	SetMenuItemText(ImpFileMHdl, 13, 'GenBank DNA')		//else		//	SetMenuItemText(ImpFileMHdl, 13, 'NBRF (DNA,RNA)');{$ENDC}		spot.v := box.top;		spot.h := box.left;		LocalToGlobal(spot);		menucode := PopUpMenuSelect(ImpFileMHdl, spot.v, spot.h, impfiletype);		if LowWord(menucode) > 0 then			impfiletype := LowWord(menucode);		NonNexusUser(theDialog, 1);	end;{-----------------------------------------------------------------------------}	procedure ReadNonNexus (var oldWindow: WindowPtr; command: str255; var nonNexus: boolean);	const 		impNBRFDNA=1;		impNBRFProtein = 2;		impClustalDNA = 3;		impClustalProtein = 4;		impGCG = 5;		impOldMacClade = 6;		impNEXUS = 7;		impNONA = 8;		impHennig86 = 9;		impPhylip33 = 10;		impPhylip33DNA = 11;		impPhylip33Protein = 12;		impPhylip34 = 13;		impPhylip34DNA = 14;		impPhylip34Protein = 15;		impGenbankDNA = 16;		impGenBankProt = 17;		impFastADNA = 18;		impFastAProt = 19;		impSimple = 20;		impSimpleDNA=21;		impSimpleProtein = 22;		impTaxonNamesOnly = 23;	var			theDialog: DialogPtr;			tempP: WindowPtr;			j: integer;			tempH: Handle;			box: rect;			localItemHit: integer;			nextCommand: str255;UserItemUProcP: UniversalProcPtr;	begin		ImpFileMHdl := GetMenu(impFileMenu);		InsertMenu(ImpFileMHdl, -1);		impfiletype := 1;		if pos('NEXUS',command)> 0 then			impFileType := impNEXUS		else if (pos('>',command)> 0) then			begin				nextCommand := MakeCaps(GetFileToken(maxtok));				if (pos('P1',nextCommand)>0) | (pos('F1',nextCommand)>0)  then					impFileType := impNBRFProtein				else					impFileType := impNBRFDNA;			end		else if (pos('LOCUS',command)> 0) then			impFileType := impGenBankDNA		else if (pos('CLUSTAL',command)> 0) then			impFileType := impClustalDNA		else if (pos('XREAD',command)> 0) | (pos('DREAD',command)> 0) then			impFileType := impNONA		else if (pos('PILEUP',command)> 0) |(pos('!!NA',command)> 0) | (pos('!!AA',command)> 0) then			impFileType := impGCG;		StartDLOG(363, theDialog, tempP);		box := GetDLOGITemBox(theDialog, 3);UserItemUProcP := MyNewUserItemUPP(@NonNexususer);  tempH := Handle(UserItemUProcP);		SetDialogItem(theDialog, 3, UserItem, tempH, box);		myShowDialog(theDialog);		Beep;		repeat			ModalDialog(nil, localItemHit);			if localItemHit = 3 then				PopUpImpM(theDialog);		until localItemHit in [1, 2];MyDisposeUserItemUPP(UserItemUProcP);		EndDLOG(theDialog, tempP);		if localItemHit = 2 then			errorflag := true		else			begin				DrawDialog(iothermo);				SetCursor(clockCursor);				if impFileType <> impNEXUS then					AddRemainingNativeNexusBlocks;				case impfiletype of					impClustalDNA:	{clustal DNA}						begin														SetDataFormat(DNA, false);							ReadClustal;							fileformat := clustal;							onOpenFileSetAsPlainMolecularStyle := true;						end;					impClustalProtein:	{clustal protein}						begin							SetDataFormat(protein, false);							ReadClustal;							fileformat := clustal;							onOpenFileSetAsPlainMolecularStyle := true;						end;					impGCG:	{GCG/MSF}						begin							ReadGCG(command);							fileformat := gcg;							onOpenFileSetAsPlainMolecularStyle := true;						end;					impNBRFDNA:   {NBRF input DNA}						begin							SetDataFormat(DNA, false);							ReadForeignSequenceFile(nbrf,false);							{ReadNBRF(command);}							fileformat := NBRF;							onOpenFileSetAsPlainMolecularStyle := true;						end;					impNBRFProtein:   {NBRF input protein}						begin							SetDataFormat(protein, false);							ReadForeignSequenceFile(nbrf,false);							{ReadNBRF(command);}							fileformat := NBRF;							onOpenFileSetAsPlainMolecularStyle := true;						end;					impOldMacClade:	{old macclade file}						begin							ReadOldFile(oldWindow);{fileformat := oldmacclade;}						end;					impNEXUS:   {new macclade files}						begin							nonNexus := false;							Exit(ReadNonNexus);						end;					impNona: 	{NONA}						begin							ReadHennigNonaData(command, true);							fileformat := nona;						end;					impHennig86: 	{Hennig86}						begin							ReadHennigNonaData(command, false);							fileformat := hennig;						end;					impPhylip33: 	{PHYLIP}						begin							phylipversion := 33;							SetDataFormat(standard, true);							ReadPhylipData(command);							fileformat := phylip;						end;					impPhylip33DNA: 	{PHYLIP DNA}						begin							phylipversion := 33;							SetDataFormat(DNA, false);							ReadPhylipData(command);							fileformat := phylip;							onOpenFileSetAsPlainMolecularStyle := true;						end;					impPhylip33Protein: 	{PHYLIP protein}						begin							phylipversion := 33;							SetDataFormat(protein, false);							ReadPhylipData(command);							fileformat := phylip;							onOpenFileSetAsPlainMolecularStyle := true;						end;					impPhylip34: {PHYLIP 3.4}						begin							phylipversion := 34;							SetDataFormat(standard, true);							ReadPhylipData(command);							fileformat := phylip;						end;					impPhylip34DNA:  {PHYLIP 3.4 DNA/RNA}						begin							phylipversion := 34;							SetDataFormat(DNA, false);							ReadPhylipData(command);							fileformat := phylip;							onOpenFileSetAsPlainMolecularStyle := true;						end;					impPhylip34Protein:   {PHYLIP 3.4 Protein}						begin							phylipversion := 34;							SetDataFormat(protein, false);							ReadPhylipData(command);							fileformat := phylip;							onOpenFileSetAsPlainMolecularStyle := true;						end;					impSimple: 	{Tab-delimited text file}						begin							SetDataFormat(standard32, true);							ReadTabText(command);						end;					impSimpleDNA: 	{Tab-delimited DNA file}						begin							SetDataFormat(DNA, false);							ReadTabText(command);							onOpenFileSetAsPlainMolecularStyle := true;						end;					impSimpleProtein: 	{Tab-delimited protein file}						begin							SetDataFormat(protein, false);							ReadTabText(command);							onOpenFileSetAsPlainMolecularStyle := true;						end;{$IFC READGENBANK}					impGenbankDNA:						begin							SetDataFormat(DNA, false);							ReadForeignSequenceFile(genbank,false);							fileformat := genbank;							onOpenFileSetAsPlainMolecularStyle := true;						end;					impGenbankProt:						begin							SetDataFormat(protein, false);							ReadForeignSequenceFile(genbank,false);							fileformat := genbank;							onOpenFileSetAsPlainMolecularStyle := true;						end;{$ENDC}					impFastADNA:						begin							SetDataFormat(DNA, false);							ReadForeignSequenceFile(fasta,false);							fileformat := fastA;							onOpenFileSetAsPlainMolecularStyle := true;						end;					impFastAProt:						begin							SetDataFormat(protein, false);							ReadForeignSequenceFile(fasta,false);							fileformat := fastA;							onOpenFileSetAsPlainMolecularStyle := true;						end;					impTaxonNamesOnly:						begin							ReadTaxonNamesOnly;						end;					otherwise						;				end;			end;		for j := 1 to numTextWindows do			begin				HUnlock(textWindowInfo[j]^.H);				SetHandleSize(textWindowInfo[j]^.H, 0);  {0's storage to free up space}			end;		if not errorflag then			UpdateCurTypes;   {v3.04: }		DeleteMenu(impFileMenu);	end;{----------------------------------------------------------------------------}	procedure CheckWhereToGo (var dotree, doedit: boolean);	begin		if optiondown then			begin				dotree := false;				doedit := true;			end		else if commanddown then			begin				dotree := true;				doedit := false;			end;	end;{----------------------------------------------------------------------------}	procedure ReadDataCharBlockEnd (theBlock, blockdatatype: integer; var dotree, doedit: boolean);	begin		CheckWhereToGo(dotree, doedit);		if blockdatatype = continuous then			ReadContinuousMatrix(theBlock = charactersBlock)		else if interleave and editorTransposed then			begin				InstantError(282);				errorflag := true;			end		else if (interleave or (editorTransposed)) and not somechars then			begin				InstantError(283);				errorflag := true;			end		else			begin				FileMatrixToMem;				SetCursID(flower);				if errorflag then					Exit(ReadDataCharBlockEnd);				CheckWhereToGo(dotree, doedit);				ReCalcMaxstAndStates(1,numchars);			end;		if FindEndOfBlock(theBlock,true) then			Skipper(punctuation, true);	end;{----------------------------------------------------------------------------}	procedure SetNexusDefaults;{include in here defaults of all options that defined as defaults in NEXUS format.}{As they are defined as defaults, the moment MacClade starts reading a NEXUS file,}{it should set these to defaults, irrespective of any current settings or preferences.}	begin		editorTransposed := false;		datatype := standard;		matchcharon := false;		symbols := '01';		interleave := false;		gap := '-';   {default for MC}		missing := '?';		deftype := unordered;{default genetic code???}	end;{-----------------------------------------------------------------------------}	procedure SkipToEndOfBlock(var justBeforeBlockEnd: longint);		var			ds: str255;			found: boolean;	begin		repeat			justBeforeBlockEnd:= fpos;			ds := MakeCaps(GetFileToken(maxtok));			found := EndOfBlock(ds);			Skipper([';'],true);		until found or (fpos >= mcFileLength) or errorflag;	end;{-----------------------------------------------------------------------------}	procedure ReadInForeignNexusBlock(var currentNexusBlock: NexusBlockPtr; originalBlockName: str255);	var		startForeignBlockpos,endForeignBlockPos: longint;		theNexusBlock: NexusBlockPtr;	begin			AddForeignNexusBlock(originalBlockName,currentNexusBlock);		next := anyNextChar;		endForeignBlockPos:= startBlockPos;		startForeignBlockPos := startBlockPos;		while next = '[' do			begin				SkipComment;				next := anyNextChar;			end;		SkipToEndOfBlock(endForeignBlockPos);		FilePiecetoH(startForeignBlockPos, endForeignBlockPos, currentNexusBlock^.H);		DrawDialog(iothermo);	end;{----------------------------------------------------------------------------}	function ValidNativeBlockLinks(blockType: integer;var firstCommand, title, linkText: str255): boolean;	var upperCaseCommand, command, ds1,ds2: str255;		linkBlockType: integer;		linkBlock: NexusBlockPtr;		oldState: SignedByte;		badLink: boolean;	begin		ValidNativeBlockLinks := true;		if blockType in [taxaBlock, dataBlock,treesDataBlock,charactersBlock, continuousBlock] then			begin				commreadon := true;  				if blockType=treesDataBlock then					curTextH := textWindowInfo[AboutTreesText]^.H				else					curTextH := textWindowInfo[AboutFileText]^.H;			end;		command := GetFileToken(maxtok);		upperCaseCommand := MakeCaps(command);		title := '';		linkText := '';		badLink := false;		while (upperCaseCommand='TITLE') | (upperCaseCommand='LINK') do			begin				if (upperCaseCommand='TITLE') then  {read title and store it}					begin						ds1 := GetFileToken(255);  						UnderlineToBlanks(ds1);						if (ds1<>';') then							Skipper([';'], true);						title := ds1;						command := GetFileToken(maxtok);						upperCaseCommand := MakeCaps(command);					end				else if (upperCaseCommand='LINK') then					begin						repeat							ds1 := GetFileToken(255);  {should be name of block}							if (ds1=';') then leave;							ds2 := GetFileToken(255);  {=}							if (ds2=';') then leave;							ds2 := GetFileToken(255);  {title of linked block}							if (ds2=';') then leave;							linkText := concat(linkText,ds1,'=',ds2,' ');							if not badLink then								begin									linkBlockType := BlockTypeFromNativeBlockName(ds1);									if (linkBlockType<> foreignBlock) then										begin											linkBlock := NexusBlockFromBlockType(linkBlockType);											if (linkBlock = nil) | not StringsEqual(@ds2,@linkBlock^.title,maxtok) then												badLink := true;										end								end;						until (ds2 = ';') | errorFlag | (fpos>= mcFileLength);						command := GetFileToken(maxtok);						upperCaseCommand := MakeCaps(command);					end;			end;		firstCommand := command;		if badLink then			begin				InstantErrorPlus(428,NativeBlockName(blockType));				commreadon := false;				UnlockHandle(curTextH, oldstate);				SetHandleSize(curTextH, 0);				ResetHandle(curTextH, oldstate);			end;		ValidNativeBlockLinks := not badLink;	end;{----------------------------------------------------------------------------}	procedure InitNexusFile;	var oldState: SignedByte;	begin		SetNEXUSDefaults;		LockHandle(filename, oldstate);		fileLastModified := FSpLastModified(FDI^[dataFileFDI].fs); 		ResetHandle(filename, oldstate);		ShowErrors('');	end;{----------------------------------------------------------------------------}	procedure ReadFile;		label			2, 3, 4;		var			endpos, oldpos, startpos, sp, dL: LONGINT;			block, command, title, linkText: Str255;			whichText: integer;			oldstate: SignedByte;			it, ic, k: integer;			theblock: integer;			theDialog: DialogPtr;			tempP: WindowPtr;			taxaDefinedInBlock, successfulread, db, nonnexus: boolean;			c: char;			dotree, doedit: boolean;			blockdatatype: integer;			nodata: boolean;			lastPAUPBlock: integer;			theNexusBlock, currentNexusBlock: NexusBlockPtr;			originalBlockName, firstCommand: str255;			discreteCharacterDataRead: boolean;			np: set of char;{..................}	begin{    DebugStr('start read file; log logfile2;');}		discreteCharacterDataRead := false;		command := '';		userCanceledRead := false;		if useOldPunct then			punctuation := punct304;  {v3.05, v3.06}		currentNexusBlock:= nil;		minMaxContinuous := false;		treeWindowPositionRead := false;		CharLegendPositionRead := false;		TreeLegendPositionRead := false;		lastPAUPBlock:= 0;		startBlockPos := 0;		isExtended := false;		preDataBlocks := 0;		badfile := false;		dataFormatRead := false;		somechars := false;		readon := true;		SetCursor(clockCursor);		openasuntitled := false;		dotree := false;		doedit := false;		dataBlockNumber := 0;		lastDataBlockChecked :=-1;		numtaxa := 0;		numchars := 0;		blocksread := [];		noundo := true;		justundid := false;		fixlostbyundo := false;		theblock := foreignBlock;		nonnexus := false;		taxaDefined := false;				for whichText := 1 to numTextWindows do			SetHandleSize(textWindowInfo[whichText]^.H, 0);		fpos := kInitialReadPos;		FDI^[readFileFDI].fs := FDI^[dataFileFDI].fs;		ioFileFDI := readFileFDI;		{iofilename^^ := filename^^;}		{29Augе  ioWorkingDirectoryNumber := WorkingDirectoryNumber; }		curTextH := textWindowInfo[AboutFileText]^.H;		SetDataFormat(standard, true);		command := MakeCaps(GetFileToken(maxtok));		if command = '' then 			begin				errorflag := true;				NewError(437,0);			end;		theblock := -1;		fileformat := macclade;		StartThermo(iothermo, tempP, 0, mcFileLength, 'Reading File', 'percent', true);		if not errorflag then			if (command <> '#NEXUS') & (command <> '#NEXUS1') then				begin					if CopyString(command, 1, 6) = '#NEXUS' then						begin							if CWarning(concat('MacClade ', VERSION, ' does not support ', command, ' extensions. Do you want to try to open the file anyway?'), 'Try to read', 'Cancel') then								goto 4							else								errorflag := true;						end					else						begin							nonnexus := true;							ReadNonNexus(tempP, command, nonNexus);							if not nonNexus then								begin									if command = 'BEGIN' then										begin											InitNexusFile;											db := true;											goto 3;										end									else if pos('NEXUS',command)>0 then										goto 4									else 										begin											InstantErrorPlus(436,command);											errorFlag := true;										end;																	end;							openasuntitled := true;						end;				end			else4:				begin	{a NEXUS file}					InitNexusFile;					repeat						db := FindFileToken('BEGIN', false);3:						if fileIsStationery then							UpdateThermo(iothermo, 0, fpos, mcFileLength,true);						block := MakeCaps(GetFileToken(maxtok));					until (db & ((block = 'DATA') | (block = 'CHARACTERS') | (block = 'TAXA') | (block = 'TAXON'))) | (fpos >= mcFileLength);					{if block='MACCLADE' then						begin							ProcessMacCladePreferencesBlock;							errorflag := true;							goto 2;						end					else } if (fpos < mcFileLength) or fileisstationery then	{file with DATA or TAXON block block}						begin							if fpos >= mcFileLength then  {for stationery files}								CheckMemoryMade(true, 1, 1);							fpos := kInitialReadPos;		{restart}							if command = '#NEXUS' then   {from first run through}								begin									command := GetFileToken(maxtok);	{skipping over #NEXUS}									next := nextdarkchar;								end							else   {no #NEXUS, find firstdarkchar}								begin									next := nextchar;									if next in whitespace then										next := nextdarkchar;								end;							oldpos := fpos;							newfile := false;{||||||||||| main loop ||||||||||}							repeat								CheckWhereToGo(dotree, doedit);								UpdateThermo(iothermo, 0, fpos, mcFileLength, true);								errorflag := abortedThermo;								if errorflag then									leave;								startpos := oldpos;								repeat									endpos := fpos;									command := MakeCaps(GetFileToken(maxtok));								until (command = 'BEGIN') or (fpos >= mcFileLength);								originalBlockName := GetFileToken(maxtok);								block := MakeCaps(originalBlockName);								UnderlineToBlanks(originalBlockName);  {make it ready to rewriteToFile if needed}								if command = 'BEGIN' then									begin										Skipper(punctuation, true);										successfulread := true;										if (block = 'DATA') then											theblock := dataBlock										else if (block = 'CHARACTERS') or (block = 'CHARACTER') then											theblock := charactersBlock{$IFC DEVELOPMENT}										else if (block = 'FOOTNOTES') or (block = 'FOOTNOTE') or (block = 'FOOTPICT') or (block = 'FOOTPICTS') then											begin												InstantInfo(concat('MacClade no longer accepts ', block, ' blocks - use NOTES block instead.'));												theblock := foreignBlock;											end{$ENDC}										else if (block = 'CONTINUOUS') then											theblock := continuousBlock										else if (block = 'TAXA') or (block = 'TAXON') then											theblock := taxaBlock										else if (block = 'ASSUMPTIONS') or (block = 'ASSUMPTION') then											theblock := assumptionsBlock										else if (block = 'SETS') or (block = 'SET') then											theblock := setsBlock										else if (block = 'LABELS') or (block = 'LABEL') then											theblock := labelsBlock										else if (block = 'NOTES') or (block = 'NOTE') then											theblock := notesBlock										else if (block = 'MACCLADESTART') then											theblock := maccladeStartBlock										else if (block = 'TREES') or (block = 'TREE') then											theblock := treesDataBlock										else if (block = 'CODONS') or (block = 'CODON') then											theblock := codonsBlock										else if (block = 'MACCLADE.BLOCK') or (block = 'MACCLADE') then											theblock := MacCladeBlock										{else if (block = 'PAUP') then											begin												lastPAUPBlock := CHUNKelements(foreignCHUNKs);												theblock := foreignBlock;											end}										else 											theblock := foreignBlock;																					startBlockPos := fpos;										if theBlock<>foreignBlock then											if (theblock in blocksread) & not ((theBlock=charactersBlock) & not (continuousBlock in blocksRead)) {& ((theBlock = taxaBlock) | (theBlock = dataBlock))} then 												begin	{this type of block has been read before and it is a taxa block or datablock.  thus, need to set it as a foreignblock}													InstantErrorPlus(279, block);													openAsUntitled := true;  {v4.06}													theBlock := foreignBlock;												end	{taxa must be specified before:}	{treesDataBlock, treefileblock, charactersBlock, continuousBlock, }											else if not ((charactersBlock in blocksread) | (dataBlock in blocksread) | (taxaBlock in blocksread)) & (theblock in [continuousBlock, treesDataBlock, treefileblock]) then												begin													InstantErrorPlus(285, block);													errorflag := true;													DrawDialog(iothermo);												end	{characters must be specified before:}	{assumptionsBlock, codonsBlock}											else if not (((dataBlock in blocksread) or (charactersBlock in blocksread)) and discreteCharacterDataRead) and (theblock in [assumptionsBlock, codonsBlock, setsBlock]) then												begin													InstantErrorPlus(286, block);													//errorflag := true;													theBlock := skipBlock;													openAsUntitled := true;													DrawDialog(iothermo);												end	{dataBlock not allowed after charactersBlock}	{else if ((dataBlock in blocksread) or (charactersBlock in blocksread)) and (theblock in [charactersBlock, dataBlock]) then}											else if ((charactersBlock in blocksread)) and (theblock = dataBlock) then												begin													InstantErrorPlus(343, block);													errorflag := true;													DrawDialog(iothermo);												end;																				if not errorFlag then										{if it is a native block then any TITLE and LINKS commands will be processed, and the first command AFTER the TITLE and LINKS commands will be returned.  ValidNativeBlockLinks will return TRUE if:	- there are no LINKS commands	- the LINKS commands are to titled blocks MacClade has processed properly }										if (theBlock=skipBlock) then											begin												if FindEndOfBlock(theBlock,false) then													Skipper(punctuation, true);											end										else if (theBlock<>foreignBlock)& ValidNativeBlockLinks(theBlock,firstCommand, title, linkText) then  											begin{$IFC NEWNEXUSBLOCK}												if (theblock<>maccladeStartBlock) then													AddNativeNexusBlock(theBlock);{$ENDC}												currentNexusBlock := NexusBlock(numNexusBlocks);																								case theblock of													taxaBlock: 														begin															commreadon := true;															ReadTaxaBlock(currentNexusBlock, firstCommand);															commreadon := false;															taxaDefined := true;															LockHandle(textWindowInfo[AboutFileText]^.H,oldState);															TESetText(textWindowInfo[AboutFileText]^.H^, GetHandleSize(textWindowInfo[AboutFileText]^.H), textWindowInfo[aboutFileText]^.TE);															ResetHandle(textWindowInfo[AboutFileText]^.H,oldState);															TECalText(textWindowInfo[aboutFileText]^.TE);														end;													maccladeStartBlock: 														begin															preDataBlocks := 1;															ReadMacCladeStartBlock(firstCommand);														end;													dataBlock: 														begin															commreadon := true;															ReadDataCharBlockStart(currentNexusBlock,dataBlock, successfulread, taxaDefinedInBlock, blockdatatype, false, firstCommand);															if errorflag then																goto 2;															if successfulread then																begin																	ReadDataCharBlockEnd(dataBlock, blockdatatype, dotree, doedit);																	commreadon := false;																	taxaDefined := true;																	LockHandle(textWindowInfo[AboutFileText]^.H,oldState);																	TESetText(textWindowInfo[AboutFileText]^.H^, GetHandleSize(textWindowInfo[AboutFileText]^.H), textWindowInfo[aboutFileText]^.TE);																	ResetHandle(textWindowInfo[AboutFileText]^.H,oldState);																	TECalText(textWindowInfo[aboutFileText]^.TE);																	if (blockDataType<>continuous) then 																		discreteCharacterDataRead := true;																end															else																begin																	DestroyNexusBlockPtr(currentNexusBlock);																	ReadInForeignNexusBlock(currentNexusBlock, originalBlockName);																	currentNexusBlock := nil;																end;														end;													charactersBlock, continuousBlock: 														begin															commreadon := true;															ReadDataCharBlockStart(currentNexusBlock,theblock, successfulread, taxaDefinedInBlock, blockdatatype, theblock = continuousBlock, firstCommand);																														if errorflag then																goto 2;															if successfulread & (taxaDefined | taxaDefinedInBlock) then  //4.01: added & (taxaDefined or taxaDefinedInBlock)																begin																	ReadDataCharBlockEnd(theBlock, blockdatatype, dotree, doedit);																	taxaDefined := taxaDefined or taxaDefinedInBlock;																	commreadon := false;																	LockHandle(textWindowInfo[AboutFileText]^.H,oldState);																	TESetText(textWindowInfo[AboutFileText]^.H^, GetHandleSize(textWindowInfo[AboutFileText]^.H), textWindowInfo[aboutFileText]^.TE);																	ResetHandle(textWindowInfo[AboutFileText]^.H,oldState);																	TECalText(textWindowInfo[aboutFileText]^.TE);																	if (blockDataType<>continuous) then 																		discreteCharacterDataRead := true;																end															else																begin																	DestroyNexusBlockPtr(currentNexusBlock);																	ReadInForeignNexusBlock(currentNexusBlock, originalBlockName);																end;														end;													codonsBlock: 														ReadGeneticCode(currentNexusBlock, firstCommand);													assumptionsBlock: 														ReadAssumptions(currentNexusBlock, firstCommand);													setsBlock: 														begin															ReadSets(currentNexusBlock, firstCommand);														end;													labelsBlock: 														begin															ReadLabels(currentNexusBlock, firstCommand);														end;													treesDataBlock, treefileblock: 														begin															startreadtree := 1;															endreadtree := -1;															ReadTreeBlock(currentNexusBlock, false, firstCommand);														end;													notesBlock: 														ReadNotesBlock(currentNexusBlock, firstCommand);													MacCladeBlock: 														ReadFileSettings(successfulread, firstCommand);													otherwise ;												end;												ShowErrors(concat('In the ', block, ' block.'));												DrawDialog(iothermo);												if successfulread then													begin														blocksread := blocksread + [theblock];														if title <> '' then															begin 																currentNexusBlock^.title := title;  {set title}																nexusBlockInfoShowTitleLink := true;															end;														if linkText <> '' then															begin 																currentNexusBlock^.linkText := linkText;  {set title}																nexusBlockInfoShowTitleLink := true;															end;													end;												if errorflag then													leave;												if (next in whitespace) & (fpos<mcFileLength) then													next := nextdarkchar;												if successfulread or (theblock = MacCladeBlock) then  {we want to reset start of foreign block storage}													oldpos := fpos;											end										else											begin												ReadInForeignNexusBlock(currentNexusBlock, originalBlockName);												currentNexusBlock := nil;											end;									end;								if (next in whitespace) & (fpos<mcFileLength) then									next := nextdarkchar;								badmemory := false;							until (fpos >= mcFileLength) or errorflag;{||||||||||| end main loop ||||||||||}						{fff 	if not errorflag then								if oldpos <= mcFileLength then									StoreForeignBlock(oldpos, mcFileLength + 1);}							nodata := false;						end  {file with DATA block}					else						nodata := true;					if (nodata | not taxaDefined) & not errorflag then			{file with no DATA or TAXON block block}						begin							fpos := kInitialReadPos;							repeat								db := FindFileToken('BEGIN', false);							until db and (MakeCaps(GetFileToken(maxtok)) = 'TREES') or (fpos >= mcFileLength);							if (fpos < mcFileLength) then {this is a treefile}								begin {mark as treefile}									InstantError(209);								end							else								begin									InstantError(287);								end;							errorflag := true;						end;					if not errorFlag then						justReadANexusFile := true;				end;  {NEXUS file}		if errorflag then			goto 2;{$IFC NEWNEXUSBLOCK}		 AddRemainingNativeNexusBlocks;{$ENDC}		 writeTaxaCharBlocks := taxaBlock in blocksread;		if lastPAUPBlock > 0 then 			begin							end;		CheckWhereToGo(dotree, doedit);		if dotree or doedit then			begin				editwasopen := doedit;				treewasopen := dotree;			end;		if openasuntitled then			begin				if not nonnexus then					InstantError(158);				filename^^ := 'Untitled';				{SetMenuItemText(FileMHdl, AboutFileItem, 'About Untitled...');}				fileSaved := false;				newfile := true;				dirtyfile := true;			end		else if fileisStationery then			begin				filename^^ := 'Untitled';				{SetMenuItemText(FileMHdl, AboutFileItem, 'About Untitled...');}				fileSaved := false;				newfile := true;				dirtyfile := true;			end;		if not twfullscreen & not treeWindowPositionRead then			begin				maxTWR.top := GetWindowDefaultTop(treeWindow);				maxTWR.right := GetWindowDefaultLeft(treeWindow) + GetWindowMaxContentWidth(treeWindow);				maxTWR.left := GetWindowDefaultLeft(treeWindow);				maxTWR.bottom := GetWindowDefaultTop(treeWindow)+GetWindowMaxContentHeight(treeWindow);			end;{checking andsep, orsep conflicts}		if andsep in [missing, matchchar, gap] then			begin				for k := 42 to 47 do					if not (char(k) in [missing, matchchar, gap]) then						leave;				andsep := char(k);			end;		if orsep in [missing, matchchar, gap, andsep] then			begin				for k := 42 to 47 do					if not (char(k) in [missing, matchchar, gap, andsep]) then						leave;				andsep := char(k);			end;		ordefsep := mstaxa = mstUncertain;		db := StateNamesHaveSeparators;   {check for statenames having separators}		CheckStateNamesSymbolsDanger(true, db);		if nucleotides then			CheckForCodPos(true);2:		for k := 1 to numtextWindows do			SetHandleSize(textWindowInfo[k]^.H, 0);  {0's storage to free up space}		SetLastChangeInEditor(lastChangeCantUndo);		SetCursorToArrow;		EndThermo(iothermo, tempP, false);					punctuation := punct305;   {v3.05: for plusnotpunct}{    if errorflag then doCodPosQuery := false;}		ShowErrors('');		readon := false;		userCanceledRead := false;{    DebugStr(';log');}	end;end.