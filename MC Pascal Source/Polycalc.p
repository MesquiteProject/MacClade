unit PolyCalc;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, TaxonCHUtil, Prohibitions, CharUtil, TreeUtil, TypeUtil, UtilLibInterface, SetLibInterface;	function PolyCalcs (pN: Nptr; ic, chat, pass: integer; var len: longint; traced: boolean): largestsetchars;	procedure CalcCharMinmaxLen (ic: integer; minOrmax: integer);	procedure ResetMinMaxTreeLength (minormax: integer);	procedure CalcMinMaxTreeLen (minorMax: integer);{еееееееееееееееееееееее}implementation {е$S PolyCalc}{-----------------------------------------------------------------------------}{######  POLYTOMIES & MINIMUM/MAXIMUM CONCEIVABLE LENGTHS  ###########}{This unit deals with character tracing and counting for polytomous nodes.  The same procedures}{are also borrowed for use in minimum and maximum conceivable length calculations for}{whole tree (e.g., for CI, RI, RC indices).}function cOldSetFromNew (s: lgsetchars):largestsetchars;external;function cNewSetFromOld (s1: largestsetchars): lgsetchars;external;{-----------------------------------------------------------------------------}{	v3.1: split this procedure into one for hard and one for soft}{	v3.1: much of slowness of Polycalcs comes from recursing for every character separately.  Thus if unordered }{	soft polytomy, could do preliminary all characters pass which accumulates singletons and allstatesinallnodes;}{	if same don't even bother to go to individual polycalcs}	function PolyCalcs (pN: Nptr; ic, chat, pass: integer; var len: longint; traced: boolean): largestsetchars;{FROZEN 3.0}{This is the grand procedure to do polytomous calculations.  Used both for polytomies and to calculate}{minimum and maximum conceivable lengths of characters.}{ic is character number}{chat is character type}{pass is down, up, triple, minlength, or maxlength}{len is length incremented}{traced is true if calculations are done on traced character storage (important if fixed states at nodes)}{NOTE that these calculations use lgsetchars instead of largestsetchars.  See notes in Equivocal.p}		type			totype = array[0..absmaxstate] of integer;		var			minL, maxL: integer;			charHdl: chHdl;			foundnonmissing: boolean;			ctype: integer;			aN, thisN: Nptr;			rset: lgsetchars;			ir, it: integer;			chmaxst: integer;			hardpolytomy: boolean;  {for unordered}			allnodes: set255;			coveredby: csintype;			allstates, sumstates, singletons, allstatesinpolytomy: lgsetchars;			nodenum, numtry, cardcoveredby, lenplus, maxall, cardall, GreatestFrequency: integer;			found, toomanynodes: boolean;			nodeswithstate: totype;  {for ordered}			largestMin, smallestMax: integer;			interstates: lgsetchars;			toleft, toright: totype;{for calcminmaxlen}			allstsinalltaxa, sureset, coverset: lgsetchars;{......................................................................................}		procedure GetSetFromNode (N: Nptr; fromabove: boolean);{FROZEN 3.0}{This procedure gets the set from node N participating in polytomy or for term taxon for min/maxlength}			var				state: integer;				oNset: largestsetchars;				Nset: lgsetchars;		begin			if (not Qtaxon(N, ic) | (N^.fix & traced)) then				begin {get set only if not missing unless fixed}		{OBTAINING SET from N}					if traced then  {for traced character}						begin							if N^.fix then								oNset := N^.fixsts							else if fromabove then								oNset := N^.down  {if request is to get set from above, obtain downstates}							else								oNset := N^.up;    {if request is to get set from below, obtain upstates}						end					else						begin							if fromabove then								oNset := getdnstlargest(N, ic)  {if request is to get set from above, obtain downstates}							else								oNset := getupstlargest(N, ic);    {if request is to get set from below, obtain upstates}						end;					Nset := NewSetFromOld(oNset);										foundnonmissing := true;  {record that at least one set was gotten}	{PROCESSING SET}		{here we add this set into accumulated information about sets in polytomy}					case ctype of						-1: 													{е======   UNORDERED  ======}							begin  {preliminary getsets to find singletons for unordered character for soft polytomy}								if MonomorphG(Nset) then									singletons := Union2(singletons, Nset);								allstatesinpolytomy := Union2(allstatesinpolytomy, Nset); {accumulates all state in case singletons cover it all}								interstates := Intersect2(interstates, Nset);							end;						unordered: 							begin				{keep running intersection set to record which states are in all sets gotten}								interstates := Intersect2(interstates, Nset);								if hardpolytomy then  {here increment the length counter for any states at the node}									begin										nodenum := nodenum + 1;  {keep track of how many nodes found}					{For each state, see if this node has it; }					{if so then add 1 to  running total of how many nodes have this state.}					{This will be used to find which state is in majority}										for state := 0 to chmaxst do											if Enset(state, Nset) then												nodeswithstate[state] := nodeswithstate[state] + 1;									end								else									begin  {if softpolytomy}					{if Nset intersects with singletons then node is already covered, so ignore it}										if (Intersect2(Nset, singletons) = nil) then											begin					{otherwise keep count of nodes gotten}												nodenum := nodenum + 1;												if nodenum <= 255 then  {remember only 255 nodes not covered by singletons allowed}													begin							{For each state, see if this node has it; }							{if so then place this node's number in the set of nodes covered by this state.}														for state := 0 to chmaxst do															if Enset(state, Nset) then																coveredby[state] := coveredby[state] + [nodenum];							{record the set of all nodes which don't overlap singletons}														allnodes := allnodes + [nodenum];							{and the set of all states in sets not overlapping singletons}														allstates := Union2(allstates, Nset);													end												else													toomanynodes := true;											end;									end;							end;						ordered, irreversible:    {е=========   ORDERED types  =======}							begin				{ordered type (all passes) and irreversible types (minlength only) are dealt with here}								minL := MinG(Nset);								maxL := maxG(Nset);								interstates := Intersect2(interstates, Makespan(minL, maxL));  {remember any states occurring in all sets gotten}								if hardpolytomy then									begin					{for all states, add to number of sets to right and left of state as appropriate}										for state := 0 to Chmaxst do											if minL > state then						{thus if minimum of set is greater than state, set is to right; }						{thus there is one more set to right of state}												toright[state] := toright[state] + 1											else if maxL < state then						{but if maximum of set is less than state, set is to left; }						{thus there is one more set to left of state}												toleft[state] := toleft[state] + 1;									end								else {soft polytomy}									begin					{keep running adjustments as to what is largest minimum}										if minL > largestMin then											largestMin := minL;					{ as well as what is smallest maximum}										if maxL < smallestMax then											smallestMax := maxL;									end;							end;						otherwise							NewError(3, ic);					end;				end		end;{......................................................................................}		procedure GetSets (N: Nptr; fromabove: boolean);{FROZEN 3.0}{this procedure recurses through the tree getting sets from the edges of the polytomous region.}{The information accumulated is later used to work out state sets, etc. for node pN.}{Note that the procedure can look upward (if fromabove is true) or downward and beside (if fromabove is false)}		begin			if not N^.null then				begin					GetSetFromNode(N, fromabove);				end  {if set found then recursion stops pursuing that path}			else if NodeIsInternal(N) then {otherwise recursion continues if still at internal node}				begin					if fromabove then {if on last getsets call we requested sets from above, will still be from above}						begin							GetSets(N^.lf, true);							GetSets(N^.rt, true);						end					else {but if on last getsets call we requested sets from below, }				{will now want to get sets from down below and beside above}						begin							if (N <> R) & ((N^.anc <> R) | (traced & R^.fix)) then					{looking below to ancestor; if already at root or anc is root then no need for anc's upstates }					{except if anc is root and is fixed, in which case go down to get that state}								GetSets(N^.anc, false);							if not (hardpolytomy & traced & NotNullAnc(N)^.fix) then					{looking around and up to sister, }					{unless fixed state below at hard polytomy insulates all but ancestor's preference}								GetSets(sis(N), true);				{ recall that soft polytomy fixing does not insulate sister, since soft polytomy}				{below base of clade}						end;				end;		end;{......................................................................................}		procedure RecursetoGetAllSets (pN: Nptr);{FROZEN 3.0}		begin			if (pass = down) then {used when pN is polytomous}				begin {more or less equivalent to downpass calculations: get from down of descendants}					GetSets(pN^.lf, true);  {get sets from up left}					GetSets(pN^.rt, true);  {get sets from up right}				end			else if pass = up then  {used when pN^.anc is polytomous}				begin {more or less equivalent to uppass calculations: get from down of sister and up of ancestor}					if (pN <> R) & ((pN^.anc <> R) | (traced & R^.fix)) then						GetSets(pN^.anc, false);  {as long as pN is not just above root, get up sets from below}					if not (hardpolytomy & traced & NotNullAnc(pN)^.fix) then						GetSets(sis(pN), true);  {get sets from sister}				end			else if pass = triple then {used when pN is hard polytomous}				begin {more or less equivalent to triple calculations: get from down of descendants, and up of node}					GetSets(pN^.lf, true);  {get sets from up left}					GetSets(pN^.rt, true); {get sets from up right}					GetSets(pN, false);  {get sets from below node (node's upstates, actually)}				end;					end;{......................................................................................}		procedure Addstate (oldsumcovered: set255; oldlaststate, oldlevel: integer);{v4:  bad to recurse set255}{eventually faster to do set calculations myself , passing pointer to set}{and number of nodes so as not to check entire set255}{oldsumcovered and }{For unordered characters}{This recursive procedure keeps adding states until the size of set desired, numtry, is achieved.  }{All sets of this size are examined to see if a covering set is found.}			var				sumcovered: set255;				t, thislevel: integer;		begin{At this point we have created a set called oldsumcovered, containing oldlevel elements.}{This set indicates the nodes which are covered by the states accumulated to this point.}{The set does not contain all the nodes, which means the set of states does not cover all the nodes}{So we will now try to add another state, i.e. add to oldsumcovered the nodes now covered by this new state, }{to see if the new set (sumcovered) now contains all nodes.  }{States from 0 through oldlaststate have already been tried, so now we will try each of states}{oldlaststate+1 through maxall.}			thislevel := oldlevel + 1;			for t := oldlaststate + 1 to maxall do				if Enset(t, allstates) then {only consider node if it was among those in the nodes}					begin			{The set of states in the hopeful covering set is updated to include t}						sumstates := AddtoSet(sumstates, t); {this variable is outside of recursion; but effectively recursed because procedure}				{does housekeeping, adding t before sending deeper into recursion, subtracting it on popping out}			{The set of nodes now covered is calculated from the old set and the nodes covered by t}						sumcovered := oldsumcovered + coveredby[t];						if (numtry = thislevel) & (sumcovered = allnodes) then {no sense trying set if we haven't yet made set of desired size}			{Success! the set now includes all nodes}							begin				{Since sumstates is therefore one of the smallest covering sets, }				{add it into the result set for polycalcs}								rset := union2(rset, sumstates);				{The number of steps cost is the number of states in the covering set minus 1,}				{ ie. the number of states in the old level of the recursion}								lenplus := oldlevel;								found := true; {record that success was had}								coverset := sumstates; {remember one of the covering sets for later calculating # steps}							end						else if (numtry > thislevel) and (numtry - thislevel <= maxall - t) then			{Sorry, the set still does not include all nodes. }			{Try adding another state, } 			{if haven't yet gotten numtry in set and if number of sets needed}			{is less than or equal to number available.}							AddState(sumcovered, t, thislevel);						sumstates := SubtractFromSet(sumstates, t); {once out of loop t is no longer included in sumstates}					end;		end;{****************************************************}	begin {function PolyCalcs}		aN := NotNullAnc(pN);{get nonnull ancestor of polytomous node pN}		chmaxst := CharMaxstOBS(ic); {use maxst observed since never have user-defined here}		if polyreal and aN^.fix and traced and (pass = up) then			rset := NewSetFromOld(aN^.fixsts)  {if polytomous ancestor fixed on up pass (traced character) then just use aN^.fixsts}		else if (chat >= fisher) | ((chat = irreversible) & (pass <> minlength)) then		{kick out if fisher, dollo or user-defined, or if irrev and not minlength}			NewError(3, ic)		else			begin				hardpolytomy := (pass = maxlength) or ((pass < minlength) and POLYREAL);				foundnonmissing := false;  {initialize that no sets gotten}				ctype := chat;  {temporary storage of character type}				nodenum := 0;				lenplus := 0;				rset := nil;				for ir := 0 to chmaxst do {initializing stuff, unordered and ordered}					begin						nodeswithstate[ir] := 0;						coveredby[ir] := [];						toleft[ir] := 0;						toright[ir] := 0;					end;				interstates := MakeSpan(0, chmaxst);{unordered}				singletons := nil;				allnodes := []; {initializing storage of nodes and states to empty}				allstates := nil;				sumstates := nil;				found := false;				toomanynodes := false;{ordered, irreversible}				largestMin := 0;  {initialize largest minimum state}				smallestMax := chmaxst;  {initialize smallest maximum state}{Getting Sets   ==============================}				if (pass >= minlength) then {minlength or maxlength calculations}					begin			{For minlength and maxlength calculations, get information about character, including}			{singleton states (states which occur alone in some terminal taxa), etc. }						charHdl := Getchhdl(ic);						chmaxst := CharHdl^^.maxst;  {maximum state in character}						if (ctype = unordered) and not hardpolytomy then							begin								singletons := NewSetFromOld(Charhdl^^.singletons);    {sets of singletons from SetTxdnst}								sureset := NewSetFromOld(Charhdl^^.sureset);   {suresets from SetTxdnst}							end;						allstsinalltaxa := NewSetFromOld(CharStatesLargest(ic));						if allstsinalltaxa <> nil then							foundnonmissing := true;						if not ((pass = minlength) & (ctype = unordered) & (allstsinalltaxa = singletons)) then				{if not already covered by singletons, get sets from terminal nodes}							begin								for it := 1 to numtaxa do  {Now getting sets from terminal nodes}									if TaxonInTree(it) then										begin											thisN := getTaxonHdl(it)^^.N;											GetSETfromNode(thisN, true);										end;							end						else							interstates := nil; {this done just so doesn't think something in common}					end				else  {polytomy calculations}					begin						if (ctype = unordered) & not hardpolytomy then  {setting singletons and suresets}			{for unordered characters in normal passes, speed can be improved by first accumulating}			{singletons among nodes, because singletons are guaranteed to be in covering set.  The below does special}			{ctype=-1 passes getting sets, solely to calculate singletons.  See comments below for explanation }			{of passes.}							begin								ctype := -1;								allstatesinpolytomy := nil;								RecursetoGetAllSets(pN);								ctype := unordered;								if not (allstatesinpolytomy = singletons) & (interstates = nil) then									begin {if all above are singletons or all nodes overlap then no point to go on}										interstates := MakeSpan(0, chmaxst); {resetting interstates}										RecursetoGetAllSets(pN);									end;							end						else							RecursetoGetAllSets(pN); {recursing through tree}					end;{processsets ====================================================================}				if toomanynodes then					begin						if pass < minlength then							NewError(94, ic)						else							NewError(19, ic);						if cardg(sureset) >= 1 then {if anything in sureset, just use these states}							begin 				{incrementing length; remember that toomanynodes only with unordered}								len := len + (cardg(sureset) - 1);								rset := sureset;							end						else							rset := MakeSpan(0, chmaxst);					end				else if foundnonmissing then					if interstates <> nil then   {intersection among all nodes exists, so take it}						rset := interstates					else						case ctype of							unordered:   {е===========================   UNORDERED ========}								begin									if (pass >= minlength) & (allstsinalltaxa = nil) then										rset := nil									else if hardpolytomy then										begin  {for hard polytomies, choose those states that appear in most sets}											rset := nil;											GreatestFrequency := 0;											for ir := 0 to ChMaxst do												begin													if nodeswithstate[ir] > GreatestFrequency then {state ir has higher frequency than so far found}														begin															rset := MakeSet(ir); {therefore make new result set with ir}															GreatestFrequency := nodeswithstate[ir];														end													else if nodeswithstate[ir] = GreatestFrequency then {ir has as high as found}														rset := AddToSet(rset, ir); {therefore add to rset}												end;											len := len + nodenum - GreatestFrequency;					{length cost is the number of nodes lacking a state of greatest frequency}										end									else {soft polytomy}										begin											rset := nil;						{find cardinality of set of all states found in get sets}											cardall := cardg(allstates);											if cardall > 0 then {some non-singletons}						{if some sets found not covered by singletons, then we have something to do}												begin							{find maximum state among those gotten}													maxall := maxg(allstates);							{now try adding states, until covering set found (see addstate)}													numtry := 0;													repeat														numtry := numtry + 1; {begin with one state sets, then try more and more}														Addstate([], -1, 0);      {look for covering sets of numtry states}													until found or (numtry >= Cardall - 1); {quit looking if covering set found or if looked too far}					{At this point, if covering set was found, then coverset will contain one of the covering sets,}					{and lenplus will contain the length cost thereby (card-1)}													if not found then {covering set not found by addstate, thus only covering set includes allstates}														begin															rset := allstates;															coverset := allstates;															lenplus := Cardall - 1  {length cost is number of states minus 1}														end; {if found, then lenplus and coverset already dealt with}						{add to length that cost by any singletons not in coverset}													len := len + lenplus + cardG(SubtractSets(singletons, coverset));												end											else {node state sets were only singletons and intersectors of singletons; only singletons in rset)}												len := len + cardg(singletons) - 1;											rset := Union2(rset, singletons);										end;								end;							ordered, irreversible:    {е===========================   ORDERED ========}								begin									if hardpolytomy then {only ordered since irrev doesn't allow maxlength/hardpoly}										begin					{Cycle along toright & toleft until "median" states found}					{Recall general criterion:  state s is median if the number of sets to the right of s}					{is less than or equal to the number to the left of s+1, AND  the number of }					{sets to the left of s is less than or equal to the number to the right of s-1.}					{Therefore we will try to find all such median states}											rset := nil; {initialize rset}											if (toright[0] <= toleft[1]) then  {for ir=0, only check one criterion}												rset := AddToset(rset, 0);											for ir := 1 to chMaxst - 1 do  {for intermediate ir, check both criteria}												if (toleft[ir] <= toright[ir - 1]) & (toright[ir] <= toleft[ir + 1]) then													rset := AddToset(rset, ir);											if (toleft[chMaxst] <= toright[chMaxst - 1]) then  {for ir=chMaxst, only check one criterion}												rset := AddToset(rset, chMaxst);					{Now, to calculate length required, count number of steps}					{presuming N is assigned the largest state in its state set}											maxL := maxg(rset);											if maxL > 0 then												for ir := 0 to maxL do													len := len + toleft[ir];  {add number of sets one, two, three, etc. steps to left of maxL}											if maxL < chmaxst then												for ir := maxL to chmaxst do													len := len + toright[ir]; {add number of sets one, two, three, etc. steps to right of maxL}										end {hardpolytomy}									else										begin {softpolytomy}											rset := MakeSpan(smallestMax, largestMin);  {smallestMax to largestMin is result for ordered soft polytomy}					{calculate cost to span smallestmax to largestmin}											len := len + largestMin - smallestMax;										end;								end;							otherwise								;						end {case}				else  {all missing}					rset := MakeSpan(0, chmaxst);			end;		PolyCalcs := OldSetFromNew(rset);	end; {function PolyCalcs}{-----------------------------------------------------------------------------}	procedure ZeroCharMinMax (ic: integer; minOrmax: integer);{FROZEN 3.0}		var			charHdl: chHdl;	begin		charHdl := getchhdl(ic);		if minormax = minlength then			charHdl^^.minLen := 0		else			charHdl^^.maxLen := 0;	end;{-----------------------------------------------------------------------------}	procedure CalcCharMinmaxLen (ic: integer; minOrmax: integer);{FROZEN 3.0}{This procedure calcualtes a character's min or maxlength, }{given that one character ic has changed, NOT IN WEIGHT but in type.}{Called only in MacClade and charting}		var			charHdl: chHdl;			len: longint;			tempset: largestsetchars;			ctyp: integer;	begin		ctyp := typeofchar(ic);		if MinMaxLenLegalChar(ic, minormax) then			begin			{initialize min/maxlength with length due to polymorphism}				len := CharPolymorphLength(ic);				tempset := PolyCalcs(R, ic, ctyp, minormax, len, tracedfalse);  {get character's new min/maxlength}				charHdl := getchhdl(ic);				if minormax = minlength then					charHdl^^.minLen := len				else					charHdl^^.maxLen := len;			end		else			ZeroCharMinMax(ic, minormax);	end;{-----------------------------------------------------------------------------}	procedure ResetMinMaxTreeLength (minormax: integer);{FROZEN 3.0}{Resets min and max treelength without recalculating min and max's for each character; }{used when weight or inclusions changed, for instance}		var			charHdl: chHdl;			cwtP, cTypP: IP;			clenP: LIP;			ic: integer;			oldState1, oldState2: SignedByte;	begin		if allowCursorChange then			SetCursor(MinLenCurs);	{initializing length to 0; }	{note that char min/maxlens already include length due to polymorphism}		if minormax = minlength then			mintreelength := 0		else			maxtreelength := 0;		LockHandle(chwtH, oldstate1);		LockHandle(chtypH, oldstate2);		cwtP := IP(GetMaster(chwtH));		ctypP := IP(GetMaster(chtypH));		for ic := 1 to numchars do  {cycling through all characters}			begin				if MinMaxLenLegalChar(ic, minormax) then					begin						charHdl := GetChHdl(ic);						if minormax = minlength then  {add character ic's contribution to min or max length}							begin								if AddToLength(mintreelength, charhdl^^.minlen, cwtP^, ctypP^) = false then									NewError(306, 0);							end						else							begin								if AddToLength(maxtreelength, charhdl^^.maxlen, cwtP^, ctypP^) = false then									NewError(306, 0);							end;					end;				cwtP := IP(ord4(cwtp) + chwb);				ctypP := IP(ord4(ctypp) + chtb);			end;		ResetHandle(chwtH, oldstate1);		ResetHandle(chtypH, oldstate2);	end;{-----------------------------------------------------------------------------}	procedure CalcMinMaxTreeLen (minorMax: integer);{FROZEN 3.0}{Calculates min and max lengths for each character and sums into overall min/max treelength; }		var			charHdl: chHdl;			ic: integer;			ctypP, cwtP: IP;			cpP: LIP;			clen: longint;			tempset: largestsetchars;			oldstate1, oldstate2, oldstate3: SignedByte;	begin		if (((not PleaseOffMinAll) & MinMaxLenLegal(false, minlength)) & ((minormax = minlength) | ((not PleaseOffMaxAll) & MinMaxLenLegal(false, maxlength)))) then			begin				if allowCursorChange then					SetCursor(MinLenCurs);				if minormax = minlength then {initializing length to 0}					mintreelength := 0				else					maxtreelength := 0;				LockHandle(chwtH, oldstate1);				LockHandle(chtypH, oldstate2);				LockHandle(chpLH, oldstate3);				ctypP := IP(GetMaster(chtypH));				cwtP := IP(GetMaster(chwtH));				cpP := LIP(GetMaster(chpLH));				for ic := 1 to numchars do					begin						if MinMaxLenLegalChar(ic, minormax) then {Note excluded chars not allowed minlength}							begin								clen := cpP^; {initialized character's length as length due to polymorphism}								tempset := PolyCalcs(R, ic, ctypP^, minormax, clen, tracedfalse); {calculate min/max length for character}								charHdl := getchhdl(ic);								if minormax = minlength then									begin										charHdl^^.minLen := clen; {store char's min length}										if AddToLength(mintreelength, cLen, cwtP^, ctypP^) = false then											NewError(306, 0); {add into mintreelength}									end								else									begin										charHdl^^.maxLen := clen; {store char's max length}										if AddToLength(maxtreelength, cLen, cwtP^, ctypP^) = false then											NewError(306, 0);  {add into maxtreelength}									end;							end						else							ZeroCharMinMax(ic, minormax);						ctypP := IP(ord4(ctypP) + chtb);						cwtP := IP(ord4(cwtP) + chwb);						cpP := LIP(ord4(cpP) + chpb);					end;				ResetHandle(chwtH, oldstate1);				ResetHandle(chtypH, oldstate2);				ResetHandle(chpLH, oldstate3);			end		else			begin				if minormax = minlength then					begin						NewError(81, 0);  {minlen could not be calculated; give warning}						PleaseOffMinAll := true;					end				else					begin						NewError(82, 0);  {maxlen could not be calculated; give warning}						PleaseOffMaxAll := true;					end;			end;	end;end.