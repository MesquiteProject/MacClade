unit CalcTraced;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, CharUtil, TypeUtil, TreeUtil, Polycalc, CalcUtil, UtilLibInterface, SetLibInterface,   Dollo;	procedure DownPassTraced (NP: Nptr);	procedure UpPassTraced (NP: Nptr);	procedure TriplePassTraced (NP: Nptr);{еееееееееееееееееееееее}implementation	var		Nfixanced, NNotFixanced, aN: Nptr;		lenpl: longint;{-----------------------------------------------------------------------------}{##########  TRACED CHARACTER (DISCRETE) RECONSTRUCTION  #############}{This unit deals with reconstructing the ancestral states of the traced character,}{for all predefined types (unordered, ordered, irreversible, fisher, dollo) }{(For user-defined types, the GenChar procedures are used; see procedure ReconstructTraced).}{The following procedures also count its number of steps, unless it is a Dollo or Fisher character}{(in which case steps are counted afterward).}{Note that they include provisions for nodes whose states are fixed.  They are}{therefore more complex than those for non traced characters, }{which can't have ancestral states fixed.}{Recall that the traced character is character i, }{For each node N:}{Downstates are stored in N^.down}{Upstates are stored in N^.up}{Final state are stored in N^.final}{Number of steps in character stored in isteps}{Type of character is itype}{See especially units CharUtil, CalcUtil and Polycalcs for procedures called here}{-----------------------------------------------------------------------------}{==================================================================================}	procedure DownPassTraced (NP: Nptr);{FROZEN 3.0}{Sets Downstates of terminal and internal nodes}{ for counting & reconstruction of traced character}{User-defined types ignored here & done separately}		var			minL, maxL: integer;			chL, istepsadd: longint;			itype, chmaxst: integer;			rd: largestsetchars;{....................................................}		procedure DownFixedTraced (N: Nptr);  {==================}{FROZEN 3.0}{sets node's downstates and counts distance when node's state is fixed}{Because state is fixed, downstate is N^.fixsts, and only distances need be counted,}{except for dollo where special packing must be done}{For internal nodes only}		begin			if itype < dollo then				begin					N^.down := N^.fixsts;					if NodeisPolytomous(N) then						begin							if itype < irreversible then								begin									chl := 0; {dummy to absorb length}									if polyreal then {hard polytomy}										AddDistOneToMany(N, i, isteps)					{Add distance between N and all descendants}									else {soft polytomy}										AddDistBetweenSets(N^.down, PolyCalcs(N, i, itype, down, isteps, tracedtrue), i, isteps)					{Add distance from N to preferred state from above; this is done because soft}					{polytomy node is treated as just below lowest node resolved out of polytomy}								end;						end					else if itype <> fisher then						AddDistOneToTwo(N^.down, N^.lf^.down, N^.rt^.down, i, isteps);				{add length between fixed N & its two descendants}				end			else if itype = Dollo then				begin  {Dollo}		{Next pack into N^.down the special Dollo storage of 0's bits, 1's bits, and sts}					N^.down := SetToPackedDolloCert(N^.fixsts, CharMaxstOBS(i)); 		{note that this allows multiple fixed states; prepared for future}		{note also that Dollo character distance not counted in downpass}				end;		end;{....................................................}		procedure DownFixancedTraced (N: Nptr); {==================}{FROZEN 3.0}{Sets N's downstates when n is internal node which is actually a terminal node}{fixed as ancestor.  Need to pull down states from this terminal, place them at the internal,}{and adjust numbers of steps}		begin{first find out which of N's descendants is the terminal fixanced upon it, and store as Nfixanced}			Nfixanced := TermofFixanc(N);			NNotFixanced := DescofFixanc(N);	{Set downstates of N and add to running total of number of steps (isteps)}	{those between fixanced node and descendants}	{Note that fisher chars sent into this even though they are not actually treated as fixanced}			CombineFixancedDown(N^.down, Nfixanced^.down, NNotfixanced^.down, gettaxonstsLargest(Nfixanced^.name, i), isteps, i, N, tracedtrue);		end;{....................................................}		procedure DownTerminalTraced (N: Nptr);{==================}{FROZEN 3.0}{Sets N's downstates when n is a terminal node.}{Need to get states stored for Taxon, and calculate how many steps required within any}{polymorphic terminal taxon.}		begin	{initialize counter for number of steps required within terminal (equivalent to chL above).}			istepsadd := 0;		{Get downstate from storage for Taxon.  }			N^.down := GetTaxonStsLargest(N^.name, i); {note:  high bits  FT, FP, ER cut out automatically}			if (MultipleStatesLg(N^.down)) then				begin  {============= POLYMORPHIC OR UNCERTAIN STATE TAXON ======}					case itype of						unordered:				{for unordered characters not much needs to be done}							if not (ucl in N^.down) then								istepsadd := istepsadd + cardLg(N^.down) - 1  {if not uncertain then add polymorphism length}							else								N^.down := N^.down - [UcL]; {otherwise just subtract uncertain bit}						ordered:				{for ordered characters need to assign range between smallest and largest of observed states}							begin								MaxMinLg(N^.down, minL, maxL);								if not (UCl in N^.down) then									istepsadd := istepsadd + maxL - minL;  {if not uncertain need to add polymorphism length}								N^.down := [minL..maxL];							end;						irreversible, fisher: 							begin								if (UCl in N^.down) then									begin						{for irreversible characters assign range }						{between smallest and largest of observed states if uncertain}										N^.down := SpanLg(N^.down);									end								else									begin						{otherwise assign smallest of observed states}						{and add polymorphism length}										if itype = irreversible then											istepsadd := istepsadd + maxLg(N^.down) - minLg(N^.down)										else											istepsadd := istepsadd + FisherDistance(N^.down, false);										N^.down := [minLg(N^.down)];									end;							end;						dollo: 							begin { for Dollo characters}								if maxLG(N^.down) > dollosize - 1 then {first check if is legal assignemt}									begin										chmaxst := dollosize - 1;										NewError(52, i);									end								else									chmaxst := CharMaxstOBS(i);								if (UCl in N^.down) then									begin  {======  UNCERTAIN Dollo======}										N^.down := SetToPackedDolloUnCert(N^.down, chmaxst);									end								else									begin {======  POLYMORPHIC Dollo ======}										istepsadd := istepsadd + maxLg(N^.down) - minLg(N^.down);  {need to add polymorphism length}										N^.down := SetToPackedDolloCert(N^.down, chmaxst);									end							end					end;				end   {polymorphic or uncertain-state taxon}			else if (MSl in N^.down) then {note: gaps treated as missing}				begin  {================= MISSING DATA ======}					if itype <> dollo then				{if missing data then assign to downstate set of all possible states unless dollo}						N^.down := [0..CharMaxstOBS(i)]					else				{for Dollo characters only MSL is set.  This leaves all 0's,1's and sts cleared}						N^.down := OldSetFromNew(PackDollo3(nil, nil, MakeSpan(0, CharMaxstOBS(i))));				{Note: sts portion of down set to all possible}				end     {missing data}			else				begin  {================= MONOMORPHIC ======}			{Cardinality of set in taxon storage is 1, thus taxon is monomorphic.}			{Nothing needs to be done for most characters; for Dollo, need to pack states into}			{three-part dollo storage}					if itype = dollo then						N^.down := SetToPackedDolloCert(N^.down, CharMaxstOBS(i));				end;			if N^.fix then {if fixed then just reassign downstates as fixsts, unless dollo}				begin					if itype = dollo then {if dollo then have to pack fixsts into three part Dollo storage}						begin							N^.down := SetToPackedDolloCert(N^.fixsts, CharMaxstOBS(i));							if not Qtaxon(N, i) then								AddDistBetweenSets(N^.fixsts, SpanLg(GetTaxonstsLargest(N^.name, i)), i, istepsadd);						end					else						begin							if itype <> fisher then								AddDistBetweenSets(N^.fixsts, N^.down, i, istepsadd);							N^.down := N^.fixsts;						end;				end;			isteps := isteps + istepsadd; {add polymorphism length to traced character's step counter}		end;{........................................................................................................................................}		procedure InDownPassTraced (Nq: Nptr); {@@@@@@@ RECURSION @@@@@@@}{FROZEN 3.0}{This is the main recursive procedure of DownPass.  It visits all the nodes, }{calling on the above procedures to do the calculations at each node as appropriate}		begin			if NodeIsInternal(Nq) then				begin  {internal node}					InDownPassTraced(Nq^.lf);					InDownPassTraced(Nq^.rt);					if not Nq^.null then {null nodes are ignored since they don't really exist}						begin{first check for and deal with complex situations like fixed states, polytomies, etc.}							if Nq^.fix then								DownFixedTraced(Nq)							else if NodeIsPolytomous(Nq) then								begin									if itype < irreversible then										Nq^.down := PolyCalcs(Nq, i, itype, down, isteps, tracedtrue)									else										NewError(3, i); {irrev, fisher, dollo, user-def not allowed with polytomies}								end							else if Nq^.fixanc then {node has terminal node fixanced upon it}								DownFixancedTraced(Nq) {The simple case - nothing complicated}							else if itype < dollo then								begin				{combine state sets of descendant nodes and increment number of steps}									stSetOpLargest(Nq^.down, Nq^.lf^.down, Nq^.rt^.down, itype, isteps);				{for fisher chars weight of missed strata not counted in StSetOplargest; will be counted later}								end							else if itype = dollo then								Nq^.down := DolloCombineAndPack(Nq^.lf^.down, Nq^.rt^.down, Nq = R, i);						end;				end {internal node}			else				DownTerminalTraced(Nq);  {terminal node; note: fixanced terminals dealt with here because we use their dnsts}		end; {@@@@@@@@@  RECURSION}	begin {main for DownPassTraced.......................}		itype := TypeOfChar(i);		if allowCursorChange then Setcursor(DownPassCurs);		isteps := 0; {initialize counter for number of steps}		InDownPassTraced(NP);	end; {DownPassTraced}{==================================================================================}{==================================================================================}	procedure UpPassTraced (NP: Nptr);{FROZEN 3.0}{Sets Upstates of internal nodes for  reconstruction of traced character}{ for unordered and ordered characters only.}{User-defined types ignored here & done separately}{Dollo and irreversible characters don't have upstates so not done here}{NOTE: upstates at node N indicates preferences of part of tree below N; it is }{calculated from upstate of ancestor, and downstate of sister. }{Sis е     е N	}{      | \  /		}{      |   е Anc	}{      | /		}{      е  		}{This means, for instance, that if N is fixanced, its upstates are not affected since what}{counts is N's ancestor and below.  Thus dealing with N being fixanced and the effect this}{has on upstates must come on N's descendants.  This is done so as to simplify the }{filtering of upstate preferences from below by the fixanc when the fixanc has uncertain}{or missing data.  The filtering is done only when N^.up is used, not when it is calculated.}{N^.up is calculated in unfiltered form.  One exception to this interpretation of }{upstates is when N's state is fixed (N^.fix), in which case N's upstates are locked to }{fixstates because preference below (anc and below) will never be needed when N^.fix}		var			itype: integer;		procedure InUpPassTraced (N: Nptr); {@@@@@@@ RECURSION @@@@@@@}		begin			if (NodeIsInternal(N)) then  {internal node}				begin					if (N <> R) and not N^.null then						begin							N^.up := N^.down;  {initalize upstate default to same as downstate}							if not N^.fix then								begin {if not fixed deal with it; otherwise leave it alone}									if PartOfPolytomy(N) then {node below is polytomous, so send to Up version of polycalcs}										N^.up := PolyCalcs(N, i, itype, up, lenpl, tracedtrue)									else if N^.anc^.fix then {if ancestor is fixed then this state insulates from sister and further down}										N^.up := N^.anc^.up									else if N^.anc = R then {regardless of whether root is fixanced or not, take upstates from sister}										N^.up := Sis(N)^.down    {node is just above root, so don't combine sister and ancestor}									else if not N^.anc^.fixanc then  {node below is not polytomous and not fixed and not fixanced}							{combine sister's down state and ancestor's upstate to yield node's upstate}										stSetOpLargest(N^.up, N^.anc^.up, Sis(N)^.down, itype, lenpl)									else										begin		{ node below fixanc; therefore use its state or use it to filter upstate. }											Nfixanced := sis(N);  {this must be the one fixanced}											if FixancedByMissing(N^.anc, i) then												N^.up := N^.anc^.up  {missing; transparent to upstate from below}											else if FixancedByUncertain(N^.anc, i) then												begin {N^.anc^.fixanc and  fixancedbyuncertain; need to filter}							{use Nfixanced^.down as filter against preference below}													N^.up := ClosestInAtoB(NFixanced^.down, N^.anc^.up, itype);												end											else												N^.up := Nfixanced^.down  {monomorphic or polymorphic - use as is}							{note: do not need to readjust fixanced irreversible as done in downpass}							{because irreversible not in uppass}										end;								end;{not N^.fix; if N^.fix then leave as is}						end;					InUpPassTraced(N^.lf);					InUpPassTraced(N^.rt);				end;		end;  {@@@@@@@@@  RECURSION}	begin {main of UpPassTraced..................................}		if allowCursorChange then Setcursor(UpPassCurs);		if NP = R then			R^.up := R^.down;		itype := typeofChar(i);		lenpl := 0; {dummy variable to absorb length increments}		InUpPassTraced(NP);	end; {UpPassTraced}{==================================================================================}{==================================================================================}	procedure TriplePassTraced (NP: Nptr);{FROZEN 3.0}{Assigns final state sets for the traced character, for}{all character types except user-defined}		var			ststemp, belowset, ancpref: largestsetchars;			itype: integer;{....................................................}		procedure TripleInternalGutsTraced (N: Nptr);{FROZEN 3.0}{Deals with internal nodes}		begin		{initially, final state is set to downstate.}		{For some cases, such as the root node, nodes with}		{fixed states and fixanced terminals, this assignment will be left as is}		{For most others, it will be modified}			N^.final := N^.down;			ancpref := N^.anc^.final; {note that if N=R this will not be used}			if not N^.fixanc then		{Node not fixed (filtered out in recursive section)}		{and not fixanc.}		{This is the simplest case.  }				begin {============================= SIMPLE ==========}					if itype = dollo then			{For dollo use special procedure to combine }			{left and right downsets, node's downset, and final set of ancestor}						N^.final := FinalCombineDollo(N^.lf^.down, N^.rt^.down, N^.down, ancpref, N = R, i)					else if N <> R then {if N=R then just use N^.down as initialized above}						TripleCombineCore(N^.final, N^.lf^.down, N^.rt^.down, N^.up, ancpref, itype);					{null anc no problem since N^.anc^.final used only for irrev, fisher}				end			else				begin  {N^.fixanc}					Nfixanced := TermofFixanc(N);					NNotFixanced := DescOfFixanc(N);					if (itype = fisher) then						begin		{Note: fisher characters treated as fixancedbyuncertain even if fixancedbypoly}		{because need to allow non-minimal values assigned to fixancednode}							if (N <> R) or (FixancedByPolymorphic(N, i)) then								begin									if FixancedByPolymorphic(N, i) and (N = R) then										ancpref := N^.down;									if FixancedbyMissing(N, i) then										TripleFixancedByUncertain(N^.final, NNotFixanced^.down, [0..charmaxstDef(i)], ancpref, itype)									else										TripleFixancedByUncertain(N^.final, NNotFixanced^.down, GetTaxonStsLargest(Nfixanced^.name, i), ancpref, itype);								end;						end					else if N <> R then {if N=R then just use N^.down as initialized above}						begin							if FixancedbyMissing(N, i) then		{Note that Fixancedbymissing can fall with triple operators under}		{simple even though there are only two nodes to combine, because missing downstates of fixed}		{terminal will be innocent identity operators}								TripleCombineCore(N^.final, N^.lf^.down, N^.rt^.down, N^.up, ancpref, itype) {null anc no problem since N^.anc^.final used only for irrev, fisher}							else if FixancedByUncertain(N, i) then								begin									if itype = dollo then										Newerror(31, i) {fixanced and dollo not allowed.  warning here just in case}									else if (N <> R) then										begin											if (itype <= ordered) then												ancpref := N^.up;											TripleFixancedByUncertain(N^.final, NNotFixanced^.down, GetTaxonStsLargest(Nfixanced^.name, i), ancpref, itype);										end;								end; {if fixancedby polymorphic or monomorphic then states are left as they are from down}						end;				end;		end;{....................................................}		procedure TripleTerminalGutsTraced (N: Nptr);{FROZEN 3.0}{Deals with terminal nodes; needed whenever terminal is uncertain or missing}		begin			N^.final := N^.down;			lenpl := 0;  {dummy variable to absorb length increase}			if Qtaxon(N, i) | (MStaxon(N, i) and not (itype = dollo)) then{if missing data or multiple states, state assigned}				begin {this deals with Dollo only if missing entirely, in which TerminalFilterCore just asigns pref from below}					if PartOfPolytomy(N) and not polyreal then				{if ancestor is soft polytomous, state assigned by uppass preference from below, not anc's state if soft poly}						TerminalFilterCore(N^.final, PolyCalcs(N, i, itype, up, lenpl, tracedtrue) + [Ftl], gettaxonstsLargest(N^.name, i), itype)					else {otherwise assign ancestor's state}			{assumes irrev will fall here because no nulls}						TerminalFilterCore(N^.final, NotNullAnc(N)^.final, gettaxonstsLargest(N^.name, i), itype);				end			else if itype = dollo then				begin			{need to reassign here because N^.final cannot be left as downstate}			{because the latter is packed in the special dollo format}					ststemp := ZeroHighBitsLg(gettaxonstslargest(N^.name, i));					if MultipleStatesLg(ststemp) then				{uncertain or polymorphic state; assign state in range of those observed closest to state below}						N^.final := ClosestInAtoB(SpanLg(ststemp), N^.anc^.final, dollo)					else						N^.final := ststemp;				end;		end;{....................................................}		procedure InTriplePassTraced (Nq: Nptr); {@@@@@@@ RECURSION @@@@@@@}{FROZEN 3.0}		begin			if (NodeIsInternal(Nq)) then				begin {Internal node}					if not Nq^.null then						begin							if Nq^.fix then								Nq^.final := Nq^.fixsts							else if NodeIsPolytomous(Nq) then								begin									lenpl := 0;									if Nq = R then										Nq^.final := Nq^.down									else if not POLYREAL then						{soft polytomy, thus calculate final on internode just below Nq from up and down}										StSetOpLargest(Nq^.final, Nq^.down, Nq^.up, itype, lenpl)									else						{hard polytomy, thus calculate final using triple version of Polycalcs}										Nq^.final := PolyCalcs(Nq, i, itype, triple, lenpl, tracedtrue)								end							else								TripleInternalGutsTraced(Nq);						end;					InTriplePassTraced(Nq^.lf);					InTriplePassTraced(Nq^.rt);				end			else {terminal node}				begin					if Nq^.fix then						Nq^.final := Nq^.fixsts					else if not Nq^.fixanc then						TripleTerminalGutsTraced(Nq);				end;		end; {@@@@@@@ RECURSION}	begin {main of TriplePassTraced...........................}		if allowCursorChange then Setcursor(TriplePassCurs);		itype := typeofchar(i);		InTriplePassTraced(NP);	end; {TriplePassTraced}end.