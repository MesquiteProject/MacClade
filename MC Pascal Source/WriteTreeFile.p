unit WriteTreeFile;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, 		UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, 		TaxonCHUtil, Thermos, CharUtil, TreeUtil, CHUNK, ReadWriteUtil, ReadUtil, WriteUtil;	procedure WriteTreeBlock (theChain: Integer);	procedure SaveTreeFile;	procedure SaveTreeFileAs;	function QuerySaveTreeFile (whichclose: str255): boolean;	function ClosetreeFile (whichclose: str255):boolean;{еееееееееееееееееееееее}implementation{----------------------------------------------------------------------------}	procedure WriteTree (packedH: handle);    {converts packed tree to parenthesis strings, writing to file}		var			oldState: SignedByte;			packedP: ptr;			thisnode: Integer;			ds: str255;{..............}		procedure WriteTaxonToken (nameofN: integer);		begin			if not includeTranslate then				begin					ds := TaxonName(nameofN);					PrepareToken(ds, tnw);					PutToken(ds)				end			else				PutToken(StringFromNum(nameofN))		end;{..............}		procedure WriteTreeRec;			var				nameofN: integer;		begin			thisnode := thisnode + 1;			nameofN := GetPackedNode(packedP, thisnode);			if (nameofN > 0) then  {terminal not fixanced}				WriteTaxonToken(nameofN)			else				begin					if (nameofN = 0) or (nameofN = nullpacked) then						begin							if (nameofN = 0) then								putSingleChar('(');							WriteTreeRec;							putSingleChar(',');							WriteTreeRec;							if (nameofN = 0) then								putSingleChar(')');						end					else						begin  {fixanc}							putSingleChar('(');							if (nameofN < 0) then								begin									WriteTreeRec;									putSingleChar(')');									WriteTaxonToken(-nameofN);								end;						end;				end;		end;{..............}	begin		LockHandle(PackedH, oldstate);		packedP := StartOfPackedTree(0, 0, PackedH);		thisnode := 0;		WriteTreeRec;		putSingleChar(';');		ResetHandle(PackedH, oldstate);	end;{----------------------------------------------------------------------------}	procedure WriteTrees (theChain: Integer);		var			theLink: longint;			packH: Handle;			ds: str255;			tempP: WindowPtr;			oldState: SignedByte;			writeRooted: boolean;	begin		writeRooted := ((TreeOrUTree = tutAsTypes) & anydirected) | (TreeOrUTree = tutRooted);		if thechain = treefilechain then			begin				ThermoAbortable := false;				TotWriteUnits := UserLinks[treefilechain];				WriteUnit := 0;				StartThermo(iothermo, tempP, 0, TotWriteUnits, 'Writing Trees', 'percent', true);			end;		LockHandle(strCHUNKs[theChain], oldstate);		for theLink := StartUserLink(theChain) to EndUserLink(theChain) do			begin				if ErrorFlag then					Exit(WriteTrees);				WriteUnit := WriteUnit + 1;				UpdateThermo(iothermo, 0, WriteUnit, TotWriteUnits,true);				putTab;				if fullNEXUS1 then   {v3.05}					puttoken('TREE ')				else if writeRooted then					puttoken('TREE ')				else					puttoken('UTREE ');				if theLink = DefaultLink[theCHAIN] then					puttoken(' * ');				ds := LinkNameFromChain(theCHAIN, theLink);				PrepareToken(ds, 255);				puttoken(ds);				puttoken(' =  ');				if writeRooted then					puttoken('[&R] ')				else					puttoken('[&U] ');				packH := HdlPtr(GetMaster(strCHUNKs[thechain]) + HdlSize * ord4(theLink))^;				WriteTree(packH);				putReturn;			end;		ResetHandle(strCHUNKs[theChain], oldstate);		if thechain = treefilechain then			begin				ThermoAbortable := true;				EndThermo(iothermo, tempP, false);			end;	end;{-----------------------------------------------------------------------------}	procedure WriteTreeBlock (theChain: Integer);		label			1;		var			theNexusBlock: NexusBlockPtr;			ds: str255;			j: integer;			{treecom: integer;}			whichText: integer;{..........}		procedure WriteTranslationLine (it: integer);		begin			putTab;			putTab;			puttoken(StringFromNum(it));			putTab;			ds := TaxonName(it);			PrepareToken(ds, tnw);			puttoken(ds);		end;{..........}	begin		if infoOpen[treeinfo] & infoEditing[treeinfo] then			ReturnInfoValue(treeinfo);		if thechain = treefilechain then			begin				{treecom := treefilecom;}				whichText:= aboutTreeFileText;				treesblock := treefileblock;			end		else			begin				treesblock := treesDataBlock;				whichText:= aboutTreesText;				{treecom := treedatacom;}			end;		if (UserLinks[thechain] > 0) | ForeignLinesInBlock(treesblock)   then			begin				SetCursID(tree);				PuttokenReturn('BEGIN TREES; ');				if textWindowInfo[whichText]^.TE^^.teLength > 0 then					begin						putReturn;						puttoken('[!');						WriteTE(textWindowInfo[whichText]^.TE, true);						putSingleChar(']');					end;				theNexusBlock := NexusBlockFromBlockType(treesblock);				WriteNexusBlockTitle(theNexusBlock);				WriteNexusBlockLinkText(theNexusBlock);				putReturn;{==== TRANSLATION TABLE ===}				if includeTranslate then					begin						putTab;						PuttokenReturn('TRANSLATE');						for j := 1 to numtaxa - 1 do							begin								WriteTranslationLine(j);								putSingleChar(',');								putReturn;								if ErrorFlag then									Exit(WriteTreeBlock);							end;						WriteTranslationLine(numtaxa);						putReturn;						putTab;						putSingleChar(';');					end;{==== TREES ====}				putReturn;				WriteTrees(thechain);				WriteForeignLinesInBlock(treesblock);{manual note: there may be problems if includetranslate is false, and yet foreign lines exist,}{for no translation table will be written for their benefit; of course, the same is true if }{someone changes the taxon order, etc in the matrix}				putReturn;				putEndofBlock;1:			end;	end;{-----------------------------------------------------------------------------}	procedure WriteTreeFile;	begin		StartWrite;		puttokenReturn('#NEXUS ');		putReturn;		WriteTreeBlock(treefilechain);		EndWrite;		dirtytreefile := false;	end;{----------------------------------------------------------------------------}	procedure SaveTreeFileAs;		label			1;		var			theInfo: FInfo;			thefile: integer;			justcreated, oldexists: BOOLEAN;			writename: str255;			Freply: StandardFileReply;			oldstate: SignedByte;	begin		oldexists := false;		LockHandle(treefilename, oldstate);		if treefile & treeFileSaved then			PutStandardFile('Save tree file as', FDI^[treeFileFDI].fs.name, Freply)		else			PutStandardFile('Save tree file as', 'Untitled Trees',  Freply);		ShowCursor;		if Freply.sfgood then			begin				FDI^[treeFileFDI].fs := Freply.sffile;  {this is the ultimate destination}				FSpCreateSaveFile(FDI^[treeFileFDI].fs, oldexists, 'CLAD', 'TEXT');  					{this creates the file into which things are directly saved, and stores FSSPec in					FDI^[extraIOFileFDI].fs AND FDI^[writeFileFDI].fs.					If the ultimate destination file does not exist, then this save file is simply the 					ultimate destination file.  If it *does* exist, then the save file is a new temporary file and the oldexists flag is set.}			end		else			Errorflag := true;		if errorflag then			goto 1;		{29Augе  treeWorkingDirectoryNumber := Freply.sffile.vrefnum;}		FDI^[treeFileFDI].fs.name := Freply.sffile.Name;		treefilename^^:=Freply.sffile.Name;				if not treefile then			DataToTreeChain;		WriteTreeFile;		if errorflag then			goto 1;		if oldexists then			FSpExchangeFilesDeleteTemp(FDI^[treeFileFDI].fs)		else 			FDI^[treeFileFDI].fs := FDI^[writefileFDI].fs;		if ErrorFlag then			goto 1;		treefile:=true;		if ErrorFlag then			goto 1;		FSpSetFileCreatorType(FDI^[treeFileFDI].fs, 'CLAD', 'TEXT');		FSpStampCLAD(FDI^[treeFileFDI].fs);		treeFileLastModified := FSpLastModified(FDI^[treeFileFDI].fs);		treefileSaved := true;1:		ResetHandle(treefilename, oldstate);	end;{-----------------------------------------------------------------------------}	procedure SaveTreeFile;		label			1;		var			tfile: integer;			theInfo: FInfo;			writename: str255;			db: boolean;			curLastMod: longint;			oldstate: signedbyte;	begin		if not treefile | not treefileSaved then			SaveTreeFileAs		else			begin				LockHandle(treefilename, oldstate);				curLastMod := FSpLastModified(FDI^[treeFileFDI].fs);				if errorflag then					goto 1;				if curLastMod <> treefileLastModified then					if not CWarning('Warning! Tree file has been modified by another program after it was opened by MacClade.  Do you want to replace it by saving?', ' Save ', ' Cancel ') then						begin							errorFlag := true;							goto 1;						end;				FSpCreateSaveFile(FDI^[treeFileFDI].fs, db, 'CLAD', 'TEXT');				if errorflag then					goto 1;								WriteTreeFile;								if errorflag then					goto 1;				FSpExchangeFilesDeleteTemp(FDI^[treeFileFDI].fs);				if errorflag then					goto 1;				if alwaysCLAD then					begin						FSpSetFileCreatorType(FDI^[treeFileFDI].fs, 'CLAD', 'TEXT');						FSpStampCLAD(FDI^[treeFileFDI].fs);					end;				treeFileLastModified := FSpLastModified(FDI^[treeFileFDI].fs);				treefileSaved := true;1:				ResetHandle(treefilename, oldstate);			end;	end;{----------------------------------------------------------------------------}	function QuerySaveTreeFile (whichclose: str255): boolean;{returns true if cancel button is NOT hit}		var			localItemHit: integer;	begin{$IFC NOT DEMO}		QuerySaveTreeFile := true;		if dirtytreefile and (UserLinks[treefilechain] > 0) then			begin				ParamText(concat('Save tree file before ', whichclose), '', '', '');				localItemHit := DoAlert(256, CautionA);				if (localItemHit = 1) then					SaveTreeFile;				QuerySaveTreeFile := (localItemHit <> 3) and not errorflag;			end;{$ELSEC}		QuerySaveTreeFile := true;{$ENDC}	end;{----------------------------------------------------------------------------}	function CloseTreeFile (whichclose: str255):boolean;	begin		CloseTreeFile := false;		if QuerySaveTreeFile(whichclose) then			begin				CloseTextWindowIfOpen(aboutTreeFileText, true);				if charton & ((CWChart = CWCC2T) | (CWTrees[CWChart] = CWStoredTrees)) then					if CWarning('Closing the tree file will force the chart to close.', 'Continue', 'Cancel') then						PleaseOffChart := true					else						Exit(CloseTreeFile);				if infoEditing[treeinfo] then					TurnOffInfoEditing(treeinfo);				InvalidateWindow(infoWindow[treeinfo],true);				if treefile and WindowVisible(textWindow[aboutTreeFileText]) then					begin						InvalidateWindow(textWindow[aboutTreeFileText], true);						InvalidateWindow(textWindow[aboutTreesText], true);					end;				treefile := false;				treeFileSaved := false;				treeChain := DatafileChain;				dirtytreefile := false;  {v3.02}{    dirtytree := true;  v4: set to true only if dirtytree or file from treefile has been chosen}				SetDirtyTree;				InvalidateWindow(tlegwindow, true);				CloseTreeFile := true;			end;	end;end.