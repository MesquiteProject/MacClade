unit FileMenu;{еееееееееееееееееееееее}interface	uses		Printing, QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, 		Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, 		Scrap,  Globals, SetLibInterface, UtilLibInterface,  Traps, Balloons, MemoryUtil,		CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, AppleTalk, PPCToolBox, 		Processes, Notification, EPPC, AppleEvents, TaxonCHUtil, BranchListWindow, 		ChartWWrite, StrUtil, TreeUtil, ImpForeignFiles, TypeUtil, WriteDataUtil,		CharUtil, LaserTree, EditUtilMenu, WriteUtil, PICT, ClickInInfoWindow, 		SpreadUtil, LinkUtil, Export, ChartMenu, ChartWindow, StatsMenu, TreeMaker, 		Windows, Fonts, PrintingUtil, PrintingMisc, DoPrint, WriteData, GenCloseFile, GenOpenFile, 		TreeMenu, TraceMenu, EditMenu, CharactersMenu, DisplayMenu, Settings, BoxUtil, 		About, Equivocal, ChartWWrite, StatusNotes, InfoWindows, ChartWText,		TextWindows, NexusBlocks, StatesWindow;	procedure CloseWindowPtr(theWindow: WindowPtr; canQuery,directWindowClosedRequest: boolean);	procedure DoSaveOptionsMenu (ItemNo: integer);	function CheckQuitfromAppleEvent: boolean;	procedure DoFileMenu (ItemNo: integer);	function QueryCloseFile(getAnotherFile: boolean): boolean;{еееееееееееееееееееееее}implementation {е$S ProcessMenu}{-----------------------------------------------------------------------------}	procedure CalcProbabilities;	var probFile: text;		isTo,isFrom: integer;		mu, kappa: double;	begin		rewrite(probFile, 'TransProbs');		kappa := 4.5;  {value from primate mtDNA}		write(probFile, 'kappa: ');		writeln(probFile, kappa);		writeln(probFile, ' ');		writeln(probFile, 'Q Matrix');		for isFrom := 0 to 3 do			for isTo := 0 to 3 do				begin				end;		writeln(probFile, ' ');				close(probFile);	end;{-----------------------------------------------------------------------------}	procedure prefInfo (theDialog: DialogPtr; itemNo: Integer);	begin		FrameButton(theDialog, 1);		DrawResourceTEXT(theDialog, 19, 128);		DrawResourceTEXT(theDialog, 12, 129);		DrawResourceTEXT(theDialog, 13, 130);		DrawResourceTEXT(theDialog, 14, 131);		if deftype >= usedef then			DimBox(GetDLOGItemBox(theDialog, 15));	end;{-----------------------------------------------------------------------------}	procedure OtherPreferences;		var			theDialog: DialogPtr;			defitem: integer;			tempP, tport: WindowPtr;			tempH: Handle;			box: rect;			localItemHit, j: integer;			prefset: set of 0..11;			ds: str255;			canDoDefType: boolean;UserItemUProcP: UniversalProcPtr;	begin		StartDLOG(140, theDialog, tempP);		prefset := [];		if useoldPunct then			begin				prefset := prefset + [10];				ItemCheckMark(theDialog, 10, true);			end;		box := GetDLOGItemBox(theDialog, 16);UserItemUProcP := MyNewUserItemUPP(@prefinfo);  tempH := Handle(UserItemUProcP);		SetDialogItem(theDialog, 17, UserItem, tempH, box);		if molecular then HideDialogItem(theDialog,11);		SetDLOGText(theDialog, 15, TypeName(deftype), false);		canDoDefType := deftype < usedef;		if not canDoDefType then			EnableDisableDLOGItem(theDialog, 6, false, false);		case datatype of			DNA: 				ds := 'DNA';			RNA: 				ds := 'RNA';			protein: 				ds := 'protein';			standard: 				ds := 'standard';			standard32: 				ds := 'extended';			otherwise				;		end;		SetDLOGText(theDialog, 16, ds, false);		myShowDialog(theDialog);		repeat			ModalDialog(nil, localItemHit);			if localItemHit in [3..11, 15, 16] then				begin					if (localitemhit = 15) & canDoDefType then						localitemhit := 6;					if (localitemhit = 16) then						localitemhit := 7;					if localitemhit <= 11 then						if localitemhit in prefSet then							prefSet := prefSet - [localitemhit]   {remove it}						else							prefSet := prefSet + [localitemhit];  {add it}				end;			for j := 3 to 8 do				ItemCheckMark(theDialog, j, j in prefSet);			ItemCheckMark(theDialog, 10, 10 in prefSet);			ItemCheckMark(theDialog, 11, 11 in prefSet);		until localItemHit in [1, 2];MyDisposeUserItemUPP(UserItemUProcP);		EndDLOG(theDialog, tempP);		if localitemHit = 1 then			begin				if 3 in prefSet then  {editor}					begin						StoreSettingsCommandFromIDIntoH(programSettings,setEditorID);						StoreSettingsCommandFromIDIntoH(programSettings,editorToolsID);						StoreSettingsCommandFromIDIntoH(programSettings,autoAlignOptionsID);						StoreSettingsCommandFromIDIntoH(programSettings,bothToolsID);						StoreSettingsCommandFromIDIntoH(programSettings,undoWarningID);						StoreSettingsCommandFromIDIntoH(programSettings,editorToolsPositionID);					end;				if 4 in prefSet then  {tree window}					begin						StoreSettingsCommandFromIDIntoH(programSettings,treewinid);						StoreSettingsCommandFromIDIntoH(programSettings,setTreeWindowID);						StoreSettingsCommandFromIDIntoH(programSettings,treeToolsID);						StoreSettingsCommandFromIDIntoH(programSettings,treeToolsPositionID);						StoreSettingsCommandFromIDIntoH(programSettings,bothToolsID);						StoreSettingsCommandFromIDIntoH(programSettings,chLegPositionID);						StoreSettingsCommandFromIDIntoH(programSettings,treeLegPositionID);						StoreSettingsCommandFromIDIntoH(programSettings,TreeFontID);					end;				if 5 in prefSet then					StoreSettingsCommandFromIDIntoH(programSettings,chartid);				if 7 in prefSet then					StoreSettingsCommandFromIDIntoH(programSettings,formatid);				if 6 in prefSet then					StoreSettingsCommandFromIDIntoH(programSettings,deftypeid);				if 8 in prefSet then					StoreSettingsCommandFromIDIntoH(programSettings,calcid);				useOldPunct := 10 in prefSet;				if 11 in prefSet then					StoreSettingsCommandFromIDIntoH(programSettings,symbolsID);				StoreSettingsCommandFromIDIntoH(programSettings,useOldPunctID);				WriteNexusPreferencesFile(false);			end;	end;{-----------------------------------------------------------------------------}	procedure WriteGraphicsFile;		var			ChartPicH: picHandle;			tport: WindowPtr;	begin{$IFC DEMO}		if not IsTreeWindow(frontwindow) then			begin				InstantInfo('You cannot save graphics files with this demonstration version of MacClade.');				Exit(WriteGraphicsFile);			end;{$ENDC}		if frontwindow = nil then			Beep		else if IsTreeWindow(frontwindow) then			LaserTree(treeOutputToGraphicsFile)		else if frontwindow = chartwindow then			begin				savepicton := true;				genericGetPort(tport);				genericSetPort(ChartWindow);				ClipRect(WindowPortRect(chartWindow));				ChartPicH := OpenNewPicture(WindowPortRect(chartWindow));				DrawChartWindow(WindowPortRect(chartWindow));				ClosePicture;				PutPICT(ChartPicH);				KillPicture(ChartPicH);				genericSetPort(tport);				savepicton := false;			end		else if frontwindow = pictwindow then			PutPICT(grabpicture);	end;{-----------------------------------------------------------------------------}	procedure DoNEXUSOptions;		var			theDialog: DialogPtr;			oldxInt1: integer;			oldTreeOrUtree: integer;			tinterleave, tconsensus, tabbrev, tincludeTranslate: boolean;			oldwriteTaxaCharBlocks, oldLinearCharLabels, oldSpaceEveryTenth: BOOLEAN;			oldinterleaveLength: integer;			oldWriteEndBlock: boolean;			oldfullNexus1: boolean;			j: integer;			tempP: WindowPtr;			ds: str255;			tempH: Handle;			box: rect;			localItemHit: integer;{..............}		procedure CheckNexusOptions;		begin			ItemCheckMark(theDialog, 4, interleave);			ItemCheckMark(theDialog, 8, saveAbbrevHeader);			ItemCheckMark(theDialog, 9, TreeOrUTree = tutRooted);			ItemCheckMark(theDialog, 10, TreeOrUTree = tutUnRooted);			ItemCheckMark(theDialog, 11, TreeOrUTree = tutAsTypes);			ItemCheckMark(theDialog, 13, includeTranslate);			ItemCheckMark(theDialog, 16, NexusDelim = ExpCR);			ItemCheckMark(theDialog, 17, NexusDelim = ExpLF);			ItemCheckMark(theDialog, 18, NexusDelim = ExpCRLF);			ItemCheckMark(theDialog, 15, writeTaxaCharBlocks);			ItemCheckMark(theDialog, 20, not singleCharNamePerLine);			ItemCheckMark(theDialog, 21, SpaceEveryTenth);{ItemCheckMark(theDialog, 22, writeEndBlock);  v3.03: writeEndblock added   v3.05: removed}			ItemCheckMark(theDialog, 22, fullNexus1);  {v3.05: fullNexus1 added}		end;{..............}		procedure RecordEditItemsNex;		begin			if interleave then				begin					j := EditTextInt(theDialog, 5,true);					if (j > 0) and (j <= 32000) then						begin							interleavelength := j;							interleave := true;						end					else						interleave := false;				end;		end;{..............}	begin		oldSpaceEveryTenth := SpaceEveryTenth;		oldTreeOrUtree := TReeOrUtree;		oldinterleaveLength := InterleaveLength;		oldwriteTaxaCharBlocks := writeTaxaCharBlocks;		oldlinearCharLabels := singleCharNamePerLine;{		oldWriteEndBlock := writeEndBlock;}		oldfullNexus1 := fullNexus1;		tinterleave := interleave;		tabbrev := saveAbbrevHeader;		tincludeTranslate := includeTranslate;		StartDLOG(137, theDialog, tempP);		SetDLOGText(theDialog, 5, StringFromNum(interleavelength), false);		if editorTransposed then			interleave := false;		CheckNexusOptions;		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			case localItemHit of				4: 					interleave := not interleave;				5: 					if not editorTransposed then						interleave := true;				8: 					saveAbbrevHeader := not saveAbbrevHeader;				9: 					TreeOrUTree := tutRooted;				10: 					TreeOrUTree := tutUnRooted;				11: 					TreeOrUTree := tutAsTypes;				13: 					includeTranslate := not includeTranslate;				16: 					NexusDelim := ExpCR;				17: 					NexusDelim := ExpLF;				18: 					NexusDelim := ExpCRLF;				14: 					begin						RecordEditItemsNex;						SetDialogValuesAsDefaults(theDialog, Nexusoptionsid, 0, 0);					end;				15: 					writeTaxaCharBlocks := not writeTaxaCharBlocks;				20: 					singleCharNamePerLine := not singleCharNamePerLine;				21: 					SpaceEveryTenth := not SpaceEveryTenth;{    22: writeEndBlock := not writeEndBlock;}				22: 					fullNexus1 := not fullNexus1;				otherwise					;			end;			CheckNexusOptions;		until localItemHit in [1, 2];		if localItemHit = 2 then			begin				singleCharNamePerLine := oldlinearCharLabels;				interleave := tinterleave;				saveAbbrevHeader := tabbrev;				TreeOrUTree := oldTReeOrUtree;				includeTranslate := tincludeTranslate;				writeTaxaCharBlocks := oldwriteTaxaCharBlocks;				interleaveLength := oldInterleaveLength;				SpaceEveryTenth := oldSpaceEveryTenth;{				writeEndBlock := oldWriteEndBlock;}				fullNexus1 := oldfullNexus1;			end		else			begin				RecordEditItemsNex;			end;		EndDLOG(theDialog, tempP);		if (writeTaxaCharBlocks <> oldwriteTaxaCharBlocks) & (infoOpen[nexusblockinfo]) then			begin				AdjustAllNexusBlockWillWrites;				InvalidateInfoWindow(nexusblockinfo);			end;		if (fullNexus1 <> oldfullNexus1) & (infoOpen[nexusblockinfo]) then			begin				SetContinuousBlockName;				InvalidateInfoWindow(nexusblockinfo);			end;	end;{-----------------------------------------------------------------------------}	var		expfiletype: integer;{----------------------------------------------------------------------------}	function GetFileType (menuitem: integer): integer;	begin		case menuitem of			1: 				GetFileType := NBRF;			2: 				GetFileType := phylip;			3: 				GetFileType := simpletext;			4: 				GetFileType := descriptions;			5: 				GetFileType := HTMLmatrix;			6: 				GetFileType := hennig;			7: 				GetFileType := nona;			8: 				GetFileType := MEGA;			9: 				GetFileType := malign;			10:				GetFileType := fasta;			otherwise				GetFileType := nbrf;		end;	end;{----------------------------------------------------------------------------}	function GetFileTypeMenu (filetype: integer): integer;	begin		case filetype of			NBRF: 				GetFileTypeMenu := 1;			phylip: 				GetFileTypeMenu := 2;			simpletext: 				GetFileTypeMenu := 3;			descriptions: 				GetFileTypeMenu := 4;			htmlMatrix:				GetFileTypeMenu := 5;			hennig: 				GetFileTypeMenu := 6;			nona: 				GetFileTypeMenu := 7;{$IFC MEGA}			mega: 				GetFileTypeMenu := 8;   {v3.05}{$ENDC}			malign:				GetFileTypeMenu := 9;			fasta:				GetFileTypeMenu := 10;			otherwise				GetFileTypeMenu := 1;		end;	end;		{----------------------------------------------------------------------------}	procedure SynchFileDelimiters;	begin		ExportDelimiter[NBRFnogaps] := ExportDelimiter[nbrf];	end;{-----------------------------------------------------------------------------}	procedure WriteOptionsUser (theDialog: DialogPtr; itemNo: Integer);		var			box: rect;			ds: str255;	begin		box := GetDLOGITemBox(theDialog, 15);		GetMenuItemText(ExpDelMHdl, GetFileTypeMenu(expfiletype), ds);		DrawPopUpRect(box, ds);		FrameButton(theDialog, 1);	end;{----------------------------------------------------------------------------}	procedure PopUpExportMenu (theDialog: DialogPtr);		var			box: rect;			spot: point;			menucode: longint;			ItemNo: integer;	begin		box := GetDLOGITemBox(theDialog, 15);		spot.v := box.top;		spot.h := box.left;		LocalToGlobal(spot);		menucode := PopUpMenuSelect(ExpDelMHdl, spot.v, spot.h, GetFileTypeMenu(expFileType));		ItemNo := LowWord(menucode);		if ItemNo > 0 then			expFileType := GetFileType(ItemNo);		WriteOptionsUser(theDialog, 1);	end;{-----------------------------------------------------------------------------}	procedure DoSaveOptions;		var			theDialog: DialogPtr;			oldExportDelimiter: ExportDelimType;			twriteExpon, talwaysCLAD, tnonCLADwarn: boolean;			oldSaveCanvas: BOOLEAN;			oldpictCreator: OSType;			j: integer;			tempP: WindowPtr;			ds: str255;			tempH: Handle;			box: rect;			localItemHit: integer;UserItemUProcP: UniversalProcPtr;{..............}		procedure CheckSaveOptions;		begin			ItemCheckMark(theDialog, 6, alwaysCLAD);			ItemCheckMark(theDialog, 7, nonCLADwarn);			ItemCheckMark(theDialog, 8, WriteExpon);			ItemCheckMark(theDialog, 10, ExportDelimiter[expfiletype] = ExpCR);			ItemCheckMark(theDialog, 11, ExportDelimiter[expfiletype] = ExpLF);			ItemCheckMark(theDialog, 12, ExportDelimiter[expfiletype] = ExpCRLF);{    ItemCheckMark(theDialog, 29, saveCanvas);}		end;{..............}		procedure RecordEditItems;		var j: integer;		begin			ds := GetEditText(theDialog, 5);			pictCreator := 'ttxt';  			if length(ds) >= 4 then				for j:= 1 to 4 do				    pictCreator[j] := ds[j];		end;{..............}	begin		ExpDelMHdl := GetMenu(ExpDelMenu);		InsertMenu(ExpDelMHdl, -1);		expfiletype := nbrf;		oldExportDelimiter := ExportDelimiter;		oldpictCreator := PictCreator;		talwaysCLAD := alwaysCLAD;		twriteExpon := WriteExpon;		tnonCLADwarn := nonCLADwarn;{    oldsaveCanvas := saveCanvas;}		StartDLOG(346, theDialog, tempP);		ds := pictcreator;		SetDLOGText(theDialog, 5, ds, true);		CheckSaveOptions;		box := GetDLOGITemBox(theDialog, 15);UserItemUProcP := MyNewUserItemUPP(@writeoptionsuser);  tempH := Handle(UserItemUProcP);		SetDialogItem(theDialog, 15, UserItem, tempH, box);		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			case localItemHit of				6: 					alwaysCLAD := not alwaysCLAD;				7: 					nonCLADwarn := not nonCLADwarn;				8: 					WriteExpon := not WriteExpon;				10: 					ExportDelimiter[expfiletype] := ExpCR;				11: 					ExportDelimiter[expfiletype] := ExpLF;				12: 					ExportDelimiter[expfiletype] := ExpCRLF;				14: 					begin						RecordEditItems;						SetDialogValuesAsDefaults(theDialog, saveoptionsid, 0, 0);					end;				15: 					PopUpExportMenu(theDialog);{    29: saveCanvas := not saveCanvas;}				otherwise					;			end;			CheckSaveOptions;		until localItemHit in [1, 2];		if localItemHit = 2 then			begin{    saveCanvas := oldsaveCanvas;}				alwaysCLAD := talwaysCLAD;				nonCLADwarn := tnonCLADwarn;				writeExpon := tWriteExpon;				ExportDelimiter := oldExportDelimiter;				pictCreator := oldPictCreator;			end		else			RecordEditItems;MyDisposeUserItemUPP(UserItemUProcP);		EndDLOG(theDialog, tempP);		ZapMenu(ExpDelMenu,ExpDelMHdl);		AdjustAllNexusBlockWillWrites;		SynchFileDelimiters;	end;{----------------------------------------------------------------------------}	procedure DoSaveOptionsMenu (ItemNo: integer);	begin		case ItemNo of			NEXUSItem: 				DoNexusOptions;			SaveOptOtherItem: 				DoSaveOptions;			otherwise				;		end;	end;{----------------------------------------------------------------------------}	function OnlyMacCladeWindowOpen(whichWindow: WindowPtr): boolean;	var numWindows: integer;		theWindow: WindowPtr;	begin		theWindow := frontwindow;		if treeopen or editorOpen then numWindows := 1 else numWindows := 0;		while (theWindow <> nil) {& (numWindows <= 1)} do			begin				if MacCladeWindow(theWindow) then					if not LockedToTreeWindow(theWindow) & not IsEditorWindow(theWindow) & WindowVisible(theWindow) then						numWindows := numWindows + 1;				theWindow := myGetNextWindow(theWindow);			end;		OnlyMacCladeWindowOpen := (numWindows <= 1) {& not IsPaletteWindow(whichWindow)};	end;{----------------------------------------------------------------------------}	procedure StoreFrontWindows;		var			j: integer;	begin		oldfrontW[0] := frontwindow;		j := 0;		while (j < numfrontW) & (oldfrontW[j] <> nil) & LockedToTreeWindow(oldfrontW[j]) do			begin				j := j + 1;				oldfrontW[j] := myGetNextWindow(oldfrontW[j - 1]);			end;		numFW := j - 1;	end;{----------------------------------------------------------------------------}	function QueryCloseFile(getAnotherFile: boolean): boolean;	var userCancelled: boolean;	begin		QueryCloseFile := false;		if QuerySaveFiles('closing?') then   {Cancel wasn't hit OR is demo version}			begin				CloseUp;				if getAnotherFile then					GetFile(userCancelled);				QueryCloseFile := true;			end;	end;{----------------------------------------------------------------------------}	function CheckQuitfromAppleEvent: boolean;	begin		CheckQuitfromAppleEvent := true;		if fileopen then			begin				if QuerySaveFiles('quitting?') then					quit := true				else					CheckQuitfromAppleEvent := false;			end		else 			quit := true;		end;{-----------------------------------------------------------------------------}	procedure CloseWindowPtr(theWindow: WindowPtr; canQuery,directWindowClosedRequest: boolean);	var db: boolean;	begin	if canQuery & not (directWindowClosedRequest & IsPaletteWindow(theWindow)) & OnlyMacCladeWindowOpen(theWindow)  then 		db := QueryCloseFile(true)	else		if IsPaletteWindow(theWindow) & directWindowClosedRequest then			ClosePaletteWindow(WhichPaletteWindow(theWindow))		else if IsEditorWindow(theWindow) then			begin				CloseEdit(true);				if badcellentry then					Exit(CloseWindowPtr);				if (not dirtyfile) & newfile then  					CloseUp;			end		else if LockedToTreeWindow(theWindow) then  			CloseTreeWindow(true)		else if IsInfoWindow(theWindow) then			CloseInfoWindow(WhichInfoWindow(theWindow))		else if IsTextWindow(theWindow) then			CloseTextWindow(WhichTextWindow(theWindow),true)		else if theWindow = BranchListwindow then			CloseBranchListWindow		else if (theWindow = statesWindow) then			CloseStatesWindow		else if theWindow = ChartWindow then			CloseChartWindow		else if theWindow = pictwindow then			ClosePictWindow		else if theWindow=chartWindow then			CloseChartWindow;	end;	{----------------------------------------------------------------------------}	procedure DoFileMenu (ItemNo: integer);		label			1;		var			ds: Str255;			db: boolean;			success:boolean;			userCancelled: boolean;	begin		case ItemNo of			NewItem: 				StartNewFile;			OpenItem: 				GetFile(userCancelled);			CloseFileItem: 				db := QueryCloseFile(true);								CloseWindowItem:		//		CalcProbabilities;								CloseWindowPtr(frontwindow, true,false);			RevertItem: 				if not newfile then					begin						if treefile then							ds := ' (tree file will be closed)?'						else							ds := '?';						if CWarning(concat('Are you sure you want to revert to saved version of file', ds), 'Revert', 'Cancel') then							begin								CloseUp;								fileopen := true;								BeginFile(true,success, userCancelled);							end;					end;			SaveDataItem, SaveDataAsItem: 				begin{$IFC DEMO}					InstantInfo('You cannot save files with this demonstration version of MacClade.');{$ELSEC}{$IFC NOT LOCKCONTROL}					if Locked(lockSaving) & (ItemNo=SaveDataItem) then						begin							InstantInfo('You do not have permission to save this file.');							goto 1;						end;{$ENDC}					saveAsStationery := OptionEvent(Event) and (ItemNo = SaveDataAsItem);					if editorSelected and editorOpen and SingleCell then						begin							ReturnValue(editorSelectionTopLeft,false);							if badcellentry then								if BadCellEntryQuery then									DiscardCellChanges								else									goto 1;						end;					ReturnAllInfoValues;					if statesWindowOpen then						begin							TurnOffSymbolsEditing;							TurnOffStatesEditing;						end;					ReturnNexusBlockText;					if editorOpen and dirtymaxst then						ReCalcMaxstAndStates(1,numchars);					if ItemNo = SaveDataItem then						SaveFile					else						SaveAsFile;{$ENDC}				end;			PageSetUpItem: 				if OptionEvent(Event) then					SetDefaultPrintRecord(true)				else					DoPageSetUp;			PrintingItem: 					DoPrint(frontWindow);							PrintExtraItem:{$IFC DEMO}						InstantInfo('You cannot print with this demonstration version of MacClade.');{$ELSEC}				if frontWindow=statesWindow then					DoPrintAllNames				else if treeopen then					DoPrint(treewindow)				else if editorOpen then					PrettyPrintData;{$ENDC}			GraphicFileItem: 				WriteGraphicsFile;			PreferenceItem: 				if ControlEvent(Event) then					ZeroErrorSet(errorsturnedoff)				else if OptionEvent(Event) then					WriteNexusPreferencesFile(true)				else					OtherPreferences;			QuitItem: 				begin					quit := True;					if fileopen then						begin							if QuerySaveFiles('quitting?') then								CloseUp							else								quit := false;						end;				end;			otherwise				;		end;1:	end;end.