unit TypeUtil;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  		MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, TaxonCHUtil;	function GettypeHdl (typ: integer): typeHandle;	function TypeisReal (typnum: integer): boolean;	function TypeOfChar (ic: integer): integer;	function TrueTypeOfChar (ic: integer): integer;	procedure settype (ic, typnum: integer);	procedure TypeStorageToUse (ic: integer);	procedure UseToTypeStorage (ic: integer);	procedure TypeSetExclude (extendH: Handle);	function TypeLegalForChar (typnum, ic: integer): boolean;	function AnyType (queryset: setchars15): BOOLEAN;	function MaxStateDefined (typnum: integer): Integer;	function MaxStateDefinedAllUseDef (justCurTypes: boolean): integer;	function NumSetDefined (typnum: integer): Integer;	function StatesDistDefined (typnum: integer): largestsetchars;{    function CharDefMaxst (ic: integer): integer;}{    function CharDefSet (ic: integer): largestsetchars;}	procedure UpdateCurTypes;	procedure CheckCurrentTypes;	procedure CheckPolarity (typenumber: Integer);	function PassMetricity (typHDL: typehandle): boolean;	procedure NborToDistance (nbor: neighbortype; maxstar: integer; var dist: distancetype; var mxs: integer; var legalset: largestsetchars);	procedure SetTypeName (typnum: integer; ds: str255);	function TypeName (typnum: integer): str255;	function TypeNameToWrite (typnum: integer): str255;	function Gettypnum (typetoken: str255): integer;	function converttotype (typetoken: str255): integer;	procedure SwitchIncExc (ic: integer);	procedure ReSetFisher;	procedure DoResetTypes;{еееееееееееееееееееееее}implementation {е$S TypeUtil}{-----------------------------------------------------------------------------}	function GettypeHdl (typ: integer): typeHandle;	begin		if (typ = excluded) or (typ > maxtypes) then			GetTypeHdl := nil		else			GettypeHdl := typeHdlPtr(GetMaster(typeCHUNKs) + HdlSize * (typ - 1))^;	end;{----------------------------------------------------------------------------}	function TypeisReal (typnum: integer): boolean;{returns true iff type is a realtype, that is, it contains real values}	begin		if typnum = excluded then			TypeisReal := false		else			TypeisReal := GettypeHdl(typnum)^^.isreal;	end;{----------------------------------------------------------------------------}	function TypeKind (typnum: integer): integer;{returns type of type, using the following conventions:}		const			cst = 0;			csg = 1;			stepmatrix = 2;			fishertype = 3;	begin{    TypeKind := GettypeHdl(typnum)^^.typeKind;}{v4 note: not used yet; to be used in version 4 !!!}	end;{|||||||||||||||||||||||||||||||||||||||||||||  Types and characters  ||||||||||||||||||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	function TypeOfChar (ic: integer): integer;{returns type number of character ic; note will return excluded type number}	begin		TypeOfChar := IP(GetMaster(chtypH) + chtb * longint(ic - 1))^;	end;{-----------------------------------------------------------------------------}	function TrueTypeOfChar (ic: integer): integer;{returns underlying type number of character ic; works for excluded characters}	begin		TrueTypeOfChar := IP(GetMaster(chstoretypH) + chtb * longint(ic - 1))^;	end;{-----------------------------------------------------------------------------}	procedure settype (ic, typnum: integer);		var			intp: IP;	begin		intp := IP(GetMaster(chtypH) + chtb * longint(ic - 1));		intp^ := typnum;	end;{-----------------------------------------------------------------------------}	procedure TypeStorageToUse (ic: integer);		var			intp: IP;	begin		intp := IP(GetMaster(chtypH) + chtb * longint(ic - 1));		intp^ := IP(GetMaster(chstoretypH) + chtb * longint(ic - 1))^;	end;{-----------------------------------------------------------------------------}	procedure UseToTypeStorage (ic: integer);		var			intp: IP;	begin		intp := IP(GetMaster(chstoretypH) + chtb * longint(ic - 1));		intp^ := IP(GetMaster(chtypH) + chtb * longint(ic - 1))^;	end;{-----------------------------------------------------------------------------}	procedure TypeSetExclude (extendH: Handle); {sets type of all excluded characters to excluded}{works on chtypH, chstoretypH, not raw links, as this procedure presumes no leading bytes & name}		var			ic: integer;			intP: IP;	begin{v4: make faster as for wtsetexclude}		for ic := 1 to numchars do			begin				intP := IP(GetMaster(extendH) + chtb * longint(ic - 1));				if not CharIncluded(ic) then					intP^ := excluded;			end;	end;{-----------------------------------------------------------------------------}	function AnyType (queryset: setchars15): BOOLEAN;{returns true if any member of the queryset is a currently used type; usedef is in}{queryset, then true if anygenchar}	begin		AnyType := (queryset * curtypes <> []) | ((usedef in queryset) & anygenchar);	end;{----------------------------------------------------------------------------}{----------------------------------------------------------}	function MaxStateDefined (typnum: integer): Integer;{returns the maximum state number "defined" or "allowed" for type typenum}	begin		if (typnum >= dollo) & (typnum <= numtypes) then			begin				typeHdl := gettypehdl(typnum);				MaxStateDefined := typeHdl^^.max;			end		else			MaxStateDefined := maxstate;	end;{-----------------------------------------------------------------------------}	function MaxStateDefinedAllUseDef (justCurTypes: boolean): integer;		var			j, curmax, maxdist: integer;	begin		maxdist := MOS;		for j := usedef to numtypes do			if not justCurTypes | (j in curtypes) then				begin					curmax := MaxStateDefined(j);					if curmax > maxdist then						maxdist := curmax;				end;		MaxStateDefinedAllUseDef := maxdist;	end;{----------------------------------------------------------}	function NumSetDefined (typnum: integer): Integer;{returns the total number of states "defined" or "allowed" for type typenum}	begin		NumSetDefined := cardLg(StatesDistDefined(typnum));	end;{----------------------------------------------------------}	function StatesDistDefined (typnum: integer): largestsetchars;{returns the set of states "defined" or "allowed" for type typenum}	begin		if (typnum >= dollo) & (typnum <= numtypes) then			begin				typeHdl := gettypehdl(typnum);				StatesDistDefined := typeHdl^^.setdefined * [0..maxstate];			end		else			StatesDistDefined := [0..maxstate];	end;{|||||||||||||||||||||||||||||||||||||||||||||  Checking Types  ||||||||||||||||||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	procedure UpdateCurTypes;		var			ic: integer;	begin		curtypes := [];		for ic := 1 to numchars do			curtypes := curtypes + [typeofchar(ic)];		curtypes := curtypes - [excluded];	end;{-----------------------------------------------------------------------------}	procedure CheckCurrentTypes;{checks all current types, and records if any of them are }{		user-defined ->  sets anygenchar}{		directed  ->  sets anydirected}{		real  ->  sets realtypes}{also checks to see if any types are illegal for the nature of the characters and tree, }{and resets them to unordered or the deftype}		var			ic, j: integer;			olddir: boolean;			ctyp: integer;	begin		Curtypes := [];		olddir := anydirected;		anydirected := false;		anygenchar := false;		realtypes := false;{==== checking legality of characters ====}		for ic := 1 to numchars do			begin				ctyp := typeofchar(ic);				if (ctyp <> excluded) then					begin						if ((ctyp = Dollo) & nucleotides) then {Note that this only checks D}							begin								if deftype = Dollo then									begin										deftype := unordered;										NewError(397, 0);									end;								NewError(362, ic);								ctyp := deftype;								SetType(ic, ctyp);								UsetoTypeStorage(ic);							end;						if ((ctyp >= Dollo) & ((CharMaxstOBS(ic) > GetTypeHdl(ctyp)^^.max) | not (CharStatesLargest(ic) <= GetTypeHdl(ctyp)^^.setdefined))) then {Note that this only checks D & User-defined}							begin								if ((CharMaxstOBS(ic) > GetTypeHdl(deftype)^^.max) | not (CharStatesLargest(ic) <= GetTypeHdl(deftype)^^.setdefined)) | (nodes & nullson & (deftype >= irreversible)) then									ctyp := unordered								else									ctyp := deftype;								NewError(33, ic);								SetType(ic, ctyp);								UsetoTypeStorage(ic);							end;						curtypes := curtypes + [ctyp];					end;			end;{==== checking nature of types ====}		for j := 1 to numtypes do			begin				typeHdl := GetTypeHdl(j);				if j in curtypes then					begin						if (j >= usedef) then							anygenchar := true;						if typeHdl^^.polar then							anydirected := true;						if typeHDL^^.isreal then							realtypes := true;						typeHdl^^.inuse := true;					end				else					typeHdl^^.inuse := false;			end;		if treeopen and (olddir <> anydirected) then			InvalidateWindow(twmesswindow, false);		CheckInflate;	end;{----------------------------------------------------------}	procedure CheckPolarity (typenumber: integer);		label			1;		var			TH: TypeHandle;			isfrom, isto, themax: integer;			dir: boolean;	begin		dir := false;		TH := GetTypeHdl(typenumber);		themax := TH^^.max;		if TH^^.root < 0 then			for isfrom := 0 to themax do				for isto := isfrom to themax do					if TH^^.dist[isfrom, isto] <> TH^^.dist[isto, isfrom] then						begin							dir := true;							goto 1;						end;1:		TH^^.polar := dir;	end;{-----------------------------------------------------------------------------}	function PassMetricityASM (distP: ptr; setdef: largestsetchars; maxdef: integer): boolean;	begin	{Wayne: v3.5 DELETE}	end;{-----------------------------------------------------------------------------}	function PassMetricity (typHDL: typehandle): boolean;	label 1;		var			ia, ib, ic: integer;			check: boolean;			ddist: distancetype;			maxdef: integer;			setdef: lgsetchars;			tname: string[typesig];	begin		tname := typHdl^^.name;		if GetTypNum(tname) >= usedef then			begin				ddist := typHDL^^.dist;				maxdef := typHDL^^.max;				Setdef := NewSetFromOld(typHDL^^.setdefined);				{v 3.5: this used to be in assembly in v. 3.0X}				{PassMetricity := PassMetricityASM(@ddist, setdef, maxdef)}				{left as pascal, but more more efficient lgsetchars and Enset used}				check := true;				for ia := 0 to maxdef do					if Enset(ia, setdef) then						for ib := 0 to maxdef do							if Enset(ib, setdef) then								for ic := 0 to maxdef do									if Enset(ic, setdef) then										if GenLessThan(AddGEndist(ddist[ia, ib], ddist[ib, ic]), ddist[ia, ic]) then											begin												check := false;												goto 1;											end;1:				PassMetricity := check;			end		else			PassMetricity := true;	end;{|||||||||||||||||||||||||||||||||||||||||||||  Neighbor to Distance  ||||||||||||||||||||||||||||||||||||||||||||||}{----------------------------------------------------------}	procedure NborToDistance (nbor: neighbortype; maxstar: integer; var dist: distancetype; var mxs: integer; var legalset: largestsetchars);{given a neighbor matrix nbor, returns the corresponding distance matrix}		var			ir, ic, scount: integer;{...................}		procedure DistancefromIC (ic, iat, ifrom: integer);			var				ir: integer;		begin			scount := scount + 1;			for ir := 0 to maxstar do				if ir in (Nbor[iat] - [ifrom]) then					begin						if ir <= maxstate then							begin								if (ir > mxs) then									mxs := ir;								dist[ic, ir] := scount;							end;						if Nbor[ir] - [iat] <> [] then							DistanceFromIC(ic, ir, iat);					end;			scount := scount - 1;		end;{...................}	begin		legalset := [];		for ir := 0 to maxstate do			for ic := 0 to maxstate do				if ir = ic then					dist[ir, ir] := 0				else					dist[ic, ir] := infinity;		mxs := 0;		for ic := 0 to maxstate do			begin				if not (Nbor[ic] <= [ic]) then					legalset := legalset + [ic];				sCount := 0;				DistanceFromIC(ic, ic, ic);			end;	end;{|||||||||||||||||||||||||||||||||||||||||||||  Type Names and Numbers  ||||||||||||||||||||||||||||||||||||||||||||||}{----------------------------------------------------------------------------}	procedure SetTypeName (typnum: integer; ds: str255);	begin 	end;{----------------------------------------------------------------------------}	function TypeName (typnum: integer): str255;{returns name of type}	begin		if typnum = excluded then			TypeName := 'excluded'		else			TypeName := GettypeHdl(typnum)^^.name;	end;{----------------------------------------------------------------------------}	function TypeNameToWrite (typnum: integer): str255;{returns the name of the type typnum as it is to be written to the file}		var			tn: str255;	begin		case typnum of			unordered: 				tn := 'unord';			ordered: 				tn := 'ord';			irreversible: 				tn := 'irrev';			fisher: 				tn := 'strat';			dollo: 				tn := 'Dollo';			otherwise				begin					tn := TypeName(typnum);					PrepareToken(tn, typesig);				end;		end;		TypeNameToWrite := tn;	end;{-----------------------------------------------------------------------------}	function Gettypnum (typetoken: str255): integer;{given the name, typetoken, of a type, returns the number}{of that type}		var			typnum, it: integer;			sigtoken, frontpart: str255;{    testtoken: string[typesig];}			perioddeleted: boolean;	begin		typnum := 0;		sigtoken := MakeSmall(CopyString(typetoken, 1, typesig));		UnderLIneToBlanks(sigtoken);		if pos('.', sigtoken) > 0 then   			{delete period and everything following it}{v3.05: there is a problem with just deleting everything after a period, as someone might legitimately want}{to name a type xxx.yyy.  So, what to do?  We could have it in the nexus standard that this is not}{allowed.  But this seems rather restrictive. Perhaps have it that if the part in front of the name}{is a standard type name, then delete the extension, otherwise leave it alone.  That is what is done.}			begin				frontpart := CopyString(sigtoken, 1, pos('.', sigtoken) - 1);				if (frontpart = 'unord') or (frontpart = 'ord') or (frontpart = 'irrev') or (frontpart = 'strat') or (frontpart = 'dollo') then					begin						InstantErrorPlus(246, concat(CopyString(sigtoken, pos('.', sigtoken), length(sigtoken)), '" in "', sigtoken, '"'));						delete(sigtoken, pos('.', sigtoken), length(sigtoken) - pos('.', sigtoken) + 1);						if readon then							openAsUntitled := true;						perioddeleted := true;					end;			end		else			perioddeleted := false;		if sigtoken = 'unord' then			typnum := unordered		else if sigtoken = 'ord' then			typnum := ordered		else if (sigtoken = 'irrev') then			typnum := irreversible		else if (sigtoken = 'strat') then			typnum := fisher		else if (sigtoken = 'dollo') then			typnum := Dollo		else			begin				if perioddeleted then		{'reinsert' the period, by recovering sigtoken from the original typetoken}					begin						sigtoken := MakeSmall(CopyString(typetoken, 1, typesig));						UnderLIneToBlanks(sigtoken);					end;				for it := usedef to numtypes do					if sigtoken = MakeSmall(TypeName(it)) then						begin							typnum := it;							leave;						end;			end;		gettypnum := typnum;	end;{----------------------------------------------------------------------------}	function ConvertToType (typetoken: str255): integer;{as for gettypnum, but also gives warning if couldn't find type}{v4: should just pass warn: boolean to gettypenum}		var			typnum: integer;	begin		typnum := gettypnum(typetoken);		if typnum = 0 then			begin				InstantErrorPlus(153, typetoken);				typnum := deftype;			end;		converttotype := typnum;	end;{-------------------------------------------------------------------------}	function TypeLegalForChar (typnum, ic: integer): boolean;	begin		if typnum = excluded then			Typelegalforchar := true		else if nodes & (((typnum >= irreversible) & nullson) | ((typnum >= dollo) & ancon)) then			TypeLegalForChar := false		else if (typnum >= dollo) & (typnum <= numtypes) then {!!!}			begin				typeHdl := gettypehdl(typnum);				TypeLegalForChar := (CharMaxstOBS(ic) <= typeHdl^^.max) & (CharStatesLargest(ic) <= TypeHdl^^.setdefined);			end		else			TypeLegalForChar := CharMaxstOBS(ic) <= maxstate;	end;{----------------------------------------------------------------------------}	procedure SwitchIncExc (ic: integer);		var			charHdl: chHdl;	begin		charHdl := chHdlPtr(GetMaster(chCHUNKs) + HdlSize * longint(ic - 1))^;		if charHdl^^.deleted then 		{including character}			begin				charhdl^^.deleted := false;				WtStorageToUse(ic);				TypeStorageToUse(ic);				if not TypeLegalForChar(TypeofChar(ic), ic) then   {can use TypeOfChar as TypeStorageToUse just called}					begin						NewError(41, ic);						charhdl^^.deleted := true;						SetType(ic, excluded);					end;			end		else											{excluding character}			begin				charhdl^^.deleted := true;				UseToWtStorage(ic);				UseToTypeStorage(ic);				SetType(ic, excluded);				UseToPartStorage(ic);			end;	end;{-----------------------------------------------------------------------------}	procedure ReSetFisher;		var			isfrom, isto: integer;	begin{this is also in StartupUtil but must be called with every file opening}		typeHdl := typeHdlPtr(GetMaster(typeCHUNKs) + HdlSize * (Fisher - 1))^;		for isfrom := 0 to absmaxstate do			for isto := 0 to absmaxstate do				if isfrom > isto then					typeHdl^^.dist[isfrom, isto] := infinity				else					typeHdl^^.dist[isfrom, isto] := (isto - isfrom) * TypeInflate;		typeHdl^^.isreal := true;  {note this fills in entire matrix; read assumption block fills only just off diagonal}	end;{-----------------------------------------------------------------------------}	procedure DoResetTypes;		var			isfrom: integer;			it: integer;	begin		typeHdl := getTypeHdl(unordered);		typeHdl^^.maxstar := maxstate;		typeHdl^^.isreal := false;		typeHdl^^.max := maxstate;		typeHdl^^.setdefined := [0..maxstate];		typeHdl := getTypeHdl(ordered);		typeHdl^^.maxstar := maxstate;		typeHdl^^.isreal := false;		typeHdl^^.max := maxstate;		typeHdl^^.setdefined := [0..maxstate];		typeHdl^^.nbors[0] := [1];		for isfrom := 1 to maxstate - 1 do			typeHdl^^.nbors[isfrom] := [isfrom - 1, isfrom + 1];		typeHdl^^.nbors[maxstate] := [maxstate - 1];		for isfrom := maxstate + 1 to maxCS do			typeHdl^^.nbors[isfrom] := [];		typeHdl := getTypeHdl(fisher);		typeHdl^^.maxstar := maxstate;		typeHdl^^.isreal := true;		if maxstate > typeHdl^^.max then			for isfrom := typeHdl^^.max + 1 to maxstate do				typeHdl^^.dist[isfrom - 1, isfrom] := typeInflate;		typeHdl^^.max := maxstate;		typeHdl^^.setdefined := [0..maxstate];		typeHdl := getTypeHdl(irreversible);		typeHdl^^.maxstar := maxstate;		typeHdl^^.isreal := false;		typeHdl^^.max := maxstate;		typeHdl^^.setdefined := [0..maxstate];		typeHdl := getTypeHdl(Dollo);		typeHdl^^.isreal := false;		if numbytes = 2 then			begin				typeHdl^^.maxstar := 2;				typeHdl^^.max := 2;				typeHdl^^.setdefined := [0..2];			end		else if numbytes = 4 then			begin				typeHdl^^.maxstar := 7;   {v4: global constants!!!}				typeHdl^^.max := 7;				typeHdl^^.setdefined := [0..7];			end;		for it := usedef to numtypes do			begin				typeHdl := gettypeHdl(it);				typeHdl^^.setdefined := typeHdl^^.setdefined * [0..maxstate];				if typeHdl^^.max > maxstate then typeHdl^^.max := maxstate;				if typeHdl^^.maxstar > maxstate then typeHdl^^.maxstar := maxstate;			end;	end;end.