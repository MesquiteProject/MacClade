unit LaserTree;{еееееееееееееееееееееее}interface	uses		Printing, QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, BoxUtil, TypeUtil, StrUtil, Settings, TreeUtil, TraceAllChangesCalc, LaserCommands, MenuUtil, Prohibitions, CharUtil, taxonchutil, BranchListwindow, Count, TreeGet, PICT, Coloring, TreeDrawer, Fonts, PrintingUtil, PrintingMisc, LaserTreeUtil, LaserDLOGDraw, LaserTreeFilter, LaserPrint, LaserDraw;	procedure LaserTree (treeOutput: integer);		const 		treeOutputToPrinter=0;		treeOutputToGraphicsFile =1;		treeOutputToClipBoard = 2;{еееееееееееееееееееееее}implementation {е$S LaserTree}//	procedure LaserTree (treeOutput: integer); begin end;	var		wasBranchListmode, wassummaryview: integer;			wasticksNoNames, wasTickStates, wasTickBoxes, wasTickNames: boolean;{----------------------------------------------------------------------------}	procedure InitPrOptions;	begin		EnableDisableItem(PrOptionsMHdl, PrTicks, (traceshown = traceAllChanges) or (traceshown = traceDiscrete) or (traceshown = traceContinuous));		EnableDisableItem(PrOptionsMHdl, PrBranchLengths, (traceshown = traceAllChanges));		EnableDisableItem(PrOptionsMHdl, PrEquiv, ((traceshown = traceDiscrete) & (resolveoption = allpossible) & EquivocalLegal(screenR)) and LaserTreePrint and not equivcycle);		EnableDisableItem(PrOptionsMHdl, PrWhichChars, (traceshown = traceDiscrete) and LaserTreePrint and not equivcycle and (numchars > 1));	end;{-----------------------------------------------------------------------------}	procedure ChangeToAngleTree;	var nodesH: longint;	begin		SetTreeshape(slanttree);		laser^.square := false;		nodesH := CalcNodesH;		if topmargin + nodesH > (fulltreeframe.bottom - 50) then			begin				laser^.versp := (laser^.versp * (fulltreeframe.bottom - topmargin - 50)) div nodesH;				laser^.txsp := laser^.versp;				MakeSpacingsEven;			end;		InvalidateWindowRect(myGetWindowPtrForDialog(LaserTreeDialog),previewB,false);	end;{-----------------------------------------------------------------------------}	procedure PrintDataBoxesNOW;		var			tempP: WindowPtr;			theDialog: DialogPtr;			horpg, vertpg, j, ic, it{%%%, pgwidth, pgheight}: Integer;			db: boolean;			box: rect;	begin		if not ChooseFontDLOG then			Exit(printDataBoxesNow);		genericGetPort(tempP);		ic := 1;		printDataBoxesInColor := CWarning('Print data boxes in color or black and white?','Color', 'B & W');		if OpenPrinter(true) then			begin				if StartPrinting(true) then					begin						box := printPageR;						SetPrintFonts;						CalcPgSizes(pgWidth, pgHeight);						ic := 1;						it := 1;						if PrepareDocument then							repeat								if NoPrinterError then									PrintDataBoxesTree(ic, pg, pgheight, pgwidth, false);							until ((PrinterError) or (ic > numchars));						EndPrint;						printPageR := box;					end;				PrintCancelOff;				ClosePrinter;			end;		printDataBoxesInColor := false;				genericSetPort(tempP);		InvalidateWindowRect(myGetWindowPtrForDialog(LaserTreeDialog),previewB,false);  {v3.02: this added}	end;{----------------------------------------------------------------------------}	procedure TransferGlobalsToLasers;	begin		newlaser^.ticksNoNames := ticksNoNames;		newlaser^.tickstates := tickstates;		newlaser^.tickboxes := tickboxes;		newlaser^.ticknames := ticknames;		laser^.summaryview := summaryview;	end;{----------------------------------------------------------------------------}	procedure SetLaserLikeTreeWindow;	var adjustLengths: boolean;		changesHeight: longint;	begin		newlaser^.ticksNoNames := wasticksNoNames;		newlaser^.tickstates := wasTickStates;		newlaser^.tickboxes := wasTickBoxes;		newlaser^.ticknames := wasTickNames;		laser^.summaryview := wassummaryview;		ticksNoNames := newlaser^.ticksNoNames;		tickstates := newlaser^.tickstates;		tickNames := newlaser^.tickNames;		tickBoxes := newlaser^.tickBoxes;		summaryview := laser^.summaryview;		if not squarebranches & not laser^.treeshape[slanttree] & not (laser^.printbranchlengths) then			ChangeToAngleTree		else if squarebranches & not laser^.treeshape[squaretree] then			ChangeToSquareTree;		if squarebranches & (traceshown = traceAllChanges) then			begin				adjustLengths := not laser^.printbranchlengths & showbranchlengths & (summaryview = asticks);				laser^.printbranchlengths := showbranchlengths;				if adjustLengths then					begin						AutoPrintTreeTicksHeighten;						laser^.pixelperchg := laser^.LPPCvalue;						// laser^.LPPCConstant := true;						changesHeight := treechangeheight(0, 1);						{if not closeupon then							laser^.versp := TruncateValue(shrink * (laser^.LPPCvalue * changesheight) / (LaserBoxes^[treeB].R.bottom - LaserBoxes^[treeB].R.top) * laser^.versp)						else							laser^.versp := TruncateValue(1.0 * (laser^.LPPCvalue * changesheight) / (LaserBoxes^[treeB].R.bottom - LaserBoxes^[treeB].R.top) * laser^.versp);						}						laser^.versp := TruncateValue(1.0 * (laser^.LPPCvalue * changesheight) / (ScreenR^.loc.v - topmargin) * laser^.versp);						if laser^.versp < 1 then							laser^.versp := 1;													MakeSpacingsEven;					{    	if not closeupon then							LaserBoxes^[treeB].R.bottom := LaserBoxes^[treeB].R.top + TruncateValue(shrink * (laser^.LPPCvalue * changesheight))						else							LaserBoxes^[treeB].R.bottom := LaserBoxes^[treeB].R.top+ laser^.LPPCvalue * changesheight;					}					end;			end;		laser^.branchShades[curTrace] := oldBranchShades[curTrace];		branchShades[curTrace] := laser^.branchShades[curTrace];		InvalidateWindowRect(myGetWindowPtrForDialog(LaserTreeDialog),previewB,false);	//	wasBranchListmode: integer;	end;{----------------------------------------------------------------------------}	procedure RememberLaser;	begin		TransferGlobalsToLasers;		laser^.starts[treeB].h := TSP.h;		laser^.starts[treeB].v := TSP.v;		laserTreeInit := true;		if PaintedBranches or ((traceshown = traceAllChanges) and not (summaryview = asblack)) or (traceshown = traceProbability) then			laser^.LaserTreeLegendInit := true;		tlaser^ := laser^;    		tlaserboxes^ := laserboxes^;	end;{----------------------------------------------------------------------------}	procedure LaserTree (treeOutput: integer);		label			1;		const			slc = 400;		var			j, k, nodesH, whichRow: longint;			tempP: WindowPtr;			tempH: Handle;			H: Handle;			B, box: rect;			oldedw, oldi, tempi: integer;			db, doneone: boolean;			localItemHit: integer;			oldrootsize: integer;			oldambigdistinguish: boolean;UserItemUProcP: UniversalProcPtr;DLOGFilterUPP: UniversalProcPtr;	begin		oldambigdistinguish := ambigdistinguish;		hasprinted := false;		laser^.numbernodes := shownodenumbers;		laser^.showEvolveSegments := showEvolveSegments;		laser^.showEvolveRealLengths := showEvolveRealLengths;		fliptree := true;		if ((traceshown = traceDiscrete) or (traceshown = traceAllChanges) or (traceshown = traceProbability) or (traceshown = traceContinuous) or laser^.numbernodes or laser^.showEvolveSegments or laser^.showEvolveRealLengths) and laser^.treeshape[circletree] then			begin				laser^.treeshape[circletree] := false;				laser^.treeshape[slanttree] := true;				laser^.square := false;			end;		if not (traceshown = traceDiscrete) then			laser^.printequiv := false;		SetAngleControlStarts;		oldbranchShades := branchShades;		oldrootsize := rootsize;		LaserTreePrint := (treeOutput=treeOutputToPrinter);		PrOptionsMHdl := GetMenu(PrOptionsMenu);		InsertMenu(PrOptionsMHdl, -1);		ShadesMHdl := GetMenu(ShadesMenu);		InsertMenu(ShadesMHdl, -1);		pleaseWriteBottom := false;		alreadydone := false;		justmag := false;		printon := true;		if not (traceshown = traceAllChanges) then			begin				laser^.printbranchlengths := false;{laser^.scaleon := false;}			end;		if SizeofClade(screenR, true) < 2 then			begin				InstantError(257);				Exit(LaserTree);			end;		genericSetPort(treewindow);		LaserCommentSH := StringHandle(NewHandle(SizeOf(str255)));		LaserCommentSH^^ := '';		tlaser := LaserPtr(NewPtr(Sizeof(lasertype)));		tlaserBoxes := LaserBoxesArrayPtr(NewPtr(SizeOf(LaserBoxesArray)));		if OpenPrinter(true) then			begin				printerOSStatus := ValidatePageFormat;				GetPrintPage;				db := CheckPrinterError(true);				CleanUpValidation;				ClosePrinter;			end;		InitPrOptions;	{	InitTreeBits;}{note this used to be as below, which caused the tree not to be printed if the dirtylink[treechain] was false}{because numtreeschosen at -1 bypasses tree printing}{    if dirtylink[treeChain] then numtreeschosen := 0 else numtreeschosen := -1;}		if (frontwindow=infoWindow[treeinfo]) then			begin				numtreeschosen := NumberInfoRowsSelected(treeinfo);				curtreechosen := InfoRowSelected(treeinfo,InfoRowOfCurrentObject(treeinfo));			end		else			begin				numtreeschosen := 0;				curtreechosen := true;			end;{    if not dirtytree then  MarkTreeBit(linknumber[treechain] - StartUserLink(treechain), true);}		oldi := i;		wasBranchListmode := BranchListmode;		wassummaryview := summaryview;		wasticksNoNames := ticksNoNames;		wasTickStates := tickstates;		wasTickNames := tickNames;		wasTickBoxes := tickBoxes;		ticksNoNames := newlaser^.ticksNoNames;		tickstates := newlaser^.tickstates;		tickNames := newlaser^.tickNames;		tickBoxes := newlaser^.tickBoxes;		summaryview := laser^.summaryview;		if not SummaryViewPrintLegal(summaryview) then			summaryview := asblack;		GetPrintPage;		treepicture := nil;{    laser^.showbox[treestatsB] := count or calcCI or calcRI or calcRC or showminsteps or showmaxsteps;}		laser^.showbox[legB] := defLaserShowCHLeg & (PaintedBranches | (traceshown = traceAllChanges) | (traceshown = traceProbability));{v3.02: added defLaserShowCHLeg so that turning off legB would "hold" inbetween invocations of PrintTree}		oldedw := edw;		LaserCursor := LaserArrow;		closeupon := false;		doneone := false;		oldtime := event.when;		SetAngleControlBox;		for j := 1 to numLaserCursors do			SetRect(LaserCursorR[j], slc + (j - 1) * 21, 4, slc + j * 21, 4 + 21);		SetRect(previewB, 70, 29, 380, 284);		tlaser^ := laser^;		tlaserboxes^ := LaserBoxes^;{----- setting up positions of things -----}		if (oldnumLaserTaxa <> ntscreen) | not LaserTreeInit | pageSetupChanged then    {number of taxa has changed, reset positions of things}			SetPreviewRects(true){note that if a different character has been traced, with different numbers}{of states, the chlegend may extend below the image...; user can use home button to fix}		else			begin{    if not laser^.LaserTreeLegendInit then}				LegendBoxPosition(true);				firsttx := laser^.starts[treeB].h;				topmargin := laser^.starts[treeB].v;			end;		oldnumLaserTaxa := ntscreen;		StartDLOG(326, LaserTreeDialog, tempP);		if (treeOutput=treeOutputToGraphicsFile) then			begin				HideControl(controlHandle(GetDLOGItemHandle(LaserTreeDialog, LPICTItem)));				HideControl(controlHandle(GetDLOGItemHandle(LaserTreeDialog, LDataBoxesItem)));{    HideControl(controlHandle(GetDLOGItemHandle(LaserTreeDialog, LPageSetUpItem)));}				SetButtonTitle(LaserTreeDialog, LPrintItem, 'PICT file...');				savepicton := true;			end		else if (treeOutput=treeOutputToClipBoard) then			begin				HideControl(controlHandle(GetDLOGItemHandle(LaserTreeDialog, LPICTItem)));				HideControl(controlHandle(GetDLOGItemHandle(LaserTreeDialog, LDataBoxesItem)));				HideControl(controlHandle(GetDLOGItemHandle(LaserTreeDialog, LClipItem)));{    HideControl(controlHandle(GetDLOGItemHandle(LaserTreeDialog, LPageSetUpItem)));}				SetButtonTitle(LaserTreeDialog, LPrintItem, 'Clipboard');				savepicton := true;			end;		LaserTreeParamText;				with laser^ do			begin				treeshapeB[slanttree] := GetDLOGItemBox(LaserTreeDialog, LSlantItem);				treeshapeB[squaretree] := GetDLOGItemBox(LaserTreeDialog, LSquareItem);				treeshapeB[eurotree] := GetDLOGItemBox(LaserTreeDialog, LEuroItem);				treeshapeB[circletree] := GetDLOGItemBox(LaserTreeDialog, LCircleItem);			end;		BranchWidthB := GetDLOGItemBox(LaserTreeDialog, LBranchWidthItem);		otherBranchWidthB := GetDLOGItemBox(LaserTreeDialog, LOtherBranchWidthItem);UserItemUProcP := MyNewUserItemUPP(@LaserUser);  tempH := Handle(UserItemUProcP);		SetRect(box, 0, 0, 0, 0);		SetDialogItem(LaserTreeDialog, LUserItem, UserItem, tempH, box);		if not PrinterOK then			begin				EnableDisableDLOGItem(LaserTreeDialog, LPrintItem, not (treeOutput=treeOutputToPrinter), false);				EnableDisableDLOGItem(LaserTreeDialog, LDataBoxesItem, false, false);			end;		EnableDisableItem(ShadesMHdl, 0, colorQDExists);		branchShades[curTrace] := laser^.branchShades[curTrace];		FixPrOptionsMenu;		ShowWindow(myGetWindowPtrForDialog(LaserTreeDialog));{FlushEvents(everyevent, 0); }{ooooooooooooooooooooooooooooo}		DLOGFilterUPP := MyNewModalFilterUPP(@LaserFilter);  		myEnableItem(dlogFontMHdl, 0);   		myEnableItem(dlogStyleMHdl, 0);   		myEnableItem(dlogSizeMHdl, 0);   1:		LaserTreeParamText;					repeat			if goerror then {otherwise problems in treecycling not noted until back in tree window}				ShowErrors('');			myModalDialog(DLOGFilterUPP, localItemHit);			SetButtonTitle(LaserTreeDialog, 2, 'Done');			case localItemHit of				LSlantItem:  {not lasersquare}					if not laser^.treeshape[slanttree] and not (laser^.printbranchlengths) then						ChangeToAngleTree;				LSquareItem:  {lasersquare}					if not laser^.treeshape[squaretree] then						ChangeToSquareTree;				LEuroItem: 					if not laser^.treeshape[eurotree] and not (laser^.printbranchlengths) then						begin							SetTreeshape(eurotree);							laser^.square := true;							InvalidateWindowRect(myGetWindowPtrForDialog(LaserTreeDialog),previewB,false);						end;				LCircleItem: 					if (not laser^.treeshape[circletree] and not ((traceshown = traceAllChanges) or (traceshown = traceDiscrete) or (traceshown = traceContinuous) or (traceshown = traceProbability))) then						begin							SetTreeshape(circletree);							laser^.square := true;							nodesH := CalcNodesH;							if topmargin + nodesH > (fulltreeframe.bottom - 50) then								begin									laser^.versp := (laser^.versp * (fulltreeframe.bottom - topmargin - 50)) div nodesH;									laser^.txsp := laser^.versp;									MakeSpacingsEven;								end;							InvalidateWindowRect(myGetWindowPtrForDialog(LaserTreeDialog),previewB,false);						end;				LClipItem: {$IFC DEMO}				InstantInfo('You cannot use the clipboard with this demonstration version of MacClade.');{$ELSEC}{$IFC NOT CARBON}					if not SystemEdit(CopyItem - 1) then   {this is necessary to notify multifinder what happened}{$ENDC}					begin						DrawTreePicture(fulltreeframe, false, true);						myCutCopyPicture(treepicture);					end; {$ENDC}				LSetItem:    {home button}					begin						SetPreviewRects(true);						InvalidateWindowRect(myGetWindowPtrForDialog(LaserTreeDialog),previewB,false);					end;				LOptionsItem: 					begin						PopUpOptionsMenu(LaserTreeDialog);					end;				LMatchTreeItem:					SetLaserLikeTreeWindow;				LMakeDefaultItem: 					begin						TransferGlobalsToLasers; {v3.04:}						SetDialogValuesAsDefaults(LaserTreeDialog, laserid, 0, 0);					end;				LOtherBranchWidthItem: 					begin						DoOtherBranchWidth;						if PaintedBranches then							DrawBullets(laser^.tracewidth)						else							DrawBullets(laser^.width);					end;				otherwise					;			end;			if goerror then {otherwise problems in treecycling not noted until back in tree window}				ShowErrors('');			FixPrOptionsMenu;		until localItemHit in [1, 2, 3, LDataBoxesItem];{ooooooooooooooooooooooooooooo}		SetCursorToArrow;		if localItemHit <> 2 then			MakeSpacingsEven;		if closeupon then			begin				Closeupon := false;				InvalidateWindowRect(myGetWindowPtrForDialog(LaserTreeDialog),previewB,false);			end;		if (localItemHit = 1) and (treeOutput=treeOutputToPrinter) then			begin{$IFC DEMO}				InstantInfo('You cannot print with this demonstration version of MacClade.');{$ELSEC}				tempi := i;				PrintLaserTree;				if goerror then {otherwise problems in treecycling not noted until back in tree window}					ShowErrors('');				hasprinted := true;				i := tempi; {$ENDC}				InvalidateWindowRect(myGetWindowPtrForDialog(LaserTreeDialog),previewB,false);			end		else if (localItemHit = 3) or ((localItemHit = 1) and  (treeOutput=treeOutputToGraphicsFile)) then			begin{$IFC DEMO}				InstantInfo('You cannot save graphics files with this demonstration version of MacClade.');{$ELSEC}				savepicton := true;				genericSetPort(myGetWindowPtrForDialog(LaserTreeDialog));				DrawTreePicture(fulltreeframe, false, true);				H := NewHandle(2);		{make temporary variable as any dialog redraw would invalidate treepicture}				CopyHandles(Handle(treepicture), H);				PutPICT(PicHandle(H));				ZapHandle(H); {$ENDC}			end		else if  ((localItemHit = 1) and  (treeOutput=treeOutputToClipboard)) then			begin{$IFC DEMO}				InstantInfo('You cannot use the clipboard with this demonstration version of MacClade.');{$ELSEC}{$IFC NOT CARBON}				if not SystemEdit(CopyItem - 1) then   {this is necessary to notify multifinder what happened}					begin{$ENDC}						DrawTreePicture(fulltreeframe, false, true);						myCutCopyPicture(treepicture);{$IFC NOT CARBON}					end;{$ENDC} {$ENDC}			end		else if (localItemHit = LDataBoxesItem) and (treeOutput=treeOutputToPrinter) then			begin{$IFC DEMO}				InstantInfo('You cannot print with this demonstration version of MacClade.');{$ELSEC}				PrintDataBoxesNOW;				hasprinted := true;   {v3.02: added} {$ENDC}			end;		if localItemHit <> 2 then			begin				SetButtonTitle(LaserTreeDialog, 2, 'Done');				doneone := true;				goto 1;			end;MyDisposeModalFilterUPP(DLOGFilterUPP);MyDisposeUserItemUPP(UserItemUProcP);		EndDLOG(LaserTreeDialog, tempP);		RememberLaser;		if treepicture <> nil then			KillPicture(treepicture);		if oldambigdistinguish <> ambigdistinguish then  {v3.04}			godraw := true;		treepicture := nil;		edw := oldedw;		treeonscreen := false;		treedrawn := false;		summaryview := wassummaryview;		ticksNoNames := wasticksNoNames;  {v3.04}		TickStates := wastickstates;		TickNames := wastickNames;		tickBoxes := wastickBoxes;{    if not laser^.treeshape[circletree] then shownodenumbers := laser^.numbernodes; }{    if not laser^.treeshape[circletree] then showEvolveSegments := laser^.showEvolveSegments; }		BranchListmode := wasBranchListmode;		i := oldi;		{DisposeTreeBits;}		ZapPointer(tlaser);		ZapPointer(tlaserboxes);		ZapHandle(LaserCommentSH);		printon := false;		savepicton := false;		oldnumLaserTaxa := ntscreen;		branchShades := oldbranchShades;		DeleteMenu(ShadesMenu);		DeleteMenu(PrOptionsMenu);		rootsize := oldrootsize;		pageSetupChanged := false;	end;end.