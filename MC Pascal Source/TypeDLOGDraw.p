unit TypeDLOGDraw;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, SymbolsNames, TypeUtil, CharUtil, TypeDLOGUtil, CharStateTree;	procedure FillEnterEdit (theDialog: DialogPtr; thevalue: longint);	function RealDisttostring (li: longint): str255;	procedure ShowHideEnter (theDialog: DialogPtr);	procedure ButHilite (theDialog: DialogPtr);	procedure DrawHTypeLabels (boundary: rect);	procedure DrawVTypeLabels (boundary: rect);	procedure DrawTypeMatrixBox (thetype: integer; boundary: rect);	procedure FillTypeMatrix (thetype: integer; boundary: rect; erase: boolean);	procedure ReDrawTypeSpecs (theDialog: DialogPtr; itemNo: INTEGER);	procedure TypeNames (theDialog: DialogPtr; itemNo: INTEGER);	procedure ShowC (theDialog: DialogPtr);{еееееееееееееееееееееее}implementation {е$S TypeDLOGDraw}	const		notetop = 30;{----------------------------------------------------------------------------}	procedure FillEnterEdit (theDialog: DialogPtr; thevalue: longint);		var			ds: str255;	begin		if thevalue = -3 then			ds := ''		else if thevalue = infinity then			ds := 'i'		else if CurTypeHdl^^.isreal then			ds := RealDisttostring(thevalue)		else			NumToString(thevalue, ds);		SetDLOGText(theDialog, 15, ds, true);	end;{-----------------------------------------------------------------------------}	function RealDisttostring (li: longint): str255;	begin		RealDisttostring := concat(StringFromNum(li div TypeInflate), '.', StringFromNum(li mod TypeInflate));	end;{----------------------------------------------------------------------------}	procedure ShowHideEnter (theDialog: DialogPtr);	begin		if showmatrix then			begin				ShowDialogItem(theDialog, 15);				ShowDialogItem(theDialog, TDenter);{   TriangleButton;}			end		else			begin				HideDialogItem(theDialog, 15);				HideDialogItem(theDialog, TDenter);			end;	end;{----------------------------------------------------------------------------}	procedure ButHilite (theDialog: DialogPtr);	begin		if (CurTypeHdl^^.isreal) then			SetButtonTitle(theDialog, TDDiscCont, 'Integral...')		else			SetButtonTitle(theDialog, TDDiscCont, 'Decimal...');		if (CurType = deftype) then			SetButtonTitle(theDialog, TDdefault, 'Not Default')		else			SetButtonTitle(theDialog, TDdefault, 'Set Default');		EnableDisableDLOGItem(theDialog, TDdefault, not ((CurType = deftype) & (curtype = unordered)), false);		if (CurType = fisher) then			SetButtonTitle(theDialog, TDclear, 'Reset')		else			SetButtonTitle(theDialog, TDclear, 'Delete');		EnableDisableDLOGItem(theDialog, TDDiscCont, showmatrix and (CurType >= usedef) and (CurTypeHdl^^.root < 0), false);		EnableDisableDLOGItem(theDialog, TDsize, showmatrix and (CurType >= usedef) and (CurTypeHdl^^.root < 0), false);		EnableDisableDLOGItem(theDialog, TDsym, showmatrix and (CurType >= usedef) and (CurTypeHdl^^.root < 0), false);		EnableDisableDLOGITem(theDialog, TDcopy, (curtype <> dollo) and (curtype <> fisher) and (curtype <= numtypes), false);		EnableDisableDLOGITem(theDialog, TDrename, (curtype >= usedef) and (curtype <= numtypes), false);		EnableDisableDLOGITem(theDialog, TDclear, ((curtype >= usedef) and (curtype <= numtypes)) or (curtype = fisher), false);		EnableDisableDLOGItem(theDialog, TDenter, showmatrix and (CurType >= usedef) and StepCellSel and (curtype <= numtypes), false);		EnableDisableDLOGItem(theDialog, TDcleancheck, showmatrix or (CurType >= usedef), false);		if showmatrix then			SetButtonTitle(theDialog, TDcleancheck, 'Check ╞...')		else			SetButtonTitle(theDialog, TDcleancheck, 'Clean Up')	end;{----------------------------------------------------------------------------}	procedure DrawHTypeLabels (boundary: rect);		var			j: integer;			box: rect;	begin		with boundary do			begin				SetRect(box, left + 3, top - 18, right + 5, top - 2);				EraseRect(box);				for j := 0 to maxdrawmat do					begin						moveto(left + StepCellWidth * j + 3, top - 5);						DrawChar(CharOfNum(htypeStart + j));					end;			end;	end;{----------------------------------------------------------------------------}	procedure DrawVTypeLabels (boundary: rect);		var			j: integer;			box: rect;	begin		with boundary do			begin				SetRect(box, left - StepCellWidth, top, left - 1, bottom);				EraseRect(box);				for j := 0 to maxdrawmat do					begin						moveto(left - StepCellWidth + 1, top + StepCellHeight * j + StepCellHeight - 4);						DrawChar(CharOfNum(vTypeStart + j));					end;			end;	end;{----------------------------------------------------------------------------}	procedure DrawTypeMatrixBox; {(thetype: integer; boundary: rect)}		var			j: integer;	begin		typeHdl := GetTypeHdl(thetype);		if printon then			begin				vTypeStart := 0;				hTypeStart := 0;			end;		with boundary do			begin				if (thetype <> fisher) then					begin						if not printon then							begin								MoveTo(noteleft, top - notetop);								DrawString('Number of steps between states:')							end;{====== To:   titles ======}						Moveto(left - 25, top - 6);						DrawString('To:');						DrawHTypeLabels(boundary);						for j := 0 to maxdrawmat do							begin								moveto(left + StepCellWidth * j, top);								GridLineto(left + StepCellWidth * j, bottom - 1, false);							end;{====== From:   titles ======}						Moveto(left - StringWidth('From: MM'), top + StepCellHeight - 4);						DrawString('From:');						DrawVTypeLabels(boundary);						for j := 0 to maxdrawmat do							begin								moveto(left, top + StepCellHeight * j);								GridLineTo(right - 1, top + StepCellHeight * j, false);							end;						PenSize(1, 1);						FrameRect(boundary);					end				else {it is fisher}					begin						if not printon then							begin								MoveTo(noteleft, top - notetop);								DrawString('Cost of skipping strata:');							end;						Moveto(left - 20, top - 6);						DrawString('Stratum:');						for j := 0 to maxdrawmat do							begin								moveto(left + StepCellWidth * j, top);								GridLineTo(left + StepCellWidth * j, bottom - 1, false);							end;						DrawVTypeLabels(boundary);						for j := 0 to maxdrawmat do							begin								moveto(left, top + StepCellHeight * j);								GridLineTo(right - 1, top + StepCellHeight * j, false);							end;						PenSize(1, 1);						FrameRect(boundary);					end;{$IFC TRUE}				PenNormal;				moveto(left + 2, bottom);				LineTo(right, bottom);				LineTo(right, top + 2);{$ENDC}			end;	end;{----------------------------------------------------------------------------}	procedure FillTypeMatrix; {(thetype: integer; boundary : rect; erase: boolean)}		var			isfrom, isto: integer;			ds: string[32];			box: rect;	begin		typeHdl := gettypeHdl(thetype);		for isfrom := vTypeStart to vTypeStart + maxdrawmat do			for isto := hTypeStart to hTypeStart + maxdrawmat do				if (thetype <> fisher) or (isfrom = isto - 1) then					begin						box := FindStepCellRect(isfrom, isto);						if erase then							begin{InsetRect(box, 1, 1);}								if box.bottom >= specRect.bottom then									box.bottom := box.bottom - 1;								EraseRect(box);							end;{if not printon and (isto = isfrom) and (thetype <> fisher) then FillRect(box, QDltGray);}						if typeHdl^^.dist[isfrom, isto] = infinity then							ds := '░'{else if isfrom = isto then  ds := ' '}						else if typehdl^^.isreal then							ds := concat(StringFromNum(typeHdl^^.dist[isfrom, isto] div TypeInflate), '.', StringFromNum(typeHdl^^.dist[isfrom, isto] mod TypeInflate))						else							ds := StringFromNum(typeHdl^^.dist[isfrom, isto]);						moveto(boundary.left + (isto - hTypeStart) * StepCellWidth + (StepCellWidth - stringwidth(ds)) div 2 + 1, boundary.top + (isfrom - vTypeStart) * StepCellHeight + StepCellHeight - 4);						DrawString(ds);						if not printon & StepCells^[isfrom, isto] then							InvertStepCellRect(isfrom, isto);					end				else if thetype = fisher then					if erase then						EraseRect(FindStepCellRect(isfrom, isto));	end;{----------------------------------------------------------------------------}	procedure ReDrawTypeSpecs (theDialog: DialogPtr; itemNo: INTEGER);		var			isfrom, isto, j, mx: integer;			oldfont, oldsize: integer;			picH: PicHandle;			box: rect;	begin		PenNormal;		TextMode(srcor);		FrameButton(theDialog, 1);{SetRect(box, 4, 77, 297, 303); Eraserect(box);  }{note from W: I don't understand why, but scrolls don't get drawn when these}{two lines are used.  I put these in to insure than matrix was always erased.  }{There were circumstances in which it wasn't (or at least Dollo wasn't).  It seemed silly to be so cute about erasing.  }{Why not just smash the whole field always?  I tried, and the scroll}{bars were erased, because checkmaxmat was done before the below.  But checkmaxmat should be separated into a checker}{and a drawer, which I did, but still it didn't help.  The scroll bars just don't appear, as if there is a port problem}		SetRect(box, 0, 80, 280, specrect.bottom + 5);		if CurType = dollo then			begin				EraseRect(box);				if numbytes = 4 then					begin						picH := GetPicture(262);						mx := 7;					end				else					begin						picH := GetPicture(263);						mx := 2;					end;				box := picH^^.picFrame;				Offsetrect(box, 60, 140);				DrawPicture(picH, box);				if numbytes = 4 then					MoveTo(box.left + 5, box.top + 39)				else					MoveTo(box.left + 28, box.top + 34);				for j := 0 to mx do					begin						DrawChar(CharOfNum(j));						Move(16, 0);					end;				ReleaseResource(Handle(picH));			end		else if showmatrix then			begin				if oldcurtype = dollo then					EraseRect(box);				SetRect(box, noteleft, specrect.top - notetop - 12, 275, specrect.top - notetop + 5);				eraserect(box);				box := specrect;				InsetRect(box, -1, -1);				box.left := box.left - 20;				box.top := box.top - 15;				EraseRect(box);				EraseRect(fromB);				EraseRect(toB);				CheckMaxMat;				CalcSpecRect(CurType, specleft, spectop, specrect);				CalcScrollTypeRect;				DrawTypeMatrixBox(CurType, specrect);				DrawMatScrolls;{==== filling in values ====}				oldfont := QDThePortTextFont;				oldsize := QDThePortTextSize;				SetStepMatrixFont;				FillTypeMatrix(CurType, SpecRect, false);				textfont(oldfont);				textsize(oldsize);			end		else			begin				UpdateCSTree;			end;	end;{-----------------------------------------------------------------------------}	procedure TypeNames; {(theDialog : DialogPtr; itemNo : INTEGER);}	begin		PenNormal;		FrameRect(nameRect);		MoveTo(6, nameRect.bottom + 14);		PenSize(2, 2);		LineTo(WindowPortRect(myGetWindowPtrForDialog(theDialog)).right - 6, nameRect.bottom + 14);		PenSize(1, 1);		Lupdate(myGetVisRgn(myGetWindowPtrForDialog(theDialog)), typList);	end;{----------------------------------------------------------------------------}	procedure ShowC (theDialog: DialogPtr);	begin		if CurType <> 0 then			begin				maxMat := MaxStateDefined(CurType);				CheckMaxMat;				ReDrawTypeSpecs(theDialog, 8);				DrawMatScrolls;				specchanged := false;			end;		ButHilite(theDialog);	end;end.