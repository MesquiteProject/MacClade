unit ExportHTML;{еееееееееееееееееееееее}interface	uses		QuickDraw, 		Types, Events, QuickDrawText, OSUtils, TextUtils, Controls, Menus, Files, Finder, Windows, Sound, Dialogs, TextEdit, Lists, ToolUtils, Memory, Fonts, Resources, Scrap, StandardFile,		Globals, GenUtil, WindowUtil, SetLibInterface, StrUtil, TaxonCHUtil, 		SymbolsNames, 		ImpForeignFiles, ExportUtil, SpreadUtil, CharUtil, TreeUtil, CHUNK, 		RowColumn, ReadUtil, WriteUtil, LinkUtil, Thermos, EditorCellEntry, ExportUtil;	function QueryExportData(filetype: integer; var dataP: univ Ptr; var response: integer): boolean;	procedure ExportData (filetype: integer; fileSpec: FSSpec; var dataP: univ Ptr);  {еееееееееееееееееееееее}implementation {е$S Export}{----------------------------------------------------------------------------}{	procedure SFPutSuffixedFile (var ds: str255; ext, SFstr: str255; var Freply: StandardFileReply);	begin		ds := concat(ds, ext);		ds := Copystring(ds, 1, maxFileNameLength);		PutStandardFile(SFstr, ds, Freply);	end;}{-----------------------------------------------------------------------------}	procedure PutHTMLFileLink(fileBaseName: str255; blockNumber,blockSize: integer);	var startchar,lastchar: integer;	begin		putToken('[<a href="');		putToken(AppendSuffixToFileName(fileBaseName, concat(StringFromNum(blocknumber),'.html')));		putToken('">');		startchar := blocksize*(blockNumber-1)+1;		lastchar := startchar+blocksize-1;		if lastchar > numchars then lastchar := numchars;		putToken(StringFromNum(startchar));		putSingleChar('-');		putToken(StringFromNum(lastchar));		putToken('</a>] ');	end;{-----------------------------------------------------------------------------}	function HexCharFromInt(theInt: integer): char;	begin		if theInt<10 then			HexCharFromInt := char(ord('0')+theInt)		else			HexCharFromInt := char(ord('A')+theInt-10);	end;{-----------------------------------------------------------------------------}	function WebColorPart(oldValue: integer): str255;	var valueLong: longint;		newValue: integer;		ds: str255;	begin{$R-}		valueLong := oldValue;		if valueLong<0 then			valueLong := 65534+valueLong;		newValue := TruncateValue((valueLong/65534.0)*256);		if newValue<0 then newValue := 0		else if newValue > 256 then newValue := 256;		ds := '  ';		ds[1] := HexCharFromInt(newValue div 16);		ds[2] := HexCharFromInt(newValue mod 16);		WebColorPart := ds;	end;{-----------------------------------------------------------------------------}	function WebColor(color: RGBColor): str255;	begin		WebColor := concat(WebColorPart(color.red),WebColorPart(color.green),WebColorPart(color.blue));	end;{-----------------------------------------------------------------------------}	function WebTaxCharColor(it,ic: integer): str255;	var 	thecolor: RGBColor;		tsts: largestSetChars;	begin		if writeHTMLAsTable then			begin				theColor.red :=  $FFFF;				theColor.green := $FFFF;				theColor.blue :=$FFFF;			end		else			begin				theColor.red := 0;				theColor.green := 0;				theColor.blue := 0;			end;		if editorColorCellsMode=editorColorCellsAAState then			begin				 PrepareAAfromDNA(it,ic,ic,tsts,false,writeStandardCells);				if (tsts=[])  then					begin					end				else 	if not (MSl in tsts) then					if (CardLg(tsts)=1)then						theColor := proteinColorKey^[MinLg(tsts)]					else						theColor := polyMorphColor;			end		else if editorColorCellsMode= editorColorCellsState then			begin				tsts := gettaxonstsLargest(it,ic);				if tsts = [] then									else if not (MSl in tsts) then					if (CardLg(tsts)=1)then						begin							{if colorAAs then								theColor := proteinColorKey^[MinLg(tsts)]							else								}theColor := GetCellColor(ic,tsts);						end					else						theColor := polyMorphColor;			end;				WebTaxCharColor := concat(WebColorPart(theColor.red),WebColorPart(theColor.green),WebColorPart(theColor.blue));	end;	{-----------------------------------------------------------------------------}	procedure WriteHTMLBlock (blocksize,blockNumber,TotalBlocks,longesttaxname: integer);	var 	startchar,lastchar,it,ic,k: integer;			tsts: largestsetchars;			lastBlock: boolean;			ds: str255;			BlockToLink: integer;			someexcluded: boolean;			writemissing, writematchchar, writegap, c: char;			cmaxst: SignedByte;			rownum, colnum: integer;	begin		startchar := blocksize*(blockNumber-1)+1;		lastchar := startchar+blocksize-1;		if lastchar > numchars then lastchar := numchars;		lastblock := blockNumber = TotalBlocks;		if molecular then			PutToken('<H3>Sites ')		else			PutToken('<H3>Characters ');		PutToken(StringFromNum(startchar));		PutToken(' through ');		PutToken(StringFromNum(lastchar));		PutToken('</H3>');		putExportReturn(HTMLMatrix);		if writeHTMLAsTable then			begin				if writeHTMLShowCellBorders then					PutToken('<TABLE BORDER=1 CELLPADDING=2 CELLSPACING=0>')				else					PutToken('<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0>');				putExportReturn(HTMLMatrix);			end		else			begin				PutToken('<PRE>');				putExportReturn(HTMLMatrix);				putToken('<b>');			end;		CalcSolidIOSymbols(writemissing,writegap,writematchchar);		if writeHTMLAsTable then			begin				if writeHTMLCharacterNumbers then					begin						PutToken('<tr><th>');						for ic := startchar to lastchar do							begin								PutToken('<th>');								PutToken(StringFromNum(ic));							end;						putToken('</tr>');						putExportReturn(HTMLMatrix);					end				else					begin						PutToken('<tr><td>');						for ic := startchar to lastchar do							if ic mod 10 = 0 then								begin									PutToken('<td align=center>');									putSingleChar('*');								end							else									PutToken('<td>');						putToken('</tr>');						putExportReturn(HTMLMatrix);					end;				if writeHTMLCharacterNames then					begin						PutToken('<tr><th>');						for ic := startchar to lastchar do							begin								PutToken('<th>');								PutToken(CharName(ic));							end;						putToken('</tr>');						putExportReturn(HTMLMatrix);					end;			end		else			begin				for k := 1 to longesttaxname do					putSpace;				for ic := startchar to lastchar do					if ic mod 10 = 0 then						putSingleChar('*')					else						putSpace;				putExportReturn(HTMLMatrix);			end;		for it := 1 to numtaxa do			begin				if writeHTMLAsTable then					begin						PutToken('<tr><td><b>');					end				else if EditorCellsColored then					putToken('<font color="000000">');				putToken(taxonName(it));				if writeHTMLAsTable then					PutToken('</b>');				if not writeHTMLAsTable then					for k := length(taxonName(it)) + 1 to longesttaxname do						putSpace;				for ic := startchar to lastchar do						begin							if writeHTMLAsTable then								putToken('<td');							if EditorCellsColored then								ds := WebTaxCharColor(it,ic)							else								ds := '';							tsts := getTaxonStsLargest(it,ic);							if (tsts = [MSl,GAl]) & not writeHTMLShowGaps then								begin									if writeHTMLAsTable then										putSingleChar('>');									putSpace;								end							else								begin									if (ds <> '') & not (MSl in tsts) then										if writeHTMLAsTable then											begin												putToken(' bgcolor="');												putToken(ds);												putToken('"');											end										else											begin												putToken('<font color="');												putToken(ds);												putToken('">');											end;									if writeHTMLAsTable then										putToken(' align=center>');																		if not editorShowCellSymbol then										putToken('&nbsp;')									else										begin											ds := TaxonCharacterCellEntry (it,ic,tsts);											putToken(ds);											{cmaxst := CharMaxstOBS(ic);											if tsts = [MSl] then												putSingleChar(writemissing)											else if tsts = [msl, gal] then												putSingleChar(writegap)											else if matchcharon & (it <> 1) & (tsts = gettaxonstsLargest(1, ic)) then												putSingleChar(writematchchar)											else if nucleotides then													begin													if not (UCl in tsts) & (mstaxa = mstVariable) & (MultipleStatesLg(tsts)) then														WritePolySTS(tsts,cmaxst)													else														putSingleChar(DNARNACharOfSet(tsts));												end											else if datatype = protein then															begin													c := ProteinCharOfSet(tsts);													if c = '?' then														WritePolySTS(tsts,cmaxst)													else														putSingleChar(c)												end											else if MonomorphLg(tsts) then															begin													putSingleChar(CharOfNum(minLg(tsts)));												end											else												WritePolySTS(tsts,cmaxst);}										end;								end;						end;				if writeHTMLAsTable then					begin						putToken('</tr>');						putExportReturn(HTMLMatrix);					end;				putExportReturn(HTMLMatrix);							end;		if EditorCellsColored then			putToken('<font color="000000">');		for k := 1 to longesttaxname do			putSpace;		someexcluded := false;		for ic := startchar to lastchar do				begin					if CharIncluded(ic) then putToken(' ')					else  						begin							puttoken('=');							someexcluded := true;						end;				end;		putExportReturn(HTMLMatrix);		if writeHTMLAsTable then			begin				putToken('</TABLE>');				putExportReturn(HTMLMatrix);			end		else			begin				putToken('</PRE>');				putExportReturn(HTMLMatrix);				putToken('</b>');			end;		putToken('<font color="000000">');		if someexcluded then			begin				putToken('Character excluded indicated by a = in the line under the matrix<P>');				putExportReturn(HTMLMatrix);			end;		putToken('<HR>');		putExportReturn(HTMLMatrix);	end;	{-----------------------------------------------------------------------------}	procedure WriteHTMLStart (writeHTMLPageTitle: str255);	begin		putToken('<HEAD>');		putExportReturn(HTMLMatrix);		PutToken('<Title>');		PutToken(writeHTMLPageTitle);		putToken('</Title>');		putExportReturn(HTMLMatrix);		putToken('</HEAD>');		putExportReturn(HTMLMatrix);		putToken('<BODY BGCOLOR="#FFFFFF">');		putExportReturn(HTMLMatrix);	end;{-----------------------------------------------------------------------------}	procedure WriteHTMLHeading (writeHTMLPageTitle: str255);	begin		putToken('<HR><P>');		putExportReturn(HTMLMatrix);		PutToken('<H2>');		PutToken(writeHTMLPageTitle);		putToken('</H2>');		putExportReturn(HTMLMatrix);	end;{-----------------------------------------------------------------------------}	procedure WriteHTMLBlockFile (fileBaseName,writeHTMLPageTitle: str255; blocksize,blockNumber,TotalBlocks,longesttaxname: integer);	var 	startchar,lastchar,it,ic,k: integer;			tsts: largestsetchars;			lastBlock: boolean;			ds: str255;			BlockToLink: integer;	begin		startchar := blocksize*(blockNumber-1)+1;		lastchar := startchar+blocksize-1;		if lastchar > numchars then lastchar := numchars;		lastblock := blockNumber = TotalBlocks;		WriteHTMLStart (writeHTMLPageTitle);		if TotalBlocks > 1 then			begin				if startchar = 1 then					begin 						putToken('[First]');						putExportReturn(HTMLMatrix);						putToken('[Previous]');						putExportReturn(HTMLMatrix);						putToken('[<a href="');						putToken(AppendSuffixToFileName(fileBaseName, concat(StringFromNum(blocknumber+1),'.html')));						putToken('">Next</a>]');					end				else if lastblock then					begin						putToken('[<a href="');						putToken(AppendSuffixToFileName(fileBaseName,'1.html'));						putToken('">First</a>]');						putToken('[<a href="');						putToken(AppendSuffixToFileName(fileBaseName, concat(StringFromNum(blocknumber-1),'.html')));						putToken('">Previous</a>]');						putToken('[Next]');						putExportReturn(HTMLMatrix);					end				else					begin						putToken('[<a href="');						putToken(AppendSuffixToFileName(fileBaseName,'1.html'));						putToken('">First</a>]');						putToken('[<a href="');						putToken(AppendSuffixToFileName(fileBaseName, concat(StringFromNum(blocknumber-1),'.html')));						putToken('">Previous</a>]');						putToken('[<a href="');						putToken(AppendSuffixToFileName(fileBaseName, concat(StringFromNum(blocknumber+1),'.html')));						putToken('">Next</a>]');					end;				putToken('<P>');				putExportReturn(HTMLMatrix);				for BlockToLink := 1 to TotalBlocks do					PutHTMLFileLink(fileBaseName, BlockToLink,blockSize);			end;{		PutToken('Data matrix used in Maddison, D.R., Baker, M.D., and Ober, K.A. In press.');  		PutToken('A preliminary phylogenetic analysis of 18S ribosomal DNA of carabid beetles (Coleoptera: Carabidae). ');		putToken('Boll. Mus. reg. Sci. nat. Torino.');}		WriteHTMLHeading (writeHTMLPageTitle);		WriteHTMLBlock(blocksize,blockNumber,TotalBlocks,longesttaxname);		putToken('</BODY>');		putExportReturn(HTMLMatrix);		putToken('</HTML>');		putExportReturn(HTMLMatrix);	end;{-----------------------------------------------------------------------------}	procedure WriteSingleHTMLBlockFile (writeHTMLPageTitle: str255; blocksize,TotalBlocks,longesttaxname: integer);	var 	startchar,lastchar,it,ic,k: integer;			tsts: largestsetchars;			theDialog: DialogPtr;			tempP: WindowPtr;			lastBlock: boolean;			ds: str255;			BlockToLink: integer;			BlockNumber: integer;	begin		WriteHTMLStart (writeHTMLPageTitle);		WriteHTMLHeading (writeHTMLPageTitle);		StartThermo(theDialog, tempP, 0, totalBlocks, 'Exporting HTML file', 'blocks', false);		for blockNumber := 1 to TotalBlocks do			begin				startchar := blocksize*(blockNumber-1)+1;				lastchar := startchar+blocksize-1;				if lastchar > numchars then lastchar := numchars;				lastblock := blockNumber = TotalBlocks;				if blockNumber > 1 then					begin						putToken('<P>');						putExportReturn(HTMLMatrix);					end;				WriteHTMLBlock(blocksize,blockNumber,TotalBlocks,longesttaxname);				UpdateThermo(theDialog, 0, blocknumber, totalBlocks,false);			end;		EndThermo(theDialog, tempP, true);		putToken('</BODY>');		putExportReturn(HTMLMatrix);		putToken('</HTML>');		putExportReturn(HTMLMatrix);	end;{-----------------------------------------------------------------------------}	procedure WriteHTMLMatrix(originalFileSpec: FSSpec; LinName: boolean;writeHTMLPageTitle: str255);		label			1,2;		var			FileSuccess: boolean;			FileSpec: FSSpec;			os: oserr;			startchar,blockNumber,it,ic,k,longesttaxname, lastchar: integer;			ds: str255;			theDialog: DialogPtr;			tempP: WindowPtr;			oldexists: boolean;			TotalBlocks : integer;	begin						fileSpec := originalFileSpec;				longesttaxname := 0;		for it := 1 to numtaxa do			begin				ds := TaxonName(it);				k := length(ds);				if k > longesttaxname then					longesttaxname := k;			end;		longesttaxname := longesttaxname + 2;				TotalBlocks := numchars div writeHTMLBlockLength;		if numchars mod writeHTMLBlockLength > 0 then			TotalBlocks := TotalBlocks + 1;					if not writeHTMLInterleaved  then			begin				StartThermo(theDialog, tempP, 0, totalBlocks, 'Exporting HTML files', 'blocks', false);				for blockNumber := 1 to TotalBlocks do					begin						if abortedthermo then leave;						if totalBlocks = 1 then							if LinName then								fileSpec.name := AppendSuffixToFileName(originalfileSpec.name, '.html')							else								fileSpec.name := AppendSuffixToFileName(originalfileSpec.name, '.htm')						else							if LinName then								fileSpec.name := AppendSuffixToFileName(originalfileSpec.name, concat(StringFromNum(blocknumber),'.html'))							else								fileSpec.name := AppendSuffixToFileName(originalfileSpec.name, concat(StringFromNum(blocknumber),'.htm'));						FSpCreateSaveFile(fileSpec, oldexists, writeHTMLCreator, 'TEXT');						StartWrite;						if errorflag then 							goto 1;						WriteHTMLBlockFile(originalfileSpec.name,writeHTMLPageTitle,writeHTMLBlockLength,blockNumber,TotalBlocks,longesttaxname);						EndWrite;						FDI^[writeFileFDI].fs := fileSpec; 						if oldexists then							FSpExchangeFilesDeleteTemp(FDI^[writeFileFDI].fs); 						UpdateThermo(theDialog, 0, blocknumber, totalBlocks,false);					end;		1:				EndThermo(theDialog, tempP, true);			end		else			begin				if LinName then					fileSpec.name := AppendSuffixToFileName(originalfileSpec.name, '.html')				else					fileSpec.name := AppendSuffixToFileName(originalfileSpec.name, '.htm');				FSpCreateSaveFile(fileSpec, oldexists, writeHTMLCreator, 'TEXT');				StartWrite;				if errorflag then 					goto 2;				WriteSingleHTMLBlockFile(writeHTMLPageTitle,writeHTMLBlockLength,TotalBlocks,longesttaxname);				EndWrite;				FDI^[writeFileFDI].fs := fileSpec; 				if oldexists then					FSpExchangeFilesDeleteTemp(FDI^[writeFileFDI].fs); 			end;2:				end;		 {-----------------------------------------------------------------------------}	function QueryExportHTML: boolean;		var			theDialog: DialogPtr;			tmatchchar: char;			tempP: WindowPtr;			oldwriteHTMLAsTable: boolean;			oldwriteHTMLShowMissing: boolean;			oldwriteHTMLBlockLength: integer;			oldwriteHTMLShowCellBorders: boolean;			oldwriteHTMLCharacterNames: boolean;			oldwriteHTMLCharacterNumbers : boolean;			oldwriteHTMLInterleaved : boolean;			oldCreator: OSType;			ds: str255;			localItemHit: integer; {........}		procedure CheckHTMLDLOG;		begin			ItemCheckMark(theDialog, 6, writeHTMLAsTable);			ItemCheckMark(theDialog, 8, not writeHTMLShowGaps);			ItemCheckMark(theDialog,10, writeHTMLShowCellBorders);			EnableDisableDLOGItem(theDialog, 10, writeHTMLAsTable,false);			ItemCheckMark(theDialog,11,writeHTMLCharacterNames);			EnableDisableDLOGItem(theDialog, 11, writeHTMLAsTable,false);			ItemCheckMark(theDialog,12,writeHTMLCharacterNumbers);			EnableDisableDLOGItem(theDialog, 12, writeHTMLAsTable,false);			ItemCheckMark(theDialog,13,not writeHTMLInterleaved);		end; {........}		procedure GrabTextItems;		var j: integer;		begin			ds := GetEditText(theDialog, 15);			writeHTMLCreator := oldCreator;  			if length(ds) >= 4 then				for j:= 1 to 4 do				    writeHTMLCreator[j] := ds[j];			ds := GetEditText(theDialog, 9);			if StringIsLongint(ds) then				writeHTMLBlockLength := TokenToInteger(ds, false);		end;{........}		procedure CheckBlockLength;		begin			ds := GetEditText(theDialog, 9);			if not StringIsLongint(ds) then				SetDLOGText(theDialog, 9, StringFromNum(writeHTMLBlockLength), true);		end; {........}	begin		oldwriteHTMLAsTable:= writeHTMLAsTable;		oldwriteHTMLShowMissing:= writeHTMLShowGaps;		oldwriteHTMLBlockLength:= writeHTMLBlockLength;		oldwriteHTMLShowCellBorders := writeHTMLShowCellBorders;		oldwriteHTMLCharacterNames := writeHTMLCharacterNames;		oldwriteHTMLCharacterNumbers := writeHTMLCharacterNumbers;		oldwriteHTMLInterleaved := writeHTMLInterleaved;		oldCreator := writeHTMLCreator;		QueryExportHTML := false;		StartDLOG(159, theDialog, tempP);		SetDLOGText(theDialog, 9, StringFromNum(writeHTMLBlockLength), false);		ds := writeHTMLCreator;		SetDLOGText(theDialog, 15, ds, false);		SetDLOGText(theDialog, 7, writeHTMLPageTitle, true);		CheckHTMLDLOG;		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			case localItemHit of				6: 					writeHTMLAsTable := not writeHTMLAsTable;				8: 					writeHTMLShowGaps := not writeHTMLShowGaps;				9: 					CheckBlockLength;				10:					writeHTMLShowCellBorders := not writeHTMLShowCellBorders;				11:					writeHTMLCharacterNames := not writeHTMLCharacterNames;				12:					writeHTMLCharacterNumbers := not writeHTMLCharacterNumbers;				13:	writeHTMLInterleaved := not writeHTMLInterleaved;				otherwise					;			end;			CheckHTMLDLOG;		until localItemHit in [1, 2];		if (localItemHit = 1) then			begin				GrabTextItems;				writeHTMLPageTitle := GetEditText(theDialog, 7);			end;		EndDLOG(theDialog, tempP);		if localItemHit = 2 then			begin				writeHTMLAsTable:= oldwriteHTMLAsTable;				writeHTMLShowGaps:= oldwriteHTMLShowMissing;				writeHTMLBlockLength:= oldwriteHTMLBlockLength;				writeHTMLShowCellBorders := oldwriteHTMLShowCellBorders;				writeHTMLCharacterNames := oldwriteHTMLCharacterNames;				writeHTMLCharacterNumbers := oldwriteHTMLCharacterNumbers;				writeHTMLInterleaved := oldwriteHTMLInterleaved;				writeHTMLCreator := oldCreator;			end		else 			QueryExportHTML := true;	end;	{----------------------------------------------------------------------------}	function QueryExportData(filetype: integer; var dataP: univ Ptr; var response: integer): boolean;	begin		QueryExportData:= true;		response := 1;		case filetype of			nbrf:				begin					response := DoAlert(164,NoteA);					QueryExportData := response <> 2;				end;			htmlMatrix: 				begin					if QueryExportHTML then						begin							QueryExportData := true; 							dataP := NewPtr(SizeOf(str255));							StringPtr(dataP)^ := writeHTMLPageTitle;						end					else						QueryExportData := false;				end;			otherwise				;		end;	end;	{----------------------------------------------------------------------------}	procedure ExportDataMemoryCleanup(filetype: integer; var dataP: univ Ptr);	begin		case filetype of			htmlMatrix: 				ZapPointer(dataP);			otherwise				;		end;			end;	{----------------------------------------------------------------------------}	function ExportMakesSingleFile(filetype: integer): boolean;	var ds: str255;	begin		ExportMakesSingleFile:= true;		if filetype = htmlmatrix then			ExportMakesSingleFile := false;	end;	{----------------------------------------------------------------------------}	procedure ExportData (filetype: integer; fileSpec: FSSpec; var dataP: univ Ptr);  	var oldExists, LinName: boolean;		ds: str255;		response: integer;	begin{		if QueryExportData(filetype, dataP, response) then			begin}				if ExportMakesSingleFile(filetype) then					begin						FSpCreateSaveFile(fileSpec, oldexists, writeHTMLCreator, 'TEXT');						StartWrite;					end;				case filetype of					{nbrf:  						WriteNBRFFastaFile(response=1,true);}					htmlMatrix:						begin							ds := MakeCaps(fileSpec.name);							if (pos('.HTML',ds) > 0) & (pos('.HTML',ds) = length(ds)-4) then								begin									fileSpec.name := copy(fileSpec.name,1, length(fileSpec.name)-5);									LinName := true;								end							else if (pos('.HTM',ds) > 0) & (pos('.HTM',ds) = length(ds)-3) then								begin									fileSpec.name := copy(fileSpec.name,1, length(fileSpec.name)-4);									LinName := false;								end							else								LinName := true;							WriteHTMLMatrix(fileSpec, LinName,StringPtr(dataP)^);						end;					otherwise;				end;				if ExportMakesSingleFile(filetype) then					begin						EndWrite;						FDI^[writeFileFDI].fs := fileSpec; 						if oldexists then							FSpExchangeFilesDeleteTemp(FDI^[writeFileFDI].fs); 					end;				ExportDataMemoryCleanup(filetype, dataP);{			end;}	end;end.