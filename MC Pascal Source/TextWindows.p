unit TextWindows;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}interface	uses		QuickDraw, ControlDefinitions,		Types, Events, QuickDrawText, OSUtils, Controls, Menus, TextUtils, Windows, Sound, Dialogs, TextEdit, Lists, ToolUtils, Memory, Fonts, Resources, Scrap, 		Globals, MemoryUtil, EventUtil, WindowUtil, StrUtil, UtilLibInterface, SetLibInterface, 		TaxonCHUtil, TreeUtil, BoxUtil, MenuUtil;	procedure DestroyTextWindow (whichText: integer);	procedure ShrinkTextWindowHeight (whichText: integer; var height: integer);	procedure SizeTextWindowText (whichText: integer; adjustDestRect, calcNLines, resetOrigin: boolean);	procedure DrawTextWindow (whichText: integer);	procedure ScrollTextWindow (whichText: integer);	procedure ScrollTextUpDown (whichControl: ControlRef; theCode: INTEGER);	procedure MouseInTextWindow (whichText: integer; Event: EventRecord);{еееееееееееееееееееееее}implementation {е$S TextWindows}	const		commBot = 4;		{----------------------------------------------------------------------------}	procedure DestroyTextWindow (whichText: integer);	begin//InstantInfo(concat("whichText: ",StringFromNum(whichText)));//InstantInfo("2.7.1 Before ZapWindow");		ZapWindow(textWindow[whichText]);//InstantInfo("2.7.2 Before ZapHandle");		if (textWindowInfo[whichText]<>nil) then			ZapHandle(textWindowInfo[whichText]^.H);//InstantInfo("2.7.3 Before ZapPointer");		ZapPointer(textWindowInfo[whichText]);	end;{----------------------------------------------------------------------------}	procedure SetTextWindowTitle (whichText: integer);	begin		HLock(Handle(filename));		HLock(Handle(treefilename));		case whichText of			aboutFileText: 				SetWTitle(textWindow[aboutFileText], concat('Notes about ', filename^^));			aboutTreeFileText: 				SetWTitle(textWindow[aboutTreeFileText], concat('Notes about trees in ', treefilename^^));			aboutTreesText: 				SetWTitle(textWindow[aboutTreesText], 'Notes about trees');			NexusBlockText: 				begin					if nexusBlockBeingEdited <> nil then						SetWTitle(textWindow[NexusBlockText], concat('NEXUS Block: ', nexusBlockBeingEdited^.blockname))					else						SetWTitle(textWindow[NexusBlockText], 'NEXUS Block');				end;			otherwise				SetWTitle(textWindow[whichText], '');		end;		HUnLock(Handle(filename));		HUnLock(Handle(treefilename));	end;{----------------------------------------------------------------------------}{----------------------------------------------------------------------------}	function TextWithCommentLine (whichText: integer): boolean;	begin		TextWithCommentLine := textWindowInfo[whichText]^.hasCommentLine;	end;{----------------------------------------------------------------------------}	function TextWindowStart (whichText: integer): integer;		var			tport: WindowPtr;	begin		genericGetPort(tport);		genericSetPort(textWindow[whichText]);		if TextWithCommentLine(whichText) then			TextWindowStart := FontHeight + 2 + 4		else			TextWindowStart := 4;		genericSetPort(tport);	end;{----------------------------------------------------------------------------}	procedure ShrinkTextWindowHeight (whichText: integer; var height: integer);	begin		height := ((height - TextWindowStart(whichText) - commBot) div textWindowInfo[whichText]^.TE^^.lineHeight) * textWindowInfo[whichText]^.TE^^.lineHeight + TextWindowStart(whichText) + commBot;	end;{----------------------------------------------------------------------------}	procedure SetTextWindowTextBox (whichText: integer; resetDest: boolean);		var			box: rect;	begin		box := WindowPortRect(textWindow[whichText]);		box.left := box.left + 6;		box.right := box.right - scrollwidth - 5;		box.top := box.top + TextWindowStart(whichText);		box.bottom := box.bottom - commBot;		textWindowInfo[whichText]^.box := box;		textWindowInfo[whichText]^.rows := (textWindowInfo[whichText]^.box.bottom - textWindowInfo[whichText]^.box.top) div textWindowInfo[whichText]^.TE^^.lineHeight;		textWindowInfo[whichText]^.TE^^.viewrect := textWindowInfo[whichText]^.box;		if resetDest then			textWindowInfo[whichText]^.TE^^.destrect := textWindowInfo[whichText]^.box		else			textWindowInfo[whichText]^.TE^^.destrect.right := textWindowInfo[whichText]^.box.right;	end;{----------------------------------------------------------------------------}	procedure SizeTextWindowText (whichText: integer; adjustDestRect, calcNLines, resetOrigin: boolean);		var			scrollmax, oldCommOrigin: integer;			tempP: WindowPtr;	begin		genericGetPort(tempP);		genericSetPort(textWindow[whichText]);		TextFont(textWindowInfo[whichText]^.font);		TextSize(textWindowInfo[whichText]^.size);		if (whichText = aboutTreesText) or (whichText = aboutTreeFileText) then			if treefile then				whichText := aboutTreeFileText			else				whichText := aboutTreesText;		SetTextWindowTextBox(whichtext,adjustDestRect & resetOrigin);		if calcNLines then			TECalText(textWindowInfo[whichText]^.TE);		scrollMax := textWindowInfo[whichText]^.TE^^.nlines - textWindowInfo[whichText]^.rows + 1;		if scrollmax < 0 then			scrollmax := 0;		SetControlMaximumLong(textWindowInfo[whichText]^.scroll, scrollMax);		if resetOrigin then			textWindowInfo[whichText]^.origin := (textWindowInfo[whichText]^.box.top - textWindowInfo[whichText]^.TE^^.destRect.top) div textWindowInfo[whichText]^.TE^^.lineHeight;		if textWindowInfo[whichText]^.origin > scrollMax then			begin				oldCommOrigin := textWindowInfo[whichText]^.origin;				textWindowInfo[whichText]^.origin := scrollMax;				if adjustDestRect then					begin						textWindowInfo[whichText]^.TE^^.destRect.top := textWindowInfo[whichText]^.TE^^.destRect.top - (textWindowInfo[whichText]^.origin - oldCommOrigin) * textWindowInfo[whichText]^.TE^^.lineHeight;						InvalidateWindow(textWindow[whichText], true);					end;			end;					SetControlValueLong(textWindowInfo[whichText]^.scroll, textWindowInfo[whichText]^.origin);{    TEScroll(0, 0,  textWindowInfo[whichText]^.TE);}{    if resetOrigin then  textWindowInfo[whichText]^.TE^^.destRect.top := textWindowInfo[whichText]^.box.top - textWindowInfo[whichText]^.origin *  textWindowInfo[whichText]^.TE^^.lineHeight;}		genericSetPort(tempP);	end;{----------------------------------------------------------------------------}	procedure DrawTextWindow (whichText: integer);	var		box: rect;		oldBack: RGBColor;	begin		if TextWithCommentLine(whichText) then			begin				{if (whichText = aboutTreesText) | (whichText = aboutTreeFileText) then					if treefile then						whichText := aboutTreeFileText					else						whichText := aboutTreesText;}				SetRect(box, 0, 0, WindowPortRect(textWindow[whichText]).right - scrollwidth - 1, FontHeight + 1);				EraseRect(box);				MoveTo(WindowPortRect(textWindow[whichText]).right - scrollwidth - 1, TextWindowStart(whichText) - 2);				Line(-(WindowPortRect(textWindow[whichText]).right - scrollwidth - 1), 0);				Move(3, -4);				TextFace([bold]);				HLock(Handle(treefilename));				case whichText of					aboutTreeFileText: 						DrawString(concat('Notes about trees in external tree file: ', treefilename^^));					aboutTreesText: 						DrawString('Notes about trees in data file');					nexusBlockText: 						begin							if (nexusBlockBeingEdited <> nil) & nexusBlockBeingEdited^.NativeBlock then								DrawString('Non-MacClade commands in block:')							else								DrawString('(Do not include "begin blockname;" and "end;" in text.)');						end;					otherwise						;				end;				HUnLock(Handle(treefilename));				TextFace([]);			end;		DrawControls(textWindow[whichText]);		SetRect(box, 0, 0, WindowPortRect(textWindow[whichText]).right - scrollwidth - 1, WindowPortRect(textWindow[whichText]).bottom);		SetTextWindowTitle(whichText);		TEUpdate(box, textWindowInfo[whichText]^.TE);	end;{----------------------------------------------------------------------------}	procedure ScrollTextWindow (whichText: integer);		var			oldOrigin, dv: integer;	begin		oldOrigin := textWindowInfo[whichText]^.origin;		textWindowInfo[whichText]^.origin := GetControlValueLong(textWindowInfo[whichText]^.scroll);		dv := (oldOrigin - textWindowInfo[whichText]^.origin) * textWindowInfo[whichText]^.TE^^.lineHeight;		TEPinScroll(0, dv, textWindowInfo[whichText]^.TE);	end;{----------------------------------------------------------------------------}	var		theTextWindow: integer;{----------------------------------------------------------------------------}	procedure ScrollTextUpDown (whichControl: ControlRef; theCode: INTEGER);		var			ds: str255;			box: rect;	begin		if scrollup then			begin				if theCode = kControlUpButtonPart then					SetControlValueLong(whichControl, GetControlValueLong(whichControl) - 1)			end		else if theCode = kControlDownButtonPart then			SetControlValueLong(whichControl, GetControlValueLong(whichControl) + 1);		ScrollTextWindow(theTextWindow);	end;{----------------------------------------------------------------------------}	procedure TextWindowScroll (whichText: integer; whichcontrol: ControlRef; wh: point);		var			MyControl, t, oldvalue, newvalue: integer;			mypt: point;	begin		oldvalue := GetControlValueLong(whichControl);		MyControl := FindControl(wh, textWindow[whichText], whichControl);		if whichControl= nil then Exit(TextWindowScroll);		SetTextWindowTextBox(whichtext, false);		theTextWindow := whichText;		case MyControl of			kControlUpButtonPart: 				begin					scrollup := true;					t := myTrackControl(whichControl, wh, ScrollTextUpDownUPP);				end;			kControlDownButtonPart: 				begin					scrollup := false;					t := myTrackControl(whichControl, wh, ScrollTextUpDownUPP);				end;			kControlPageUpPart: 				repeat					GetMouse(myPt);					if TestControl(whichControl, myPt) = mycontrol then						SetControlValueLong(whichControl, GetControlValueLong(whichControl) - textWindowInfo[whichText]^.rows + 1);					ScrollTextWindow(whichText);				until not StillDown;			kControlPageDownPart: 				repeat					GetMouse(myPt);					if TestControl(whichControl, myPt) = mycontrol then						SetControlValueLong(whichControl, GetControlValueLong(whichControl) + textWindowInfo[whichText]^.rows - 1);					ScrollTextWindow(whichText);				until not StillDown;			kControlIndicatorPart: 				begin					t := myTrackControl(whichControl, wh, nil);					ScrollTextWindow(whichText);				end;			otherwise				;		end;	end;{-----------------------------------------------------------------------------}	procedure MouseInTextWindow (whichText: integer; Event: EventRecord);		var			wh: point;			tport: WindowPtr;			box: rect;	begin		wh := Event.where;		genericGetPort(tport);		genericSetPort(textWindow[whichText]);		GlobalToLocal(wh);		box := myGetControlRect(textWindowInfo[whichText]^.scroll);		if ptinrect(wh, box) then			TextWindowScroll(whichText, textWindowInfo[whichText]^.scroll, wh)		else if not TextWindowLocked(whichText) then			begin				TEClick(wh, ShiftEvent(Event), textWindowInfo[whichText]^.TE);				SizeTextWindowText(whichText, false, false, true);				FixEditMenu;			end;		genericSetPort(tport);	end;end.