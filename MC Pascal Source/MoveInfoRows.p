unit MoveInfoRows;{еееееееееееееееееееееее}interface	uses		QuickDraw, 		Types, Events, QuickDrawText, OSUtils, TextUtils, Controls, Menus, Files, Windows, Sound, Dialogs, TextEdit, Lists, ToolUtils, Memory, Fonts, Resources, Scrap, 		Globals, MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, TypeUtil,  CHUNK, StringCompare,		 CharUtil, SpreadUtil,   IncExcTaxa, RowColumn, SymbolsNames, 		 MenuUtil, TreeUtil, LinkUtil,  MCWindows, 		 InfoWindowsUtil, CharPartitions;	function LegalMove (whichinfo, ic, releasedic: integer): boolean;	function MoveIndividualInfoRow(whichinfo, theRow, newRow: integer): boolean;	procedure UndoRowMoves(whichinfo: integer);	procedure CleanUpAfterRowMove(whichinfo: integer; pleaseUndo: boolean);	procedure SetUpBeforeRowMove(whichinfo: integer);		procedure SortByColumn(whichinfo,columnID: integer; descending: boolean);	procedure SortByStateOrName(whichInfo: integer; clickColumn: integer; descending: boolean);{еееееееееееееееееееееее}implementation {е$S MoveInfoRows}{-----------------------------------------------------------------------------}	procedure CleanUpAfterRowMove(whichinfo: integer; pleaseUndo: boolean);	begin		if whichinfo=charinfo then			SetLastChangeInEditor(lastChangeMoveCharacters)		else			SetLastChangeInEditor(lastChangeMoveTaxa);		if pleaseUndo then			begin				UndoRowMoves(whichinfo);				SetLastChangeInEditor(lastChangeCantUndo);			end;		InvalidateAllWindowsMarkedUnupdatable;	end;{-----------------------------------------------------------------------------}	procedure SetUpBeforeRowMove(whichinfo: integer);	begin		TurnOffInfoEditing(whichinfo);		StoreOldNumbers(whichinfo);		if (whichinfo=charinfo) | (whichinfo=taxinfo) then			DisableWindowUpdates(editorWindow);		DisableWindowUpdates(infoWindow[whichinfo]);	end;{----------------------------------------------------------------------------}	function LegalMove (whichinfo, ic, releasedic: integer): boolean;	begin		LegalMove := false;  		case whichinfo of			charinfo: 				LegalMove := not Locked(lockData); 			treeinfo:				LegalMove:= not Locked(lockTrees);			taxinfo:				LegalMove:= not Locked(lockData);			wtsetinfo, exsetinfo, typesetinfo:				LegalMove:= not Locked(lockAssumptions);			charsetinfo,taxsetinfo,charpartinfo, charpartnameinfo:				LegalMove := true;			nexusblockinfo:				LegalMove := NexusBlockForeign(ic) & not Locked(lockData);			otherwise				;		end;	end;{----------------------------------------------------------------------------}	procedure MoveLinkInChain (whichInfo, icstart, icend, releasedic: integer);	var theChain: integer;		linkH: Handle;		offset, currentic: integer;		irstart, irend, releasedir: integer;	begin		theChain := ChainFromInfo(whichinfo);		if theChain <> notAChain then			begin				irstart := icstart+PreDefLinks[theChain];				irend := icend+PreDefLinks[theChain];				releasedir := releasedic+PreDefLinks[theChain];				{GetLink(theChain, irstart, linkH, false);				offset := LinkOffSet(linkH);}				MoveHandlePieces(strCHUNKs[theChain], HdlSize, irstart,irend,releasedir,0);				currentic := InfoRowOfCurrentObject(whichinfo);				if (currentic >= icstart) & (currentic <= icend) then  {default link is being moved}					if releasedic < icstart then 						linkNumber[theChain] := linkNumber[theChain]-(icstart-releasedic)					else						linkNumber[theChain] := linkNumber[theChain]+(releasedic-icend)				else if (currentic >= releasedic) & (currentic < icstart)  then					linkNumber[theChain] := linkNumber[theChain] + (icend-icstart+1)				else if (currentic <= releasedic) & (currentic >icend)  then					linkNumber[theChain] := linkNumber[theChain] - (icend-icstart+1);			end;	end;{----------------------------------------------------------------------------}	procedure MoveNexusBlock(blockNumber,newBlockNumber: integer);	var theNexusBlock, dropNexusBlock: NexusBlockPtr;	begin		theNexusBlock := NexusBlock(blockNumber);		dropNexusBlock := NexusBlock(newBlockNumber);		if (theNexusBlock <> nil) & (dropNexusBlock<> nil) & (blockNumber <> newBlockNumber) then			begin				if theNexusBlock^.next <> nil then					theNexusBlock^.next^.prev := theNexusBlock^.prev;				if theNexusBlock^.prev <> nil then					theNexusBlock^.prev^.next := theNexusBlock^.next;				if blockNumber>newBlockNumber then					begin						if dropNexusBlock^.prev <> nil then							dropNexusBlock^.prev^.next := theNexusBlock;						theNexusBlock^.prev := dropNexusBlock^.prev;						dropNexusBlock^.prev := theNexusBlock;						theNexusBlock^.next := dropNexusBlock;						if newBlockNumber=1 then {have to reset NexusBlocks}							NexusBlocks := theNexusBlock;						dirtyfile := true;					end				else if blockNumber<newBlockNumber then					begin						if dropNexusBlock^.next <> nil then							dropNexusBlock^.next^.prev := theNexusBlock;						if blockNumber=1 then {have to reset NexusBlocks}							NexusBlocks := theNexusBlock^.next;						theNexusBlock^.next := dropNexusBlock^.next;						dropNexusBlock^.next := theNexusBlock;						theNexusBlock^.prev := dropNexusBlock;						dirtyfile := true;					end;			end;	end;{----------------------------------------------------------------------------}	procedure MovePartNameWithinPartition (H: Handle; newRow, theRow, offset: integer);		var			intP: IP;			thisPart: integer;			ic: integer;			oldState: SignedByte;	begin		LockHandle(H, oldState);		intP := IP(GetMaster(H)+offset);		for ic := 1 to numchars do			begin				thisPart:= intP^;				if thisPart = theRow then					intP^ := newRow				else if theRow > newRow then //moving things down					begin						if (thisPart >= newRow) & (thisPart < theRow) then   {it is in the piece between the new spot and the block moved}							intP^ := thisPart + 1;					end				else   // moving things up					begin						if (thisPart > theRow) & (thisPart <=newRow) then  {it is in the piece between the new spot and the block moved}								intP^ := thisPart-1;					end;				intP := IP(ord4(intP) + chpartb);			end;		ResetHandle(H, oldstate);	end;{----------------------------------------------------------------------------}	procedure MovePartNameWithinAllPartitions (newRow, theRow: integer);		var			j: longint;			H: Handle;	begin		for j := StartUserLink(charPartitionChain) to EndUserLink(charPartitionChain) do			begin				H := GetDirectLinkH(charpartitionchain, LinkNumberFromInfoRow(charpartitionchain,j));				MovePartNameWithinPartition(H, newRow, theRow, LinkOffSet(H));			end;	end;{----------------------------------------------------------------------------}	procedure MoveCharPartName(partNumber,newpartNumber: integer);	var thePartName, dropPartName: CharPartNamePtr;	begin		thePartName := GetCharPartNamePtr(partNumber);		dropPartName := GetCharPartNamePtr(newpartNumber);		if (thePartName <> nil) & (dropPartName<> nil) & (partNumber <> newpartNumber) then			begin				if thePartName^.next <> nil then					thePartName^.next^.prev := thePartName^.prev;				if thePartName^.prev <> nil then					thePartName^.prev^.next := thePartName^.next;				if partNumber>newpartNumber then					begin						if dropPartName^.prev <> nil then							dropPartName^.prev^.next := thePartName;						thePartName^.prev := dropPartName^.prev;						dropPartName^.prev := thePartName;						thePartName^.next := dropPartName;						if newpartNumber=1 then {have to reset PartNames}							charPartNames := thePartName;						dirtyfile := true;					end				else if partNumber<newpartNumber then					begin						if dropPartName^.next <> nil then							dropPartName^.next^.prev := thePartName;						if partNumber=1 then {have to reset PartNames}							charPartNames := thePartName^.next;						thePartName^.next := dropPartName^.next;						dropPartName^.next := thePartName;						thePartName^.prev := dropPartName;						dirtyfile := true;					end;			end;	end;{----------------------------------------------------------------------------}	function MoveIndividualInfoRow(whichinfo, theRow, newRow: integer): boolean;	var theSet: integer;	begin		MoveIndividualInfoRow := true;		case whichinfo of			treeinfo: 				begin					MoveLinkInChain(treeinfo,theRow,theRow,newRow);					InvalidateWindow(infowindow[treeinfo],true);					InvalidateWindow(tlegwindow,true);				end;			charinfo: 				begin					UnSelectAll;					if badcellEntry then 						begin							MoveIndividualInfoRow := false;							Exit(MoveIndividualInfoRow);						end;					if not MoveCharacters(theRow, theRow, newRow) then 						begin							MoveIndividualInfoRow := false;							Exit(MoveIndividualInfoRow);						end;					if editorOpen then						InvalidateWindow(editorWindow, true);				end;			taxinfo:				begin					UnSelectAll;					if badcellEntry then 						begin							MoveIndividualInfoRow := false;							Exit(MoveIndividualInfoRow);						end;					MoveTaxa(theRow, theRow, newRow);					if editorOpen then						InvalidateWindow(editorWindow, true);				end;			nexusblockinfo:				begin					MoveNexusBlock(theRow,newRow);					InvalidateWindow(infowindow[whichinfo],true);				end;			charpartnameinfo:				begin					if theRow = 1 then						begin							Sysbeep(2);							MoveIndividualInfoRow := false;							Exit(MoveIndividualInfoRow);						end;					if newRow < 2 then NewRow := 2;					MovePartNameWithinPartition(chPartitionH,newRow,theRow,0);					MovePartNameWithinPartition(chStorePartitionH,newRow,theRow,0);					MovePartNameWithinAllPartitions(newRow,theRow);					MoveCharPartName(theRow,newRow);					InvalidateWindow(infowindow[whichinfo],true);					if infoOpen[charinfo] then						InvalidateInfoColumn(charinfo,CharInfoPartition, 1,numchars);					RebuildCharPartNamesMenu;				end;			wtsetinfo, exsetinfo, typesetinfo,charsetinfo,taxsetinfo,charpartinfo:				begin					MoveLinkInChain(whichinfo,theRow,theRow,newRow);					if whichinfo=charsetinfo then						begin							{if editorCharacterSetToShade <> defaultCharSetToShade then								if editorOpen then InvalidateWindow(editorWindow,true);}							theSet := editorCharacterSetToShade - FirstUserShadeCharSet+1;							if theRow < newRow then  {going up}								begin									if (theSet >= theRow) & (theSet <= newRow) then										if theSet = theRow then											editorCharacterSetToShade := newRow+FirstUserShadeCharSet-1										else											editorCharacterSetToShade := editorCharacterSetToShade-1;								end							else if theRow > newRow  then {going down}								begin									if (theSet >= newRow) & (theSet <= theRow) then										if theSet = theRow then											editorCharacterSetToShade := newRow+FirstUserShadeCharSet-1										else											editorCharacterSetToShade := editorCharacterSetToShade+1;								end;							RebuildShadeCharSetMenu;						end					else if whichinfo =taxsetinfo then						RebuildConsensusTaxSetMenu;											InvalidateWindow(infowindow[whichinfo],true);				end;			otherwise				;		end;	end;{----------------------------------------------------------------------------}	function RowOldNumber(whichinfo: integer; theRow: longint): longint;	begin		case whichinfo of 			charinfo: 				RowOldNumber := getchhdl(theRow)^^.oldnumber;			taxinfo:				RowOldNumber := gettaxonhdl(theRow)^^.oldnumber;			otherwise;		end;	end;{-----------------------------------------------------------------------------}	procedure UndoRowMoves(whichinfo: integer);	label 1;	var		theRow: longint;		currentRow, rowToMove, maxRows: longint;		theDialog: DialogPtr;		tempP: WindowPtr;	begin		SetCursor(clockCursor);		currentRow := 1;		maxRows := MaximumInfoRows(whichinfo);		thermoAbortable := false;		StartThermo (theDialog,tempP,0,maxRows ,'Undoing...','',false);		DisableWindowUpdates(infoWindow[whichinfo]);		if (whichinfo=charinfo) | (whichinfo=taxinfo) then			DisableWindowUpdates(editorWindow);		repeat			rowToMove := 0;			UpdateThermo (theDialog,0,currentRow, maxRows,false);			for theRow := currentRow to MaximumInfoRows(whichinfo) do				if RowOldNumber(whichinfo,theRow)=currentrow then					begin						rowToMove := theRow;						leave;					end;			if rowToMove > currentRow then				if not MoveIndividualInfoRow(whichinfo,rowToMove,currentRow) then					goto 1;			currentRow := currentRow+1;		until currentRow = MaximumInfoRows(whichinfo);1: 		 EndThermo (theDialog,tempP,false);		 thermoAbortable := true;		InvalidateAllWindowsMarkedUnupdatable;	end;{-----------------------------------------------------------------------------}	procedure SortByColumn(whichinfo,columnID: integer; descending: boolean);	label 1;	var		 match: boolean;		originalString, rowString: str255;		theRow: longint;		currentValue,sortValue: double;		currentValueLongint,sortValueLongint: longint;		currentValueBoolean, sortValueBoolean: boolean;		currentRow, rowToMove: longint;		columnType: integer;		maxRows: longint;		movedone: boolean;		theDialog: DialogPtr;		tempP: WindowPtr;		pleaseUndo: boolean;	begin		if columnID = infoName then			SortByStateOrName(whichinfo,0,descending)		else			begin				moveDone := false;				maxRows := MaximumInfoRows(whichinfo);				StartThermo (theDialog,tempP,0,maxRows ,'Sorting...','',false);				SetUpBeforeRowMove(whichinfo);				if InfoColumnSortable(whichinfo,columnID) then					begin						columnType := InfoColumnType(whichInfo,columnID);							currentRow := 1;						case columnType of							columnIsDouble:								begin									repeat										UpdateThermo (theDialog,0,currentRow, maxRows,false);										if abortedThermo then											leave;										rowToMove := 0;										if descending then 											sortValue := 0.0										else											sortValue := 999999999.0;										for theRow := currentRow to MaximumInfoRows(whichinfo) do											begin												currentValue := InfoCellDouble(whichinfo,columnID,theRow);												if ((currentValue > sortValue) & descending) | ((currentValue < sortValue) & not descending) then													begin														sortValue := currentValue;														rowToMove := theRow;													end;											end;										if rowToMove > currentRow then											begin												if not MoveIndividualInfoRow(whichinfo,rowToMove,currentRow) then													goto 1;												moveDone := true;											end;										currentRow := currentRow+1;									until currentRow = MaximumInfoRows(whichinfo);								end;							columnIsLongint:								begin									repeat										UpdateThermo (theDialog,0,currentRow, maxRows,false);										if abortedThermo then leave;										rowToMove := 0;										if descending then 											sortValueLongint := 0										else											sortValueLongint := maxlongint;										for theRow := currentRow to MaximumInfoRows(whichinfo) do											begin												currentValueLongint := InfoCellLongint(whichinfo,columnID,theRow);												if ((currentValueLongint > sortValueLongint) & descending) | ((currentValueLongint < sortValueLongint) & not descending) then													begin														sortValueLongint := currentValueLongint;														rowToMove := theRow;													end;											end;										if rowToMove > currentRow then											begin												if not MoveIndividualInfoRow(whichinfo,rowToMove,currentRow) then													goto 1;												moveDone := true;											end;										currentRow := currentRow+1;									until currentRow = MaximumInfoRows(whichinfo);								end;							columnIsboolean:								begin									repeat										UpdateThermo (theDialog,0,currentRow, maxRows,false);										if abortedThermo then leave;										rowToMove := 0;										if descending then 											sortValueBoolean := true										else											sortValueBoolean := false;										for theRow := currentRow to MaximumInfoRows(whichinfo) do											begin												currentValueBoolean := InfoCellBoolean(whichinfo,columnID,theRow);												if (currentValueBoolean = sortValueBoolean) then													rowToMove := theRow;											end;										if rowToMove > currentRow then											begin												if not MoveIndividualInfoRow(whichinfo,rowToMove,currentRow) then 													goto 1;												moveDone := true;											end;										currentRow := currentRow+1;									until currentRow = MaximumInfoRows(whichinfo);								end;							otherwise								;						end;					end;				pleaseUndo := abortedThermo;		1:		 EndThermo (theDialog,tempP,false);				if moveDone then					CleanUpAfterRowMove(whichinfo,pleaseUndo)				else					InvalidateAllWindowsMarkedUnupdatable;			end;	end;{----------------------------------------------------------------------------}	function FirstStringLower(ds1,ds2: str255): boolean;	begin		FirstStringLower := CompareString(ds1,ds2,nil) < 0;	//	FirstStringLower := false;	end;{----------------------------------------------------------------------------}	function FindBestNameRemaining(whichinfo: integer; startRow: longint; descending: boolean): longint;	var 	ir : integer;		name, bestSoFar: str255;		maxSortRows, bestRemaining: longint;		emptyFound: boolean;	begin		bestRemaining := 0;		bestSoFar := '';   {this will store the best non-blank name}		maxSortRows := MaximumInfoRows(whichinfo);		emptyFound:= false;		for ir := startRow to maxSortRows do			begin				name := InfoNameString(whichinfo,ir);				if name = '' then					emptyFound := true				else if (bestSoFar = '') then					bestSoFar := name				else if (descending & not FirstStringLower(name,bestSoFar)) |  (not descending & FirstStringLower(name,bestSoFar)) then					bestSoFar := name;			end;		if emptyFound & not descending then {then we want to go after those empty ones first}			bestSoFar := '';		for ir := startRow to maxSortRows do			if InfoNameString(whichinfo,ir) = bestSoFar then				begin					bestRemaining := ir;					leave;				end;		FindBestNameRemaining := bestRemaining;	end;{----------------------------------------------------------------------------}	function GetSortState(whichinfo: integer; sortRow, clickColumn: integer): largestSetChars;	begin		if whichinfo = taxinfo then			GetSortState := getTaxonStsLargest(sortRow,clickColumn)		else			GetSortState := getTaxonStsLargest(clickColumn,sortRow);	end;{----------------------------------------------------------------------------}	function FindBestStateRemaining(whichinfo: integer; startRow: longint; clickColumn: integer; descending: boolean): longint;	var bestStateSoFar, ir, theState : integer;		bestSetSoFar, bestRemaining, maxSortRows: longint;		tsts: largestSetChars;		singletonFound, multipleFound, missingFound, gapFound: boolean;	begin		bestRemaining := 0;		singletonFound := false;		multipleFound := false;		missingFound := false;		gapFound := false;		maxSortRows := MaximumInfoRows(whichinfo);		if descending then			begin				bestStateSoFar := 0;				bestSetSoFar := 0;			end		else			begin				bestStateSoFar := absmaxstate;				bestSetSoFar := longint([0..absmaxstate]);			end;		for ir := startRow to maxSortRows do			begin				tsts := GetSortState(whichinfo, ir, clickColumn);				if tsts = [MSl] then					missingFound := true				else if tsts = [MSl,GAl] then					gapFound := true				else if CardLg(tsts) = 1 then					begin						theState := MinLg(tsts);						if (descending & (theState > bestStateSoFar)) |  (not descending & (theState < bestStateSoFar)) then							begin								bestStateSoFar := theState;								singletonFound:= true;							end;					end				else 					if (descending & (longint(tsts) > bestSetSoFar)) |  (not descending & (longint(tsts) < bestSetSoFar)) then						begin							bestSetSoFar := longint(tsts);							multipleFound := true;						end;			end;		if descending then			for ir := startRow to maxSortRows do				begin					tsts := GetSortState(whichinfo, ir, clickColumn);					if (not multipleFound & ([bestStateSoFar]= tsts)) | (multipleFound & (bestSetSoFar=longint(tsts))) then						begin							bestRemaining := ir;							leave;						end;				end		else			for ir := startRow to maxSortRows do				begin					tsts := GetSortState(whichinfo, ir, clickColumn);					if (SingletonFound & ([bestStateSoFar]= tsts)) | (not SingletonFound & (bestSetSoFar=longint(tsts))) then						begin							bestRemaining := ir;							leave;						end;				end;		if bestRemaining = 0 then			if missingFound then				for ir := startRow to maxSortRows do					begin						if GetSortState(whichinfo, ir, clickColumn)=[MSl] then							begin								bestRemaining := ir;								leave;							end;					end			else if gapFound then				for ir := startRow to maxSortRows do					begin						if GetSortState(whichinfo, ir, clickColumn)=[MSl,GAl] then							begin								bestRemaining := ir;								leave;							end;					end;		FindBestStateRemaining := bestRemaining;	end;{-----------------------------------------------------------------------------}	procedure SortByStateOrName(whichinfo: integer; clickColumn: integer; descending: boolean);	label 1;	var		ir, theRow: integer;		maxSortRows: longint;		movedone: boolean;		theDialog: DialogPtr;		tempP: WindowPtr;		pleaseUndo: boolean;	begin		moveDone := false;		maxSortRows:= MaximumInfoRows(whichinfo);		if clickColumn = 0 then			StartThermo (theDialog,tempP,0,maxSortRows ,'Sorting by name...','',false)		else			StartThermo (theDialog,tempP,0,maxSortRows ,'Sorting by state...','',false);		SetUpBeforeRowMove(whichinfo);		for ir := 1 to maxSortRows do			begin				UpdateThermo(theDialog,0,ir,maxSortRows,false);				if abortedThermo then goto 1;				if clickColumn=0 then					theRow := FindBestNameRemaining(whichinfo, ir, descending)				else					theRow := FindBestStateRemaining(whichinfo, ir, clickColumn, descending);				if (theRow > ir) then					begin						if not MoveIndividualInfoRow(whichinfo,theRow,ir) then							goto 1;						moveDone := true;					end;			end;1:		pleaseUndo := abortedThermo;		EndThermo (theDialog,tempP,false);		if moveDone then			CleanUpAfterRowMove(whichinfo,pleaseUndo)		else			InvalidateAllWindowsMarkedUnupdatable;	end;{-----------------------------------------------------------------------------}end.