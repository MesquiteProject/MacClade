unit ClickInInfoWindow;{еееееееееееееееееееееее}interface	uses		QuickDraw, 		Types, Events, QuickDrawText, OSUtils, TextUtils, Controls, Menus, Files, Windows, Sound, Dialogs, TextEdit, Lists, ToolUtils, Memory, Fonts, Resources, Scrap, 		Globals, MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, TypeUtil,  CHUNK,		 CharUtil, SpreadUtil,   IncExcTaxa, RowColumn, SymbolsNames, 		 MenuUtil, TreeUtil, LinkUtil,  MCWindows, ChangeAssumptions, Selection, TreeGet,		 InfoWindowsUtil, InfoWindowsDraw, InfoWindows, MoveInfoRows, EditorUndo;	procedure GoToTreeWindow(whichRow: integer);	procedure PopUpInfoSetM (whichinfo: integer; theSpot: point);	procedure UseSelectedObject(whichinfo, whichRow: longint);	procedure OpenEditNexusBlockNumber(blockNumber: integer);	procedure UserChooseSelectedPartNameColor;	function WhichInfoColumn (whichinfo: integer; wh: point): integer;	procedure DoIncExcTaxaMenu (itemNo: integer);	procedure PopUpInfoWindowM (whichinfo: integer; theMHdl: MenuHandle; theMenu: integer; theSpot: point);	procedure ClickInInfoWindow (whichinfo: integer);	procedure QueryDeleteSelectedInfoRows (whichinfo:integer);	procedure KeyInInfoWindow (whichInfo: integer; theChar: char);{еееееееееееееееееееееее}implementation {е$S ClickInInfoWindow} {-----------------------------------------------------------------------------}	procedure GoToTreeWindow(whichRow: integer);		var			opentreeanyway: boolean;			tport: WindowPtr;			cc, growsize: size;			amountneeded: longint;			db: boolean;	begin{if thewindow = commwindow then HideWindow(commwindow);}		if treeopen and OptionEvent(Event) then			begin				if WindowVisible(twmesswindow) then					HideWindow(twmesswindow)				else					ShowWindow(twmesswindow)			end		else if treeopen and not IsTreeWindow(frontwindow) then			SelectTreeWindows		else if not treeopen then			begin{check if within 5 k of memory full)}				opentreeanyway := true;				if not EnoughMemory(MemoryForTree(numtaxa, numchars) + 5000, amountneeded) then					begin						cc := MaxMem(growsize);						if not EnoughMemory(MemoryForTree(numtaxa, numchars) + 5000, amountneeded) then							opentreeanyway := Cwarning('There may not be enough memory to open tree. Do you want to proceed anyway?', 'Proceed', 'Cancel');					end				else if numtaxa < minTaxaIn then					begin						openTreeAnyway := false;						NewError(107, 0);					end;				if opentreeanyway then					begin						SetCursorToArrow;						if editorOpen then							CloseEdit(true);						if badcellentry then							Exit(GoToTreeWindow);						if whichrow>0 then							begin								OpenTreeWindow;								GoToSingleInfoTree(whichRow);							end						else if treeinmemory then							begin								OpenTreeWindow;								MakeTreeAfterEdit;								CheckNewTaxa;							end						else							db := StartTree;					end;			end;	end;{-------------------------------------------------------------------------}	procedure ShowChainColumnTitle (localpoint: point; whichChain: integer);		var			ds: str255;	begin		if dirtylink[whichChain] then			ds := 'Untitled'		else			ds := curLinkNames[whichChain]^^;		UnderLineToBlanks(ds);		Stripblanks(ds);		if (ds = '') or (ds = ' ') then			ds := 'Untitled';		PopUpStringMenu(localpoint, ds);	end;{-------------------------------------------------------------------------}	function InColumn (whichinfo: integer; wh: point; whichColumn: integer): boolean;	var infoWindowColumn: infoWindowColumnPtr;	begin		infoWindowColumn := InfoColumnPtr(whichinfo, whichColumn);		if infoWindowColumn = nil then			inColumn := false		else if whichColumn <= infoName then			InColumn := ((wh.h > infoWindowColumn^.left) and (wh.h < infoWindowColumn^.right))		else			InColumn := ((wh.h > infoWindowColumn^.left - infoLeft[whichinfo] + 1) and (wh.h < infoWindowColumn^.right - infoLeft[whichinfo] + 1));	end;{-------------------------------------------------------------------------}	function WhichInfoColumn (whichinfo: integer; wh: point): integer;		var			j: integer;	begin		WhichInfoColumn := -1;		for j := 0 to MaximumInfoColumns(whichinfo) do			if InColumn(whichinfo, wh, j) then				begin					WhichInfoColumn := j;					leave;				end;	end;{-----------------------------------------------------------------------------}	procedure DoIncExcTaxaMenu (itemNo: integer);	begin		if not ((frontwindow = infoWindow[taxinfo]) & infoSomeSelected[taxinfo]) then			begin				if ItemNo > 0 then					InstantError(415);			end		else 			IncludeExcludeInfoSelTaxa(ItemNo);	end;{-----------------------------------------------------------------------------}	procedure DoIncExcCharMenu (itemNo: integer);		var			charHdl: chHdl;			tport: windowPtr;			ic, numexcluded: integer;			polyoranc, didchange, warnNotSelected: boolean;			doCharacters, doTaxa: boolean;	begin		if not ((IsTreeWindow(frontwindow) & (traceshown = traceDiscrete)) | ((IsEditorWindow(frontwindow)) & WholeCharSel) | ((frontwindow = infoWindow[charinfo]) & infoSomeSelected[charinfo])| (ItemNo=ExcUninform)) then			begin				if ItemNo > 0 then					InstantError(219);			end		else			DoIncExcCharactersMenu(ItemNo);	end;{-----------------------------------------------------------------------------}	procedure DoImplicitContextIncExcMenu (itemNo: integer);		var			charHdl: chHdl;			tport: windowPtr;			ic, numexcluded: integer;			polyoranc, didchange, warnNotSelected: boolean;			doCharacters, doTaxa: boolean;	begin		doCharacters :=  (IsTreeWindow(frontwindow) & (traceshown = traceDiscrete)) | ((IsEditorWindow(frontwindow)) & WholeCharSel) | ((frontwindow = infoWindow[charinfo]) & infoSomeSelected[charinfo]);		doCharacters := doCharacters | (ItemNo=ExcUninform);		doTaxa := ((frontwindow = infoWindow[taxinfo]) & infoSomeSelected[taxinfo]);		warnNotSelected := not (doCharacters | doTaxa);		if warnNotSelected then			begin				if ItemNo > 0 then					if doTaxa then						InstantError(415)					else						InstantError(219);			end		else if doCharacters then			DoIncExcCharactersMenu(ItemNo)		else if doTaxa then			IncludeExcludeInfoSelTaxa(ItemNo);	end;{----------------------------------------------------------------------------}	procedure MarkPartNamesInUse;		var			thisPart, ic: integer;			oldState: SignedByte;			intP: IP;	begin		for thisPart := 1 to numCharPartNames do 			SetPartNameInUse(thisPart,false);		LockHandle(chPartitionH, oldState);		intP := IP(GetMaster(chPartitionH));		for ic := 1 to numchars do			begin				thisPart:= intP^;				SetPartNameInUse(thisPart,true);				intP := IP(ord4(intP) + chpartb);			end;		ResetHandle(chPartitionH, oldstate);		for thisPart := 1 to numCharPartNames do			if GetPartNameInUse(thisPart) then				SetItemMark(CharpartMHdl, thisPart, 'е')			else				SetItemMark(CharpartMHdl, thisPart, chr(NoMark));	end;{----------------------------------------------------------------------------}	procedure PopUpInfoWindowM (whichinfo: integer; theMHdl: MenuHandle; theMenu: integer; theSpot: point);		var			menucode: longint;			ItemNo, currentsel, j: integer;	begin		if theMHdl = CharpartMHdl then			MarkPartNamesInUse;		 if  Locked(lockAssumptions) & (whichinfo=charinfo)  then		 	Exit(PopUpInfoWindowM);		{ if  Locked(lockTrees) & (whichinfo=taxinfo) & (theMHdl = IncExcMHdl) then		 	Exit(PopUpInfoWindowM);}		 LocalToGlobal(thespot);		currentsel := 1;		menucode := PopUpMenuSelect(theMHdl, thespot.v + 5, thespot.h, currentsel);		ItemNo := LowWord(menucode);		if theMHdl = IncExcMHdl then			begin				if whichInfo = charinfo then					DoIncExcCharactersMenu(ItemNo)				else if whichinfo = taxinfo then					IncludeExcludeInfoSelTaxa(ItemNo);			end		else if theMHdl = TypeMHdl then			DoTypeMenu(ItemNo)		else if theMHdl = CodingMHdl then			DoCodingMenu(ItemNo)		else if theMHdl = WeightMHdl then			DoWeightMenu(ItemNo)		else if theMHdl = CharpartMHdl then			DoCharPartMenu(ItemNo);	end;{----------------------------------------------------------------------------}	procedure PopUpInfoSetM (whichinfo: integer; theSpot: point);		var			menucode: longint;			ItemNo, currentsel: integer;	begin		LocalToGlobal(thespot);		currentsel := 1;		FixSelectMenu(whichinfo);  		menucode := PopUpMenuSelect(InfoSelectMHdl, thespot.v + 5, thespot.h, currentsel);		ItemNo := LowWord(menucode);		DoInfoWindowSelectMenu(whichInfo, ItemNo);	end;{----------------------------------------------------------------------------}	procedure PopUpInfoMoveM (whichinfo, whichRow: integer; theSpot: point);		var			menucode: longint;			ItemNo, currentsel: integer;			db: boolean;	begin		LocalToGlobal(thespot);		currentsel := 1;		FixSelectMenu(whichinfo);  		menucode := PopUpMenuSelect(InfoMoveMHdl, thespot.v + 5, thespot.h, currentsel);		ItemNo := LowWord(menucode);		if ItemNo = 1 then			db := MoveIndividualInfoRow(whichinfo,whichRow, 1) 		else if ItemNo=2 then 			db := MoveIndividualInfoRow(whichinfo,whichRow, MaximumInfoRows(whichInfo)) 	end;{----------------------------------------------------------------------------}	procedure DeletePartNameWithinPartition (H: Handle; theRow, offset: integer);		var			intP: IP;			thisPart: integer;			ic: integer;			oldState: SignedByte;	begin		LockHandle(H, oldState);		intP := IP(GetMaster(H)+offset);		for ic := 1 to numchars do			begin				thisPart:= intP^;				if thisPart = theRow then					intP^ := defaultPartition				else if thisPart > theRow then					intP^ := thisPart - 1;				intP := IP(ord4(intP) + chpartb);			end;		ResetHandle(H, oldstate);	end;{----------------------------------------------------------------------------}	procedure DeletePartNameWithinAllPartitions (theRow: integer);		var			j: longint;			H: Handle;	begin		for j := StartUserLink(charPartitionChain) to EndUserLink(charPartitionChain) do			begin				H := GetDirectLinkH(charpartitionchain, LinkNumberFromInfoRow(charpartitionchain,j));				DeletePartNameWithinPartition(H, theRow, LinkOffSet(H));			end;	end;{-----------------------------------------------------------------------------}	procedure DeleteInfoRows (whichinfo, itstart, itend: integer);		var			tn: Nptr;			it: integer;			cdt: longint;	begin		case whichinfo of			charinfo: 				begin					DestroyCharacters(itstart, itend, true, false,true,false);					godraw := true;					dirtyfile := true;				end;			taxinfo: 				begin					DestroyTaxa(itstart, itend,true,false);					if treeopen then 						begin							godraw := true;							noundo := true;						end;					dirtyfile := true;				end;			nexusblockinfo:				begin					for it := itend downto itstart do						DestroyNexusBlock(it);					InvalidateInfoWindow(nexusblockinfo);				end;			charpartnameinfo:				begin					for it := itend downto itstart do						begin							DeletePartNameWithinPartition(chPartitionH,it,0);							DeletePartNameWithinPartition(chStorePartitionH,it,0);							DeletePartNameWithinAllPartitions(it);							DestroyCharPartName(it);						end;					InvalidateInfoWindow(charpartnameinfo);					InvalidateInfoWindow(charpartinfo);					if infoOpen[charinfo] then						InvalidateInfoColumn(charinfo,CharInfoPartition, 1,numchars);				end;			treeinfo: 				begin					for it := LinkNumberFromInfoRow(treechain,itend) downto  LinkNumberFromInfoRow(treechain,itstart) do						RemoveLink(treechain, it);					godraw := true;					if treefile then 						dirtytreefile := true					else						dirtyfile := true;				end;			typesetinfo, wtsetinfo, exsetinfo, charsetinfo, taxsetinfo, charpartinfo:				begin					for it := LinkNumberFromInfoRow(ChainFromInfo(whichinfo),itend) downto  LinkNumberFromInfoRow(ChainFromInfo(whichinfo),itstart) do						begin							RemoveLink(ChainFromInfo(whichinfo), it);						end;					if whichinfo=taxsetinfo then						for it := itend downto itstart do							begin								if editorConsensusTaxSet <> AllTaxSet then									if editorOpen then InvalidateWindow(editorWindow,true);								if it = editorConsensusTaxSet then									editorConsensusTaxSet := AllTaxSet								else if it < editorConsensusTaxSet then									editorConsensusTaxSet := editorConsensusTaxSet-1;															end;					if whichinfo=charsetinfo then						for it := itend downto itstart do							begin								if editorCharacterSetToShade <> defaultCharSetToShade then									if editorOpen then InvalidateWindow(editorWindow,true);								if it = editorCharacterSetToShade - FirstUserShadeCharSet+1 then									editorCharacterSetToShade := defaultCharSetToShade								else if it < editorCharacterSetToShade - FirstUserShadeCharSet+1 then									editorCharacterSetToShade := editorCharacterSetToShade-1;															end;					godraw := true;					dirtyfile := true;				end;			otherwise				;		end;	end;{-----------------------------------------------------------------------------}	procedure DeleteSelectedInfoWindowRows (whichInfo: integer);		var			j, jstart: integer;			numElements: integer;			theChain: integer;	begin		j := 1;		{SetCursor(clockCursor);}		numElements := MaximumInfoRows(whichInfo);		case whichinfo of			treeinfo:				begin					if InfoRowSelected(treeinfo, InfoRowFromLinkNumber(treeChain,linknumber[treechain])) then						begin							linkNumber[treechain] := 0;							SetDirtyTree;						end;				end;			typesetinfo, wtsetinfo, exsetinfo, charsetinfo, taxsetinfo, charpartinfo:				begin					theChain := ChainFromInfo(whichinfo);					if InfoRowSelected(whichinfo, InfoRowFromLinkNumber(theChain,linknumber[theChain])) then						begin							linkNumber[theChain] := 0;							dirtyLink[theChain] := true;						end;				end;			charinfo:				begin					if statesWindowOpen then						begin							TurnOffStatesEditing;							TurnOffSymbolsEditing;						end;				end;			otherwise;		end;		repeat			if InfoRowSelected(whichinfo, j) then				begin					SpinBeachBall;					jstart := j;					repeat						j := j + 1;					until (j > numElements) | not InfoRowSelected(whichinfo, j);					DeleteInfoRows(whichinfo, jstart, j - 1);					numElements := numElements - (j - jstart);					j := jstart+1;				end			else				j := j + 1;		until j > numElements;					case whichinfo of			treeinfo: 				begin					if treeopen then						begin							ChangeStoredTreesGoList;							InvalidateWindow(tlegwindow, true);						end;				end;			charsetinfo:				RebuildShadeCharSetMenu;			taxsetinfo:				begin					RebuildConsensusTaxSetMenu;				end;			taxinfo:				begin					if dirtymaxst then						ReCalcMaxstAndStates(1,numchars);					InvalidateInfoWindow(charinfo);					InvalidateInfoWindow(taxinfo);					InvalidateWindow(editorWindow, true);				end;			charinfo:				begin					if treeopen then						InvalidateWindow(chlegwindow, true)					else						InvalidateWindow(editorWindow,true);					InvalidateInfoWindow(charinfo);					InvalidateInfoWindow(taxinfo);					InvalidateWindow(editorWindow, true);				end;			otherwise				;		end;		ResetInfoScroll(whichinfo);		SizeInfoWindow(whichinfo,true,false);		CheckInfoSomeSelected(whichinfo);		ChangeInfoSelectMenuFix(whichinfo);	end;{----------------------------------------------------------------------------}	{----------------------------------------------------------------------------}	function SomeSelectedInfoRowsUndeletable(whichinfo: integer): boolean;	var ir: integer;	begin		SomeSelectedInfoRowsUndeletable:= false;				if not InfoRowsDeletable(whichinfo) then			SomeSelectedInfoRowsUndeletable:= true		else if (whichinfo=nexusblockinfo) then			begin				for ir := 1 to MaximumInfoRows(whichinfo) do					if inforowselected(whichinfo,ir) & not NexusBlockForeign(ir) then						begin							SomeSelectedInfoRowsUndeletable:= true;							leave;						end;			end;			end;{----------------------------------------------------------------------------}	procedure QueryDeleteSelectedInfoRows (whichinfo:integer);	var 	ds: str255;	begin		if not InfoRowsDeletable(whichinfo) | SomeSelectedInfoRowsUndeletable(whichinfo) then			Exit(QueryDeleteSelectedInfoRows);		case whichinfo of			treeinfo:				begin					if charton & (CWChart = CWCC2T) then						ds := 'Are you sure you want to permanently delete the selected trees (chart will automatically close)?'					else						ds := 'Are you sure you want to permanently delete the selected trees?';				end;			otherwise 				ds := concat('Are you sure you want to permanently delete the selected ', MakeSmall(InfoObjectName[whichinfo]), '?');		end;				if editorOpen & editorSelected & ((whichinfo=charinfo) | (whichinfo=taxinfo)) then			begin				UnSelectAll;				if badcellentry then					Exit(QueryDeleteSelectedInfoRows);			end;		if CWarning(ds, 'Delete', 'Cancel') then			DeleteSelectedInfoWindowRows(whichInfo);	end;{----------------------------------------------------------------------------}	procedure OpenEditNexusBlockNumber(blockNumber: integer);	var theNexusBlock: NexusBlockPtr;		oldState: SignedByte;	begin		theNexusBlock := NexusBlock(blockNumber);		if (theNexusBlock<>nil) & NexusBlockIsEditable(theNexusBlock) then			begin				if textWindowInfo[NexusBlockText]^.open then					if nexusBlockBeingEdited<>theNexusBlock then						ReturnNexusBlockText;				if not (textWindowInfo[NexusBlockText]^.open & (nexusBlockBeingEdited=theNexusBlock)) then					begin						{ReturnNexusBlockText;}						LockHandle(theNexusBlock^.H,oldState);						TESetText(theNexusBlock^.H^, GetHandleSize(theNexusBlock^.H), textWindowInfo[NexusBlockText]^.TE);						ResetHandle(theNexusBlock^.H,oldState);						TECalText(textWindowInfo[NexusBlockText]^.TE);					end;				if not textWindowInfo[NexusBlockText]^.open then					OpenTextWindow(NexusBlockText)				else					begin						InvalidateWindow(textWindow[nexusBlockText],true);						SelectWindow(textWindow[NexusBlockText]);					end;				nexusBlockBeingEdited := theNexusBlock;			end;	end;{----------------------------------------------------------------------------}	procedure UserChoosePartNameColor(whichinfo, whichRow: longint);	var inColor, outColor: RGBColor;		pos: point;	begin		pos.v := 45;		pos.h := 40;		inColor := GetPartNameColor(whichRow);		if GetColor(pos, 'Select color', incolor, outcolor) then			begin				SetPartNameColor(whichRow,outColor);				InvalidateInfoColumn(charpartnameinfo,CharPartNameInfoColor,1,numCharPartNames);			end;	end;{----------------------------------------------------------------------------}	procedure UserChooseSelectedPartNameColor;	var inColor, outColor: RGBColor;		pos: point;		 partNumber: longint;	begin		pos.v := 45;		pos.h := 40;		if FirstInfoRowSelected(charpartnameinfo,partNumber) then			begin				inColor := GetPartNameColor(partNumber);				if GetColor(pos, 'Select color', incolor, outcolor) then					begin						for partNumber := 2 to numCharPartNames do							if InfoRowSelected(charpartnameinfo,partNumber) then								SetPartNameColor(partNumber,outColor);						InvalidateInfoColumn(charpartnameinfo,CharPartNameInfoColor,1,numCharPartNames);					end;			end;					end;{----------------------------------------------------------------------------}	procedure UseSelectedObject(whichinfo, whichRow: longint);	var didchange: boolean;		theChain: integer;	begin		theChain := ChainFromInfo(whichinfo);		if (whichRow >= 0) & (whichRow <= MaximumInfoRows(whichinfo)) then			case whichinfo of				charinfo: 					if (not ((traceshown = traceDiscrete) & (i = whichRow)) & treeopen & CharIncluded(whichRow)) then						begin							genericSetPort(treewindow);							SetClip(TWClip);							TurnOnTrace(i, whichRow);							InvalidateInfoWindow(charinfo);							genericSetPort(infoWindow[whichinfo]);						end				taxinfo: 					;				typeinfo: 					;				typesetinfo,exsetinfo,wtsetinfo,charpartinfo:					begin						linknumber[theChain] := LinkNumberFromInfoRow (theChain,whichRow);  						ChooseLink(theChain, true);						InvalidateWindow(infoWindow[charinfo],false);						InvalidateWindow(infoWindow[taxinfo],false);						InvalidateWindow(tlegwindow,false);						if (whichinfo=charpartinfo) then							begin								if not charInfoShowPartition then									ShowCharPartitionColumn;								charPartitionsChanged := true;							end;					end;				charsetinfo:					begin						didchange:= false;						CheckSelectMode;						if selectMode = selectIntersection then							infoSomeSelected[charinfo] := false						else if selectMode = selectReplace then								begin									SetAllInfoDeSelected(charinfo);									didchange := true;								end;						SelectChosenSet(charinfo, whichRow-1, didchange);						FixAssumpMenu;						if didchange then							InvalidateWindow(infoWindow[charinfo], false);					end;				taxsetinfo:					begin						didchange:= false;						CheckSelectMode;						if selectMode = selectIntersection then							infoSomeSelected[taxinfo] := false						else if selectMode = selectReplace then								begin									SetAllInfoDeSelected(taxinfo);									didchange := true;								end;						SelectChosenSet(taxinfo, whichRow-1, didchange);						FixAssumpMenu;						if didchange then							InvalidateWindow(infoWindow[taxinfo], false);					end;				treeinfo: 					if treeopen then						GoToSingleInfoTree(whichRow)					else						GoToTreeWindow(whichRow);				nexusblockinfo:					begin						if not Locked(lockData) then							OpenEditNexusBlockNumber(whichRow);					end;				charpartnameinfo:					begin						if whichRow <> 1 then							begin								UserChoosePartNameColor(whichinfo, whichRow);								SelectInfoCell (whichinfo,whichRow,false,true);								infoSomeSelected[whichinfo] := false;							end;					end;				otherwise					Beep;			end;	end;{----------------------------------------------------------------------------}const	infoWindowUseBoxRounding=10;	{----------------------------------------------------------------------------}	procedure MouseInOrOutOfButton(box: rect; wh: point; roundbutton: boolean; var inButton:boolean);	var oldClip: RgnHandle;	begin		if inButton <> PtInRect(wh,box) then			begin				oldClip := NewRgn;				GetClip(oldClip);				ClipRect(box);				InsetRect(box,1,1);				inButton := not inButton;				if roundbutton then					InvertRoundRect(box,infoWindowUseBoxRounding,infoWindowUseBoxRounding)				else					InvertRect(box);				SetClip(oldClip);			end;	end;{----------------------------------------------------------------------------}{	function MouseUpInBox(box: rect): boolean;	var wh: point;		inButton: boolean;	begin		InvertRoundRect(box,infoWindowUseBoxRounding,infoWindowUseBoxRounding);		inButton:= true;		repeat			GetMouse(wh);			MouseInOrOutOfButton(box,wh,true,inButton);		until not StillDown;		if inButton then 			InvertRoundRect(box,infoWindowUseBoxRounding,infoWindowUseBoxRounding);		GetMouse(wh);		MouseUpInBox:= PtInRect(wh,box);	end;}{----------------------------------------------------------------------------}	function firstCharacterWithPartName(whichRow: integer): longint;	var ic, firstChar, lastChar : longint;	begin		firstChar := 0;		for ic := FirstVisibleCharacter to numchars do			if (CharPartition(ic) = whichRow) then				begin					firstChar := ic;					leave;				end;		if firstChar = 0 then			begin				for ic := FirstVisibleCharacter -1 downto 1 do					if (CharPartition(ic) = whichRow) then						begin							firstChar := ic;							leave;						end;				if (firstChar > 1) then					begin						lastChar := firstChar;						firstChar := lastChar-numVisibleEditorCharacters+1;						for ic := lastChar -1 downto lastChar-numVisibleEditorCharacters+1 do							if (CharPartition(ic) <> whichRow) then								begin									firstChar := ic;									leave;								end;					end;			end;		firstCharacterWithPartName := firstChar;	end;{----------------------------------------------------------------------------}	procedure GoToInfoRowObjectInEditor (whichinfo, whichRow: integer);	var			taxonGoTo, characterGoTo: integer;	begin		taxonGoTo := 0;		characterGoTo := 0;//theChain := ChainFromInfo(whichinfo);		if (whichRow >= 0) & (whichRow <= MaximumInfoRows(whichinfo)) then			case whichinfo of				charinfo: 					characterGoTo := whichRow;				taxinfo: 					taxonGoTo := whichRow;				charpartnameinfo:					if whichRow <> 1 then						characterGoTo := firstCharacterWithPartName(whichRow);				otherwise					;			end;		if (taxonGoTo > 0)|(characterGoTo > 0) then			if editorTransposed then				ScrolltoRectangle(characterGoTo,characterGoTo,taxonGoTo,taxonGoTo,true,true)			else				ScrollToRectangle(taxonGoTo,taxonGoTo,characterGoTo,characterGoTo,true,true);	end;{----------------------------------------------------------------------------}	procedure AddSubtractSelectedToSet(frominfo,toinfo: integer; toRow: longint; add: boolean);	var name : str255;		toChain: integer;		linkH: Handle;		j: integer;	begin		linkH := NewHandle(2);		if (toinfo=charSetInfo) then			toChain:= charSetChain		else if (toinfo=taxsetInfo) then			toChain:= taxSetChain		else			Exit(AddSubtractSelectedToSet);		name := LinkNameFromChain(toChain, toRow-1);		LinkNumber[toChain] := toRow-1;		ChooseLink(toChain, false);				if (toChain=charSetChain) then			begin				for j := 1 to MaximumInfoRows(frominfo) do					if InfoRowSelected(fromInfo, j) then						setInCharSet(j,add);				MemoryToCharExSet(linkH, name, toChain);			end		else			begin				for j := 1 to MaximumInfoRows(frominfo) do					if InfoRowSelected(fromInfo, j) then						setInTaxSet(j,add);				MemoryToTaxSet(linkH, name);			end;		SetLink(toChain, toRow-1, linkH);		ZapHandle(linkH);				dirtyfile := true;		AdjustAllNexusBlockWillWrites;		InvalidateInfoWindow(toInfo);	end;{----------------------------------------------------------------------------}	function MouseOutOfInfoWindow(whichinfo: integer; wh: point): boolean;	var windoLoc: integer;		whichWindow,tempP: WindowPtr;	begin		genericGetPort(tempP);		genericSetPort(infoWindow[whichinfo]);		LocalToGlobal(wh);		WindoLoc := FindWindow(wh, WhichWindow);		MouseOutOfInfoWindow:= whichwindow <> infowindow[whichinfo];		genericSetPort(tempP);	end;{----------------------------------------------------------------------------}	procedure InfoDragSetElements(frominfo, toinfo: integer; wh: point; add: boolean);	var	windoLoc: integer;		whichWindow: WindowPtr;		wPort: CGrafPtr;		tempP: WindowPtr;		whichRow: integer;	begin		genericGetPort(tempP);		genericSetPort(infoWindow[frominfo]);		LocalToGlobal(wh);				WindoLoc := FindWindow(wh, WhichWindow);		if whichwindow = infowindow[toinfo] then			begin				genericSetPort(infoWindow[toInfo]);				GlobalToLocal(wh);				whichRow := infoRowFromHeight(toinfo,wh.v);				if (whichRow<=0) | (whichRow> MaximumInfoRows(toinfo)) | (wh.v <= infoLW[toinfo] ) | (wh.v > infoDrawRect[toinfo].bottom - scrollwidth - 1)then					begin						if add then							MakeNewObject(SelectSetInfoFromObjectInfo(frominfo),'',true, false,true);					end				else					AddSubtractSelectedToSet(fromInfo,toInfo,whichRow,add);								end;		genericSetPort(tempP);	end;{----------------------------------------------------------------------------}	procedure MoveOrSelectInfoRow (whichinfo, ic: integer);		var			releasedWh: point;			releasedic: integer;			upScrollBox, downScrollBox, highlightBox,highLightClipRect: rect;			highlightWindow, tempP: WindowPtr;			numElements: integer;			inTrashButton,inUseButton, highlightObject: boolean;			N: NPtr;	begin		SelectInfoCell(whichinfo, ic, true,true);		highlightObject := false;		highlightWindow := nil;		upScrollBox:= infoDrawRect[whichinfo];		upScrollBox.bottom:= infoLW[whichinfo];		downScrollBox:= infoDrawRect[whichinfo];		downScrollBox.top:= infoDrawRect[whichinfo].bottom-scrollwidth;		numElements := MaximumInfoRows(whichinfo);		inTrashButton:= false;		inUseButton:= false;		genericGetPort(tempP);		if (whichinfo=taxinfo) & treeopen then			begin				NPtrOfTaxon(ic,N);				if (N<>nil) then					begin						SetRect(highlightBox,N^.loc.h - 2, N^.loc.v - 10-StringWidth(TaxonName(ic))-2,N^.loc.h + FontHeight-1,  N^.loc.v - 8);						highlightObject := true;						highlightWindow := treeWindow;						highLightClipRect := visTWR;					end;			end;		if highlightObject & (highlightWindow<>nil) then			begin				genericSetPort(highlightWindow);				ClipRect(highLightClipRect);				InvertRect(highlightBox);			end;		genericSetPort(tempP);		repeat			GetMouse(releasedWh);			if OptionEvent(Event) & MouseOutOfInfoWindow(whichinfo,releasedWh) then				if CommandEvent(Event) then					SetCursID(176)				else					SetCursID(175)			else				SetCursH(handcurs);			PenMode(patXor);			PenSize(3, 3);			penpat(QDltGray);			moveTo(releasedWh.h, releasedWh.v);			lineto(WindowPortRect(infowindow[whichInfo]).right - scrollwidth - 1, releasedWh.v);			Delay(3, ticks);			lineTo(releasedWh.h, releasedWh.v);			PenNormal;						if PtInRect(releasedWh,upScrollBox) & (infoTop[whichinfo] > 1) then				begin					scrollup := true;					currentInfo := whichinfo;					ScrollInfoUpDown(infoScroll[whichinfo],kControlUpButtonPart);				end			else if PtInRect(releasedWh,downScrollBox) & not infoRowVisible(whichinfo,numElements) then				begin					scrollup := false;					currentInfo := whichinfo;					ScrollInfoUpDown(infoScroll[whichinfo],kControlDownButtonPart);				end			else if (infoWithButtons[whichinfo] | infoWithToolRow[whichinfo])  then				begin					if infoTools^[whichinfo,infoScissorsT].enabled then						MouseInOrOutOfButton(infoTools^[whichinfo,infoScissorsT].R, releasedWh,false, inTrashButton);					{if (whichinfo<>charinfo)|treeopen then						MouseInOrOutOfButton(infoUseButtonBox[whichinfo], releasedWh,true,inUseButton);}				end;					until not StillDown;		if highlightObject & (highlightWindow<>nil) then			begin				genericGetPort(tempP);				genericSetPort(highlightWindow);				InvertRect(highlightBox);				genericSetPort(tempP);			end;		if infoWithToolRow[whichinfo] then			begin 				if inTrashButton then					InvertInsideRect(infoTools^[whichinfo,infoScissorsT].R);				{if inUseButton then					InvertRoundRect(infoUseButtonBox[whichinfo],infoWindowUseBoxRounding,infoWindowUseBoxRounding);}			end;		GetMouse(releasedWh);		if infoWithToolRow[whichinfo] then			if  PtInRect(releasedWh,infoTools^[whichinfo,infoScissorsT].R) then				begin					QueryDeleteSelectedInfoRows(whichinfo);					Exit(MoveOrSelectInfoRow);				end;		{	else if infoWithButtons[whichinfo]& PtInRect(releasedWh, InfoUseButtonBox[whichinfo]) & ((whichinfo<>charinfo)|treeopen) then				begin					UseSelectedObject(whichinfo,ic);					Exit(MoveOrSelectInfoRow);				end;			} //\\		if OptionEvent(Event) & MouseOutOfInfoWindow(whichinfo,releasedWh) then			begin			 	if whichinfo=charinfo then			 		InfoDragSetElements(charinfo, charsetinfo, releasedWh,not CommandEvent(Event))			 	else if whichinfo=taxinfo then			 		InfoDragSetElements(taxinfo, taxsetinfo, releasedWh,not CommandEvent(Event));			 	Exit(MoveOrSelectInfoRow);			end;				if releasedWh.v > WindowPortRect(infowindow[whichInfo]).bottom-infoButtonRowHeight then			Exit(MoveOrSelectInfoRow);					if releasedWh.v - infoLW[whichinfo] * infoTitleLines - infoLW[whichinfo] div 2 < 0 then			releasedic := infoTop[whichinfo] - 1		else			releasedic := infoTop[whichinfo] + (releasedWh.v - infoLW[whichinfo] * infoTitleLines - infoLW[whichinfo] div 2) div infoLW[whichinfo];		if releasedic > MaximumInfoRows(whichinfo) then			releasedic := MaximumInfoRows(whichinfo);		if releasedic < ic then			releasedic := releasedic+1;		if (releasedic <> ic) {and (releasedic <> ic - 1)} then			if LegalMove(whichinfo, ic, releasedic) then				begin					SelectInfoCell(whichinfo, ic, false,false);					SetUpBeforeRowMove(whichinfo);					if  MoveIndividualInfoRow(whichinfo, ic,releasedic) then						CleanUpAfterRowMove(whichinfo,false);					InvalidateAllWindowsMarkedUnupdatable;					SelectInfoCell(whichinfo, releasedic, true,true);				end			else				Beep;	end;{----------------------------------------------------------------------------}	var		lastclickic: integer;{----------------------------------------------------------------------------}	procedure ShimmerColumnOutline2 (box: rect);	begin		PenMode(patXor);		PenSize(3, 3);		PenPat(QDBlack);		FrameRect(box);		PenNormal;	end;{----------------------------------------------------------------------------}	procedure ShimmerColumnOutline (box: rect);	begin		PenMode(patXor);		PenSize(3, 3);		PenPat(QDBlack);		FrameRect(box);		Delay(1, ticks);		FrameRect(box);		PenNormal;	end;{----------------------------------------------------------------------------}	procedure InfoDragAndDrop(frominfo,fromColumn, toinfo,toChain: integer);	var wh, oldwh: point;		windoLoc: integer;		whichWindow: WindowPtr;		wPort: CGrafPtr;		tempP: WindowPtr;		box: rect;		TL, BR: point;	begin		genericGetPort(tempP);		genericSetPort(infoWindow[frominfo]);		GetMouse(oldWh);				TL.v := 0;		TL.h := InfoColumnLeft(frominfo, fromColumn);		BR.v := WindowPortRect(infoWindow[frominfo]).bottom;		BR.h := InfoColumnRight(frominfo, fromColumn);		SetRect(box, TL.h, TL.v, BR.h, BR.v);{$IFC NOT CARBON}		GetCWMgrPort(wPort);		genericSetPort(WindowPtr(wPort));{$ENDC}		ClipRect(ScreenBoundsRect);  		{OffSetRect(box,wh.h-oldwh.h, wh.v-oldwh.v); } {**}		ShimmerColumnOutline2(box);{**}		repeat			GetMouse(wh);			if not EqualPt(wh,oldwh) then				begin					ShimmerColumnOutline2(box);					OffSetRect(box,wh.h-oldwh.h, wh.v-oldwh.v);					ShimmerColumnOutline2(box);				end;			oldWH := wh;			CallWaitNextEventForDrawing;		until not button;		ShimmerColumnOutline2(box);{**}		LocalToGlobal(wh);				WindoLoc := FindWindow(wh, WhichWindow);		if whichwindow = infowindow[toinfo] then			begin				SaveLinkToChain(toChain, DefaultInfoObjectName(toinfo), false,false);				linknumber[toChain] := EndUserLink(toChain);				AddOpenEditLastInfoRowName(toinfo, true);			end;		genericSetPort(tempP);	end;{----------------------------------------------------------------------------}	procedure ReportOnSelection(wh: point; whichinfo: integer);	var numSelected : longint;		var ds: str255;	begin		ds := concat('Number of rows: ',StringFromNum(MaximumInfoRows(whichinfo)),chr(13));		numSelected := NumberInfoRowsSelected(whichinfo);		if numSelected = 0 then			ds := concat(ds,'No rows selected')		else			ds := concat(ds,'Number of rows selected: ',StringFromNum(numSelected));		PopUpStringMenu(wh, ds);	end;{----------------------------------------------------------------------------}	procedure PopUpInfoMenus (wh: point;whichinfo, whichColumn: longint);		var			towt: integer;		infoWindowColumn: infoWindowColumnPtr;	begin		infoWindowColumn := InfoColumnPtr(whichinfo, whichColumn);		if infoWindowColumn<> nil then			with infoWindowColumn^ do				if (whichColumn = infoName) then					begin						{if menu then }						if (whichinfo <> nexusblockinfo) then							PopUpInfoSetM(whichinfo, wh);					end				else					begin						case whichinfo of							charinfo: 								case columnID of									CharInfoIncExc: 										begin											if OptionEvent(Event) & (dblclick & (lastclickic = 0)) then												OpenOrSelectInfoWindow(exSetInfo)											else if CommandEvent(Event) then												ShowChainColumnTitle(wh, exSetChain)											else												PopUpInfoWindowM(whichinfo, IncExcMHdl, IncExcMenu, wh);										end;									CharInfoCodPos: 										begin											PopUpInfoWindowM(whichinfo, CodingMHdl, CodingMenu, wh)										end;									CharInfoTypes: 										begin											if OptionEvent(Event) then												begin													if dblclick & (lastclickic = 0) then														OpenOrSelectInfoWindow(typesetinfo)													else														InfoDragAndDrop(charinfo,whichColumn,typesetinfo,typeSetChain);												end											{else if dblclick & (lastclickic = 0) then												DefineType(unordered)}											else if CommandEvent(Event) then												ShowChainColumnTitle(wh, TypeSetChain)											else												PopUpInfoWindowM(whichinfo, TypeMHdl, TypeMenu, wh);										end;									CharInfoWeights: 										begin											if OptionEvent(Event) then												begin													if dblclick & (lastclickic = 0) then														OpenOrSelectInfoWindow(wtsetinfo)													else														InfoDragAndDrop(charinfo,whichColumn,wtsetinfo,wtSetChain);												end											else if dblclick & (lastclickic = 0) then												begin													if SetWtDialog( towt) then														ChangeWt(towt);												end											else if CommandEvent(Event) then												ShowChainColumnTitle(wh, wtSetChain)											else												PopUpInfoWindowM(whichinfo, WeightMHdl, WeightMenu, wh);										end;{$IFC CHARPARTITIONS}									CharInfoPartition: 										begin											if OptionEvent(Event) then												begin													if dblclick & (lastclickic = 0) then														OpenOrSelectInfoWindow(charpartinfo)													else														InfoDragAndDrop(charinfo,whichColumn,charpartinfo,charPartitionChain);												end											else if CommandEvent(Event) then												ShowChainColumnTitle(wh, charPartitionChain)											else												PopUpInfoWindowM(whichinfo, CharPartMHdl, CharPartMenu, wh);										end;{$ENDC}									otherwise										;								end;							taxinfo: 								case columnID of									TaxInfoIncExc: 										PopUpInfoWindowM(whichinfo, IncExcMHdl, IncExcMenu, wh);									{TaxInfoRank: 										PopUpTempMenu(whichinfo, TaxInfoRank, wh);}	{								TaxInfoParaphyletic: 										PopUpTempMenu(whichinfo, TaxInfoParaphyletic, wh);									TaxInfoWriteTT: 										PopUpTempMenu(whichinfo, TaxInfoWriteTT, wh);									TaxInfoIncertaeSedis: 										PopUpTempMenu(whichinfo, TaxInfoIncertaeSedis, wh);									TaxInfoExtinct: 										PopUpTempMenu(whichinfo, TaxInfoExtinct, wh);}									{TaxInfoTOLItems:										PopUpInfoWindowM(whichinfo, nxxToLPopUpTaxaMHdl, NetLinkMenu, wh);									TaxInfoNetLinks: 										PopUpInfoWindowM(whichinfo, NetLinkMHdl, NetLinkMenu, wh);}									otherwise										;								end;							otherwise								;						end;					end;	end;{----------------------------------------------------------------------------}	procedure MouseInInfoTitleLine (wh: point;whichinfo, whichColumn: integer);		var			towt: integer;		infoWindowColumn: infoWindowColumnPtr;	begin		if whichColumn=notAColumn then			ReportOnSelection(wh, whichinfo)		else			begin				infoWindowColumn := InfoColumnPtr(whichinfo, whichColumn);				if infoWindowColumn<> nil then					with infoWindowColumn^ do						if (currentInfoTool[whichinfo]=infoSortAscendingT) & InfoColumnSortable(whichInfo,columnID) then							SortByColumn(whichinfo,columnID, OptionEvent(Event))						else if (currentInfoTool[whichinfo]=infoSortDescendingT) & InfoColumnSortable(whichInfo,columnID)& PtInRect(wh,infoDrawRect[whichinfo]) then							SortByColumn(whichinfo,columnID, not OptionEvent(Event))						else PopUpInfoMenus(wh,whichinfo,whichColumn);			end;	end;{----------------------------------------------------------------------------}	procedure DelayedClickInInfoColumn (wh: point; whichinfo, whichColumn: longint);	var prevTime: longint;	begin		prevTime := TickCount;		while StillDown do			begin				if TickCount - prevTime > 30 then					begin						PopUpInfoMenus(wh,whichinfo,whichColumn);						leave;					end;			end;	end;{----------------------------------------------------------------------------}	procedure DoubleClickInInfoContent (whichinfo, whichColumn, whichRow: longint);	begin		TurnOffInfoEditing(whichinfo);		UseSelectedObject(whichinfo,whichRow);		if (whichinfo <> charpartnameinfo) then			SelectInfoCell(whichinfo, whichRow, true,true);	end;{----------------------------------------------------------------------------}	function PtInInfoToolRects(wh: point; whichinfo: integer; var whichTool: integer): boolean;	var j: integer;	begin		whichTool := 0;		PtInInfoToolRects := false;		for j := 0 to numInfoTools do			if PtInRect(wh,infoTools^[whichinfo,j].R) & infoTools^[whichinfo,j].enabled then				begin					whichTool := j;					PtInInfoToolRects := true;					leave;				end;	end;{----------------------------------------------------------------------------}	procedure ClickInInfoWindow (whichinfo: integer);		var			box: rect;			tempi, ic, j, k, height: integer;			columnID: longint;			tport: windowptr;			whichColumn, whichTool: integer;			whichRow: longint;			ds: str255;			theControlPart: integer;			whichControl: ControlHandle;	begin		genericGetPort(tport);		genericSetPort(infoWindow[whichinfo]);{little box just above grow box: SetRect(reportBox,myGetControlRect(infoHScroll[whichinfo]).right,myGetControlRect(infoHScroll[whichinfo]).top,WindowPortRect(infowindow[whichInfo]).right,myGetControlRect(infoHScroll[whichinfo]).bottom);}		wh := Event.where;		GlobalToLocal(wh);		theControlPart := FindControl(wh, infoWindow[whichinfo], whichControl);				if (theControlPart<>0) & (whichControl<>nil) then			begin				ClipRect(WindowPortRect(infoWindow[whichinfo]));				if (whichControl=infoWindowButton[whichinfo])& SingleInfoRowSelected(whichinfo,whichRow)  & (MyTrackControl(infoWindowButton[whichinfo],wh,nil)<>0) then					UseSelectedObject(whichinfo,whichRow) 				else if (whichControl=infoScroll[whichinfo]) then					DoInfoScroll(whichinfo)				else if (whichControl=infoHScroll[whichinfo]) then					DoInfoScroll(whichinfo)	{	else if ptinrect(wh, myGetControlRect(infoWindowButton[whichinfo])) & infoWithButtons[whichinfo] & ((whichinfo<>charinfo)|treeopen) & SingleInfoRowSelected(whichinfo,whichRow)  then			UseSelectedObject(whichinfo,whichRow)		else if ptinrect(wh, myGetControlRect(infoScroll[whichinfo])) then			DoInfoScroll(whichinfo)		else if ptinrect(wh, myGetControlRect(infoHScroll[whichinfo])) then			DoInfoScroll(whichinfo)		}			end		else if wh.v > infoDrawRect[whichInfo].bottom - scrollwidth - 1 then			begin				if PtInRect(wh, InfoWindowLockBox(whichInfo)) then					begin						infoLocked[whichinfo] := not infoLocked[whichinfo];						if infoLocked[whichinfo] & infoEditing[whichinfo] then							TurnOffInfoEditing(whichinfo);						DrawInfoWindowLock(whichinfo);{$IFC COLORINFOBACKGROUND}						InvalidateInfoColumn(whichinfo, InfoName, 1, MaximumInfoRows(whichinfo));{$ENDC}					end				else if (wh.v<myGetControlRect(infoHScroll[whichinfo]).bottom) then					PopUpFreeMemory(wh)			{	else if PtInRect(wh, InfoUseButtonBox[whichinfo]) & ((whichinfo<>charinfo)|treeopen) then					begin						if SingleInfoRowSelected(whichinfo,whichRow)  & MouseUpInBox( InfoUseButtonBox[whichinfo]) then							UseSelectedObject(whichinfo,whichRow);					end			}				else if PtInInfoToolRects(wh, whichinfo,whichTool) & infoTools^[whichinfo,whichTool].enabled then					begin						if currentInfoTool[whichinfo]<>whichTool then							begin								InvertInsideRect(infoTools^[whichinfo,currentInfoTool[whichinfo]].R);								InvertInsideRect(infoTools^[whichinfo,whichTool].R);							end;						currentInfoTool[whichinfo] := whichTool;						{if infoSomeSelected[whichinfo] & MouseUpInBox(infoTools^[whichinfo,infoScissorsT].R) then							QueryDeleteSelectedInfoRows(whichinfo);}					end			end		else if not equivcycle then			begin				whichColumn := WhichInfoColumn(whichinfo, wh);				columnID := InfoColumnID(whichinfo, whichColumn);				if wh.v <= infoLW[whichinfo] then{||||||||||||||||||||||||||||||||| in title line |||||||||||||||||||||||||||||||||}					begin						MouseInInfoTitleLine(wh,whichinfo, whichColumn);						lastclickic := 0;					end				else{||||||||||||||||||||||||||||||||| in main body of window |||||||||||||||||||||||||||||||||}					begin{tempi := (wh.v - infoLW[whichinfo]) div infoLW[whichinfo];}						ic := infoRowFromHeight(whichinfo,wh.v);						if infoSomeSelected[whichinfo] then							if not CommandEvent(Event) & not ShiftEvent(Event) & not OptionEvent(Event) & not ((currentInfoTool[whichinfo]=infoScissorsT)& infoRowSelected(whichinfo,ic)) then  								DeSelectAllInfo(whichinfo)							else if (currentInfoTool[whichinfo]=infoSortAscendingT) | (currentInfoTool[whichinfo]=infoSortDescendingT) then								DeSelectAllInfo(whichinfo);						height := InfoHeight(whichinfo, ic);						if ic <= MaximumInfoRows(whichinfo) then							begin								if (whichColumn = InfoName) & not (infoLocked[whichinfo] | InfoNameLocked(whichinfo, ic))& not InfoToolWorksOnNames(currentInfoTool[whichinfo]) then									begin										if infoEditing[whichinfo] & (ic = infoEditRow[whichinfo]) then											TEClick(wh, ShiftEvent(Event), infoTE[whichinfo])										else											begin												if infoEditing[whichinfo] then													TurnOffInfoEditing(whichinfo);												TurnOnInfoEditing(whichinfo, ic);											end;									end								else if dblclick & (lastclickic = ic) then									DoubleClickInInfoContent(whichinfo, whichColumn, ic)								else if (whichinfo = typeinfo) & (columnID = TypeInfoExpand) then									begin									end								else if (whichinfo = charinfo) & (columnID = CharInfoExpand) then									if statesWindowOpen & (statesWindowCharacter = ic) then										begin											{CloseStatesWindow;}										end									else										begin											if statesWindowOpen then												InvalidateInfoColumn(charinfo, whichColumn, statesWindowCharacter, statesWindowCharacter);											statesWindowCharacter := ic;											OpenStatesWindow(not statesWindowOpen, Event.where.h + 16, Event.where.v - 7);										end								else									begin										if (ControlEvent(Event) & CommandEvent(Event) & not OptionEvent(Event)) then											PopUpInfoMoveM(whichinfo,ic,wh)										else if (whichColumn = infoName) & infoEditing[whichinfo] & (ic = infoEditRow[whichinfo]) & not InfoToolWorksOnNames(currentInfoTool[whichinfo]) then											begin												TEClick(wh, ShiftEvent(Event), infoTE[whichinfo]);												//InstantInfo('Click!');											end										else											begin												//InstantInfo('Click 2!');												TurnOffInfoEditing(whichinfo);												if (currentInfoTool[whichinfo]=infoWandT) & InfoColumnWandable(whichInfo,whichColumn) & PtInRect(wh,infoAllCellsDrawRect[whichinfo]) then													SelectAllWithSameValue(whichinfo,whichColumn, ic,ShiftEvent(Event), CommandEvent(Event), ControlEvent(Event), OptionEvent(Event))												else if (currentInfoTool[whichinfo]=infoSortAscendingT) & InfoColumnSortable(whichInfo,columnID)& PtInRect(wh,infoDrawRect[whichinfo]) then													SortByColumn(whichinfo,columnID, OptionEvent(Event))												else if (currentInfoTool[whichinfo]=infoSortDescendingT) & InfoColumnSortable(whichInfo,columnID)& PtInRect(wh,infoDrawRect[whichinfo]) then													SortByColumn(whichinfo,columnID, not OptionEvent(Event))												else if (currentInfoTool[whichinfo]=infoScissorsT) & infoTools^[whichinfo,currentInfoTool[whichinfo]].enabled & PtInRect(wh,infoAllCellsDrawRect[whichinfo]) then													begin														{if ShiftEvent(Event) then															ShiftSelectInfo(whichinfo, ic)														else if CommandEvent(Event) then															SelectInfoCell(whichinfo, ic, not InfoRowSelected(whichinfo, ic))														else if InfoRowSelected(whichinfo, ic) then															SelectInfoCell(whichinfo, ic, true)														else}															SelectInfoCell(whichinfo,ic,true,true);														if infoRowSelected(whichinfo,ic) then															QueryDeleteSelectedInfoRows(whichinfo);													end												else if ShiftEvent(Event) & not OptionEvent(Event) then													ShiftSelectInfo(whichinfo, ic)												else if CommandEvent(Event) & not OptionEvent(Event) then													SelectInfoCell(whichinfo, ic, not InfoRowSelected(whichinfo, ic),true)  {reverse cell}												else													begin														if whichColumn < 0 then															if ControlEvent(Event) & OptionEvent(Event) & (editorOpen) then																GoToInfoRowObjectInEditor(whichinfo,ic)															else																MoveOrSelectInfoRow(whichinfo, ic)														else															begin																SelectInfoCell(whichinfo, ic, true,true);																if (whichinfo=nexusBlockinfo) & (columnID=NexusBlockInfoLinkText) then																	begin																		ds := InfoCellString(whichinfo,whichColumn,ic);																		if ds <> '' then 																			PlaceTextWhileButtonDown(ds,wh, false);																	end																else																	DelayedClickInInfoColumn(wh,whichinfo,whichColumn);															end;													end;											end;									end;							end;						lastclickic := ic;					end;			end;		SetCursorToArrow;		ChangeInfoSelectMenuFix(whichinfo);		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	procedure MoveSelectionUpDown(whichinfo,whichRow: longint; goup: boolean);	var newRow: integer;	begin		newRow := whichRow;		if goup then			begin				repeat					newRow := newRow-1;				until (newRow=0) | InfoRowSelectable(whichinfo,newRow);				if newRow<>0 then					begin						SelectInfoRow(whichinfo,whichRow,false);						SelectInfoRow(whichinfo,newRow,true);					end				else					Beep;			end		else			begin				repeat					newRow := newRow+1;				until (newRow>MaximumInfoRows(whichinfo)) | InfoRowSelectable(whichinfo,newRow);				if newRow<=MaximumInfoRows(whichinfo) then					begin						SelectInfoRow(whichinfo,whichRow,false);						SelectInfoRow(whichinfo,newRow,true);					end				else					Beep;			end;	end;{-----------------------------------------------------------------------------}	procedure KeyInInfoWindow (whichInfo: integer; theChar: char);		var			charcode,ir: integer;			j: longint;			scrollMax: longint;			success: boolean;			whichRow: longint;	begin		charcode := ord(theChar);		{if EscapeChar(theChar) then			begin				j := GetLongint(concat(InfoObjectName[whichinfo], ': Go to number'), 1, 1, MaximumInfoRows(whichinfo), success);  				if success then					begin						scrollMax := GetControlMaximumLong(infoScroll[whichinfo]);						if j > scrollMax then							j := scrollMax;						SetControlValueLong(infoScroll[whichinfo], j);						ScrollInfoWindow(whichinfo, true);					end;			end		else }		if infoEditing[whichinfo] then			begin				if (charcode = 3) then					TurnOffInfoEditing(whichinfo)				else if (charcode=13) then					begin						TurnOffInfoEditing(whichinfo);						if ShiftEvent(Event) then							begin								ir := infoEditRow[whichinfo]-1;								while (ir>0) & InfoNameLocked(whichinfo,ir) do									ir := ir -1;								if (ir>0) then									begin										TurnOnInfoEditing(whichinfo, ir);									//	ScrollInfoWindowToEditingRow(whichinfo);									end;							end						else							begin								ir := infoEditRow[whichinfo]+1;								while (ir<=MaximumInfoRows(whichinfo)) & InfoNameLocked(whichinfo,ir) do									ir := ir +1;								if (ir<=MaximumInfoRows(whichinfo)) then									begin										TurnOnInfoEditing(whichinfo, ir);									//	ScrollInfoWindowToEditingRow(whichinfo);									end;							end;											end				else					begin						TEKey(theChar, infoTE[whichinfo]);						StoreRowNameForUndo(whichinfo,infoEditRow[whichinfo]);					end;			end		else if infoSomeSelected[whichinfo] then			if  (charcode = 8) then				QueryDeleteSelectedInfoRows(whichinfo)			else if SingleInfoRowSelected(whichinfo,whichRow) then				begin					if (charcode = upA) & (whichrow>1) then						begin							MoveSelectionUpDown(whichinfo,whichRow,true);							if not infoRowVisible(whichinfo,whichRow-1) then								begin									ScrollInfoWindowToSelectedRow(whichinfo);									InvalidateInfoRow(whichinfo, infoTop[whichinfo],infoBottom[whichinfo]);								end							else								InvalidateInfoRow(whichinfo,whichRow-1,whichRow);														end					else if (charcode = downA) & (whichrow<MaximumInfoRows(whichinfo)) then						begin							MoveSelectionUpDown(whichinfo,whichRow,false);							if not infoRowVisible(whichinfo,whichRow+1) then								begin									ScrollInfoWindowToSelectedRow(whichinfo);									InvalidateInfoRow(whichinfo, infoTop[whichinfo],infoBottom[whichinfo]);								end							else								InvalidateInfoRow(whichinfo,whichRow,whichRow+1);						end				end;	end;{-----------------------------------------------------------------------------}end.