unit Startup;{еееееееееееееееееееееее}interface	uses		Printing, QuickDraw, GestaltEqu, Folders,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, 		Windows, Sound, Dialogs, Files, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, 		WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, InfoWindows, BoxUtil, Speech, CharUtil, Legends, 		MenuUtil, CHUNK, About, PrintSpreadSheet, SpreadUtil, DrawSpread, Windows, GenCloseFile, GenOpenFile,		 PrintingUtil, Settings, StartupUtil, ReadUtil{,Navigation};	procedure InitErrors;	procedure KillErrors;	function SystemCheck: boolean;	//procedure SplashOpeningScreen (var theDialog: DialogPtr; var tempP: WindowPtr; var picH: PicHandle);	procedure EndOpeningScreen (theDialog: DialogPtr; tempP: WindowPtr);	function Expired: boolean;		procedure InitMacClade;{еееееееееееееееееееееее}implementation {е$S Startup} {$IFC NOT CARBON}	const		_waitnextevent = $A860;		_unimplemented = $A89F;		_StripAddress = $A055;		_Gestalt = $A1AD;		_InitGraf = $A86E;		_SndPlay = $A805;		_GetEnvirons = $A8B5;{$ENDC}{$SETC DATAFORKPERS = FALSE}{$SETC RUNTIME = FALSE}	var		systemVolumeRefNumber: INTEGER;	{-----------------------------------------------------------------------------}	procedure InitErrors;		var			j, ic: integer;	begin		errorsposted := newPtr(NumErrorWords * 2);		errorsturnedoff := newPtr(NumErrorWords * 2);		ZeroErrorSet(errorsposted);		ZeroErrorSet(errorsturnedoff);		for j := 1 to maxerrorswithchars do  {v3.02:}			for ic := 0 to maxcharsoferrors do				errorswithchars[j, ic] := -1;		goerror := false;	end;{-----------------------------------------------------------------------------}	procedure KillErrors;	begin		ZapPointer(errorsposted);		ZapPointer(errorsturnedoff);	{	ZapPointer(memoryErrors);}	end;{-----------------------------------------------------------------------------}	function ScrambleName (ds: str255; theBit: integer): str255;		var			j: integer;			newds: str255;			sBit: integer;	begin		newds := ds;		sBit := theBit;		for j := 1 to length(newds) do			begin				if sBit > 7 then					SBit := 0;				if BitTst(@newds[j], sBit) then					BitClr(@newds[j], sBit)				else					BitSet(@newds[j], sBit);				sBit := sBit + 1;			end;		ScrambleName := newds;	end;{-----------------------------------------------------------------------------}	function GetUserInfo: boolean;		label			1;		var			theDialog: DialogPtr;			tempP: WindowPtr;			ds1, ds2: str255;			localItemHit: integer;	begin		GetUserInfo := false;		StartDLOG(134, theDialog, tempP);		myShowDialog(theDialog);1:		repeat			ModalDialog(nil, localItemHit);		until localItemHit in [9, 2];		if localItemHit = 9 then			begin				ds1 := GetEditText(theDialog, 3);				ds2 := GetEditText(theDialog, 4);				if (length(ds1) > 3) and (Length(ds2) > 3) then					begin						ds1 := CopyString(ds1, 1, 64);						ds2 := CopyString(ds2, 1, 64);						userName^^ := ds1;						userInstitution^^ := ds2;						GetUserInfo := true;					end				else					begin						InstantInfo('Name and Institution must each be at least four characters long.');  {v3.02}						goto 1;					end;			end;		EndDLOG(theDialog, tempP);	end;{-----------------------------------------------------------------------------}	const		bitPos1 = 16;		bitPos2 = 24;{-----------------------------------------------------------------------------}	procedure GetPersonalization (sH: StringHandle; p: Ptr; posStart: integer);		var			Bit: Integer;			ds: str255;			sp: StringPtr;	begin		sp := StringPtr(ord4(p) + posStart);		ds := sp^;		Bit := IP(ord4(p) + posStart - bitPos1)^;		ds := ScrambleName(ds, Bit);		Bit := IP(ord4(p) + posStart - bitPos2)^;		ds := ScrambleName(ds, Bit);		sH^^ := ds;	end;{-----------------------------------------------------------------------------}	procedure Personalize (sH: StringHandle; p: Ptr; posStart: integer);		var			Bit, Bit2: Integer;			intP: IP;			sp: StringPtr;			ds: str255;	begin		ds := sH^^;		Bit := RandomBetween(0, 7);		intP := IP(ord4(p) + posStart - bitPos1);		intP^ := Bit;								 {record first bit}		ds := ScrambleName(ds, Bit);		{scramble name}		repeat			Bit2 := RandomBetween(0, 7);		until Bit2 <> Bit;		intP := IP(ord4(p) + posStart - bitPos2);		intP^ := Bit2; 							 {record second bit}		sp := StringPtr(ord4(p) + posStart);   {find start of string}		sp^ := ScrambleName(ds, Bit2);		{scramble name again}	end;{-----------------------------------------------------------------------------}	procedure ResourceToPtr (t: restype; resid, psize: integer; p: Ptr; var success: boolean);{note: you must set the current volume appropriately before calling this}		var			H: Handle;	begin		success := false;		UseResFile(FDI^[maccladeFDI].rfFileNum);		H := Get1Resource(t, resid);		{only searches current resource file, as set by previous lines}		if (ResError = noerr) and (H <> nil) then			begin				HLock(H);				BlockMove(Pointer(GetMaster(H)), p, psize);   {presumes pointer p already of correct size}				success := true;				HUnlock(H);				ReleaseResource(H);			end;	end;{-----------------------------------------------------------------------------}	const		persSize = 400;{-----------------------------------------------------------------------------}	function CheckIfPersonalized: boolean;		const			persSize = 400;			persStart = 154;			nameStart = 206;			InstitutionStart = 312;			notpers = 'k_√#╠.(e:K';			pers = 'js8I4s86j─';		var			success: boolean;			sp: StringPtr;			ds: str255;			p: Ptr;			H: Handle;			nameBit, institutionBit: integer;			intP: IP;			curVol, refNum: integer;	begin		iofilename := StringHandle(NewHandle(SizeOf(Str255)));		iofilename^^ := '';		userName := StringHandle(NewHandle(sizeOf(str255)));		userName^^ := '';		userInstitution := StringHandle(NewHandle(sizeOf(str255)));		userInstitution^^ := '';		CheckIfPersonalized := false;		p := NewPtr(persSize);		ResourceToPtr('jars', 128, persSize, p, success);		success := success & not errorflag & (GetPtrSize(P) = persSize);		if not success then   {will fail if jars resource is not of right size, or not present}			InstantInfo('This copy of MacClade has been damaged')		else			begin				ds := StringPtr(ord4(p) + persStart)^;				ds := ScrambleName(ds, 4);				ds := ScrambleName(ds, 6);{$IFC TRUE}				if ds = notpers then   {it is an OK copy of the jars resource, but it is not personalized}					begin						if GetUserInfo then							begin{scramble 2 bits, not the same}								sp := StringPtr(ord4(p) + persStart);								sp^ := ScrambleName(pers, 4);								sp^ := ScrambleName(sp^, 6);								GetDateTime(UInt32(ourRandSeed));								Personalize(userName, p, nameStart);								Personalize(userInstitution, p, InstitutionStart);{$ENDC}								UseResFile(FDI^[maccladeFDI].rfFileNum);								H := Get1Resource('jars', 128);								if H <> nil then									RemoveResource(H);								currentIOPosition := 81;   {v3.05}								if OSSuccessful(PtrToHand(p, H, persSize)) then	{places copy of resources into H}									begin										AddResource(H, 'jars', 128, '');										if OSSuccessful(ResError) then											begin												WriteResource(H);												if OSSuccessful(ResError) then													UpdateResFile(FDI^[maccladeFDI].rfFileNum);												CheckIfPersonalized := ResError = NoErr;											end;									end;								ReleaseResource(H);{    PtrToResource(p, psize, resid, 'jars', '');}{    ResourceToPtr('jars', 128, persSize, p, true, false, success);}{report error if not success}{$IFC TRUE}							end					end				else if ds = pers then   {it is an OK copy of the jars resource, and it is personalized}					begin						CheckIfPersonalized := true;						GetPersonalization(userName, p, nameStart);						GetPersonalization(userInstitution, p, InstitutionStart);					end				else					InstantInfo('This copy of MacClade has been damaged'){$ENDC}			end;		ZapPointer(p);		iofilename^^ := '';	end;{$IFC NOT CARBON}{-----------------------------------------------------------------------------}	function NumToolboxTraps: integer;	begin		if NGetTrapAddress(_InitGraf, ToolTrap) = NGetTrapAddress($AA6E, ToolTrap) then			NumToolboxTraps := $200		else			NumToolboxTraps := $400;	end;{-----------------------------------------------------------------------------}	function TrapAvailable (theTrap: integer): boolean;  {see IM 6 p. 3-8}		const			TrapMask = $0800;		var			tType: TrapType;	begin		if BAND(theTrap, TrapMask) > 0 then			tType := ToolTrap		else			tType := OSTrap;		if tType = ToolTrap then			begin				theTrap := BAND(theTrap, $07FF);				if theTrap >= NumToolBoxTraps then					theTrap := _Unimplemented;			end;		TrapAvailable := NGetTrapAddress(theTrap, tType) <> NGetTrapAddress(_Unimplemented, ToolTrap);	end;{$ENDC}{-----------------------------------------------------------------------------}{-----------------------------------------------------------------------------}	procedure CreateInvisSysFile;		var			theInfo: FInfo;	begin		if FSpGetFInfo(FDI^[betaFileFDI].fs, theInfo) = FNFErr then			begin				resultcode := FSpCreate(FDI^[betaFileFDI].fs, '????', '????',scriptTag);				if (resultCode = noErr) then					begin						resultCode := FSpGetFInfo(FDI^[betaFileFDI].fs, theInfo);						theInfo.fdFlags := fInvisible;   {v3.04}						resultcode := FSpSetFInfo(FDI^[betaFileFDI].fs, theInfo);					end;			end;	end;{-----------------------------------------------------------------------------}	procedure PostSettings;	var j: integer;	begin		SetDataFormat(datatype, false);		if not twfullscreen then			WindowPop(true,true);		for j := 1 to numToolPalettes do			if toolPaletteOpen[j] then				SetLockLegPts(toolPaletteWindow[j], -1);{if writeAddresses then }	{	if autoWriteAddressesFile then 			SaveAddressesFile;}	end;{-----------------------------------------------------------------------------}	function CheckForExchangeFiles: boolean;  {not actually called}	var		pbRec: HParamBlockRec;		vParamBuffer: GetVolParmsInfoBuffer;	begin		pbRec.ioBuffer := @vParamBuffer;              	pbRec.ioCompletion := nil;		pbRec.ioNamePtr := nil;		pbRec.ioReqCount := sizeof(vParamBuffer);		pbRec.iovRefNum := systemVolumeRefNumber;		currentIOPosition := 7000;  		if OSSuccessful(PBHGetVolParmsSync(@pbRec)) then			CheckForExchangeFiles := BTst(vParamBuffer.vMAttrib, bHasFileIDs)		else			CheckForExchangeFiles := false;	end;{-----------------------------------------------------------------------------}	function SystemCheck: boolean;{returns true if current Operating System acceptable}		var			theInfo: FInfo;			response: longint;			isMacOSX1013OrGreater,isMacOSX1010OrGreater, isMacOSX1015OrGreater: boolean;			theNumber: integer;			db: boolean;			prefFolderID, systemVolumnRefNumberID: longint;  {v3.05: }			prefFolderVol: integer;			os: OSErr;			theFileSpec: FSSpec;			j: integer;			mcVol: integer;				begin		FDI := fileDirInfoPtr(NewPtr(SizeOf(fileDirInfoArray)));		for j := 0 to maxFDI do			begin				if not OSSuccessful(FSMakeFSSpec(0,0,'',FDI^[j].fs)) then					InstantInfo('Can''t make FSSpecs');				FDI^[j].rfFileNum := -1;				FDI^[j].dfFileNum := -1;			end;		FDI^[maccladeFDI].rfFileNum := CurResFile;		if OSSuccessful(GetVRefNum(CurResFile, mcVol)) then			if not OSSuccessful(FSMakeFSSpec(mcVol,0,'',FDI^[maccladeFDI].fs)) then				InstantInfo('Can''t make FSSpecs');		systemVolumeRefNumber := FDI^[maccladeFDI].fs.vRefNum;		prefname := CopyString(GetString(1261)^^, 1, 31);		if ResError <> NoErr then			prefname := 'MacClade Preferences';					mayHaveAVBug := false;		colorQDexists := false;		HasStripAddress := false;		hasWaitNextEvent := false;		hasGestalt := false;		hasBalloonHelp := false;		hasSys7StandFile := false;		hasFindFolder := false;		has32BitControlValues := false;		hasAppearanceManager := false;{$IFC FOOTSOUNDS}		hasSndPlay := false;{$ENDC}		hasGetEnvirons := false;		hasAppleEventMgr := false;		hasSpeechManager := false;		useOldFloatingWindows:= true;		hasNavigationalServices := false;		hasExchangeFiles := false;		hasFSSpecCalls := false;		hasNotificationManager := false;		isMacOSX := false;		hasAquaMenuLayout := false;		{Davidv4.1: decide whether to include this section or not.:				if not GetFontNumber(MacCladeFontName, MacCladeSmall) then			begin				if (OpenRFPerm(FontFileName, mcVol, fsRdPerm) = -1) | not GetFontNumber(MacCladeFontName, MacCladeSmall) then					begin					end;			end;		if MacCladeSmall = 0 then}			MacCladeSmall := kFontIDGeneva;		SystemCheck := true;		if not earlyquit then			begin{$IFC NOT CARBON}				hasGestalt := TrapAvailable(_Gestalt);{$ELSEC}				hasGestalt := true;{$ENDC}				if hasGestalt then					begin						prefFolderVol := 0;						prefFolderID := 0;						{systemVolumeRefNumber := SysEnv.sysVRefNum;}{$IFC NOT CARBON}						HasStripAddress := TrapAvailable(_StripAddress);						hasWaitNextEvent := TrapAvailable(_WaitNextEvent);{$IFC FOOTSOUNDS}						hasSndPlay := TrapAvailable(_SndPlay);{$ENDC}						hasGetEnvirons := TrapAvailable(_GetEnvirons);{$ELSEC}						HasStripAddress := true;						hasWaitNextEvent := true;						hasGetEnvirons := true;{$ENDC}						{hasNavigationalServices := NavServicesAvailable; }{ Davidv4.1: check for appearance manager first}{$IFC POWERPC}						hasNavigationalServices := false;						 IF ord4(@NavLibraryVersion) <> kUnresolvedCFragSymbolAddress THEN					                hasNavigationalServices := NavServicesCanRun;						if Gestalt(gestaltMenuMgrAttr, response) = NoErr then							hasAquaMenuLayout := BitTst(@response, 31 - gestaltMenuMgrAquaLayoutBit);						//isMacOSX := hasAquaMenuLayout;{$ELSEC}						hasNavigationalServices := false;{$ENDC}						if Gestalt(gestaltQuickDrawFeatures, response) = NoErr then							colorQDexists := BitTst(@response, 31 - gestaltHasColor);						if Gestalt(gestaltSystemVersion, response) = NoErr then							begin								useOldFloatingWindows := response < 1872;								system7OrGreater := LowWord(response) > $0700;								isMacOSX :=  LowWord(response) >= $1000;								isMacOSX1010OrGreater :=  LowWord(response) >= $1010;								isMacOSX1013OrGreater :=  LowWord(response) >= $1013;								isMacOSX1015OrGreater :=  LowWord(response) >= $1015;							end;						if Gestalt(gestaltFindFolderAttr, response) = NoErr then							hasFindFolder := BitTst(@response, 31 - gestaltFindFolderPresent);						if Gestalt(gestaltStandardFileAttr, response) = NoErr then							begin								hasSys7StandFile := BitTst(@response, 31 - gestaltStandardFile58);							end ;						if Gestalt(gestaltAppearanceAttr, response) = NoErr then							begin								hasAppearanceManager := BitTst(@response, 31 - gestaltAppearanceExists);								if hasAppearanceManager & (Gestalt(gestaltAppearanceVersion, response)=NoErr) then									has32BitControlValues := LowWord(response) > $0110;							end;						if Gestalt(gestaltHelpMgrAttr, response) = NoErr then							hasBalloonHelp := BitTst(@response, 31 - gestaltHelpMgrPresent);						if Gestalt(gestaltNotificationMgrAttr, response)=NoErr then							hasNotificationManager := BitTst(@response, 31 - gestaltNotificationPresent);{$IFC SPEECH}						if Gestalt(gestaltSpeechAttr, response) = NoErr then							hasSpeechManager := BitTst(@response, 31 - gestaltSpeechMgrPresent);{$ENDC}						if Gestalt(gestaltAppleEventsAttr, response) = NoErr then							hasAppleEventMgr := BitTst(@response, 31 - gestaltAppleEventsPresent);{if Gestalt(gestaltPopupAttr, response) = NoErr then hasPopUpCDEF := BitTst(@response, 31 - gestaltPopUpPresent);}						if not (hasSys7StandFile | hasNavigationalServices) then							begin								InstantError(296);								earlyquit := true;								SystemCheck := false;							end;						if not earlyquit & hasFindFolder then							begin								if FindFolder(kOnSystemDisk, kPreferencesFolderType, false, prefFolderVol, prefFolderID) = NoErr then										begin 											os := FSMakeFSSpec(prefFolderVol,prefFolderID,prefname,theFileSpec);											if (os<>noErr) & (os<>FNFErr) then												InstantInfo('Can''t make prefFolderVol FSSpecs')											else												FDI^[preferencesFDI].fs := theFileSpec;{$IFC CARBON}											os := FSMakeFSSpec(prefFolderVol,prefFolderID,betaFile,theFileSpec);											if (os<>noErr) & (os<>FNFErr) then												InstantInfo('Can''t make beta FSSpecs')											else												FDI^[betaFileFDI].fs := theFileSpec;{$ENDC}										end;								if FindFolder(kOnSystemDisk, kSystemFolderType, false, systemVolumeRefNumber, systemVolumnRefNumberID) = NoErr then										begin 											if not OSSuccessful(FSMakeFSSpec(systemVolumeRefNumber,0,'',FDI^[systemFDI].fs)) then												InstantInfo('Can''t make sysVol FSSpecs');{$IFC NOT CARBON}											os := FSMakeFSSpec(systemVolumeRefNumber,systemVolumnRefNumberID,betaFile,theFileSpec);											if (os<>noErr) & (os<>FNFErr) then												InstantInfo('Can''t make beta FSSpecs')											else												FDI^[betaFileFDI].fs := theFileSpec;{$ENDC}										end;							end;						if Gestalt(gestaltFSAttr, response) = NoErr then							begin								hasFSSpecCalls := BitTst(@response, 31 - gestaltHasFSSpecCalls);								if hasFSSpecCalls then									hasExchangeFiles := HasFileIDFunctions(systemVolumeRefNumber);{CheckForExchangeFiles;}							end;					end				else					begin						InstantError(296);						earlyquit := true;						SystemCheck := false;					end;			end;		if (isMacOSX & not isMacOSX1010OrGreater) then			begin				InstantError(455);				earlyquit := true;				SystemCheck := false;			end;	//	hasSpeechManager := hasSpeechManager & (not isMacOSX);    		hasSpeechManager := hasSpeechManager & ((not isMacOSX) | isMacOSX1015OrGreater);   	end;{-----------------------------------------------------------------------------}	procedure SplashOpeningScreen (var theDialog: DialogPtr; var tempP: WindowPtr);		var			box,clipbox: rect;			oldfont, oldsize: integer;			ds: str255;			left,top,j: integer;			localitemhit : integer;			db: boolean;	begin		StartDLOG(183, theDialog, tempP);		if theDialog = nil then			begin				InstantError(229);				earlyQuit:= true;				Exit(SplashOpeningScreen);			end;		myShowDialog(theDialog);		CallWaitNextEventForDrawing;		DrawDialog(theDialog);		CallWaitNextEventForDrawing;				genericSetPort(myGetWindowPtrForDialog(theDialog));		DrawOpenAbout(theDialog);		CallWaitNextEventForDrawing;		DrawDialog(theDialog);		CallWaitNextEventForDrawing;	end;{-----------------------------------------------------------------------------}	procedure EndOpeningScreen (theDialog: DialogPtr; tempP: WindowPtr);	begin		EndDLOG(theDialog, tempP);	end;{$IFC BETA  OR EXPIRABLE}{-----------------------------------------------------------------------------}	function Expired: boolean;		var			betaFileFound, maddFileFound, couldntexpire: boolean;			betaFileResult: OSErr;			pastExpiryDate: boolean;			secs: UInt32;			date: DateTimeRec;			theInfo: FInfo;			fileSpec: FSSpec;	begin		Expired := false;		GetDateTime(secs);		SecondsToDate(secs, date);		betaFileResult :=  FSpGetFInfo(FDI^[betaFileFDI].fs, theInfo);		betaFileFound := (noErr = betaFileResult);  {if the FSpGetFInfo call returns NoErr, then beta file found}		fileSpec := FDI^[betaFileFDI].fs;		fileSpec.name := 'MaddArchives';		maddFileFound := FSpGetFInfo(fileSpec, theInfo) = noErr;		pastExpiryDate := (((date.year = expiryYear) and (date.month >= expiryMonth)) or (date.year > expiryYear));		if betaFileFound | (pastExpiryDate & not maddFileFound) then			begin				couldntexpire := false;				if not betaFileFound then					begin						CreateInvisSysFile;						RemoveResource(Get1Resource('DLOG', 183));						RemoveResource(Get1Resource('DITL', 183));						UpdateResFile(FDI^[maccladeFDI].rfFileNum);						if ResError <> NoErr then							begin								InstantError(228);								couldntexpire := true;							end;					end;				if not couldntexpire then					InstantError(229);				Expired := true;			end;	end;{$ENDC}{-----------------------------------------------------------------------------}{	procedure GetInitialFolderInfo;		var			j: integer;			os: OSErr;			db: boolean;			mcVol: integer;	begin		FDI := fileDirInfoPtr(NewPtr(SizeOf(fileDirInfoArray)));		for j := 0 to maxFDI do			begin				if not OSSuccessful(FSMakeFSSpec(0,0,'',FDI^[j].fs)) then					InstantInfo('can''t make FSSpecs');				FDI^[j].rfFileNum := -1;				FDI^[j].dfFileNum := -1;			end;		if OSSuccessful(GetVRefNum(CurResFile, mcVol)) then			if not OSSuccessful(FSMakeFSSpec(mcVol,0,'MacClade',FDI^[maccladeFDI].fs)) then				InstantInfo('can''t make FSSpecs');		systemVolumeRefNumber := FDI^[maccladeFDI].fs.vRefNum;		if not OSSuccessful(FSMakeFSSpec(systemVolumeRefNumber,0,'MacClade',FDI^[systemFDI].fs)) then			InstantInfo('can''t make FSSpecs');		prefname := CopyString(GetString(1261)^^, 1, 31);		if ResError <> NoErr then			prefname := 'MacClade Preferences';	end;}{-----------------------------------------------------------------------------}	procedure InitMacClade;		var			theDialog: DialogPtr;			tempP: windowptr;			j, k: INTEGER;			db: boolean;	begin		{$IFC NOT CARBON}	{||||||||||||||||||||||||||||||||||||||||||   ToolBox initializations  ||||||||||||||||||||||||||||||||||||||||||}		InitGraf(@qd.thePort);		InitWindows;		InitMenus;		for j := 1 to 80 do			MoreMasters;		InitFonts;		TEInit;		InitDialogs(nil);{$ENDC}		InitCursor;				earlyquit := false;		UniversalDLOGFilterUPP := nil;  		ReadingSettings:= false;		quit := false;		currentIOPosition := 0;   {v3.05}		printRecordH := nil;		theDialog := nil;		tempP := nil;{$IFC CARBON}		printPageFormat:= kPMNoPageFormat;		printSession:= nil;		printSettings:= kPMNoPrintSettings;{$ENDC}		errorFlag := false;		{$IFC PRINTSTAMP}		printStampLine := true;{$ENDC}		dontCancelUpdate := false;{||||||||||||||||||||||||||||||||||||||||||   Volumes, FileNames, System Info   ||||||||||||||||||||||||||||||||||||||||||}		currentIOPosition := 82;   {v3.05}		InitErrors;  {v3.05}		currentIOPosition := 821;   {v3.05}{		GetInitialFolderInfo;   FDI storage created in here}				if not SystemCheck then			begin				KillErrors;  {v3.05}				ZapPointer(FDI);				earlyQuit := true;				Exit(InitMacClade);			end;{$IFC DEBUG}		debugon := false;{$ENDC}{$IFC DEMO OR BETA}		iofilename := StringHandle(NewHandle(SizeOf(Str255)));		iofilename^^ := '';		userName := StringHandle(NewHandle(sizeOf(str255)));		userInstitution := StringHandle(NewHandle(sizeOf(str255)));{$IFC DEMO}		userName^^ := 'Demonstration Version';		userInstitution^^ := '';{$ENDC}{$IFC BETA}		//userName^^ := concat("University High School, Tucson");		userName^^ := concat(testVersion, ' - ', testDate);		userInstitution^^ := 'DO NOT DISTRIBUTE';		//userInstitution^^ := 'Molecular Evolution Course at CCMAR - DO NOT DISTRIBUTE';{$ENDC}{$ELSEC}		userName := StringHandle(NewHandle(sizeOf(str255)));		userInstitution := StringHandle(NewHandle(sizeOf(str255)));		userName^^ := 'Free Download Version';		userInstitution^^ := '';{		if not CheckIfPersonalized then			begin				earlyquit := true;				ZapHandle(iofilename);				ZapHandle(userName);				ZapHandle(userInstitution);				ZapPointer(FDI);				Exit(InitMacClade);			end;			}{$IFC ARIZONAVERSION}		userInstitution^^ := 'For use at the University of Arizona ONLY';{$ENDC}{$ENDC}{||||||||||||||||||||||||||||||||||||||||||   Opening DLOG  ||||||||||||||||||||||||||||||||||||||||||}		SplashOpeningScreen(theDialog, tempP);		if earlyQuit then			begin				ZapHandle(iofilename);				ZapHandle(userName);				ZapHandle(userInstitution);				Exit(InitMacClade);			end;		ReportStartUpStatus(theDialog, 'Initializing...');{|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}		SetUpStuff(theDialog);{|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}		if earlyquit then			begin				EndOpeningScreen(theDialog, tempP);				Exit(InitMacClade);			end;			{||||||||||||||||||||||||||||||||||||||||||   Printer SetUp    ||||||||||||||||||||||||||||||||||||||||||}		printRecordSize := SizeOf(TPrint);{$IFC NOT CARBON}		printRecordH := THPrint(NewHandle(SizeOf(TPrint)));		printerOK := printRecordH <> nil;{$ELSEC}		printerOK := true;{$ENDC}		printDefaultsSet := false;				{if (printRecordH <> nil) then			begin				PrintDefault(printRecordH);				printerOK := CheckPrinterError;			end;}		SetDefaultPrintRecord(false);  		ReportStartUpStatus(theDialog, 'Reading Preferences...');		if ReadNexusPreferencesFile then			PostSettings;		errorFlag := false;		ReportStartUpStatus(theDialog, '');		EndOpeningScreen(theDialog, tempP);//		SayStringChannel('Well, let us hope this doesnt crash');{||||||||||||||||||||||||||||||||||||||||||   expiry  ||||||||||||||||||||||||||||||||||||||||||}{$IFC BETA OR EXPIRABLE}		if Expired then			quit := true{$IFC BETA}		else if not isforeground | not CWarning(concat('This is a TEST version of MacClade.', chr(13), 'In pressing AGREE, you agree NOT TO DISTRIBUTE COPIES and NOT TO PUBLISH RESULTS BASED ON THIS VERSION WITHOUT PERMISSION.'), 'Agree', 'Quit') then				quit := true;{$ENDC}{$ENDC}	end;end.