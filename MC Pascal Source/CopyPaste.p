unit CopyPaste;{ееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, 		ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, CharUtil, MenuUtil, 		TreeUtil, LinkUtil, SpreadUtil, DrawSpread, ScrollSpread, RowColumn, EditorUndo;	procedure PasteAndRemoveReturns(theTE: TEHandle);	procedure myPasteText(TE: TEHandle);	procedure StoreCellBlockAsText;	procedure StoreEWScrap;	procedure PasteEWScrap;	procedure DoEWPaste;{ееееееееееееееееееееее}implementation {е$S CopyPaste}{-----------------------------------------------------------------------------}	procedure StoreEWScrap;{stores MacClade specific editorWindow scrap (used for blocks of cells)}var db: boolean;	begin		db := StoreDataIntoCellBlock(EWScrapBlockP,editorSelectionBotRight,editorSelectionTopLeft, false, false, true, false, false,false);		InvalidateTool(editorTools,stampPasteT);	end;{-----------------------------------------------------------------------------}	procedure StoreCellBlockAsText;	var st,et,sc,ec: integer;		H: Handle;		tsts: largestsetchars;		ds: str255;		it,ic: integer;		box: rect;		tempTE: TEHandle;	begin		H := NewHandle(0);		CalcSelectedTaxaCharacters(st, et, sc, ec,true);		if (ec=0) then			begin				for it := st to et do					if (it>0) then						begin							AppendToHandle(H,TaxonName(it));							if (it<et) then								AppendToHandle(H, chr(13));						end;			end		else if (et=0) then			begin				for ic := sc to ec do					if (ic>0) then						begin							AppendToHandle(H,CharName(ic));							if (ic<ec) then								AppendToHandle(H, chr(13));						end;			end		else			for it := st to et do				if (it>0) then					begin						for ic := sc to ec do							if (ic > 0) then								begin									tsts := GetTaxonStsLargest(it, ic);									ds := StsToString(tsts, ic, editorShowFullStateNames & not nucleotides,editorShowIUPACSymbols);									AppendToHandle(H,ds);								end;						if (it<et) then							AppendToHandle(H, chr(13));					end;		SetRect(box, 0, 0, 10, 10);		tempTE := TENew(box, box);		TESetText(H^, GetHandleSize(H), tempTE);		TESetSelect(0, 32700, tempTE);		TECopy(tempTE);		TEDispose(tempTE);		ZapHandle(H);	end;{-----------------------------------------------------------------------------}	procedure PasteEWScrap;{pastes MacClade Specific EWScrapBlockP^}		var			charHdl: chHdl;			st, et, sc, ec, it, ic, extchar, exttax: integer;			B: Rect;			scrapPtr: Ptr;			newset, tsts: LargestSetChars;			notempty, db: boolean;			oldstate: SignedByte;	begin		badmemory := false;		SetCursor(clockCursor);		CalcSelectedTaxaCharacters(st, et, sc, ec, true);		if not StoreSelectedCellBlockForUndo(false,false,true) then Exit(PasteEWScrap);		{===== Inserting or deleting characters or taxa as necessary =======}		extchar := EWScrapBlockP^.nchar - (ec - sc + 1);		exttax := EWScrapBlockP^.ntax - (et - st + 1);		if (EWScrapBlockP^.starttaxa = -1) & WholeCharSel & (EWScrapBlockP^.ntax = numtaxa) then{v3.01: added numtaxa restrictions}			begin				if extchar > 0 then					begin						InsertNewCharacters(extchar, ec + 1, false);  						lastChangeInEditor := lastChangeInsertCharAndCellBlock;					end				else if extchar < 0 then					DestroyCharacters(ec + extchar + 1, ec, true, true,true,true);				ec := ec + extchar;				if not editorTransposed then					editorSelectionBotRight.h := ec				else					editorSelectionBotRight.v := ec;				CalcEditorSelectionRect(editorSelectionTopLeft, editorSelectionBotRight);			end;		if (EWScrapBlockP^.startchars = -1) & WholeTaxonSel & (EWScrapBlockP^.nchar = numchars) then{v3.01: added numchars restrictions}			begin				if exttax > 0 then					begin						InsertNewTaxa(exttax, et + 1,molecular); 						lastChangeInEditor := lastChangeInsertTaxaAndCellBlock;					end				else if exttax < 0 then					DestroyTaxa(et + exttax + 1, et,true,true);				et := et + exttax;				if not editorTransposed then					editorSelectionBotRight.v := et				else					editorSelectionBotRight.h := et;				CalcEditorSelectionRect(editorSelectionTopLeft, editorSelectionBotRight);			end;{=====================}		if badmemory then			Beep		else if PasteCellBlock(EWScrapBlockP,[],st,et,sc,ec) then			begin{======================}				if (extchar = 0) and (Exttax = 0) then					begin						EraseREct(editorSelectionRect);						InvalidateWindowRect(editorWindow,editorSelectionRect,false);					end				else					begin						B := editorBoundaryRect;						if (not editorTransposed and (extchar <> 0)) or (editorTransposed and (exttax <> 0)) then							begin								B.left := editorSelectionRect.left;								if B.left < editorFirstColumnLeft then									B.left := editorFirstColumnLeft;							end;						if (editorTransposed and (extchar <> 0)) or (not editorTransposed and (exttax <> 0)) then							begin								B.top := editorSelectionRect.top;								if B.top < editorFirstRowTop then									B.top := editorFirstRowTop;							end;						ClipRect(B);						EraseRect(B);						InvalidateWindowRect(editorWindow,B,false);					end;			end;	end;{-----------------------------------------------------------------------------}	procedure CleanPaste;	begin		myDisableItem(EditMHdl, CutItem);		myDisableItem(EditMHdl, CopyItem);		myDisableItem(EditMHdl, ClearItem);		Datachanged := true;		dirtymaxst := true;	end;{-----------------------------------------------------------------------------}	procedure PasteAndRemoveReturns(theTE: TEHandle);	var		j: integer;		chdl: CharsHandle;		c: char;		foundReturn: boolean;	begin		myPasteText(theTE);		chdl := TEGetText(theTE);		foundReturn := false;		for j := 0 to theTE^^.telength - 1 do			begin				c := chdl^^[j];				if (c = chr(13)) |  (c = chr(10)) then					begin						chdl^^[j] := ' ';						foundReturn := true;					end;			end;		if foundReturn then			begin				TECalText(theTE);				TEUpdate(theTE^^.viewRect,theTE);			end;	end;{-----------------------------------------------------------------------------}	procedure myPasteText(TE: TEHandle);	const kMaxTELength = 32767;	var os: OSErr;		scrapReference: ScrapRef ;		sizeOfTextData: Size;		totalSize, contigSize, newSize: SInt32;	begin {$IFC CARBON}		os := GetCurrentScrap(scrapReference);     	 	os := GetScrapFlavorSize(scrapReference,kScrapFlavorTypeText,sizeOfTextData);      		newSize := TE^^.teLength + sizeOfTextData;		If newSize <= kMaxTELength then			begin				os := TEFromScrap;				if (os=noErr) then{$ENDC}					TEPaste(TE); {$IFC CARBON}			end;{$ENDC}	end;{-----------------------------------------------------------------------------}	procedure DoEWPaste;	var ds: str255;	begin		if SingleCell and footediting then			begin				if ((EWScrapBlockP^.ntax <= 1) and (EWScrapBlockP^.nchar <= 1)) then					begin						myPasteText(noteTE);						CheckNoteLength;						CleanPaste;					end				else if (EWScrapBlockP^.ntax = 1) then					begin						ds := CellBlockString(EWScrapBlockP,true);						InsertSelection(noteTE,ds,'','');						CheckNoteLength;						CleanPaste;					end;								end		else if SingleCell  and ((EWScrapBlockP^.ntax <= 1) and (EWScrapBlockP^.nchar <= 1)) then			begin				PasteAndRemoveReturns(editorCellTE);				SelCellChanged := true;				StoreSelectedSingleCellForUndo;				myEnableItem(EditMHdl, UndoItem);				CleanPaste;			end		else if not SingleCell then			PasteEWScrap;	end;end.