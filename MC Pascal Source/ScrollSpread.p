unit ScrollSpread;{ееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, CharUtil, TreeUtil, SpreadUtil, DrawSpread, RowColumn;	procedure ScrollEditor (returnval: boolean; cellBlock: CellBlockPtr; validateWindow: boolean);	procedure ScrollSpreadUpDown (whichControl: ControlRef; theCode: INTEGER);	procedure ScrolltoRectangle (top,bottom,left,right: integer; returnval,validateWindow: boolean);	procedure ScrolltoSelection (returnval, validateWindow: boolean);	procedure ScrollToTaxon (it: integer; fullredraw: boolean);	procedure ScrollToChar (ic: integer; fullredraw: boolean);	procedure ScrollEditHome;	procedure ScrollEditorToMouse (wh: point; cellBlock: CellBlockPtr; scrollHorAllowed, scrollVertAllowed: boolean; var didScroll: boolean; var icChanged : integer; var pointMoved: point);	procedure FlashVerLine (hor: integer; corner: boolean);	procedure FlashHorLine (ver: integer; corner: boolean);	procedure AutoHorScroll (unrestricted, cangodown, corner: boolean);	procedure AutoVertScroll (unrestricted, cangodown, corner: boolean);	procedure PullUpDown (Event: EventRecord);	procedure PullLeftRight (Event: EventRecord);	procedure PullInsertCols (drop: integer);	procedure PullInsertRows (drop: integer);	procedure SelectCell (tax, char: integer);{ееееееееееееееееееееее}implementation {е$S ScrollSpread}{$SETC SNAPPICTURE=FALSE}{----------------------------------------------------------------------------}	procedure ScrollEditor (returnval: boolean; cellBlock: CellBlockPtr; validateWindow: boolean);		var			OldOrigin, NewOrigin: Point;			upRgn,hiddenRgn: RgnHandle;			oldDRect, SRect, RowColRect: RECT;			dv, dh: integer;			singleRowCol: boolean;  {if true, then only a single row or column is to be drawn}	begin				OldOrigin := editorOrigin;				NewOrigin.h := GetControlValueLong(editorHScroll) + 1;				NewOrigin.v := GetControlValueLong(editorVScroll) + 1;				dv := OldOrigin.v - NewOrigin.v;				dh := OldOrigin.h - NewOrigin.h;				singleRowCol := (dh = 1) | (dv = 1) | ((dh = -1) & WindowBotRightOnScreen(editorWindow, false, editorBoundaryRect.right)) | ((dv = -1) & WindowBotRightOnScreen(editorWindow, true, editorBoundaryRect.bottom));				if (cellBlock<>nil) & ((dv <> 0) | (dh <> 0)) then					 DrawDataCellsInRect(cellBlock^.visibleRect,selectionModeAsIs);					 {======= deselect old selection ========}				if editorSelected and ((dv <> 0) or (dh <> 0)) then					begin						if (dv <> 0) and (dh <> 0) then							SetEWClip(noscroll)						else if dv <> 0 then							if editorSelectionTopLeft.h > 0 then								SetEWClip(justdataAndConsenses)							else								SetEWClip(vertscroll)						else if dh <> 0 then							if editorSelectionTopLeft.v > 0 then								SetEWClip(justdataAndConsenses)							else								SetEWClip(horscroll);						SetClip(EWClip);						if SingleCell then							begin								if returnval then									begin										ReturnValue(editorSelectionTopLeft,false);										if badcellentry then											if BadCellEntryQuery then												DiscardCellChanges											else												Exit(ScrollEditor);									end;								if singleRowCol then									if (dh = 0) and (dv = -1) and (editorSelectionTopLeft.v = editorOrigin.v) and (editorSelectionTopLeft.h <= editorOrigin.h + editorColumns - 1) and ((editorSelectionTopLeft.h >= editorOrigin.h) or (editorSelectionTopLeft.h = 0)) then										InvertOldCell									else if (dh = 0) and (dv = 1) and (editorSelectionTopLeft.v = editorOrigin.v + editorRows - 1) and (editorSelectionTopLeft.h <= editorOrigin.h + editorColumns - 1) and ((editorSelectionTopLeft.h >= editorOrigin.h) or (editorSelectionTopLeft.h = 0)) then										InvertOldCell									else if (dv = 0) and (dh = -1) and (editorSelectionTopLeft.h = editorOrigin.h) and (editorSelectionTopLeft.v <= editorOrigin.v + editorRows - 1) and ((editorSelectionTopLeft.v >= editorOrigin.v) or (editorSelectionTopLeft.v = 0)) then										InvertOldCell									else if (dv = 0) and (dh = 1) and (editorSelectionTopLeft.h = editorOrigin.h + editorColumns - 1) and (editorSelectionTopLeft.v <= editorOrigin.v + editorRows - 1) and ((editorSelectionTopLeft.v >= editorOrigin.v) or (editorSelectionTopLeft.v = 0)) then										InvertOldCell;								if singleRowCol then									if (dh = 0) and (dv = 1) and (editorSelectionTopLeft.v = editorOrigin.v - 1) and (editorSelectionTopLeft.h <= editorOrigin.h + editorColumns - 1) and ((editorSelectionTopLeft.h >= editorOrigin.h) or (editorSelectionTopLeft.h = 0)) then										BorderCell(editorSelectionTopLeft.h, editorSelectionTopLeft.v)									else if (dh = 0) and (dv = -1) and (editorSelectionTopLeft.v = editorOrigin.v + editorRows) and (editorSelectionTopLeft.h <= editorOrigin.h + editorColumns - 1) and ((editorSelectionTopLeft.h >= editorOrigin.h) or (editorSelectionTopLeft.h = 0)) then										BorderCell(editorSelectionTopLeft.h, editorSelectionTopLeft.v)									else if (dv = 0) and (dh = 1) and (editorSelectionTopLeft.h = editorOrigin.h - 1) and (editorSelectionTopLeft.v <= editorOrigin.v + editorRows - 1) and ((editorSelectionTopLeft.v >= editorOrigin.v) or (editorSelectionTopLeft.v = 0)) then										BorderCell(editorSelectionTopLeft.h, editorSelectionTopLeft.v)									else if (dv = 0) and (dh = -1) and (editorSelectionTopLeft.h = editorOrigin.h + editorColumns) and (editorSelectionTopLeft.v <= editorOrigin.v + editorRows - 1) and ((editorSelectionTopLeft.v >= editorOrigin.v) or (editorSelectionTopLeft.v = 0)) then										BorderCell(editorSelectionTopLeft.h, editorSelectionTopLeft.v);							end;						if not singleRowCol then							InvertOldCell;					end;{=====================}				if (dv <> 0) and (dh <> 0) then					begin						Srect := editorBoundaryRect;						SetEWClip(noScroll);					end				else if dv <> 0 then					begin						SetRect(Srect, 0, editorFirstRowTop, editorBoundaryRect.right, editorBoundaryRect.bottom);						SetEWClip(vertscroll);					end				else if dh <> 0 then					begin						SetRect(Srect, editorFirstColumnLeft, 0, editorBoundaryRect.right, editorBoundaryRect.bottom);						SetEWClip(horscroll);					end;				SetClip(EWClip);				editorOrigin := NewOrigin;				upRgn := NewRgn;				oldDRect := editorMatrixRect;				CalcEditorMatrixRect;				if editorSelectionTopLeft.v = -1 then					editorSelectionRect.bottom := editorMatrixRect.bottom				else if editorSelectionTopLeft.h = -1 then					editorSelectionRect.right := editorMatrixRect.right;				if (dv <> 0) or (dh <> 0) then					begin						CalcEditorSelectionRect(editorSelectionTopLeft, editorSelectionBotRight);						if editorSelected and SingleCell and (((dh <> 0) and (editorSelectionTopLeft.h > 0)) or ((dv <> 0) and (editorSelectionTopLeft.v > 0))) then							MoveSTE;{==== single row or column scroll - just draw the relevant row or column ====}						if singleRowCol  then							begin								ClipRect(WindowPortRect(editorWindow));								ScrollRect(srect, dh * editorColumnWidth, dv * editorLineWidth, upRgn);								SectRgn(EWClip, upRgn, EWClip);  {intersection of two regions, gets put into EWClip}																SectRgn(upRgn,myGetVisRgn(EditorWindow),upRgn); {places intersection of													update region and visrgn into upRgn.  }																					SetClip(upRgn);								DrawDataCellsInRgn(upRgn,selectionModeAsIs);								DrawGrayEditorRgn(false);								if (FirstVisibleCharacter<=numChars) & (FirstVisibleTaxon<=numTaxa) then									FrameEditorMatrixRect;														CopyRgn(EWClip, upRgn);  {copy EWClip into upRgn}								CopyRgn(upRgn, EWClip);								SetClip(EWClip);								ReFixCell;							end						else {==== page scrolls ====}												if not EqualREct(OldDRect, editorMatrixRect) then							begin								EraseRect(srect);								DrawCells(true, false,true);							end						else							begin								{if SingleRowCol then									begin										ScrollRect(srect, dh * editorColumnWidth, dv * editorLineWidth, upRgn);										SetClip(upRgn);									end;}								DrawCells(false, false,true);							end;					end;		ZapRegion(upRgn);		if not poorentry then			begin				if validateWindow then					myValidRect(editorWindow,WindowPortRect(editorWindow));			end		else			poorentry := false;		CallWaitNextEventForDrawing;		SetEWClip(noscroll);		ClipRect(WindowPortRect(editorWindow));	end;{----------------------------------------------------------------------------}	procedure ScrollSpreadUpDown (whichControl: ControlRef; theCode: INTEGER);	begin		if scrollup then			begin				if theCode = kControlUpButtonPart then					begin						SetControlValueLong(whichControl, GetControlValueLong(whichControl) - 1);						ScrollEditor(true,nil,true)					end			end		else if theCode = kControlDownButtonPart then			begin				SetControlValueLong(whichControl, GetControlValueLong(whichControl) + 1);				ScrollEditor(true,nil,true)			end	end;{----------------------------------------------------------------------------}	procedure ScrolltoRectangle (top,bottom,left,right: integer; returnval, validateWindow: boolean);		var			doscroll: boolean;			widthOfSelection: integer;			amountToScroll: integer;			tPort: windowPtr;	begin		genericGetPort(tPort);		genericSetPort(editorWindow);		doscroll := false;		if (left > 0) and (left < editorOrigin.h) then	{it is off to the left}			begin				SetControlValueLong(editorHScroll, left - 1);				doscroll := true;			end		else if (left > editorOrigin.h + editorColumns - 1) then			begin				widthOfSelection := right-left+1;				if widthOfSelection<=editorColumns then					amountToScroll := widthOfSelection				else					amountToScroll := 1;				SetControlValueLong(editorHScroll, left - amountToScroll);				doscroll := true;			end;		if doscroll then			ScrollEditor(returnval,nil,validateWindow);		doscroll := false;		if (top > 0) and (top < editorOrigin.v) then			begin				SetControlValueLong(editorVScroll, top - 1);				doscroll := true;			end		else if (top > editorOrigin.v + editorRows - 1) then			begin				widthOfSelection := bottom-top+1;				if widthOfSelection<=editorRows then					amountToScroll := widthOfSelection				else					amountToScroll := 1;				SetControlValueLong(editorVScroll, top - amountToScroll);				doscroll := true;			end;		if doscroll then			ScrollEditor(returnval,nil,validateWindow);		genericSetPort(tPort);	end;{----------------------------------------------------------------------------}	procedure ScrolltoSelection (returnval,validateWindow: boolean);	begin		ScrollToRectangle (editorSelectionTopLeft.v,editorSelectionBotRight.v,editorSelectionTopLeft.h,editorSelectionBotRight.h,returnval,validateWindow);	end;{----------------------------------------------------------------------------}	procedure ScrollToTaxon (it: integer; fullredraw: boolean);	begin		if editorTransposed then			SetControlValueLong(editorHScroll, it - 1)		else			SetControlValueLong(editorVScroll, it - 1);		if fullredraw then			begin				editorOrigin.h := GetControlValueLong(editorHScroll) + 1;				editorOrigin.v := GetControlValueLong(editorVScroll) + 1;				InvalidateWindow(editorWindow, true);			end		else			ScrollEditor(true,nil,true);	end;{----------------------------------------------------------------------------}	procedure ScrollToChar (ic: integer; fullredraw: boolean);	begin		if not editorTransposed then			SetControlValueLong(editorHScroll, ic - 1)		else			SetControlValueLong(editorVScroll, ic - 1);		if fullredraw then			begin				editorOrigin.h := GetControlValueLong(editorHScroll) + 1;				editorOrigin.v := GetControlValueLong(editorVScroll) + 1;				InvalidateWindow(editorWindow, true);			end		else			ScrollEditor(true,nil,true);	end;{----------------------------------------------------------------------------}	procedure ScrollEditHome;	begin		SetControlValueLong(editorHScroll, 0);		SetControlValueLong(editorVScroll, 0);		ScrollEditor(true,nil,true);	end;{----------------------------------------------------------------------------}	procedure ScrollEditorToMouse (wh: point; cellBlock: CellBlockPtr; scrollHorAllowed, scrollVertAllowed: boolean; var didScroll: boolean; var icChanged : integer; var pointMoved: point);	var oldValue, oldicOrigin: integer;		tempP: WindowPtr;		oldClip: RgnHandle;	begin		oldClip := NewRgn;		GetClip(oldClip);		oldicOrigin := FirstVisibleCharacter;		didscroll := false;		pointMoved.h := 0;		pointMoved.v := 0;		if (wh.h < editorFirstColumnLeft) & scrollHorAllowed then			begin				oldValue:= GetControlValueLong(editorHScroll);				ClipRect(WindowPortRect(editorWindow));				SetControlValueLong(editorHScroll, GetControlValueLong(editorHScroll) - 1);				SetClip(oldClip);				ScrollEditor(true,cellBlock,true);				didscroll := GetControlValueLong(editorHScroll)<> oldValue;				pointMoved.h := GetControlValueLong(editorHScroll) - oldValue;			end		else if (wh.h > editorBoundaryRect.right) & (editorMatrixRect.right = editorBoundaryRect.right)  & scrollHorAllowed then			begin				oldValue:= GetControlValueLong(editorHScroll);				ClipRect(WindowPortRect(editorWindow));				SetControlValueLong(editorHScroll, GetControlValueLong(editorHScroll) + 1);				SetClip(oldClip);				ScrollEditor(true,cellBlock,true);				didscroll := GetControlValueLong(editorHScroll)<> oldValue;				pointMoved.h := GetControlValueLong(editorHScroll) - oldValue;			end		else if (wh.v < editorFirstRowTop) & scrollVertAllowed then			begin				oldValue:= GetControlValueLong(editorVScroll);				ClipRect(WindowPortRect(editorWindow));				SetControlValueLong(editorVScroll, GetControlValueLong(editorVScroll) - 1);				SetClip(oldClip);				ScrollEditor(true,cellBlock,true);				didscroll := GetControlValueLong(editorVScroll)<> oldValue;				pointMoved.v := GetControlValueLong(editorVScroll) - oldValue;			end		else if (wh.v > editorBoundaryRect.bottom) & (editorMatrixRect.bottom = editorBoundaryRect.bottom) & scrollVertAllowed  then			begin				oldValue:= GetControlValueLong(editorVScroll);				ClipRect(WindowPortRect(editorWindow));				SetControlValueLong(editorVScroll, GetControlValueLong(editorVScroll) + 1);				SetClip(oldClip);				ScrollEditor(true,cellBlock,true);				didscroll := GetControlValueLong(editorVScroll)<> oldValue;				pointMoved.v := GetControlValueLong(editorVScroll) - oldValue;			end;		icChanged := FirstVisibleCharacter - oldicOrigin;		ZapRegion(oldClip);	end;{|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}{----------------------------------------------------------------------------}	procedure FlashVerLine (hor: integer; corner: boolean);	begin		PenMode(patXor);		PenSize(3, 3);		PenPat(QDltGray);		moveto(hor, editorTitleLineWidth + 3);		lineto(hor, editorMatrixRect.bottom);		CallWaitNextEventForDrawing;		if corner then			begin				lineto(editorMatrixRect.right, editorMatrixRect.bottom);{$IFC SNAPPICTURE}				Delay(30, ticks);				if not OptionDown then{$ELSEC}				Delay(3,ticks);{$ENDC}					lineto(hor, editorMatrixRect.bottom);			end		else{$IFC SNAPPICTURE}				Delay(30, ticks);				if not OptionDown then{$ELSEC}				Delay(3,ticks);{$ENDC}			lineto(hor, editorTitleLineWidth + 3);		PenNormal;	end;{----------------------------------------------------------------------------}	procedure AutoHorScroll (unrestricted, cangodown, corner: boolean);		var			mp: point;			st: longint;	begin		GetMouse(mp);		if (mp.h < editorFirstColumnLeft) and cangodown then			begin				SetControlValueLong(editorHScroll, GetControlValueLong(editorHScroll) - 1);				ScrollEditor(true,nil,true);			end		else if mp.h > editorBoundaryRect.right then			begin				SetControlValueLong(editorHScroll, GetControlValueLong(editorHScroll) + 1);				if unrestricted then					begin						st := GetControlMaximumLong(editorHScroll);						if (not editorTransposed and (st < mnchars - 1)) or (editorTransposed and (st < mntaxa - 1)) then							SetControlMaximumLong(editorHScroll, GetControlMaximumLong(editorHScroll) + 1);					end;				ScrollEditor(true,nil,true);			end		else			FlashVerLine(mp.h, corner);	end;{----------------------------------------------------------------------------}	procedure FlashHorLine (ver: integer; corner: boolean);	begin				PenMode(patXor);		PenSize(3, 3);		PenPat(QDltGray);		moveto(editorRowNameStart, ver);		lineto(editorMatrixRect.right, ver);		CallWaitNextEventForDrawing;		if corner then			begin				lineto(editorMatrixRect.right, editorMatrixRect.bottom);{$IFC SNAPPICTURE}				Delay(30, ticks);				if not OptionDown then{$ELSEC}				Delay(3,ticks);{$ENDC}				lineto(editorMatrixRect.right, ver);			end		else{$IFC SNAPPICTURE}				Delay(30, ticks);				if not OptionDown then{$ELSEC}				Delay(3,ticks);{$ENDC}		lineto(editorRowNameStart, ver);		PenNormal;	end;{----------------------------------------------------------------------------}	procedure AutoVertScroll (unrestricted, cangodown, corner: boolean);		var			mp: point;			st: longint;	begin		GetMouse(mp);		if (mp.v < editorFirstRowTop) and cangodown then			begin				SetControlValueLong(editorVScroll, GetControlValueLong(editorVScroll) - 1);				ScrollEditor(true,nil,true);			end		else if mp.v > editorBoundaryRect.bottom then			begin				SetControlValueLong(editorVScroll, GetControlValueLong(editorVScroll) + 1);				if unrestricted then					begin						st := GetControlMaximumLong(editorVScroll);						if (not editorTransposed and (st < mntaxa - 1)) or (editorTransposed and (st < mnchars - 1)) then							SetControlMaximumLong(editorVScroll, GetControlMaximumLong(editorVScroll) + 1);					end;				ScrollEditor(true,nil,true);			end		else			FlashHorLine(mp.v, corner);	end;{----------------------------------------------------------------------------}	procedure EndPull (B: rect);	begin		if editorSelectionTopLeft.v = -1 then			editorSelectionBotRight.v := editorTotalRows;		if editorSelectionTopLeft.h = -1 then			editorSelectionBotRight.h := editorTotalColumns;		CalcEditorMatrixRect;		EraseRect(B);		InvalidateWindowRect(editorWindow,B,false);		CalcEditorSelectionRect(editorSelectionTopLeft, editorSelectionBotRight);	end;{----------------------------------------------------------------------------}	procedure PullUpDown (Event: EventRecord);{pulling the edge of the matrix up or down}		var			mp: point;			k, currow, st, mnrows, top, bottom: integer;			B: rect;			pluralds: str255;	begin		if editorSelected then			begin				UnselectAll;				if badcellEntry then					Exit(PullUpDown);			end;		if not editorTransposed then			mnrows := mntaxa		else			mnrows := mnchars;		repeat			AutoVertScroll(true, true, (editorMatrixRect.right <> editorBoundaryRect.right));		until not button;		GetMouse(mp);		currow := editorOrigin.v + (mp.v - editorFirstRowTop) div editorLineWidth;		if currow > mnrows then			begin				currow := mnrows;				NewError(398, 0);			end		else if mp.v - editorFirstRowTop < 0 then			currow := -1		else if currow <> editorTotalRows then			currow := currow - 1;		if currow <> editorTotalRows then			if (currow > editorTotalRows) then   {it's been pulled down}				begin					CellVer(editorTotalRows, top, bottom, true);					B := editorBoundaryRect;					B.top := bottom;					SetCursor(clockCursor);					if not editorTransposed then						begin							AddNewTaxa(currow - numtaxa, molecular);							SetLastChangeInEditor(lastChangeAddTaxa);						end					else						begin							AddNewCharacters(currow - numchars, molecular);							SetLastChangeInEditor(lastChangeAddCharacters);						end;					EndPull(B);				end			else 				{it's been pulled up}				begin					if not editorTransposed then						pluralds := ' taxa'					else						pluralds := ' characters';					if currow < 0 then						InstantErrorPlus(175, pluralds)					else						begin							if editorTotalRows - currow - 1 > 1 then								ParamText(concat(StringFromNum(editorTotalRows - currow - 1), pluralds), '', '', '')							else if not editorTransposed then								ParamText('1 taxon', '', '', '')							else								ParamText('1 character', '', '', '');							if (DoAlert(426, CautionA) = 1) then								begin									CellVer(currow + 1, top, bottom, true);									B := editorBoundaryRect;									B.top := bottom;									SetCursor(clockCursor);									if not editorTransposed then										DestroyTaxa(currow + 2, numtaxa,true,true)									else										DestroyCharacters(currow + 2, numchars, true, true,true,true);									ZeroSelection;									EndPull(B);								end						end				end;		ClipRect(WindowPortRect(editorWindow));		SetScrollMax;		SetClip(EWClip);	end;{----------------------------------------------------------------------------}	procedure PullLeftRight (Event: EventRecord);{pulling the edge of the matrix right or left }		var			mp: point;			k, curcol, lastcol, st, mncols, left, right: integer;			B: rect;			pluralds: str255;	begin		if editorSelected then			begin				UnselectAll;				if badcellEntry then					Exit(PullLeftRight);			end;		if not editorTransposed then			mncols := mnchars		else			mncols := mntaxa;		repeat			AutoHorScroll(true, true, (editorMatrixRect.bottom <> editorBoundaryRect.bottom));		until not button;		GetMouse(mp);		curcol := editorOrigin.h + (mp.h - editorFirstColumnLeft) div editorColumnWidth;		if curcol > mncols then			begin				curcol := mncols;				NewError(398, 0);			end		else if (mp.h - editorFirstColumnLeft) < 0 then			curcol := -1		else if curcol <> editorTotalColumns then			curcol := curcol - 1;		if curcol <> editorTotalColumns then			if curcol > editorTotalColumns then 		{pulled to the right; adding}				begin					begin						CellHor(editorTotalColumns, left, right, true);						B := editorBoundaryRect;						B.left := right - 2;						SetCursor(clockCursor);						if editorTransposed then							begin								AddNewTaxa(curcol - numtaxa, molecular);								SetLastChangeInEditor(lastChangeAddTaxa);							end						else							begin								AddNewCharacters(curcol - numchars, molecular);								SetLastChangeInEditor(lastChangeAddCharacters);							end;						EndPull(B);					end				end			else						{pulled to the left; deleting}				begin					if editorTransposed then						pluralds := ' taxa'					else						pluralds := ' characters';					if curcol < 0 then						InstantErrorPlus(175, pluralds)					else						begin							if editorTotalColumns - curcol - 1 > 1 then								ParamText(concat(StringFromNum(editorTotalColumns - curcol - 1), pluralds), '', '', '')							else if editorTransposed then								ParamText('1 taxon', '', '', '')							else								ParamText('1 character', '', '', '');							if (DoAlert(426, CautionA) = 1) then								begin									CellHor(curcol + 1, left, right, true);									B := editorBoundaryRect;									B.left := right - 2;									SetCursor(clockCursor);									if editorTransposed then										DestroyTaxa(curcol + 2, numtaxa,true,true)									else										DestroyCharacters(curcol + 2, numchars, true, true,true,true);									EndPull(B);									ZeroSelection;								end						end				end;		SetScrollMax;	end;{----------------------------------------------------------------------------}	procedure PullInsertCols (drop: integer);{inserting columns in the middle}		var			wh: point;			nc: integer;			oldorigin: integer;	begin		GlobalToLocal(Event.where);		oldorigin := editorOrigin.h;		repeat			AutoHorScroll(true, false, false);		until not button;		GetMouse(wh);		nc := (wh.h - event.where.h + editorColumnWidth div 2) div editorColumnWidth + (editorOrigin.h - oldorigin);		if nc > 0 then			begin				if editorTransposed then					begin						if nc + numtaxa > mntaxa then {v3.01}							begin								nc := mntaxa - numtaxa;								NewError(398, 0);							end;						InsertNewTaxa(nc, drop, molecular);						SetLastChangeInEditor(lastChangeAddTaxa);					end				else					begin						if nc + numchars > mnchars then {v3.01}							begin								nc := mnchars - numchars;								NewError(398, 0);							end;						InsertNewCharacters(nc, drop, molecular);						SetLastChangeInEditor(lastChangeAddCharacters);					end;				EraseRect(WindowPortRect(editorWindow));				InvalidateWindowRect(editorWindow,WindowPortRect(editorWindow),false);				if editorSelected then					begin						if (editorSelectionTopLeft.h >= drop) then							editorSelectionTopLeft.h := editorSelectionTopLeft.h + nc;						if editorSelectionBotRight.h >= drop then							editorSelectionBotRight.h := editorSelectionBotRight.h + nc;						CalcEditorSelectionRect(editorSelectionTopLeft, editorSelectionBotRight);						if SingleCell then							movesTE;					end;				SetScrollMax;			end;	end;{----------------------------------------------------------------------------}	procedure PullInsertRows (drop: integer);{inserting rows in the middle}		var			wh: point;			nc, oldorigin: integer;	begin		oldorigin := editorOrigin.v;		GlobalToLocal(Event.where);		repeat			AutoVertScroll(true, false, false);		until not button;		GetMouse(wh);		nc := (wh.v - event.where.v + editorLineWidth div 2) div editorLineWidth + (editorOrigin.v - oldorigin);		if nc > 0 then			begin				if not editorTransposed then					begin						if nc + numtaxa > mntaxa then {v3.01}							begin								nc := mntaxa - numtaxa;								NewError(398, 0);							end;						InsertNewTaxa(nc, drop,molecular);						SetLastChangeInEditor(lastChangeAddTaxa);					end				else					begin						if nc + numchars > mnchars then  {v3.01}							begin								nc := mnchars - numchars;								NewError(398, 0);							end;						InsertNewCharacters(nc, drop, molecular);						SetLastChangeInEditor(lastChangeAddCharacters);					end;				EraseRect(WindowPortRect(editorWindow));				InvalidateWindowRect(editorWindow,WindowPortRect(editorWindow),false);				if editorSelected then					begin						if (editorSelectionTopLeft.v >= drop) then							editorSelectionTopLeft.v := editorSelectionTopLeft.v + nc;						if editorSelectionBotRight.v >= drop then							editorSelectionBotRight.v := editorSelectionBotRight.v + nc;						CalcEditorSelectionRect(editorSelectionTopLeft, editorSelectionBotRight);						if SingleCell then							movesTE;					end;				SetScrollMax;			end;	end;{----------------------------------------------------------------------------}{$IFC SPEECH}{this is only used in speech}	procedure SelectCell (tax, char: integer);		var			oldSelCellTL, oldSElCellBR: point;	begin		oldSelCellTL := editorSelectionTopLeft;		oldSelCellBR := editorSelectionBotRight;		if not editorTransposed then			begin				editorSelectionTopLeft.v := tax;				editorSelectionTopLeft.h := char;			end		else			begin				editorSelectionTopLeft.v := char;				editorSelectionTopLeft.h := tax;			end;		editorSelectionBotRight := editorSelectionTopLeft;		if not EqualPt(OldSelCellTL, editorSelectionTopLeft) or not EqualPt(OldSelCellBR, editorSelectionBotRight) then			begin				CleanOldCell(OldselCellTL, OldselCellBR);				if badcellentry then					Exit(SelectCell);			end;		FillsTE(editorCellTE, CellString);		if not CellVisible(editorSelectionTopLeft, editorSelectionBotRight) then			ScrollToSelection(true,true)		else if not EqualPt(OldSelCellTL, editorSelectionTopLeft) or not EqualPt(OldSelCellBR, editorSelectionBotRight) then			FixNewCell(editorSelectionTopLeft, editorSelectionBotRight);		editorSelected := true;		SetUpCellEdit;		ClipRect(WindowPortRect(editorWindow));	end;{$ENDC}end.