unit RandomTree;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, WriteUtil, TaxonCHUtil, charutil, TreeUtil, Thermos, TreeMakerUtil, LinkUtil;	procedure MakeRandomTree (rndtype: integer);	procedure PrepareToRandomPoly (N: Nptr);	procedure RandomizeAllPolytomies (N: Nptr);	procedure RandomizePolytomy (N: Nptr);	procedure InitializeRndTreesReport;	procedure UpdateRndTreesReport;	procedure SaveRndTreesReportToFile (numtrees, rtkind: longint);{еееееееееееееееееееееее}implementation {е$S RandomTree}	var		numtx: integer;		nextnode: longint;{===================RANDOM TREE CALCULATIONS =========================}{These procedures to generate random trees make either equiprobable trees,}{random joining trees, or random partition trees (see Maddison & Slatkin, 1991)}	function includetaxon (itt: integer): boolean;{returns whether or not to include taxon itt into random tree}	begin		includetaxon := RTallTaxa | TaxoninTree(itt);	end;{-------------------------------------------------------------}{generates random number between 1 and maxnum (but number 'excluded' not chosen)}{passed excluded=-1 if all included}	function ChooseRandomNode (maxnum: integer; excluded: integer): integer;		var			temp: integer;	begin		if maxnum = 1 then			ChooseRandomNode := 1		else			begin				repeat					temp := randombetween(1, maxnum);				until temp <> excluded;				ChooseRandomNode := temp;			end;	end;{-------------------------------------------------------------}	procedure MakeTwoTaxonTree (var tn: integer);		var			TaxonHdl: thdl;	begin		R := Newnode(4);  {making root and making it same as first taxon in tree}		if not FillNode(R) then			treemakingfailed := true;		R^.anc := SubR;		SubR^.rt := R;		R^.slant := 1;		R^.name := 0;		R^.lf := NewNode(5);		if not FillNode(R^.lf) then			treemakingfailed := true;		R^.lf^.anc := R;		R^.lf^.slant := -1;		tn := 0;		repeat			tn := tn + 1;		until (tn > numtaxa) | includetaxon(tn);  {find first taxon number to be included}		R^.lf^.name := tn;		TaxonHdl := GetTaxonHdl(tn);		taxonHdl^^.N := R^.lf;		R^.rt := NewNode(6);		if not FillNode(R^.rt) then			treemakingfailed := true;		R^.rt^.anc := R;		R^.rt^.slant := 1;		repeat			tn := tn + 1;		until (tn > numtaxa) | includetaxon(tn);  {find first taxon number to be included}		R^.rt^.name := tn;		TaxonHdl := GetTaxonHdl(tn);		taxonHdl^^.N := R^.rt;	end;{=====================================================}	function FindNodenumbered (itn: integer; terminalonly: boolean): Nptr;{Finds itn'th node on traversal through growing tree}		var			numct: integer;			found: boolean;			foundNode: Nptr;		procedure GoUpToNumber (N: Nptr);		begin			if not terminalonly | (NodeIsTerminal(N)) then				numct := numct + 1;			if numct <> itn then				begin					if NodeIsInternal(N) then						begin							GoUpToNumber(N^.lf);							if not found then								GoUpToNumber(N^.rt);						end;				end			else				begin					found := true;					foundnode := N;				end;		end;	begin		found := false;		numct := 0;		GoUpToNumber(R);		findNodeNumbered := foundnode;	end;{=====================================================}	procedure EquiprobableTree;{FROZEN 3.0}{Generates a random tree so that each distinct tree is equiprobable}{Does this by adding taxa one at a time to a growing tree, each time}{to a randomly chosen branch (internal or external)}		var			it, tn: integer;			foundnode: nptr;			TaxonHdl: thdl;	begin		MakeTwoTaxonTree(tn);{we now have two-taxon tree consisting of first two taxa.  Now add all remaining taxa}		for it := 3 to numtx do			begin				repeat					tn := tn + 1;				until (tn > numtaxa) | includetaxon(tn);  {get next taxon to be included}				if tn <= numtaxa then					begin						foundnode := FindNodeNumbered(ChooseRandomNode(((it - 1) * 2 - 1), -1), false); {-1 used to be excluded}						AddTaxon(tn, foundnode);					end;			end;	end;{=====================================================}{$IFC FALSE}	procedure NewJoiningTree;  {THIS IS NOT USED IN MacClade 3}{Generates random tree by splitting - adding taxa to terminal branches}		var			tn: integer;			it: integer;			TaxonHdl: thdl;			foundnode, foundsecondnode: Nptr;			firsttxnum, secondtxnum: integer;	 {........} {..................}	begin		MakeTwoTaxonTree(tn);{we now have two-taxon tree consisting of  two taxa.  Now add all remaining taxa}		for it := 3 to numtx do			begin				repeat					tn := tn + 1;				until (tn > numtaxa) | includetaxon(tn);  {get next taxon to be included}				if tn <= numtaxa then					begin						foundnode := FindNodenumbered(ChooseRandomNode(it - 1, -1), true);						AddTaxon(tn, foundnode);					end;			end;{We now have to randomize taxon assignments}		for it := 1 to numtx - 1 do			begin				foundnode := FindNodeNumbered(it, true);				foundsecondnode := FindNodeNumbered(it - 1 + ChooseRandomNode(numtx - it + 1, -1), true);				if foundnode <> foundsecondnode then					begin						firsttxnum := foundnode^.name;						secondtxnum := foundsecondnode^.name;						foundsecondnode^.name := firsttxnum;						TaxonHdl := GetTaxonHdl(firsttxnum);						taxonHdl^^.N := foundsecondnode;						foundnode^.name := secondtxnum;						TaxonHdl := GetTaxonHdl(secondtxnum);						taxonHdl^^.N := foundnode;					end;			end;	end;{$ENDC}{=====================================================}{$IFC TRUE}	procedure JoiningTree;{FROZEN 3.0}{Generates random tree by starting with list of terminal taxa and fusing them pairwise,}{each time choosing pair randomly}		type			nptrptr = ^Nptr;		var			TaxonHdl: thdl;			nodeline: ptr;			tempstates: setchars15;			ic, ft, st, tt, it, counter, tn: integer;			NodeInLine: nptrptr;			sdn, newN: nptr;	 {........}		function GetNodeInLine (ii: integer): Nptr;     {gets ii'th node pointer in a block of node pointers}			var				tNodeInLine: nptrptr;		begin			tNodeInLine := nptrptr(ord4(nodeline) + 4 * (ii - 1));			GetNodeInLine := tNodeInLine^;		end;	 {........}		procedure SetNodeInLine (ii: integer; nn: nptr);     {places node pointer nn into ii'th spot in a block of node pointers}			var				tNodeInLine: nptrptr;		begin			tNodeInLine := nptrptr(ord4(nodeline) + 4 * (ii - 1));			tNodeInLine^ := nn;		end;	 {........}	begin		nodeline := newPtr(numtx * 4);   {allocate block for storing node pointers}		NodeInLine := nptrptr(nodeline);  {point to first spot in block of node pointers}		nextnode := 4; {first node is to be number 4 in TreeBlock because 1, 2, 3 for subR, R, etc}		tn := 0;		for it := 1 to numtx do  {make all terminal nodes}			begin				sdN := newnode(nextnode);				sdN^.rt := nil;				sdN^.lf := nil;				nextnode := nextnode + 1;				repeat					tn := tn + 1;				until (tn > numtaxa) | includetaxon(tn);  {find next taxon to be included}				sdN^.name := tn;				if not FillNode(sdN) then					treemakingfailed := true;				TaxonHdl := GetTaxonHdl(tn);				taxonHdl^^.N := sdN;  {connecting taxon to terminal node}				taxonHdl^^.deleted := false;				NodeInLine^ := sdN;  {store node at current spot in Nptr block}				NodeInLine := nptrptr(ord4(NodeInLine) + 4);  {move to next spot in Nptr block}			end;{now start fusing nodes to build tree by joining}		for counter := 1 to numtx - 2 do			begin				ft := ChooseRandomNode(numtx - counter + 1, -1);  {choose first node from among numtax-counter+1 remaining}				st := ChooseRandomNode(numtx - counter + 1, ft);  {choose second node from among those remaining}				if ft > st then					begin  {reassign so that ft is lower numbered of two nodes chosen}						tt := st;						st := ft;						ft := tt;					end;				newN := newNode(nextnode);  {make new internal node resulting from fusion}				nextnode := nextnode + 1;				newN^.name := 0;				if not FillNode(newN) then					treemakingfailed := true;				sdn := GetNodeInLine(ft);  {get leftmost of two fusing}				newN^.lf := sdn;				sdn^.anc := NewN;				sdn^.slant := -1;				sdn := GetNodeInLine(st); {get righttmost of two fusing}				newN^.rt := sdn;				sdn^.anc := NewN;				sdn^.slant := 1;				SetNodeInLine(ft, NewN);  {Now replace leftmost by new node}				for it := st to (numtx - counter) do  {=delete node st and compress nodes remaining }					SetNodeInLine(it, GetNodeInLine(it + 1));			end;{now only two nodes remain, the left and right descendants of the root.  Make the root and connect}{it to the two nodes}		R := newNode(nextnode);		if not FillNode(R) then			treemakingfailed := true;		R^.name := 0;		sdn := GetNodeInLine(1); {left descendant}		R^.lf := sdn;		sdn^.anc := R;		sdn^.slant := -1;		sdn := GetNodeInLine(2); {right descendant}		R^.rt := sdn;		sdn^.anc := R;		sdn^.slant := 1;		R^.anc := SubR;		R^.slant := 1;		ZapPointer(Nodeline);	end;{$ENDC}{=====================================================}	procedure PartitionTree;{FROZEN 3.0}{Generates random trees by successively partitioning all taxa more and more finely}		type			sptr = ^set2bytes;			set2bytes = set of 0..15;		var			TaxonHdl: thdl;			icp: ip;			ic, tn, mf, pn: integer;			subpartition, alltaxa: ptr;			numwords, numns: integer;	{........}		procedure fillAllTaxa (numwds: integer);{initialize by filling set of taxa with all taxa}			var				irr: integer;				fsp: sptr;		begin			fsp := sptr(AllTaxa);			for irr := 1 to numwds do				begin					fsp^ := [0..15];					fsp := sptr(ord4(fsp) + 2);				end;		end;   {........}		procedure CopyPointers (fpt, spt: ptr; numwds: integer);{copy elements of block numwds long from fpt into spt}			var				irr: integer;				fsp, ssp: sptr;		begin			fsp := sptr(fpt);			ssp := sptr(spt);			for irr := 1 to numwds do				begin					ssp^ := fsp^;					ssp := sptr(ord4(ssp) + 2);					fsp := sptr(ord4(fsp) + 2);				end;		end;   {........}		procedure MakeSubpartition (fpt: ptr; numwds: integer);{places in subpartion block a set of taxa reduced from fpt set by random intersection}			var				irr: integer;				fsp, qsp: sptr;		begin			fsp := sptr(fpt);			qsp := sptr(subpartition);			for irr := 1 to numwds do				begin					icp^ := RandomInteger(ourrandseed);					qsp^ := fsp^ * sptr(icp)^; {intersect old set with new set to further reduce}					qsp := sptr(ord4(qsp) + 2);					fsp := sptr(ord4(fsp) + 2);				end;		end;   {........}		procedure MakeOtherHalf (fpt, spt, tpt: ptr; numwds: integer);{subtracts contents of set in s (subpartion ptr) from those in f (last partion)}{and stores in t}			var				irr: integer;				fsp, ssp, tsp: sptr;		begin			fsp := sptr(fpt);			ssp := sptr(spt);			tsp := sptr(tpt);			for irr := 1 to numwds do				begin					tsp^ := fsp^ - ssp^;					tsp := sptr(ord4(tsp) + 2);					ssp := sptr(ord4(ssp) + 2);					fsp := sptr(ord4(fsp) + 2);				end;		end;   {........}		function minfrom (pt: ptr; numbits: integer): integer;{returns the bitnumber of the first 1 in a block of 0's and 1's numbits long}			label				3;			var				tpt: sptr;				bts, ib: integer;		begin			tpt := sptr(pt);			bts := 0;			while bts <= numbits do				begin					for ib := 0 to 15 do						begin							bts := bts + 1;  {count which bit we are in}							if (bts > numbits) or ((15 - ib) in tpt^) then  {if gone to far or have hit a 1, stop}								goto 3;						end;					tpt := sptr(ord4(tpt) + 2); {go to next word}				end;3:			minfrom := bts;		end;{.......................}		procedure InPartitionTree (var N: Nptr; an: Nptr; sl: integer; clade: ptr);{moves up tree, starting with root node.  AT each node the set of taxa in its clade is}{ pointed to by clade.  The two partitions made below will represent the taxa in}{ the two descendants of N.}			var				copyclade, otherhalf: ptr;		begin			N := newNode(nextnode);  {make the node corresponding to this level in recursion}			N^.rt := nil;			N^.lf := nil;			nextnode := nextnode + 1;			N^.slant := sl;			N^.anc := aN;			if not FillNode(N) then				treemakingfailed := true;			copyclade := NewPtr(numwords * 2);			otherhalf := newptr(numwords * 2);			if cardfrom(clade, numns) > 1 then  {if not yet reduced clade to one taxon then make next partition}				begin		{before moving up higher in recursion save set of taxa in this clade }		{(because recursion will change original storage)}					CopyPointers(clade, copyclade, numwords);					repeat						MakeSubpartition(copyclade, numwords); {make subpartition of copyclade; stored in subpartition}					until (cardfrom(subpartition, numns) <> 0) and (cardfrom(subpartition, numns) <> cardfrom(copyclade, numns));{We have now made set of taxa for left descendant of N.}{Now we find remaining taxa in clade and make set for right descendant of N}					MakeOtherHalf(copyclade, subpartition, otherhalf, numwords);					N^.name := 0;					InPartitionTree(N^.lf, N, -1, subpartition);					InPartitionTree(N^.rt, N, 1, otherhalf);				end			else  {if reduced clade to one taxon then we have reached the limit of the recursion }				{and need only to find which terminal taxon N is}				begin					mf := minfrom(clade, numns); {minfrom will find [smallest] element in clade's set -}{this corresponds to our terminal taxa}					pn := 0;					tn := 0;					repeat						pn := pn + 1;						repeat							tn := tn + 1; {find the mf'th included taxon}						until (tn > numtaxa) | includetaxon(tn);					until pn = mf;					N^.name := tn;					if N^.name <= numtaxa then						begin							TaxonHdl := GetTaxonHdl(N^.name);							taxonHdl^^.N := N;							taxonHdl^^.deleted := false;						end;				end;			ZapPointer(copyclade);			ZapPointer(otherhalf);		end;{.......................}	begin		new(icp);		nextnode := 4;		tn := 0;		numns := numtx;		numwords := numns div 16 + 1;		subpartition := NewPtr(numwords * 2);		alltaxa := NewPtr(numwords * 2);		FillAllTaxa(numwords); {make set of all taxa}		InPartitionTree(R, subR, 1, alltaxa);		Dispose(icp);		ZapPointer(subpartition);		ZapPointer(alltaxa);	end;{===================================================================}	procedure MakeRandomTree (rndtype: integer);{calls procedures above to make random trees}		var			TaxonHdl: thdl;			it: integer;	begin		if RTallTaxa then			begin				numtx := numtaxa;				for it := 1 to numtaxa do					begin						TaxonHdl := gettaxonHdl(it);						taxonHdl^^.deleted := false;					end;			end		else			numtx := numtaxain;		case rndtype of			RTjoining: 				JoiningTree;			RTpartition: 				PartitionTree;			RTequiprobable: 				EquiprobableTree;			otherwise				;		end;	end;{=======================================================================}	procedure RandomizePolytomy (N: Nptr);{FROZEN 3.0}{Chooses Random (equiprobable) resolution of polytomy at branch N.  }{Note that null nodes have already been zapped, and so this uses wasnull as indication as to }{whether node used to be null.}{}{This procedure operates by moving a branch onto Nbranches ont}		var			ondeck, batting, rightmost, leftmost, second, chosenbranch, F, G, C, H: Nptr;			GrowingClade: Nptr;			numnodes: integer;			toslantRight, fromancslantright, ChosenSlantsRight: boolean;{..............}		procedure ChooseRandomBranch (maxnum: integer);{assigns to Nptr Chosenbranch a random branch in the null region}{Maxnum is number of nodes in null region}			var				ibr, branchnum: integer;				found: boolean;			procedure UpTillNumber (Nq: Nptr);	{recurses up formerly null section of tree and finds branchnum'th node in this section}			begin				ibr := ibr + 1;				if ibr <> branchnum then					begin						if (Nq^.wasnull) then							begin								UpTillNumber(Nq^.lf);								if not found then									UpTillNumber(Nq^.rt);							end;					end				else					begin						found := true;						chosenbranch := Nq;					end;			end;		begin			found := false;			branchnum := RandomBetween(1, maxnum);			ibr := 0;			UpTillNumber(GrowingClade);		end;{..............}		function NextSisterRightinRandom (wN: Nptr): Nptr;			var				sister, leftanc: Nptr;			function FindLeftSlantAncestor (pN: Nptr): Nptr;			begin				if not NodeSlantsRight(pN) | (pN = R) | (not pN^.wasnull & (pN <> wN)) then					FindLeftSlantAncestor := pN				else					FindLeftSlantAncestor := FindLeftSlantAncestor(pN^.anc);			end;			function firstNonWasNullLeft (pN: Nptr): Nptr;			begin				if pN^.wasnull then					firstNonWasNullLeft := firstNonWasNullLeft(pN^.lf)				else					firstNonWasNullLeft := pN;			end;		begin			if not NodeSlantsRight(wN) then				begin					sister := sis(wN);					NextSisterRightinRandom := firstNonWasNullLeft(sister)				end			else				begin					if wN^.anc^.wasnull then						begin							leftanc := FindLeftSlantAncestor(wN);							if leftanc^.wasnull then								begin									sister := sis(leftanc);									NextSisterRightinRandom := firstNonWasNullLeft(sister)								end							else								NextSisterRightinRandom := wN;						end					else						NextSisterRightinRandom := wN;				end;		end;{.................................................................}	begin		rightmost := N^.rt;		while rightmost^.wasnull do			rightmost := rightmost^.rt; {last node in polytomy}		leftmost := N^.lf;		while leftmost^.wasnull do			leftmost := leftmost^.lf;{first node in polytomy}		second := NextSisterRightinRandom(leftmost); {second node in polytomy}		if not NodeSlantsRight(second) then			begin  {moving so second is always sister of leftmost}				G := sis(second);				F := second^.anc;				C := leftmost^.anc;				fromancslantright := NodeSlantsRight(F);				H := F^.anc;				G^.anc := H;				if fromancslantright then					begin						H^.rt := G;						G^.slant := 1;					end				else					begin						H^.lf := G;						G^.slant := -1;					end;				leftmost^.anc := F;				C^.lf := F;				F^.anc := C;				F^.lf := leftmost;				F^.rt := second;				F^.slant := -1;				second^.slant := 1;			end;		Growingclade := leftmost^.anc; {start off clade with Leftmost + second}		batting := NextSisterRightinRandom(second); {third node in polytomy}		numnodes := 2;		while batting <> rightmost do  {add all but rightmost}			begin				ondeck := NextSisterRightinRandom(batting);  {before adding next sister into clade, record who will come after}				ChooseRandomBranch(2 * numnodes - 1);				if chosenbranch <> sis(batting) then  {if not already done add batting onto chosenbranch}					begin						fromancslantright := NodeSlantsRight(batting^.anc);						G := sis(batting);						H := batting^.anc^.anc;						C := chosenbranch^.anc;						F := batting^.anc;{Put G and H together}						G^.anc := H;						if fromancslantright then							begin								H^.rt := G;								G^.slant := 1;							end						else							begin								H^.lf := G;								G^.slant := -1;							end;{insert F on chosenbranch and adjust slants}						ChosenSlantsRight := NodeSlantsRight(ChosenBranch);						Chosenbranch^.anc := F;						F^.anc := C;						if ChosenSlantsRight then							begin								F^.rt := chosenbranch;								C^.rt := F;								F^.slant := 1;								batting^.slant := -1;								F^.lf := batting;							end						else							begin								F^.lf := chosenbranch;								C^.lf := F;								F^.slant := -1;								batting^.slant := 1;								F^.rt := batting;							end;					end;				if chosenbranch = growingclade then					Growingclade := chosenbranch^.anc;				numnodes := numnodes + 1;				batting := ondeck;			end;{now taking care of final move of batting=rightmost; this will be N^.rt}		ChooseRandomBranch(2 * numnodes - 1);		if (chosenbranch <> N^.lf) then			begin				toslantRight := NodeSlantsRight(chosenbranch);				F := N^.lf^.lf; {This is not a problem if only three taxa because N will be root and only one taxon on right}				H := N^.lf^.rt;				G := N^.lf; {will be used as ancestor for batting}{ insert N in place of G.  This keeps lower node as not wasnull}				N^.lf := F;				N^.rt := H;				F^.anc := N;				H^.anc := N;				C := chosenbranch^.anc;{insert G into chosenbranch; remember G has to take slant of chosenbranch}				G^.anc := C;				if toslantRight then					begin						G^.rt := chosenbranch;						Chosenbranch^.anc := G;						C^.rt := G;						G^.slant := 1;						G^.lf := batting;						batting^.slant := -1;					end				else					begin						G^.lf := chosenbranch;						Chosenbranch^.anc := G;						C^.lf := G;						G^.slant := -1;						G^.rt := batting;						batting^.slant := 1;					end;				batting^.anc := G;			end;	end;{---------------------------------------------------------------}	procedure PrepareToRandomPoly (N: Nptr);{Destroys all polytomies but preserves a record of which nodes were null}{in wasnull.}{This is done in preparation for randomizing the polytomies}	begin		N^.wasnull := N^.null;		N^.null := false;		if NodeIsInternal(N) then			begin				PrepareToRandomPoly(N^.lf);				PrepareToRandomPoly(N^.rt);			end;		nullson := false;	end;{---------------------------------------------------------------}	procedure RandomizeAllPolytomies (N: Nptr);{Finds random resolution for all polytomies in tree}{Note that polytomies must be first prepared using PrepareToRandomPoly,}{because during this random resolution process, there are no null nodes, only nodes}{marked as having formerly been null}	begin		if NodeIsInternal(N) then			begin				if not N^.wasnull then {was not null}					begin						if (N^.lf^.wasnull) or (N^.rt^.wasnull) then {was polytomous}							RandomizePolytomy(N);					end;				RandomizeAllPolytomies(N^.lf);				RandomizeAllPolytomies(N^.rt);			end;{v4: one basic problem with this procedure is that it alters the original tree; thus,}{you can't just ask MacClade's ChartTreeCycle to output the random seed to a text file,}{and use that seed in the random tree DLOG, expecting it to resurrect the same tree. }{The seeds might be the same, but the starting polytomous trees aren't.  The only way}{around this that I can see would be to have it save and restore the tree in between each}{of these, something that I think would be very cumbersome.}	end;{================}{-----------------------------------------------------------------------------}	procedure InitializeRndTreesReport;	begin		split := NewPtr(4 * numtaxa);		ZeroBlockLongWords(split, numtaxa);	end;{-----------------------------------------------------------------------------}	procedure UpdateRndTreesReport;		var			spP: LIP;			spl, tn: integer;			TaxonHdl: thdl;	begin		tn := 0;		repeat			tn := tn + 1;		until (tn > numtaxa) | includetaxon(tn);  {get first taxon  included}		TaxonHdl := GetTaxonHdl(tn);		if IsAnc(R^.lf, taxonHdl^^.N) then			spl := SizeOfClade(R^.lf, false)		else			spl := SizeOfClade(R^.rt, false);		spP := LIP(ord4(split) + 4 * (spl - 1));		spP^ := spP^ + 1;	end;{-----------------------------------------------------------------------------}	function Expected (m, n: integer): double;		var			a: double;	{........}		function T (n: integer): double;			var				ir: integer;				ch: double;		begin			ch := 1.0;			for ir := 2 to n do				ch := ch * (2 * ir - 3.0);			T := ch;		end;	{........}		function Power2 (n: integer): double;			var				ir: integer;				ch: double;		begin			ch := 1.0;			for ir := 1 to n do				ch := ch * 2;			Power2 := ch;		end;	{........}		function factorial (N: integer): double;			var				ir: integer;				ch: double;		begin			ch := 1.0;			for ir := 1 to n do				ch := ch * ir;			factorial := ch;		end;	{........}		function Choose (n, m: integer): double;		begin			if (m = n) or (m = 0) then				Choose := 1.0			else if m = 1 then				Choose := n			else				choose := factorial(n) / factorial(n - m) / factorial(m);		end;	{........}	begin		case RTKind of			RTequiprobable, RTResolve: 				begin					a := choose(n, m) * T(m) * T(n - m) / T(n);					if n = m + m then {Maddison & Slatkin put a*2 !!!!!!}						a := a / 2;				end;			RTjoining: 				begin					a := 1 / (n - 1);					if n <> m + m then						a := a * 2;				end;			RTpartition: 				if n <> m + m then					a := choose(n, m) / (power2(n - 1) - 1)				else					a := choose(n, m) / (power2(n) - 2);			otherwise				;		end;		Expected := a;	end;{-----------------------------------------------------------------------------}	procedure SaveRndTreesReportToFile (numtrees, rtkind: longint);		label			1;		var			theInfo: FInfo;			thefile: integer;			oldexists, db: BOOLEAN;			ds, dss, writename: str255;			secs: longint;			H: Handle;			dL: longint;			SpP, spEP: LIP;			j, jj: integer;			theDialog: DialogPtr;			tempP: WindowPtr;			Freply: StandardFileReply;			chartWriteFileFS: FSSpec;			chartIOFDI: integer;{............}	begin	{	if storeChartFDIinfo then			begin				chartWriteFileFS := FDI^[writeFileFDI].fs;				chartIOFDI := ioFileFDI;			end;}		if RTalltaxa or (RTKind = RTResolve) then			numtx := numtaxa		else			numtx := numtaxain;{$IFC FALSE}		ds := 'SPLIT: ';		spP := LIP(split);		for j := 1 to (numtx - 1) do			begin				ds := concat(ds, stringfromnum(spP^), '/');				spP := LIP(ord4(spP) + 4);			end;		InstantInfo(ds);{$ENDC}		oldexists := false;		ds := 'Random Tree Report';		PutStandardFile('Save report as:', ds, Freply);		ShowCursor;		if Freply.sfgood then			FSpCreateSaveFile(Freply.sfFile, oldexists, 'ttxt', 'TEXT')		else			Errorflag := true;		if errorflag then			goto 1;						StartWrite;		PutTokenReturn('Report from generation of random trees');		PutTokenReturn(Maccladestamp);		PutTokenReturn(UserStamp(true, true, false));		PutTokenReturn(TimeStamp);		PutReturn;		PutTokenReturn(DataFileStamp);		putreturn;		PutToken('Number of taxa in trees: ');		PutToken(stringFromNum(numtx));		putreturn;		PutToken('Kind of random tree: ');		case RTkind of			RTjoining: 				PutTokenReturn('Random joining/splitting');			RTpartition: 				PutTokenReturn('Random partition');			RTequiprobable: 				PutTokenReturn('Equiprobable trees');			RTResolve: 				PutTokenReturn('Random (equiprobable) resolutions of current tree');			otherwise				;		end;		PutToken('Total number of trees: ');		PutToken(stringFromNum(numtrees));		putreturn;		putreturn;		PutTokenReturn('Number of trees with varying numbers of taxa on same side of root as first taxon');		PutToken('#taxa');		Puttab;		PutToken('#trees (obs.)');		Puttab;		PutToken('Expected');		PutReturn;		spP := LIP(split);		StartThermo(theDialog, tempP, 0, numtx - 1 + (numtx div 2), 'Writing Report...', '', true);		for j := 1 to (numtx - 1) do			begin				UpdateThermo(theDialog, 0, j, numtx - 1 + (numtx div 2),true);				PutToken(stringFromNum(j));				PutTab;				PutToken(stringfromnum(spP^));				PutTab;				if j + j = numtx then					jj := j + j				else					jj := j;				RealtoString(Expected(j, numtx) * numtrees * jj / numtx, dss, 1000000.0, 4, true);				Puttoken(dss);				PutReturn;				spP := LIP(ord4(spP) + 4);			end;		PutReturn;		PutTokenReturn('Number of trees with i-j basal splits: ');		PutToken('i');		PutTab;		PutToken('j');		PutTab;		PutToken('#Observed');		PutTab;		PutToken('Expected');		PutReturn;		spP := LIP(split);		spEP := LIP(ord4(split) + 4 * (numtx - 2));		for j := 1 to (numtx div 2) do			begin				UpdateThermo(theDialog, 0, j + numtx - 1, numtx - 1 + (numtx div 2), true);				PutToken(stringFromNum(j));				PutTab;				PutToken(stringFromNum(numtx - j));				PutTab;				if j + j = numtx then					PutToken(stringfromnum(spP^))				else					PutToken(stringfromnum(spP^ + spEP^));				PutTab;				RealtoString(Expected(j, numtx) * numtrees, dss, 1000000.0, 4, true);				PutToken(dss);				PutReturn;				spP := LIP(ord4(spP) + 4);				spEP := LIP(ord4(spEP) - 4);			end;		EndThermo(theDialog, tempP, false);		EndWrite;		if errorflag then			goto 1;		if oldexists then			FSpExchangeFilesDeleteTemp(Freply.sfFile);1:	{	if storeChartFDIinfo then			begin				FDI^[writeFileFDI].fs := chartWriteFileFS;				FDI^[extraIOFileFDI].fs := chartWriteFileFS;				ioFileFDI := chartIOFDI;			end;}		ZapPointer(split);	end;end.