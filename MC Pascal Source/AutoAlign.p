unit AutoAlign;{ееееееееееееееееееееее}interface	uses		QuickDraw, 		Types, Events, QuickDrawText, OSUtils, TextUtils,Controls, Menus, Files,  Windows, 		Sound, Dialogs, TextEdit, Lists, ToolUtils, Memory, Fonts, Resources, Scrap, 		Globals, WindowUtil, GenUtil, StrUtil, BoxUtil, SetLibInterface, TaxonCHUtil,		CharUtil, MenuUtil, SymbolsNames, TreeUtil, Fill, SpreadUtil, Footnote, DrawSpread, 		RowColumn, StatesWindow, ScrollSpread, CopyPaste, ToolPalette,AlignmentUtil, MoveData, EditorUndo, Thermos;		function DistanceBetweenStateSets(set1,set2: largestsetchars): longint;	procedure AutoAlignSequences(clickTaxon: integer);	procedure StarAlignment(referenceTaxon: integer; justSelected:boolean);	procedure AlignSelectedBlock(clickTaxon: integer);	function PairwiseDistance(it1, it2, sc, ec: integer): longint;	procedure CalcSumOfPairwise;	procedure UndoAlignment;				{ееееееееееееееееееееее}implementation {е$S AutoAlign}	var alignmentTypeH: TypeHandle;		useGotohMethod: boolean;		alignmentMatrixP, gapInClickMatrixP, gapInDropMatrixP, dropSequence, clickSequence, lastClickCosts: LIP;		dropChars, clickChars: longint;		startingDropGaps, endingDropGaps: longint;{$SETC SPINBEACH=FALSE}	{$SETC DEBUGALIGNMENT=FALSE}{$SETC WRITEALIGNMENTFILES=FALSE}{$SETC WRITETIMES=FALSE}{$IFC DEBUGALIGNMENT}	var  		debugfile: text;		oldDebugTime: longint;		otherTime, clickScanTime, dropScanTime, clickCalc1Time: longint;			{----------------------------------------------------------------------------}	procedure AddLastTime(var dL: longint);	begin		dL := dL + (TickCount-oldDebugTime);		oldDebugTime := TickCount;	end;{----------------------------------------------------------------------------}	procedure StartDebugFile;	begin		rewrite(debugfile, 'AlignmentMatrices');	end;{----------------------------------------------------------------------------}	procedure EndDebugFile;	begin		close(debugfile);	end;	{$ENDC}{-----------------------------------------------------------------------------}	function WithinACodon(ic: integer): boolean;	begin		WithinACodon := nucleotides & (ic>1) & (ic<numchars) & ((CharCodPos(ic)=1) | (CharCodPos(ic)=2)) & (CharCodPos(ic+1)=CharCodPos(ic)+1);	end;{-----------------------------------------------------------------------------}	function NumNonGapsInTaxon (it,firstAlignmentChar,lastAlignmentChar: integer; considerMissing,terminalMissingAsGaps: boolean): longint;	var dL: longint;		ic: integer;		tsts: largestsetchars;		sc, ec: integer;	begin			sc := firstAlignmentChar;		ec := lastAlignmentChar;		if terminalMissingAsGaps & not considerMissing then			begin				for ic := firstAlignmentChar to lastAlignmentChar do					begin						tsts := gettaxonstsLargest(it, ic);						if tsts <> [MSl] then							begin								sc := ic;								leave;							end;					end;				for ic := lastAlignmentChar downto firstAlignmentChar do					begin						tsts := gettaxonstsLargest(it, ic);						if tsts <> [MSl] then							begin								ec := ic;								leave;							end;					end;			end;		dL:= 0;		for ic := sc to ec do				begin					tsts := gettaxonstsLargest(it, ic);					if not ((tsts = [MSl,GAl]) | (considerMissing&(MSl in tsts))) then						dL := dL + 1;				end;		NumNonGapsInTaxon:= dL;	end;{-----------------------------------------------------------------------------}	function DistanceBetweenStateSets(set1,set2: largestsetchars): longint;	var tH: typeHandle;		st1,st2: integer;		min1,min2: integer;		minDistance, distanceReverse: longint;		distance: longint;	begin		distance := 1;		if EqualSets(set1,set2) | StateInSet(MSl,set1) | StateInSet(MSl,set2) | EmptySet(OldSetFromNew(Intersect2(NewSetFromOld(set1),NewSetFromOld(set1)))) then			distance := 0		else if alignmentCostMatrix <> unordered then			begin				if (alignmentTypeH<> nil) & not StateInSet(MSl,set1) & not StateInSet(MSl,set2) then					begin						min1:= MinLg(set1);						min2 := MinLg(set2);						if (set1=[min1]) & (set2=[min2]) then							begin								if alignmentTypeH^^.dist[Min1, min2]=infinity then									distance := ord4(numchars)*gapextensionCost								else									begin										distance := alignmentTypeH^^.dist[min1,min2];										{distanceReverse := alignmentTypeH^^.dist[min2,min1];										if (distance = infinity) | (distanceReverse<distance) then											if distanceReverse=infinity then												distance := superInfinity											else												distance := distanceReverse;}									end;							end						else							begin								minDistance := ord4(numchars)*gapextensionCost;								for st1 := min1 to maxstate do									if st1 in set1 then										for st2 := min2 to maxstate do											if st2 in set2 then												begin													distance := alignmentTypeH^^.dist[st1,st2];													{distanceReverse := alignmentTypeH^^.dist[st2,st1];													if (distance = infinity) | (distanceReverse<distance) then														if distanceReverse=infinity then															distance := superInfinity														else															distance := distanceReverse;}													if distance<minDistance then															minDistance := distance;												end;								distance := minDistance;							end;					end;			end;		DistanceBetweenStateSets := distance * alignmentChangeCost;			end;{-----------------------------------------------------------------------------}	procedure SetlastPValue(lastP: LIP; ic: integer; value: longint);	begin		LIP(ord4(lastP) + ord4(ic)*4)^ := value;	end;{-----------------------------------------------------------------------------}	function GetLastPValue(lastP: LIP; ic: integer): longint;	begin		GetLastPValue := LIP(ord4(lastP) + ord4(ic)*4)^;	end;{-----------------------------------------------------------------------------}	procedure SetAlignmentMatrixValue(matrixP: LIP; icClick, icDrop: integer; value: longint);	var test: longint;	begin		if (icClick < 0) | (icClick> clickChars) | (icDrop < 0) | (icDrop> dropChars) then			begin				test:= value;			end		else			LIP(ord4(matrixP) + (ord4(dropChars+1)*(icClick)+icDrop)*4)^ := value;	end;{-----------------------------------------------------------------------------}	function GetAlignmentMatrixValue(matrixP: LIP; icClick, icDrop: integer): longint;	var matrixPos: longint;	matrixSize: longint;	begin		matrixSize:= GetPtrSize(Ptr(matrixP));		matrixPos:=  (ord4(dropChars+1)*(icClick)+icDrop)*4;		GetAlignmentMatrixValue := LIP(ord4(matrixP) +matrixPos)^;	end;	{-----------------------------------------------------------------------------}	procedure MarkAlignmentMatrixValue(matrixP: LIP; icClick, icDrop: integer);	var minCost: longint;	begin		minCost := GetAlignmentMatrixValue(matrixP, icClick, icDrop);		SetAlignmentMatrixValue(matrixP, icClick, icDrop,-minCost-1);	end;{-----------------------------------------------------------------------------}	procedure ReverseAlignmentMatrixValueSign(matrixP: LIP; icClick, icDrop: integer);	begin		LIP(ord4(matrixP) + (ord4(dropChars+1)*(icClick)+icDrop)*4)^ := -LIP(ord4(matrixP) + (ord4(dropChars+1)*(icClick)+icDrop)*4)^;	end;{-----------------------------------------------------------------------------}	function AlignmentSequenceState(sequence: LIP; ic: integer; removeSSl: boolean): LargestSetChars;	var tsts: LargestSetChars;	begin		tsts := SetPointer31(ord4(sequence)+(ic-1)*4)^;		if removeSSl then tsts := tsts - [SSl];		AlignmentSequenceState := tsts;	end;{-----------------------------------------------------------------------------}	function DropSequenceHasGap(ic: integer): boolean;	begin		DropSequenceHasGap:=AlignmentSequenceState(dropSequence,ic, true)=[MSl,GAl];	end;{-----------------------------------------------------------------------------}	procedure UndoAlignment;	begin		case lastChangeInEditor of			lastChangeCellBlock:				begin					UndoCellBlock(true);				end;			lastChangeInsertCharAndCellBlock:				begin					DeleteNewlyInsertedCharacters;					UndoCellBlock(false);					InvalidateWindow(editorWindow,true);				end;			otherwise;		end;		{SetLastChangeInEditor(lastChangeCantUndo);}	end;{-----------------------------------------------------------------------------}{$IFC WRITEALIGNMENTFILES}	procedure WriteAlignmentMatrix(matrixP: LIP; matrixname: str255);	var icDrop, icClick: integer;		dist: longint;		tsts: largestsetchars;		ds: str255;	begin		writeln(debugfile, ' ');		writeln(debugfile, matrixname);				write(debugfile,0);		write(debugfile, chr(9));		write(debugfile, chr(9));		write(debugfile, chr(9));		for icDrop := 1 to dropChars do			begin				tsts :=  AlignmentSequenceState(dropSequence,icDrop, true); 				ds := StsToString(tsts, icDrop, false,nucleotides);				write(debugfile, chr(9),'  ',ds);			end;		writeln(debugfile, ' ');				write(debugfile,0);		write(debugfile, chr(9));		write(debugfile, chr(9));		for icDrop := 0 to dropChars do			begin				write(debugfile, chr(9),icDrop:3);			end;		writeln(debugfile, ' ');				for icClick := 0 to clickChars do			begin				tsts :=  AlignmentSequenceState(clickSequence,icClick, true); 				ds := StsToString(tsts, icClick, false,nucleotides);				write(debugfile, chr(9),'  ',ds);				write(debugfile, chr(9),icClick);				for icDrop := 0 to dropChars do					begin						dist := GetAlignmentMatrixValue(matrixP,icClick,icDrop);						write(debugfile,  chr(9), dist:3);					end;				writeln(debugfile, ' ');			end;		writeln(debugfile, ' ');		writeln(debugfile, ' ');	end;{-----------------------------------------------------------------------------}	procedure WritelastValues(lastP: LIP; lastPName: str255; maxChars: integer);	var ic: integer;		dist: longint;		tsts: largestsetchars;		ds: str255;	begin		writeln(debugfile, ' ');		writeln(debugfile, ' ');		writeln(debugfile, lastPName);						write(debugfile,0);		write(debugfile, chr(9));		write(debugfile, chr(9));		for ic := 0 to maxChars do			begin				dist := GetLastPValue(lastP,ic);				write(debugfile, chr(9),dist:3);			end;		writeln(debugfile, ' ');		writeln(debugfile, ' ');	end;{$ENDC}{-----------------------------------------------------------------------------}	procedure CalcLocalMinPath (reportOnlyPath: boolean;  icClick, icDrop,minDropDist: longint; var deltaClick, deltaDrop: longint; dist: longint; var minCost: longint);{given we are at icClick and icDrop in the alignment matrix, this procedure calculates the best way to get there, and how much it costs}	label 1;	var noGap, gapClick, gapDrop: longint;		gapCost: longint;		thisCost, dropGaps, startGapCost, endGapCost, terminalDropGaps, maxTerminalGapCost : longint;		ic,icEnd: integer;		minCostToFind, minClickDist: longint;	begin		minCostToFind := minCost;		if (icClick=0) & (icDrop=0) then			begin				deltaClick := 0; 				deltaDrop := 0;			end		else if icClick = 0 then			begin				deltaClick := 0; 				deltaDrop := -1;			end		else if icDrop = 0 then			begin				deltaClick := -1; 				deltaDrop := 0;			end		else   {by default, presume we came from cell up and to the left}			begin				deltaClick := -1;  				deltaDrop := -1;			end;				minCost := -1;  {start here so that we can detect first time through}		{now figure out how much it would cost to just come from one over}		if (icClick>0) & (icDrop>0) then			minCost := GetAlignmentMatrixValue(alignmentMatrixP,icClick-1,icDrop-1)+dist;					{ else if (icClick=0) & (icDrop=0) then			begin				minCost := dist;				deltaDrop := -1;				deltaClick:= -1;			end};					if reportOnlyPath & (minCost=minCostToFind) then Exit(CalcLocalMinPath);					if minCost = 0 then Exit(CalcLocalMinPath);		maxTerminalGapCost := terminalGapStartCost + (icClick)* terminalGapExtensionCost;		if approximateAlignment & (terminalGapStartCost=0) & (gapStartCost=0) then			begin				icEnd := icClick-approxAlignRange;				if icEnd < 0 then icEnd := 0;			end		else 			icEnd := 0;		if DropSequenceHasGap(1) then			startGapCost := 0 		else			startGapCost := terminalGapStartCost;		if DropSequenceHasGap(dropChars) then			endGapCost := 0 		else			endGapCost := terminalGapStartCost;{$IFC WRITETIMES}AddLastTime(otherTime);{$ENDC}{=====  check up the column for best cost =========}		for ic := icClick-1 downto icEnd do			begin				thisCost := GetAlignmentMatrixValue(alignmentMatrixP,ic,icDrop);				if thisCost < 0 then thisCost := -thisCost-1;				{if AlignmentSequenceState(dropSequence,icDrop, true)<>[MSl,GAl] then} {it's a gap, so no cost for going over one}				if (ic = 0) then  {we have made our way up to the start of the sequence}					gapCost := maxTerminalGapCost				else if (icClick=ClickChars) then  {we are hitting the edge, and so this must be a terminal gap}					gapCost := terminalGapStartCost + (icClick-ic)* terminalGapExtensionCost				else if (icDrop=DropChars) then   {we are already at the right-most edge, and so this must be a terminal gap, as it must run to the end}					gapCost := endGapCost + (icClick-ic)* terminalGapExtensionCost				else if WithinACodon(icDrop) then					gapCost := gapStartCost + alignmentInnerCodonCost + (icClick-ic)* gapExtensionCost				else					gapCost := gapStartCost + (icClick-ic)* gapExtensionCost;				{if  (maxTerminalGapCost<=gapCost) then					begin						if (maxTerminalGapCost > mincost) then leave					end				else }				if  approximateAlignment & (gapCost > minCost) then leave;  				thisCost := thisCost+gapCost;				if reportOnlyPath & (thisCost=minCostToFind) then 					begin						deltaClick := ic - icClick;						deltaDrop := 0;						Exit(CalcLocalMinPath);					end;				if (minCost = -1) | (thisCost < minCost) then 					begin						minCost := thisCost;						deltaClick := ic - icClick;						deltaDrop := 0;					end;			end;{$IFC WRITETIMES}AddLastTime(clickScanTime);{$ENDC}		{check left in the row for best cost}		dropGaps := 0;		terminalDropGaps := 0;		ic := icDrop-1;{$IFC WRITETIMES}AddLastTime(clickCalc1Time);{$ENDC}		if approximateAlignment & (terminalGapStartCost=0) & (gapStartCost=0) & (not DropSequenceHasGap(icDrop)) & ((icDrop<=1) | (not DropSequenceHasGap(icDrop-1))) then			begin				icEnd := icDrop-approxAlignRange;				if icEnd < 0 then icEnd := 0;			end		else			icEnd := 0;					if icEnd > 0 then			begin				gapCost := 0;			end;		while ic >= icEnd do 			begin				thisCost := GetAlignmentMatrixValue(alignmentMatrixP,icClick,ic);				{if thisCost < 0 then thisCost := -thisCost;}				{if AlignmentSequenceState(dropSequence,icDrop, true)<>[MSl,GAl] then} {it's a gap, so no cost for going over one}				if (ic = 0) then					gapCost :=  startGapCost + (icDrop-terminalDropGaps-dropGaps)* terminalGapExtensionCost				else if (icDrop=dropChars) then  {we are the end}					 gapCost :=  endGapCost + (icDrop-ic-terminalDropGaps-dropGaps)* terminalGapExtensionCost				else if icClick = clickChars then  {we are at the end of the click sequence}					if endingDropGaps = 0 then						 gapCost :=  endGapCost + (icDrop-ic-terminalDropGaps-dropGaps)* terminalGapExtensionCost					else						gapCost := (icDrop-ic-terminalDropGaps-dropGaps)* terminalGapExtensionCost				else	if (dropGaps > 0)  then						gapCost := (icDrop-ic-dropGaps)* gapExtensionCost					else						gapCost := gapStartCost + (icDrop-ic)* gapExtensionCost;				{if  (maxTerminalGapCost<=gapCost) then					begin						if (maxTerminalGapCost > mincost) then leave					end				else} 				if approximateAlignment & (gapCost > minCost) then goto 1;  				thisCost := thisCost+gapCost;				if reportOnlyPath & (thisCost=minCostToFind) then 					begin						deltaDrop := ic - icDrop;						deltaClick:= 0;						Exit(CalcLocalMinPath);					end;				if (minCost = -1) |(thisCost < minCost) then 					begin						minCost := thisCost;						deltaDrop := ic - icDrop;						deltaClick:= 0;					end;{$IFC false}				if not DropSequenceHasGap(ic)  then					ic := ic-1				else 					begin						while DropSequenceHasGap(ic) & (ic>=1) do							begin								if (ic>= startingDropGaps) & (ic <=dropChars-endingDropGaps) then									dropGaps := dropGaps + 1								else									terminalDropGaps := terminalDropGaps+1;								ic := ic-1;							end;						if ic < 0 then ic := 0;					end;  {$ELSEC}								if DropSequenceHasGap(ic) then					begin						if (ic>= startingDropGaps) & (ic <=dropChars-endingDropGaps) then							dropGaps := dropGaps + 1						else							terminalDropGaps := terminalDropGaps+1;					end;				ic := ic-1;{$ENDC}			end;	1:{$IFC WRITETIMES}AddLastTime(dropScanTime);{$ENDC}	end;{-----------------------------------------------------------------------------}	procedure BackTrackPathGotoh (icClick, icDrop: longint; var deltaClick, deltaDrop: longint;   minCostToFind: longint);	begin		if (icClick=0) & (icDrop=0) then			begin				deltaClick := 0; 				deltaDrop := 0;			end		else if icClick = 0 then			begin				deltaClick := 0; 				deltaDrop := -1;			end		else if icDrop = 0 then			begin				deltaClick := -1; 				deltaDrop := 0;			end		else if minCostToFind = GetAlignmentMatrixValue(gapInDropMatrixP,icClick,icDrop) then			begin				deltaClick := -1; 				deltaDrop := 0;			end		else if minCostToFind = GetAlignmentMatrixValue(gapInClickMatrixP,icClick,icDrop) then			begin				deltaClick := 0; 				deltaDrop := -1;			end		else if (icDrop <= startingDropGaps) & (minCostToFind= (icClick)* terminalGapExtensionCost) then			begin				deltaClick := -1; 				deltaDrop := 0;			end		else if (icClick=ClickChars) & (minCostToFind= GetLastPValue(lastClickCosts,icDrop))& (icDrop> (DropChars-endingDropGaps)) then			begin				deltaClick := -1; 				deltaDrop := 0;			end		else   {by default, presume we came from cell up and to the left}			begin				deltaClick := -1;  				deltaDrop := -1;			end;	end;{-----------------------------------------------------------------------------}	procedure CalcLocalMinPathGotoh (icClick, icDrop, minDropDist: longint; var deltaClick, deltaDrop: longint; dist: longint; var minCost: longint);{given we are at icClick and icDrop in the alignment matrix, this procedure calculates the best way to get there, and how much it costs}	label 1;	var noGap, gapClick, gapDrop: longint;		gapCost: longint;		thisCost, dropGaps, startGapCost, endGapCost, terminalDropGaps, maxTerminalGapCost : longint;		ic,icEnd: integer;		minCostToFind, minClickDist: longint;		singleGapCost, multiGapCost,bestGapCost,fullTerminalGapCost: longint;	begin		minCostToFind := minCost;		if (icdrop=15) then			begin				deltaClick := 0; 				deltaDrop := 0;			end;							if (icClick=0) & (icDrop=0) then			begin				deltaClick := 0; 				deltaDrop := 0;			end		else if icClick = 0 then			begin				deltaClick := 0; 				deltaDrop := -1;			end		else if icDrop = 0 then			begin				deltaClick := -1; 				deltaDrop := 0;			end		else   {by default, presume we came from cell up and to the left}			begin				deltaClick := -1;  				deltaDrop := -1;			end;				minCost := -1;  {start here so that we can detect first time through}		{now figure out how much it would cost to just come from one over and up; i.e., with no gaps introduced}		if (icClick>0) & (icDrop>0) then			minCost := GetAlignmentMatrixValue(alignmentMatrixP,icClick-1,icDrop-1)+dist;					if DropSequenceHasGap(1) then			startGapCost := 0 		else			startGapCost := terminalGapStartCost;		if DropSequenceHasGap(dropChars) then			endGapCost := 0 		else			endGapCost := terminalGapStartCost;{=====  check up one up to see its cost in putting gaps in Drop sequence; also, set the gapInDropMatrixP cost   =========}		if icClick>=1 then 			begin	{е first calculate the cost of opening up a single gap in the Drop sequence, by coming down from the one immediately above}						{it is calculated as the value at the preceding square, plus the cost of opening a gap of length 1}				if icDrop = dropChars then					if endingDropGaps > 0 then						singleGapCost := GetAlignmentMatrixValue(alignmentMatrixP,icClick-1,icDrop)+terminalgapStartCost+terminalgapExtensionCost					else						singleGapCost := GetAlignmentMatrixValue(alignmentMatrixP,icClick-1,icDrop)+terminalgapExtensionCost				else if WithinACodon(icDrop) then					singleGapCost := GetAlignmentMatrixValue(alignmentMatrixP,icClick-1,icDrop)+gapStartCost+alignmentInnerCodonCost+gapExtensionCost				else					singleGapCost := GetAlignmentMatrixValue(alignmentMatrixP,icClick-1,icDrop)+gapStartCost+gapExtensionCost;	{е now calculate the cost of extending a gap in the Drop sequence, by coming down from the one immediately above under the presumption that one was in a gap}				if icClick > 1 then					if icDrop=dropChars then						multiGapCost := GetAlignmentMatrixValue(gapInDropMatrixP,icClick-1,icDrop)+terminalgapExtensionCost					else						multiGapCost := GetAlignmentMatrixValue(gapInDropMatrixP,icClick-1,icDrop)+gapExtensionCost				else					multiGapCost := singleGapCost+1;	{е now figure out which of the preceeding gap possibilities is cheaper}				if singleGapCost<multiGapCost then   {the best cost ending in an internal gap for the current cell is the singleGapCost}					bestGapCost := singleGapCost				else					bestGapCost := multiGapCost;				SetAlignmentMatrixValue(gapInDropMatrixP,icClick,icDrop,bestGapCost);	{е now calculate cost of opening up terminal gaps in drop sequence 		- note that these will only be TERMINAL gaps if all states of the dropSequence from 1 to icDrop inclusive have gaps, 			otherwise this will measure INTERNAL gaps}				if icDrop <= startingDropGaps then					begin						fullTerminalGapCost := (icClick)* terminalGapExtensionCost;						if fullTerminalGapCost < bestGapCost then							bestGapCost := fullTerminalGapCost;					end;	{е if we are end, check possibility of terminal gap.  can only be relevant if icClick is = clickChars AND icDrop>= endingDropGaps}				if (icClick=ClickChars) & (icDrop> (DropChars-endingDropGaps)) then					begin						fullTerminalGapCost := GetLastPValue(lastClickCosts,icDrop);						{fullTerminalGapCost := GetAlignmentMatrixValue(gapInDropMatrixP,0,icDrop)+terminalgapExtensionCost ;						for ic := 1 to clickChars-1 do							temp}						if fullTerminalGapCost <bestGapCost then							bestGapCost := fullTerminalGapCost;					end;				if (minCost = -1) | (bestGapCost < minCost) then 					begin						minCost := bestGapCost;						deltaClick := -1;						deltaDrop := 0;					end;			end;		{=====  check up one to the left to see its cost in putting gaps in click sequence; also, set the gapInClickMatrixP cost   =========}		if icDrop >= 1 then			begin	{е first calculate the cost of opening up a single gap in the click sequence, by coming down from the one immediately to the left}						{it is calculated as the value at the preceding square, plus the cost of opening a gap of length 1}				if DropSequenceHasGap(icDrop) then  {should it be icDrop-1???}					if ((icDrop>(DropChars-endingDropGaps)) | (icDrop<=startingDropGaps)) & (icClick<clickChars) then  {the dropsequence gap is terminal, but the click one is internal}						singleGapCost := GetAlignmentMatrixValue(alignmentMatrixP,icClick,icDrop-1)+gapStartCost+gapExtensionCost					else						singleGapCost := GetAlignmentMatrixValue(alignmentMatrixP,icClick,icDrop-1)				else if icClick=ClickChars then					if endingDropGaps > 0 then						singleGapCost := GetAlignmentMatrixValue(alignmentMatrixP,icClick,icDrop-1)+terminalgapExtensionCost					else						singleGapCost := GetAlignmentMatrixValue(alignmentMatrixP,icClick,icDrop-1)+terminalgapStartCost+terminalgapExtensionCost				else if WithinACodon(icClick) then   {added 4.01}					singleGapCost := GetAlignmentMatrixValue(alignmentMatrixP,icClick,icDrop-1)+gapStartCost+alignmentInnerCodonCost+gapExtensionCost				else 					singleGapCost := GetAlignmentMatrixValue(alignmentMatrixP,icClick,icDrop-1)+gapStartCost+gapExtensionCost;	{е now calculate the cost of extending a gap in the Drop sequence, by coming down from the one immediately above under the presumption that one was in a gap}				if icDrop > 1 then					if not DropSequenceHasGap(icDrop) then						if icClick=ClickChars then							multiGapCost := GetAlignmentMatrixValue(gapInClickMatrixP,icClick,icDrop-1)+terminalgapExtensionCost						else							multiGapCost := GetAlignmentMatrixValue(gapInClickMatrixP,icClick,icDrop-1)+gapExtensionCost					else						multiGapCost := GetAlignmentMatrixValue(gapInClickMatrixP,icClick,icDrop-1)				else					multiGapCost := singleGapCost+1;	{е now figure out which of the preceeding gap possibilities is cheaper}				if singleGapCost<multiGapCost then   {the best cost ending in an internal gap for the current cell is the singleGapCost}					bestGapCost := singleGapCost				else					bestGapCost := multiGapCost;				SetAlignmentMatrixValue(gapInClickMatrixP,icClick,icDrop,bestGapCost);				if (minCost = -1) | (bestGapCost < minCost) then 					begin						minCost := bestGapCost;						deltaClick := 0;						deltaDrop := -1;					end;			end;1:	{now we need to determine if the cost of going from here all the way to the end (i.e. to clickChars) and storing it in lastClickCosts}		if (icClick=0) then			begin				if (icDrop >= endingDropGaps) then					if WithinACodon(icDrop) then						SetLastPValue(lastClickCosts,icDrop,gapStartCost+gapExtensionCost*clickChars+alignmentInnerCodonCost)					else						SetLastPValue(lastClickCosts,icDrop,gapStartCost+gapExtensionCost*clickChars);			end		else if (icClick< clickChars) then			begin				fullTerminalGapCost := GetLastPValue(lastClickCosts,icDrop);  {current value}				if endingDropGaps > 0 then 					SetLastPValue(lastClickCosts,icDrop,minCost + (clickChars-icClick)*terminalGapExtensionCost)				else					SetLastPValue(lastClickCosts,icDrop,minCost + terminalGapStartCost+(clickChars-icClick)*terminalGapExtensionCost);			end;	end;{-----------------------------------------------------------------------------}	function AlignClickOntoDrop(clickTaxon, dropTaxon, firstAlignmentChar: integer; var lastAlignmentChar: integer; doUpdates, showthermo,OKtoHaveAllGapsInClick: boolean): boolean;	const pathValue=-1; 	label 1;	var  curNumChars, amountNeeded: longint;		tsts, dropTSTS, clickTSTS: largestsetchars;		curChar: LIP;		charInserted, contiguous: boolean;		dist, enddist, lastdist,originalEndDist, minDropDist: longint;		icDrop, icClick, ic, deltaClick, deltaDrop, curClickChar, curDropChar,matrixDropChar: longint;		sc,ec: longint;		noGap,gapClick,gapDrop,minCost, score, bestscore, endGapCost:longint;		userAborted, foundNonGap: boolean;		thermoTotalUnits, thermoUnits, baseThermoUnits: longint;		tempP: WindowPtr;		TD: DialogPtr;		changedTaxon: integer;	begin{$IFC SPINBEACH}		SpinBeachBall;{$ENDC}		AlignClickOntoDrop := false;				useGotohMethod :=  useGotohIfPossible;		alignmentTypeH := GetTypeHdl(alignmentCostMatrix);		userAborted := false;{$IFC DEBUGALIGNMENT}	writeln(debugfile,'AlignClickOntoDrop 1');{$ENDC}		clickChars := NumNonGapsInTaxon(clickTaxon, firstAlignmentChar,lastAlignmentChar,editorToolsTreatMissingAsGaps,alignTreatsTerminalMissingAsGaps);		if (clickChars = 0) then 			begin				if OKtoHaveAllGapsInClick then					AlignClickOntoDrop := true;				Exit(AlignClickOntoDrop);			end;		if CheckIfAllGaps(dropTaxon,dropTaxon,firstAlignmentChar,lastAlignmentChar,editorToolsTreatMissingAsGaps) then 			Exit(AlignClickOntoDrop);		dropChars := lastAlignmentChar-firstAlignmentChar+1;				if useGotohMethod then			begin				if not EnoughMemory((clickChars+1)*(dropChars+1)*12+clickChars*4+dropChars*8+1024, amountneeded) then					begin						InstantErrorPlus(414, concat(StringFromNum(amountneeded div 1024), 'Kb'));						Exit(AlignClickOntoDrop);					end;			end		else			begin				if not EnoughMemory((clickChars+1)*(dropChars+1)*4+clickChars*4+dropChars*4+1024, amountneeded) then					begin						InstantErrorPlus(414, concat(StringFromNum(amountneeded div 1024), 'Kb'));						Exit(AlignClickOntoDrop);					end;			end;{$IFC DEBUGALIGNMENT}	writeln(debugfile,'AlignClickOntoDrop 2');	writeln(debugfile,'clickChars: ', clickChars);	writeln(debugfile,'dropChars: ', dropChars);{$ENDC}{========  make the memory  =========}		alignmentMatrixP := LIP(NewPtrClear(ord4(clickChars+1)*(dropChars+1)*4)); {$IFC DEBUGALIGNMENT}	writeln(debugfile,'AlignClickOntoDrop 3');{$ENDC}		if useGotohMethod then			begin				gapInClickMatrixP := LIP(NewPtrClear((clickChars+1)*(dropChars+1)*4));   {matrix holding min cost of gap in Click, that is, coming from left}				gapInDropMatrixP := LIP(NewPtrClear((clickChars+1)*(dropChars+1)*4));   {matrix holding min cost of gap in Drop, that is, coming from Up}				lastClickCosts:= LIP(NewPtrClear((dropChars+1)*4));			end		else			begin				gapInClickMatrixP := nil;				gapInDropMatrixP := nil;			end;{$IFC DEBUGALIGNMENT}	writeln(debugfile,'AlignClickOntoDrop 4');{$ENDC}		clickSequence := LIP(NewPtr(clickChars*4));		dropSequence := LIP(NewPtr(dropChars*4));{$IFC DEBUGALIGNMENT}	writeln(debugfile,'AlignClickOntoDrop 5');{$ENDC}{$IFC NOT SPINBEACH}	thermototalUnits := clickChars*9;  {this is going through clickchars 4 times:  									- calc similarity values (wt of 1)									- calc paths (wt of 5)									- set -1's (wt of 1)									- doing alignment (wt of 2)}	thermoUnits := 0;		if showthermo then		StartThermo(TD, tempP, 0, thermoTotalUnits, 'Pairwise Alignment', '', true);{$ENDC}		{========  figure out first non-missing and last non-missing in click sequence ==========}{ only need to do this if we were asked to skip over these by having alignTreatsTerminalMissingAsGaps to true}		sc := firstAlignmentChar;		ec := lastAlignmentChar;		if alignTreatsTerminalMissingAsGaps  then			begin				for ic := firstAlignmentChar to lastAlignmentChar do					begin						tsts := gettaxonstsLargest(clickTaxon, ic);						if tsts <> [MSl] then							begin								sc := ic;								leave;							end;					end;				for ic := lastAlignmentChar downto firstAlignmentChar do					begin						tsts := gettaxonstsLargest(clickTaxon, ic);						if tsts <> [MSl] then							begin								ec := ic;								leave;							end;					end;			end;{========  fill the Click Sequence Pointer with the click sequence  =========}		curChar := clickSequence;		for ic := sc to ec do			begin				tsts := gettaxonstsLargest(clickTaxon, ic);				if not ((tsts = [MSl,GAl]) | (editorToolsTreatMissingAsGaps&(MSl in tsts))) then					begin						if AlternativeSymbol(clickTaxon,ic)  then							tsts := tsts + [SSl];						SetPointer31(curChar)^ := tsts;						curChar := LIP (Pointer(ord4(curChar)+4));					end;			end;		{========  figure out first non-missing and last non-missing in drop sequence ==========}{ only need to do this if we were asked to skip over these by having alignTreatsTerminalMissingAsGaps to true}		sc := firstAlignmentChar;		ec := lastAlignmentChar;		if alignTreatsTerminalMissingAsGaps then			begin				for ic := firstAlignmentChar to lastAlignmentChar do					begin						tsts := gettaxonstsLargest(dropTaxon, ic);						if tsts <> [MSl] then							begin								sc := ic;								leave;							end;					end;				for ic := lastAlignmentChar downto firstAlignmentChar do					begin						tsts := gettaxonstsLargest(dropTaxon, ic);						if tsts <> [MSl] then							begin								ec := ic;								leave;							end;					end;			end;{========  fill the Drop Sequence Pointer with the Drop sequence  =========}		curChar := dropSequence;		for ic := firstAlignmentChar to lastAlignmentChar do			begin				tsts := gettaxonstsLargest(dropTaxon, ic);				if (tsts = [MSl,GAl]) | (editorToolsTreatMissingAsGaps&(MSl in tsts)) | (ic<sc) | (ic>ec) then						SetPointer31(curChar)^ := [MSl,GAl]				else						SetPointer31(curChar)^ := tsts;				curChar := LIP (Pointer(ord4(curChar)+4));			end;		{========  find how many starting and ending gaps there are in the Drop sequence  =========}		startingDropGaps := 0;		for ic := 1 to DropChars do			if DropSequenceHasGap(ic) then				startingDropGaps := startingDropGaps + 1			else				leave;		endingDropGaps := 0;		for ic := DropChars downto 1 do			if DropSequenceHasGap(ic) then				endingDropGaps := endingDropGaps + 1			else				leave;{$IFC DEBUGALIGNMENT}	writeln(debugfile,'AlignClickOntoDrop 6');{$ENDC}				{========  fill left-most column  ==========}		SetAlignmentMatrixValue(alignmentMatrixP,0,0, 0);		if startingDropGaps > 0 then			endGapCost := 0		else			endGapCost := terminalGapStartCost;		for icClick := 1 to clickChars do			SetAlignmentMatrixValue(alignmentMatrixP,icClick,0, endGapCost+ icClick*terminalGapExtensionCost);			{========  fill top row  ==========}		curDropChar := 0;		for icDrop := 1 to dropChars do			begin				if not DropSequenceHasGap(icDrop) then					curDropChar := curDropChar+1;				SetAlignmentMatrixValue(alignmentMatrixP,0,icDrop, endGapCost+ curDropChar*terminalGapExtensionCost);			end;		if curDropChar=0 then goto 1;{======== fill lastClick and lastDrop endterminal cost vectors  =========}		if useGotohMethod then			begin				for ic := 1 to dropChars do					begin						minCost  :=GetAlignmentMatrixValue(alignmentMatrixP,0,ic);  //4.06 reversed ic and 0						if ic >= (dropChars-endingDropGaps) then  							SetLastPValue(lastClickCosts,ic,terminalgapExtensionCost*clickChars+minCost)						else							SetLastPValue(lastClickCosts,ic,terminalGapStartCost+terminalgapExtensionCost*clickChars+minCost);					end;			end;{$IFC DEBUGALIGNMENT}	writeln(debugfile,'AlignClickOntoDrop 7');{$ENDC}					baseThermoUnits:= 0;{======== fill center with similarity values =========}		for icClick := 1 to clickChars do			begin				clickTSTS :=  AlignmentSequenceState(clickSequence,icClick, true); 				for icDrop := 1 to dropChars do					begin						dropTSTS := AlignmentSequenceState(dropSequence,icDrop, true); 						dist  := DistanceBetweenStateSets(clickTSTS,dropTSTS);						if nucleotides then dist := dist* alignmentCodonCosts[CharCodPos(icDrop)];						SetAlignmentMatrixValue(alignmentMatrixP,icClick,icDrop, dist);					end;{$IFC SPINBEACH}				if (icClick mod 10 = 0) then SpinBeachBall;				if (icClick mod 50 = 0) & CommandPeriod then					begin						userAborted:= true; 						goto 1;					end;{$ELSEC}				if ((icClick mod 25 = 0) & useGotohMethod) | (icClick mod 10 = 0) then  					begin						thermoUnits := baseThermoUnits+icClick;						if showthermo then							UpdateThermo (TD,0, thermoUnits, thermoTotalUnits, true);						if abortedThermo then							begin								userAborted:= true; 								goto 1;							end;					end;{$ENDC}{$IFC DEBUGALIGNMENT}	writeln(debugfile,'AlignClickOntoDrop loop: ', icClick);{$ENDC}			end;{$IFC WRITEALIGNMENTFILES}WriteAlignmentMatrix(alignmentMatrixP,'Similarity Values');   // DEBUG{$ENDC}{$IFC WRITETIMES}AddLastTime(otherTime);{$ENDC}{=======  now go through matrix and calculate scores for pathways  ==============}{this section does it row by row}{within each row it goes from left to right}	thermoUnits := baseThermoUnits + clickChars;	basethermoUnits := thermoUnits;		for icClick := 1 to clickChars do    			begin				minDropDist := -1;				for icDrop := 1 to dropChars do					begin						dist := GetAlignmentMatrixValue(alignmentMatrixP,icClick,icDrop);						if useGotohMethod then							begin								CalcLocalMinPathGotoh (icClick, icDrop, minDropDist, deltaClick, deltaDrop, dist, minCost);								SetAlignmentMatrixValue(alignmentMatrixP,icClick,icDrop,minCost);							end						else							begin								CalcLocalMinPath (false,icClick, icDrop, minDropDist, deltaClick, deltaDrop, dist, minCost);								SetAlignmentMatrixValue(alignmentMatrixP,icClick,icDrop,minCost);							end;						if (minDropDist=-1)|(minDropDist > minCost) then							minDropDist := minCost;					end;{$IFC  SPINBEACH}				if dropChars > 500 then					SpinBeachBall				else					if (icClick mod 5 = 0) then 						SpinBeachBall;				if (icClick mod 25 = 0) & CommandPeriod then					begin						userAborted:= true; 						goto 1;					end;{$ELSEC}			{	if dropChars > 500 then					begin						thermoUnits := thermoUnits+5;						UpdateThermo (TD,0, thermoUnits, thermoTotalUnits,true);						if abortedThermo then							begin								userAborted:= true; 								goto 1;							end;					end				else}				if ((icClick mod 25 = 0) & useGotohMethod) | (icClick mod 5 = 0) then 					begin						thermoUnits := baseThermoUnits + icClick*5;						if showthermo then							UpdateThermo (TD,0, thermoUnits, thermoTotalUnits, true);						if abortedThermo then							begin								userAborted:= true; 								goto 1;							end;					end;{$ENDC}			end;	thermoUnits := baseThermoUnits + clickChars*5;	baseThermoUnits := thermoUnits;{$IFC WRITEALIGNMENTFILES}  WriteAlignmentMatrix(alignmentMatrixP,'Basic Alignment matrix');   // DEBUGif useGotohMethod then	begin		WriteAlignmentMatrix(gapInClickMatrixP,'Gap in click matrix');   // DEBUG		WriteAlignmentMatrix(gapInDropMatrixP,'Gap in drop matrix');   // DEBUG		WritelastValues(lastClickCosts, 'lastClick', dropChars);	end;{$ENDC}		curDropChar := dropChars;		curClickChar := clickChars;		{set the startpoint to -1}			SetAlignmentMatrixValue(alignmentMatrixP,0,0, -1);		MarkAlignmentMatrixValue(alignmentMatrixP,curClickChar,curDropChar);		{now backtrack and set the rest of the endpoints to -1}			repeat			minCost := -GetAlignmentMatrixValue(alignmentMatrixP,curClickChar,curDropChar)-1;			dist := DistanceBetweenStateSets(AlignmentSequenceState(clickSequence,curClickChar, true),AlignmentSequenceState(dropSequence,curDropChar, true));			if useGotohMethod then				BackTrackPathGotoh (curClickChar, curDropChar, deltaClick, deltaDrop,minCost)			else				CalcLocalMinPath (true, curClickChar, curDropChar,  0, deltaClick, deltaDrop, dist, minCost);						if (deltaClick=-1) & (deltaDrop=-1) then				MarkAlignmentMatrixValue(alignmentMatrixP,curClickChar-1,curDropChar-1)			else if deltaClick < 0 then				for ic := curClickChar -1 downTo curClickChar + deltaClick do					MarkAlignmentMatrixValue(alignmentMatrixP,ic,curDropChar)			else if deltaDrop < 0 then				for ic := curDropChar -1 downTo curDropChar + deltaDrop do					MarkAlignmentMatrixValue(alignmentMatrixP,curClickChar,ic);			curClickChar := curClickChar + deltaClick;			curDropChar := curDropChar + deltaDrop;{			SetAlignmentMatrixValue(alignmentMatrixP,curClickChar,curDropChar, pathValue);}{$IFC SPINBEACH}			if (curClickChar mod 100 = 0) then				SpinBeachBall;			if (curClickChar mod 100 = 0) & CommandPeriod then				begin					userAborted:= true; 					goto 1;				end;{$ELSEC}			if ((curClickChar mod 100=0) & useGotohMethod) | (curClickChar mod 50 = 0) then					begin						thermoUnits := baseThermoUnits+(clickChars-curClickChar);  {going down}						if showthermo then							UpdateThermo (TD,0, thermoUnits, thermoTotalUnits,true);						if abortedThermo then							begin								userAborted:= true; 								goto 1;							end;					end;{$ENDC}		until (curClickChar <= 1) & (curDropChar<=1);				thermoUnits := baseThermoUnits+clickChars;		baseThermoUnits := thermoUnits;		{		if curClickChar > 1 then			for ic := 1 to curClickChar do				SetAlignmentMatrixValue(alignmentMatrixP,ic,curDropChar, pathValue);		if curDropChar > 1 then			for ic := 1 to curDropChar do				SetAlignmentMatrixValue(alignmentMatrixP,curClickChar,ic, pathValue);}					{$IFC WRITEALIGNMENTFILES}WriteAlignmentMatrix(alignmentMatrixP,'Matrix with path marked by -1');   {$ENDC}{now the path is marked by -1, let's do it}		curClickChar := 0;		curDropChar := 0;		matrixDropChar := firstAlignmentChar;		charInserted := false;				for ic := firstAlignmentChar to lastAlignmentChar do			settaxonStsLargest(clickTaxon,ic,[MSl,GAl]);				repeat			deltaDrop := 0;			deltaClick := 0;			if (curDropChar<dropChars)& (GetAlignmentMatrixValue(alignmentMatrixP,curClickChar,curDropChar+1)< 0) then					begin   {need to add a gap to the click sequence - don't do anything}						deltaDrop := 1;					end			else if (curClickChar<clickChars)&(GetAlignmentMatrixValue(alignmentMatrixP,curClickChar+1,curDropChar)<0) then					begin   {need to add a gap to the drop sequence - unless one is already there}						deltaClick := 1;						clickTSTS :=  AlignmentSequenceState(clickSequence,curClickChar+1, false); 						InsertNewCharacters(1,matrixDropChar,true);						if badmemory then leave;						lastAlignmentChar := lastAlignmentChar+1;						lastChangeInEditor := lastChangeInsertCharAndCellBlock;						charInserted := true;						if matrixDropChar<= lastAlignmentChar then							settaxonStsLargest(clickTaxon,matrixDropChar,clickTSTS);					end			else if (curClickChar<clickChars) & (curDropChar<dropChars) & (GetAlignmentMatrixValue(alignmentMatrixP,curClickChar+1,curDropChar+1)<0) then					begin  {just assign values}						deltaClick := 1;						deltaDrop := 1;						clickTSTS :=  AlignmentSequenceState(clickSequence,curClickChar+1,false); 						if matrixDropChar<= lastAlignmentChar then							settaxonStsLargest(clickTaxon,matrixDropChar,clickTSTS);					end;			curClickChar := curClickChar + deltaClick;			curDropChar := curDropChar + deltaDrop;			matrixDropChar := matrixDropChar+1;{$IFC SPINBEACH}			SpinBeachBall;			if (matrixDropChar mod 100 = 0) & CommandPeriod then				begin					userAborted:= true; 					goto 1;				end;{$ELSEC}			if showthermo & ((curClickChar mod 5 = 0) | not useGotohMethod) then					begin						thermoUnits := baseThermoUnits+curClickChar*2;						UpdateThermo (TD,0, thermoUnits, thermoTotalUnits,true);  {don't abort at this stage}						{if abortedThermo then							begin								userAborted:= true; 								goto 1;							end;}					end;{$ENDC}		until (matrixDropChar > lastAlignmentChar);				if abortedThermo then			begin				userAborted := true;				goto 1;			end;			{we didn't take care of all of the clickChars - have to drop all that remain}		if curClickChar < clickChars then			begin				curNumChars := lastAlignmentChar;				InsertNewCharacters(clickChars-curClickChar,lastAlignmentChar+1,true);				lastAlignmentChar := lastAlignmentChar + clickChars - curClickChar;				lastChangeInEditor := lastChangeInsertCharAndCellBlock;				charInserted := true;				for ic := curNumChars+1 to lastAlignmentChar do  {4.07:  changed to curNumChars+1}					begin						if curClickChar+ic-curNumChars<=0 then							clickTSTS := [MSl, GAl]						else							clickTSTS :=  AlignmentSequenceState(clickSequence,curClickChar+ic-curNumChars, false); 						settaxonStsLargest(clickTaxon,ic,clickTSTS);											end;			end;				if doUpdates then			if charInserted | ConsensusSequenceVisible | UpdateAsSensitiveToFirstTaxonChange(clickTaxon)  then				InvalidateWindow(editorWindow,true)			else				InvalidateTaxChar(clickTaxon,0, true);1: 		ZapPointer(alignmentMatrixP);		if useGotohMethod then			begin				ZapPointer(gapInClickMatrixP);				ZapPointer(gapInDropMatrixP);				ZapPointer(lastClickCosts);			end;		ZapPointer(clickSequence);		ZapPointer(dropSequence);{$IFC NOT SPINBEACH}	if showthermo then		EndThermo (TD, tempP, false);{$ENDC}				if userAborted | badmemory then			UndoAlignment		else			AlignClickOntoDrop := true;					{set dirtyfile, do returnvalue}		dirtyfile := true;	end;{-----------------------------------------------------------------------------}	procedure StarAlignmentToReference(st,et,sc: integer; var ec: integer; referenceTaxon: integer);	var 	TD1: DialogPtr;		tempP: WindowPtr;		moveTaxon,changedTaxon, it: integer;		success: boolean;		oldnumchars: integer;	begin		oldnumchars := numchars;		UnselectAll;		if badcellEntry then			Exit(StarAlignmentToReference);		StoreStateFrequencies(st,et);		DisableWindowUpdates(editorWindow);		HideControl(editorHScroll);		HideControl(editorVScroll);		DisableWindowUpdates(infoWindow[charinfo]);		StartThermo(TD1, tempP, 0, et-st, concat('Align to ',TaxonName(referenceTaxon)), '', false);		it := 0;		for moveTaxon := st to et do			if moveTaxon<> referenceTaxon then				begin					UpdateThermo (TD1,0, it, et-st,false); 					success := AlignClickOntoDrop(moveTaxon,referenceTaxon,sc,ec,false, {not useGotohIfPossible}true,true);					if not success | abortedThermo then						begin							UndoAlignment;							leave;						end;					it := it+1				end;		EndThermo (TD1, tempP, false);				if success then			begin				if not CheckStateFrequencies(st,et,changedTaxon) then					begin						if not CWarning(concat('Sequence alignment tool has altered state frequencies of taxon ',StringFromNum(changedTaxon),'!  Please report this to clade@arizona.edu!!'), 'Proceed','Cancel') then						  	begin						  		UndoAlignment;						  		success := false;						  	end;					end;				{if oldnumchars<>numchars then}									{else					begin						InvalidateCellBlock(st,et,sc,ec,true);						CheckRedrawFullCharactersInEditor (st, et,sc,ec,true);					end;}			end;		ShowControl(editorHScroll);		ShowControl(editorVScroll);	end;{-----------------------------------------------------------------------------}	procedure AlignSelectedBlock(clickTaxon: integer);	var 	st,et,sc,ec: integer;	begin{$IFC DEBUGALIGNMENT}	StartDebugFile;{$ENDC}		CalcSelectedTaxaCharacters(st, et, sc, ec,true);		if  (st<>et) & (sc<>ec) & StoreSelectedCellBlockForUndo(false,false,true) then 			StarAlignmentToReference(st,et,sc,ec,clickTaxon);{$IFC DEBUGALIGNMENT}	EndDebugFile;{$ENDC}	end;{-----------------------------------------------------------------------------}	procedure StarAlignment(referenceTaxon: integer; justSelected:boolean);	begin		if numtaxa>1 then			if justSelected then				AlignSelectedBlock(referenceTaxon)			else				if  StoreCellBlockForUndo(1, numtaxa, 1, numchars, true,false,false) then					StarAlignmentToReference(1,numtaxa,1,numchars,referenceTaxon);	end;{----------------------------------------------------------------------------}{-----------------------------------------------------------------------------}	procedure AutoAlignSequences(clickTaxon: integer);	var wh, drop: point;		dropTaxon: integer;		db, success: boolean;		st,et,sc,ec,changedTaxon: integer;		star: boolean;	begin{$IFC DEBUGALIGNMENT}	StartDebugFile;otherTime:= 0;clickScanTime:= 0;dropScanTime:= 0;clickCalc1Time := 0;oldDebugTime := TickCount;{$ENDC}							if not editorTransposed then			repeat				AutoVertScroll(false, true, false);			until not button		else			repeat				AutoHorScroll(false, true, false);			until not button;		GetMouse(wh);		drop := FindCell(wh,true,false);		if not editorTransposed then 			dropTaxon := drop.v 		else 			dropTaxon := drop.h;				star := false;		if editorSelected & WholeTaxonSel then			begin				CalcSelectedTaxaCharacters(st, et, sc, ec,true);				if (clickTaxon>=st) & (clickTaxon<=et) & (st<>et) then					star := true;			end;	{$IFC DEBUGALIGNMENT}	writeln(debugfile,'AutoAlign 1');{$ENDC}		if (dropTaxon= clickTaxon) | (dropTaxon<1) | (dropTaxon> numtaxa) then			Exit(AutoAlignSequences);		if star then 			StarAlignment(dropTaxon,true)		else			begin				DisableWindowUpdates(editorWindow);				DisableWindowUpdates(infoWindow[charinfo]);				if not StoreCellBlockForUndo(clickTaxon, clickTaxon, 1, numChars, true,false,false) then					Exit(AutoAlignSequences);				UnselectAll;				if badcellEntry then					begin						SetLastChangeInEditor(lastChangeCantUndo);						Exit(AutoAlignSequences);					end;									StoreStateFrequencies(clickTaxon,clickTaxon);					{$IFC DEBUGALIGNMENT}	writeln(debugfile,'AutoAlign 2');{$ENDC}				sc := 1;				ec := numchars;				if clickTaxon<> dropTaxon then					success := AlignClickOntoDrop(clickTaxon,dropTaxon, sc,ec,true, true, false);				InvalidateAllWindowsMarkedUnupdatable;				if success then					begin						if not CheckStateFrequencies(clickTaxon,clickTaxon,changedTaxon) then							begin								if not CWarning('Sequence alignment tool has altered state frequencies!  Please report this to clade@arizona.edu!!', 'Proceed','Cancel') then								  	begin								  		UndoAlignment;								  		success := false;								  	end;							end;					end;				if success then					CheckRedrawFullCharactersInEditor(clickTaxon,clickTaxon,1,numchars,true);							{$IFC WRITETIMES}		AddLastTime(otherTime);			writeln(debugfile, ' ');			write(debugfile, 'other time: ');			writeln(debugfile, otherTime);			writeln(debugfile, ' ');			write(debugfile, 'click scan time: ');			writeln(debugfile, clickScanTime);			writeln(debugfile, ' ');			write(debugfile, 'calc1 time: ');			writeln(debugfile, clickCalc1Time);			writeln(debugfile, ' ');			write(debugfile, 'drop scan time: ');			writeln(debugfile, dropScanTime);		{$ENDC}		{$IFC DEBUGALIGNMENT}			EndDebugFile;		{$ENDC}		end;	end;{-----------------------------------------------------------------------------}	function SetUpCompactGapCharsBlockP(compactCellPtr: CellBlockPtr; st,et,sc,ec: integer): boolean;	var 	BR, TL: point;	begin		if editorTransposed then			begin				SetPt(BR,et, ec);				SetPt(TL,st, sc);			end		else			begin 				SetPt(BR,ec, et);				SetPt(TL,sc, st);			end;		SetUpCompactGapCharsBlockP := StoreDataIntoCellBlock(compactCellPtr,BR,TL, true, true, true,false, false,true);	end;{-----------------------------------------------------------------------------}	function PairwiseDistance(it1, it2, sc, ec: integer): longint;		var			ic, ic2: integer;			pairCost, subCost, gapCost: longint;			tsts, tsts2: largestsetchars;			db: boolean;			it1IsGap, it2IsGap: boolean;			first1NonGap, last1NonGap, first2NonGap, last2NonGap: integer;			lowBoundary, highBoundary, largestGapInOther, hb, lb, opening: integer;			compactCellPtr: CellBlockPtr;	begin		CreateCellBlock(compactCellPtr);		pairCost := 0;		if SetUpCompactGapCharsBlockP(compactCellPtr,it1,it2,sc,ec) then			begin								subCost := 0;				gapCost := 0;				for ic := sc to ec do   // calculate the substitution cost between these two sequences					begin						tsts := gettaxonstsLargest(it1, ic);						tsts2 := gettaxonstsLargest(it2, ic);						it1IsGap := IsGapLike(it1,ic, editorToolsTreatMissingAsGaps);						it2IsGap := IsGapLike(it2,ic,editorToolsTreatMissingAsGaps);						if (not it1IsGap and not it2IsGap) then							subCost := subCost + DistanceBetweenStateSets(tsts, tsts2);					end;				ZeroUnused1;				first1NonGap := FirstNonGapInBlock(it1, sc,ec);				first2NonGap := FirstNonGapInBlock(it2,sc,ec);				last1NonGap := LastNonGapInBlock(it1, sc,ec);				last2NonGap := LastNonGapInBlock(it2, sc,ec);								// now let's get the gap cost for the first sequence				ic := first1NonGap;				while (ic<=last1NonGap) do					begin						it1IsGap := IsGapLike(it1,ic,editorToolsTreatMissingAsGaps);						if (it1IsGap) then							begin								GapBlockBoundaries(it1,ic, first1NonGap, last1NonGap, lowBoundary, highBoundary);								// ok, so we now know that there is a gap from lowBoundary to highBoundary								if highBoundary > 0 then									begin										largestGapInOther := 0;										lb := 0;										hb := 0;										opening := 1;										for ic2 := lowBoundary to highBoundary do											if IsGapLike(it2,ic2,editorToolsTreatMissingAsGaps) then												begin													opening := 0;  // the other one is open here too; don't count opening cost												 	GapBlockBoundaries(it2,ic2, lowBoundary, highBoundary, lb, hb);												 	if (hb-lb)>largestGapInOther then												 		largestGapInOther := hb-lb;												end;										gapCost := gapCost + gapStartCost*opening + gapExtensionCost*(highBoundary-lowBoundary-largestGapInOther);										ic := highBoundary+1;									end								else ic := ic+1;							end						else							ic := ic+1;					end;		//maxTerminalGapCost := terminalGapStartCost + (icClick)* terminalGapExtensionCost;				// now let's get the gap cost for the second sequence				ic := first2NonGap;				while (ic<=last2NonGap) do					begin						it2IsGap := IsGapLike(it2,ic,editorToolsTreatMissingAsGaps);						if (it2IsGap) then							begin								GapBlockBoundaries(it2,ic, first2NonGap, last2NonGap, lowBoundary, highBoundary);								// ok, so we now know that there is a gap from lowBoundary to highBoundary								opening := 1;								//otherLowBoundary := 0;								largestGapInOther := 0;								lb := 0;								hb := 0;								for ic2 := lowBoundary to highBoundary do									if IsGapLike(it1,ic2,editorToolsTreatMissingAsGaps) then										begin										 	opening := 0;										 	GapBlockBoundaries(it1,ic2, lowBoundary, highBoundary, lb, hb);										 	if (hb-lb)>largestGapInOther then										 		largestGapInOther := hb-lb;										end;								gapCost := gapCost + gapStartCost*opening + gapExtensionCost*(highBoundary-lowBoundary-largestGapInOther);								if highBoundary = 0 then									ic := ic + 1								else									ic := highBoundary+1;							end						else							ic := ic+1;					end;				pairCost := subCost + gapCost;		end;		if compactCellPtr<>nil then			begin				EmptyCellBlock(compactCellPtr);			end;		PairwiseDistance := pairCost;	end;{-----------------------------------------------------------------------------}	procedure CalcSumOfPairwise;		var			it,it2, ic, st, et, sc, ec: integer;			cost, pairCost: longint;	begin		cost := 0;		CalcSelectedTaxaCharacters(st, et, sc, ec, true);		for it := st to et do			for it2 := it+1 to et do				begin					pairCost := 0;					cost := cost + PairWiseDistance(it, it2, sc, ec);				end;		InstantInfo(StringFromNum(cost));		multiAlignmentCost := cost;	end;{-----------------------------------------------------------------------------}end.