unit MouseInTree;{еееееееееееееееееееееее}interface	uses		QuickDraw, Printing,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, 		Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, 		Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, 		TaxonCHUtil, TypeUtil, Settings, RandomTree, LinkUtil, CharUtil, Prohibitions,		 Continuous, TraceAllChangesCalc, N7On, FootNote, IncExcTaxa, Equivocal, MenuUtil, TreeUtil, 		 Legends, ScrollTree, BranchListWindow, InfoWindows, Count, Coloring, 		 TraceControl, TreeDrawer, ClickInInfoWindow, Shading, TypeDLOG, 		 TreeGet, ScanPick, ProbReconstruct, TraceAllChangesOptions;	procedure PolyOptions;	procedure CharLegendGoAway;	procedure SwitchLockLegends;	procedure ScrollLegUpDown (whichControl: ControlRef; theCode: INTEGER);	procedure ScrollCommUpDown (whichControl: ControlRef; theCode: INTEGER);	procedure MouseInCommWindow (Event: EventRecord);	procedure LegendScroll (whichwindow: WindowPtr; whichcontrol: ControlRef; wh: point);	procedure MouseInTreeLeg;	procedure MouseInBranchList;	procedure MouseInTWMessage;	procedure MouseInChLeg;	procedure MouseInTree;{еееееееееееееееееееееее}implementation {е$S MouseInTree}{-----------------------------------------------------------------------------}	procedure PolyInfo (theDialog: DialogPtr; itemNo: Integer);	begin		FrameButton(theDialog, 1);		DrawResourceTEXT(theDialog, 6, 23107);		DrawResourceTEXT(theDialog, 8, 24878);	end;{-----------------------------------------------------------------------------}	procedure PolyOptions;{polytomy options}		const			realpoly = 4;			uncertpoly = 3;		var			theDialog: DialogPtr;			defitem: integer;			oldpoly: boolean;			tempP, tport: WindowPtr;			tempH: Handle;			box: rect;			localItemHit: integer;UserItemUProcP: UniversalProcPtr;	begin		oldpoly := polyreal;		StartDLOG(323, theDialog, tempP);		box := GetDLOGItemBox(theDialog, 6);UserItemUProcP := MyNewUserItemUPP(@polyinfo);  tempH := Handle(UserItemUProcP);		SetDialogItem(theDialog, 6, UserItem, tempH, box);		ItemCheckMark(theDialog, realpoly, polyreal);		ItemCheckMark(theDialog, uncertpoly, not polyreal);		myShowDialog(theDialog);		repeat			ModalDialog(nil, localItemHit);			if localItemHit = uncertpoly then				polyreal := false			else if localItemHit = realpoly then				polyreal := true			else if localItemHit = 7 then				SetDialogValuesAsDefaults(theDialog, polytomyid, 0, 0);			ItemCheckMark(theDialog, realpoly, polyreal);			ItemCheckMark(theDialog, uncertpoly, not polyreal);		until localItemHit in [1, 2];		if localItemHit = 2 then			polyreal := oldpoly;MyDisposeUserItemUPP(UserItemUProcP);		EndDLOG(theDialog, tempP);		if (oldpoly <> polyreal) then			begin{FROZEN 3.0}				if nullson then					RearrangeTreeGoList; {changed type of polytomies; redo calculations concerning tree}				if CWTrees[CWChart] <> CWRandomTrees then					golist := golist + fullgochartmult; {redo all multi trees charts in case polytomies were involved }			end;	end;{----------------------------------------------------------------------------}{	procedure ScrollComm;		var			oldOrigin, dv: integer;	begin		oldOrigin := commOrigin;		commOrigin := GetControlValueLong(commScroll);		dv := (oldOrigin - commOrigin) * commentsTE[curcom]^^.lineHeight;		TEPinScroll(0, dv, commentsTE[curcom]);	end;}{----------------------------------------------------------------------------}{	procedure ScrollCommUpDown (whichControl: ControlRef; theCode: INTEGER);		var			ds: str255;			box: rect;	begin		if scrollup then			begin				if theCode = kControlUpButtonPart then					SetControlValueLong(whichControl, GetControlValueLong(whichControl) - 1)			end		else if theCode = kControlDownButtonPart then			SetControlValueLong(whichControl, GetControlValueLong(whichControl) + 1);		ScrollComm;	end;}{----------------------------------------------------------------------------}{	procedure CommWindowScroll (whichcontrol: ControlRef; wh: point);		var			MyControl, t, oldvalue, newvalue: integer;			mypt: point;	begin		oldvalue := GetControlValueLong(whichControl);		MyControl := FindControl(wh, commWindow, whichControl);		SetCommTextBox;		case MyControl of			kControlUpButtonPart: 				begin					scrollup := true;					t := myTrackControl(whichControl, wh, ScrollTextUpDownUPP);				end;			kControlDownButtonPart: 				begin					scrollup := false;					t := myTrackControl(whichControl, wh, ScrollTextUpDownUPP);				end;			kControlPageUpPart: 				repeat					GetMouse(myPt);					if TestControl(whichControl, myPt) = mycontrol then						SetControlValueLong(whichControl, GetControlValueLong(whichControl) - commWindowLines + 1);					ScrollComm;				until not StillDown;			kControlPageDownPart: 				repeat					GetMouse(myPt);					if TestControl(whichControl, myPt) = mycontrol then						SetControlValueLong(whichControl, GetControlValueLong(whichControl) + commWindowLines - 1);					ScrollComm;				until not StillDown;			kControlIndicatorPart: 				begin					t := myTrackControl(whichControl, wh, nil);					ScrollComm;				end;			otherwise				;		end;	end;}{-----------------------------------------------------------------------------}{	procedure MouseInCommWindow (Event: EventRecord);		var			wh: point;			tport: WindowPtr;			box: rect;	begin		wh := Event.where;		genericGetPort(tport);		genericSetPort(commwindow);		GlobalToLocal(wh);		box := myGetControlRect(commScroll);		if ptinrect(wh, box) then			CommWindowScroll(commScroll, wh)		else			begin				TEClick(wh, ShiftEvent(Event), commentsTE[curcom]);				SizeCommWindowText(false, false, true);				FixEditMenu;			end;		genericSetPort(tport);	end;}{----------------------------------------------------------------------------}	procedure ScrollLegUpDown (whichControl: ControlRef; theCode: INTEGER);		var			ds: str255;			box: rect;	begin		if scrollup then			begin				if theCode = kControlUpButtonPart then					begin						if whichcontrol = chlegscroll then							SetControlValueLong(whichcontrol, PrevIncludedChar(GetControlValueLong(chlegscroll) - 1))						else							SetControlValueLong(whichControl, GetControlValueLong(whichControl) - 1)					end;			end		else if theCode = kControlDownButtonPart then			begin				if whichcontrol = chlegscroll then					SetControlValueLong(whichcontrol, NextIncludedChar(GetControlValueLong(chlegscroll) + 1))				else					SetControlValueLong(whichControl, GetControlValueLong(whichControl) + 1);			end;		delay(8, ticks);		DrawLegNumber(whichControl);	end;{----------------------------------------------------------------------------}	procedure LegendScroll (whichwindow: WindowPtr; whichcontrol: ControlRef; wh: point);		var			MyControl, t, oldvalue, newvalue: integer;			mypt: point;			wasfix: boolean;			tport: windowptr;	begin		genericGetPort(tport);		oldvalue := GetControlValueLong(whichControl);		MyControl := FindControl(wh, whichWindow, whichControl);		if whichControl=nil then Exit(LegendScroll);		genericSetPort(whichwindow);		case MyControl of			kControlUpButtonPart: 				begin					scrollup := true;					t := myTrackControl(whichControl, wh, ScrollLegUpDownUPP);				end;			kControlDownButtonPart: 				begin					scrollup := false;					t := myTrackControl(whichControl, wh, ScrollLegUpDownUPP);				end;			kControlPageUpPart: 				repeat					GetMouse(myPt);					if TestControl(whichControl, myPt) = mycontrol then						begin							SetControlValueLong(whichControl, GetControlValueLong(whichControl) - 10);							delay(8, ticks);						end;					DrawLegNumber(whichControl);				until not StillDown;			kControlPageDownPart: 				repeat					GetMouse(myPt);					if TestControl(whichControl, myPt) = mycontrol then						begin							SetControlValueLong(whichControl, GetControlValueLong(whichControl) + 10);							delay(8, ticks);						end;					DrawLegNumber(whichControl);				until not StillDown;			kControlIndicatorPart: 				begin{$IFC TRACKPAGENUMBERS}					TrackFeedbackThumb(whichControl,wh, whichWindow);{$ELSEC}												t := myTrackControl(whichControl, wh, nil);{$ENDC}				end;			otherwise				;		end;		newvalue := GetControlValueLong(whichControl);		if oldvalue <> newvalue then			if whichcontrol = tlegscroll then				begin					setcursor(clockCursor);					{oldtreelinknumber := linknumber[treechain];}					if not GoToTree(newvalue + StartUserLink(treechain) - 1) then						begin							SetControlValueLong(whichControl, oldValue);							DrawLegNumber(whichControl);						end;				end			else if whichcontrol = chlegscroll then				begin					if not CharIncluded(newvalue) then						begin							if newvalue < oldvalue then								begin									newValue := PrevIncludedChar(newValue);									if newvalue > oldvalue then										begin											newvalue := oldvalue;											Beep;										end;								end							else								begin									newValue := NextIncludedChar(newValue);									if newvalue < oldvalue then										begin											newvalue := oldvalue;											Beep;										end;								end;							SetControlValueLong(chlegscroll, newvalue);						end;					TurnOnTrace(oldvalue, newvalue);				end;		genericSetPort(tport);	end;{-------------------------------------------------------------------------}	procedure SwitchLockLegends;	var tport: windowPtr;	begin		genericGetPort(tport);		locklegends := not locklegends;		myCheckMenuItem(TWDisplayMHdl, LockLegendsItem, locklegends);		if locklegends then			begin				SetLockLegPts(tlegwindow, -1);				MoveWindow(tlegwindow, tlegpt.h, tlegpt.v, false);				SetLockLegPts(chlegwindow, -1);				MoveWindow(chlegwindow, chlegpt.h, chlegpt.v, false);			end;		InvalidateWindow(chlegwindow, true);		InvalidateWindow(tlegwindow, true);		genericSetPort(tport);	end;{-------------------------------------------------------------------------}	procedure MouseInTreeLeg;		var			box, dragarea: rect;			namewidth: integer;			wh: point;			oldpolyreal: boolean;			showPopupIndex: boolean;		function BottomofRect (tlegNum: integer): integer;		begin			bottomofrect := treenameB.bottom + tlegStats[tlegNum].linesabove * tlegline + tlegline * tlegStats[tlegNum].lines;		end;	begin		genericSetPort(tlegwindow);		wh := Event.where;		GlobalToLocal(wh);		box := myGetControlRect(tlegscroll);		if ptinrect(wh, box) and not equivcycle then			begin				LegendScroll(tlegwindow, tlegScroll, wh);			end		else if wh.v >= box.top then			begin				PopUpStringMenu(wh, StringFromNum(GetControlValueLong(tlegScroll)));			end		else if wh.v < treeLegendTitleWidth then			begin				if dblclick and not equivcycle then					OpenOrSelectInfoWindow(treeinfo)				else					begin						HLock(Handle(treename));						if dirtytree then							box := LegendBox(treenameB, ' ')						else							box := LegendBox(treenameB, treename^^);						if box.right > treenameB.right - 5 then							box.right := treenameB.right - 5;						if box.left < 5 then							box.left := 5;						HUnLock(Handle(treename));						if (wh.h > box.left) & (wh.h < box.right) then							if treefile then								PopUpStringMenu(wh, concat('Using external treefile: ', treefilename^^))							else								PopUpStringMenu(wh, 'Using data file for tree storage')						else if not locklegends then							begin								DragArea := ScreenBoundsRect;								InsetREct(DragArea, 4, 4);								DragArea.top := DragArea.top + 12;								DragWindow(tlegwindow, event.where, @DragArea);								SelectWindow(tlegwindow);							end						else if wh.h > WindowPortRect(tlegwindow).right-8 then							SwitchLockLegends;					end;			end		else if count | showminsteps | showmaxsteps then			begin				if count & (wh.v < BottomOfRect(tlegTreeLength)) then					begin						if tlegStats[tlegTreeLength].show then							begin{NOTE: the three treelength messages cannot coexist since polytomies, user-defined chars, and fixed ancestors}{cannot exist together in any combination}								if nullson and not polyreal then									PopUpStringMenu(wh, '+ soft polytomies underestimate')								else if FixancPolymorph then									PopUpStringMenu(wh, '* taxon fixed as anc. is polymorphic')								else									begin										oldpolyreal := polyreal;										polyreal := true;										if TreelengthPlus then											begin												PopUpStringMenu(wh, '+ polymorph>3 states in user-def char.');												wh.v := wh.v + 20;											end;										polyreal := oldpolyreal;									end;							end;					end				else if tlegStats[tlegChg].show & (wh.v < BottomOfRect(TlegChg)) & (wh.v > (treenameB.bottom + tlegStats[TlegChg].linesabove * tlegline)) then					begin						if TerminalPolymorphisms then							PopUpStringMenu(wh, '* excludes changes within polymorphic terminal taxa');					end				else if tlegStats[tlegCI].show | tlegStats[tlegMin].show | tlegStats[tlegRI].show | tlegStats[tlegRC].show | tlegStats[tlegMax].show then					if MinMaxLenLegal(false, minlength) then						begin							showPopupIndex := false;							if Anytype([usedef, dollo, fisher, irreversible]) then								begin									if tlegStats[tlegCI].show & (wh.v < Bottomofrect(tlegCI)) then										begin											if Anytype([usedef, dollo, fisher]) then												showPopupIndex := true;										end									else if tlegStats[tlegRI].show & (wh.v < Bottomofrect(tlegRI)) then										showPopupIndex := true									else if tlegStats[tlegRC].show & (wh.v < Bottomofrect(tlegRC)) then										showPopupIndex := true									else if tlegStats[tlegMin].show & (wh.v < Bottomofrect(tlegMin)) then										begin											if Anytype([usedef, dollo, fisher]) then												showPopupIndex := true;										end									else if tlegStats[tlegMax].show & (wh.v < Bottomofrect(tlegMax)) then										showPopupIndex := true;								end;							if showPopupIndex then								PopUpStringMenu(wh, '* excludes chars. of some types');						end;			end;		genericSetPort(treewindow);	end;{-----------------------------------------------------------------------------}	procedure MouseInBranchList;		var			ds: str255;			datalen, colon, period, punct, oldi: integer;			tport: WindowPtr;			cell: point;	begin		genericGetPort(tport);		genericSetPort(branchlistwindow);		GlobalToLocal(Event.where);{we don't want the ListManager to handle clicks in the window if the branchlist state sum option is on,}{but we do want it to handle clicks in the scrollbar. Thus the following 3 lines:}		if not ((traceshown = traceAllStates) and (BLSWhat = BLSstatesum)) or (event.where.h > WindowPortRect(branchListWindow).right - scrollwidth) then			if LClick(Event.where, event.modifiers, BranchList) then				if not ((traceshown = traceAllStates) and (BLSWhat = BLSstatesum)) then					begin						ds := '          ';						datalen := 10;						cell := LLastClick(BranchList);						if cell.v >= firstcharLine then  {ignores if clicked in one of the first comment lines}							begin								LGetCell(Pointer(ord4(@ds) + 1), datalen, cell, BranchList);								colon := pos(':', ds);								period := pos('.', ds);								if (period = 0) then									punct := colon								else									punct := period;								delete(ds, punct, length(ds) - punct + 1);								oldi := i;								i := TokenToInteger(ds, false);								if (i < 1) or (i > numchars) or not CharIncluded(i) then									begin										Beep;										i := oldi;									end								else									TurnOnTrace(oldi, i);							end;					end;		LocalToGlobal(Event.where);		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	procedure MouseInTWMessage;		var			wh, zeroPoint: point;			dL: longint;			ds: str255;			tport: windowptr;			theFile: TEXT;	begin		genericGetPort(tport);		genericSetPort(twmesswindow);		SetPt(zeroPoint,0,0);		wh := Event.where;		GlobalToLocal(wh);		if not equivcycle then			if PtInRect(wh, TWmessageB) then				ShowMemory			else if (wh.h > TWmessIcon[TWmessFix].left) and (wh.h < TWmessIcon[TWmessFix].right) then				begin					if OptionEvent(Event) and dblclick then						OffFix(true)					else						begin							PopUpStringMenu(zeroPoint,'States fixed');							WriteTWMessageB;							FlashFix;						end;				end			else if (wh.h > TWmessIcon[TWmessTaxExc].left) and (wh.h < TWmessIcon[TWmessTaxExc].right) then				begin					PopUpStringMenu(zeroPoint, 'Some Taxa Excluded');					if dblclick then						if OptionEvent(Event) then   {include all taxa}							IncAllTaxa						else							OpenOrSelectInfoWindow(taxinfo);				end			else if (wh.h > TWmessIcon[TWmessCharExc].left) and (wh.h < TWmessIcon[TWmessCharExc].right) then				begin					PopUpStringMenu(zeroPoint, 'Some Chars. Excluded');					if dblclick then						if OptionEvent(Event) then							begin								linknumber[exSetChain] := 0;								ChooseLink(exSetChain, false);								InvalidateWindow(twmesswindow, true);							end						else							OpenOrSelectInfoWindow(exSetInfo);				end			else if (wh.h > TWmessIcon[TWmessEquiv].left) and (wh.h < TWmessIcon[TWmessEquiv].right) then				begin					if resolveOption=acctran then						PopUpStringMenu(zeroPoint, 'ACCTRAN in use')					else if resolveOption=deltran then						PopUpStringMenu(zeroPoint, 'DELTRAN in use');					if dblclick then						if OptionEvent(Event) then							begin								resolveoption := allpossible;{FROZEN 3.0}								changeAcctranDeltranGoList;								InvalidateWindow(twmesswindow, false);								FixTreeShadingMenus;							end						else							AcctranDeltranDLOG;				end			else if (wh.h > TWmessIcon[TWmessPolyT].left) and (wh.h < TWmessIcon[TWmessPolyT].right) then				begin					if not OptionEvent(event) then						if polyreal then							PopUpStringMenu(zeroPoint, 'Polytomies hard')						else							PopUpStringMenu(zeroPoint, 'Polytomies soft');					if dblclick then						begin							if OptionEvent(event) then								begin									if CWarning('Do you want to randomly resolve the polytomies?', 'Resolve', 'Cancel') then										begin											StoreOldTreeForUndo;											undotype := justother;											fullundo := true;											noundo := false;											justundid := false;											ShrinkTree;											DrawRloc := DrawR^.loc;											PrepareToRandomPoly(R);											RandomizeAllPolytomies(R);											SetNullson;											noundo := false;											RearrangeTreeGoList;											godraw := true;											InvalidateWindow(tlegwindow, false);											dirtyfile := true;											SetDirtyTree;											FixTreeShadingMenus;										end;								end							else								PolyOptions;						end;				end			else if (wh.h > TWmessIcon[TWmessExpd].left) and (wh.h < TWmessIcon[TWmessExpd].right) then				begin					PopUpStringMenu(zeroPoint, 'Only one clade shown');					if dblclick and OptionEvent(Event) and expd then						begin							ShrinkTree;							godraw := true;							FixTreeShadingMenus;						end;				end			else if (wh.h > TWmessIcon[TWmessRoot].left) and (wh.h < TWmessIcon[TWmessRoot].right) then				PopUpStringMenu(zeroPoint, 'Some chars. directed');		genericSetPort(tport);	end;{-------------------------------------------------------------------------}{$IFC FALSE}{Wayne: save this somewhere}	procedure ContrastChart;  {ввввввввв}		var			theDialog: DialogPtr;			tempP, tport: WindowPtr;			box: rect;			H: Handle;			localItemHit, temp: integer;			cont1, cont2: integer;			notfirst, notsecond: boolean;			foldindep, absvalue: boolean;{.....}		procedure DrawContrastChart (theDialog: DialogPtr);			var				ds: str255;				inode, tempicont: integer;				min1, max1, min2, max2: single;			procedure MoveFinalCtoD (N: Nptr);			begin				if NodeIsInternal(N) then					begin						MoveFinalCtoD(N^.lf);						MoveFinalCtoD(N^.rt);						N^.finalD := N^.finalC;					end;			end;			procedure findminmaxcont (N: NPtr);			begin				if NodeIsInternal(N) then					begin						if (foldindep or absvalue) & (N^.finalC < 0) then							begin								N^.finalC := -N^.finalC;								N^.finalD := -N^.finalD;							end;						if absvalue & (N^.finalD < 0) then							N^.finalD := -N^.finalD;						if N^.finalC < min1 then							min1 := N^.finalC;						if N^.finalC > max1 then							max1 := N^.finalC;						if N^.finalD < min2 then							min2 := N^.finalD;						if N^.finalD > max2 then							max2 := N^.finalD;						findminmaxcont(N^.lf);						findminmaxcont(N^.rt);					end;			end;			function LocateC1 (c1: single): integer;			begin				if max1 = min1 then					LocateC1 := 125				else					LocateC1 := RoundValue(10 + 250 * ((c1 - min1) / (max1 - min1)));			end;			function LocateC2 (c2: single): integer;			begin				if max2 = min2 then					LocateC2 := 125				else					LocateC2 := RoundValue(260 - 250 * ((c2 - min2) / (max2 - min2)));			end;			procedure DrawNodeSpot (N: Nptr);			begin				if NodeIsInternal(N) then					begin						DrawNodeSpot(N^.lf);						DrawNodeSpot(N^.rt);						MoveTo(LocateC1(N^.finalC), LocateC2(N^.finalD));						TextFont(0);						Textsize(12);						Drawstring('е');						TextFont(maccladesmall);						Textsize(9);						DrawString(StringFromNum(NumberOfNode(N)));						TextFont(0);						Textsize(12);					end;			end;		begin			setrect(box, 0, 0, 350, 375);			EraseRect(box);			tempicont := icont;			icont := cont2;			ReconstructContinuous;			MoveFinalCtoD(R);			icont := cont1;			ReconstructContinuous;			min1 := 100000;			max1 := -100000;			min2 := 100000;			max2 := -100000;			findminmaxcont(R);			if min2 > 0 then				min2 := 0;			if max2 < 0 then				max2 := 0;			if min1 > 0 then				min1 := 0;			if max1 < 0 then				max1 := 0;			moveTo(LocateC1(0), LocateC2(min2));  {Drawing axes}			LineTo(LocateC1(0), LocateC2(max2));			moveTo(LocateC1(min1), LocateC2(0));			LineTo(LocateC1(max1), LocateC2(0));			inode := 0;			DrawnodeSpot(R);			icont := tempicont;			ReconstructContinuous;		end;{.....}		procedure CheckConts;			var				ir: integer;		begin			for ir := 1 to 4 do				begin					if Continuouscomplete(ir, true) then						if notfirst then							begin								notfirst := false;								cont1 := ir							end						else if notsecond then							begin								notsecond := false;								cont2 := ir;							end;					ItemCheckMark(theDialog, 2 + ir, (cont1 = ir));					EnableDisableDLOGItem(theDialog, 2 + ir, Continuouscomplete(ir, true), false);					ItemCheckMark(theDialog, 6 + ir, (cont2 = ir));					EnableDisableDLOGItem(theDialog, 6 + ir, Continuouscomplete(ir, true), false);				end;			ItemCheckMark(theDialog, 13, foldindep);			ItemCheckMark(theDialog, 14, absvalue);		end;{.....}	begin		StartDLOG(570, theDialog, tempP);		notfirst := true;		notsecond := true;		foldindep := false;		absvalue := false;		cont1 := 0;		cont2 := 0;		CheckConts;		myShowDialog(theDialog);		FrameButton(theDialog, 1);		if cont2 > 0 then			DrawContrastChart(theDialog);		repeat			ModalDialog(nil, localItemHit);			case localItemHit of				3, 4, 5, 6: 					begin						temp := localitemhit - 2;						if temp = cont2 then							cont2 := cont1;						cont1 := temp;					end;				7, 8, 9, 10: 					begin						temp := localitemhit - 6;						if temp = cont1 then							cont1 := cont2;						cont2 := temp;					end;				13: 					foldindep := not foldindep;				14: 					absvalue := not absvalue;				otherwise					;			end;			CheckConts;			if (localitemhit <> 1) and (cont2 > 0) then				DrawContrastChart(theDialog);		until localItemHit = 1;		EndDLOG(theDialog, tempP);	end;{$ENDC}{-----------------------------------------------------------------------------}	procedure CharLegendGoAway;	var box: rect;	begin		if EquivCycle then			StopEquivCycle;		genericSetPort(chlegwindow);		if legendTitleIsWindowTitle then			begin				SetRect(box, 2, 3, 9, 10);  //goaway box				InsetRect(box, 1, 1);				InvertRect(box);				Delay(5, ticks);			end;		if (traceshown = traceDiscrete) then			begin				TurnoffTrace(i, true, true, true);				CloseTraceMenus;			end		else if (traceshown = traceAllChanges) then			TurnOffShowChg(true)		else if (traceshown = traceContinuous) then			TurnOffContinuous(true);{$IFC PROBRECONSTRUCT}		else if (traceshown = traceProbability) then			TurnOffProbReconstruct;{$ENDC}	end;{-----------------------------------------------------------------------------}	procedure MouseInChLeg;		var			ic, nic: integer;			oldi, limit: integer;			tport: windowptr;			box, dragarea: rect;			ds: str255;			tickClass: integer;	begin		wh := Event.where;		genericGetPort(tport);		genericSetPort(chlegwindow);		GlobalToLocal(wh);		box := myGetControlRect(chlegscroll);		if ptinrect(wh, box) and (traceshown = traceDiscrete) and not equivcycle then			LegendScroll(chlegwindow, chlegScroll, wh)		else if (wh.v >= box.top) and (traceshown = traceDiscrete) then			begin				genericSetPort(chlegwindow);				PopUpStringMenu(wh, StringFromNum(GetControlValueLong(chlegScroll)));				genericSetPort(tport);			end		else if wh.v < charLegendTitleWidth then			begin				SetRect(box, 2, 3, 9, 10);				if PtInRect(wh, box) & legendTitleIsWindowTitle then					CharLegendGoAway				else if dblclick and not equivcycle then					begin						if (traceshown = traceDiscrete) then							OpenOrSelectInfoWindow(charinfo)						else if (traceshown = traceContinuous) then							begin{$IFC FALSE}								if Optiondown and (continuousmode in [sqFelsContrast, sqFelsContrastSTD]) then {ввв}									ContrastChart								else {$ENDC}									ContinuousOptions							end{$IFC PROBRECONSTRUCT}						else if (traceshown = traceProbability) then							DoProbReconstruct(true){$ENDC}						else if (traceshown = traceAllChanges) then							SummaryModeOptions(false);					end				else if (currentTool[treeTools] = treePictureT) then					begin						if showPicturesMode=showPicturesPopUpMode then							begin								if GetFootPict(0,i) then									PlaceFramedPictureWhileButtonDown(grabpicture, wh);							end						else							ShowFootPict(0, i,0,0);					end				else if not locklegends then					begin						DragArea := ScreenBoundsRect;						InsetREct(DragArea, 4, 4);						DragArea.top := DragArea.top + 12;						DragWindow(chlegwindow, Event.where, @DragArea);						SelectWindow(chlegwindow);					end				else if wh.h > WindowPortRect(chlegwindow).right-8 then					SwitchLockLegends				else if (traceshown = traceDiscrete) & GetFootString(foottext, 0, i, ds) then					begin						genericSetPort(chlegwindow);						PopUpStringMenu(wh, ds);						genericSetPort(tport);					end			end		else if (traceshown = traceDiscrete) & PTINRECT(wh, chlengthB) then			begin				if not equivcycle & (TypeOfChar(i) >= usedef) & poly3inchar(i) then					begin						genericSetPort(chlegwindow);						PopUpStringMenu(wh, '* taxon is polymorphic for more than two states');						genericSetPort(tport);					end;			end		else if (traceshown = traceDiscrete) & PTINRECT(wh, chlegtypeB) & not equivcycle then			begin				if not Locked(lockAssumptions) then					if dblclick then						DefineType(TypeOfChar(i))					else						begin							genericSetPort(chlegWindow);							FixAssumpMenu;							PopUpInfoWindowM(typeinfo, typeMHdl, TypeMenu, wh);						end;			end		else if (traceshown = traceDiscrete) or ((traceshown = traceAllChanges) and (summaryview = aspattern)) then			begin{what about (traceshown = traceContinuous)?}				ic := 0;				if (traceshown = traceDiscrete) then					begin						if nucleotides then							limit := 4						else							limit := CharMaxstDISPLAY(i) + 1;     {v4:  this should use legendstates}						if datatype = protein then							nic := maxstate + 1						else							nic := limit;					end				else if (traceshown = traceAllChanges) then					limit := maxchg + 1;				repeat					ic := ic + 1;					if PTINRECT(wh, strect[ic]) and (((ic - 1) in legendstates) or not (traceshown = traceDiscrete)) then						begin							if (traceshown = traceDiscrete) and not dblclick then								begin									if currentTool[treeTools] = paintT then										begin											if ic > charmaxstDEF(i) + 1 then												NewError(341, 0)											else												begin													brushset := [ic - 1];													InvalidateWindow(chlegwindow, true);													FixBrushColor;													tool^[treeTools,paintT].curs := fullbrush;													DropTool(treeTools,paintT);													SetCursH(tool^[treeTools,paintT].curs);												end;										end;{v4: else if (currentTool[treeTools] = treePictureT) then begin if StatePicture(i, ic - 1, thetaxon) then ShowFootPict(thetaxon, i); end}								end							else if dblclick then								begin									if ((traceshown = traceDiscrete) or (traceshown = traceAllChanges)) and (branchShades[curTrace] <> branchGrayScale) then										begin											displayedDataType := datatype;											SetColorKey(ic - 1, nic);											FixBrushColor;											godraw := true;											InvalidateWindow(chlegwindow, false);										end;								end;							leave;						end;				until (ic = limit);			end 		else if TicksVisible & showTickClass then			begin				for tickClass := 0 to tickMajorClassMax do					if PtInRect(wh,LegendTickClassBox(tickClass,legboxheight,numCharLegendBoxes)) then						begin							ToolOnAllOfClass(tickClass);							leave;						end;			end;		genericSetPort(tport);	end;{-------------------------------------------------------------------------}	function OrientTreeVertical (h, v: integer): integer;{given the true points h,v in window coordinates, returns the vertical}{tree coordinate}	begin{v4: is visTWR.topright the best point to use as origin in this system?}{$IFC FLIPTREE}		if treeflipped then			OrientTreeVertical := visTWR.right - h		else{$ENDC}			OrientTreeVertical := v;	end;{-------------------------------------------------------------------------}	function OrientTreeHorizontal (h, v: integer): integer;{given the true points h,v in window coordinates, returns the horizontal}{tree coordinate}	begin{$IFC FLIPTREE}		if treeflipped then			OrientTreeHorizontal := v  {Davidv4.1: add visTWR.top???}		else{$ENDC}			OrientTreeHorizontal := h;	end;{-------------------------------------------------------------------------}	function AboveTaxonBranch (wh: point; taxonColumn: integer): boolean; {v3.02}{given that the point wh is the the column of taxon taxonColumn, this}{procedure returns true iff wh is in the region of the column above the taxon's branch}		var			TaxonHdl: thdl;	begin		TaxonHdl := gettaxonHdl(taxonColumn);{$IFC FALSE}		if treeflipped then			AboveTaxonBranch := (wh.h > taxonHdl^^.N^.loc.h)		else{$ENDC}			AboveTaxonBranch := (OrientTreeVertical(wh.h, wh.v) < taxonHdl^^.N^.loc.v);	end;{-------------------------------------------------------------------------}	function InTaxonColumn (wh: point; var intaxon: integer): boolean;		var			TaxonHdl: thdl;			it: integer;			left, right, width, minWidth, possibleMinWidth: integer;			tport: WindowPtr;	begin		intaxon := 0;		genericGetPort(tport);		genericSetPort(treewindow);		TextFont(treetaxafont);		TextSize(treetaxafontsize);		TextFace(treetaxaStyle);		minWidth := FontHeight*2;		if minWidth > txsp - 4 then			minWidth := txsp - 4;		if minWidth < 6 then 			minWidth := 6;		genericSetPort(tport);		InTaxonColumn := false;		for it := 1 to numtaxa do			if TaxonInTree(it) then				begin					TaxonHdl := gettaxonHdl(it);					right := taxonHdl^^.B.right;					left := taxonHdl^^.B.left;					width := right-left;					if width < minWidth then 						begin							left := left-(minWidth-width)div 2;							right := right+(minWidth-width)div 2;						end;					if (OrientTreeHorizontal(wh.h, wh.v) > left) and (OrientTreeHorizontal(wh.h, wh.v) < right) then{$IFC FALSE}						if (treeflipped & ((wh.v > taxonHdl^^.B.top) and (wh.v < taxonHdl^^.B.bottom))) | (not treeflipped & ((wh.h > taxonHdl^^.B.left) and (wh.h < taxonHdl^^.B.right))) then							if (wh.h > taxonHdl^^.B.left) and (wh.h < taxonHdl^^.B.right) then{$ENDC}								begin									intaxon := it;									InTaxonColumn := true;									leave;								end;				end;	end;{-------------------------------------------------------------------------}	procedure MouseInTree;   {waits for mouse click}		var			TaxonHdl: thdl;			ic, ir, adj: integer;			oldi, windowloc, j, intaxon, it: integer;			mpoint: point;			tport, whichwindow: windowptr;			box: rect;			oldstoredN: Nptr;			useset: largestsetchars;			c: char;			mousemoved,aboveTaxon: boolean;			ds: str255;	begin		wh := Event.where;		windowloc := FindWindow(wh, whichwindow);		ClipRect(visTWR);		genericGetPort(tport);		genericSetPort(whichwindow);		GlobalToLocal(wh);		genericSetPort(tport);{if BranchListon and not PtInRgn(wh, TWClip) then CloseBranchListWindow; }		oldstoredN := storedN;		if nex7on & (numchars > numboxes) & Ptinrect(wh, myGetControlRect(databoxScroll)) & (numboxes > 0) then			DoDataBoxScroll(wh)		else if Ptinrect(wh, claspRect) and nex7on then{orient: no - clasprect not oriented}			begin				PenMode(patXor);				PenSize(2, 2);				mousemoved := false;				repeat					GetMouse(mpoint);{$IFC FLIPTREE}					if treeflipped then						begin							if mpoint.h <> wh.h then								mousemoved := true;							if mousemoved and ((visTWR.right - mpoint.h - databoxB.bottom) div n7LW > numchars) then								mpoint.h := visTWR.right - (databoxB.top + ord4(numchars) * n7LW);							MoveTo(mpoint.h, visTWR.bottom);							LineTo(mpoint.h, visTWR.top);							LineTo(mpoint.h, visTWR.bottom);						end					else						begin							if mpoint.v <> wh.v then   {orient:}								mousemoved := true;							if mousemoved and ((mpoint.v - databoxB.top) div n7LW > numchars) then								mpoint.v := databoxB.top + ord4(numchars) * n7LW;							MoveTo(visTWR.right, mpoint.v);							LineTo(visTWR.left, mpoint.v);							LineTo(visTWR.right, mpoint.v);						end;{$ELSEC}					if mpoint.v <> wh.v then   {orient:}						mousemoved := true;					if mousemoved and ((mpoint.v - databoxB.top) div n7LW > numchars) then  {orient: most of this stuff can be fixed by reorienting mpoint first}						mpoint.v := databoxB.top + ord4(numchars) * n7LW;					MoveTo(visTWR.right, mpoint.v);					LineTo(visTWR.left, mpoint.v);					LineTo(visTWR.right, mpoint.v);{$ENDC}					CallWaitNextEventForDrawing;				until not Button;				PenNormal;				adj := n7LW div 2;{orient:}				if abs(mpoint.v - dataBoxB.bottom) > 6 then {еmoved enough to notice}					begin						if mpoint.v < (dataBoxB.bottom - n7LW * natnumboxes + adj) then {orient:}							Nex7OnOff(false)						else							begin								numboxes := (mpoint.v - databoxB.top) div n7LW; {orient:}								mpoint.v := dataBoxB.top + numboxes * n7LW;{orient:}								displace7 := mpoint.v - nattop + 10;								RecalcBoxes;								ResetRects;								databoxBHeight := (databoxB.bottom - TWorigV);{orient:}								SetTWScrollMax;								if i7 + numboxes > numchars then									begin										i7 := IntegerMax(numchars - numboxes + 1, 1);										SetControlValueLong(databoxScroll, i7);									end;								godraw := true;							end;						VertTWScrollPosition;					end;			end		else if nex7on & Ptinrect(wh, dataBoxB) then{orient:}			begin				ic := i7 + (wh.v - dataBoxB.top - 2) div n7LW;				if (ic >= 1) & (ic <= numchars) then					begin						aboveTaxon := InTaxonColumn(wh, intaxon);						if (currentTool[treeTools] = treePictureT) & not CommandEvent(Event) & aboveTaxon then							if showPicturesMode=showPicturesPopUpMode then								begin									if GetFootPict(intaxon,ic) then										PlaceFramedPictureWhileButtonDown(grabpicture, wh);								end							else								ShowFootPict(intaxon, ic,0,0)						else if aboveTaxon & GetFootString(foottext, intaxon, ic, ds) then							PopUpStringMenu(wh, ds)						else if dblclick then							begin								oldi := i;								if (currentTool[treeTools] <> treePictureT) then									if not ((traceshown = traceDiscrete) and (ic = i)) and CharIncluded(ic) then										TurnOnTrace(oldi, ic)									else										Beep;							end;					end;			end		else if PTinrect(wh, myGetControlRect(vTWScroll)) | PTinrect(wh, myGetControlRect(hTWScroll)) then			ScrollTree(wh)		else if ((currentTool[treeTools] = handT) and not CommandEvent(Event)) or (ShiftEvent(Event) and not CommandEvent(Event) and not OptionEvent(Event)) then			begin				Delay(15, ticks);				repeat					GetMouse(mpoint);					if not EqualPt(wh, mpoint) then						begin							j := IntegerMax(GetControlMinimumLong(vTWScroll), GetControlValueLong(vTWScroll) - (mpoint.v - wh.v));  {DRMAAA}							SetControlValueLong(vTWScroll, j);							j := IntegerMax(GetControlMinimumLong(hTWScroll), GetControlValueLong(hTWScroll) - (mpoint.h - wh.h));							SetControlValueLong(hTWScroll, j);							ScrollTreeWindow;						end;					wh := mpoint;					CallWaitNextEventForDrawing;				until not button;			end		else if not equivcycle & InTaxonColumn(wh, intaxon) & AboveTaxonBranch(wh, intaxon) then{    if (OrientVert(wh.h, wh.v) < topmargin) and not equivcycle then}{this section is for attaching PICTs and FootTexts etc. to taxon names}			begin{    if InTaxonColumn(wh, intaxon) then}				begin					TaxonHdl := gettaxonHdl(intaxon);					if (currentTool[treeTools] = treePictureT) then						begin							if showPicturesMode=showPicturesPopUpMode then								begin									if (traceshown = traceDiscrete) & PtInRectOrient(wh, taxonHdl^^.B) then										begin											if GetFootPict(intaxon,i) then												PlaceFramedPictureWhileButtonDown(grabpicture, wh);										end									else										if GetFootPict(intaxon,0) then											PlaceFramedPictureWhileButtonDown(grabpicture, wh);								end							else							if (traceshown = traceDiscrete) & PtInRectOrient(wh, taxonHdl^^.B) then								ShowFootPict(intaxon, i,0,0)							else								ShowFootPict(intaxon, 0,0,0);						end					else if (traceshown = traceDiscrete) & PtInRectOrient(wh, taxonHdl^^.B) then						begin							useset := GetTaxonStsLargest(intaxon, i);							if UCl in useset then								c := '?'							else								c := '*';							genericSetPort(chlegwindow);							DrawAsterisksEtc(useset, i, c);							if GetFootString(foottext, intaxon, i, ds) then								begin									genericSetPort(TreeWindow);									PopUpStringMenu(wh, ds);									genericSetPort(chlegwindow);								end							else								repeat								until not button;							EraseAsterisksEtc;							genericSetPort(TreeWindow);						end					else if GetFootString(foottext, intaxon, 0, ds) then						PopUpStringMenu(wh, ds);				end;			end		else if not equivcycle then			ScanPick;		dblclick := false;		if (currentTool[treeTools] <> arrowT) and (oldstoredN <> storedN) then			DropTool(treeTools,arrowT);	end;end.