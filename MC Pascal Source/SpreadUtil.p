unit SpreadUtil;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{ееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap, 		 Globals, SetLibInterface, UtilLibInterface,  UtilLibInterface, MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil,		  ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, TypeUtil, CharUtil, TreeUtil, MenuUtil, 		  SymbolsNames, FootNote, FlashUtil;	function FirstVisibleCharacter: integer;	function LastVisibleCharacter: integer;	function CharacterIsVisible(ic: integer): boolean;	function FirstVisibleTaxon: integer;	function LastVisibleTaxon: integer;	function TaxonIsVisible(it: integer): boolean;		function FirstVisibleColumn: integer;	function LastVisibleColumn: integer;	function FirstVisibleRow: integer;	function LastVisibleRow: integer;	function numVisibleEditorCharacters: integer;	procedure ConsensusSequenceFromRowColumn(var consensusSequence: integer; rowcolumn: integer);	procedure RowColumnFromConsensusSequence(var rowcolumn: integer; consensusSequence: integer);	procedure GetTaxonCharacterFromDataCell(var it,ic: integer; cell: point; minumumOfOne: boolean);	procedure TaxonCharacterFromRowColumn(var it,ic: integer; row, column: integer);	procedure RowColumnFromTaxonCharacter(it,ic: integer; var row,column: integer);	function FindTaxChar(wh: point; var it,ic: integer): boolean;	function JustAboveCellline(ishoriz: boolean; wh: point): boolean;	function NearCellLineInEditor(ishoriz: boolean; place: point): boolean;	function NearSplitMultiBlockLine(ishoriz:boolean; place: point): boolean;	function FirstNonGap(it: integer): integer;	function LastNonGap(it: integer): integer;	function numNonGaps(st,et, sc,ec: longint; missingAsGaps: boolean): longint;	function CharacterNumberOfDataCellNumber(it: longint; dataCellNumber: longint): longint;	function FirstNonGapInBlock(it, sc,ec: integer): integer;	function LastNonGapInBlock(it,sc,ec: integer): integer;	procedure GapBlockBoundaries(it,currentIC, sc, ec: integer; var lowBoundary, highBoundary: integer);	function StartOfCodon(ic: integer): integer;	function EndOfCodon(ic: integer): integer;	function InSameCodon(ic1,ic2: integer): boolean;	procedure SetDirtyEditor (updateJustSelected: boolean);	procedure FixTotNums;	procedure EraseEditorRect(box: rect);	procedure InvalidateTaxChar (it, ic: integer; erase: boolean);	procedure InvalidateCellBlock (st,et,sc,ec: integer; erase: boolean);	procedure InvalidateEditorNames (doTaxa: boolean);	procedure CellHor (colnum: integer; var left, right: integer; bounded: boolean);	procedure CellVer (rownum: integer; var top, bottom: integer; bounded: boolean);	function CellRect (cellh, cellv: integer): RECT;	function FindCell (wh: point; bounded, formove: boolean): point;	procedure FindTaxonCharacterInEditor(wh: point; var it,ic: integer);	procedure CalcEditorMatrixRect;	procedure CalcEditorBoundaryRect;	procedure CalcEditorSelectionRect (CellTL, CellBR: point);	procedure CalcSplitMultiFlashRegion;	procedure ClipEditBox (box: rect);	procedure FillsTE (var TE: TEHandle; ds: str255);	function LegalSetChars (ic: integer; addhigh: boolean): LargestSetChars;	function MakeLegalSet (inset: LargestSetChars; var outset: LargestSetChars; ic: integer): boolean;	function CellBlockStates(cellBlock: CellBlockPtr; it,ic,pasteIC: integer; var smallSymbol: boolean): LargestSetChars;	function BadCellEntryQuery: boolean;	function ShadeCharacter(ic: integer): boolean;	procedure CalcStateFreq(var freq: stateFreqType; st,et, sc,ec: integer);	function NumOfStateInTaxon(it: integer; state: integer; allCharacters: boolean): longint;	function TotalNumStateCells(it: integer; allCharacters: boolean): longint;	const		columnSmallIncrement=4;		columnIncrement=8;		columnControlTickDrawIncrement=4;		editorNumberWidthControlTicks = 20;		writeStandardCells = 1;		writeInvertedCells = 2;		writeGapCells = 3;		writeMissingCells = 4;		writeClipBoard = 5;		writeCellBlock = 6;		writeCellsUnderMovingBlock=7;				notegap = 0;			var		ordefSep: boolean;				cellBlockOffset: point;		footNoteLines: integer;		edSelQueryRect: Rect;{$SETC EXPANDFEET=TRUE}{$IFC EXPANDFEET}		notePullR: Rect;{$ENDC}{ееееееееееееееееееееее}implementation {е$S SpreadUtil}{-----------------------------------------------------------------------------}	function FirstVisibleCharacter: integer;	begin		if editorTransposed then			FirstVisibleCharacter := editorOrigin.v		else			FirstVisibleCharacter := editorOrigin.h;	end;{-----------------------------------------------------------------------------}	function LastVisibleCharacter: integer;	var last: integer;	begin		if editorTransposed then			begin				last := editorOrigin.v+editorRows-1;				if last > numchars then last := numchars;			end		else			begin				last := editorOrigin.h+editorColumns-1;				if last > numchars then last := numchars;			end;		LastVisibleCharacter:= last;	end;{-----------------------------------------------------------------------------}	function CharacterIsVisible(ic: integer): boolean;	begin		CharacterIsVisible := (ic >= FirstVisibleCharacter) & (ic <= LastVisibleCharacter);	end;{-----------------------------------------------------------------------------}	function FirstVisibleTaxon: integer;	begin		if editorTransposed then			FirstVisibleTaxon := editorOrigin.h		else			FirstVisibleTaxon := editorOrigin.v;	end;{-----------------------------------------------------------------------------}	function LastVisibleTaxon: integer;	var last: integer;	begin		if not editorTransposed then			begin				last := editorOrigin.v+editorRows-1;				if last > numtaxa then last := numtaxa;			end		else			begin				last := editorOrigin.h+editorColumns-1;				if last > numtaxa then last := numtaxa;			end;		LastVisibleTaxon:= last;	end;	{-----------------------------------------------------------------------------}	function TaxonIsVisible(it: integer): boolean;	begin		TaxonIsVisible := (it >= FirstVisibleTaxon) & (it <= LastVisibleTaxon);	end;{----------------------------------------------------------------------------}	function FirstVisibleColumn: integer;	begin		FirstVisibleColumn := editorOrigin.h;	end;{----------------------------------------------------------------------------}	function LastVisibleColumn: integer;	begin		LastVisibleColumn := editorOrigin.h+editorColumns-1;	end;{----------------------------------------------------------------------------}	function FirstVisibleRow: integer;	begin		FirstVisibleRow := editorOrigin.v;	end;{----------------------------------------------------------------------------}	function LastVisibleRow: integer;	begin		LastVisibleRow := editorOrigin.v+editorRows-1;	end;{----------------------------------------------------------------------------}	procedure ConsensusSequenceFromRowColumn(var consensusSequence: integer; rowcolumn: integer);	begin		consensusSequence := -rowcolumn-1;	end;{----------------------------------------------------------------------------}	procedure RowColumnFromConsensusSequence(var rowcolumn: integer; consensusSequence: integer);	begin		rowcolumn := -consensusSequence-1;	end;{----------------------------------------------------------------------------}	function numVisibleEditorCharacters: integer;	begin		if not editorTransposed then			numVisibleEditorCharacters := editorColumns		else			numVisibleEditorCharacters := editorRows;	end;{----------------------------------------------------------------------------}	procedure GetTaxonCharacterFromDataCell(var it,ic: integer; cell: point; minumumOfOne: boolean);	begin		if not editorTransposed then			begin				it := cell.v;				ic := cell.h;			end		else			begin				ic := cell.v;				it := cell.h;			end;		if minumumOfOne then			begin				if ic<=0 then ic := 1;				if it<=0 then it := 1;			end;	end;{----------------------------------------------------------------------------}	procedure TaxonCharacterFromRowColumn(var it,ic: integer; row, column: integer);	begin		if not editorTransposed then			begin				it := row;				ic := column;			end		else			begin				ic := row;				it := column;			end;	end;{----------------------------------------------------------------------------}	procedure RowColumnFromTaxonCharacter(it,ic: integer; var row,column: integer);	begin		if not editorTransposed then			begin				row := it;				column := ic;			end		else			begin				row := ic;				column := it;			end;	end;{----------------------------------------------------------------------------}	function FindTaxChar(wh: point; var it,ic: integer): boolean;	var cell: point;	begin		cell:= FindCell(wh,true,false);		if not editorTransposed then			begin				it := cell.v;				ic := cell.h;			end		else			begin				ic := cell.v;				it := cell.h;			end;		FindTaxChar := (it>0) & (it<= numtaxa) & (ic> 0) & (ic<= numchars);	end;{-----------------------------------------------------------------------------}	function JustAboveCellline(ishoriz: boolean; wh: point): boolean;	var closeness: integer;	begin		JustAboveCellline:= false;		if ishoriz then		 	begin 				closeness := (wh.h-editorFirstColumnLeft) mod editorColumnWidth;		 		JustAboveCellline := closeNess < editorColumnWidth div 2;		 	end		else		 	begin 				closeness := (wh.v-editorFirstRowTop) mod editorLineWidth;		 		JustAboveCellline := closeNess < editorLineWidth div 2;			end; 	end;{-----------------------------------------------------------------------------}	function NearCellLineInEditor(ishoriz: boolean; place: point): boolean;	var closeness: integer;		begin		NearCellLineInEditor:= false;		if ishoriz then		 	begin		 		if place.h > editorFirstColumnLeft then		 			begin		 				closeness := {(editorColumnWidth - }(place.h-editorFirstColumnLeft) mod editorColumnWidth;				 		if closeNess > editorColumnWidth div 2 then				 			closeNess := editorColumnWidth-closeNess-1;		 				NearCellLineInEditor := closeness < editorLineSensitivity;				 	end				 else				 	NearCellLineInEditor:= false;		 	end		else		 	begin		 		if place.v > editorFirstRowTop then		 			begin		 				closeness := (place.v-editorFirstRowTop) mod editorLineWidth;				 		if closeNess > editorLineWidth div 2 then				 			closeNess := editorLineWidth-closeNess-1;		 				NearCellLineInEditor := closeness < editorLineSensitivity;				 	end				 else				 	NearCellLineInEditor:= false;			end;		{if closeness >= 0 then} 		{else		 	NearCellLineInEditor := closeness > 5;} 	end;{----------------------------------------------------------------------------}	function NearSplitMultiBlockLine(ishoriz:boolean; place: point): boolean;	var it, ic: integer;	begin		if  NearCellLineInEditor(ishoriz,place) & FindTaxChar(place,it,ic) then			begin				if JustAboveCellLine(not editorTransposed,place) then					NearSplitMultiBlockLine :=  (it >= splitTaxonStart) & (it <= splitTaxonEnd) & (ic=splitCharacter+1)				else					NearSplitMultiBlockLine :=  (it >= splitTaxonStart) & (it <= splitTaxonEnd) & (ic=splitCharacter);			end		else			NearSplitMultiBlockLine := false;	end;{----------------------------------------------------------------------------}	function FirstNonGap(it: integer): integer;	{this calculates the first character that is a non-gap in taxon it}	var ic: integer;	begin		for ic := 1 to numchars do			if not IsGap(it, ic) then				leave;		FirstNonGap := ic;	end;{----------------------------------------------------------------------------}	function LastNonGap(it: integer): integer;	{this calculates the last character that is a non-gap in taxon it}	var ic: integer;	begin		for ic := numchars downto 1 do			if not IsGap(it, ic) then				leave;		LastNonGap := ic;	end;{----------------------------------------------------------------------------}	function FirstNonGapInBlock(it, sc,ec: integer): integer;	{this calculates the first character that is a non-gap in taxon it in a block between sc and ec}	var ic: integer;	begin		for ic := sc to ec do			if not IsGap(it, ic) then				leave;		FirstNonGapInBlock := ic;	end;{----------------------------------------------------------------------------}	function LastNonGapInBlock(it,sc,ec: integer): integer;	{this calculates the last character that is a non-gap in taxon it in a block between sc and ec}	var ic: integer;	begin		for ic := ec downto sc do			if not IsGap(it, ic) then				leave;		LastNonGapInBlock := ic;	end;{----------------------------------------------------------------------------}	procedure GapBlockBoundaries(it,currentIC, sc, ec: integer; var lowBoundary, highBoundary: integer);	{this calculates the boundaries of a block of gaps including it,sc}	var ic: integer;	begin		if not isGap(it,currentIC) | (currentIC < sc) | (currentIC > ec) then			begin				lowBoundary := 0;				highBoundary := 0;			end		else			begin				if (currentIC > sc) then					begin						for ic := currentIC-1 downto sc do							if not IsGap(it, ic) then								leave;						lowBoundary := ic+1;					end				else					lowBoundary := currentIC;				if (currentIC < ec) then					begin						for ic := currentIC+1 to ec do							if not IsGap(it, ic) then								leave;						highBoundary := ic-1;					end				else					highBoundary := currentIC;			end;	end;{----------------------------------------------------------------------------}	function numNonGaps(st,et, sc,ec: longint; missingAsGaps: boolean): longint;	var it, ic, numNon: longint;	begin		numNon := 0;		for it := st to et do			for ic := sc to ec do				if not IsGapLike(it,ic,missingAsGaps) then					numNon := numNon+1;		numNonGaps := numNon;	end;{----------------------------------------------------------------------------}	function CharacterNumberOfDataCellNumber(it: longint; dataCellNumber: longint): longint;	var ic, numNon, charNumber: longint;	begin		numNon := 0;		charNumber := 0;		for ic := 1 to numChars do			if not IsGapLike(it,ic,editorToolsTreatMissingAsGaps) then				begin					numNon := numNon+1;					if (numNon=dataCellNumber) then						begin							charNumber := ic;							leave;						end;				end;		CharacterNumberOfDataCellNumber := charNumber;	end;{----------------------------------------------------------------------------}	function InSameCodon(ic1,ic2: integer): boolean;	var bigic,smallic: integer;	begin		InSameCodon := false;		if ic1>ic2 then			begin				bigic := ic1;				smallic := ic2;			end		else 			begin				bigic := ic2;				smallic := ic1;			end;		if bigic=smallic then			InSameCodon := true		else if bigic > smallic+2 then			InSameCodon := false		else if (CharCodPos(bigic)=2) & (CharCodPos(smallic)=1) & (bigic=smallic+1) then			InSameCodon := true		else if (CharCodPos(bigic)=3) & (CharCodPos(smallic)=2) & (bigic=smallic+1) then			InSameCodon := true		else if (CharCodPos(bigic)=3) & (CharCodPos(smallic+1)=2) & (CharCodPos(smallic)=1) &  (bigic=smallic+2) then			InSameCodon := true;	end;{----------------------------------------------------------------------------}	function StartOfCodon(ic: integer): integer;	begin		StartOfCodon := ic;					case CharCodPos(ic) of			{1: StartOfCodon := ic;}			2: 	if (ic>1) & (CharCodPos(ic-1)=1) then					StartOfCodon := ic-1;			3: 	if (ic>2) & (CharCodPos(ic-1)=2)& (CharCodPos(ic-2)=1) then					StartOfCodon := ic-2				else if (ic>1)  & (CharCodPos(ic-1)=2) then					StartOfCodon := ic-1			otherwise;		end;	end;{----------------------------------------------------------------------------}	function EndOfCodon(ic: integer): integer;	begin		EndOfCodon := ic;					case CharCodPos(ic) of			1: 	if (ic<numchars-1) & (CharCodPos(ic+1)=2)& (CharCodPos(ic+2)=3) then					EndOfCodon := ic+2				else if (ic<numchars)  & (CharCodPos(ic+1)=2) then					EndOfCodon := ic+1			2: 	if (ic<numchars) & (CharCodPos(ic+1)=3) then					EndOfCodon := ic+1;			{3: EndOfCodon := ic;}			otherwise;		end;	end;{----------------------------------------------------------------------------}	procedure EraseEditorRect(box: rect);	begin		EraseRect(box);	end;{----------------------------------------------------------------------------}{-----------------------------------------------------------------------------}	procedure SetDirtyEditor (updateJustSelected: boolean);		var			tport: WindowPtr;	begin		genericGetPort(tport);		genericSetPort(editorWindow);		dirtyMaxst := true;		dataChanged := true;		if updateJustSelected then			begin				if SingleCell then					EraseEditorRect(editorSelectionRect)				else					EraseRect(editorSelectionRect);				InvalidateWindowRect(editorWindow,editorSelectionRect,false);			end		else			InvalidateWindow(editorWindow, true);		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	function BadCellEntryQuery: boolean;	begin{BadCellEntryQuery := CWarning('Bad entry in cell of data editor.  Check spelling, and-or separators, and whether character transformation type restricts maximum state for character.', 'Discard', 'Go back to cell')}		BadCellEntryQuery := CWarning('Bad entry in cell of data editor.  Possible problems: name misspelled or not defined; check names not selected in Entry Interpretation; improper and-or separator; undefined symbol; character''s transformation type restricts maximum state.', 'Discard', 'Go back to cell')	end;{----------------------------------------------------------------------------}	procedure FixTotNums;	begin		if not editorTransposed then			begin				editorTotalColumns := numchars;				editorTotalRows := numtaxa;			end		else			begin				editorTotalColumns := numtaxa;				editorTotalRows := numchars;			end;	end;{|||||||||||||||||||||||||||   Editor screen positions  ||||||||||||||||||||||||||||||||||}{----------------------------------------------------------------------------}	procedure CellHor (colnum: integer; var left, right: integer; bounded: boolean);		var			longleft: longint;			consensusSequence:integer;	begin		if (colnum <-1) then			begin				ConsensusSequenceFromRowColumn(consensusSequence,colnum);				longleft := editorRowNameEnd + longint(consensusSequence -1) * editorColumnWidth;				if longleft > 32760 - editorColumnWidth then					longleft := 32760 - editorColumnWidth;				if longleft < -32760 then					longleft := -32760;				left := longleft;				{GRID:} {				right := left + editorColumnWidth + 2;}				right := left + editorColumnWidth;				{:GRID}			end		else if (colnum > 0) | not bounded then			begin				longleft := editorFirstColumnLeft + longint(colnum - editorOrigin.h) * editorColumnWidth;				if longleft > 32760 - editorColumnWidth then					longleft := 32760 - editorColumnWidth;				if longleft < -32760 then					longleft := -32760;				left := longleft;				{GRID:} {				right := left + editorColumnWidth + 2;}				right := left + editorColumnWidth;				{:GRID}			end		else if colnum = 0 then			begin				left := editorRowNameStart;				right := editorRowNameEnd;			end		else if colnum = -1 then			begin				left := -1;				right := editorRowNameStart;			end;	end;{----------------------------------------------------------------------------}	procedure CellVer (rownum: integer; var top, bottom: integer; bounded: boolean);		var			longtop: longint;			consensusSequence:integer;	begin		if rownum<-1 then {is consensus sequence}			begin				ConsensusSequenceFromRowColumn(consensusSequence,rownum);				longtop := editorTitlesWidth + longint(consensusSequence-1) * editorLineWidth;				if longtop > 32760 - editorLineWidth then					longtop := 32760 - editorLineWidth;				if longtop < -32760 then					longtop := -32760;				top := longtop;				bottom := top + editorLineWidth;			end		else if (rownum > 0) | not bounded then			begin				longtop := editorFirstRowTop + longint(rownum - editorOrigin.v) * editorLineWidth;				if longtop > 32760 - editorLineWidth then					longtop := 32760 - editorLineWidth;				if longtop < -32760 then					longtop := -32760;				top := longtop;				bottom := top + editorLineWidth;			end		else if rownum = 0 then			begin				top := editorTitleLineWidth;				bottom := editorTitlesWidth;			end		else if rownum = -1 then			begin				top := 0;				bottom := editorTitleLineWidth;			end;	end;{----------------------------------------------------------------------------}	function CellRect (cellh, cellv: integer): RECT;		var			left, top, right, bottom: integer;			B: Rect;	begin		CellHor(cellh, left, right, true);		CellVer(cellv, top, bottom, true);		SetREct(B, left, top, right, bottom);		CellRect := B;	end;{----------------------------------------------------------------------------}	function FindCell (wh: point; bounded, formove: boolean): point;{this function returns the cell in which the point wh is found in the editorWindow}		var			cell: point;			consensusNumber: integer;	begin		if (wh.v >= editorFirstRowTop) | not bounded | formove then			begin				Cell.v := (wh.v - editorFirstRowTop) div editorLineWidth + editorOrigin.v;				if formove & bounded & (cell.v < 1) then					cell.v := 1;			end		else if wh.v < editorTitleLineWidth then			Cell.v := -1		else if wh.v < editorTitlesWidth then			Cell.v := 0		else if wh.v < editorFirstRowTop then			begin				consensusNumber := (wh.v - editorTitlesWidth) div editorLineWidth+1;				RowColumnFromConsensusSequence(Cell.v,consensusNumber);			end;		if (wh.h >= editorFirstColumnLeft) | not bounded | formove then			begin				Cell.h := (wh.h - editorFirstColumnLeft) div editorColumnWidth + editorOrigin.h;				if formove & bounded & (cell.h < 1) then					cell.h := 1;			end		else if wh.h < editorRowNameStart then			Cell.h := -1		else if wh.h < editorRowNameEnd then			Cell.h := 0		else			begin				consensusNumber := (wh.h - editorRowNameEnd) div editorColumnWidth+1;				RowColumnFromConsensusSequence(Cell.h,consensusNumber);			end;		FindCell := cell;	end;{----------------------------------------------------------------------------}	procedure FindTaxonCharacterInEditor(wh: point; var it,ic: integer);	var theCell : point;	begin		theCell := FindCell(wh, true, false);		if not editorTransposed then			begin				it := theCell.v;				ic := theCell.h;			end		else			begin				it := theCell.h;				ic := theCell.v;			end;		if it > numtaxa then it := numtaxa;		if ic > numchars then ic := numchars;	end;{----------------------------------------------------------------------------}	procedure InvalidateCellBlock (st,et,sc,ec: integer; erase: boolean);	var		tempP: WindowPtr;		left,right,top,bottom, d: integer;		box: rect;	begin 		genericGetPort(tempP);		if st < FirstVisibleTaxon then st := FirstVisibleTaxon;		if et > LastVisibleTaxon then et := LastVisibleTaxon;		if sc < FirstVisibleCharacter then sc := FirstVisibleCharacter;		if ec > LastVisibleCharacter then ec := LastVisibleCharacter;		genericSetPort(editorWindow);		if not editorTransposed then			begin				CellHor(sc, left, d, true);				CellHor(ec, d, right, true);				CellVer(st, top, d, true);				CellVer(et, d, bottom, true);			end		else 			begin				CellHor(st, left, d, true);				CellHor(et, d, right, true);				CellVer(sc, top, d, true);				CellVer(ec, d, bottom, true);			end;		SetRect(box,left,top,right,bottom);		if erase then 			EraseRect(box);		InvalidateWindowRect(editorWindow,box,false);		genericSetPort(tempP);	end;{----------------------------------------------------------------------------}	procedure InvalidateTaxChar (it, ic: integer; erase: boolean);	var		tempP: WindowPtr;		left,right,top,bottom, d: integer;		box: rect;	begin 		genericGetPort(tempP);		genericSetPort(editorWindow);		if it = 0 then  {it's a character}			if not editorTransposed then				begin					CellHor(ic, left, right, true);					CellVer(1, top, d, true);					CellVer(numtaxa, d, bottom, true);				end			else 				begin					CellHor(1, left, d, true);					CellHor(numtaxa, d, right, true);					CellVer(ic, top, bottom, true);				end		else   {it's a taxon}			if not editorTransposed then				begin					CellHor(1, left, d, true);					CellHor(numchars, d,right, true);					CellVer(it, top, bottom, true);				end			else 				begin					CellHor(it, left, right, true);					CellVer(1, top, d, true);					CellVer(numchars, d, bottom, true);				end;		SetRect(box,left,top,right,bottom);		if erase then 			EraseRect(box);		InvalidateWindowRect(editorWindow,box,false);		genericSetPort(tempP);	end;{----------------------------------------------------------------------------}	procedure InvalidateEditorNames (doTaxa: boolean);	var		tempP: WindowPtr;		left,right,top,bottom, d: integer;		startName,endName: longint;		box: rect;	begin 		genericGetPort(tempP);		if dotaxa then			begin				startName := firstVisibleTaxon;				endName := lastVisibleTaxon;			end		else			begin				startName := firstVisibleCharacter;				endName := lastVisibleCharacter;			end;		genericSetPort(editorWindow);		if editorTransposed = doTaxa then  {do names across top}			begin				CellHor(startname, left, d, true);				CellHor(endName, d, right, true);				CellVer(0, top, bottom, true);			end		else 			begin				CellHor(0, left, right, true);				CellVer(startName, top, d, true);				CellVer(endName, d, bottom, true);			end;		SetRect(box,left,top,right,bottom);		EraseRect(box);		InvalidateWindowRect(editorWindow,box,false);		genericSetPort(tempP);	end;{----------------------------------------------------------------------------}	procedure CalcEditorMatrixRect;{editorMatrixRect is the actual rectangle in which data are drawn}		var			botrow, rtcol: integer;			bot, rt: integer;	begin		editorMatrixRect := editorBoundaryRect;		botrow := editorOrigin.v + editorRows - 1;		if botrow > editorTotalRows then			begin				bot := editorTotalRows - editorOrigin.v + 1;				if bot < 1 then					bot := 1;				editorMatrixRect.bottom := editorFirstRowTop + bot * editorLineWidth;			end;		rtcol := editorOrigin.h + editorColumns - 1;		if rtcol > editorTotalColumns then			begin				rt := editorTotalColumns - editorOrigin.h + 1;				if rt < 1 then					rt := 1;				editorMatrixRect.right := editorFirstColumnLeft + rt * editorColumnWidth;			end;		SetRect(editorTitleCornerRect, 0, 0, editorRowNameEnd, editorTitlesWidth);  {v3.04}	end;{----------------------------------------------------------------------------}	procedure CalcEditorBoundaryRect;{editorBoundaryRect is the maximum editorMatrixRect - that is, the drawing area of editorWindow, exclusive of scroll bars and footnotes}	begin		editorBoundaryRect := WindowPortRect(editorWindow);		editorBoundaryRect.right := editorBoundaryRect.right - scrollwidth;		editorBoundaryRect.bottom := editorBoundaryRect.bottom - scrollwidth - notewidth - notegap;		SetEWClip(noscroll);	end;{----------------------------------------------------------------------------}	procedure CalcEditorSelectionRect (CellTL, CellBR: point);{calculates the rectangle of the selection}		var			B: rect;	begin		editorSelectionRect := CellRect(CellTL.h, CellTL.v);		B := CellRect(CellBR.h, CellBR.v);		{if AAAutoTranslationVisible then 			if not editorTransposed then				B.bottom := B.top+editorLineWidth div 2			else				B.right := B.left + editorColumnWidth div 2; }		editorSelectionRect.botright := B.botright;		if CellTL.v = -1 then			begin				{InsetRect(editorSelectionRect, 2, 0);}				{editorSelectionRect.left := editorSelectionRect.left - 1;}				editorSelectionRect.bottom := editorMatrixRect.bottom;			end;		if CellTL.h = -1 then			begin				{editorSelectionRect.top := editorSelectionRect.top + 1;}				editorSelectionRect.right := editorMatrixRect.right;			end;	end;{-----------------------------------------------------------------------------}	procedure CalcSplitMultiFlashRegion;	var TL, BR: point;		d, top, bottom, right, left: integer;		box: rect;		 flashRgn: RgnHandle;		 tport: WindowPtr;		 tempRgnOuter, tempRgnInner: RgnHandle;	begin		if editorTransposed then			begin				CellHor(splitTaxonStart,left,d,false);				CellHor(splitTaxonEnd,d,right,false);				CellVer(splitCharacter,d,bottom,false);				top := bottom;			end		else			begin				CellVer(splitTaxonStart,top,d,false);				CellVer(splitTaxonEnd,d,bottom,false);				CellHor(splitCharacter,d,right,false);				left := right;			end;		SetRect(box,left,top,right,bottom);		InsetRect(box,-2,-2);		RectRgn(theflashRgn,box);	end;{||||||||||||||||||||||||||||||||||||||||||||||||||||}{----------------------------------------------------------------------------}	procedure ClipEditBox (box: rect);{clips to the intersection of the box and the current clipregion}		var			oldR, dClip: RgnHandle;	begin		if printon then			ClipRect(box)		else			begin				oldR := NewRgn;				dClip := NewRgn;				GetClip(oldR);				RectRgn(dClip, box);				SectRgn(dClip, oldR, dClip);				SetClip(dClip);				ZapRegion(dClip);				ZapRegion(oldR);			end;	end;{----------------------------------------------------------------------------}	procedure FillsTE (var TE: TEHandle; ds: str255);{fills the text edit record TE with the string ds}	begin		TESetText(Pointer(ORD4(@ds) + 1), ORD4(length(ds)), TE);		if (editorSelectionTopLeft.v = 0) or (editorSelectionTopLeft.h = 0) then			TESetAlignment(teJustLeft, TE)		else			TESetAlignment(teJustCenter, TE);	end;{----------------------------------------------------------------------------}	function LegalSetChars (ic: integer; addhigh: boolean): LargestSetChars;{returns set of states that can legally be assigned to a data cell for character ic}		var			tsts: LargestSetChars;			theType: integer;			typeHdl : typeHandle;	begin		if (ic = 0) then   {ic is passed 0 when no specific character is being considered}			tsts := [0..maxstate]		else			begin				theType := TrueTypeOfChar(ic);				typeHdl := GetTypeHdl(theType);				if typeHdl = nil then 					tsts := [0..maxstate]				else					tsts := typeHdl^^.setdefined * [0..maxstate];			end;		if addhigh then			tsts := tsts + [msl, ucl, gal];		LegalSetChars := tsts;	end;{-----------------------------------------------------------------------------}	function MakeLegalSet (inset: LargestSetChars; var outset: LargestSetChars; ic: integer): boolean;{returns true if set tsts contains at least some states legal for char ic}	begin		outset := inset * LegalSetChars(ic, true);    {clean out illegal states!!!}		if inset <> outset then			NewError(125, ic);		MakeLegalSet := not ((outset = []) or (outset = [UCl]));	end;{----------------------------------------------------------------------------}	function CellBlockStates(cellBlock: CellBlockPtr; it,ic,pasteIC: integer; var smallSymbol: boolean): LargestSetChars;	var 	oldstate: SignedByte;		scrapPtr: Ptr;		clipSet, tsts: LargestSetChars;	begin		LockHandle(cellBlock^.H, oldstate);		scrapPtr := Ptr(GetMaster(cellBlock^.H) + ord4(cellBlock^.blocktcb)*(ord4(it-1)*cellBlock^.nchar+(ic-1)));		if cellBlock^.blocknumbytes = 2 then			clipSet := set15to31(IP(ScrapPtr)^)		else			clipSet := LargestSetPointer(ScrapPtr)^;		ResetHandle(cellBlock^.H, oldstate);				if nucleotides then			begin				smallSymbol := SSl in clipSet;				clipSet := clipSet - [FTl,FPl,SSl];			end		else			clipSet := clipSet - [FTl, FPl];  {so MakeLegalSet doesn't generate error}		if not MakeLegalSet(clipSet, tsts, pasteIC) then			tsts := [MSl];		CellBlockStates := tsts;	end;{----------------------------------------------------------------------------}	function ShadeCharacter(ic: integer): boolean;	begin		if editorCharacterSetToShade=NoneShadeCharSet then			ShadeCharacter := false		else if editorCharacterSetToShade <=AllDataTypesStandardShadeCharSet then			begin				case editorCharacterSetToShade of					AllShadeCharSet:						ShadeCharacter:= true;					AllIncludedShadeCharSet:						ShadeCharacter := charincluded(ic);					AllExcludedShadeCharSet:						ShadeCharacter := not charincluded(ic);					AllInvariantShadeCharSet:						ShadeCharacter := InvariantChar(ic);					AllGapsMissingShadeCharSet:						ShadeCharacter := AllGaps(ic,true);					Every10thShadeCharSet:						ShadeCharacter := ic mod 10 = 0;					otherwise						ShadeCharacter := false;				end;			end		else if (nucleotides & (editorCharacterSetToShade <=NucleotideStandardShadeCharSet)) then			begin				case editorCharacterSetToShade of					ProteinCodingShadeCharSet:						ShadeCharacter:= IsCoding(ic);					NonCodingShadeCharSet:						ShadeCharacter:= not  IsCoding(ic);					EveryFirstShadeCharSet:						ShadeCharacter:= CharCodPos(ic)=1;					EverySecondShadeCharSet:						ShadeCharacter:= CharCodPos(ic)=2;					EveryThirdShadeCharSet:						ShadeCharacter:= CharCodPos(ic)=3;					otherwise						ShadeCharacter := false;				end;			end		else 				begin				ShadeCharacter:= InShadeCharSet(ic);			end;	end;{----------------------------------------------------------------------------}	procedure CalcStateFreq(var freq: stateFreqType; st,et, sc,ec: integer);	var 	j : integer;		ic, it: longint;		tsts: LargestSetChars;	begin		for j := 0 to absmaxstate do			freq[j] := 0;		for it := st to et do			for ic := sc to ec do				begin					tsts := GetTaxonStsLargest(it, ic);					for j := 0 to absmaxstate do						if j in tsts then							freq[j] := freq[j]+1;				end;	end;{-----------------------------------------------------------------------------}	function NumOfStateInTaxon(it: integer; state: integer; allCharacters: boolean): longint;	var dL: longint;		ic: integer;		tsts: largestsetchars;	begin		dL:= 0;		for ic := 1 to numchars do			if allCharacters | CharIncluded(ic) then				begin					tsts := gettaxonstsLargest(it, ic);					if tsts = [state] then						dL := dL + 1;				end;		NumOfStateInTaxon:= dL;	end;{-----------------------------------------------------------------------------}	function TotalNumStateCells(it: integer; allCharacters: boolean): longint;	var dL: longint;		ic: integer;		tsts: largestsetchars;	begin		dL:= 0;		for ic := 1 to numchars do			if allCharacters | CharIncluded(ic) then				begin					tsts := gettaxonstsLargest(it, ic);					if not (MSl in tsts) & MonomorphLg(tsts) then						dL := dL + 1;				end;		TotalNumStateCells:= dL;	end;end.