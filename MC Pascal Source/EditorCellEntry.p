unit EditorCellEntry;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{ееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  		UtilLibInterface, MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, 		TypeUtil, CharUtil, TreeUtil, MenuUtil, SymbolsNames, FootNote, SpreadUtil, EditorUndo, ConsensusSequences;	function StsToString (tsts: LargestSetchars; ic: integer; statenames,useIUPAC: boolean): str255;	procedure CheckConvertAlternativeSymbol(isSmall, checkStorage: boolean; it,ic: integer; var ds: str255);	function SimpleCellEntry (it,ic: integer): str255;	function TaxonCharacterCellEntry (it,ic: integer; var tsts: LargestSetChars): str255;	function CellEntry (rownum, colnum: integer; var tsts: LargestSetChars): str255;	function CellString: Str255;	function StringToSetChars (var ds: str255; var tsts: largestsetchars; it, ic: integer): BOOLEAN;	function StringToSts (it, ic: integer; var ds: str255): BOOLEAN;	function AASymbolsInAAwithDNACell(ic: integer; tsts: LargestSetChars): str255;	procedure ReturnValue (cell: point;overrideLock: boolean);	function PasteCellBlock(cellBlock: CellBlockPtr; pasteState: LargestSetChars; st,et,sc,ec: integer): boolean;	function CellBlockEntry(cellBlock:CellBlockPtr; it,ic,pasteIC: integer; var tsts: LargestSetChars):str255;	procedure RedrawAATranslation(it,ic: integer);	procedure RedrawAATranslationBlock(st,et,sc,ec: integer);	procedure WriteSingleAAwithDNACell(it, icstart,icend: integer; tsts: LargestSetChars);	procedure DrawAAfromDNACell(cell: point);	procedure WriteCell (B: rect; rownum, colnum: integer; pasteIC: integer; selected, offScreen, eraseBox: boolean; cellWritingMode: integer);	procedure WriteTaxonCharacterCell (it,ic: integer; offScreen: boolean; cellWritingMode: integer; selectionMode: integer);	procedure WriteConsensusCell (consensusNumber,ic: integer; offScreen: boolean; cellWritingMode: integer; selectionMode: integer);	procedure WriteAllConsensesForCharacters (icstart,icend: integer; cellWritingMode: integer; selectionMode: integer);	procedure WriteConsensusName (consensusNumber, selectionMode: integer);	procedure DrawRowName (rownum: integer; selectionMode: integer);	procedure DrawColName (colnum: integer; selectionMode: integer);	procedure DrawRCNumberBox (rcnum: integer; row: boolean);	procedure MatchCharUpdate (icstart, icend: integer);	procedure RedrawCharactersInEditor (icstart, icend: integer);	procedure CheckRedrawFullCharactersInEditor (itstart,itend, icstart, icend: integer; cellChange: boolean);	procedure DrawDataCellsInRect(box: rect;  selectionMode: integer);	procedure DrawDataCellsBetweenCorners(TL,BR: point;  selectionMode: integer);	procedure DrawDataCellsInRgn(theRgn: RgnHandle;  selectionMode: integer);	procedure DrawConsensusSequence(consensusNumber, selectionMode: integer);	procedure DrawConsensusBlock(cellBlock: cellBlockPtr;oldicstart,oldicend: integer);	procedure PrepareAAfromDNA(it,ic,pasteIC: integer; var tsts: LargestSetChars; isConsensus: boolean;cellWritingMode: integer);	procedure SetEdgeTSTS(isFirst: boolean; it: integer; tsts: LargestSetChars);	function GetEdgeTSTS(isFirst: boolean; it: integer): LargestSetChars;	procedure SizeEdgeTSTS(isFirst: boolean; totalNumTaxa: integer);	procedure EmptyEdgeTSTS(isFirst: boolean);		procedure DrawCellBlockBoundaryAAwithDNA (cellBlock: CellBlockPtr; oldicstart,oldicend,selectionMode: integer);	procedure UndoCellBlock(updateStuff: boolean);const	selectionModeAsIs=0;	selectionModeOn=1;	selectionModeOff=2;{ееееееееееееееееееееее}implementation {е$S SpreadUtil}{----------------------------------------------------------------------------}	procedure SetEdgeTSTS(isFirst: boolean; it: integer; tsts: LargestSetChars);		var oldstate: SignedByte;			H: Handle;			statePtr: LIP;	begin		if it > EWCurrentDrawBlockP^.ntax then			begin				Beep;				Exit(SetEdgeTSTS);			end;		if isFirst then			H:= EWCurrentDrawBlockP^.firstEdgeTSTSH		else			H := EWCurrentDrawBlockP^.lastEdgeTSTSH;		LockHandle(H, oldstate);		statePtr := LIP(GetMaster(H)+4*(it-1));		statePtr^ := longint(tsts);		ResetHandle(H, oldstate);	end;{----------------------------------------------------------------------------}	function GetEdgeTSTS(isFirst: boolean; it: integer): LargestSetChars;		var oldstate: SignedByte;			H: Handle;			tsts: LargestSetChars;			statePtr: LIP;	begin		tsts:= [];		if isFirst then			H:= EWCurrentDrawBlockP^.firstEdgeTSTSH		else			H := EWCurrentDrawBlockP^.lastEdgeTSTSH;		LockHandle(H, oldstate);		statePtr := LIP(GetMaster(H)+4*(it-1));		tsts := LargestSetPointer(statePtr)^;		ResetHandle(H, oldstate);		GetEdgeTSTS := tsts;	end;{----------------------------------------------------------------------------}	procedure SizeEdgeTSTS(isFirst: boolean; totalNumTaxa: integer);		var oldstate: SignedByte;			H: Handle;	begin		if isFirst then			H:= EWCurrentDrawBlockP^.firstEdgeTSTSH		else			H := EWCurrentDrawBlockP^.lastEdgeTSTSH;		UnLockHandle(H, oldstate);		SetHandleSize(H, 4 * EWCurrentDrawBlockP^.ntax);		ResetHandle(H, oldstate);	end;{----------------------------------------------------------------------------}	procedure EmptyEdgeTSTS(isFirst: boolean);		var oldstate: SignedByte;			H: Handle;	begin		if isFirst then			H:= EWCurrentDrawBlockP^.firstEdgeTSTSH		else			H := EWCurrentDrawBlockP^.lastEdgeTSTSH;		UnLockHandle(H, oldstate);		SetHandleSize(H, 0);		ResetHandle(H, oldstate);	end;{|||||||||||||||||||||||||||   SetChars to String ||||||||||||||||||||||||||||||||||}{----------------------------------------------------------------------------}{	procedure SetToCellString (miss, gap, uncert, poly: char; symb, dest, statenames: ptr; setc: largestsetchars);	external;}{----------------------------------------------------------------------------}	function StsToString (tsts: LargestSetchars; ic: integer; statenames,useIUPAC: boolean): str255;{converts the state set tsts to a string describing the state set}		var			j: integer;			ds: str255;			dhdl: Handle;			oldstate1, oldstate2: SignedByte;{$IFC DEBUG}			sy, de, sn: str255;			ts: largestsetchars;{$ENDC}	begin		ds := '';		if tsts * [0..absmaxstate, MsL, Gal]=[] then			NewError(53, 0)		else if statenames & not (tsts <= [MSl, GAl]) then  // 4.07a: removed SSl from list			begin				if datatype = protein then					begin						LockHandle(AminoAcidNamesHdl, oldstate1);						SetToCellString(missing, gap, orsep, andsep, @symbols, @ds, Pointer(GetMaster(AminoAcidNamesHdl)), tsts);						ResetHandle(AminoAcidNamesHdl, oldstate1);					end				else					begin						LockHandle(statenamesCHUNKs, oldstate1);  {v4: all of this should be done once per character, not once per cell!}						dhdl := HdlPtr(GetMaster(statenamesCHUNKs) + HdlSize * longint(ic - 1))^;						LockHandle(dhdl, oldstate2);						SetToCellString(missing, gap, orsep, andsep, @symbols, @ds, Pointer(GetMaster(dhdl)), tsts);						ResetHandle(dhdl, oldstate2);						ResetHandle(statenamesCHUNKs, oldstate1);					end;			end		else if nucleotides & useIUPAC & not (tsts <= [MSl, GAl, SSl]) then			begin				if not (UCl in tsts) & (MultipleStatesLg(tsts)) then  {polymorphic}					begin						for j := 0 to maxstate do							if j in tsts then								ds := concat(ds, CharOfNum(j), andsep);						delete(ds, length(ds), 1);					end				else					ds := DNARNACharOfSet(tsts);			end		else			begin				{if nucleotides & (CardLg(tsts)=1) then					begin						case minLg(tsts) of							0:  ds := 'A';							1:  ds := 'C';							2:  ds := 'G';							3:  ds := 'T';						otherwise							ds := '';						end;					end				else					}					SetToCellString(missing, gap, orsep, andsep, @symbols, @ds, nil, tsts);			end;		StsToString := ds;	end;{----------------------------------------------------------------------------}	procedure CheckConvertAlternativeSymbol(isSmall, checkStorage: boolean; it,ic: integer; var ds: str255);	begin		if nucleotides then			if isSmall | (checkStorage & AlternativeSymbol(it,ic)) then				if ds ='A' then					ds := 'a'				else if ds ='C' then					ds := 'c'				else if ds ='G' then					ds := 'g'				else if ds ='T' then					ds := 't'				else if ds = missing then					ds := 'N';	end;{----------------------------------------------------------------------------}	function TaxonCharacterCellEntry (it,ic: integer; var tsts: LargestSetChars): str255;		var			ds: str255;	begin		tsts := GetTaxonStsLargest(it, ic);		if matchcharon & (it <> 1) & not (MSl in tsts) & (Gettaxonstslargest(1, ic) = tsts) then			TaxonCharacterCellEntry := matchchar		else			begin				ds := StsToString(tsts, ic, editorShowFullStateNames & not nucleotides,editorShowIUPACSymbols);				CheckConvertAlternativeSymbol(false,true,it,ic,ds);				TaxonCharacterCellEntry := ds;			end;	end;{----------------------------------------------------------------------------}	function SimpleCellEntry (it,ic: integer): str255;		var			ds: str255;			tsts: LargestSetChars;	begin		tsts := GetTaxonStsLargest(it, ic);		ds := StsToString(tsts, ic, editorShowFullStateNames & not nucleotides,false);		CheckConvertAlternativeSymbol(false,true,it,ic,ds);		SimpleCellEntry := ds;	end;{----------------------------------------------------------------------------}	function CellEntry (rownum, colnum: integer; var tsts: LargestSetChars): str255;		var			it, ic: integer;			ds: str255;	begin		TaxonCharacterFromRowColumn(it,ic,rownum,colnum);		CellEntry := TaxonCharacterCellEntry(it,ic,tsts);	end;{----------------------------------------------------------------------------}	function CellBlockEntry(cellBlock: CellBlockPtr;it,ic,pasteIC: integer; var tsts: LargestSetChars):str255;	var ds: str255;		smallSymbol: boolean;	begin		tsts := CellBlockStates(cellBlock,it,ic,pasteIC, smallSymbol);		ds := StsToString(tsts, pasteIC, editorShowFullStateNames& not nucleotides,editorShowIUPACSymbols);		CheckConvertAlternativeSymbol(smallSymbol,false,it,ic,ds);		CellBlockEntry := ds;	end;{----------------------------------------------------------------------------}	function CellString: str255;{returns string to put into editorCellTE for the currently selected single cell}{similar to CellEntry, except that it works specifically for the currently selected cell}		var			it, ic: integer;			ds :str255;	begin		it := TaxonOfCell(editorSelectionTopLeft);		ic := CharOfCell(editorSelectionTopLeft);		if (it = 0) then			CellString := Charname(ic)		else if (ic = 0) then			CellString := taxonname(it)		else			begin				ds := StsToString(GetTaxonStsLargest(it, ic), ic, editorShowFullStateNames & not nucleotides,editorShowIUPACSymbols);				CheckConvertAlternativeSymbol(false,true, it,ic,ds);				CellString := ds;			end;{note: matchchar is not considered - this is OK}	end;{|||||||||||||||||||||||||||   String to SetChars  ||||||||||||||||||||||||||||||||||}{----------------------------------------------------------------------------}	function CleanStrToSetChars (var ds: str255; var tsts: largestsetchars; LegalSet: largestsetchars; it, ic: integer): boolean;{a clean string is one with all state names removed}		label			1;		var			j: integer;			dsts: largestsetchars;			nosepfound: boolean;	begin		nosepfound := true;		if nucleotides & ((ds='N') | (ds='n')) then			tsts := tsts + [MSl,SSl]		else if not (MSl in tsts) then		{clean out rest}			for j := 1 to length(ds) do				if ds[j] = orsep then					begin						nosepfound := false;						tsts := tsts + [UCl];					end				else if ds[j] = andsep then					begin						nosepfound := false;						tsts := tsts - [UCl];					end				else if (ds[j] <> ' ') & (ds[j] <> missing) & (ds[j] <> gap) then					begin						dsts := SetOfChar(ds[j], true, it, ic);						if (dsts <= LegalSet) and not ErrorPosted(88) then							tsts := tsts + dsts						else{dsts is not in legalset or error 88 was posted}							begin								if ErrorPosted(88) then					{88 is invalid character state symbol}									BitClr(Errorsposted, 88); 	{can remove this as will be reported via badcellentry}																	{or in ChangeEdit DLOG}								CleanStrToSetChars := false;								goto 1;							end;					end;		if (MultipleStatesLg(tsts)) and nosepfound and ordefsep then			tsts := tsts + [UCl];		if (tsts = [UCl]) | (tsts = []) then   {need to put this in case someone types in only '/' to cell}			tsts := [MSl];		CleanStrToSetChars := true;1:	end;{----------------------------------------------------------------------------}	function StringToSetChars (var ds: str255; var tsts: largestsetchars; it, ic: integer): BOOLEAN;{note: currently this function is used only in ChangeEdit,}{and in this procedure ic is always 0. In Change edit, it is used for two purposes: to }{check if the string typed into the "Change:" edit text item is a valid LargestSetChars,}{and to return the value of the corresponding setchars into tsts}	begin		stripblanks(ds);		tsts := [];		if (ds = missing) or (ds = '') or (ds = ' ') then			tsts := [MSl]		else if ds = gap then			tsts := [msl, gal];		ds := MakeSmall(ds);		StringToSetChars := CleanStrToSetChars(ds, tsts, LegalSetChars(ic, true), it, ic)	end;{----------------------------------------------------------------------------}	function StateNameInString (ds, sn: str255; lds, lsn, place: integer): boolean;{ds is the string typed into the cell; sn is a statename;}{lds and lsn are the lengths of each of these strings;}{place is a position in the string ds}{this function returns true iff the string sn is contained within the string ds at position place}	begin		StateNameInString := true;		if (sn = CopyString(ds, place, lsn)) and (place > 0) and (place <= lds) and (lds > 0) and (lsn > 0) then			begin				if not ((place = 1) | (ds[place - 1] in [orsep, andsep])) then{the character before the substring is not a valid separator}					StateNameInString := false;				if not ((lds = place + lsn - 1) | (ds[place + lsn] in [orsep, andsep])) then{the character after the substring is not a valid separator}					StateNameInString := false;			end		else			StateNameInString := false;	end;{----------------------------------------------------------------------------}	function StringToSts (it, ic: integer; var ds: str255): boolean;		label			1;		var					//dtsts: largestsetchars;									charHdl: chHdl;			j, k, lsn, lds: integer;			sn: str255;			tsts: largestsetchars;			ist, place: integer;			smallSymbol: boolean;			foundyet, nosepfound, goodstring: boolean;	begin		nosepfound := true;		smallSymbol := false;		StringToSts := true;		stripblanks(ds);		if (ds = missing) or (ds = '') or (ds = ' ') then			tsts := [MSl]		else if ds = gap then			tsts := [msl, gal]		else			begin				tsts := [];				CHUNKpos := 0;				smallSymbol :=  IsAlternativeSymbolString(ds);				ds := MakeSmall(ds);				UnderLineToBlanks(ds);{    if editorShowFullStateNames & not nucleotides then	}				if not nucleotides & interpretStateNames then	{clean out recognizable names}{v4:   if protein, then use Munger in AminoAcidNameHdl for much faster processing}					for j := 0 to maxstate do						begin							sn := GetNextStateName(ic);							if sn = NoName then								cycle							else if sn = EndNames then								leave;							sn := MakeSmall(sn);							Underlinetoblanks(sn);							StripBlanks(sn);							lds := length(ds);							lsn := length(sn);							place := pos(sn, ds);							foundyet := false;							repeat								if StateNameInString(ds, sn, lds, lsn, place) then									begin										if not foundyet then											begin												foundyet := true;												tsts := tsts + [j];											end;										delete(ds, place, lsn);										lds := length(ds);									end;								place := place + 1;							until (place + lsn > length(ds) + 1) or (pos(sn, ds) = 0);							if ds = '' then								leave;						end;				goodstring := CleanStrToSetChars(ds, tsts, LegalSetChars(ic, true), it, ic);		{clean out rest}				StringToSts := goodstring;				if not goodstring then					goto 1;			end;		//dtsts := gettaxonstslargest(it, ic);				settaxonstsLargestFoot(it, ic, tsts);				//dtsts := gettaxonstslargest(it, ic); 				SetAlternativeSymbol(it,ic,smallSymbol);				//dtsts := gettaxonstslargest(it, ic);{note that it no longer seems necessary to temporarily update maxst}1:	end;{----------------------------------------------------------------------------}	procedure DrawAAfromDNACell(cell: point);	var TL, BR: point;		ic: integer;	begin		ic := CharOfCell(Cell);		TL := cell;		BR := cell;		case CharCodPos(ic) of			1: 					if editorTransposed then					BR.v := BR.v+2				else					BR.h := BR.h+2;			2:				if editorTransposed then					begin						TL.v := TL.v-1;						BR.v := BR.v+1;					end				else					begin						TL.h := TL.h-1;						BR.h := BR.h+1;					end;			3:				if editorTransposed then					TL.v := TL.v-2				else					TL.h := TL.h-2;			otherwise;		end;		DrawDataCellsBetweenCorners(TL,BR,selectionModeAsIs);	end;{-----------------------------------------------------------------------------}	function PasteCellBlock(cellBlock: CellBlockPtr; pasteState: LargestSetChars; st,et,sc,ec: integer): boolean;{pastes contents of cellBlock into the cells from st to et, sc to ec}		var			charHdl: chHdl;			it, ic: integer;			scrapPtr: Ptr;			newset, tsts: LargestSetChars;			oldstate: SignedByte;			smallSymbol: boolean;	begin		if pasteState <> [] then			begin				PasteCellBlock:= true;				for it := st to et do					for ic := sc to ec do						settaxonstsLargestOverwriteCase(it, ic, pasteState);		//				SetTaxonStsLargestFoot(it, ic, pasteState);				{if UpdateAsSensitiveToFirstTaxonChange(st) then					InvalidateCellBlock(1,numtaxa,sc, ec,false);}				CheckRedrawFullCharactersInEditor(1,numtaxa,sc, ec,true);				datachanged := true;				dirtymaxst := true;			end		else if ((cellBlock^.ntax <> et - st + 1) | (cellBlock^.nchar <> ec - sc + 1))  then			begin				PasteCellBlock:= false;				Beep;			end		else			begin				PasteCellBlock:= true;				LockHandle(cellBlock^.H, oldstate);				scrapPtr := Ptr(GetMaster(cellBlock^.H));				for it := st to et do					for ic := sc to ec do						begin							if cellBlock^.blocknumbytes = 2 then								tsts := set15to31(IP(ScrapPtr)^)							else								tsts := LargestSetPointer(ScrapPtr)^;							smallSymbol := nucleotides & (SSl in tsts);							if nucleotides then								tsts := tsts - [FTl, FPl, SSl]							else								tsts := tsts - [FTl, FPl];  {so MakeLegalSet doesn't generate error}							if not MakeLegalSet(tsts, newset, ic) then								newset := [MSl];							if tsts <> newset then								NewError(123, 0);							SetTaxonStsLargestFoot(it, ic, newset);							if nucleotides then SetAlternativeSymbol(it,ic,smallSymbol);							scrapPtr := Ptr(ord4(scrapPtr) + cellBlock^.blocktcb);						end;				{if UpdateAsSensitiveToFirstTaxonChange(st) then					InvalidateCellBlock(1,numtaxa,sc, ec,false);}				CheckRedrawFullCharactersInEditor(1,numtaxa,sc, ec,true);				ResetHandle(cellBlock^.H, oldstate);				datachanged := true;				dirtymaxst := true;			end;	end;{----------------------------------------------------------------------------}	function FindCodonBoundary (it,ic: integer; var icstart, icend: integer): boolean;	begin		FindCodonBoundary := true;		case CharCodPos(ic) of			1: 				begin					icstart := ic;					icend := ic+2;				end;			2:				begin					icstart := ic-1;					icend := ic+1;					if icstart<1 then icstart := 1;  {v4.06}				end;			3:				begin					icstart := ic-2;					icend := ic;					if icstart<1 then icstart := 1; {v4.06}				end;			otherwise				begin					icstart := 0;					icend := 0;					FindCodonBoundary := false;				end;		end;	end;{----------------------------------------------------------------------------}	function FindVisibleCodonBoundary (it,ic: integer; var icstart, icend: integer): boolean;	begin		FindVisibleCodonBoundary := true;		if CodPosSet(ic) then			begin				case CharCodPos(ic) of					1: 						begin							icstart := ic;							icend := ic+2;						end;					2:						begin							icstart := ic-1;							icend := ic+1;						end;					3:						begin							icstart := ic-2;							icend := ic;						end;					otherwise						begin							icstart := 0;							icend := 0;							FindVisibleCodonBoundary := false;						end;				end;				while not CharacterIsVisible(icstart) do					icstart := icstart+1;				while not CharacterIsVisible(icend) do					icend := icend-1;			end		else			begin				icstart := 0;				icend := 0;				FindVisibleCodonBoundary := false;			end;	end;{----------------------------------------------------------------------------}	procedure CheckRedrawFullCharactersInEditor (itstart,itend, icstart, icend: integer; cellChange: boolean);	var 	ic, icVisibleStart,icVisibleEnd: integer;		icConsensusStart, icConsensusEnd: integer;		sc,ec: integer;		oldClip: RgnHandle;		tPort: WindowPtr;		oldMOS: integer;	begin		if not editorOpen then Exit(CheckRedrawFullCharactersInEditor);		oldMOS := MOS;		if cellChange then			if  (editorColorCellsMode = editorColorCellsState) & not molecular & sameStateColorsForAllCharacters then				ReCalcMaxstAndStates(1,numchars)			else				ReCalcMaxstAndStates(icstart,icend);		icVisibleStart := 0;		icVisibleEnd := numchars;		for ic := icstart to icend do 			if CharacterIsVisible(ic) then				begin					icVisibleStart := ic;					leave;				end;		for ic := icend downto icstart do 			if CharacterIsVisible(ic) then				begin					icVisibleEnd := ic;					leave;				end;		if icVisibleStart <> 0 then			begin				genericGetPort(tport);				genericSetPort(editorWindow);				oldClip := NewRgn;				GetClip(oldClip);				SetEWClip(justdataAndConsenses);				SetClip(EWClip);				if ConsensusSequenceVisible then					begin						icConsensusStart := icVisibleStart;						icConsensusEnd := icVisibleEnd;						if nucleotides & (editorColorCellsMode = editorColorCellsAAState) then							begin								if FindVisibleCodonBoundary(itstart,icVisibleStart,sc,ec) then									icConsensusStart := sc;								if FindVisibleCodonBoundary(itstart,icVisibleEnd,sc,ec) then									icConsensusEnd := ec;							end;						WriteAllConsensesForCharacters(icConsensusStart,icConsensusEnd,writeStandardCells,selectionModeAsIs);					end;				if cellChange & (editorColorCellsMode = editorColorCellsState) & not molecular & sameStateColorsForAllCharacters & (MOS<> oldMOS) then					RedrawCharactersInEditor(1,numchars)				else if ShadeCharacterSensitiveToCellChange & cellChange then					begin						RedrawCharactersInEditor(icVisibleStart,icVisibleEnd);						if editorShadeCharSetTitle | editorShadeCharSetNumbers then							for ic := icVisibleStart to icVisibleEnd do								begin									DrawRCNumberBox(ic,not editorTransposed);									if editorTransposed then										DrawRowName(ic,selectionModeAsIs)									else										DrawColName(ic,selectionModeAsIs);								end;					end				else if EditorCellsColoredByState & not molecular  & not sameStateColorsForAllCharacters then					begin						ReCalcMaxstAndStates(icstart,icend);						RedrawCharactersInEditor(icVisibleStart,icVisibleEnd)					end				else if UpdateAsSensitiveToFirstTaxonChange(itstart) then					RedrawCharactersInEditor(icVisibleStart,icVisibleEnd);				RedrawAATranslationBlock(itstart,itend,icVisibleStart,icVisibleEnd);				SetClip(oldClip);				ZapRegion(oldClip);				genericSetPort(tport);			end;		 if cellChange then		 	begin		 		InvalidateInfoWindow(charinfo);		 		InvalidateInfoWindow(taxinfo);		 	end;	end;{----------------------------------------------------------------------------}	procedure WriteCodonTriplet (it,ic: integer; cellWritingMode: integer; selectionMode: integer; writeConsensus: boolean);	var sc,ec,ir: integer;	begin		if FindCodonBoundary(it,ic,sc,ec) then			for ir := sc to ec do 				begin					WriteTaxonCharacterCell (it,ir, false, cellWritingMode,selectionMode);					if writeConsensus& ConsensusSequenceVisible & CharacterIsVisible(ir) then						WriteAllConsensesForCharacters(ir,ir,cellWritingMode,selectionMode)					end;	end;{----------------------------------------------------------------------------}	procedure RedrawAATranslation(it,ic: integer);	var cell: point;	begin		if nucleotides then			begin				RowColumnFromTaxonCharacter(it,ic,cell.v,cell.h);				if editorShowAAwithDNA & editorColorAAwithDNA & IsCoding(ic) then 					DrawAAfromDNACell(cell);				if (editorColorCellsMode = editorColorCellsAAState) & IsCoding(ic) then					begin						WriteCodonTriplet(it,ic,writeStandardCells,selectionModeAsIs, true);					end;			end;	end;{----------------------------------------------------------------------------}	procedure RedrawAATranslationBlock(st,et,sc,ec: integer);	var it,ic: integer;	begin		for it := st to et do			begin				RedrawAATranslation(it,sc);				RedrawAATranslation(it,ec);			end	end;{----------------------------------------------------------------------------}	procedure ReturnValue (cell: point; overrideLock: boolean);{reads the text of the currently selected cell, and returns its value to memory}		var			ds: str255;			it, ic, icstart, icend: integer;			oldtsts, tsts: largestsetchars;			crgn: RgnHandle;			oldstate: SignedByte;			TL,BR: point;	begin		if Locked(lockData) & not overrideLock then				Exit(ReturnValue);		badcellentry := false;		poorentry := false;		LockHandle(editorCellTE, oldstate);		GetDialogItemText(editorCellTE^^.hText, ds);		ResetHandle(editorCellTE, oldstate);		it := TaxonOfCell(Cell);		ic := CharOfCell(Cell);		if (it > 0) and (ic > 0) then							{it's a data cell}			begin				oldtsts := gettaxonstslargest(it, ic);				badcellentry := not StringToSts(it, ic, ds);				tsts := gettaxonstslargest(it,ic);				poorentry := badcellentry;				if not badcellentry then					begin						RedrawAATranslation(it,ic);						CheckRedrawFullCharactersInEditor(it,it,ic,ic, tsts<>oldtsts);						{if ConsensusSequenceVisible & CharacterIsVisible(ic) then							WriteAllConsensesForCharacters(ic,ic,writeStandardCells,selectionModeAsIs);						if CharacterIsVisible(ic) then							if UpdateAsSensitiveToFirstTaxonChange(it) & (tsts <> gettaxonstslargest(it, ic)) then								MatchCharUpdate(ic, ic)							else if ShadeCharacterSensitiveToCellChange then								begin									ReCalcMaxstAndStates(ic,ic);									RedrawCharactersInEditor(ic,ic);								end							else if (editorColorCellsMode=editorColorCellsState) & not molecular & not sameStateColorsForAllCharacters then								begin									ReCalcMaxstAndStates(ic,ic);									RedrawCharactersInEditor(ic, ic);								end;}					end;			end		else if it > 0 then 									{it's a taxon name}			begin				SetTaxonName(it, ds);				if ErrorPosted(328) then					FillsTE(editorCellTE, TaxonName(it));				dirtytaxnames := true;				infoDirtyNames[taxinfo] := true;				if treefile then					dirtytreefile := true;   {at least the translation table is dirty}			end		else if ic > 0 then												{it's a character name}			begin				SetCharname(ic, ds);				if ErrorPosted(328) then					FillsTE(editorCellTE, CharName(ic));				infoDirtyNames[charinfo] := true;				dirtycharnames := true;				if ic = statesWindowCharacter then					InvalidateWindow(statesWindow,false);			end;		if foottexton then			AddFootText(Cell);	end;{|||||||||||||||||||||||||||   Editor drawing of cells  ||||||||||||||||||||||||||||||||||}{----------------------------------------------------------------------------}	procedure ShadeEditorCell(B: rect);	begin		if grid then			begin				B.right := B.right-editorGridThickness;				B.bottom := B.bottom-editorGridThickness;			end;		if not printon then 			ShadeSelectedRectangle(B);		if grid then			begin				B.right := B.right+editorGridThickness;				B.bottom := B.bottom+editorGridThickness;			end;	end;{----------------------------------------------------------------------------}	procedure ShadeCharSetCell(B: rect);	begin		if editorShadeCharSetLighter then			SwitchShade(muchPaler)		else			SwitchShade(muchDarker);		ShadeEditorCell(B);		SwitchShade(selectionShade);	end;{----------------------------------------------------------------------------}	procedure LightenSingleCell(B: rect);	begin		SwitchShade(paler);		ShadeEditorCell(B);		SwitchShade(selectionShade);	end;{----------------------------------------------------------------------------}	procedure ShadeCellInPartition (B: rect; ic: integer; dimFirst: boolean; doCodPos: boolean);	{I am presuming here that B is the ENTIRE rectangle for a cell, including the lower and right and grid, if any is present.}	{if no grid is present, then the colored cell will extend throughout the whole B; otherwise,	color all but the left and right edges}	var theColor: RGBColor;	begin			{	case editorColorPartitionsMode of			editorColorPartitionCodPos:}		if doCodPos then			begin				if nucleotides & SomeCodePosPartToColor then					if CharCodPos(ic)<> nonCoding then						begin							if dimFirst then								begin									SwitchShade(slightlyPaler);									ShadeSelectedRectangle(B);								end;							if CharCodPos(ic) in [1,2,3,codeNotSet] then								SetRGBShade(CharCodonPosRGB(ic));							ShadeSelectedRectangle(B);							SwitchShade(selectionShade);						end;			end		else			begin				if SomePartitionPartToColor then					if CharPartition(ic)<> defaultPartition then						begin							if dimFirst then								begin									SwitchShade(slightlyPaler);									ShadeSelectedRectangle(B);								end;							SetRGBShade(GetPartNameColor(CharPartition(ic)));							ShadeSelectedRectangle(B);							SwitchShade(selectionShade);						end;			end;{			editorColorPartitionPartition: 				;			otherwise;		end;}	end;{----------------------------------------------------------------------------}	procedure SetCodonTriplet(var codon: codontype; it,ic2: integer; nonBlock1,nonBlock2,nonBlock3,cellWritingMode,drawBlockMoveDirection: integer; var atFirstEdge,atLastEdge: boolean; isConsensus: boolean);	{nonBlock1, nonBlock2, nonBlock3: the character positions over which the codon triplet is resting.	if the the StampPasteBlock is being drawn, or if the BlockMoveTool is moving things, then one gets the triplet info	first from the block that is being moved, and second from the raw character data, and third from gaps	(at the edge of the block where cells are being exposed)	however, 	ic2: the reference to the storage element for the character data}	var tsts: LargestSetChars;		maxChars: integer;		charToUse: integer;		minChars: integer;		pasteit: integer;		dataFraction: double;		db, smallSymbol: boolean;	begin		atFirstEdge:= false;		atLastEdge := false;		minChars := 1;		if cellWritingMode=writeClipBoard then			begin					pasteit := it;				maxChars:= EWScrapBlockP^.nchar;			end		else if cellWritingMode = writeCellBlock then			begin				pasteit := it+EWCurrentDrawBlockP^.currentStartTaxa-1;				maxChars:= EWCurrentDrawBlockP^.nchar;			end		else			begin				maxChars := numchars;				pasteit := it;			end;{get first element of triplet}		if (ic2-1<minChars) then {need to get some off the left end}			begin				charToUse := nonBlock1;				if (drawBlockMoveDirection<>drawBlockMoveUp) & {(cellWritingMode= writeClipBoard) &}(charToUse>=1) & not IsGapLike(pasteit,charToUse,editorToolsTreatMissingAsGaps) & (CharCodPos(charToUse)=1)then					begin						codon[0] := PrepareTSTSforCodons(GetTaxonStsLargest(pasteit,charToUse));					end;				atFirstEdge:= true;			end		else if cellwritingMode = writeStandardCells then			begin				if CharCodPos(ic2-1)=1 then					if isConsensus then						codon[0]  := PrepareTSTSforCodons(GetConsensusSet(it,ic2-1,it=1,false,db,[MSl,GAl],dataFraction))					else						codon[0]  := PrepareTSTSforCodons(GetTaxonStsLargest(it, ic2-1));			end		else if cellWritingMode = writeCellBlock then			codon[0] := PrepareTSTSforCodons(CellBlockStates(EWCurrentDrawBlockP,it,ic2-1,ic2-1,smallSymbol))		else			codon[0] := PrepareTSTSforCodons(CellBlockStates(EWScrapBlockP,it,ic2-1,ic2-1,smallSymbol));{get second element of triplet}		if (ic2 < minChars) then			begin				charToUse := nonBlock2;				atFirstEdge:= true;				if (drawBlockMoveDirection<>drawBlockMoveUp) & {(cellWritingMode= writeClipBoard) &}(charToUse>=1) & not IsGapLike(pasteit,charToUse,editorToolsTreatMissingAsGaps) & (CharCodPos(charToUse)=2)then					begin						codon[1] := PrepareTSTSforCodons(GetTaxonStsLargest(pasteit,charToUse));					end;			end		else if (ic2> maxChars) then 			begin				atLastEdge := true;				charToUse := nonBlock2;				if (drawBlockMoveDirection<>drawBlockMoveDown) & {(cellWritingMode= writeClipBoard) &}(charToUse<=numchars) & not IsGapLike(pasteit,charToUse,editorToolsTreatMissingAsGaps) & (CharCodPos(charToUse)=2)then					begin						codon[1] := PrepareTSTSforCodons(GetTaxonStsLargest(pasteit,charToUse));					end;			end		else if cellwritingMode = writeStandardCells then			begin				if CharCodPos(ic2)=2 then					if isConsensus then						codon[1]  := PrepareTSTSforCodons(GetConsensusSet(it,ic2,it=1,false,db,[MSl,GAl],dataFraction))					else						codon[1]  := PrepareTSTSforCodons(GetTaxonStsLargest(it, ic2));			end		else if cellWritingMode = writeCellBlock then			codon[1] := PrepareTSTSforCodons(CellBlockStates(EWCurrentDrawBlockP,it,ic2,ic2,smallSymbol))		else			codon[1] := PrepareTSTSforCodons(CellBlockStates(EWScrapBlockP,it,ic2,ic2,smallSymbol));		{get third element of triplet}		if ic2+1 > maxChars then			begin				atLastEdge := true;				charToUse := nonBlock3;				if (drawBlockMoveDirection<>drawBlockMoveDown) & { (cellWritingMode= writeClipBoard) &}(charToUse<=numchars) & not IsGapLike(pasteit,charToUse,editorToolsTreatMissingAsGaps) & (CharCodPos(charToUse)=3)then					begin						codon[2] := PrepareTSTSforCodons(GetTaxonStsLargest(pasteit,charToUse));					end;			end		else if cellwritingMode = writeStandardCells then			begin				if CharCodPos(ic2+1)=3 then					if isConsensus then						codon[2]  := PrepareTSTSforCodons(GetConsensusSet(it,ic2+1,it=1,false,db,[MSl,GAl],dataFraction))					else						codon[2]  := PrepareTSTSforCodons(GetTaxonStsLargest(it, ic2+1));			end		else if cellWritingMode = writeCellBlock then			codon[2] := PrepareTSTSforCodons(CellBlockStates(EWCurrentDrawBlockP,it,ic2+1,ic2+1,smallSymbol))		else			codon[2] := PrepareTSTSforCodons(CellBlockStates(EWScrapBlockP,it,ic2+1,ic2+1,smallSymbol));	end;{----------------------------------------------------------------------------}	procedure PrepareAAfromDNA(it,ic,pasteIC: integer; var tsts: LargestSetChars; isConsensus: boolean;cellWritingMode: integer);	{ic is the number of the character that whose states are being drawn;	pasteIC is the position of the cell being drawn}	var	codon: codontype;		 ds: str255;		j: integer;		 drawBlockMoveDirection : integer;		 hasGap, atFirstEdge,atLastEdge, turnIntoUncertainty : boolean;	begin		{figure out if going up or down...}		atFirstEdge:= false;		atLastEdge := false;		drawBlockMoveDirection := drawBlockMoveOff;		codon[0]:= PrepareTSTSforCodons([MSl, GAl]);		codon[1]:= PrepareTSTSforCodons([MSl, GAl]);		codon[2]:= PrepareTSTSforCodons([MSl, GAl]);		case charCodPos(pasteIC) of			1:				SetCodonTriplet(codon,it,ic+1,pasteIC,pasteIC+1,pasteIC+2,cellWritingMode,drawBlockMoveDirection, atFirstEdge,atLastEdge,isConsensus);  			2: 				SetCodonTriplet(codon,it,ic,pasteIC-1,pasteIC,pasteIC+1,cellWritingMode,drawBlockMoveDirection, atFirstEdge,atLastEdge,isConsensus);			3:				SetCodonTriplet(codon,it,ic-1,pasteIC-2,pasteIC-1,pasteIC,cellWritingMode,drawBlockMoveDirection, atFirstEdge,atLastEdge,isConsensus);			otherwise				;		end;		hasGap := false;		for j := 0 to 2 do			if GAl in codon[j] then				begin					hasGap := true;					leave;				end;		turnIntoUncertainty := true;		if ((CardLg(codon[0])>1) & not (UCl in codon[0])) | ((CardLg(codon[1])>1) & not (UCl in codon[1])) | ((CardLg(codon[2])>1) & not (UCl in codon[2])) then			{at least one thing is polymorphic}			if ([UCl,MSl] * codon[0]=[]) &  ([UCl,MSl] * codon[1]=[]) &  ([UCl,MSl] * codon[2]=[]) then  {none are missing, gap, or uncertain}				turnIntoUncertainty := false;						tsts := AAFromCodon(codon, false);		if hasGap & (tsts<>[MSl,GAl]) then tsts := [];		if turnIntoUncertainty & (CardLg(tsts)>1) & (tsts <> [MSl,GAl]) then 			tsts := tsts + [UCl];  {force it to be uncertainty}				if (cellWritingMode = writeCellBlock) then			begin				if atFirstEdge then EWCurrentDrawBlockP^.firstEdgeTSTS := tsts;				if atLastEdge then EWCurrentDrawBlockP^.lastEdgeTSTS := tsts;				if atFirstEdge then SetEdgeTSTS(true,it,tsts);				if atLastEdge then SetEdgeTSTS(false,it,tsts);			end;		 			end;{----------------------------------------------------------------------------}	procedure SetCellColorToState(B: rect; tsts: LargestSetChars; pasteIC, colorMode: integer; colorAAs, dim: boolean);	const dimFraction = 0.60;	var theColor: RGBColor;	begin		if (CardLg(tsts)=1)then			begin				if nucleotides & (colormode=editorColorCellsPurPyr) then					if tsts*purine<>[] then						theColor := purRGB					else						theColor := pyrRGB				else if colorAAs then					theColor := proteinColorKey^[MinLg(tsts)]				else					theColor := GetCellColor(pasteic,tsts);				if dim then					theColor := DimColor(theColor,dimFraction);				RGBForeColor(theColor);				if editorColorCellsByFillRect then					begin						FillRect(B, QDBlack);						RGBForeColor(blackRGB);					end;			end		else			begin				//d := CardLg(tsts);				theColor := polyMorphColor;				if dim then					theColor := DimColor(theColor,dimFraction);				RGBForeColor(polyMorphColor);				if editorColorCellsByFillRect then					begin						FillRect(B, QDBlack);						RGBForeColor(blackRGB);					end;			end;	end;{----------------------------------------------------------------------------}	procedure ColorCell (B: rect; tsts: largestsetchars;it,ic, pasteic, colorMode: integer; selected, colorAAs, isConsensus: boolean; cellWritingMode: integer);	{I am presuming here that B is the ENTIRE rectangle for a cell, including the lower and right and grid, if any is present.}	{if no grid is present, then the colored cell will extend throughout the whole B; otherwise,	color all but the left and right edges}	var theColor: RGBColor;		aaTSTS: largestSetChars;		d: integer;	begin		{GRID:}{InsetRect(B, 2, 0);		B.top := B.top + 1;}		if grid then 			begin				B.right := B.right-editorGridThickness;				B.bottom := B.bottom-editorGridThickness;			end;{:GRID}				case colorMode of			editorColorCellsMatchFirst:				if not (MSl in tsts) & (((it = 1) & (cellWritingMode=writeStandardCells)) | (Gettaxonstslargest(1, pasteic) = tsts)) then					begin						RGBForeColor(GrayScale(5,2));						if editorColorCellsByFillRect then							begin								FillRect(B, QDBlack);								RGBForeColor(blackRGB);							end;					end;			editorColorCellsAAState:				begin					 PrepareAAfromDNA(it,ic,pasteic,aaTSTS,isConsensus,cellWritingMode);					SetStateSetBoundaries(false);					if (aaTSTS=[])  then						begin							if (tsts<>[]) & not (MSl in tsts) then								SetCellColorToState(B,tsts, pasteic, colorMode, false,true);						end					else  if (MSl in aaTSTS) then						begin							if (tsts<>[]) & not (MSl in tsts) then								SetCellColorToState(B,tsts, pasteic, colorMode, false,true);						end					else	if not (MSl in aaTSTS) then						if (CardLg(aaTSTS)=1)then							begin								theColor := proteinColorKey^[MinLg(aaTSTS)];								RGBForeColor(theColor);								if editorColorCellsByFillRect then									begin										FillRect(B, QDBlack);										RGBForeColor(blackRGB);									end;							end						else							begin								RGBForeColor(polyMorphColor);								if editorColorCellsByFillRect then									begin										FillRect(B, QDBlack);										RGBForeColor(blackRGB);									end;							end;					SetStateSetBoundaries(nucleotides);				end;			editorColorCellsState, editorColorCellsPurPyr:				if (tsts=[])  then					begin						if colorAAs then							begin								RGBForeColor(GrayScale(5,1));								if editorColorCellsByFillRect then									begin										FillRect(B, QDBlack);										RGBForeColor(blackRGB);									end;							end;					end				else 	if not (MSl in tsts) then					begin						if colorAAs then							SetStateSetBoundaries(false);						SetCellColorToState(B,tsts, pasteic, colorMode, colorAAs,false);						if colorAAs then							SetStateSetBoundaries(true);					end;			{editorColorCellsCodPos:				if CharCodPos(pasteic)<> nonCoding then					begin						case CharCodPos(pasteic) of							1: 	RGBForeColor(blueRGB);							2: 	RGBForeColor(greenRGB);							3:  	RGBForeColor(redRGB);							codeNotSet:  	RGBForeColor(codeNotSetRGB);							otherwise;						end;						FillRect(B, QDBlack);						RGBForeColor(blackRGB);					end}			otherwise;		end;				{ if tsts = ColorCellSet then			begin				ForeColor(redcolor);				FillRect(B, QDBlack);				ForeColor(blackcolor);			end;}	end;{----------------------------------------------------------------------------}	function AASymbolsInAAwithDNACell(ic: integer; tsts: LargestSetChars): str255;	var		ds: str255;		oldDataType: integer;		oldSymbols: str255;	begin		ds := '*';		if tsts = [MSl,GAl] then			ds[1] := gap		else			{ds[1] := ProteinCharOfSet(tsts);}			begin				oldDataType := datatype;				datatype:= protein;				oldSymbols := symbols;				symbols := protsymbols;				SetStateSetBoundaries(false);				ds := StsToString (tsts,ic, editorShowFullStateNames,false);				SetStateSetBoundaries(nucleotides);				datatype := oldDataType;				symbols := oldSymbols;			end;		AASymbolsInAAwithDNACell := ds;	end;{----------------------------------------------------------------------------}	procedure DrawAASymbolsInAAwithDNACell(ic: integer; B: rect; tsts: LargestSetChars);	var		ds: str255;		hor, vert: integer;	begin		ds := AASymbolsInAAwithDNACell(ic,tsts);		hor := B.left + ((B.right - B.left) - StringWidth(ds)) div 2;		vert := B.bottom - editorFontDescent;		moveto(hor, vert);		DrawString(ds);	end;{----------------------------------------------------------------------------}	procedure WriteSingleAAwithDNACell(it, icstart,icend: integer; tsts: LargestSetChars);	{this is used either to draw the extra AA line when moving blocks, or to color the nucleotides with aa colors}	var ic, ic2,d: integer;		B: rect;		oldClip: RgnHandle;		cellRgn: RgnHandle;	begin		ic2 := -1;		for ic := icstart to icend do			if CharCodPos(ic) = 2 then				begin					ic2 := ic;				end;		if editorTransposed then			begin				B:= CellRect(it,icstart);				CellVer(icend,d,B.bottom,false);				if editorShowAAwithDNA then B.left := B.right - editorColumnWidth div 2;			end		else			begin				B:= CellRect(icstart,it);				CellHor(icend,d,B.right,false);				if editorShowAAwithDNA then B.top := B.bottom - editorLineWidth div 2;			end;				if RectInRgn(B, EWClip)|printon then  {this is never done offscreen, so don't need to ask "if offscreen |"}			begin				oldClip := NewRgn;				GetClip(oldClip);				cellRgn:= NewRgn;				if editorShowAAwithDNA & editorColorAAwithDNA then  					begin						if CharCodPos(icend) <> 3 then							if editorTransposed then								B.bottom := B.bottom + editorGridThickness							else								B.right := B.right + editorGridThickness;						if MSl in tsts then							begin								if grid then									if not editorTransposed then										B.bottom := B.bottom - editorGridThickness									else										B.right := B.right - editorGridThickness;							end;					end;				SetEWClip(justdata);				RectRgn(cellRgn,B);				SectRgn(cellRgn,EWClip,cellRgn);				SetClip(cellRgn);				SetEWClip(noscroll);				if editorShowAAwithDNA & editorColorAAwithDNA then  					if MSl in tsts then						EraseRect(B)  					else						ColorCell(B,  tsts, it,0,0,editorColorCellsState, false, true, false,writeStandardCells);				if (ic2<> -1) & (tsts <> []) then					begin						if editorTransposed then							begin								B:= CellRect(it,ic2);								B.left := B.right - editorColumnWidth div 2;							end						else							begin								B:= CellRect(ic2,it);								B.top := B.bottom - editorLineWidth div 2;							end;						DrawAASymbolsInAAwithDNACell(ic,B,tsts);					end;				SetClip(oldClip);				ZapRegion(oldClip);				ZapRegion(cellRgn);			end;	end;{----------------------------------------------------------------------------}	procedure WriteColorAAwithDNA(it, icstart,icend: integer; tsts: LargestSetChars);	{this is used either to draw the extra AA line when moving blocks, or to color the nucleotides with aa colors}	var ic, ic2,d: integer;		B: rect;		oldClip: RgnHandle;		cellRgn: RgnHandle;	begin		if editorShowAAwithDNA then 			WriteSingleAAwithDNACell(it,icstart,icend, tsts)		{else			for ic := icstart to icend do				WriteTaxonCharacterCell (it,ic,false,writeCellBlock,selectionModeAsIs)};	end;{----------------------------------------------------------------------------}	procedure WriteAAwithDNA(B: rect; it,ic,pasteIC: integer; tsts: LargestSetChars; offscreen,isConsensus: boolean;cellWritingMode: integer);	{ic is the number of the character whose states are being drawn;	pasteIC is the position of the cell being drawn}	var sc,ec: integer;	begin		PrepareAAfromDNA(it,ic,pasteIC,tsts,isConsensus,cellWritingMode);		 				if editorTransposed then 			begin				OffsetRect(B,editorColumnWidth div 2,0);			end		else 			begin				OffsetRect(B,0,editorLineWidth div 2);  {shift down so that state is drawn in cell below nucleotides}{$IFC FALSE}				if (CardLg(tsts)>1) & FindVisibleCodonBoundary(it,pasteIC,sc,ec) then  {let's expand the box so that it covers the whole area}					begin						if sc = pasteIC-1 then							B.left := B.left-editorColumnWidth;						if ec = pasteIC+1 then							B.right := B.right + editorColumnWidth;					end;{$ENDC}			end;		if editorColorAAwithDNA then			begin				if not offScreen then					ClipREct(B);				if CharCodPos(pasteIC) <> 3 then					B.right := B.right + editorGridThickness;				{if (CardLg(tsts)=1) & (CharCodPos(pasteIC) < 3) then}					ColorCell(B,  tsts, it,0,0,editorColorCellsState, false, true, isConsensus,cellWritingMode);			end;		if (CharCodPos(pasteIC) = 2) & (tsts <> []) & editorShowCellSymbol then			DrawAASymbolsInAAwithDNACell(pasteIC,B,tsts);	end;{----------------------------------------------------------------------------}	function DarkenEditorGridLine(pasteic: integer): boolean;	begin		DarkenEditorGridLine := (pasteic mod 10 = 0);	end;{----------------------------------------------------------------------------}	procedure WriteCell (B: rect; rownum, colnum: integer; pasteIC: integer; selected, offScreen, eraseBox: boolean; cellWritingMode: integer);		var			tport: windowPtr;			ds: str255;			c: char;			fullB: rect;			isfoot, ispict: boolean;			doColorCell: boolean;			it,ic, maxChars, consensusSequence: integer;			isSingleChar,isConsensus,trueMajority, consensusDim: boolean;			box: rect;			clipRgn: RgnHandle;			theConsensus: ConsensusPtr;			tsts: LargestSetChars;			dataFraction: double;			darkenEditorEvery10th: boolean;			dimLowerCaseNuc: boolean;	begin		if offScreen | RectInRgn(B, EWClip)| printon then			begin				if not offscreen & not printon then					begin						genericGetPort(tport);						genericSetPort(editorWindow);					end;				isfoot := false;				ispict := false;				consensusDim := false;				dataFraction := 1.0;				isConsensus := false;				if (rownum < -1) then					begin						isConsensus := true;						ConsensusSequenceFromRowColumn(consensusSequence,rownum);						ic := colnum;					end				else if (colnum<-1) then 					begin						isConsensus := true;						ConsensusSequenceFromRowColumn(consensusSequence,colnum);						ic := rownum;					end				else TaxonCharacterFromRowColumn(it,ic, rownum,colnum);				if pasteIC = -1 then 					pasteIC := ic;				case cellWritingMode of					 	writeGapCells:							begin								ds := gap;								tsts := [MSl, GAl];							end;						writeMissingCells:							begin								ds := missing;								tsts :=[MSl];							end;						writeClipBoard:							begin								{TaxonCharacterFromRowColumn(it,ic, rownum,colnum);}								{if pasteIC = -1 then pasteIC := ic;}								ds := CellBlockEntry(EWScrapBlockP,it,ic,pasteIC,tsts);							end;						writeCellBlock:							begin								{TaxonCharacterFromRowColumn(it,ic, rownum,colnum);}								{if pasteIC = -1 then pasteIC := ic;}								ds := CellBlockEntry(EWCurrentDrawBlockP,it,ic,pasteIC,tsts);							end;					otherwise						if isConsensus then							begin								{if consensusSequence = 1 then }								tsts := GetConsensusSet(consensusSequence,ic,consensusSequence=1,false,trueMajority,[],dataFraction);								theConsensus := Consensus(consensusSequence);								consensusDim := (dataFraction < 1.0) & (theConsensus<> nil) &((theConsensus^.dimProportionalToFreq)|(theConsensus^.dimProportionalToNonGaps));								if tsts = [] then									ds := ''								else 									ds := StsToString(tsts, ic, editorShowFullStateNames & not nucleotides,nucleotides);							end						else							ds := CellEntry(rownum, colnum, tsts);				end;				isSingleChar := length(ds)=1;				if isSingleChar then						c:= ds[1];				dimLowerCaseNuc := editorColorCellsDimLowerCase & nucleotides & isSingleChar & (ord(c)>=ord('a')) &  (ord(c)<=ord('z'));				if not offScreen then					begin						GetClip(oldGlobalClip);						ClipREct(B);					end;				if eraseBox | (isConsensus & ((tsts = [])|(CardLg(tsts)>1))) then 					begin						box := B;						{GRID:}{InsetRect(box, 2, 0);						box.top := box.top + 1;} {:GRID}						{InsetRect(box,0,1);						box.bottom := box.bottom + 1;}						EraseRect(box);					end;										if grid then					begin						if AAAutoTranslationVisible then 							begin								PenNormal;								moveto(B.right-editorGridThickness, B.bottom-editorGridThickness- editorLineWidth div 2);								GridLineTo(B.left, B.bottom-editorGridThickness- editorLineWidth div 2, false);								moveto(B.left, B.bottom-editorGridThickness);								if isConsensus then									LineTo(B.right-editorGridThickness, B.bottom- editorGridThickness)								else									GridLineTo(B.right-editorGridThickness, B.bottom- editorGridThickness, false);								if cellWritingMode=writeClipBoard then									maxChars:= EWScrapBlockP^.nchar								else if cellWritingMode=writeCellBlock then									maxChars := EWCurrentDrawBlockP^.nchar								else									maxChars := numchars;								if  (CharCodPos(pasteIC) = 3) | ( (pasteIC<maxChars)&not IsCoding(pasteIC) & (CharCodPos(pasteIC+1)=1))then									begin										if not editorTransposed then											begin												moveto(B.right-editorGridThickness, B.top);												LineTo(B.right-editorGridThickness, B.bottom-editorGridThickness);											end;									end								else									begin										moveto(B.right-editorGridThickness, B.top);										GridLineTo(B.right-editorGridThickness, B.bottom-editorGridThickness- editorLineWidth div 2, false);									end;							end						else							begin								moveto(B.right-editorGridThickness, B.top);								if isConsensus then									begin										if editorTransposed then											begin												LineTo(B.right-editorGridThickness, B.bottom-editorGridThickness);												GridLineTo(B.left, B.bottom-editorGridThickness, false);											end										else											begin												GridLineTo(B.right-editorGridThickness, B.bottom-editorGridThickness, false);												LineTo(B.left, B.bottom-editorGridThickness);											end;									end								else									begin										GridLineTo(B.right-editorGridThickness, B.bottom-editorGridThickness, false);										GridLineTo(B.left, B.bottom-editorGridThickness,  false);									end;							end;					end;				{else if not grid & darkenEditorEvery10th & not AAAutoTranslationVisible & DarkenEditorGridLine(pasteic) then					begin						if editorTransposed then							begin								moveto(B.right-editorGridThickness, B.bottom-editorGridThickness);								GridLineTo(B.left, B.bottom-editorGridThickness,  true);							end						else							begin								moveto(B.right-editorGridThickness, B.top);								GridLineTo(B.right-editorGridThickness, B.bottom-editorGridThickness, true);							end;					end;}				if AAAutoTranslationVisible then					B.bottom := B.top + editorLineWidth div 2;				doColorCell := ((cellWritingMode = writeCellBlock)|(cellWritingMode = writeStandardCells)|(cellWritingMode = writeClipBoard)) & ((editorColorCellsMode<>editorColorCellsOff) & not ((editorColorCellsMode=editorColorCellsMatchFirst) & isConsensus) | ColorSetCells) {& (offScreen  | not CellInSelection(rownum,colnum))};				if doColorCell then					if isConsensus then						ColorCell(B,  tsts, consensusSequence, ic, pasteic, editorColorCellsMode, selected, false, isConsensus, cellWritingMode)					else						ColorCell(B,  tsts, it, ic, pasteic, editorColorCellsMode, selected, false, isConsensus, cellWritingMode);				if  editorColorCodPosCells then					ShadeCellInPartition(B,ic,editorColorCellsMode=editorColorCellsState,true);				if  editorColorPartitionCells then					ShadeCellInPartition(B,ic,editorColorCellsMode=editorColorCellsState,false);									if not offScreen & not isConsensus then					begin						isfoot := ((not editorTransposed & footpresent(rownum, colnum)) | (editorTransposed & footpresent(colnum, rownum)));						ispict := ((not editorTransposed & footpictpresent(rownum, colnum)) | (editorTransposed & footpictpresent(colnum, rownum)));					end;				if (not offScreen & (isfoot | ispict))| (cellWritingMode=writeClipBoard) | (doColorCell & not editorColorCellsByFillRect) {| selected} then					Textface([bold]);				{if selected then					ForeColor(whitecolor);}				if editorShowCellSymbol & (ds<>'') then					if isSingleChar then						begin							moveto(B.left + ((B.right - B.left) - CharWidth(c)) div 2, B.bottom - editorFontDescent);							DrawChar(c);						end					else						begin							moveto(B.left + ((B.right - B.left) - StringWidth(ds)) div 2, B.bottom - editorFontDescent);							DrawString(ds);						end;				if (isfoot or ispict) and not offScreen then					begin						Textface([]);						if isfoot then							drawchar(footTextFlag);						if ispict then							drawchar(footPictFlag);					end;				if  editorShadeCharSetCells & ((((cellWritingMode=writeStandardCells) & ShadeCharacter(ic))|(((cellWritingMode=writeClipBoard) |(cellWritingMode=writeCellBlock)) & (ShadeCharacter(pasteIC))))) then					ShadeCharSetCell(B);				if dimLowerCaseNuc then					LightenSingleCell(B);				if selected then					begin						fullB := B;						if AAAutoTranslationVisible then							if editorTransposed then 								fullB.right := fullB.right +editorColumnWidth div 2							else 								fullB.bottom := fullB.bottom + editorLineWidth div 2;					end				else 					begin						if consensusDim then							begin								SetShade(false, dataFraction);								ShadeEditorCell(B);								SwitchShade(selectionShade);							end;						if (AAAutoTranslationVisible & editorDimDNAwithAA  & ((cellWritingMode = writeCellBlock)|(cellWritingMode=writeStandardCells) | (cellWritingMode=writeClipboard)) ) then							begin								SwitchShade(paler);								ShadeEditorCell(B);								SwitchShade(selectionShade);							end;					end;				if (cellWritingMode = writeCellBlock)|(cellWritingMode=writeStandardCells) | (cellWritingMode=writeClipboard) then					if AAAutoTranslationVisible then						if isConsensus then							WriteAAwithDNA(B, consensusSequence,ic,pasteIC, tsts, offScreen, true,cellWritingMode)						else							WriteAAwithDNA(B, it,ic,pasteIC, tsts, offScreen, false,cellWritingMode);				RGBForeColor(blackRGB);				if not offScreen then					begin						SetClip(oldGlobalClip);					end;				if selected then					ShadeSelectedRectangle(fullB);				if isConsensus & (consensusSequence=editorNumConsensusSequences) then {it is the last one}					if editorTransposed then						begin							if AAAutoTranslationVisible then B.right := B.right +editorColumnWidth div 2;							PenSize(consensusBoundaryLineThickness,1);							MoveTo(B.right,B.top);							LineTo(B.right,B.bottom);							PenNormal;						end					else						begin							if AAAutoTranslationVisible  then B.bottom := B.bottom +editorLineWidth div 2;							PenSize(1,consensusBoundaryLineThickness);							MoveTo(B.left,B.bottom);							LineTo(B.right,B.bottom);							PenNormal;						end;				if not offscreen  & not printon then					genericSetPort(tport);			end;	end;{----------------------------------------------------------------------------}	procedure WriteTaxonCharacterCell (it,ic: integer; offScreen: boolean; cellWritingMode: integer; selectionMode: integer);	var box: rect;		rownum,colnum: integer;	begin		RowColumnFromTaxonCharacter(it,ic,rownum,colnum);		box := CellRect(colnum, rowNum);		case selectionMode of			selectionModeAsIs:				WriteCell(box, rownum, colnum, -1, CellInSelection(rownum,colnum), false, true, cellWritingMode);			selectionModeOn:				WriteCell(box, rownum, colnum, -1, true, false, true, cellWritingMode);			selectionModeOff:				WriteCell(box, rownum, colnum, -1, false, false, true, cellWritingMode);			otherwise;		end;	end;{----------------------------------------------------------------------------}	procedure WriteConsensusCell (consensusNumber,ic: integer; offScreen: boolean; cellWritingMode: integer; selectionMode: integer);	var box: rect;		rowColumn: integer;		selected, doErase: boolean;	begin		selected := (selectionMode=selectionModeOn)|((selectionMode=SelectionModeAsIs) &ConsensusSelected(consensusNumber));		doErase := (editorColorCellsMode <> editorColorCellsState);		RowColumnFromConsensusSequence(rowColumn,consensusNumber);		if editorTransposed then				begin				box := CellRect(rowColumn, ic);				WriteCell(box,ic, rowColumn, -1, selected, false,doErase,cellWritingMode);			end		else			begin				box := CellRect(ic,rowColumn);				WriteCell(box,rowColumn, ic, -1, selected, false, doErase,cellWritingMode);			end;	end;{----------------------------------------------------------------------------}	procedure WriteAllConsensesForCharacters (icstart,icend: integer; cellWritingMode: integer; selectionMode: integer);	var j: integer;		ic: integer;	begin		for j := 1 to editorNumConsensusSequences do			for ic := icstart to icend do				WriteConsensusCell(j,ic,false,cellWritingMode,selectionMode);	end;{----------------------------------------------------------------------------}	procedure DrawRowName (rownum: integer; selectionMode: integer);{draws name of row}	label 1;		var			B: REct;			top, bottom,consensusSequence: integer;			isfoot, ispict, isConsensus: boolean;			oldBack: RGBColor;	begin		if (rownum>editorTotalRows) then			Exit(DrawRowName);		isConsensus:= rownum <-1;		if isConsensus then			ConsensusSequenceFromRowColumn(consensusSequence,rownum);		CellVer(rownum, top, bottom, true);		B := CellRect(0,rownum);		PenNormal;		{InsetRect(B, 1, 0);  was 1,1}		if isConsensus then 			begin				B.left := 0;				B.bottom := B.bottom+consensusBoundaryLineThickness+1;			end;		if isConsensus then			ClipRect(B)		else			ClipEditBox(B);		if isConsensus then 			begin				B.bottom := B.bottom-consensusBoundaryLineThickness-1;				{GetRGBSetTingeBackground(oldBack, yellowTinge);}			end;		EraseRect(B);		if isConsensus then			begin				{SetRGBBackground(oldBack);}				if (selectionMode=selectionModeOn) | ((selectionMode=selectionModeAsIs)&ConsensusSelected(consensusSequence)) then					ShadeSelectedRectangle(B);			end		else if (selectionMode=selectionModeOn) | ((selectionMode=selectionModeAsIs)&CellInSelection(rownum,0)) then			ShadeSelectedRectangle(B);		PenSize(editorGridThickness+editorExtraGridThickness,1);		moveTo(B.right-editorGridThickness-editorExtraGridThickness, B.top);		lineTo(B.right-editorGridThickness-editorExtraGridThickness, B.bottom-editorGridThickness);		PenNormal;		{if grid then}		if isConsensus then			begin				if editorNumConsensusSequences = consensusSequence then					PenSize(1,consensusBoundaryLineThickness+editorGridThickness);				moveTo(0, B.bottom-editorGridThickness);				LineTo(B.right,B.bottom-editorGridThickness);				PenNormal;			end		else			begin				moveTo(B.left, B.bottom-editorGridThickness);				GridLineTo(B.right-editorGridThickness-editorExtraGridThickness-1,B.bottom-editorGridThickness, false);			end;		B.right := B.right - editorGridThickness-editorExtraGridThickness;		if grid then			B.bottom := B.bottom-editorGridThickness;		if isConsensus then			ClipRect(B)		else			ClipEditBox(B);		if AAAutoTranslationVisible & not editorTransposed then 			moveto(B.left + 8, B.bottom - editorFontDescent-editorLineWidth div 2)		else			moveto(B.left + 8, B.bottom - editorFontDescent);		if isConsensus then			begin				TextFace([italic]);				//ClipRect(WindowPortRect(editorWindow));				DrawString(GetConsensusName(consensusSequence));				TextFace([]);			end		else 			begin				isfoot := (not editorTransposed & footpresent(rownum, 0)) | (editorTransposed & footpresent(0, rownum));				ispict := (not editorTransposed & footpictpresent(rownum, 0)) | (editorTransposed & footpictpresent(0, rownum));				if isfoot or ispict then					Textface([bold]);				if not editorTransposed then					begin						if ItalicTaxon(rownum) then							TextFace(QDThePortTextFace + [italic]);						if showtaxname then 							DrawString(TaxonName(rownum))					end				else					begin						DrawString(Charname(rownum));						if editorColorCodPosTitle then							ShadeCellInPartition(B,rownum,false, true);						if editorColorPartitionTitle then							ShadeCellInPartition(B,rownum,false, false);						if ShadeCharacter(rownum) & editorShadeCharSetTitle then							ShadeCharSetCell(B);					end;				Textface([]);				if isfoot then					drawchar(footTextFlag);				if ispict then					drawchar(footPictFlag);			end;		SEtClip(EWClip);1:	end;{----------------------------------------------------------------------------}	procedure DrawColName (colnum: integer; selectionMode: integer);	label 1;		var			B: REct;			right, left,consensusSequence: integer;			isfoot, ispict, isConsensus: boolean;	begin		if (colnum>editorTotalColumns)  then			Exit(DrawColName);		isConsensus := colnum<-1;		if isConsensus then			ConsensusSequenceFromRowColumn(consensusSequence,colnum);		CellHor(colnum, left, right, true);				B := CellRect(colnum,0);		PenNormal;		if isConsensus then 			begin				B.top := 0;				B.right := B.right+consensusBoundaryLineThickness+1;			end;		{InsetRect(B, 1, 1);}		if isConsensus then			ClipRect(B)		else			ClipEditBox(B);		if isConsensus then 			B.right := B.right-consensusBoundaryLineThickness-1;		EraseRect(B);		if (selectionMode=selectionModeOn) | ((selectionMode=selectionModeAsIs)&CellInSelection(0,colnum)) then			ShadeSelectedRectangle(B);					PenSize(1, editorGridThickness+editorExtraGridThickness);		moveTo(B.left, B.bottom-editorGridThickness-editorExtraGridThickness);		lineTo(B.right-editorGridThickness, B.bottom-editorGridThickness-editorExtraGridThickness);		PenNormal;		{if grid then}		if isConsensus then			begin				if editorNumConsensusSequences = consensusSequence then					PenSize(consensusBoundaryLineThickness,1);				moveTo(B.right-editorGridThickness, 0);				LineTo(B.right-editorGridThickness,B.bottom);				PenNormal;			end		else			begin				moveTo(B.right-editorGridThickness, B.top);				GridLineTo(B.right-editorGridThickness,B.bottom-editorGridThickness-editorExtraGridThickness-1, false);			end;		{B.right := B.right - 3;		ClipEditBox(B);}		if vertMatrixNames then			moveto(B.right - editorColumnWidth div 2 + editorFontDescent + 1, B.bottom - editorFontDescent)		else			moveto(B.left + 2, B.bottom - editorFontDescent);		if isConsensus then			begin				TextFace([italic]);				if vertMatrixNames then					VerticalString(GetConsensusName(consensusSequence), true)				else					DrawString(GetConsensusName(consensusSequence));				Textface([]);			end		else 			begin				isfoot := (not editorTransposed & footpresent(0, colnum)) | (editorTransposed & footpresent(colnum, 0));				ispict := (not editorTransposed & footpictpresent(0, colnum)) | (editorTransposed & footpictpresent(colnum, 0));				if isfoot or ispict then					Textface([bold]);				if editorTransposed then					begin						if ItalicTaxon(colnum) then							TextFace(QDThePortTextFace + [italic]);						if showtaxname then							if vertMatrixNames then								VerticalString(TaxonName(colnum), true)							else								DrawString(TaxonName(colnum))					end				else 					begin						if vertMatrixNames then							VerticalString(Charname(colnum), true)						else							DrawString(Charname(colnum));						if editorColorCodPosTitle then							ShadeCellInPartition(B,colnum,false, true);						if editorColorPartitionTitle then							ShadeCellInPartition(B,colnum,false, false);						if ShadeCharacter(colnum) & editorShadeCharSetTitle then							ShadeCharSetCell(B);					end;				Textface([]);				if isfoot then					drawchar(footTextFlag);				if ispict then					drawchar(footPictFlag);			end;		SetClip(EWClip);1:		end;{----------------------------------------------------------------------------}	procedure DrawRCNumberBox (rcnum: integer; row: boolean);		var			ds: str255;			drawNumber: boolean;			B: rect;			left, right, top, bottom: integer;	begin		if row then 			begin				drawNumber := ((Showtaxnum and not editorTransposed) or (showcharnum and editorTransposed));				B := CellRect(-1, rcnum);			end		else			begin				drawNumber := (Showcharnum and not editorTransposed) or (showtaxnum and editorTransposed);				B := CellRect(rcnum,-1);			end;		DressUpBox(B);		if (rcnum <= numchars) & ((not editorTransposed & not row) | (editorTransposed & row)) then			begin				if editorColorCodPosNumbers then ShadeCellInPartition(B,rcnum,false,true);				if editorColorPartitionNumbers then ShadeCellInPartition(B,rcnum,false,false);				if editorShadeCharSetNumbers & ShadeCharacter(rcnum) then					ShadeCharSetCell(B);			end;		Textface([bold]);		if drawNumber &  (RectInRgn(B, EWClip)|printon) & ((B.right-B.left)>CharWidth('1')) then			begin				NumToString(rcnum, ds);				{if not printon & ColorPort & (editorColorCodPossMode=editorColorCodPossCodPos) & nucleotides & (rcnum <= numchars) & ((not editorTransposed & not row) | (editorTransposed & row)) then					case GetchHdl(rcnum)^^.codpos of						1: 	RGBForeColor(blueRGB);						2: 	RGBForeColor(greenRGB);						3:  	RGBForeColor(redRGB);						codeNotSet:  	RGBForeColor(codeNotSetRGB);						nonCoding:  	RGBForeColor(blackRGB);						otherwise							;					end;}				GetClip(oldGlobalClip);				ClipREct(B);				if AAAutoTranslationVisible & (row & not editorTransposed) then					moveto(B.left + ((B.right - B.left) - Stringwidth(ds)) div 2, B.bottom - editorFontDescent - editorLineWidth div 2)				else					moveto(B.left + ((B.right - B.left) - Stringwidth(ds)) div 2, B.bottom - editorFontDescent);				drawstring(ds);				SetClip(oldGlobalClip);				ForeColor(blackcolor);			end;		Textface([]);	end;{----------------------------------------------------------------------------}	procedure RedrawCharactersInEditor (icstart, icend: integer);		var			tport: WindowPtr;			box: rect;			di: integer;			it,ic: integer;	begin	{	genericGetPort(tport);		genericSetPort(editorWindow);		if not editorTransposed then 			begin				CellHor(icstart, box.left, di, true);				CellHor(icend, di, box.right, true);				CellVer(1, di, box.top, true);				box.top := box.top + 2;				box.bottom := editorMatrixRect.bottom;			end		else			begin				CellVer(icstart, box.top, di, true);				CellVer(icend, di, box.bottom, true);				CellHor(1, di, box.left, true);				box.left := box.left + 2;				box.right := editorMatrixRect.right;			end;		EraseRect(box);		InvalidateWindowRect(box);		genericSetPort(tport);}				for it := FirstVisibleTaxon to LastVisibleTaxon do			for ic := icstart to icend do				begin					WriteTaxonCharacterCell (it,ic, false,writeStandardCells,selectionModeAsIs);				end;	end;{----------------------------------------------------------------------------}	procedure MatchCharUpdate (icstart, icend: integer);	begin		RedrawCharactersInEditor(icstart,icend);	end;{----------------------------------------------------------------------------}	procedure DrawDataCellsBetweenCorners(TL,BR: point;  selectionMode: integer);	var it,ic,itstart,itend,icstart,icend: integer;	begin		GetTaxonCharacterFromDataCell(itstart,icstart,TL,false);		GetTaxonCharacterFromDataCell(itend,icend,BR,false);		if itstart < 0 then itstart := 0;		if icstart < 0 then icstart:= 0;		for it := itstart to itend do			for ic := icstart to icend do				if (it<= numtaxa) & (ic <= numchars) then				begin					if it = 0 then						if editorTransposed then							DrawRowName(ic,selectionMode)						else							DrawColName(ic,selectionMode)					else if ic = 0 then						if editorTransposed then							DrawColName(it,selectionMode)						else							DrawRowName(it,selectionMode)					else if (ic>=FirstVisibleCharacter) &  (ic<=LastVisibleCharacter) &  (it>=FirstVisibleTaxon) &  (it<=LastVisibleTaxon) then						WriteTaxonCharacterCell (it,ic, false,writeStandardCells,selectionMode);				end;	end;{----------------------------------------------------------------------------}	procedure DrawDataCellsInRect(box: rect;  selectionMode: integer);	var it,ic,itstart,itend,icstart,icend: integer;		BR, TL: point;	begin		TL := FindCell(box.topleft,false,false);		BR := FindCell(box.botright,false,false);		DrawDataCellsBetweenCorners(TL,BR,selectionMode);	end;{----------------------------------------------------------------------------}	procedure DrawDataCellsInRgn(theRgn: RgnHandle; selectionMode: integer);	var it,ic: integer;		row,column, rowcolumn: integer;		box: rect;	begin		for it := FirstVisibleTaxon to LastVisibleTaxon do			for ic := FirstVisibleCharacter to LastVisibleCharacter do				begin					RowColumnFromTaxonCharacter(it,ic,row,column);					box := CellRect(column, row);				{	ClipRect(WindowPortRect(editorWindow));}					if RectInRgn(box,theRgn) then						begin							{EraseRect(box);							InvertRgn(theRgn);}							WriteTaxonCharacterCell (it,ic, false,writeStandardCells,selectionModeAsIs);						end;				end;		{for it := FirstVisibleTaxon to LastVisibleTaxon do			begin				RowColumnFromTaxonCharacter(it,0,row,column);				box := CellRect(column, row);				if RectInRgn(box,theRgn) then					if editorTransposed then						DrawColName(it,selectionMode)					else						DrawRowName(it,selectionMode);			end;		for ic := FirstVisibleCharacter to LastVisibleCharacter do			begin				RowColumnFromTaxonCharacter(0,ic,row,column);				box := CellRect(column, row);				if RectInRgn(box,theRgn) then					if editorTransposed then						DrawRowName(ic,selectionMode)					else						DrawColName(ic,selectionMode);			end;}		{for ic := FirstVisibleCharacter to LastVisibleCharacter do			begin				RowColumnFromTaxonCharacter(0,ic,row,column);				box := CellRect(column, row);				if RectInRgn(box,theRgn) then					if editorTransposed then						DrawRowName(ic,selectionMode)					else						DrawColName(ic,selectionMode);			end;}		if ConsensusSequenceVisible then			for it := 1 to editorNumConsensusSequences do				for ic := FirstVisibleCharacter to LastVisibleCharacter do					begin						RowColumnFromConsensusSequence(rowColumn,it);						RowColumnFromTaxonCharacter(rowColumn,ic,row,column);						box := CellRect(column, row);						if RectInRgn(box,theRgn) then							WriteCell(box, row,column,-1, ConsensusSelected(it), false, true,writeStandardCells);					end;		for ic := FirstVisibleColumn to LastVisibleColumn do			begin				box := CellRect(ic,-1);				if RectInRgn(box,theRgn) then					DrawRCNumberBox(ic,false);				box := CellRect(ic,0);				if RectInRgn(box,theRgn) then					DrawColName(ic,selectionMode);			end;		for ic := FirstVisibleRow to LastVisibleRow do			begin				box := CellRect(-1,ic);				if RectInRgn(box,theRgn) then					DrawRCNumberBox(ic,true);				box := CellRect(0, ic);				if RectInRgn(box,theRgn) then					DrawRowName(ic,selectionMode);			end;	end;{----------------------------------------------------------------------------}	procedure DrawCellBlockBoundaryAAwithDNA (cellBlock: CellBlockPtr; oldicstart,oldicend,selectionMode: integer);		var			icstart,icend, it: integer;			TL,BR: point;	begin		icstart := cellBlock^.currentStartChars;		icend := cellBlock^.currentEndChars;		if nucleotides  & (editorShowAAwithDNA | (editorColorCellsMode = editorColorCellsAAState)) then			begin			if IsCoding(icstart) & (CharCodPos(icstart) <> 1) then				begin					if (CharCodPos(icstart)=2) & (icstart>1) & (CharCodPos(icstart-1)=1)  then						for it := cellBlock^.currentStartTaxa to cellBlock^.currentEndTaxa do							WriteColorAAwithDNA(it,icstart-1,icstart-1,GetEdgeTSTS(true,it-cellBlock^.currentStartTaxa+1))					else if (CharCodPos(icstart)=3) & (icstart>2) & (CharCodPos(icstart-1)=2)& (CharCodPos(icstart-2)=1)  then						for it := cellBlock^.currentStartTaxa to cellBlock^.currentEndTaxa do							WriteColorAAwithDNA(it,icstart-2,icstart-1,GetEdgeTSTS(true,it-cellBlock^.currentStartTaxa+1))				end;			if IsCoding(icend) & (CharCodPos(icend) <> 3) then				begin					if (CharCodPos(icend)=2) & (icend<numchars) & (CharCodPos(icend+1)=3)  then						for it := cellBlock^.currentStartTaxa to cellBlock^.currentEndTaxa do							WriteColorAAwithDNA(it,icend+1,icend+1,GetEdgeTSTS(false,it-cellBlock^.currentStartTaxa+1))					else if (CharCodPos(icend)=1) & (icend<numchars-1) & (CharCodPos(icend+1)=2)& (CharCodPos(icend+2)=3)  then						for it := cellBlock^.currentStartTaxa to cellBlock^.currentEndTaxa do							WriteColorAAwithDNA(it,icend+1,icend+2,GetEdgeTSTS(false,it-cellBlock^.currentStartTaxa+1))				end;			if (oldicstart<icstart) & Not InSameCodon(oldicstart,icstart) then {going up}				begin					RowColumnFromTaxonCharacter(cellBlock^.currentStartTaxa ,StartOfCodon(oldicstart),TL.v,TL.h);					RowColumnFromTaxonCharacter(cellBlock^.currentEndTaxa ,StartOfCodon(icstart)-1,BR.v,BR.h);					DrawDataCellsBetweenCorners(TL,BR,selectionMode);				end;			if (oldicend>icend) & Not InSameCodon(oldicend,icend) then {going down}				begin					RowColumnFromTaxonCharacter(cellBlock^.currentStartTaxa ,EndOfCodon(icend)+1,TL.v,TL.h);					RowColumnFromTaxonCharacter(cellBlock^.currentEndTaxa ,EndOfCodon(oldicend),BR.v,BR.h);					DrawDataCellsBetweenCorners(TL,BR,selectionMode);				end;			end;	end;{----------------------------------------------------------------------------}	procedure DrawConsensusSequence(consensusNumber, selectionMode: integer);	var consensusRowCol: integer;		B: rect;		selected: boolean;		ic: integer;	begin		RowColumnFromConsensusSequence(consensusRowCol,consensusNumber);		selected := (selectionmode=SelectionModeOn) | (ConsensusSelected(consensusNumber) & (selectionmode=selectionModeAsIs));		if editorTransposed then			DrawColName(consensusRowCol,selectionMode)		else			DrawRowName(consensusRowCol,selectionMode);		for ic := FirstVisibleCharacter to LastVisibleCharacter do			WriteConsensusCell (consensusNumber,ic,false,writeStandardCells, selectionMode);	end;{----------------------------------------------------------------------------}	procedure DrawConsensusBlock(cellBlock: cellBlockPtr;oldicstart,oldicend: integer);		var highestChar, lowestChar: integer;	begin	{12 ticks for GetConsensusSets}		{6 for first sequence, 6 for remaining ones}	{1-2 ticks for coloring cells}	{5-6 ticks for drawing character}		if ConsensusSequenceVisible then			begin			{	lasttime := TickCount;}				if oldicend>cellBlock^.currentEndChars then					highestChar := oldicend				else					highestChar := cellBlock^.currentEndChars;				if highestChar > LastVisibleCharacter then					highestChar := LastVisibleCharacter;				if oldicstart< cellBlock^.currentStartChars then					lowestChar := oldicstart				else					lowestChar := cellBlock^.currentStartChars;				if lowestChar < FirstVisibleCharacter then					lowestChar := FirstVisibleCharacter;				WriteAllConsensesForCharacters(lowestChar,highestChar,writeStandardCells,selectionModeAsIs);			{	InstantInfo(StringFromNum(TickCount - LastTime));}			end;	end;{-----------------------------------------------------------------------------}	procedure UndoCellBlock(updateStuff: boolean);	var db: boolean;	begin		if undoSelectionValid then			begin				editorSelectionTopLeft := undoSelectionTopLeft;				editorSelectionBotRight := undoSelectionBotRight;				editorSelected := true;				CalcEditorSelectionRect(editorSelectionTopLeft,editorSelectionBotRight);			end;		db := PasteCellBlock(EWUndoBlockP,[],EWUndoBlockP^.starttaxa,EWUndoBlockP^.endtaxa,EWUndoBlockP^.startchars,EWUndoBlockP^.endchars);		InvalidateCellBlock(EWUndoBlockP^.starttaxa,EWUndoBlockP^.endtaxa,EWUndoBlockP^.startchars,EWUndoBlockP^.endchars,true);		if updateStuff then			begin				CheckRedrawFullCharactersInEditor(EWUndoBlockP^.starttaxa,EWUndoBlockP^.endtaxa,EWUndoBlockP^.startchars,EWUndoBlockP^.endchars,true);				{if ConsensusSequenceVisible  then					WriteAllConsensesForCharacters(EWUndoBlockP^.startchars,EWUndoBlockP^.endchars,writeStandardCells,selectionModeAsIs);				if UpdateAsSensitiveToFirstTaxonChange(EWUndoBlockP^.starttaxa)  then					MatchCharUpdate(EWUndoBlockP^.startchars, EWUndoBlockP^.endchars);}			end;		SetLastChangeInEditor(lastChangeCantUndo);	end;end.