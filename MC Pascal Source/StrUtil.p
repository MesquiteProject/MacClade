unit StrUtil;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils,		Memory, Fonts, Resources, Scrap,  FixMath,		Globals, SetLibInterface, UtilLibInterface,  SetLibInterface, MemoryUtil, CarbonUtil, SimpleUtil, 		WindowUtil, ErrorUtil, EventUtil, GenUtil, UtilLibInterface, DateTimeUtils;	procedure BeginPostScriptRotatedText;	procedure EndPostScriptRotatedText;	PROCEDURE MyFlushPostScriptState;	function GetSimpleString(prompt: str255; var theString: str255): boolean;	procedure PopUpStringMenu (LocalSpot: point; ds: str255);	procedure PopUpFreeMemory(wh: point);	procedure VerticalString (ds: str255; counterclockwise: boolean);	procedure DualVerticalString (ds: str255; oldClipRgn: RgnHandle; horiz, vert: integer);	function OrderOfMag (num: longint): longint;	function Exp10 (num: integer): longint;	function LengthString (theLength: longint; showreal: boolean): str255;	function EscapeChar (c: char): boolean;{	function StringsEqual (st1, st2: ptr; siglen: integer): boolean;	function CharAtPointer (p: ptr): char;	procedure ConcatStringChar (s: ptr; ch: char);}{	function charinstringASM (ch: char; s: ptr): boolean;}{	function ComparestringASM (st1, st2: ptr): boolean;}	procedure Stripblanks (var stripstr: str255);	procedure BlanksToUnderline (var ds: str255);	procedure WhiteSpaceToUnderline (var ds: str255);	procedure UnderLineToBlanks (var ds: str255);	function CapChar (c: char): char;	function MakeCaps (ds: str255): str255;	function MakeSmall (ds: str255): str255;	procedure SwitchCase (var c: char);	function CharIsMolecularChar (c: char): boolean;	function RealToIntegerstring (li: longint; inflate: integer): str255;	procedure RealtoString (r: double; var dss: str255; elimit: double; sigdigits: integer; expon: boolean);	function TokenToReal (token: str255): double;	function StringIsLongint (var ds: str255): boolean;	function TokenToInteger (token: str255; doPostError: boolean): integer;	function TokenToLongint (token: str255; doPostError: boolean): longint;	function LegalChars (token: str255): boolean;	procedure ReplaceIllegalCharsWithBlank (var token: str255);	procedure PrepareToken (var token: str255; msize: integer);	procedure CopyHandles (fromH: Handle; var toH: Handle);	procedure AppendToHandle (H: Handle; ds: str255);	procedure MergeHandles (sourceH, destH: Handle; mode: Integer);	procedure StringToH (ds: str255; H: Handle);	function StringFromHandle (H: Handle; startpos, endpos: longint): str255;	procedure StringToCHUNK (ds: str255; CHUNKHandleBlock: Handle; CHUNKnumber: integer);	procedure HandleToCHUNK (H, CHUNKHandleBlock: Handle; CHUNKnumber: integer);	procedure StartHandleRead (H: Handle);	function Hchar (H: Handle; charnumber: longint): char;	function CHUNKchar (CHUNKHandleBlock: Handle; CHUNKnumber, charnumber: longint): char;	function curCHUNKchar: char;	function getHtoken (H: Handle): str255;	function getCHUNKtoken (CHUNKHandleBlock: Handle; CHUNKnumber: integer): str255;	procedure SetButtonTitle (theDialog: DialogPtr; num: integer; ds: str255);	function GetEditText (theDialog: DialogPtr; num: integer): str255;	procedure EditTextNum (theDialog: DialogPtr; num: integer; var realvalue: double; var intvalue: longint; var isreal: boolean);	function EditTextInt (theDialog: DialogPtr; num: integer; warn: boolean): longint;	procedure SetDLOGText (theDialog: DialogPtr; num: integer; ds: str255; selectit: boolean);	procedure SetEditTextNum (theDialog: DialogPtr; num: integer; realvalue: double; intvalue: longint; isreal, selectit: boolean);	function GetLongint (message: str255; startingValue, minAllowed, maxAllowed: longint; var success: boolean): longint;	function GetLinkName (H: Handle): str255;	function LinkNameFromChain (theChain, theLink: longint): str255;	function UserStamp (initCap, includeReg, twoLines: boolean): str255;	function MacCladeStamp: str255;	function TimeStamp: str255;	function DataFileStamp: str255;	function CurrentTreeStamp: str255;	procedure WrapAroundSelection (TE: TEHandle; startString,endString: str255);	procedure InsertSelection (TE: TEHandle; ds1,ds2,ds3: str255);	procedure RemoveTemporaryCHUNK(var newCHUNK: Handle; chunkElements: integer);	procedure CreateTemporaryCHUNK(var newCHUNK: Handle; oldCHUNK: Handle; chunkElements: integer);{еееееееееееееееееееееее}implementation {е$S StrUtil}{########################## String & TE Utilities ###############################}	PROCEDURE MyFlushGrafPortState;	VAR		penInfo: PenState;		penPt: point;	BEGIN		GetPen(penPt);		GetPenState(penInfo); {save pen size}		PenSize(0,0); {make it invisible}		MoveTo(-3200,-3200); {move the pen way off the page in case the printer driver draws a dot even with a pen size of (0,0)}		Line(0,0); {go through QDProcs.lineProc}		PenSize(penInfo.pnSize.h, penInfo.pnSize.v); {restore pen size}		MoveTo(penPt.h, penPt.v); {restore pen position}	END;{-----------------------------------------------------------------------------}	procedure BeginPostScriptRotatedText;	begin		MyFlushPostScriptState;		MyFlushGrafPortState;		PicComment(TextBegin, SizeOf(TTxtPicRec), Handle(TTPR));		PicComment(TextCenter,SizeOf(TTxtCenter), Handle(TTC));	end;{-----------------------------------------------------------------------------}	procedure EndPostScriptRotatedText;	begin		PicComment(TextEnd, 0, nil);	end;{-----------------------------------------------------------------------------}	PROCEDURE MyFlushPostScriptState;	BEGIN		PicComment(PostScriptBegin, 0, NIL);		PicComment(PostScriptEnd, 0, NIL);	END;{	function charinstringASM; 	external;}{	function ComparestringASM (st1, st2: ptr): boolean;	external;}{	function StringsEqual (st1, st2: ptr; siglen: integer): boolean;	external;}{	procedure RotateBits (srcMap: BitMap; var destMap: BitMap);	EXTERNAL;}{	procedure ConcatStringChar (s: ptr; ch: char);	EXTERNAL;}{----------------------------------------------------------------------------}	function EscapeChar (c: char): boolean;	begin		EscapeChar := c = char(27);	end;{----------------------------------------------------------------------------}	procedure PopUpStringMenu (LocalSpot: point; ds: str255);	var globalSpot: point;	begin		//globalSpot := localSpot;		//LocalToGlobal(globalSpot);		PlaceTextWhileButtonDown(ds,LocalSpot, false);	end;{----------------------------------------------------------------------------}	procedure PopUpFreeMemory(wh: point);	var ds: str255;	begin{$IFC DEVELOPMENT}		ds := concat('Free memory in MacClade: ',StringFromNum(myFreeMem), ' b');{$ELSEC}		if isMacOSX then			ds := concat('Free memory is not easy to calculate in MacOS X')		else			ds := concat('Free memory in MacClade: ',StringFromNum(myFreeMem div 1024), 'K');{$ENDC}		PopUpStringMenu(wh, ds);	end;{-----------------------------------------------------------------------------}	function OrderOfMag (num: longint): longint;{returns RoundValue(log base 10 (num)), that is, the order of magnitude}{note that OrderOfMag(5) = 0}{note that OrderOfMag(10) = 1}	begin		if num < 10 then			OrderOfMag := 0		else if num < 100 then			OrderOfMag := 1		else if num < 1000 then			OrderOfMag := 2		else if num < 10000 then			OrderOfMag := 3		else if num < 100000 then			OrderOfMag := 4		else if num < 1000000 then			OrderOfMag := 5		else if num < 10000000 then			OrderOfMag := 6		else			OrderOfMag := 7;	end;{-----------------------------------------------------------------------------}	function Exp10 (num: integer): longint;{returns 10 raised to the power num}		var			j: integer;			td: longint;	begin		td := 1;		for j := 1 to num do			td := td * 10;		Exp10 := td;	end;{-----------------------------------------------------------------------------}	function LengthString (theLength: longint; showreal: boolean): str255;{this function returns a string for the length measurement given in theLength; it automatically}{adjusts if realwt or realtypes is true by converting the theLength to its real string representation}{using the lengthinflate factor - note that one can put further restrictions on when the real number}{form of theLength is written by using the boolean showreal}{NEVER TO BE USED FOR SINGLE CHARACTERS, only whole lengths}	begin		if showReal and (realwt or realtypes) then			LengthString := RealToIntegerstring(theLength, lengthinflate)		else			LengthString := StringFromNum(theLength);	end;{-----------------------------------------------------------------------------}	function RealToIntegerstring (li: longint; inflate: integer): str255;		var			ts: string[32];			neg: boolean;	begin		Neg := li < 0;		if neg then			li := -li;		if (li mod inflate < inflate div 10) and (inflate > 10) then			begin				if (li mod inflate < inflate div 100) and (inflate > 100) then					ts := '.00'				else					ts := '.0';			end		else			ts := '.';		if neg then			RealToIntegerstring := concat('-', StringFromNum(li div inflate), ts, StringFromNum(li mod inflate))		else			RealToIntegerstring := concat(StringFromNum(li div inflate), ts, StringFromNum(li mod inflate))	end;{-----------------------------------------------------------------------------}	function RotateString (ds: str255; var destMap: BitMap; counterclockwise: integer): osErr; {еееееее}{pass 1 to counterclockwise if you want it counterclockwise}	EXTERNAL;{-----------------------------------------------------------------------------}	procedure VerticalString (ds: str255; counterclockwise: boolean);	label 1;		var			myfontInfo: FontInfo;			 destMap: BitMap;			maplength: integer;			destRect: rect;			OrigPort: GrafPtr;			originalWindow: WindowPtr;			penpt: point; 			thePenState: penState;			os: OSErr;	begin		genericGetPort(originalWindow);		GetFontInfo(myfontInfo);		genericSetPort(originalWindow);		if counterclockwise then			begin				if not OSSuccessful(RotateString(ds,destMap,1)) then					goto 1;				GetPenState(thePenState);				destrect := destMap.bounds;				with destrect do					begin 						OffsetRect(destrect, -left, -top); 						maplength := bottom-top;					end;				getpen(penpt);				offsetrect(destrect, penpt.h - myFontInfo.ascent, penpt.v - maplength);			end		else			begin				if not OSSuccessful(RotateString(ds,destMap,0)) then					goto 1;				GetPenState(thePenState);				destrect := destMap.bounds;				getpen(penpt);				offsetrect(destrect, penpt.h-6, penpt.v );			end;		CopyBits(destMap, myGetPortBits(myGetWindowPort(originalWindow)), destMap.bounds, destrect, srcor, nil);		thePenState.PnLoc.v := destrect.top;		thePenState.PnLoc.h := destrect.right;		SetPenState(thePenState);1: 		ZapPointer(destmap.baseAddr);	end;{-----------------------------------------------------------------------------}	procedure DualVerticalString (ds: str255; oldClipRgn: RgnHandle; horiz, vert: integer);{call this and it will draw vertically on screen using bitmap, but postscript vertical if on printer}		var			nilrect: rect;	begin		SetRect(nilrect, 0, 0, 0, 0);		TTPR^^.tAngle := 270;		TTPR^^.tAngleFixed := Long2Fix(TTPR^^.tAngle);		moveto(horiz, vert);		BeginPostScriptRotatedText;		ClipRect(nilrect);		DrawString(ds);		SetClip(OldClipRgn);		moveto(horiz, vert);		VerticalString(ds, true);		EndPostScriptRotatedText;	end;{-----------------------------------------------------------------------------}	procedure Stripblanks (var stripstr: str255);{strips blanks from the end of the string stripstr}		var			ir: integer;	begin		ir := length(stripstr);		if ir > 0 then			while (stripstr[ir] = ' ') and (ir > 1) do				begin					delete(stripstr, ir, 1);					ir := ir - 1;				end;	end;{-----------------------------------------------------------------------------}	procedure FullStripBlanks (var ds: str255);	begin		StripBlanks(ds);		if ds = ' ' then			ds := '';	end;{-----------------------------------------------------------------------------}	procedure BlanksToUnderline (var ds: str255);{converts all blanks in the string to underscores}		var			ir, posBlank: integer;	begin		if (length(ds) > 0) then			begin				posBlank := pos(' ', ds);				if (posBlank > 0) then					for ir := posBlank to length(ds) do						if ds[ir] = ' ' then							ds[ir] := '_';			end;	end;{-----------------------------------------------------------------------------}	procedure WhiteSpaceToUnderline (var ds: str255);{converts all whiteSpace in the string to underscores}		var			ir: integer;	begin		for ir := 1 to length(ds) do			if ds[ir] in whitespace then				ds[ir] := '_';	end;{-----------------------------------------------------------------------------}	procedure WhiteSpaceToBlank (var ds: str255);{converts all whiteSpace in the string to blanks}		var			ir: integer;	begin		for ir := 1 to length(ds) do			if ds[ir] in whitespace then				ds[ir] := ' ';	end;{-----------------------------------------------------------------------------}	procedure UnderLineToBlanks (var ds: str255);{converts all underscores in string to blanks}		var			ir, posUnder: integer;	begin		if (length(ds) > 0) then			begin				posUnder := pos('_', ds);				if (posUnder > 0) then					for ir := posUnder to length(ds) do						if ds[ir] = '_' then							ds[ir] := ' ';			end;	end;{-----------------------------------------------------------------------------}	function CapChar (c: char): char;	begin		if (c >= 'a') & (c <= 'z') then			CapChar := chr(ord(c) - 32)		else			CapChar := c;	end;{-----------------------------------------------------------------------------}	function MakeCaps (ds: str255): str255;{converts the string ds to all caps}		var			ts: str255;	begin		ts := ds;		UpperString(ts, true);		MakeCaps := ts;	end;{-----------------------------------------------------------------------------}	function MakeSmall (ds: str255): str255;		var			j: integer;			ts: str255;	begin		ts := ds;		if length(ts) > 0 then			for j := 1 to length(ts) do				if (ts[j] >= 'A') and (ts[j] <= 'Z') then     {v4: this is not international!}					ts[j] := chr(ord(ts[j]) + 32);		MakeSmall := ts;	end;{-----------------------------------------------------------------------------}	procedure SwitchCase (var c: char);	begin		if (c >= 'a') & (c <= 'z') then			c := chr(ord(c) - 32)		else if (c >= 'A') & (c <= 'Z') then			c := chr(ord(c) + 32);	end;{-----------------------------------------------------------------------------}	function CharIsMolecularChar (c: char): boolean;{true iff c is a character that is potentially used in a molecular sequence data set; this}{is used to restrict other symbols so they are not anything contained herein}{but note occasional overrides before this is called for nucleotide data in which N is designated as "missing"}	begin{v 3.06}		CharIsMolecularChar := (pos(c, 'abcdefghiklmnpqrstuvwyzABCDEFGHIKLMNPQRSTUVWYZ*1234') > 0) | (c = '*') | ((c >= '1') & (c <= '4'));	end;{-----------------------------------------------------------------------------}	procedure RealtoString (r: double; var dss: str255; elimit: double; sigdigits: integer; expon: boolean);		const			longintlimit = maxlongint;		var			temps, tts, fractionString: str255;			expo, fract, sigmultint: longint;			tr, sigmult, sigsmall: double;			ir: integer;			isneg: boolean;			elimitChanged: boolean;			alwaysAddZeros: boolean;	begin		alwaysAddZeros := false;		if r < 0.0 then			begin				r := abs(r);				isneg := true;			end		else			isneg := false;		sigsmall := 1.0;		sigmult := 1.0;		sigmultint := 1;		for ir := 1 to sigdigits do			begin				sigsmall := sigsmall / 10.0;				sigmult := sigmult * 10.0;				sigmultint := sigmultint * 10;			end;		if (TruncateValue(r) > longintlimit) & (r < elimit) then   {less than elimit, but too big for longinteger!}			begin				elimit := longintlimit * 1.0;   {force it to be processed using exponential notation if allowed}				elimitchanged := true;			end		else			elimitchanged := false;		if r = 0 then			dss := '0.0'{========   r within bounds  - don't use exponential   =========}		else if (r <= elimit) and (r >= sigsmall) then			begin{    if TruncateValue(r) > longintlimit then r := longintlimit * 1.0;}				numtostring(TruncateValue(r), dss);				dss := Concat(dss, '.');				fract := RoundValue(sigmult * (r - TruncateValue(r)));				if fract = sigmultint then					fract := sigmultint - 1;				fractionString := '';				for ir := 1 to sigdigits do					begin						sigmultint := sigmultint div 10;						if (fract < sigmultint) then							fractionString := concat(fractionString, '0');					end;				if fract <> 0 then					fractionString := concat(fractionString, stringfromnum(fract));				dss := concat(dss, fractionString);				if AlwaysAddZeros then					if length(fractionString)< sigDigits then						for ir := length(fractionString)+1 to sigDigits do							dss := concat(dss,'0');			end{========   r < sigsmall   =========}		else if r < sigsmall then			if expon then				begin					if r < 0 then						r := 0;					expo := 0;					tr := r;					repeat						expo := expo + 1;						tr := tr * 10.0;					until tr >= 1;					Realtostring(tr, temps, elimit, sigdigits, expon);					Numtostring(expo, tts);					dss := concat(temps, 'E-', tts);				end			else				begin					isneg := false;					dss := '0.0';				end{========   r > elimit   =========}		else if expon then			begin				expo := 0;				tr := r;				repeat					expo := expo + 1;					tr := tr / 10.0;				until tr < 10.0;				Realtostring(tr, temps, elimit, sigdigits, expon);				Numtostring(expo, tts);				dss := concat(temps, 'E+', tts);			end		else if not elimitchanged then   {r to big, expand elimit}			begin				Realtostring(r, temps, elimit * 10, sigdigits, expon);				dss := temps;   {v4: what if gets more than 255 length?}			end		else	{still wants to expand r, but can't as too close to longintlimit}			dss := '***';		if isneg then			dss := concat('-', dss);	end;{-----------------------------------------------------------------------------}	function TokenToReal (token: str255): double;		var			ds: str255;			fact, thereal: double;			badchar: boolean;			j, k: integer;			exponent: longint;			wtstring: str255;			realIsNegative: boolean;	begin		wtstring := ' ее';		wtstring[2] := chr(13);		wtstring[3] := chr(9);		realIsNegative := false;		ds := token;		j := 1;		while (j < length(ds)) & (charinstringC(ds[j], @wtstring)) do		{ignore leading whitespace}			j := j + 1;		k := length(ds);		while (k > 1) & (charinstringC(ds[k], @wtstring)) do		{ignore trailing whitespace}			k := k - 1;		ds := CopyString(ds, j, k - j + 1);		if pos('e', ds) > 0 then			begin				StringToNum(CopyString(ds, pos('e', ds) + 1, length(ds)), exponent);				ds := CopyString(ds, 1, pos('e', ds) - 1);			end		else if pos('E', ds) > 0 then			begin				StringToNum(CopyString(ds, pos('E', ds) + 1, length(ds)), exponent);				ds := CopyString(ds, 1, pos('E', ds) - 1);			end		else			exponent := 0;		badchar := false;		if pos('-', ds) > 0 then			begin		badchar := false;			end;		if ds[1] = '-' then			begin				realIsNegative := true;				ds := CopyString(ds, 2, length(ds)-1);			end;		if pos('.', ds) > 0 then			begin				thereal := 0.0;				for j := 1 to pos('.', ds) - 1 do					begin						if (ds[j] < '0') or (ds[j] > '9') then							badchar := true;						thereal := 10.0 * thereal + (ord(ds[j]) - 48);					end;				fact := 1.0;				for j := pos('.', ds) + 1 to length(ds) do					begin						fact := fact * 10.0;						if (ds[j] < '0') or (ds[j] > '9') then							badchar := true;						thereal := thereal + (ord(ds[j]) - 48) * 1.0 / fact;					end;			end		else			begin				thereal := 0.0;				for j := 1 to length(ds) do					begin						if (ds[j] < '0') or (ds[j] > '9') then							badchar := true;						thereal := 10.0 * thereal + (ord(ds[j]) - 48);					end;			end;		if badchar then			thereal := -1.0		else 			begin				if exponent < 0 then					begin						exponent := -exponent;						for j := 1 to exponent do							thereal := thereal / 10.0;					end				else if exponent > 0 then					begin						for j := 1 to exponent do							thereal := thereal * 10.0;						if realIsNegative then							theReal := -theReal;					end;				if realIsNegative then					theReal := -theReal;			end;		TokenToReal := thereal;	end;{-----------------------------------------------------------------------------}	function StringIsLongint (var ds: str255): boolean;		var			LI: longint;			j, k: integer;			wtstring: str255;			bad: boolean;	begin		if length(ds) = 0 then			StringIsLongint := false		else			begin				wtstring := ' еее';				wtstring[2] := chr(13);				wtstring[3] := chr(9);				wtstring[4] := chr(10);				j := 1;				while (j < length(ds)) & (charinstringC(ds[j], @wtstring)) do		{ignore leading whitespace}					j := j + 1;				k := length(ds);				while (k > 1) & (charinstringC(ds[j], @wtstring)) do		{ignore trailing whitespace}					k := k - 1;				ds := CopyString(ds, j, k - j + 1);				bad := false;				if length(ds) > 0 then					begin						if (ds[1] in ['-', '+']) then							k := 2						else							k := 1;						for j := k to length(ds) do							if (ds[j] < '0') or (ds[j] > '9') then								begin									ds := '-1';									bad := true;									leave;								end;					end				else					begin						ds := '0';						bad := true;					end;				StringIsLongint := not bad;			end;	end;{-----------------------------------------------------------------------------}	function TokenToInteger (token: str255; doPostError: boolean): integer;		var			ds: str255;			LI: longint;	begin		if length(token) = 0 then			TokenToInteger := 0       {note that no warning is given}		else			begin				ds := token;				if StringIsLongint(ds) then					begin						StringToNum(ds, LI);					{	if (LI>32727) | (LI<-32767) then							begin								if doPostError then									NewError(464,0);								TokenToInteger := 0;							end						else }							TokenToInteger := LowWord(LI);					end				else					begin						if doPostError then							NewError(17, 0);						TokenToInteger := 0;					end;			end;	end;{-----------------------------------------------------------------------------}	function TokenToLongint (token: str255; doPostError: boolean): longint;		var			ds: str255;			LI: longint;	begin		if length(token) = 0 then			TokenToLongint := 0       {note that no warning is given}		else			begin				ds := token;				if StringIsLongint(ds) then					begin						StringToNum(ds, LI);						TokenToLongint := LI;					end				else					begin						if doPostError then							NewError(17, 0);						TokenToLongint := 0;					end;			end;	end;{-----------------------------------------------------------------------------}	function LegalChars (token: str255): boolean;{returns true if the string token contains only characters that are legal in }{an unquoted NEXUS token}		var			j: integer;	begin		LegalChars := true;		for j := 1 to length(token) do			if (token[j] in punct305 + [''''] ) then				begin					LegalChars := false;					leave;				end;	end;{-----------------------------------------------------------------------------}	procedure ReplaceIllegalCharsWithBlank (var token: str255);		var			j: integer;	begin		for j := 1 to length(token) do			if (token[j] in punct305 + [''''] ) then				token[j] := '_';	end;{-----------------------------------------------------------------------------}	procedure PrepareToken (var token: str255; msize: integer);		var			j: integer;	begin		StripBlanks(token);		if token = '' then			token := '_'		else			WhiteSpaceToBlank(token);		token := CopyString(token, 1, msize);		if not legalchars(token) then			begin				if pos('''', token) > 0 then  {quotes in the token; have to double them for output}					begin						j := 1;						repeat							if token[j] = '''' then								begin									insert('''', token, j);									j := j + 1;								end;							j := j + 1;						until j > length(token);					end;				token := concat('''', token, '''');			end		else			BlanksToUnderline(token);	end;{||||||||||||||||||||||||||||||||  Copy, Merging Handles  |||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	procedure CopyHandles (fromH: Handle; var toH: Handle);{copies contents of handle fromH to toH; note that HANDLE toH MUST EXIST or be set to NIL}		var			db: boolean;	begin		ZapHandle(toH);		toH := fromH;		currentIOPosition := 53;   {v3.05}		db := OSSuccessful(HandToHand(toH));	end;{-----------------------------------------------------------------------------}	procedure AppendToHandle (H: Handle; ds: str255);		var			db: boolean;			oldstate: SignedByte;	begin		UnlockHandle(H, oldstate);		currentIOPosition := 54;   {v3.05}		db := OSSuccessful(PtrAndHand(Pointer(ord4(@ds) + 1), H, length(ds)));		currentIOPosition := 85;   {note that 85 means: "sometime after 54"}		ResetHandle(H, oldstate);	end;{----------------------------------------------------------------------------}{	procedure sectHandles (src, dest: ptr; numbytes: longint);	EXTERNAL;	procedure UnionHandles (src, dest: ptr; numbytes: longint);	EXTERNAL;}{----------------------------------------------------------------------------}	procedure MergeHandles (sourceH, destH: Handle; mode: Integer);		var			oldstate1, oldstate2: SignedByte;			sourcePtr, destPtr: Ptr;			numbytes: longint;	begin		UnlockHandle(destH, oldstate2);		SetHandleSize(destH, GetHandleSize(sourceH));		numbytes := GetHandleSize(sourceH);		HLock(destH);		LockHandle(sourceH, oldstate1);		sourcePtr := Ptr(GetMaster(sourceH));		destPtr := Ptr(GetMaster(destH));		if mode = srcor then			UnionHandles(sourcePtr, destPtr, numbytes)		else			SectHandles(sourcePtr, destPtr, numbytes);		ResetHandle(sourceH, oldstate1);		ResetHandle(destH, oldstate2);	end;{||||||||||||||||||||||||||||||||  Strings To and From CHUNKS and Handles  |||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	procedure StringToH (ds: str255; H: Handle);{replaces whatever was in handle by the string ds}		var			oldState: SignedByte;	begin		UnlockHandle(H, oldstate);		SetHandleSize(H, 0);		AppendToHandle(H, ds);		ResetHandle(H, oldstate);	end;{-----------------------------------------------------------------------------}	procedure StringToCHUNK (ds: str255; CHUNKHandleBlock: Handle; CHUNKnumber: integer);		var			oldstate: SignedByte;			H: Handle;	begin		LockHandle(CHUNKHandleBlock, oldstate);		H := HdlPtr(GetMaster(CHUNKHandleBlock) + HdlSize * ord4(CHUNKnumber - 1))^;		StringToH(ds, H);		ResetHandle(CHUNKHandleBlock, oldstate);	end;{-----------------------------------------------------------------------------}	procedure HandleToCHUNK; {(H, CHUNKHandleBlock : Handle; CHUNKnumber : integer);}		var			oldstate: SignedByte;			dhdl: Handle;			dhp: HdlPtr;	begin		LockHandle(CHUNKHandleBlock, oldstate);		dhp := HdlPtr(GetMaster(CHUNKHandleBlock) + HdlSize * ord4(CHUNKnumber - 1));		dhdl := dhp^;		CopyHandles(H, dhdl);		dhp^ := dhdl;		ResetHandle(CHUNKHandleBlock, oldstate);	end;{-----------------------------------------------------------------------------}{	function CharAtPointer (p: ptr): char;	EXTERNAL;}{    var tc: integer;}{begin tc := p^; if tc < 0 then tc := tc + 256; CharAtPointer := char(tc);end;}{-----------------------------------------------------------------------------}	function Hchar (H: Handle; charnumber: longint): char; {v3.05:  changed to longint}		var			oldstate: SignedByte;	begin		LockHandle(H, oldstate);		Hchar := charatpointer(Pointer(GetMaster(H) + charnumber - 1));		ResetHandle(H, oldstate);	end;{-----------------------------------------------------------------------------}	function StringFromHandle (H: Handle; startpos, endpos: longint): str255;{v4: adjust so uniformly 0-based}		var			ds: str255;			j, lengthds: integer;	begin		if endpos < startpos then			StringFromHandle := ''		else			begin				lengthds := IntegerMin(endpos - startpos, 255);{$R-}{turn off range checking so it doesn't always complain about setting length byte of string}				ds[0] := chr(lengthds);				for j := 1 to lengthds do					ds[j] := HChar(H, startpos + j); {note that HChar does Locking/unlocking itself}				StringFromHandle := ds;			end;	end;{-----------------------------------------------------------------------------}	function CHUNKchar (CHUNKHandleBlock: Handle; CHUNKnumber, charnumber: longint): char;   {v3.05:  changed to longint}		var			oldstate: SignedByte;			dhdl: Handle;	begin		LockHandle(CHUNKHandleBlock, oldstate);		dhdl := HdlPtr(GetMaster(CHUNKHandleBlock) + HdlSize * ord4(CHUNKnumber - 1))^;		CHUNKchar := Hchar(dhdl, charnumber);		ResetHandle(CHUNKHandleBlock, oldstate);	end;{note: before using curCHUNKchar, you}{MUST initialize chunkPtr, by calling StartHandleRead}{-----------------------------------------------------------------------------}	procedure StartHandleRead (H: Handle);	begin		chunkPtr := Pointer(GetMaster(H));	end;{-----------------------------------------------------------------------------}	function curCHUNKchar: char;	begin		curCHUNKchar := charatpointer(Pointer(ord4(chunkPtr) + CHUNKpos));	end;{-----------------------------------------------------------------------------}	function getHtoken (H: Handle): str255;		label			1, 2;		var			oldstate: SignedByte;			ds: str255;			quitwhile, longtoken, longquote: boolean;			chunksize: longint;			c: char;	begin		LockHandle(H, oldstate);		chunksize := GetHandleSize(H);		StartHandleRead(H);		ds := '';		quitwhile := false;		longtoken := false;		longquote := false;							{find first non whitespace char}		while (curCHUNKchar in whitespace+vacuum) and (CHUNKpos < chunksize) do			CHUNKpos := CHUNKpos + 1;		c := curCHUNKchar;{=======  punctuation =======}		if c in punctuation then			begin				ds := c;				CHUNKpos := CHUNKpos + 1;			end{=======  quoted token =======}		else if c = '''' then			begin1:				CHUNKpos := CHUNKpos + 1;				c := curCHUNKchar;				while (c <> '''') and (CHUNKpos < CHUNKsize) and not longquote do					begin						ConcatStringChar(@ds, c);						CHUNKpos := CHUNKpos + 1;						c := curCHUNKchar;						longquote := (length(ds) >= maxtok);					end;				if (c = '''') and (CHUNKpos < CHUNKsize) then	{deal with double quotes or endquote}					begin						CHUNKpos := CHUNKpos + 1;						if curCHUNKchar = '''' then						{double quotes}							begin								ConcatStringChar(@ds, c);							{save one of the quotes}								goto 1;							end						else							longquote := false;					end;			end{=======  normal token =======}		else			while not quitwhile and not longtoken and not (c in whitespace+vacuum) and (CHUNKpos < chunksize) do				begin					if c in punctuation then						quitwhile := true					else						begin							ConcatStringChar(@ds, c);							CHUNKpos := CHUNKpos + 1;							longtoken := (length(ds) >= maxtok);						end;					c := curCHUNKchar;				end;		if longtoken then			while not (curCHUNKchar in whitespace+vacuum) and not (curCHUNKchar in punctuation) and (CHUNKpos < chunksize) do				CHUNKpos := CHUNKpos + 1;		if longquote then			begin2:				while not (curCHUNKchar = '''') and (CHUNKpos < chunksize) do					CHUNKpos := CHUNKpos + 1;				if (CHUNKpos < chunksize) then					begin						CHUNKpos := CHUNKpos + 1;						if curCHUNKchar = '''' then							goto 2;					end;				CHUNKpos := CHUNKpos + 1;			end;		getHtoken := ds;		ResetHandle(H, oldstate);	end;{-----------------------------------------------------------------------------}	function getCHUNKtoken; {(CHUNKHandleBlock : Handle; CHUNKnumber : integer) : str255;}		var			oldstate: SignedByte;			dhp: HdlPtr;	begin		LockHandle(CHUNKHandleBlock, oldstate);		dhp := HdlPtr(GetMaster(CHUNKHandleBlock) + HdlSize * ord4(CHUNKnumber - 1));     {get pointer to CHUNKnumber handle in handle block}		getCHUNKtoken := GetHToken(dhp^);		ResetHandle(CHUNKHandleBlock, oldstate);	end;{-----------------------------------------------------------------------------}{||||||||||||||||||||||||||||  DLOG Utilities  |||||||||||||||||||||||||||||||}{----------------------------------------------------------------------------}	procedure SetButtonTitle (theDialog: DialogPtr; num: integer; ds: str255);		var			H: Handle;			itemtype: integer;			box: rect;	begin		GetDialogItem(theDialog, num, itemtype, H, box);		SetControlTitle(ControlHandle(H), ds);	end;{----------------------------------------------------------------------------}	function GetEditText (theDialog: DialogPtr; num: integer): str255;		var			H: Handle;			itemtype: integer;			box: rect;			ds: str255;	begin		ds := '';		GetDialogItem(theDialog, num, itemtype, H, box);		if GetHandleSize(H)>255 then			begin				{ds := StringFromHandle(H,0,255);				SetDLOGText(theDialog,num,ds,false);}				NewError(435,0); 			end;		GetDialogItemText(H, ds);		GetEditText := ds;	end;{----------------------------------------------------------------------------}	procedure EditTextNum (theDialog: DialogPtr; num: integer; var realvalue: double; var intvalue: longint; var isreal: boolean);		var			H: Handle;			itemtype: integer;			box: rect;			ds: str255;	begin		intvalue := 0;		realvalue := 0.0;		GetDialogItem(theDialog, num, itemtype, H, box);		GetDialogItemText(H, ds);		if (pos('.', ds) > 0) | (pos('e', ds) > 0) | (pos('E', ds) > 0) then			begin				isreal := true;				realvalue := TokenToReal(ds);			end		else			begin				isreal := false;				if StringIsLongint(ds) then					StringToNum(ds, intvalue)				else					NewError(130, 0);			end;	end;{----------------------------------------------------------------------------}	function EditTextInt (theDialog: DialogPtr; num: integer; warn: boolean): longint;		var			H: Handle;			itemtype: integer;			box: rect;			ds: str255;			LI: longint;	begin		GetDialogItem(theDialog, num, itemtype, H, box);		GetDialogItemText(H, ds);		if StringIsLongint(ds) then			StringToNum(ds, LI)		else			begin				LI := 0;				if warn then NewError(130, 0);			end;		EditTextInt := LI;	end;{-----------------------------------------------------------------------------}	procedure SetDLOGText (theDialog: DialogPtr; num: integer; ds: str255; selectit: boolean);		var			H: Handle;			itemtype: integer;			box: rect;	begin		GetDialogItem(theDialog, num, itemtype, H, box);		SetDialogItemText(H, ds);		if (itemtype = editText) then			if selectit then			{obviously can only do for edit text items}				SelectDialogItemText(TheDialog, num, 0, 32767);	//4.0b28		else	//4.0b28			SelectDialogItemText(TheDialog, num, 32767, 32767); 	end;{-----------------------------------------------------------------------------}	procedure SetEditTextNum (theDialog: DialogPtr; num: integer; realvalue: double; intvalue: longint; isreal, selectit: boolean);		var			H: Handle;			itemtype: integer;			box: rect;			ds: str255;	begin		GetDialogItem(theDialog, num, itemtype, H, box);		if isreal then			RealToString(realvalue, ds, 100000, 1, false)		else			NumtoString(intvalue, ds);		SetDialogItemText(H, ds);		if selectit then			SelectDialogItemText(TheDialog, num, 0, 32767);	end;{-----------------------------------------------------------------------------}	function GetSimpleString(prompt: str255; var theString: str255): boolean;		var			theDialog: DialogPtr;			tempP: WindowPtr;			localItemHit: integer;	begin		GetSimpleString := false;		ParamText(prompt, '', '', '');		StartDLOG(596, theDialog, tempP);		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);		until localItemHit in [1, 2];		if localItemHit = 1 then			begin 				theString := GetEditText(theDialog, 3);				GetSimpleString:= true;			end;		EndDLOG(theDialog, tempP);	end;{-----------------------------------------------------------------------------}	function GetLongint (message: str255; startingValue,minAllowed, maxAllowed: longint; var success: boolean): longint;{returns an integer, entered by the user in a DLOG box}{note negative values for maxAllowed not allowed!!!}{maxAllowed = -1 indicates highest longint allowed}		label			1;		var			theDialog: DialogPtr;			tempP: WindowPtr;			ds: str255;			LI: longint;			localItemHit: integer;	begin		ParamText(message, '', '', '');		StartDLOG(596, theDialog, tempP);		SetDLOGText(theDialog,3, StringFromNum(startingValue), true);		myShowDialog(theDialog);		FrameButton(theDialog, 1);1:		repeat			ModalDialog(nil, localItemHit);		until localItemHit in [1, 2];		if localItemHit = 1 then			begin				ds := GetEditText(theDialog, 3);				if StringIsLongint(ds) then					StringToNum(ds, LI)				else					begin						Beep;						goto 1;					end;				if (LI >= minAllowed) & ((LI <= maxAllowed) | (maxAllowed < 0)) then					GetLongint := LI				else					begin						Beep;						goto 1;					end;			end		else			GetLongint := 0;		success := localItemHit = 1;		EndDLOG(theDialog, tempP);	end;{-----------------------------------------------------------------------------}	function GetLinkName (H: Handle): str255;{returns the name of the link in handle H, where H points to a processed link description,}{with the name at the start}		var			oldstate: SignedByte;			startp: ptr;			leng: integer;			linkP: longint;			ds: str255;			ir: integer;	begin		ds := '';		LockHandle(H, oldstate);		linkP := GetMaster(H);		startP := Ptr(linkP + SLB);		leng := ip(linkP)^;		for ir := SLB + 1 to leng - 1 do			begin				concatStringChar(@ds, Charatpointer(startP));				startP := Ptr(ord4(startP) + 1);			end;		ResetHandle(H, oldstate);		underlinetoblanks(ds);		stripblanks(ds);		GetLinkName := ds;	end;{-----------------------------------------------------------------------------}	function LinkNameFromChain (theChain, theLink: longint): str255;{v4:  theLink is now 0-based}	begin		LinkNameFromChain := GetLinkName(HdlPtr(GetMaster(strCHUNKs[theChain]) + HdlSize * ord4(theLink))^)	end;{-----------------------------------------------------------------------------}	function UserStamp (initCap, includeReg, twoLines: boolean): str255;		var			ds: str255;	begin		HLock(Handle(userName));		HLock(Handle(userInstitution));		if includeReg then			if initCap then				ds := 'Registered to '			else				ds := 'registered to '		else			ds := '';		if twoLines then			ds := concat(ds, userName^^, chr(13), userInstitution^^)		else			ds := concat(ds, userName^^, ', ', userInstitution^^);		HUnLock(Handle(userName));		HUnLock(Handle(userInstitution));		UserStamp := ds;	end;{-----------------------------------------------------------------------------}	function MacCladeStamp: str255;	begin		{$IFC RELEASEVERSION}		MacCladeStamp := concat('MacClade version ', Version);		{$ELSEC}		MacCladeStamp := concat('MacClade test version ', testVersion);		{$ENDC}	end;{-----------------------------------------------------------------------------}	function TimeStamp: str255;		var			ds, dss: str255;			secs: UInt32;	begin		GetDateTime(secs);		myDateString(secs,longDate,ds);		myTimeString(secs,false,dss);		//DateString(secs, longdate, ds,nil);		//TimeString(secs, false, dss,nil);		TimeStamp := concat(ds, ', ', dss);	end;{-----------------------------------------------------------------------------}	function DataFileStamp: str255;		var			ds: str255;			oldstate: SignedByte;	begin		LockHandle(filename, oldstate);		ds := concat('Data file: ', filename^^, '.');		ResetHandle(filename, oldstate);		DataFileStamp := ds;	end;{-----------------------------------------------------------------------------}	function CurrentTreeStamp: str255;		var			ds: str255;			oldstate: SignedByte;	begin		if (treename^^ = '') or (treename^^ = UnStoredLink) or dirtytree then			ds := 'Current tree: untitled.'		else			begin				LockHandle(treename, oldstate);				ds := concat('Current tree: ', treename^^, '.');				ResetHandle(treename, oldstate);			end;		CurrentTreeStamp := ds;	end;{-----------------------------------------------------------------------------}	procedure WrapAroundSelection (TE: TEHandle; startString,endString: str255);		var			startSelect, endSelect, j: integer;	begin		startSelect := TE^^.selstart;		endSelect := TE^^.selend;		TESetSelect(startSelect, startSelect, TE);		for j := 1 to length(startString) do			TEKey(startString[j], TE);		TESetSelect(endSelect + length(startString), endSelect + length(startString), TE);		for j := 1 to length(endString) do			TEKey(endString[j], TE);		TESetSelect(startSelect + length(startString), endSelect + length(startString), TE);	end;{-----------------------------------------------------------------------------}	procedure InsertSelection (TE: TEHandle; ds1,ds2,ds3: str255);		var			startSelect, j: integer;	begin		startSelect := TE^^.selstart;		for j := 1 to length(ds1) do			TEKey(ds1[j], TE);		for j := 1 to length(ds2) do			TEKey(ds2[j], TE);		for j := 1 to length(ds3) do			TEKey(ds3[j], TE);		TESetSelect(startSelect, startSelect + length(ds1) + length(ds2) + length(ds3), TE);	end;{-----------------------------------------------------------------------------}{-----------------------------------------------------------------------------}	procedure RemoveTemporaryCHUNK(var newCHUNK: Handle; chunkElements: integer);	var ir: integer;	begin		if newCHUNK=nil then Exit(RemoveTemporaryCHUNK);		HLock(newCHUNK);		for ir := 1 to chunkElements do			ZapHandle(HdlPtr(GetMaster(newCHUNK) + HdlSize * ord4(ir - 1))^);		HUnLock(newCHUNK);		ZapHandle(newCHUNK);	end;{-----------------------------------------------------------------------------}	procedure CreateTemporaryCHUNK(var newCHUNK: Handle; oldCHUNK: Handle; chunkElements: integer);	var 	ir: integer;		oldH: Handle;	begin		newCHUNK := NewHandleClear(GetHandleSize(oldChunk));		HLock(newCHUNK);		for ir := 1 to chunkElements do			begin				oldH := HdlPtr(GetMaster(oldChunk) + HdlSize * ord4(ir - 1))^;				CopyHandles(oldH,HdlPtr(GetMaster(newCHUNK) + HdlSize * ord4(ir - 1))^);				if errorFlag then leave;			end;		HUnLock(newCHUNK);	end;end.