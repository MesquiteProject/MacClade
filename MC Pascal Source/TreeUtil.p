unit TreeUtil;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap, 		 Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, 		 EventUtil, GenUtil, StrUtil, TypeUtil, CharUtil, TaxonCHUtil;	procedure DisposeNODEs;	function FillNode (N: Nptr): boolean;	function NodeisPolytomous (N: Nptr): boolean;	function NodeisTerminal (N: Nptr): boolean;	function NodeisInternal (N: Nptr): boolean;	function BranchExists (N: Nptr): Boolean;	function NodeSlantsRight (N: Nptr): boolean;	function AnyNulls (N: Nptr): boolean;	procedure setNullsOn;	procedure CollapseClade (N: Nptr);	procedure setAncOn;	function AnyFixanc (N: Nptr): boolean;	procedure OffAnc (N: Nptr);	function IsAnc (N, cN: Nptr): BOOLEAN;	procedure CheckSetLengthsToDefaults(N: Nptr);	function allRealLengthsDefault: boolean;	function allSetLengths1: boolean;		procedure ResetForNew;	procedure EmptyAssociatedTreeHandles;	function tickOverHang: integer;	function FirstCladeIsBigger (N1, N2: Nptr): boolean;	function LeftEdgeOfClade (N: Nptr; wideTool, justRight: boolean): integer;	function RightEdgeOfClade (N: Nptr; wideTool, justRight: boolean): integer;	procedure FindBranch (pt: point; N: Nptr; wideTool: boolean);	function FindJustRightOfBranch (pt: point; N: Nptr; var foundN: Nptr): boolean;{fliptree stuff:  ABSOLUTE MOVES, COMMANDS }{(these perform a Tree Coordinate to window coord switch if needed)}	function OrientHoriz (h, v: longint): integer;	function OrientVert (h, v: longint): integer;	function OrientPoint (pt: point): point;	function OrientRect (r: rect): rect;	procedure MoveToOrient (h, v: longint);	procedure LineToOrient (h, v: longint);	function PtInRectOrient (pt: point; r: rect): boolean;	procedure ClipRectOrient (r: rect);	procedure EraseRectOrient (r: rect);	procedure FrameRectOrient (r: rect);	procedure FillRectOrient (r: rect; pat: pattern);	procedure DrawStringOrient (ds: str255);	procedure VerticalStringOrient (ds: str255);{(this performs a window coord to tree coord switch if needed)}	function DisOrientPoint (pt: point): point;{RELATIVE MOVES, COMMANDS}	procedure MoveOrient (h, v: integer);	procedure LineOrient (h, v: integer);	procedure PenSizeOrient (h, v: integer);	procedure InsetRectOrient (var r: rect; h, v: integer);	procedure offsetRectOrient (var r: rect; h, v: integer);	procedure OffSetRgnOrient (var reg: RgnHandle; h, v: integer);	procedure OffSetPOLYOrient (var Poly: polyHandle; h, v: integer);	procedure ZeroTreeOrigin;	function Sis (N: Nptr): Nptr;	function LeftMostDescendant (N: Nptr): Nptr;	function RightMostDescendant (N: Nptr): Nptr;	function firstNonNullLeft (pN: Nptr): Nptr;	function firstNonNullRight (pN: Nptr): Nptr;	function NextSisterRight (N: Nptr): Nptr;	function NotNullAnc (N: Nptr): Nptr;	function farthestright (N: Nptr): integer;	function farthestleft (N: Nptr): integer;	procedure NPtrOfTaxon(it: integer; var theNode: Nptr);	function NodeOfNumber (ni: integer): Nptr;	function NumberofNode (N: Nptr): integer;	function PackedTreeHasFixanc (H: handle): boolean;	function PackedTreeHasPolytomies (H: handle): boolean;	function IsTerminalFixanc (N: Nptr): Boolean;	function TermOfFixanc (N: Nptr): Nptr;	function DescOfFixanc (N: Nptr): Nptr;	function IsFixancedUpon (N: Nptr): Boolean;	function RoomNeededOnRight: integer;	procedure CalcNodeTriangle;	procedure VertTWScrollPosition;	procedure SetTWScrollMax;	function BranchLengthLongint (N: Nptr; pleaseDeflate: boolean): longint;	procedure CalcBranchLengthSpacing(originalSpacing: integer);	function TreeChangeHeight (extraBranchLength, perChangeFactor: integer): longint;   {v3.02: moved up from LaserDraw}	procedure CalcEdw (ntaxa: integer);	procedure NodesFromTop (N: Nptr; var minnodes, maxnodes: longint; countNulls: boolean);	function SizeofClade (N: Nptr; useLocsIfPossible: boolean): integer;	function PartofSamePolytomy (N1, N2: Nptr): boolean;	function PartOfPolytomy (N: Nptr): boolean;	procedure ShrinkTree;	procedure SetNumTaxaInPackedTree (tH: handle; howmany: integer);	function GetNumTaxaInPackedTree (tH: handle): integer;	function GetNumTaxaInLinkTree (theLink: longint; linkH: Handle): integer;	procedure SetPackedNode (startP: ptr; place, setto: integer);	function GetPackedNode (startP: ptr; place: integer): integer;	procedure movepackedtoright (startP: ptr; istart, iend: integer);	procedure movepackedtoleft (startP: ptr; istart, iend: integer);	function PackedAncestorOf (startP: ptr; ie: integer): integer;	procedure DeletePackedTaxon (startP: ptr; idel, iend: integer);	function StartOFPackedTree (theChain, theLink: longint; treeH: Handle): ptr;	procedure ExciseTaxonFromCurrentTree (var N : Nptr); 	function AllocateCubePointer(N: Nptr):boolean;	function AllocateAllCubePointers(baseN: Nptr): boolean;	procedure DestroyCubePointer(N: Nptr);	procedure DestroyAllCubePointers(baseN: Nptr);	function CubeValueDouble(theCube: Ptr; iState,iFrom,iTo: integer): double;	procedure SetCubeValueDouble(theCube: Ptr; iState,iFrom,iTo: integer; value: double);	procedure CalcMaxMPRStateChar(ic: integer);	procedure CalcMaxMPRStateAll;	function MPRSquareSize: longint;	function CubeSize: longint;	function CubeValueLongint(theCube: Ptr; iState,iFrom,iTo: integer): longint;	procedure SetCubeValueLongint(theCube: Ptr; iState,iFrom,iTo: integer; value: longint);{еееееееееееееееееееееее}implementation {е$S TreeUtil}{v4: have a function that returns whether or not all trees in current tree file have polytomies, or all have ancon}{(mainly for charting facilities)}{-----------------------------------------------------------------------------}	procedure EmptyAssociatedTreeHandles;	begin		StringToH('0', fixdataH);		StringToH('0', segdataH); 		StringToH('0', realBranchLengthsDataH); 	end;{-----------------------------------------------------------------------------}	procedure DisposeNs (var N: Nptr);	begin		if NodeIsInternal(N) then			begin				DisposeNs(N^.lf);				DisposeNs(N^.rt);				ZapHandle(N^.lf^.dnstH);				ZapHandle(N^.lf^.upstH);				ZapHandle(N^.lf^.stsH);				ZapHandle(N^.rt^.dnstH);				ZapHandle(N^.rt^.upstH);				ZapHandle(N^.rt^.stsH);			end;	end;{-----------------------------------------------------------------------------}	procedure DisposeNODEs;	begin		if nodes then			begin				DestroyAllCubePointers(R);				DisposeNs(R);				ZapHandle(R^.dnstH);				ZapHandle(R^.upstH);				ZapHandle(R^.stsH);				ZapHandle(subR^.dnstH);				ZapHandle(subR^.upstH);				ZapHandle(subR^.stsH);				ZapHandle(subsubR^.stsH);				ZapPointer(Treeblock);  {This is what gets rid of all the tree structure}			end;		nodes := false;		treedrawn := false;	end;{-----------------------------------------------------------------------------}	function FillNode (N: Nptr): boolean;{v4: really now, we should allow trees to be built without filled nodes, for browsing, printing, etc!!}		var			amountneeded: longint;	begin		N^.fix := FALSE;		N^.fixanc := False;		N^.null := false;		N^.setLength := 1;		N^.realLength := realBranchLengthDefault;		N^.length1 := 0;   {v3.02: for showbranchlengths}		N^.length2 := 0;   {v3.02: for showbranchlengths}		N^.MPRCube := nil;		if not EnoughMemory(tcb * 3 * ord4(numchars), amountneeded) then			begin				N^.dnstH := NewHandle(0);				N^.upstH := NewHandle(0);				N^.stsH := NewHandle(0);				FillNode := false;			end		else			begin				N^.dnstH := NewHandle(tcb * ord4(numchars));				N^.upstH := NewHandle(tcb * ord4(numchars));				N^.stsH := NewHandle(tcb * ord4(numchars));				FillNode := MemoryOK;			end;	end;{-----------------------------------------------------------------------------}	function AnyNulls (N: Nptr): boolean;{FROZEN 3.0}		var			tb: boolean;  {returns true if any nulls}{..........}		procedure CheckNulls (NP: Nptr);  {finds if any nulls}		begin			if NP^.null then				tb := true			else if not tb & (NodeIsInternal(NP)) then				begin					CheckNulls(NP^.lf);					CheckNulls(NP^.rt);				end;		end;{..........}	begin		tb := false;		CheckNulls(N);		AnyNulls := tb;	end;{-----------------------------------------------------------------------------}	procedure setNullsOn;{FROZEN 3.0}	begin		nullson := anyNulls(R);		InvalidateWindow(twmesswindow, false);	end;{-----------------------------------------------------------------------------}	procedure CollapseClade (N: Nptr);{FROZEN 3.0}{collapses all internal nodes in clade N to yield bush}		procedure InCollapseClade (N: Nptr);		begin			if NodeIsInternal(N) then				begin					InCollapseClade(N^.lf);					InCollapseClade(N^.rt);					if N^.fix then						begin							dirtyfix := true;							N^.fix := false;  {fullundo posting not needed here since collapseclade automatically does this}						end;					N^.null := true;					CheckSetLengthsToDefaults(N);				end;		end;	begin		InCollapseClade(N);		SetFixon;		SetNullson;	end;{-----------------------------------------------------------------------------}	function AnyFixanc (N: Nptr): boolean;{FROZEN 3.0}		var			tb: boolean;		procedure CheckAnc (pN: Nptr);		begin   {checks if any "terminal" taxa ancestral}			if pN^.fixanc then				begin					if (pN^.name > 0) and not pN^.anc^.fixanc then						NewError(359, 0);					tb := true;				end;			if not tb and (NodeIsInternal(pN)) then				begin					CheckAnc(pN^.lf);					CheckAnc(pN^.rt);				end;		end;	begin		tb := false;		CheckAnc(N);		AnyFixanc := tb;	end;{-----------------------------------------------------------------------------}	procedure setAncOn;{FROZEN 3.0}		procedure SetFixancPolymorph (pN: Nptr);		begin   {checks if any "terminal" taxa ancestral have polymorphisms}			if IsTerminalFixanc(pN) & TaxonPolyFixancBeware(pN^.name) then				FixancPolymorph := true;			if not FixancPolymorph & (NodeIsInternal(pN)) then				begin					SetFixancPolymorph(pN^.lf);					SetFixancPolymorph(pN^.rt);				end;		end;	begin		ancon := AnyFixanc(R);		FixancPolymorph := false;		if ancon then			begin				myEnableItem(TreeMHdl, AllTermItem);				SetFixancPolymorph(R);			end{$IFC NOT ALWAYSENABLED}		else			myDisableItem(TreeMHdl, AllTermItem);{$ENDC}	end;{-----------------------------------------------------------------------------}	procedure OffAnc;  {var N : Nptr}{FROZEN 3.0}		procedure inOffAnc (pN: Nptr);		begin   {undoes all Make Ancestor}			pN^.fixanc := FALSE;			if NodeIsInternal(pN) then				begin					InOffAnc(pN^.lf);					InOffAnc(pN^.rt);				end;		end;	begin		InOffAnc(N);		SetAncOn;	end;{-----------------------------------------------------------------------------}	function IsAnc; {(N, cN : Nptr) : BOOLEAN}{FROZEN 3.0}{checks if N ancestor of cN or same as cN}		var			yesanc: boolean;{...............}		procedure CheckIfAnc (LcN: Nptr);		begin			if LcN = N then				yesanc := true			else if LcN <> R then {don't really need recursion}				CheckIfAnc(LcN^.anc);		end;{...............}	begin		yesanc := false;		CheckifAnc(cN);		IsAnc := yesanc;	end;{-----------------------------------------------------------------------------}	function NodeisTerminal (N: Nptr): boolean;{FROZEN 3.0}	begin		NodeIsterminal := (N<> nil) & (N^.name > 0);	end;{-----------------------------------------------------------------------------}	function NodeisInternal (N: Nptr): boolean;{FROZEN 3.0}	begin		NodeisInternal := (N<> nil) & (N^.name = 0);	end;{-----------------------------------------------------------------------------}	function BranchExists (N: Nptr): Boolean;{FROZEN 3.0}	begin		BranchExists := not ((N = nil) | N^.null | (N^.fixanc & (NodeIsTerminal(N))));	end;{-----------------------------------------------------------------------------}	function IsTerminalFixanc (N: Nptr): Boolean;{true if N is terminal node fixanced onto ancestor (to user, N therefore does not exist)}{FROZEN 3.0}	begin		IsTerminalFixanc := N^.fixanc & (NodeIsTerminal(N));	end;{-----------------------------------------------------------------------------}	function TermOfFixanc (N: Nptr): Nptr; {finds node that is fixanced onto N; only to be used if N is indeed fixanced}{FROZEN 3.0}	begin {Duplicates Terminalfixancing in charUtil!!!}		if IsTerminalFixanc(N^.rt) then			TermOfFixanc := N^.rt		else			TermOfFixanc := N^.lf;	end;{-----------------------------------------------------------------------------}	function DescOfFixanc (N: Nptr): Nptr;{FROZEN 3.0}	begin		if IsTerminalFixanc(N^.lf) then			DescOfFixanc := N^.rt		else			DescOfFixanc := N^.lf;	end;{-----------------------------------------------------------------------------}	function IsFixancedUpon (N: Nptr): Boolean;{FROZEN 3.0}	begin		IsFixancedUpon := (NodeIsInternal(N)) & (N^.fixanc);	end;{-----------------------------------------------------------------------------}	function NodeSlantsRight (N: Nptr): boolean;{FROZEN 3.0}	begin{$IFC DEBUG}		if (N^.anc^.rt = N) <> (N^.slant = 1) then			NewError(34, 0);{$ENDC}		NodeSlantsRight := N^.anc^.rt = N;	end;{-----------------------------------------------------------------------------}	function SinglesCloseEnough(s1,s2: single; sigdigits: integer): boolean;	var ir : integer;		closeness, diff: single;	begin		closeness := 1 * exp(-sigdigits);		diff := (s1-s2);		if diff > 0 then			singlesCloseEnough := (-diff < closeness)		else			singlesCloseEnough := (diff < closeness);	end;{-----------------------------------------------------------------------------}	procedure CheckSetLengthsToDefaults(N: Nptr);	begin		if N^.setLength <> 1 then			begin				NewError(390, 0);				N^.setLength := 1;			end;		if not SinglesCloseEnough(N^.realLength ,realBranchLengthDefault,branchLengthSigDigits) then			begin				NewError(390, 0);				N^.realLength := realBranchLengthDefault;			end;	end;{-----------------------------------------------------------------------------}	function allRealLengthsDefault: boolean;		label			1;		var			all1realLength: boolean;{..............}		procedure incheckRealLengths (var N: Nptr);		begin			if BranchExists(N) & not SinglesCloseEnough(N^.realLength,realBranchLengthDefault,branchLengthSigDigits) then				begin					all1realLength := false;					goto 1;				end;			if N^.name = 0 then				begin					incheckRealLengths(N^.lf);					incheckRealLengths(N^.rt);				end;		end;{..............}	begin		all1realLength := true;		incheckRealLengths(R);1:		allRealLengthsDefault := all1realLength;	end;{-----------------------------------------------------------------------------}	function allSetLengths1: boolean;		label			1;		var			all1setlength: boolean;{..............}		procedure incheckSetLengths (var N: Nptr);		begin			if BranchExists(N) & (N^.setLength <> 1) then				begin					all1setlength := false;					goto 1;				end;			if N^.name = 0 then				begin					incheckSetLengths(N^.lf);					incheckSetLengths(N^.rt);				end;		end;{..............}	begin		all1setlength := true;		incheckSetLengths(R);1:		allSetLengths1 := all1setLength;	end;{-----------------------------------------------------------------------------}	procedure ResetForNew;  {reset for new data or getting tree from file}	begin		justchanc := false;		expd := FALSE;		fixon := FALSE;		ancon := false;		polyon := false;	end;{-----------------------------------------------------------------------------}{---------------------------------------------------------------------}{FLIPTREE STUFF  v4: }{How it was done: to flip the tree I simply intervened at the drawing stage and at the information finding stage.}{	That is, N^.loc's and other graphic locations still have the exact same coordinate values as if the}{	tree had not been flipped (except that the differeing window space available sideways tends to}{	compress the tree), but all drawing calls into the tree window itself (with a few special exceptions)}{	must not use the regular MoveTo, LineTo, etc, but the treeflipped-sensitive commands below. }{	All such commands contain the word Orient in their names, and thus can be easily found throughout the}{	text.  Note that I have not conditionally compiled these because (a) it would have been a nuisance given the}{	scattered occurrences of these drawing calls,  (b) they can easily be removed by replacing Orient by}{	nothing,  (c) they cost little timewise and very little sizewise, (d) we will want trees on their}{	side soon enough, and (e) they are completely safe as they are, since every Orient utility returns}{	back exactly what it was given if treeflipped is false.  There are a few special things in the code }{	(such as the placement of the legends) which can be found easily by searching for treeflipped.}{Expected rules:  all graphics objects in the tree window are positioned relative to what I will call "tree coordinates", }{	which may be rotated 90 degrees relative to windows coordinates (the entire system works very much}{	like LocaltoGlobal and GlobalToLocal).  This should include N^.loc's, taxon boxes, }{	databoxes boxes including DataboxB and clasprect, and I suppose DrawTWR.  }{NOTE clasprect is not rotated - I can see no reason for it.  It is not an element}{of the tree}{	On the other hand, visTWR must be specified with respect}{	to window coordinates, as must clip regions.  Clip Rects can be requested via rectangles in tree coordinates as long as}{	ClipRectOrient is called to .  Is there a comment explaining the differences between}{	treerect, drawTWR, and visTWR??}{Current status:  }{Drawing: the basic drawing is in OK shape except for opposite VerticalString command needed to rotate text down}{	for labels on branches, if that is what we want, and except for data boxes, the main problems of which concern }{	(I think) topmargin via nattop via TWOrigin via scroll positioning, and there are no doubt problems with}{	 cliprects.}{Clipping: cliprects and clip regions are probably in rough shape, because we need to reorient tree-coordinate based}{	rectangles like databoxB before using them to formulate cliprects and regions}{Mouse watching: needs work; i.e. when something in tree window is clicked on, the window coordinates of the click}{	must be matched up against the tree coordinates of the objects in the window.  This is done in part (e.g., for}{	the branches themselves), but no doubt many bugs remain.  Mouse-watching as in Cursor and MouseInTree}{	will need to be carefully gone over to ensure that all questions about points on the tree drawing surface itself are}{	asked with respect to the tree coordiantes.  Where possible, it would be good to isolate all questions about movements}{	over the tree surfaces to a block of code (apart from questions about chleg, twmessageB, scrolls, etc.) which can}{	internally be entirely phrased in terms of tree coordinates, and points are translated into tree coordinates at the start}{	of it.}{Scrolling needs to be fixed, presumably by making scroll up think it is scroll left, etc.  Note that the home position of}{	scroll bars when the tree in flipped position is vertical up and horizontal to the right (instead of left).}{	Scrolling data boxes will be a pain since the control needs to be moved.}{Printing: I have no idea what havoc treeflipping will cause.  At present the tree itself does not come up flipped,}{	since you use your own drawing routines, but the character tracing does show up flipped on top of the tree, since}{	there you use general coloring calls.  If printing turns out to be a major hurdle, we might want to replace }{	all "treeflipped" to "treeflipped & not printon" throughout the program to prohibit}{	flipping in tree preview window, but this should be viewed as temporary, since some people will want }{	legends and text to be upright on a flipped tree, which cannot be obtained via page setup}{=============ABSOLUTE MOVES, COMMANDS=================}{---------------------------------------------------------------------}	function OrientHoriz (h, v: longint): integer;{given treeCoordinate h,v, returns horizontal value on window}{note that this doesn't work if h,v are true location in window}	var horiz: longint;	begin{v4: is visTWR.topright the best point to use as origin in this system?}{$IFC FLIPTREE}		if treeflipped then			begin				horiz := visTWR.right - v;			end		else{$ENDC}			horiz := h;		 if (horiz>maxint) then			horiz := 32000;		OrientHoriz := horiz;	end;{---------------------------------------------------------------------}	function OrientVert (h, v: longint): integer;{given treeCoordinate h,v, returns vertical value on window}	var vert: longint;	begin{$IFC FLIPTREE}		if treeflipped then			vert := visTWR.top + h		else{$ENDC}			vert := v;		if (vert>maxint) then			vert := 32000;		OrientVert := vert;	end;{---------------------------------------------------------------------}	function DisOrientPoint (pt: point): point;{given Window Coordinate pt, returns pt on tree coordinates}		var			pnew: point;	begin{$IFC FLIPTREE}		if treeflipped then			begin				pnew.v := visTWR.right - pt.h;				pnew.h := pt.v - visTWR.top;				DisOrientPoint := pnew;			end		else{$ENDC}			DisOrientPoint := pt;	end;{---------------------------------------------------------------------}	function OrientPoint (pt: point): point;{given treeCoordinate pt, returns pt on window coordinates}		var			pnew: point;	begin{$IFC FLIPTREE}		if treeflipped then			begin				pnew.h := visTWR.right - pt.v;				pnew.v := visTWR.top + pt.h;				OrientPoint := pnew;			end		else{$ENDC}			OrientPoint := pt;	end;{---------------------------------------------------------------------}	function OrientRect (r: rect): rect;{given treeCoordinate rect, returns rect on window coordinates}		var			box: rect;	begin{$IFC FLIPTREE}		if treeflipped then			begin				SetRect(box, visTWR.right - r.bottom, visTWR.top + r.left, visTWR.right - r.top, visTWR.top + r.right);				OrientRect := box;			end		else{$ENDC}			OrientRect := r;	end;{---------------------------------------------------------------------}	procedure MoveToOrient (h, v: longint);{given tree coordinates h,v, moves pen to the pt on window coordinates}		var			pt: point;	begin		MoveTo(OrientHoriz(h, v), OrientVert(h, v))	end;{---------------------------------------------------------------------}	procedure LineToOrient (h, v: longint);{given tree coordinates h,v, does lineto to the pt on window coordinates}	begin		LineTo(OrientHoriz(h, v), OrientVert(h, v))	end;{---------------------------------------------------------------------}	function PtInRectOrient (pt: point; r: rect): boolean;{given window Point pt, asks if in rect r which is tree coordiante based}	begin		PtInRectOrient := PtInRect(pt, OrientRect(r));	end;{---------------------------------------------------------------------}	procedure ClipRectOrient (r: rect);{given rect r based on tree coordinates, sets as cliprect}	begin		Cliprect(OrientRect(r));	end;{---------------------------------------------------------------------}	procedure EraseRectOrient (r: rect);{given rect r based on tree coordinates, erases}	begin		eraserect(OrientRect(r));	end;{---------------------------------------------------------------------}	procedure FrameRectOrient (r: rect);{given rect r based on tree coordinates, frames}	begin		FrameRect(OrientRect(r));	end;{---------------------------------------------------------------------}	procedure FillRectOrient (r: rect; pat: pattern);{given rect r based on tree coordinates, fills}	begin		FillRect(OrientRect(r), pat);	end;{---------------------------------------------------------------------}	procedure DrawStringOrient (ds: str255);{given string designed to be written horizontally in tree coordinates, writes in window coordinates}	begin{$IFC FLIPTREE}		if treeflipped then			VerticalString(ds, true)  {v4: fliptree: need new version of VerticalString which is passed parameter up or down}		else{$ENDC}			DrawString(ds);	end;{---------------------------------------------------------------------}	procedure VerticalStringOrient (ds: str255);{given string designed to be written vertically in tree coordinates, writes in window coordinates}	begin{$IFC FLIPTREE}		if not treeflipped then{$ENDC}			VerticalString(ds, true){$IFC FLIPTREE}		else			DrawString(ds);{$ENDC}	end;{---------------------------------------------------------------------}{RELATIVE MOVES, COMMANDS}{---------------------------------------------------------------------}	procedure MoveOrient (h, v: integer);{moves pen in window coordinats to correspond to movement of h,v in tree coordinates}	begin{$IFC FLIPTREE}		if treeflipped then			Move(-v, h)		else{$ENDC}			Move(h, v);	end;{---------------------------------------------------------------------}	procedure LineOrient (h, v: integer);{extends line in window coordinats to correspond to movement of h,v in tree coordinates}	begin{$IFC FLIPTREE}		if treeflipped then			Line(-v, h)		else{$ENDC}			Line(h, v);	end;{---------------------------------------------------------------------}	procedure PenSizeOrient (h, v: integer);{sets pensize in window coordinats to correspond to  h,v in tree coordinates}	begin{$IFC FLIPTREE}		if treeflipped then			PenSize(v, h)		else{$ENDC}			PenSize(h, v);	end;{---------------------------------------------------------------------}	procedure offsetRectOrient (var r: rect; h, v: integer);{offsets rectangle in window coordinates to correspond to  h,v in tree coordinates}	begin{$IFC FLIPTREE}		if Treeflipped then			offSetRect(r, -v, h)		else{$ENDC}			offSetRect(r, h, v);	end;{---------------------------------------------------------------------}	procedure InsetRectOrient (var r: rect; h, v: integer);{insets rectangle in window coordinates to correspond to  h,v in tree coordinates}	begin{$IFC FLIPTREE}		if Treeflipped then			InsetRect(r, v, h)		else{$ENDC}			InsetRect(r, h, v);	end;{---------------------------------------------------------------------}	procedure OffSetRgnOrient (var reg: RgnHandle; h, v: integer);{offsets region in window coordinates to correspond to  h,v in tree coordinates}	begin{$IFC FLIPTREE}		if Treeflipped then			offSetRgn(reg, -v, h)		else{$ENDC}			offSetRgn(reg, h, v);	end;{---------------------------------------------------------------------}	procedure OffSetPOLYOrient (var Poly: polyHandle; h, v: integer);{offsets poly in window coordinates to correspond to  h,v in tree coordinates}	begin{$IFC FLIPTREE}		if Treeflipped then			offSetPoly(Poly, -v, h)		else{$ENDC}			offSetPoly(Poly, h, v);	end;{-----------------------------------------------------------------------------}{-----------------------------------------------------------------------------}	function tickOverHang: integer;	var overhang: integer;	begin		overhang := 4;		if overhang*2 + edw > txsp -2 then			overhang := 3;		if overhang*2 + edw > txsp -2 then			overhang := 2;		tickOverHang := overhang+extraOverHang;			end;{-----------------------------------------------------------------------------}	function JustRightTickOverHang: integer;	var overHang: integer;	begin		TextFont(maccladesmall);		TextFace([]);		overHang := StringWidth(StringFromNum(numchars));		if overhang > txsp then			overhang := txsp;		TextFont(treetaxafont);		TextFace(treetaxastyle);		JustRightTickOverHang := overHang;	end;{-----------------------------------------------------------------------------}	function PtInBranch (pt: POINT; N: Nptr; wideTool, justRight: boolean): boolean;{FROZEN 3.0}		var			ans: boolean;			d, t, p, q: integer;			aNh, aNv, Nh, Nv: integer;			pNh, pNhedw, aNNv, prodhv, prodhedwv: longint;			aN: Nptr;			ptt: point;			tempEdw: integer;			rightOverHang: integer;	begin		ptt := DisOrientPoint(pt);		ans := false;		aN := NotNullAnc(N);		Nv := N^.loc.v;		Nh := N^.loc.h;   {branchlengths}		aNh := aN^.loc.h;		aNv := aN^.loc.v;		if wideTool then			begin				tempEdw := gedw+tickOverHang*2;				Nh := nh - tickOverHang;				aNh := aNh - tickOverHang;			end		else 			tempEdw := gedw;		if justRight then			rightOverHang := tickOverHang+JustRightTickOverHang 		else			rightOverHang := 0;{if Nh < aNh then}{begin if branchwidth > 0 then begin Nv := Nv + branchwidth; aNv := aNv + branchwidth;}{end; end;}{$IFC TINKERTOY}		if TinkerTree & PtInRectOrient(ptt, GetTinkerBox(N)) then			ans := true		else{$ENDC}{$IFC SQUAREBRANCHES}			if squareBranches then				begin					if (ptt.v >= Nv) and (ptt.v <= aNv) then						begin							if (ptt.h >= Nh) and (ptt.h <= Nh + tempEdw+rightOverHang) then								ans := true;						end;				end			else{$ENDC}				if N^.anc^.null then					begin  {ANC NULL}						if (ptt.v >= Nv) and (ptt.v <= aNv) then							begin								pNh := (ptt.h - Nh);								pNhedw := (ptt.h - Nh - tempEdw);								aNNv := (aNv - Nv);								prodhv := pNh * aNNv;								prodhedwv := pNhedw * aNNv;								if Nh < aNh then									ans := (ptt.v < Nv + prodhv div (aNh - Nh)) and (ptt.v > Nv + prodhedwv div (aNh - Nh))								else if Nh > aNh then									ans := (ptt.v > Nv + prodhv div (aNh - Nh)) and (ptt.v < Nv + prodhedwv div (aNh - Nh))								else									ans := (ptt.h >= Nh) and (ptt.h <= Nh + tempEdw+rightOverHang);							end;					end  {ANC NULL}				else					begin						if NodeSlantsRight(N) then							begin								t := Nh + tempEdw + 1+rightOverHang;								d := Nv;								p := aNh + tempEdw div 2 - 1+rightOverHang;								q := aNv - tempEdw div 2;							end						else							begin								t := aNh + tempEdw div 2 + 1+rightOverHang;								d := aNv - tempEdw div 2;								p := Nh - 1;								q := Nv;							end;						if (ptt.h > p) and (t > ptt.h) and (abs(ptt.v - d) < abs(t - ptt.h)) and (abs(ptt.v - q) < abs(p - ptt.h)) then							ans := true;					end;		PtInBranch := ans;	end;{-----------------------------------------------------------------------------}	function LocationIndicatesCladeSize: boolean;	begin		LocationIndicatesCladeSize := not ( (condensedBranches | ((traceshown = traceAllChanges) & showbranchlengths)) & squarebranches);	end;{-----------------------------------------------------------------------------}	function FirstCladeIsBigger (N1, N2: Nptr): boolean;{returns true if clade N1 has more taxa than clade N2}	begin		if LocationIndicatesCladeSize then			FirstCladeIsBigger := N1^.loc.v > N2^.loc.v		else			FirstCladeIsBigger := SizeOfClade(N1, false) > SizeOfClade(N2, false);	end;{-----------------------------------------------------------------------------}	function LeftEdgeOfClade (N: Nptr; wideTool, justRight: boolean): integer;{returns the leftmost point in the clade above N}	var overHang: integer;	begin		if wideTool then			overHang := tickOverhang		else			overHang := 0;		if NodeIsTerminal(N) then			LeftEdgeOfClade := N^.loc.h-overHang		else if squareBranches & (((traceshown = traceAllChanges) & showbranchlengths) | centerSquareBranches | condensedBranches | (treeScaleVert <> 1.0)) then			LeftEdgeOfClade := LeftMostDescendant(N)^.loc.h-overHang		else			LeftEdgeOfClade := N^.loc.h - (N^.loc.v - topmargin)-overHang;  {we know that we can use the triangle rules}	end;{-----------------------------------------------------------------------------}	function RightEdgeOfClade (N: Nptr; wideTool, justRight: boolean): integer;{returns the rightmost point in the clade above N}	var overHang: integer;	begin		if justRight then			begin				overHang := tickOverhang+JustRightTickOverHang;			end		else if WideTool then			overHang := tickOverHang		else			overHang := 0;		if NodeIsTerminal(N) then			RightEdgeOfClade := N^.loc.h + gedw+overHang		else if squareBranches & (((traceshown = traceAllChanges) & showbranchlengths) | centerSquareBranches | condensedBranches | (treeScaleVert <> 1.0)) then			RightEdgeOfClade := RightMostDescendant(N)^.loc.h + gedw+overHang		else			RightEdgeOfClade := N^.loc.h + (N^.loc.v - topmargin) + gedw+overHang;  {we know that we can use the triangle rules}	end;{-----------------------------------------------------------------------------}	function PtInClade (pt: POINT; N: Nptr; wideTool, justRight: boolean): boolean;{FROZEN 3.0}{used by FindBranch}		var			ans: boolean;			ptt: point;	begin		ptt := DisOrientPoint(pt);		ans := (ptt.v >= topmargin) & (ptt.v <= N^.loc.v);  {it is in vertical bounds of clade}		PtInClade := ans & (ptt.h >= LeftEdgeOfClade(N,wideTool,justRight)) & (ptt.h <= RightEdgeOfClade(N,wideTool,justRight));  {it is in horizontal bounds of clade}	end;{-----------------------------------------------------------------------------}	procedure FindBranch (pt: point; N: Nptr; wideTool: boolean);{FROZEN 3.0}		procedure findBRec (pN: Nptr);		begin			if (NodeIsInternal(pN)) then				begin					if not pN^.null then						begin							if PtInClade(pt, pN,wideTool, false) then								begin									findBRec(pN^.lf);									if fn = subR then										findBRec(pN^.rt);								end							else if fn = subR then								if PtInBranch(pt, pN,wideTool,false) then									fn := pn;						end					else						begin							findBRec(pN^.lf);							if fn = subR then								findBRec(pN^.rt);						end;				end			else if PtInBranch(pt, pN,wideTool,false) then				fn := pn;		end;	begin		fn := subR;		findBRec(N);	end;{-----------------------------------------------------------------------------}	function FindJustRightOfBranch (pt: point; N: Nptr; var foundN: Nptr): boolean;		procedure findnearBRec (pN: Nptr);		begin			if (NodeIsInternal(pN)) then				begin					if not pN^.null then						begin							if PtInClade(pt, pN,false, true) then								begin									findnearBRec(pN^.lf);									if foundN = subR then										findnearBRec(pN^.rt);								end							else if foundN = subR then								if PtInBranch(pt, pN,false, true) then									foundN := pn;						end					else						begin							findnearBRec(pN^.lf);							if foundN = subR then								findnearBRec(pN^.rt);						end;				end			else if PtInBranch(pt, pN,false, true) then				foundN := pn;		end;	begin		foundN := subR;		findnearBRec(N);		FindJustRightOfBranch := foundN <> subR	end;{-----------------------------------------------------------------------------}	function Sis (N: Nptr): Nptr; {FROZEN 3.0}{finds sister node to node N, even if null}		var			tsis: nptr;	begin		if N^.anc^.rt = N then			tSis := N^.anc^.lf		else			tSis := N^.anc^.rt;		if tsis = nil then			tsis := N;		Sis := tsis;	end;{-----------------------------------------------------------------------------}	function LeftMostDescendant (N: Nptr): Nptr;{FROZEN 3.0}{finds leftmost terminal taxon descendant from N;}{compare to FirstNonNullLeft , whichi finds leftmost immediate descendant}		var			lN: Nptr;	begin		lN := N;		while NodeIsInternal(lN) do			lN := lN^.lf;		LeftMostDescendant := lN;	end;{----------------------------------------------------------}	function NotNullAnc (N: Nptr): Nptr;{FROZEN 3.0}{finds the first ancestor  below N that is not null}		var			aN: Nptr;	begin		aN := N^.anc;		while (aN^.null) do			aN := aN^.anc;		NotNullAnc := aN;	end;{-----------------------------------------------------------------------------}	function farthestright (N: Nptr): integer;{FROZEN 3.0}{returns horizontal location of farthest right node among IMMEDIATE descendants of N}{Compare to RightMostDescendant in TreeUtil and firstNonNullLeft in treeUtil}		var			rN: Nptr;	begin		if NodeIsInternal(N) then			begin				rN := N^.rt;				while (rN^.null) and (NodeIsInternal(rN)) do					rN := rN^.rt;			end		else			rN := N;		farthestright := rN^.loc.h;	end;{-----------------------------------------------------------------------------}	function farthestleft (N: Nptr): integer;{FROZEN 3.0}{returns horizontal location of farthest left node among IMMEDIATE descendants of N}{Compare to LeftMostDescendant in TreeUtil}		var			lN: Nptr;	begin		if NodeIsInternal(N) then			begin				lN := N^.lf;				while (lN^.null) and (NodeIsInternal(lN)) do					lN := lN^.lf;			end		else			lN := N;		farthestleft := lN^.loc.h;	end;{-----------------------------------------------------------------------------}	function RightMostDescendant (N: Nptr): Nptr;{FROZEN 3.0}{finds rightmost terminal taxon descendant from N;}{compare to farthestright in charUtil, whichi finds rightmost immediate descendant}		var			rN: Nptr;	begin		rN := N;		while NodeIsInternal(rN) do			rN := rN^.rt;		RightMostDescendant := rN;	end;{-----------------------------------------------------------------------------}	function firstNonNullLeft (pN: Nptr): Nptr;{FROZEN 3.0}{if pN is not null, returns pn; otherwise returns first descendant left that is not null}	begin		if pN^.null then			firstNonNullLeft := firstNonNullLeft(pN^.lf)		else			firstnonnullleft := pN;	end;{-----------------------------------------------------------------------------}	function firstNonNullRight (pN: Nptr): Nptr;{FROZEN 3.0}{if pN is not null, returns pn; otherwise returns first descendant right that is not null}	begin		if pN^.null then			firstNonNullRight := firstNonNullRight(pN^.rt)		else			firstNonNullRight := pN;	end;{-----------------------------------------------------------------------------}	function NextSisterRight (N: Nptr): Nptr;{FROZEN 3.0}{Finds next sister to the right of N.}{Especially used when N is part of polytomy, to bounce along the sisters}		var			sister, leftanc: Nptr;	{....}		function FindLeftSlantAncestor (pN: Nptr): Nptr;		begin			if not NodeSlantsRight(pN) | (pN = R) | (not pN^.null & (pN <> N)) then				FindLeftSlantAncestor := pN			else				FindLeftSlantAncestor := FindLeftSlantAncestor(pN^.anc);		end;	{....}	begin		if not NodeSlantsRight(N) then {N leans left, then go to sister and find it or its first descendant}			begin				sister := sis(N);				NextSisterRight := firstNonNullLeft(sister)			end		else			begin				if N^.anc^.null then					begin						leftanc := FindLeftSlantAncestor(N); {Find first ancestor which slants left}						if (leftanc^.null) then  {if it is null, then its sister must be or have descendant which is next sister right}							begin								sister := sis(leftanc);								NextSisterRight := firstNonNullLeft(sister)							end						else  {if leftanc is not null, then N must already be rightmost in its clade}							NextSisterRight := N;					end				else					NextSisterRight := N; {if not N^.anc^.null then N must already be rightmost in its clade}			end;	end;{-----------------------------------------------------------------------------}	function NodeOfNumber (ni: integer): Nptr;{FROZEN 3.0}{returns which node is numbered ni; numbering system is 1 through numtaxain for observed taxa, whether}{terminal or fixed as ancestors; numtaxain+1 and upward for internal nodes traversed in a left to right manner}{up the tree.  The root of the tree therefore recieves number numtaxain+1}		var			nodecount: integer;			fnode: Nptr;			isinternal: boolean;{..............}		procedure FindNumber (pN: Nptr);		begin			if fnode = nil then				begin					if BranchExists(pN) then						begin							if (isinternal & ((NodeIsInternal(pN)) & not pN^.fixanc)) | (not isinternal & (NodeIsTerminal(pN) | pN^.fixanc)) then								nodecount := nodecount + 1;							if (nodecount = ni) then								fnode := pN;						end;					if NodeIsInternal(pN) then						begin							FindNumber(pN^.lf);							FindNumber(pN^.rt);						end;				end;		end;{..............}	begin		isinternal := ni > numtaxain;		if isinternal then {it's an internal node, startcount off at numtaxain}			nodecount := numtaxain		else			nodecount := 0;		fnode := nil;		FindNumber(R);		NodeOfNumber := fnode;	end;{-----------------------------------------------------------------------------}	function NumberofNode (N: Nptr): integer;{FROZEN 3.0}{returns the number of node N; the numbering system is explained under NodeofNumber, above}		var			nodecount: integer;			nodefound, isInternal: boolean;{..............}		procedure FindNode (pN: Nptr);		begin			if not nodefound then				begin					if BranchExists(pN) then						begin							if (isinternal & ((NodeIsInternal(pN)) & not pN^.fixanc)) | (not isinternal & (NodeIsTerminal(pN) | pN^.fixanc)) then								nodecount := nodecount + 1;							if (pN = N) then								nodefound := true						end;					if NodeIsInternal(pN) then						begin							FindNode(pN^.lf);							FindNode(pN^.rt);						end;				end;		end;{..............}	begin		nodefound := false;		isinternal := (NodeIsInternal(N)) and not N^.fixanc;		if isinternal then {it's an internal node, startcount off at numtaxain}			nodecount := numtaxain		else			nodecount := 0;		FindNode(R);		if nodefound then			NumberofNode := nodecount		else			nUmberofNode := 0;	end;{-----------------------------------------------------------------------------}	procedure CalcNodeTriangle;		var			lengthTri, halflength: integer;			tport: WindowPtr;	begin		genericGetPort(tport);		genericSetPort(treewindow);{====defining nodeclip====}		OpenRgn;		MovetoOrient(1, 0);		LinetoOrient(edw - 1, 0);		linetoOrient(edw div 2, 1 - edw div 2);		linetoOrient(1, 0);		CloseRgn(NodeClip);{$IFC TRUE}		KillPoly(NodeTriangle);		Nodetriangle := OpenPoly;		MovetoOrient(0, 0);		if not odd(edw) then			begin				lengthTri := edw - 2;				LineToOrient(lengthTri, 0);   {bottom of triangle}				linetoOrient(lengthTri div 2, -lengthTri div 2);   {right side of triangle}			end		else			begin				lengthTri := edw - 2;				halflength := lengthTri div 2;				LineToOrient(lengthTri, 0);   {bottom}				linetoOrient(lengthTri - halflength, -halflength);   {right side}				lineOrient(-1, 0);    {flat top}			end;		linetoOrient(0, 0);    {left side}		ClosePoly;		if savepicton then			offsetpolyOrient(nodetriangle, 0, 1)		else if not printon then			OffSetPolyOrient(NodeTriangle, 1, 1);{$ENDC}{$IFC FALSE}		KillPoly(NodeTriangle);		Nodetriangle := OpenPoly;		MovetoOrient(0, 0);		if odd(edw) then			begin				lengthTri := edw - 1;				LineToOrient(lengthTri, 0);   {bottom of triangle}				linetoOrient(lengthTri div 2, -lengthTri div 2);   {right side of triangle}			end		else			begin				lengthTri := edw - 1;				halflength := lengthTri div 2;				LineToOrient(lengthTri, 0);   {bottom}				linetoOrient(lengthTri - halflength, -halflength);   {right side}				lineOrient(-1, 0);    {flat top}			end;		linetoOrient(0, 0);    {left side}		ClosePoly;		if savepicton then			offsetpolyOrient(nodetriangle, 0, 1)		else if not printon then			OffSetPolyOrient(NodeTriangle, 1, 1);{===}		KillPoly(NodeTriangle);		Nodetriangle := OpenPoly;		if printon then			MovetoOrient(0, 0)		else			MovetoOrient(1, 0);		LinetoOrient(edw - 1, 0);		linetoOrient(edw div 2, 1 - edw div 2);		if printon then			linetoOrient(0, 0)		else			linetoOrient(1, 0);		ClosePoly;{$ENDC}		genericSetPort(tport);	end;{----------------------------------------------------------------------------}	procedure VertTWScrollPosition;		const			indent = 10;	begin		with WindowPortRect(treeWindow) do			if nex7on then				begin{$IFC FLIPTREE}					if treeflipped then						begin							SizeControl(databoxScroll, databoxB.bottom - 2 - n7splitW, scrollwidth + 1);							if twfullscreen then								begin									MoveControl(databoxScroll, right - scrollwidth - indent - databoxB.bottom, bottom - scrollwidth - indent);									databoxB.right := bottom - scrollwidth - indent;								end							else								begin									MoveControl(databoxScroll, right - scrollwidth - databoxB.bottom, bottom - scrollwidth);									databoxB.right := bottom - scrollwidth;								end;{    MoveControl(vTWScroll, right - scrollwidth, databoxB.bottom);}							SizeControl(hTWscroll, right - scrollwidth - 1 - (databoxB.bottom) + 2, scrollwidth + 1);						end					else						begin							SizeControl(databoxScroll, scrollwidth + 1, databoxB.bottom - 2 - n7splitW);							if twfullscreen then								begin									MoveControl(databoxScroll, right - scrollwidth - indent, 3);									databoxB.right := right - scrollwidth - indent;								end							else								begin									MoveControl(databoxScroll, right - scrollwidth, 3);									databoxB.right := right - scrollwidth;								end;							MoveControl(vTWScroll, right - scrollwidth, databoxB.bottom);							SizeControl(vTWscroll, scrollwidth + 1, bottom - scrollwidth - 1 - (databoxB.bottom) + 2);						end;{$ELSEC}					SizeControl(databoxScroll, scrollwidth + 1, databoxB.bottom - 2 - n7splitW);					if twfullscreen then						begin							MoveControl(databoxScroll, right - scrollwidth - indent, 3);							databoxB.right := right - scrollwidth - indent;						end					else						begin							MoveControl(databoxScroll, right - scrollwidth, 3);							databoxB.right := right - scrollwidth;						end;					MoveControl(vTWScroll, right - scrollwidth, databoxB.bottom);					SizeControl(vTWscroll, scrollwidth + 1, bottom - scrollwidth - 1 - (databoxB.bottom) + 2);{$ENDC}					SetTWScrollMax;					SetControlMinimumLong(databoxScroll, 1);					SetControlMaximumLong(databoxScroll, IntegerMax(1, numchars - numboxes + 1));					SetControlValueLong(databoxScroll, i7);				end			else				begin					SizeControl(databoxScroll, scrollwidth + 1, 0);					MoveControl(databoxScroll, right - scrollwidth, 3);					MoveControl(vTWScroll, right - scrollwidth, 3);					SizeControl(vTWscroll, scrollwidth + 1, bottom - scrollwidth - 2);				end;	end;{----------------------------------------------------------------------------}	procedure SetTWScrollMax;		var			k: longint;			curV: longint;			vScroll, hScroll: ControlRef;	begin{$IFC FLIPTREE}		if treeflipped then				begin				vScroll := hTWScroll;				hScroll := vTWScroll;				databoxBHeight := databoxB.bottom;			end		else			begin				vScroll := vTWScroll;				hScroll := hTWScroll;				databoxBHeight := (databoxB.bottom - TWorigV);			end;{$ELSEC}		vScroll := vTWScroll;		hScroll := hTWScroll;		databoxBHeight := (databoxB.bottom - TWorigV);{$ENDC}		k := drawTWR.bottom - visTWR.bottom;		if k < 0 then			k := 0;		curV := GetControlValueLong(vScroll);		if nex7on then			begin				SetControlMaximumLong(vScroll, k + (databoxBHeight - nattop));				SetControlMinimumLong(vScroll, -nattop);			end		else			begin				SetControlMaximumLong(vScroll, k);				SetControlMinimumLong(vScroll, 0);			end;{v3.02: next little section}		if curV < GetControlMinimumLong(vScroll) then			SetControlValueLong(vScroll, GetControlMinimumLong(vScroll))		else if curV > GetControlMaximumLong(vScroll) then			SetControlValueLong(vScroll, GetControlMaximumLong(vScroll));		if TWOrigin.v <> GetControlValueLong(vScroll) then			godraw := true;		TWOrigin.v := GetControlValueLong(vScroll);{end v3.02 section}		k := drawTWR.right - visTWR.right;		if k < 0 then			k := 0;		SetControlMaximumLong(hScroll, k);{checkTools := true;}	end;{-----------------------------------------------------------------------------}	function RoomNeededOnRight: integer;{if there are labels written on the branches, then one needs to be able to scroll over to the right more.}{This function calculates how much more one needs to scroll}{Note that it is primitive, not calculating, for example, the string width of strings written on the right-most}{branches.  It just uses a constant. }	begin		if (traceshown = traceAllChanges) & (summaryview = asticks) then			begin				if tickstates & ticknames then					RoomNeededOnRight := 200				else if tickstates or ticknames then					RoomNeededOnRight := 75				else					RoomNeededOnRight := 10;			end		else if (traceshown = traceDiscrete) & showtracelabels & tracelabelsbyname then			RoomNeededOnRight := 30		else if (traceshown = traceContinuous) & ShowContTraceLabels then			RoomNeededOnRight := 30		else if (traceshown = traceProbability) & showProbTraceLabels then			RoomNeededOnRight := 30		else			RoomNeededOnRight := 0;	end;{-----------------------------------------------------------------------------}	procedure ZeroTreeOrigin;	begin{v3.02:    SetPt(TWOrigin, 0, 0);}		SetControlValueLong(vTWScroll, GetControlMinimumLong(vTWScroll));		SetControlValueLong(hTWScroll, GetControlMinimumLong(hTWScroll));{$IFC FLIPTREE}		if treeflipped then			begin				TWOrigin.v := GetControlValueLong(hTWScroll);				TWOrigin.h := GetControlValueLong(vTWScroll);			end		else			begin				TWOrigin.v := GetControlValueLong(vTWScroll);				TWOrigin.h := GetControlValueLong(hTWScroll);			end;{$ELSEC}		TWOrigin.v := GetControlValueLong(vTWScroll);		TWOrigin.h := GetControlValueLong(hTWScroll);{$ENDC}	end;{$IFC SHOWBRANCHLENGTHS}{-----------------------------------------------------------------------------}	function BranchLengthLongint (N: Nptr; pleaseDeflate: boolean): longint;		var			len: longint;	begin		if branchlistmode = minmaxmode then			len := N^.length2		else			len := N^.length1;		if pleaseDeflate & (realwt | realtypes) then			len := len div lengthinflate;		BranchLengthLongint := len;	end;{-----------------------------------------------------------------------------}	procedure CalcBranchLengthSpacing(originalSpacing: integer);	begin		branchLengthSpacing := originalSpacing;		if (summaryview = asticks) then   {now let's adjust it so doesn't go under minima}			begin{$IFC COLORTICKS}				if TicksRequireBoxes then					begin						if ticksNoNames & (branchLengthSpacing < 2) then							branchLengthSpacing := 2						else if not ticksNoNames & (branchLengthSpacing < 10) then							branchLengthSpacing := 10;						if branchLengthSpacing < colorTicksBarWidth+colorTicksMinSpaceBetween then							branchLengthSpacing := colorTicksBarWidth + colorTicksMinSpaceBetween;					end				else{$ENDC}					if ticksNoNames & (branchLengthSpacing < 4) then						branchLengthSpacing := 4					else if not ticksNoNames & (branchLengthSpacing < 10) then						branchLengthSpacing := 10;			end;	end;{$ENDC}{-----------------------------------------------------------------------------}{The following procedure returns the number of changes from the root to the highest tip.  It is I believe much}{like your old CalcVPhyloLocs.  Note that the number of changes on each branch is stored in N^.length1.}{This is a long integer and may be high, especially when inflated by real weights and real types}{Thus, pixelperchg can no longer be an integer; it has to be a real, otherwise it would be 0 if branch lengths were}{large.  I cannot find out the name of the box in which the tree must be drawn; laserboxes^[treeb].r seems close but}{not really.  I do not understand this shrink stuff. What I have done is simply to pretend like the tree is never a phylogram}{for the sake of boxes etc, but when it comes time to draw the tree the vertical locations are adjusted using a pixelperchg}{calculated directly from topmargin, ScreenR^.loc.v, and the maximum change height of tree}{Does note NOT include root length}	function TreeChangeHeight (extraBranchLength, perChangeFactor: integer): longint;   {v3.02: moved up from LaserDraw}{extraBranchLength is an extra amount added to each branch}{perChangeFactor is the factor to multiple each change unit by}		var			maxdisttorootLOCAL: longint;{................}		procedure FindTreeChangeHeight (N: Nptr);			var				tN: Nptr;				disttoroot: longint;		begin			if NodeIsTerminal(N) then				begin					disttoroot := 0;					tN := N;					repeat{$IFC MINMAXIN}						if (branchlistmode <> minmaxmode) then							disttoroot := disttoroot + BranchLengthLongint(tN, not printon & branchLengthsWeighted) * perChangeFactor{v4: if NodeIsTerminal, then have to add on length to where taxon name is written}						else if (NodeIsTerminal(tN) and not (laser^.mmShow = mmDontShow)) or (laser^.mmEnd = mmMax) or not printon then							disttoroot := disttoroot + BranchLengthLongint(tN, not printon & branchLengthsWeighted) * perChangeFactor						else if laser^.mmEnd = mmMin then							disttoroot := disttoroot + tN^.length1 * perChangeFactor						else if laser^.mmEnd = mmMean then							disttoroot := disttoroot + RoundValue(tN^.lengthMean) * perChangeFactor; {* lengthinflate}{$ELSEC}						disttoroot := disttoroot + tN^.length1 * perChangeFactor;  {changes are packed into long1}{$ENDC}						if not tN^.null then							disttoroot := disttoroot + extrabranchLength;						tN := tN^.anc;					until tN = screenR;					if disttoroot > maxdisttorootLOCAL then						maxdisttorootLOCAL := disttoroot;				end			else				begin					FindTreeChangeHeight(N^.lf);					FindTreeChangeHeight(N^.rt);				end;		end;	begin		maxdisttorootLOCAL := 0;		FindTreeChangeHeight(screenR);		TreeChangeHeight := maxdisttorootLocal;	end;{$IFC SHOWBRANCHLENGTHS}{-----------------------------------------------------------------------------}	function MaxChangeDiscrepancy: single;		var			maxDiscrepancy: single;			discrepancy: single;			bL: longint;{................}		procedure FindMaxChangeDiscrepancy (N: Nptr);		begin			bL := BranchLengthLongint(N, branchLengthsWeighted);			if bL > 0 then				begin					discrepancy := N^.chg / bL;					if discrepancy > maxDiscrepancy then						maxDiscrepancy := discrepancy;				end;			if not NodeIsTerminal(N) then				begin					FindMaxChangeDiscrepancy(N^.lf);					FindMaxChangeDiscrepancy(N^.rt);				end;		end;	begin		maxDiscrepancy := 0;		FindMaxChangeDiscrepancy(screenR);		MaxChangeDiscrepancy := maxDiscrepancy;	end;{-----------------------------------------------------------------------------}	procedure CalcShowBranchLengthTreeHeight (bufferedTH: integer);		var			maxDisc: single;	begin		Treeheight := bufferedTH + treechangeHeight(screenExtraBranchLength, branchLengthSpacing) + (BranchLengthLongint(ScreenR, branchLengthsWeighted)) * branchLengthSpacing + screenExtraBranchLength + 20	end;{$ENDC}{-----------------------------------------------------------------------------}	procedure CalcEdw (ntaxa: integer);		const			minTreeMargins = 15;		var			bufferedTH: integer;			rawtxsp: integer;			treeWidth: integer;			LeftMargin, rightmargin, theTop: integer;			maxDisc: single;			minNodes,maxNodes: longint;	begin		CalcTaxonHeight;  { v3.02: }		bufferedTH := IntegerMax(80, taxonheight + 22);{==== txsp calculation =====}{$IFC FLIPTREE}		if treeflipped then			begin				leftmargin := visTWR.top;				rightmargin := visTWR.bottom;			end		else{$ENDC}			begin				leftmargin := visTWR.left;				rightmargin := visTWR.right;			end;		txsp := (rightmargin - leftmargin - 28) div ntaxa;		if odd(txsp) then			txsp := txsp - 1;		if txsp < mintxsp then			begin				txsp := mintxsp;				if odd(txsp) then					txsp := txsp + 1;			end;		if treeScale <> 1.0 then			begin				rawtxsp := txsp;				txsp := RoundValue(txsp * treeScale);				if odd(txsp) then					txsp := txsp + 1;				if txsp < mintxsp then  {this means that user has asked to shrink too much}					begin						txsp := mintxsp;						if odd(txsp) then							txsp := txsp + 1;						NewError(114, 0);					end;				treeScale := txsp / rawtxsp;			end;		vertTxsp := txsp;{==== edw calculation =====}{$IFC SQUAREBRANCHES}		edw := txsp - 3;		if edw < 2 then			edw := 2		else if squarebranches & (edw > 7) then			edw := 7;		if edw > maxedw then			edw := maxedw;{$ELSEC}		edw := txsp - 3;		if edw > 9 then			edw := 9		else if edw < 2 then			edw := 2;{$ENDC}{$IFC COLORTICKS}		if (traceShown = traceAllChanges) & (summaryView=asTicks) then			begin				boxedw := edw;				edw := 2;			end		else{$ENDC}			boxedw := edw;{$IFC TINKERTOY}		TinkerWidth := edw + 2;		if TinkerTree and (edw > 4) then			edw := 4;{$ENDC}{    if edw > maxedw then edw := maxedw;}		natedw := edw;		gedw := edw;{==== firsttx calculation =====}		treeWidth := (txsp * (ntaxa - 1) + edw);		if rightmargin - leftmargin < treewidth + minTreeMargins * 2 then   {tree wider than screen}			firsttx := leftmargin + minTreeMargins		else			firsttx := leftmargin + (rightmargin - leftmargin - treewidth) div 2;{==== drawTWR.right calculation =====}		drawTWR.right := drawTWR.left + firsttx * 2 + treewidth + RoomNeededOnRight;{==== nattop & drawTWR.bottom calculation =====}{$IFC SQUAREBRANCHES}{$IFC SHOWBRANCHLENGTHS}		if squarebranches & showbranchlengths & (traceshown = traceAllChanges) & nodes then			begin				CalcBranchLengthSpacing(branchLengthSpacingUser);				CalcShowBranchLengthTreeHeight(bufferedTH);				if nex7on then					theTop := dataBoxB.bottom - nattop				else					theTop := visTWR.top;				if not nex7on & (treeheight < visTWR.bottom - theTop) then {not nex7on &}					begin						repeat							branchLengthSpacing := branchLengthSpacing + 1;							CalcShowBranchLengthTreeHeight(bufferedTH);						until (treeheight > visTWR.bottom - theTop) or (branchLengthSpacing > 100);						branchLengthSpacing := branchLengthSpacing - 1;					end;				if treescale <> 1.0 then					branchLengthSpacing := RoundValue(branchLengthSpacing * treescale);				CalcShowBranchLengthTreeHeight(bufferedTH);{$IFC FALSE}				if branchlengthsweighted & (summaryview = asticks) then					begin						maxDisc := MaxChangeDiscrepancy;						if maxDisc > 1.01 then							branchLengthSpacing := RoundValue(10 * maxDisc);{    branchLengthSpacing := branchLengthSpacing * maxDisc;}					end;{$ENDC}			end		else {$ENDC}			if condensedBranches & squareBranches & not showbranchlengths & nodes then				begin					NodesFromTop(screenR, minnodes, maxnodes,false);					if treeScaleVert<> 1.0 then 						vertTxsp := RoundValue(((visTWR.bottom-visTWR.top)-bufferedTH-defRootSize-20)/treeScaleVert / maxNodes)					else						vertTxsp := ((visTWR.bottom-visTWR.top)-bufferedTH-defRootSize-20) div maxNodes;					if vertTxsp<edw then						vertTxsp := edw;					Treeheight := bufferedTH + RoundValue((verttxsp * maxnodes+ defRootSize + 20) * treeScaleVert)				end			else if squarebranches & (treeScaleVert <> 1.0) then				Treeheight := bufferedTH + RoundValue(((txsp * (ntscreen - 1) + edw) div 2 + defRootSize + 20) * treeScaleVert)			else{$ENDC}				Treeheight := bufferedTH + (txsp * (ntscreen - 1) + edw) div 2 + defRootSize + 20;{v3.02: in next line, added not nex7on &}		if not nex7on & (treeheight < visTWR.bottom - visTWR.top) then  {tree shorter than screen}			nattop := visTWR.top + (visTWR.bottom - visTWR.top - treeheight) div 2 + bufferedTH		else			begin				nattop := bufferedTH;				drawTWR.bottom := drawTWR.top + treeheight;			end;{$IFC SHOWBRANCHLENGTHS}		if not ((traceshown = traceAllChanges) & showbranchlengths & squarebranches) then{$ENDC}			SetTWScrollMax;		CalcNodeTriangle;	end;{-----------------------------------------------------------------------------}	procedure NodesFromTop (N: Nptr; var minnodes, maxnodes: longint; countNulls: boolean);{FROZEN 3.0}{this procedure returns, for a given node N, the number of nodes from the top of the tree}{the number of nodes on the shortest pathway is returned in minmodes, }{the number in the longest pathway is returned in maxnodes}		var			numnodes: integer; {.......}		procedure FindTaxa (NP: Nptr);			var				aN: Nptr;		begin			if NodeIsInternal(NP) then				begin					FindTaxa(NP^.lf);					FindTaxa(NP^.rt);				end			else				begin  {terminal node; see if descendant of N}					aN := NP;					numnodes := 0;					repeat						if aN <> N then							begin								aN := aN^.anc;								if countNulls | not aN^.null then									numnodes := numnodes + 1;							end;					until (aN = R) or (aN = N);					if (aN = N) then {terminal node was a descendant of N; record how far}						begin							if numnodes < minnodes then								minnodes := numnodes;							if numnodes > maxnodes then								maxnodes := numnodes;						end;				end;		end; {.......}	begin		minnodes := 32000;		maxnodes := 0;		FindTaxa(N);	end;{-----------------------------------------------------------------------------}	function SizeofClade (N: Nptr; useLocsIfPossible: boolean): integer;{FROZEN 3.0}		var			termtaxa: integer;{returns number of taxa in clade.  }{if useLocsIfPossible is true, then it uses the horizontal and vertical}{positioning of nodes to calculate number, if this allowable given the shape of the tree.}{Thus, only pass userLocsIfPossible=true if nodelocs have ALREADY BEEN SET FOR THE TREE.}{........}		procedure CountTaxa (NP: Nptr);		begin			if NodeIsInternal(NP) then				begin					CountTaxa(NP^.lf);					CountTaxa(NP^.rt);				end			else				termtaxa := termtaxa + 1;		end;{........}	begin		if useLocsIfPossible & (not squarebranches | (not condensedBranches & (treescalevert = 1.0) & not ((traceshown = traceAllChanges) & showbranchlengths))) then			termtaxa := ((N^.loc.v - topmargin) * 2) div txsp + 1   {we can use triangle relationships}		else			begin				termtaxa := 0;				CountTaxa(N);			end;		SizeOfClade := termtaxa;	end;{-----------------------------------------------------------------------------}	function PartofSamePolytomy (N1, N2: Nptr): boolean;{FROZEN 3.0}	begin		if (N1 = R) or (N2 = R) then			PartofSamePolytomy := false		else			PartofSamePolytomy := (NotNullAnc(N1) = NotNullAnc(N2));	end;{-----------------------------------------------------------------------------}	function PartOfPolytomy (N: Nptr): boolean;{FROZEN 3.0}	begin		PartOfPolytomy := (N <> subR) & (N <> R) & (N^.anc^.null | N^.anc^.lf^.null | N^.anc^.rt^.null);	end;{-----------------------------------------------------------------------------}	function NodeisPolytomous (N: Nptr): boolean;{FROZEN 3.0}	begin		NodeisPolytomous := (NodeIsInternal(N)) & (N^.lf^.null | N^.rt^.null);	end;{-----------------------------------------------------------------------------}	procedure ShrinkTree;	begin		goTWHome := true;		ZeroTreeOrigin;		if expd then			InvalidateWindow(twmesswindow, false);		ntscreen := numtaxain;		expd := false;		ScreenR := R;		DrawR := ScreenR;		myDisableItem(ShowMHdl, ShrinkItem);	end;{==================================================================}{------------PACKED TREE UTILITIES--------------------------------------------------}{-----------------------------------------------------------------------------}	function PackedTreeHasFixanc (H: handle): boolean;	begin		PackedTreeHasFixanc := Bittst(ptr(GetMaster(H)), fixancbit);	end;{-----------------------------------------------------------------------------}	function PackedTreeHasPolytomies (H: handle): boolean;	begin		PackedTreeHasPolytomies := Bittst(ptr(GetMaster(H)), polytomybit);	end;{---------------------------------------}	procedure SetPackedNode (startP: ptr; place, setto: integer);		var			pi: ip;	begin		pi := ip(ord4(startP) + ord4(place - 1) * 2);		pi^ := setto;	end;{---------------------------------------}	function GetPackedNode (startP: ptr; place: integer): integer;	begin		GetPackedNode := ip(ord4(startP) + ord4(place - 1) * 2)^;	end;{---------------------------------------}	procedure movepackedtoright (startP: ptr; istart, iend: integer); {v4: possibly do in assembly}		var			puthere: integer;			pi, pileft: ip;	begin		pi := ip(ord4(startP) + ord4(iend) * 2);		pileft := ip(ord4(pi) - 2);		for puthere := iend downto istart do			begin				pi^ := piLeft^;				pi := piLeft;				pileft := ip(ord4(pi) - 2);			end;	end;{---------------------------------------}	procedure movepackedtoleft (startP: ptr; istart, iend: integer);		var			puthere: integer;			pi, piright: ip;	begin		pi := ip(ord4(startP) + ord4(istart - 2) * 2);  {starting one to left of istart}		piright := ip(ord4(pi) + 2);		for puthere := istart to iend do			begin				pi^ := piright^;				pi := piright;				piright := ip(ord4(pi) + 2);			end;	end;{---------------------------------------}	function PackedAncestorOf (startP: ptr; ie: integer): integer;		var			locanc, numty, numin, nnlocanc: integer;	begin		numty := 0;  {finding ancestor}		numin := 0;		locanc := ie;		repeat			locanc := locanc - 1;			nnlocanc := GetPackedNode(startP, locanc);			if (nnlocanc = 0) or (nnlocanc = nullpacked) then				numin := numin + 1			else if (nnlocanc > 0) then				numty := numty + 1;		until (numin >= numty) or (locanc = 1);		packedancestorof := locanc;	end;{--------------------------------------------------------}	procedure DeletePackedTaxon (startP: ptr; idel, iend: integer);		var			locanc: integer;			ancwasnull: boolean;	begin		if (GetPackedNode(startP, idel) < 0) then			MovePackedtoLeft(startP, idel + 1, iend)		else if idel <= 1 then			begin				if idel = 1 then					MovePackedtoLeft(startP, 2, iend);			end		else			begin				locanc := PackedAncestorOf(startP, idel);				if (GetPackedNode(startP, locanc) < 0) and (GetPackedNode(startP, locanc) <> nullpacked) then					begin {anc is fixanc thus just zap idel and change anc to positive}						MovePackedtoLeft(startP, idel + 1, iend);						SetPackedNode(startP, locanc, -GetPackedNode(startP, locanc));					end				else  {locanc is zero or null ancestor; thus zap it then zap idel}					begin{fixed 3.05}						ancwasnull := GetPackedNode(startP, locanc) = nullpacked;						MovePackedToLeft(startP, locanc + 1, iend);						MovePackedToLeft(startP, idel, iend - 1);						if not ancwasnull and (GetPackedNode(startP, locanc) = nullpacked) then							SetPackedNode(startP, locanc, 0);      {if ancestor was not null then new anc can't be null}      {Compare to DeleteTaxon in TreeMakerUtil, when N is deleted, }      {sis(N) is set to null iff sis(N) was null and Nanc was null}					end;			end;	end;{-----------------------------------------------------------------------------}	function StartOfPackedTree (theChain, theLink: longint; treeH: Handle): ptr;{note that the handle must be locked!}		var			BaseBuf: longint;			linkH: Handle;	begin		if treeH = nil then			linkH := HdlPtr(GetMaster(strCHUNKs[thechain]) + HdlSize * ord4(thelink - 1))^		else			linkH := treeH;		baseBuf := GetMaster(LinkH);  {start of packedtree}		StartOFPackedTree := ptr(baseBuf + ip(baseBuf)^);	end;{----------------------------------------------------------------------------}	procedure SetNumTaxaInPackedTree (tH: handle; howmany: integer);		var			ippt: ip;	begin		ippt := ip(GetMaster(th) + numberInLinkByte);		ippt^ := howmany;	end;{----------------------------------------------------------------------------}	function GetNumTaxaInPackedTree (tH: handle): integer;	begin		GetNumTaxaInPackedTree := ip(GetMaster(th) + numberInLinkByte)^;  {don't need to lock}	end;{----------------------------------------------------------------------------}	function GetNumTaxaInLinkTree (theLink: longint; linkH: Handle): integer;	var H: Handle;	begin		if linkH <> nil then			H := linkH		else			H := HdlPtr(GetMaster(strCHUNKs[treeChain]) + HdlSize * ord4(thelink))^;		GetNumTaxaInLinkTree := ip(GetMaster(H) + numberInLinkByte)^;  {don't need to lock}	end;{-----------------------------------------------------------------------------}	procedure NPtrOfTaxon(it: integer; var theNode: Nptr);		procedure NodeForTaxon (N: Nptr);		begin			if N^.name = it then				theNode := N			else if NodeIsInternal(N) then				begin					NodeForTaxon(N^.lf);					NodeForTaxon(N^.rt);				end;		end;	begin		theNode:= nil;		NodeForTaxon(R);	end;{-----------------------------------------------------------------------------}	procedure ExciseTaxonFromCurrentTree (var N : Nptr);  {excises term taxon N}		var			TaxonHdl: thdl;			v, w, x: Nptr;			Vslantedright: boolean;	begin		dirtyTreeTaxNames := true;		numtaxain := numtaxain - 1;		if (N^.name <= numtaxa) & (N^.name>0) then			begin				TaxonHdl := gettaxonHdl(N^.name);				taxonhdl^^.deleted := true;			end;		v := N^.anc;		W := sis(N);		X := V^.anc;		Vslantedright := NodeSlantsRight(V);		W^.slant := V^.slant;		if W^.name > 0 then			W^.fixanc := false;		W^.null := (v^.null and W^.null);		W^.anc := X;		if Vslantedright then			X^.rt := W		else			X^.lf := W;		if screenR = V then			screenR := W;		if drawR = V then			drawR := W;		if R = V then			R := W;		ZapHandle(V^.dnstH);		ZapHandle(V^.upstH);		ZapHandle(V^.stsH);		V^.name := -1;		ZapHandle(N^.dnstH);		ZapHandle(N^.upstH);		ZapHandle(N^.stsH);		N^.name := -1;	end;		{-----------------------------------------------------------------------------}	function CubeSize: longint;	var dL: longint;	begin		if chartchangesmode = meanmode then			dL := longint(maxMPRState+1) * (maxMPRState+1) * (maxMPRState+1)*SizeOf(double)		else			dL := longint(maxMPRState+1) * (maxMPRState+1) * (maxMPRState+1)*SizeOf(longint);		CubeSize := dL;	end;{-----------------------------------------------------------------------------}	function MPRSquareSize: longint;	var dL: longint;	begin		if chartchangesmode = meanmode then			dL := SizeOf(CMDDoubleArray)		else			dL := SizeOf(CMDArray);		MPRSquareSize := dL;	end;{-----------------------------------------------------------------------------}	function AllocateCubePointer(N: Nptr):boolean;	begin		N^.MPRCube := NewPtrClear(CubeSize);		AllocateCubePointer := N^.MPRCube <> nil;	end;{-----------------------------------------------------------------------------}	function AllocateAllCubePointers(baseN: Nptr): boolean;	var success : boolean;	{...............}		procedure AllocateAllCubePointersRec(N: Nptr);		begin			if success then				if not AllocateCubePointer(N) then 					success := false				else					if NodeIsInternal(N) then						begin							AllocateAllCubePointersRec(N^.lf);							AllocateAllCubePointersRec(N^.rt);						end;		end;	{...............}	begin		success := true;		AllocateAllCubePointersRec(baseN);		AllocateAllCubePointers := success;	end;{-----------------------------------------------------------------------------}	procedure DestroyCubePointer(N: Nptr);	begin		ZapPointer(N^.MPRCube);	end;{-----------------------------------------------------------------------------}	procedure DestroyAllCubePointers(baseN: Nptr);	begin		DestroyCubePointer(baseN);		if NodeIsInternal(baseN) then			begin				DestroyAllCubePointers(baseN^.lf);				DestroyAllCubePointers(baseN^.rt);			end;	end;	type doublePtr = ^double;	var iStateIncrementInCube,iFromIncrementInCube: longint;		{-----------------------------------------------------------------------------}	function CubeValueDouble(theCube: Ptr; iState,iFrom,iTo: integer): double;	var dd: double;		offSet : longint;		elementSize: longint;	begin		offSet :=  longint(iState)* (maxMPRState+1)*(maxMPRState+1)*SizeOf(double)+ longint(iFrom)*(maxMPRState+1)*SizeOf(double)+ longint(iTo)*SizeOf(double);		dd := doublePtr(longint(theCube) + offSet)^;		CubeValueDouble := dd;	end;{-----------------------------------------------------------------------------}	procedure SetCubeValueDouble(theCube: Ptr; iState,iFrom,iTo: integer; value: double);	var dP: DoublePtr;		offSet: longint;	begin		offSet :=  longint(iState)* (maxMPRState+1)*(maxMPRState+1)*SizeOf(double)+ longint(iFrom)*(maxMPRState+1)*SizeOf(double)+ longint(iTo)*SizeOf(double);		dP := doublePtr(longint(theCube) +offSet);		dP^ := value;	end;{-----------------------------------------------------------------------------}	function CubeValueLongint(theCube: Ptr; iState,iFrom,iTo: integer): longint;	var 	value: longint;		offSet : longint;		elementSize: longint;	begin		offSet :=  longint(iState)* (maxMPRState+1)*(maxMPRState+1)*SizeOf(longint)+ longint(iFrom)*(maxMPRState+1)*SizeOf(longint)+ longint(iTo)*SizeOf(longint);		value := LIP(longint(theCube) + offSet)^;		CubeValueLongint := value;	end;{-----------------------------------------------------------------------------}	procedure SetCubeValueLongint(theCube: Ptr; iState,iFrom,iTo: integer; value: longint);	var dP: LIP;		offSet: longint;	begin		offSet :=  longint(iState)* (maxMPRState+1)*(maxMPRState+1)*SizeOf(longint)+ longint(iFrom)*(maxMPRState+1)*SizeOf(longint)+ longint(iTo)*SizeOf(longint);		dP := LIP(longint(theCube) +offSet);		dP^ := value;	end;{-----------------------------------------------------------------------------}	procedure CalcMaxMPRStateChar(ic: integer);	begin		maxMPRState := CharMaxstDEF(ic);	end;{-----------------------------------------------------------------------------}	procedure CalcMaxMPRStateAll;	var ic: integer;		max: integer;	begin		max := 0;		for ic := 1 to numchars do			if charincluded(ic) then				if max < CharMaxstDEF(ic) then					max := CharMaxstDEF(ic);		maxMPRState := max;	end;{-----------------------------------------------------------------------------}end.