unit Prohibitions;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, 		ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, CharUtil, TreeUtil, TypeUtil;	function CollapseProhibited (N: Nptr; allcollapse: boolean): boolean;	function ContinuousisManhattan: boolean;	function EquivocalLegal (N: Nptr): boolean;	function EquivocalCyclingNeeded: boolean;	function ContinuousLegal (poster: boolean): boolean;	function PolytomiesLegal (poster: boolean): boolean;	function FixancLegal (N: Nptr; poster: boolean): boolean;	function MinMaxLenLegal (poster: boolean; minormax: integer): boolean;	function MinMaxLenLegalChar (ic: integer; minormax: integer): boolean;	function CalcMenuItemLegal (ItemNo: integer): boolean;{еееееееееееееееееееееее}implementation {е$S Prohibitions}{-----------------------------------------------------------------------------}	function EquivocalLegal (N: Nptr): boolean;{FROZEN 3.0}	begin		EquivocalLegal := nodes & (not (((N = R) & (ancon | nullson)) | ((N <> R) & (Anynulls(N) | AnyFixanc(N)))));	end;{-----------------------------------------------------------------------------}	function ContinuousisManhattan: boolean;{FROZEN 3.0}	begin		ContinuousisManhattan := (continuousmode = manhattan) or (continuousmode = manhatmin) or (continuousmode = manhatmax);	end;{-----------------------------------------------------------------------------}	function ContinuousLegal (poster: boolean): boolean;{FROZEN 3.0}		var			prohib: boolean;	begin		prohib := false;		if nodes and (numtaxain > 1) then			begin				if numcontinuous = 0 then					begin						prohib := true;						if poster then							NewError(67, 0);					end				else if nullson and not polyreal then					begin						prohib := true;						if poster then							NewError(68, 0);					end				else if (nullson and ContinuousisManhattan) then					begin						prohib := true;						if poster then							NewError(69, 0);					end				else if (continuousmode = squnrooted) and NodeIsPolytomous(R) then					begin						prohib := true;						if poster then							NewError(70, 0);					end				else if (continuousmode in [sqFelsX, sqFelsContrast, sqFelsContrastSTD]) and nullson then  {ввв}					begin						prohib := true;						if poster then							NewError(405, 0);					end				else if ancon then					begin						prohib := true;						if poster then							NewError(71, 0);					end;			end		else			prohib := true;		ContinuousLegal := not prohib;	end;{-----------------------------------------------------------------------------}	function EquivocalCyclingNeeded: boolean;{FROZEN 3.0}	begin		EquivocalCyclingNeeded := treeopen & (((traceshown = traceAllChanges) & ((branchlistmode = minmaxmode) | ((branchlistmode = maxmode) & anytype([irreversible, fisher, dollo, usedef])))) | (charton & (CWChart = CWCChanges) & (CWTRees[CWChart] = CWCurrentTree) & (chartchangesmode <> unambigmode))) | (charton & (CWChart = CWCSteps) & (CWTRees[CWChart] = CWCurrentTree) & (CWStepsSteps = CWStepsChanges) | calctreechanges);	end;{-----------------------------------------------------------------------------}	function PolytomiesLegal (poster: boolean): boolean;{FROZEN 3.0}		var			prohib: boolean;	begin		prohib := false;		if Anytype([irreversible, fisher, dollo, usedef]) then			begin				prohib := true;				if poster then					NewError(57, 0);			end		else if (traceshown = traceProbability) then			begin				prohib := true;				if poster then					NewError(411, 0);			end		else if (traceshown = traceContinuous) & (ContinuousisManhattan) then			begin  {note:  this does not cause problems in chart treecycling}				{ if (traceshown = traceContinuous) is irrelevant because PolytomiesLegal not used there}				prohib := true;				if poster then					NewError(58, 0);			end		else if (traceshown = traceContinuous) & not polyreal then			begin				prohib := true;				if poster then					NewError(65, 0);			end		else if (traceshown = traceContinuous) & (continuousmode in [sqFelsX, sqFelsContrast, sqFelsContrastSTD]) then  {ввв}			begin				prohib := true;				if poster then					NewError(406, 0);			end		else if EquivocalCyclingNeeded then			begin				prohib := true;				if poster then					NewError(78, 0);			end		else if ((traceshown = traceAllChanges) & ((branchlistmode = maxmode) | (branchlistmode = minmaxmode))) then			begin				prohib := true;				if poster then					NewError(32, 0);			end		else if ((traceshown = traceDiscrete) & (resolveoption <> allpossible)) then			begin				prohib := true;				if poster then					NewError(46, 0);			end		else if nodes & ancon then			begin				prohib := true;				if poster then					NewError(56, 0);			end;		PolytomiesLegal := not prohib;	end;{-----------------------------------------------------------------------------}	function FixancLegal (N: Nptr; poster: boolean): boolean;{FROZEN 3.0}		var			prohib: boolean;	begin		prohib := false;		if AnyType([dollo, usedef]) then			begin				prohib := true;				if poster then					NewError(61, 0);			end		else if (traceshown = traceProbability) then			begin				prohib := true;				if poster then					NewError(411, 0);			end		else if (traceshown = traceContinuous) then			begin				prohib := true;				if poster then					NewError(62, 0);			end		else if EquivocalCyclingNeeded then			begin				prohib := true;				if poster then					NewError(78, 0);			end		else if ((traceshown = traceAllChanges) & ((branchlistmode = maxmode) | (branchlistmode = minmaxmode))) then			begin				prohib := true;				if poster then					NewError(32, 0);			end		else if ((traceshown = traceDiscrete) & (resolveoption <> allpossible)) then			begin				prohib := true;				if poster then					NewError(46, 0);			end		else if (N <> subR) & nodes then {passing subR is way to avoid tree checking}			begin				if (NodeIsInternal(N)) then					begin						prohib := true;						if poster then							NewError(59, 0);					end				else if N^.anc^.fixanc then					begin						prohib := true;						if poster then							NewError(136, 0);					end				else if nullson then					begin						prohib := true;						if poster then							NewError(60, 0);					end;			end;		FixancLegal := not prohib;	end;{-----------------------------------------------------------------------------}	function CollapseProhibited; {: boolean;}		var			prohib: boolean;	begin		prohib := false;		if ancon then			begin				prohib := true;				InstantError(236);			end		else if Anytype([irreversible, fisher, dollo, usedef]) then			begin				prohib := true;				InstantError(237)			end		else if (traceshown = traceProbability) then			begin				prohib := true;				InstantError(411);			end		else if ((traceshown = traceAllChanges) & ((branchlistmode = maxmode) | (branchlistmode = minmaxmode))) then			begin				prohib := true;				InstantError(238)			end		else if ((traceshown = traceDiscrete) & (resolveoption <> allpossible)) then			begin				prohib := true;				InstantError(239)			end		else if (traceshown = traceContinuous) & (ContinuousisManhattan) then			begin				prohib := true;				InstantError(240)			end		else if (traceshown = traceContinuous) & (continuousmode in [sqFelsX, sqFelsContrast, sqFelsContrastSTD]) then {ввв}			begin				prohib := true;				InstantError(406)			end		else if (traceshown = traceContinuous) & not polyreal then			begin				prohib := true;				InstantError(241)			end		else if (traceshown = traceContinuous) & ((continuousmode = squnrooted) & ((allcollapse & (N = R)) | (not allcollapse & (N^.anc = R)))) then			begin				prohib := true;				InstantError(242)			end		else if EquivocalCyclingNeeded then			begin				prohib := true;				InstantError(243)			end;		CollapseProhibited := prohib;	end;{-------------------------------------------------------------------------}	function MinMaxLenLegal (poster: boolean; minormax: integer): boolean;		label			1;		var			AllCharsIllegal: boolean;			ic: integer;			ctypP: IP;			cstatesP: ptr;			oldstate1, oldstate2: SignedByte;	begin{v4: allow min max with irrev and dollo if no multistate taxa in any char}		AllCharsIllegal := true;		LockHandle(chtypH, oldstate1);		LockHandle(chstatesH, oldstate2);		ctypP := IP(GetMaster(chtypH));		cstatesP := ptr(GetMaster(chstatesH));		for ic := 1 to numchars do			begin				if (ctypP^ < irreversible) | ((ctypP^ < fisher) & (minormax = minlength)) then					begin						AllCharsIllegal := false;						goto 1;					end;				ctypP := IP(ord4(ctypP) + chtb);				cstatesP := ptr(ord4(cstatesP) + chsb);			end;1:		ResetHandle(chtypH, oldstate1);		ResetHandle(chstatesH, oldstate2);		if AllCharsIllegal then			begin				if poster then					begin						if minormax = minlength then							begin								PleaseOffCI := true;								PleaseOffMinAll := true;								NewError(81, 0);							end						else							NewError(82, 0);						PleaseOffRIRC := true;						PleaseOffMaxAll := true;					end;				minmaxlenlegal := false;			end		else			begin				if poster & (((minormax = minlength) & Anytype([fisher, dollo, usedef])) | ((minormax = maxlength) & Anytype([irreversible, fisher, dollo, usedef]))) then					begin						if minormax = minlength then							NewError(83, 0)						else							NewError(84, 0)					end;				minmaxlenlegal := true;			end;	end;{-------------------------------------------------------------------------}	function MinMaxLenLegalChar (ic: integer; minormax: integer): boolean;	begin{v4: allow min max with irrev and dollo if no multistate taxa in char ic}		if minormax = minlength then			minmaxLenLegalChar := typeofchar(ic) < fisher  {note excluded must be disallowed also}		else			minmaxLenLegalChar := typeofchar(ic) < irreversible;	end;{-----------------------------------------------------------------------------}	function CalcMenuItemLegal (ItemNo: integer): boolean;	begin		if ItemNo = lengthitem then			CalcMenuItemLegal := true		else if ItemNo = ChangesItem then			begin				if EquivocalLegal(R) then					CalcMenuItemLegal := true				else					begin						CalcMenuItemLegal := false;						NewError(78, 0);					end;			end		else if (ItemNo = CIItem) or (ItemNo = MinPosItem) then			CalcMenuItemLegal := MinMaxLenLegal(true, minlength)		else if ItemNo = MaxPosItem then			CalcMenuItemLegal := MinMaxLenLegal(true, maxlength)		else if (ItemNo = RIItem) or (ItemNo = RCItem) then			CalcMenuItemLegal := MinMaxLenLegal(true, minlength) & MinMaxLenLegal(true, maxlength);	end;end.