unit ChartWScatter;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, 		TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, 		EventUtil, GenUtil, BoxUtil, CharUtil, StrUtil, MenuUtil, TreeUtil, SymbolsNames, TypeUtil, 		TaxonCHUtil, ChartWUtil, ChartWTable, PrintingUtil;	procedure DrawChartLegend (boundary: rect);	procedure DrawScatter (boundary: rect);	type		spotboxtype = array[0..3] of rect;	var		spotbox: spotboxtype;{еееееееееееееееееееееее}implementation {е$S ChartWScatter}{-----------------------------------------------------------------------------}	procedure DrawChartLegend (boundary: rect);{draws the circles or squares at the bottom left of the chart window indicating}{the significance of the QDBlack, QDGray, and white regions on the chart}		var			box: rect;			numtoshow, numlegendboxes, j: integer;			settoshow: set15;			left, top, rightmost: integer;			colorlegend: boolean;			pt: Point;			doColorCodpos: boolean;	begin		settoshow := SpotBarSetToShow;		numtoshow := NumSpotBar(settoshow);		doColorCodPos := (chartColorMode=chartColorCodPos) & ColorCodPosLegal & someCodingIncluded;		if doColorCodPos then			numlegendboxes := 3		else if (CWChart = CWCChanges) & nucleotides & ColorPort & CWScatterMultiColor & (numtoshow < 2) then			numlegendboxes := 2		else			numlegendboxes := numtoshow;		left := boundary.left + 5;		top := boundary.bottom - (FontHeight + 4) * numlegendboxes - 5;		if myIsControlVisible(CWScroll) then  {the scroll is visible}			top := top - scrollwidth;   {make room for scroll bar}		SetRect(spotbox[numtoshow], left, top, left + FontHeight, top + fontheight);		colorlegend := (not ((CWChart = CWCChanges) & (CWScatterMultiColor & (nucleotides))) & not ((chartColorMode=chartColorCodPos) & ColorCodPosLegal)) & ColorPort;		rightmost := left - FontHeight;		if numtoshow > 1 then			for j := numtoshow downto 1 do				begin					if colorlegend then						if MinMaxIrregular then							if GetSpotBarKind(SetToShow, j) = CLmin then								RGBForeColor(blueRGB)							else								RGBForeColor(redRGB)						else							RGBForeColor(histocolor);					if CWChart = CWCChanges then						begin							FillOval(spotbox[j], SpotBarPattern(numtoshow, j));							FrameOval(spotbox[j]);						end					else						begin							FillRect(spotbox[j], SpotBarPattern(numtoshow, j));							FrameRect(spotbox[j]);						end;					if ColorPort then						RGBForeColor(blackRGB);					MoveTo(spotbox[j].right + 6, spotbox[j].bottom - 3);					DrawString(SpotBarName(GetSpotBarKind(SetToShow, j), false));					GetPen(pt);					if pt.h > rightmost then						rightmost := pt.h;					SpotBox[j - 1] := spotbox[j];					OffsetRect(spotbox[j - 1], 0, fontheight + 4);				end;		rightmost := rightmost + FontHeight;		SetRect(box, rightmost, top, rightmost + FontHeight, top + fontheight);		if doColorCodPos then			for j := 1 to 3 do				begin					case j of						1: 							RGBForeColor(blueRGB);						2: 							RGBForeColor(greenRGB);						3: 							RGBForeColor(redRGB);					end;					FillBlackRect(box);					FrameRect(box);					ForeColor(blackcolor);					MoveTo(box.right + 6, box.bottom - 3);					DrawString(concat('Position ', StringFromNum(j)));					OffsetRect(box, 0, fontheight + 4);				end		else if (CWChart = CWCChanges) & nucleotides & CWScatterMultiColor & ColorPort then			begin				RGBForeColor(redRGB);				FillOval(box, QDBlack);				FrameOval(box);				ForeColor(blackcolor);				MoveTo(box.right + 6, box.bottom - 3);				DrawString('Transitions');				OffsetRect(box, 0, fontheight + 4);				RGBForeColor(blueRGB);				FillOval(box, QDBlack);				FrameOval(box);				ForeColor(blackcolor);				MoveTo(box.right + 6, box.bottom - 3);				DrawString('Transversions');				OffsetRect(box, 0, fontheight + 4);			end;	end;{-----------------------------------------------------------------------------}{$SETC ACCURATECIRCLES=FALSE}{$IFC ACCURATECIRCLES}	const		dowhite = 0;		dogray = 1;		doblack = 2;		doother = 3;{-----------------------------------------------------------------------------}	function SpotBarLevel (range, num: integer): Integer;	begin		if (range > 1) then			if num = 1 then				SpotBarLevel := doblack			else if num = 2 then				SpotBarLevel := dogray			else				SpotBarLevel := dowhite		else			SpotBarLevel := dogray;   { this overrules any settings of user!!!}	end;{-----------------------------------------------------------------------------}	procedure FillAccurateCircle (circleDiam: double; boxleft, boxtop, boxedge, isto, isfrom, numtoshow, whichspot: integer; circlebox: rect);		var			x, y, r: str255;			height, theLevel: integer;			pa: pattern;			nilrect: rect;			centercircleleft, centercircletop: double;	begin		SetRect(nilrect, 0, 0, 0, 0);		theLevel := SpotBarLevel(numtoshow, whichspot);		if theLevel <> doother then			begin				centercircleleft := 1.0 * (boxleft + boxedge * isto) + boxedge / 2.0;				centercircletop := 1.0 * (boxtop + boxedge * isfrom) + boxedge / 2.0;				RealToString(circleDiam / 2.0, r, 100000.0, 2, false);				RealToString(centercircleleft, x, 100000.0, 2, false);				RealToString(centercircletop, y, 100000.0, 2, false);				height := WindowPortRect(QDThePort).bottom;				PicComment(PostScriptBegin, 0, nil);				PicComment(TextIsPostScript, 0, nil);				ClipRect(nilrect);				DrawString('gsave');				DrawString('/ACircle {newpath');				DrawString(concat(x, ' ', y, ' ', r, ' 0 360 arc'));				DrawString('closepath} def');				if theLevel = doblack then					begin						DrawString('ACircle 0 setgray');						DrawString('fill');					end				else if theLevel = dogray then					begin						DrawString('ACircle 0.8 setgray');						DrawString('fill');					end;				DrawString('0 setgray');				DrawString('0.25 setlinewidth');				DrawString('ACircle stroke');				DrawString('1 setlinewidth');				DrawString('grestore');				ClipRect(WindowPortRect(QDThePort));			end;		pa := SpotBarPattern(numtoshow, whichspot);		FillOval(circlebox, pa);		FrameOval(circleBox);		if theLevel <> doother then			PicComment(PostScriptEnd, 0, nil);	end;{$ENDC}{-----------------------------------------------------------------------------}	procedure DrawScatterGrid (box: rect; boxedge: integer);		var			isto, isfrom: integer;	begin		GroupBegin;		for isto := 0 to maxChartMatrixCat do			begin				MoveTo(box.left + boxedge * isto + boxedge div 2, box.top);				gridLineTo(box.left + boxedge * isto + boxedge div 2, box.bottom - 1, false);			end;		for isfrom := 0 to maxChartMatrixCat do			begin				MoveTo(box.left, box.top + boxedge * isfrom + boxedge div 2);				gridLineTo(box.right - 1, box.top + boxedge * isfrom + boxedge div 2, false);			end;		GroupEnd;	end;{-----------------------------------------------------------------------------}	procedure DrawScatter (boundary: rect);{this procedure draws scattergrams}		var			leftcircle, topcircle, boxedgeH, boxedgeW, theKind, whichspot, numtoshow: integer;			biggest: longint;			box, circlebox: rect;			isfrom, isto: integer;			circlediam: integer;			circlediamReal: double;			ds: str255;			divide, biggestArea: double;			setToShow: set15;			numLegendBoxes: integer;			showLegend: boolean;{..................}		procedure DrawSpot (il: longint; divide: double; numtoshow, whichspot: integer);{this draws a spot, filling it with the pattern pa, and sizing it relative to its value, il}{divide is basically the inflation factor, so that means, etc., are scaled down accordingly}		begin			if CWScatterArea then				circlediamReal := sqrt(((1.0 * il / divide / biggest) * biggestArea)) / biggest * boxedge			else				circlediamReal := 1.0 * il / biggest * boxedge / divide;			circlediam := IntegerMax(RoundValue(circlediamReal), 1);			leftcircle := box.left + boxedge * isto + (boxedge - circlediam) div 2;			topcircle := box.top + boxedge * isfrom + (boxedge - circlediam) div 2;			SetRect(circlebox, leftcircle, topcircle, leftcircle + circlediam, topcircle + circlediam);{do not document this for version 3!!!}{$IFC ACCURATECIRCLES}			if OptionEvent(Event) & CommandEvent(Event) then   {v4: make public}				FillAccurateCircle(circleDiamReal, box.left, box.top, boxedge, isto, isfrom, numtoshow, whichspot, circlebox)			else {$ENDC}				begin					FillOval(circlebox, SpotBarPattern(numtoshow, whichspot));					FrameOval(circleBox);				end;		end;{..................}	begin		writeScatterStates := CWTraced and ShiftEvent(Event);		{v4: better control of this}		SetMenuItemText(FileMHdl, PrintingItem, 'Print Chart...');		settoshow := SpotBarSetToShow;		numtoshow := NumSpotBar(setToShow);		if (CWChart = CWCChanges) & nucleotides & ColorPort & CWScatterMultiColor & (numtoshow < 2) then			begin				showlegend := true;				numlegendBoxes := 2;			end		else			begin				showlegend := numtoshow > 1;				numlegendBoxes := numtoshow;			end;{===== calculating largest value, which will be largest spot =======}		biggest := BiggestSpotToShow;		if biggest > 0 then				{we have at least one spot to draw!}			begin				if CWScatterArea then					biggestArea := biggest * biggest;     {don't need to worry about pi as will get factored out anyway}		{calculating unscaled area of largest spot}{======= calculating size of scattergram (box)  ========}{======= and size of each square within scattergram (boxedge) =======}				box := boundary;				InsetRect(box, 40, 10);				box.top := box.top + fontheight * 2 + ChartImageTitleHeight;				if numLegendBoxes > 1 then					box.bottom := box.bottom - fontheight div 2 - (numLegendBoxes + 1) * fontheight				else					box.bottom := box.bottom - fontheight div 2;				boxedgeH := (box.bottom - box.top) div (maxChartMatrixCat + 1);				boxedgeW := (box.right - box.left) div (maxChartMatrixCat + 1);				if boxedgeW < boxedgeH then					boxedge := boxedgeW				else					boxedge := boxedgeH;				InsetRect(box, (box.right - box.left - boxedge * (maxChartMatrixCat + 1)) div 2, (box.bottom - box.top - boxedge * (maxChartMatrixCat + 1)) div 2);				chartbox := box;				with box do					begin{    if showChartTitle thenDrawChartImageTitle;}{====== draw grid ======}						if ChartGrid then							DrawScatterGrid(box, boxedge);						PenNormal;						FrameRect(box);{====== horizontal axis ======}						GroupBegin;						MoveTo(left + boxedge * maxChartMatrixCat div 2, top - 4 - fontheight);						Drawstring('To');						for isto := 0 to maxChartMatrixCat do							begin								if WriteScatterStates then									ds := AvailCharStateName(i, isto)								else									ds := CharOfNum(isto);								MoveTo(left + boxedge * isto + boxedge div 2 - 4, top - 4);								if (datatype = protein) & ColorPort then									if isto in polarAA then										ForeColor(bluecolor)									else if isto in nonpolarAA then										ForeColor(greencolor)									else if isto in negativeAA then										ForeColor(blackcolor)									else if isto in positiveAA then										ForeColor(redcolor)									else										ForeColor(cyancolor);								if WriteScatterStates then									VerticalString(ds, true)								else									DrawString(ds);								ForeColor(blackColor);								if CapsLockEvent(Event) then									if nucleotides then										if isto in [0, 2] then											DropCursorID(10580, left + boxedge * isto + boxedge div 2 - 4 + 15, top - 16, srcor)										else											DropCursorID(16411, left + boxedge * isto + boxedge div 2 - 4 + 15, top - 16, srcor);							end;						GroupEnd;{====== vertical  axis ======}						GroupBegin;						MoveTo(left - 9 - StringWidth('From00'), top + boxedge * maxChartMatrixCat div 2);						Drawstring('From');						for isfrom := 0 to maxChartMatrixCat do							begin								if WriteScatterStates then									ds := AvailCharStateName(i, isfrom)								else									ds := CharOfNum(isfrom);								MoveTo(left - 5 - Stringwidth(ds), top + boxedge * isfrom + boxedge div 2 + 4);								if datatype = protein then									if isfrom in polarAA then										ForeColor(bluecolor)									else if isfrom in nonpolarAA then										ForeColor(greencolor)									else if isfrom in negativeAA then										ForeColor(blackcolor)									else if isfrom in positiveAA then										ForeColor(redcolor)									else										ForeColor(cyancolor);								DrawString(ds);								ForeColor(blackcolor);								if CapsLockEvent(Event) then									if nucleotides then										if isfrom in [0, 2] then											DropCursorID(10580, left - 20, top + boxedge * isfrom + boxedge div 2 + 16, srcor)										else											DropCursorID(16411, left - 20, top + boxedge * isfrom + boxedge div 2 + 16, srcor);							end;						GroupEnd;{====== circles ======}						GroupBegin;						for isfrom := 0 to maxChartMatrixCat do							for isto := 0 to maxChartMatrixCat do								begin									if CWScatterMultiColor & (nucleotides) then										begin											if abs(isfrom - isto) = 2 then												RGBForeColor(redRGB)											else if isfrom <> isto then												RGBForeColor(blueRGB);										end									else if OptionEvent(Event) & (datatype = protein) then										begin											if ([isfrom, isto] <= polarAA) | ([isfrom, isto] <= nonpolarAA) | ([isfrom, isto] <= negativeAA) | ([isfrom, isto] <= positiveAA) then												RGBForeColor(redRGB)											else												RGBForeColor(blueRGB);										end									else if ColorPort then										RGBForeColor(histocolor);{||||||||||||  DRAWING the SPOTS  ||||||||||||||||}									for whichspot := numtoshow downto 1 do										begin											theKind := GetSpotBarKind(setToShow, whichspot);											divide := ChangesDivide(theKind);											if ChartMatrixData[theKind]^[isfrom][isto] > 0 then												if MeanSpotBar(theKind) or inflatedchanges then													DrawSpot(ChartMatrixData[theKind]^[isfrom][isto], divide, numtoshow, whichspot)												else													DrawSpot(ChartMatrixData[theKind]^[isfrom][isto], 1.0, numtoshow, whichspot);										end;{||||||||||||||||||||||||||||}									Forecolor(blackcolor);								end;						GroupEnd;{    if not ((Chartchangesmode = unambigmode) and (CWTRees[CWChart] = CWCurrentTRee)) then}						if showLegend then							DrawChartLegend(boundary);					end;			end		else			ReportNoChanges;	end;end.