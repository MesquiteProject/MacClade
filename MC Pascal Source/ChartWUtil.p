unit ChartWUtil;{еееееееееееееееееееееее}interface{$SETC DRMCST := FALSE}{if true, then if hold OptionDown when choose Tree Lengths chart, it will show instead the length}{distribution of all CST's for the currently traced character on the current tree}	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, 		EventUtil, GenUtil, BoxUtil, CharUtil, Prohibitions,{ SetStates,}		SymbolsNames, StrUtil, TaxonCHUtil;	procedure SetChartLinearCategory (theCLkind: integer; interv, setvalue: longint);	function GetChartLinearCategory (theCLkind: integer; interv: longint): longint;	procedure SetChartLinearData (theCLkind: integer; interv, setvalue: longint);	procedure SumChartLinearData (theCLkind: integer; interv, addvalue: longint);	procedure SubtractChartLinearData (theCLkind: integer; interv, subvalue: longint);	function GetChartLinearData (theCLkind: integer; interv: longint): longint;	function LinearChartInitialData (theCLKind: integer): longint;	procedure AddLinearChart (theCLkind: integer; howmany: longint; front: boolean; minChartLinearCat: longint);	procedure AddToChartLinear (theCLkind: integer; theCat: longint; var minCLC, maxCLC: longint);	procedure PadMinMaxChart (minminCLC, minmaxCLC, maxminCLC, maxmaxCLC: longint);	function InflationOnCategory (theChart: integer): longint;	function InflationOnData: longint;	function CIRICategory: boolean;	function CIRIData: boolean;	function InflatedChanges: boolean;	function IntervalLegal (theInterval: longint): boolean;	function ChangesDivide (whichKind: integer): double;	function MeanSpotBar (whichKind: integer): boolean;	function TracedChart: boolean;	procedure ZeroChartData;	function MaximumChartMatrix (theCMkind: integer): longint;	function MinimumChartLinear (theCLkind: integer): longint;	function MaximumChartLinear (theCLkind: integer): longint;	procedure CalcMinMaxCatValues (var mincatvalue, maxcatvalue: longint);	procedure CheckChartMinMax (theCLmin, theCLmax, theinterval: integer; Data: longint);	procedure CalcTotalChart (theCLkind: integer);	function ResetUserMaxChartIntervalsAllowed(newValue: longint): boolean;	function SpotBarSetToShow: set15;	function SpotBarSetToCalc: set15;	function GetSpotBarKind (theSet: Set15; whichbar: integer): integer;	function SpotBarPattern (range, num: integer): pattern;	function NumSpotBar (theSet: set15): integer;	function MaxSpotBarKind: integer;	function MinMaxOn: boolean;	function MinMaxIrregular: boolean;	function CharStateTerm (dostate, firstcap, doplural: boolean): str255;	function CLAllValuesString (j: integer): str255;	function CMAllValuesString (isfrom, isto: integer; var ds: str255): str255;	function CategoryString (theInterval: longint; numdigits: integer; dorange, fortextfile: boolean): Str255;	function CLDataString (theCLkind, theinterval: integer; dopercent: boolean): str255;	function SpotBarName (theKind: integer; longname: boolean): str255;	function StepsChartUnits (toshow: integer; userestriction: boolean): str255;	function CategoryTitle: str255;	procedure SetChartTitleClip;	function ChartTitle: str255;	function ChartImageTitleHeight: integer;	procedure DrawChartImageTitle;	procedure ChartMessage (ds: str255);	procedure SetMaxChangesState;	function MinMaxEnabled: boolean;	const		lengthcycle = 0;		tracedstepcycle = 1;		sequencecycle = 2;		positioncycle = 3;		changescycle = 4;		BiggestMaxMax = -2;		BiggestAuto = -1;		chartRightMargin = 4;		chartDataOffset = 4;		{for each piece of data in linear chart, offset to data of chart}								{note that offset for category is 0}		LDS = 8;		{Linear Data Size - the number of bytes each piece of data for a linear chart occupies}					{the 16 bytes are composed of 4 longints, as follows}					{1.  category longint}					{2.  longint for chart values}		MeanInflate = 1000.0;		MeanChangesInflate = 1000;		CIRIInflate = 100;		maxislands = 25;	type		numintArray = array[0..numCLkinds] of longint;		islandrec = record				starttree: longint;				endtree: longint;				numhits: longint;			end;		islandarray = array[1..maxislands] of islandrec;	var		islands: islandarray;		shortestLength: longint;		numislands: integer;		BiggestSpot: integer;   	{this is the value of the largest spot on a ScatterGram; that is, it is the}								{value of a spot that fills one full square of the scattergram}								{if positive, then equal to the value of the largest spot;}								{if = BiggestMaxMax (-2), then biggest spot is = value of the largest spot}								   {across all CMKinds}								{if = BiggestAuto ( - 1 ) , then biggest spot is = value of the largest spot }								   {for the CMkinds on the chart}		ChartCalcToText: boolean;		useLowCats: boolean;   {if true, then when catwid > 1, category should be assigned value of lower end of range}		ChangesSelMin, ChangesSelMax: longint;		changesSelAvg: double;		allTreesChangesSelMin: longint;		allTreesChangesSelMax: longint;		allTreesChangesSelAvgMin: double;		allTreesChangesSelAvgMax: double;		allTreesTransRatioMin: double;		allTreesTransRatioMax: double;		allTreesTransversionMin: longint;		allTreesTransversionMax: longint;		allTreesTransversionAvgMin: double;		allTreesTransversionAvgMax: double;		allTreesTransitionMin: longint;		allTreesTransitionMax: longint;		allTreesTransitionAvgMin: double;		allTreesTransitionAvgMax: double;		TransversionAvg, TransitionAvg: double;		maxChartLinearCat, maxChartMatrixCat, minChartLinearCat: longint;		CWMultiTreeShow: integer;		ChartTitleRect: rect;		defaultCatWid: longint;		chartTitleStart: point;		maxChartIntervals: longint;		numIntervals: numintArray;		chartorigin: longint;		chartintervals: longint;		TransversionMax, TransversionMin, TransitionMax, TransitionMin: longint;		WriteRootStates: boolean;		{true iff roots states are to be written to text file during TracedStep Calc}		boxedge: integer;		{width & height of each square in a scattergram}{note that numIntervals is not 0-based, whereas in most of the procedures}{and functions, the interval number passed is 0-based}		totalChartLinear, totalChartMatrix: longint;		numCWTrees, numCWchars: longint;		multicharschart: boolean;		transRatio, transRatioMax, transRatioMin, transRatioTotal: double;		DataInflation, CategoryInflation: longint;		PleaseNoMoreChart: boolean;		polytomiesWereBlasted: boolean;   {true if polytomies Blasted in current chart}{еееееееееееееееееееееее}implementation{ throughout the chart window code for linear data (histograms), the following conventions are applied:}{in general, if you look at ChartLinear Data as an array,  A[x], then }{  the index x is the interval number, and this corresponds to some category, stored as a longint}{  the data is given by A[x]}{in a histogram, the vertical axis is always the Data; the horizontal axis the Interval (with the name}{of the interval, in longint form, being the Category}{note that theInterval could be calculated as follows:}{    TheInterval := (theCategory - MinChartLinearCat) div catwid;}{EXAMPLE:}{         |                                             }{ 20 _ |                 ____                    }{         |                 |        |                   }{         |                 |        |                   }{         |                 |        |                   }{         |                 |        |                   }{         |                 |        |                   }{    0_ |____|____|____|____|____|  }{             8     10     12     14     16    }{}{for the single bar, the variables are:}{    category = 12}{	interval = 2  (remember, interval number is 0-based!)}{    Data = 20}{}{other variables:}{    catwid = category width = 2}{    minChartLinearCat = minimum category = 8}{    maxChartLinearCat = maximum category = 16}{    numIntervals = 5, ranging from 0 to 4}{==================================================================}{!!!!!!!!!!!!  Types of Charts  !!!!!!!!!!!!!!}{CWChart takes on the following values}{    CWCSteps  - steps, CI, RI, RC, changes histogram}{    CWCCTAll  - treelength histogram}{    CWCChanges  changes scattergram}{    CWCStates  - states histogram}{    CWCC2T  - compare two trees histogram}{    CWCC2TF  - compare two treefiles histogram}{     CWCcst  - steps in all CST's (only available if compiler directive DRMCST is turned on)}{	CWCProbSteps}{categories and values for the Linear charts}{CWCHART			CATEGORIES		Data			Categ=Steps		Data=Steps}{CWCSteps																				}{  SequenceChart		characters		steps,CI, etc.								x	}{  positionChart		codonPositions	steps,CI, etc.								x	}{  neither				steps,CI, etc.		#characters			x						}{**********}{thus in dialog box the six icons of charts are distinguished as follows:}{(CWTRees[CWChart] = CWCurrentTree)}{[neither]      sequencechart  positionchart}{(CWTRees[CWChart] <> CWCurrentTree)}{[neither]      sequencechart  positionchart}{**********}{CWCCTAll			treelengths		#trees					x						}{CWCStates  			states				frequency										}{CWCC2T				characters		diff in steps								x	}{CWCC2TF  			characters		diff in steps								x	}{CWCcst  				steps				#CST's				x						}{==================================================================}{!!!!!!!!!!!!    Kinds & SpotBars    !!!!!!!!!!!!!}{for a given calculated chart, there may be more than one array of}{data.  These different arrays, which manifest themselves on the screen}{as white versus QDGray versus QDBlack bars or circles, are called Kinds or}{SpotBars.  For some types of chart, their exists only one Kind - e.g. treelength}{for other types, in which multiple historical pathways are possible, and }{multiple trees are examined, their can be multiple Kinds - that is, one}{array housing the minimum of minima across trees, another housing the}{mean of minima, maximum of minima, minimum of maxima, mean of maxima,}{and maximum of maxima}{no more than 3 Kinds can be displayed in the chart at once; if more than 3 are}{calculated, it is up to the user to specify which kinds are displayed.}{ 2 global variables, CLKind and CMKind, are generally equal to CLStandard, and}{are the kinds that are used when no other kinds are requested.  the value of }{CLKind is actually set to MaxSpotBarKind- in ChartMenu}{==================================================================}{values of theKind global constants:}{		3minmax								6minmax			4extras}{0		CLmin									CLminmin			CLmin1}{1		CLstandard							CLminmean		CLmax1}{2		CLmax									CLminmax			CLmin2}{3							CLextra			CLmaxmin			CLmax2}{4												CLmaxmean		}{5												CLmaxmax		}{												2extras					}{6												CLextraMin		}{7												CLextraMax		}{CWCHART						Kinds Calculated			Temporary Kinds}{CWCSteps}{CWTrees[CWChart] = CWCurrentTree; i.e., single tree}{CWCSteps-StepsCIRIRC}{  SequenceChart					CLStandard					}{  positionChart					CLStandard					}{  neither							CLStandard					}{CWCSteps-Changes}{  SequenceChart					CLmin CLMax					}{  positionChart					CLmin CLmax					}{  neither							CLmin CLMax					}{CWTrees[CWChart] <> CWCurrentTree; i.e., multiple trees}{CWCSteps-StepsCIRIRC}{  SequenceChart					3minmax						CLextra}{  positionChart					3minmax						CLextra}{  neither							CLStandard					}{CWCSteps-Changes}{  SequenceChart					6minmax						2extras}{  positionChart					6minmax						2extras}{  neither							CLMin CLMax				}{CWCCTAll						CLStandard		}{CWCStates  						CLStandard		}{CWCC2T							CLStandard		}{CWCC2TF  						CLStandard					4extras}{CWCcst  							CLStandard		}{CWCChanges}{CWTrees[CWChart] = CWCurrentTree; i.e., single tree}{  unambigmode					CMStandard					}{  meanmode						CMStandard					}{  minmaxmode					CMMin CMMax					}{CWTrees[CWChart] <> CWCurrentTree; i.e., single tree}{  unambigmode					3minmax						}{  meanmode						3minmax						}{  minmaxmode					6minmax						}{==================================================================} {е$S ChartWUtil}{||||||||||||||||||||||||||||||||||  Setting or Getting Chart Linear Categories & Data |||||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	function currentMaxInterval(theCLKind: integer): longint;	begin		currentMaxInterval := GetHandleSize(ChartLinearData[theCLkind]) div LDS - 1;	end;{-----------------------------------------------------------------------------}	procedure SetChartLinearCategory (theCLkind: integer; interv, setvalue: longint);		var			datapointer: LIP;			oldState: SignedByte;	begin		if interv<= currentMaxInterval(theCLKind) then			begin				LockHandle(ChartLinearData[theCLkind], oldstate);				datapointer := LIP(GetMaster(ChartLinearData[theCLkind]) + interv*LDS);				datapointer^ := setvalue;				ResetHandle(ChartLinearData[theCLkind], oldstate);			end;	end;{-----------------------------------------------------------------------------}	function GetChartLinearCategory (theCLkind: integer; interv: longint): longint;		var			oldState: SignedByte;	begin		LockHandle(ChartLinearData[theCLkind], oldstate);		if interv>currentMaxInterval(theCLKind) then			GetChartLinearCategory := LIP(GetMaster(ChartLinearData[theCLkind]) + LDS * currentMaxInterval(theCLKind))^		else			GetChartLinearCategory := LIP(GetMaster(ChartLinearData[theCLkind]) + LDS * interv)^;		ResetHandle(ChartLinearData[theCLkind], oldstate);	end;{-----------------------------------------------------------------------------}	procedure SetChartLinearData (theCLkind: integer; interv, setvalue: longint);		var			datapointer: LIP;			oldState: SignedByte;	begin		if interv<= currentMaxInterval(theCLKind) then			begin				LockHandle(ChartLinearData[theCLkind], oldstate);				datapointer := LIP(GetMaster(ChartLinearData[theCLkind]) + LDS * interv + chartDataOffset);				datapointer^ := setvalue;				ResetHandle(ChartLinearData[theCLkind], oldstate);			end;	end;{-----------------------------------------------------------------------------}	procedure SumChartLinearData (theCLkind: integer; interv, addvalue: longint);		var			datapointer: LIP;			oldState: SignedByte;	begin		if interv<= currentMaxInterval(theCLKind) then			begin				LockHandle(ChartLinearData[theCLkind], oldstate);				datapointer := LIP(GetMaster(ChartLinearData[theCLkind]) + LDS * interv + chartDataOffset);				datapointer^ := datapointer^ + addvalue;				ResetHandle(ChartLinearData[theCLkind], oldstate);			end;	end;{-----------------------------------------------------------------------------}	procedure SubtractChartLinearData (theCLkind: integer; interv, subvalue: longint);{this is called in compare two trees, compare two treefiles}		var			datapointer: LIP;			oldState: SignedByte;	begin		if interv<= currentMaxInterval(theCLKind) then			begin				LockHandle(ChartLinearData[theCLkind], oldstate);				datapointer := LIP(GetMaster(ChartLinearData[theCLkind]) + LDS * interv + chartDataOffset);				datapointer^ := datapointer^ - subvalue;				ResetHandle(ChartLinearData[theCLkind], oldstate);			end;	end;{-----------------------------------------------------------------------------}	function GetChartLinearData (theCLkind: integer; interv: longint): longint;		var			oldState: SignedByte;	begin		LockHandle(ChartLinearData[theCLkind], oldstate);		if interv>currentMaxInterval(theCLKind) then			GetChartLinearData := LIP(GetMaster(ChartLinearData[theCLkind]) + LDS * currentMaxInterval(theCLKind) + chartDataOffset)^		else			GetChartLinearData := LIP(GetMaster(ChartLinearData[theCLkind]) + LDS * interv + chartDataOffset)^;		ResetHandle(ChartLinearData[theCLkind], oldstate);			end;{|||||||||||||||||||||||  Adding new elements to the linear chart Data structure ||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	function LinearChartInitialData (theCLKind: integer): longint;{returns the value of the Data to which an element of theCLKind should be initialized}		var			initnum: longint;	begin		initnum := 0;		if (CWChart = CWCsteps) then			begin				if (sequencechart or positionchart) then					if (CWTrees[CWChart] <> CWCurrentTree) then						if ((CWStepsShow = CWStepsChanges) and (theCLKind in [CLmaxmin, CLminmin])) or ((CWStepsShow <> CWStepsChanges) and (theCLKind = CLmin)) then							initnum := ChartInfinity;			end		else if (((CWChart <> CWCC2TF) and (CWTrees[CWChart] <> CWCurrentTree)) and (theCLkind = CLmin)) or ((CWChart = CWCC2TF) and (theCLkind in [CLmin1, CLmin2])) then			initnum := ChartInfinity;		LinearChartInitialData := initnum;	end;{-----------------------------------------------------------------------------}{note: if catwid > 1, then ChartLinearCategory stores the lower bound for an interval}{therefore, if catwid = 2, then :}{	int		cat}{	1		1}{	2		1}{	3		3}{	4		3}{-----------------------------------------------------------------------------}	function OldLowerCatValue (theCat: longint): longint;	begin		OldLowerCatValue := (theCat - 1) div catwid * catwid + 1;	end;{-----------------------------------------------------------------------------}	function LowerCatValue (theCLKind: integer; theInterval: longint): longint;	begin		LowerCatValue := GetChartLinearCategory(theCLKind, theInterval);	end;{-----------------------------------------------------------------------------}	function UpperCatValue (theCLKind: integer; theInterval: longint): longint;	begin		UpperCatValue := GetChartLinearCategory(theCLKind, theInterval) + catWid - 1;	end;{-----------------------------------------------------------------------------}	procedure AddLinearChart (theCLkind: integer; howmany: longint; front: boolean; minChartLinearCat: longint);{adds howmany new linear Chart elements either to front or back of ChartLinearData,}{and initializes their values}		var			j: longint;			H: Handle;			initnum: longint;			amountneeded: longint;	begin		if not EnoughMemory(ord4(LDS) * howmany, amountneeded) then			begin				pleaseNoMoreChart := true;				NewError(375, 0);				Exit(AddLinearChart);			end;{===== determining the number to initialize each new element ========}		initnum := LinearChartInitialData(theCLKind);{====== creating and initializing new elements ======}		if front then		{we have to add howmany elements to the front of the existing storage}			begin				H := NewHandle(LDS * howmany);				HLock(ChartLinearData[theCLkind]);				currentIOPosition := 69;   {v3.05}				if not OSSuccessful(HandandHand(ChartLinearData[theCLkind], H)) then   {could not add new things to chartlinear}					begin						pleaseNoMoreChart := true;						NewError(375, 0);						HUnlock(ChartLinearData[theCLkind]);						ZapHandle(H);						Exit(AddLinearChart);					end;				HUnlock(ChartLinearData[theCLkind]);				ZapHandle(ChartLinearData[theCLkind]);				ChartLinearData[theCLkind] := H;				for j := 1 to howmany do		{going through new intervals from the left to right}					begin						SetChartLinearData(theCLkind, j - 1, initnum);  {+++ use nocum}						SetChartLinearCategory(theCLkind, j - 1, minChartlinearCat - (howmany - j + 1) * catwid);{that is, set category to minChartlinearCat - (howmany - (j - 1)) * catwid }					end;			end		else			begin				HUnlock(ChartLinearData[theCLkind]);				SetHandleSize(ChartLinearData[theCLkind], GetHandleSize(ChartLinearData[theCLkind]) + LDS * howmany);				for j := numIntervals[theCLkind] + 1 to numIntervals[theCLkind] + howmany do					begin						SetChartLinearData(theCLkind, j - 1, initnum);  {+++ use nocum}						SetChartLinearCategory(theCLkind, j - 1, minChartlinearCat + (j - 1) * catwid);					end;			end;		numIntervals[theCLkind] := numIntervals[theCLkind] + howmany;	end;{-----------------------------------------------------------------------------}	function QueryIncreaseIntervalNumber: boolean;	begin		QueryIncreaseIntervalNumber:= false;		if autoIncreaseChartIntervals then			QueryIncreaseIntervalNumber:= not pleaseNoMoreChart & ResetUserMaxChartIntervalsAllowed(userMaxChartIntervals+100)		else			case DoAlert(158,CautionA) of				1: 					QueryIncreaseIntervalNumber:= not pleaseNoMoreChart & ResetUserMaxChartIntervalsAllowed(userMaxChartIntervals+100);				3: 					begin						QueryIncreaseIntervalNumber:= not pleaseNoMoreChart & ResetUserMaxChartIntervalsAllowed(userMaxChartIntervals+100);						autoIncreaseChartIntervals := true;					end;				otherwise ;			end;	end;{-----------------------------------------------------------------------------}	procedure AddToChartLinear (theCLkind: integer; theCat: longint; var minCLC, maxCLC: longint);{adds 1 to the data value of the interval corresponding to category theCat}		var			toAdd: longint;{.........}		function LocalInterval (theCategory: longint): longint;			var				li: longint;		begin			li := (theCategory - minCLC) div catwid;			LocalInterval := li;		end;{.........}	begin{===== adding/preparing the Category if not already there =====}		if (minCLC + maxCLC < 0) then			begin				if catwid > 1 then   {assign to theCat the lower value of the interval, so that interval ranges from}								{lowerCat  to lowerCat + catwid-1}					minCLC := theCat div catwid * catwid				else					minCLC := theCat;				maxCLC := minCLC;				HUnlock(ChartLinearData[theCLkind]);				SetHandleSize(ChartLinearData[theCLkind], LDS);				SetChartLinearData(theCLkind, 0, 0);  {+++ use nocum}				SetChartLinearCategory(theCLkind, 0, minCLC);				numIntervals[theCLkind] := 1;			end		else if theCat < minCLC then			begin				toAdd := LocalInterval(minCLC) - LocalInterval(theCat);				if (catwid > 1) and ((theCat - minCLC) mod catwid <> 0) then					toAdd := toAdd + 1;				if (toAdd + numintervals[theCLkind] < userMaxChartIntervals) | QueryIncreaseIntervalNumber then					begin						AddLinearChart(theCLkind, toAdd, true, minCLC);						minCLC := theCat div catwid * catwid;					end				else					begin						pleaseNoMoreChart := true;						NewError(119, 0);					end;			end		else if theCat > maxCLC then			begin				toAdd := LocalInterval(theCat) - LocalInterval(maxCLC);				if (toAdd + numintervals[theCLkind] < userMaxChartIntervals) | QueryIncreaseIntervalNumber then					begin						AddLinearChart(theCLkind, toAdd, false, minCLC);						maxCLC := theCat div catwid * catwid;					end				else					begin						pleaseNoMoreChart := true;						NewError(119, 0);					end;			end;{==== adding 1 to the value =====}		if not errorflag and not pleaseNoMoreChart then			SumChartLinearData(theCLkind, LocalInterval(theCat), 1);  {+++ use nocum}	end;{-----------------------------------------------------------------------------}	procedure PadMinMaxChart (minminCLC, minmaxCLC, maxminCLC, maxmaxCLC: longint);	begin		if minminCLC < maxminCLC then				{need to pad out start of CLmax data}			AddLinearChart(CLmax, maxminCLC - minminCLC, true, maxminCLC);		if minmaxCLC < maxmaxCLC then				{need to pad out end of CLmin data}			AddLinearChart(CLmin, maxmaxCLC - minmaxCLC, false, minminCLC);		minChartLinearCat := minminCLC;		maxChartLinearCat := maxmaxCLC;	end;{-----------------------------------------------------------------------------}{||||||||||||||||||||||||||||| Inflation |||||||||||||||||||||||||||||||||||||}{inflation is used in place of using real variables}{Things that cause inflation:  }{1. CI,RI - in which case the categories or data are inflated 100x}{2.  means - their are two types of means:  }{      a. raw data calculated are not means, but one of the SpotBars that is calculated is a mean of}{           the raw data   }{			- inflation factor of MeanInflate}{      b. raw data calculated are means - this only occurs in CWCChanges, chartchangesmode = meanmode}{			-inflation factor MeanChangesInflate}{3. steps, changes that are effected by realwts or realtypes - in which case the inflation factor is either}{    lengthinflate or typeinflate}{-----------------------------------------------------------------------------}	function InflationOnCategory (theChart: integer): longint;{Returns inflation on stored values of categories (horizontal) of charts.}		var			inflate: longint;	begin		case theChart of			CWCSteps:   {Steps/etc}				begin					if sequencechart or positionchart then						InflationOnCategory := 1  {category is positional thus not inflated}					else						case CWStepsShow of							CWStepsChanges: 								InflationOnCategory := 1; {category is changes thus not inflated; never mean categories}							CWSTepsSteps: 								begin {Steps }									inflate := 1;									if realtypes then										if not CWTraced | TypeisReal(TypeOfChar(i)) then											inflate := inflate * typeinflate;									if (CWTRees[theChart] = CWCurrentTree) & realwt then										inflate := inflate * wtinflate;					{don't inflate if multitrees as then it is only done}					{over traced character and weighting is not shown}									InflationOnCategory := inflate;								end;							otherwise {CI, RI, RC}								InflationOnCategory := CIRIInflate; {category is CIRIRC thus inflated for accuracy to two decimals}						end;				end;			CWCChanges: {Changes & Stasis}				begin					InflationOnCategory := 1  {category is type of change and thus not inflated}				end;			CWCStates:  {State frequencies}				begin					InflationOnCategory := 1  {category is type of state and thus not inflated}				end;			CWCCTAll:   {Treelengths}				begin					InflationOnCategory := lengthinflate; {lengthinflate records inflation due to both types and wts}				end;			CWCC2T:   {compare two trees histogram}				begin					InflationOnCategory := 1  {category is positional thus not inflated}				end;			CWCC2TF:   {compare two treefiles histogram}				begin					InflationOnCategory := 1  {category is positional thus not inflated}				end;			CWCProbSteps: 				InflationOnCategory := 1;			otherwise				InflationOnCategory := 1;		end;	end;{-----------------------------------------------------------------------------}	function InflationOnData: longint;{Returns inflation on stored values of Data (Vertical) of charts.}{note: this does NOT consider mean inflation}{that is, this is inflation independent of SpotBarKind}{It also does not consider percent, which does not affect the stored values anyway}	begin		case CWChart of			CWCSteps:   {Steps/etc}				begin					if sequencechart or positionchart then						begin							case CWStepsShow of								CWSTepsSteps: 									begin {Steps }										InflationOnData := lengthinflate; {lengthinflate records inflation due to both types and wts}									end;								CWStepsChanges: 									InflationOnData := 1; 		{data is changes thus not inflated thereby}								otherwise {CI, RI, RC}									inflationondata := CIRIInflate; 	{category is CIRIRC thus inflated for accuracy to two decimals}							end;						end					else {not sequencechart or positionchart}						InflationOnData := 1;  { Data is number of characters or trees thus not inflated }				end;			CWCChanges: {Changes & Stasis}				begin					if chartchangesmode = meanmode then						InflationOnData := meanchangesinflate					else						InflationOnData := 1  {data is number of changes and thus not inflated}				end;			CWCStates:  {State frequencies}				begin					InflationOnData := 1				end;			CWCCTAll:   {Treelengths}				begin					InflationOnData := 1;  { Data is number of trees thus not inflated }				end;			CWCC2T:   {compare two trees histogram}				begin					InflationOnData := lengthinflate; {lengthinflate records inflation due to both types and wts}				end;			CWCC2TF:   {compare two treefiles histogram}				begin					InflationOnData := lengthinflate; {lengthinflate records inflation due to both types and wts}				end;			CWCProbSteps: 				InflationOnData := 10000;			otherwise				InflationOnData := 1;		end;	end;{-----------------------------------------------------------------------------}	function CIRICategory: boolean;	begin		CIRICategory := (CWChart = CWCSteps) and (CWStepsShow in [CWStepsCI, CWStepsRI, CWStepsRC]) and not (sequencechart or positionchart);	end;{-----------------------------------------------------------------------------}	function CIRIData: boolean;	begin		CIRIData := (CWChart = CWCSteps) and (CWStepsShow in [CWStepsCI, CWStepsRI, CWStepsRC]) and (sequencechart or positionchart);	end;{-----------------------------------------------------------------------------}	function IntervalLegal (theInterval: longint): boolean;{this procedure returns TRUE if the interval theInterval is legal, that is, }{values for it can be calculated.  this is used in sequencecharts and positionchart.}{e.g. in a sequencechart, interval legal is false if that character is excluded.}{this procedure is used to QDGray intervals in drawing of the histogram  -}		var			ic, firstchar: longint;			barexcluded, allillegal: boolean;	begin		IntervalLegal := true;		if (((CWChart = CWCsteps) & sequencechart) | (CWChart = CWCC2T) | (CWChart = CWCC2TF)) then			begin				firstChar := GetChartLinearCategory(CLKind, theInterval);{===== check that they are all excluded ======}				if numchars <> numcharin then					begin						barexcluded := true;						for ic := firstchar to firstchar + catwid - 1 do							if ic <= numchars then {v3.02:}								if CharIncluded(ic) then									begin										barexcluded := false;										leave;									end;					end				else					barexcluded := false;				if barexcluded then					IntervalLegal := false				else if CWStepsShow in [CWStepsCI, CWStepsRI, CWStepsRC] then					begin{===== check that they are all illegal ======}						allillegal := true;{v4: have a global boolean that records if all legal - globals made but not used}						for ic := firstchar to firstchar + catwid - 1 do							if ic <= numchars then {v3.02:}								if charincluded(ic) & MinMaxLenLegalChar(ic, minlength) & ((CWStepsShow = CWStepsCI) | MinMaxLenLegalChar(ic, maxlength)) then									begin										allillegal := false;										leave;									end;						if allillegal then							IntervalLegal := false					end;			end{===== positionchart =====}		else if (CWChart = CWCsteps) and positionchart then			begin{===== check that they are all excluded ======}				barexcluded := true;				for ic := 1 to numchars do					if CharIncluded(ic) and (charCodPos(ic) = theInterval + 1) then						begin							barexcluded := false;							leave;						end;				if barexcluded then					IntervalLegal := false				else if CWStepsShow in [CWStepsCI, CWStepsRI, CWStepsRC] then					begin{===== check that they are all illegal ======}						allillegal := true;						for ic := 1 to numchars do							if (charCodPos(ic) = theInterval + 1) & MinMaxLenLegalChar(ic, minlength) & ((CWStepsShow = CWStepsCI) | MinMaxLenLegalChar(ic, maxlength)) then								begin									allillegal := false;									leave;								end;						if allillegal then							IntervalLegal := false					end;			end;	end;{-----------------------------------------------------------------------------}	function InflatedChanges: boolean;	begin		InflatedChanges := (CWChart = CWCChanges) and (Chartchangesmode = meanmode);	end;{-----------------------------------------------------------------------------}	function ChangesDivide (whichKind: integer): double;		var			divide: double;	begin		divide := 1.0;		if inflatedchanges then			divide := divide * MeanChangesInflate;		if MeanSpotBar(whichKind) then			divide := divide * MeanInflate;		ChangesDivide := divide;	end;{-----------------------------------------------------------------------------}	function TracedChart: boolean;{returns true if current chart only concerns the traced character}	begin		TracedChart := ((CWChart = CWCSteps) and CWTraced) or ((CWChart = CWCStates) and CWTraced) or ((CWChart = CWCChanges) and CWTraced);	end;{-----------------------------------------------------------------------------}	function MeanSpotBar (whichKind: integer): boolean;	begin		MeanSpotBar := false;		if CWChart = CWCChanges then			begin				if CWTRees[CWChart] <> CWCurrentTRee then					if (Chartchangesmode = unambigmode) or (Chartchangesmode = meanmode) then						MeanSpotBar := whichKind = CMStandard					else						MeanSpotBar := whichKind in [CMmaxmean, CMminmean];			end		else if (CWTrees[CWChart] <> CWCurrentTree) and (CWChart in [CWCSteps]) and (sequencechart or positionchart) then			if (CWStepsShow = CWStepsChanges) then				MeanSpotBar := whichKind in [CLmaxmean, CLminmean]			else				MeanSpotBar := whichKind = CLStandard;	end;{||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	procedure ZeroChartData;{initializes either matrix or linear chart data}{note for linear chart data, does not initialize the values of each interval, as they}{are initialized when they are created}		var			j, k, m: integer;	begin		if not CWLinear then			begin				for m := 0 to numCMkinds do					begin						if (CWTrees[CWCChanges] <> CWCurrentTree) and (((Chartchangesmode = minmaxmode) and (m in [CMminmin, CMmaxmin])) or (((Chartchangesmode = unambigmode) or (Chartchangesmode = meanmode)) and (m = CMmin))) then {>>>>>>>>>>>>}							begin								for j := 0 to maxChangesState do									for k := 0 to maxChangesState do										if (j <> k) or CWShowConstant then											ChartMatrixData[m]^[j][k] := ChartInfinity										else											ChartMatrixData[m]^[j][k] := 0;							end						else							for j := 0 to maxChangesState do								for k := 0 to maxChangesState do									ChartMatrixData[m]^[j][k] := 0;					end;			end		else			for m := 0 to numCLkinds do				begin					HUnlock(ChartLinearData[m]);					SetHandleSize(ChartLinearData[m], 0);				end;	end;{-----------------------------------------------------------------------------}	function MinimumChartLinear (theCLkind: integer): longint;		var			j, minvalue: longint;	begin		minvalue := ChartInfinity;		for j := 0 to numIntervals[theCLkind] - 1 do			ReplaceIfMinimumLong(minvalue, GetChartLinearData(theCLkind, j));  {what about -1}  {+++ use cumview}		MinimumChartLinear := minvalue;	end;{-----------------------------------------------------------------------------}	function MaximumChartLinear (theCLkind: integer): longint;		var			j, maxvalue, theData: longint;			divvalue: double;	begin		if MeanSpotBar(theCLKind) then			divvalue := MeanInflate * catwid  {no possibility this is zero}		else			divvalue := 1.0;		maxvalue := 0;		for j := 0 to numIntervals[theCLkind] - 1 do			begin				theData := RoundValue(GetChartLinearData(theCLkind, j) / divvalue);  {+++ use cumview}				if theData > maxvalue then					maxvalue := theData;			end;		MaximumChartLinear := maxvalue;	end;{-----------------------------------------------------------------------------}	function MaximumChartMatrix (theCMkind: integer): longint;		var			j, k, maxvalue, currentData: longint;	begin		maxvalue := 0;		for j := 0 to maxChangesState do			for k := 0 to maxChangesState do				begin					if MeanSpotBar(theCMKind) then						currentData := RoundValue(ChartMatrixData[theCMkind]^[j][k] / MeanInflate)					else						currentData := ChartMatrixData[theCMkind]^[j][k];					if InflatedChanges then						if (maxvalue > 0) or (currentData > 0) then							currentData := currentData div MeanChangesInflate + 1						else							currentData := currentData div MeanChangesInflate;					if currentData > maxvalue then						maxvalue := currentData;				end;		MaximumChartMatrix := maxvalue;	end;{-----------------------------------------------------------------------------}	procedure CalcMinMaxCatValues (var mincatvalue, maxcatvalue: longint);		var			j: integer;	begin		if CWChart in [CWCC2T, CWCC2TF] then			mincatvalue := MinimumChartLinear(CLkind)		else			mincatvalue := 0;		if CWPercent and CW100Axis then			maxcatvalue := 100		else if MinMaxIrregular then			begin				maxCatValue := MaximumChartLinear(CLmin);				j := MaximumChartLinear(CLmax);				if j > maxCatValue then					maxCatValue := j;			end		else if CWScaleToMax and MinMaxOn then			maxCatValue := MaximumChartLinear(CLMaxMax)		else			maxCatValue := MaximumChartLinear(MaxSpotBarKind);		emptychart := minCatValue = maxCatValue;	end;{-----------------------------------------------------------------------------}	procedure CheckChartMinMax (theCLmin, theCLmax, theinterval: integer; Data: longint);{checks to see if value of Data is less than previously recorded minimum, in which case}{it resets minimum to this new low, or whether it is larger than previously recorded}{maximum, in which case it resets it to this new high}	begin		if Data < GetChartLinearData(theCLmin, theinterval) then {+++ use nocum}			SetChartLinearData(theCLmin, theinterval, Data);		if Data > GetChartLinearData(theCLmax, theinterval) then {+++ use nocum}			SetChartLinearData(theCLmax, theinterval, Data);	end;{-----------------------------------------------------------------------------}	procedure CalcTotalChart (theCLkind: integer);{theCLKind is only relevant for linear charts - it is ignored by matrix charts}		var			isfrom, isto, j: longint;			theCM: integer;	begin{gets the value of the highest state involved in matrix, to get bounds of matrix cells, and it calculates}{total}		if not CWLinear then			begin				theCM := MaxSpotBarKind;				totalChartMatrix := 0;				maxChartmatrixcat := 0;				for isfrom := 0 to maxChangesState do					for isto := 0 to maxChangesState do						if ChartMatrixData[theCM]^[isfrom][isto] > 0 then							begin								totalChartMatrix := totalChartMatrix + ChartMatrixData[theCM]^[isfrom][isto];								maxChartMatrixCat := IntegerMax(maxChartMatrixCat, isfrom);								maxChartMatrixCat := IntegerMax(maxChartMatrixCat, isto);							end;			end		else{=============}			begin				TotalChartLinear := 0;				for j := 0 to numIntervals[theCLkind] - 1 do					TotalChartLinear := TotalChartLinear + GetChartLinearData(theCLkind, j);  {+++use cumview}			end;	end;{||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||} {-----------------------------------------------------------------------------}	function SpotBarSetToShow: set15;{returns the set of spotbars=kinds to show on the chart window}{note that this will be a subset of the calculated spotbars}{CMShow is determined by the user in MinMaxOptions in ChartWindow, and by its }{initialization in StartUpUtil}{tshow is set to CMShow only if minmaxon}		var			tshow: set15;	begin		if CWChart = CWCChanges then			begin				if (Chartchangesmode = unambigmode) or (Chartchangesmode = meanmode) then					begin						if CWTRees[CWChart] = CWCurrentTRee then							tshow := [CMstandard]						else							tshow := [CMmin, CMmax, CMstandard];					end				else if CWTRees[CWChart] = CWCurrentTRee then					tshow := [CMmin, CMmax]				else					tshow := CMshow;			end		else if (CWTrees[CWChart] <> CWCurrentTree) and (CWChart in [CWCSteps]) and (sequencechart or positionchart) then			if (CWStepsShow = CWStepsChanges) then				tshow := CMShow			else				tshow := [CLmin, CLstandard, CLmax]		else if (CWChart = CWCSteps) and (CWStepsShow = CWStepsChanges) then			tshow := [CLmin, CLmax]		else			tshow := [CLstandard];		SpotBarSetToShow := tShow;	end;{-----------------------------------------------------------------------------}	function SpotBarSetToCalc: set15;	begin		if minmaxon then			SpotBarSetToCalc := [0..5]		else			SpotBarSetToCalc := SpotBarSetToShow;	end;{-----------------------------------------------------------------------------}	function ResetUserMaxChartIntervalsAllowed(newValue: longint): boolean;	var		maxintervals, olduserMaxChartIntervals: longint;		setToCalc: set15;		numtoCalc, memoryrequired: longint;	begin		olduserMaxChartIntervals := userMaxChartIntervals;		settocalc := SpotBarSetToCalc;		NumtoCalc := cardP(@settocalc, 15);		maxintervals := (myFreeMem - memorySlack) div LDS div numtocalc;		userMaxChartIntervals := newValue;		if userMaxChartIntervals < 2 then			userMaxChartIntervals := 2		else if userMaxChartIntervals > maxintervals then			begin				InstantErrorPlus(87, StringFromNum(maxintervals));				userMaxChartIntervals := maxintervals;			end;		ResetUserMaxChartIntervalsAllowed := userMaxChartIntervals > olduserMaxChartIntervals;	end;{-----------------------------------------------------------------------------}	function GetSpotBarKind (theSet: Set15; whichbar: integer): integer;{given a set of kinds (that is, a set of spotbars), and the position in this set of a bar or kind,}{this function returns the value of theKind;  e.g. if theSet = [1,3,4] and whichbar = 2 , then theKind = 3 }		var			k, j: integer;	begin		k := 0;		for j := 0 to NumCLkinds do			if j in theSet then				begin					k := k + 1;					if k = whichbar then						leave;				end;		GetSpotBarKind := j;	end;{-----------------------------------------------------------------------------}	function NumSpotBar (theSet: set15): integer;	begin		NumSpotBar := cardP(@theSet, 15);	end;{-----------------------------------------------------------------------------}	function MaxSpotBarKind: integer;{returns the highest-valued Kind that is to be shown; this kind will have the highest}{valued data}		var			settoshow: set15;	begin		settoshow := SpotBarSetToShow;		MaxSpotBarKind := GetSpotBarKind(settoshow, NumSpotBar(setToShow));	end;{-----------------------------------------------------------------------------}	function MinMaxOn: boolean;{this function reports as to whether or not there are more than three Kinds in the settocalc;}{this occurs when theData values can have a maximum and minimum over a tree, and multiple}{trees are being processed}{It is up to the user to choose which of the more than three Kinds should be shown at any one time}	begin		MinMaxOn := (CWTrees[CWChart] <> CWCurrentTree) and (((CWChart = CWCChanges) and (ChartChangesMode = minmaxmode)) or ((CWChart in [CWCSteps]) and (CWStepsShow = CWStepsChanges) and (sequencechart or positionchart)))	end;{|||||||||||||||||  Patterns |||||||||||||||||||}{-----------------------------------------------------------------------------}	function MinMaxIrregular: boolean;{returns true if have to show the diagonal striping with CWStepsChanges}	begin		MinMaxIrregular := (CWChart in [CWCSteps]) and not (sequencechart or positionchart) and (CWStepsShow = CWStepsChanges);	end;{-----------------------------------------------------------------------------}	function SpotBarPattern (range, num: integer): pattern;		var			thePat: pattern;	begin		if MinMaxIrregular then			begin				GetIndPattern(thePat, 258, num);				SpotBarPattern := thePat;			end		else if range = 1 then			SpotBarPattern := pat[histopat]		else if num = 1 then			SpotBarPattern := QDBlack		else if num = 2 then			SpotBarPattern := QDGray		else			SpotBarPattern := QDWhite;	end;{||||||||||||||||||||||||||||||  Names  ||||||||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	function CharStateTerm (dostate, firstcap, doplural: boolean): str255;		var			ds: str255;	begin		if dostate then			if nucleotides then				ds := 'nucleotide'			else if datatype = protein then				ds := 'amino acid'			else				ds := 'state'		else if nucleotides then			ds := 'site'		else if datatype = protein then			ds := 'site'		else			ds := 'character';		if firstcap then			ds[1] := CapChar(ds[1]);		if doplural then			ds := concat(ds, 's');		CharStateTerm := ds;	end;{-----------------------------------------------------------------------------}	function CategoryString (theInterval: longint; numdigits: integer; dorange, fortextfile: boolean): Str255;{returns the name of the category for theInterval}		var			ds, ds2: str255;			roundfactor: double;			j: integer;			theCat: longint;			realspresent: boolean;{.............}		function SingleCatString (theCat: longint): str255;		begin			if CategoryInflation > 1 then				SingleCatString := RealToIntegerstring(theCat, CategoryInflation)			else				SingleCatString := StringFromNum(theCat);		end;{.............}		procedure standardCatString;			var				endInt: longint;		begin			theCat := GetChartLinearCategory(CLkind, theInterval);			if not useLowCats & not dorange & (theInterval <> 0) then				ds := SingleCatString(theCat + catwid - 1)			else				ds := SingleCatString(theCat);			if dorange then 				begin					if (catwid > 1) then						begin							endInt := theCat + catwid - 1;							if (CWChart = CWCSteps) & sequencechart & (endInt > numchars) then								endInt := numchars;							ds2 := SingleCatString(endInt);{if fortextfile then ds := concat(ds, chr(9), ds2) else }							ds := concat(ds, ' - ', ds2);						end;				end		end;{..............}	begin		case CWChart of			CWCcst: 				StandardCatString; {DRM CST}			CWCProbSteps: 				StandardCatString;			CWCStates: 				begin					if datatype = protein then						ds := CharStateName(1, theInterval)					else						ds := CharOfNum(theInterval);				end;			CWCSteps: 				if (CWStepsShow in [CWStepsSteps, CWStepsChanges]) or sequencechart or positionchart then					StandardCatString				else  {CI, RI, RC}					begin{$IFC FALSE}						roundfactor := 0.001;						for j := 1 to 2 do							roundfactor := roundfactor / 10.0;{$ENDC}						RealToString(GetChartLinearCategory(CLkind, theInterval) / CIRIInflate, ds, 10, 2, false);						if dorange then							if (theInterval <> numintervals[CLkind] - 1) then								begin									RealToString(GetChartLinearCategory(CLkind, theInterval + 1) / CIRIInflate - 0.001, ds2, 10, 3, false);{if fortextfile then ds := concat ( ds , chr ( 9 ) , ds2 ) else}									ds := concat(ds, ' - ', ds2);								end;{else if fortextfile then ds := concat(ds, chr(9), ds)}					end;			CWCCTAll: 				StandardCatString;			CWCC2T, CWCC2TF: 				if (CWView = tableView) and not fortextfile then					ds := concat(StringFromNum(theInterval + 1), '. ', CharName(theInterval + 1))				else					StandardCatString;			otherwise				;		end;		CategoryString := ds;	end;{-----------------------------------------------------------------------------}	function CLDataString (theCLkind, theinterval: integer; dopercent: boolean): str255;{returns the string representation of theData for theinterval}		var			ds: str255;			realvalue: double;			divvalue: double;	begin		if dopercent then			divvalue := 1		else			divvalue := DataInflation;		if MeanSpotBar(theCLKind) then			divvalue := divvalue * MeanInflate;  {no possibility this is zero}		if dopercent & (TotalChartLinear > 0) then			begin				realvalue := 100.0 * GetChartLinearData(theCLkind, theinterval) / TotalChartLinear / divvalue;				RealToString(realvalue, ds, 100, 2, true);			end		else if MeanSpotBar(theCLKind) or (datainflation > 1) then			if CWChart = CWCProbSteps then {v3.05}				RealToString(1.0 * GetChartLinearData(theCLkind, theinterval) / divvalue, ds, 10000, OrderOfMag(datainflation), true)			else				RealToString(1.0 * GetChartLinearData(theCLkind, theinterval) / divvalue, ds, 10000, 2, true)		else			ds := StringFromNum(GetChartLinearData(theCLkind, theinterval));		CLDataString := ds;	end;{-----------------------------------------------------------------------------}	function CLAllValuesString (j: integer): str255;		var			k, numtoshow, theKind: integer;			ds, ds2: str255;			settoshow: set15;	begin		settoshow := SpotBarSetToShow;		numtoshow := NumSpotBar(setToShow);		if not IntervalLegal(j) then			ds := '-'		else if numtoshow > 1 then			begin				ds := '';				for k := 1 to numtoshow do					begin						theKind := GetSpotBarKind(settoshow, k);						ds2 := CLDataString(theKind, j, CWpercent);						if k = 1 then							ds := ds2						else if (CWChart = CWCSteps) & not sequencechart & not positionchart then							ds := Concat(ds, ', ', ds2)						else							ds := Concat(ds, ' - ', ds2);					end;			end		else			ds := CLDataString(CLkind, j, CWpercent);		CLAllValuesString := ds;	end;{-----------------------------------------------------------------------------}	function CMAllValuesString (isfrom, isto: integer; var ds: str255): str255;		var			j, numtoshow, whichKind: integer;			dshyphen, ds2: str255;			settoshow: set15;			divide: double;	begin		settoshow := SpotBarSetToShow;		numtoshow := NumSpotBar(settoshow);		ds := '';		dshyphen := '';		for j := 1 to numtoshow - 1 do			begin				whichkind := GetSpotBarKind(settoshow, j);				divide := ChangesDivide(whichkind);				if MeanSpotBar(whichkind) or InflatedChanges then					RealToString(1.0 * ChartMatrixData[whichkind]^[isfrom][isto] / divide, ds2, 10000, 3, true){>>>>>>>>>>>>>>>>}				else					NumToString(ChartMatrixData[whichkind]^[isfrom][isto], ds2);				ds := concat(ds, ds2, chr(13));				dshyphen := concat(dshyphen, ds2, '-');			end;		whichkind := GetSpotBarKind(settoshow, numtoshow);		divide := ChangesDivide(whichkind);		if MeanSpotBar(whichkind) or InflatedChanges then			RealToString(1.0 * ChartMatrixData[whichkind]^[isfrom][isto] / divide, ds2, 10000, 3, true){>>>>>>>>>>>>>>>>}		else			NumToString(ChartMatrixData[whichkind]^[isfrom][isto], ds2);		ds := concat(ds, ds2);		dshyphen := concat(dshyphen, ds2);		CMAllValuesString := dshyphen;	end;{-----------------------------------------------------------------------------}	function SpotBarName (theKind: integer; longname: boolean): str255;		var			ds: str255;	begin		if MinMaxOn then			begin				case theKind of					CMminmin, CMmaxmin: 						ds := 'minimum';					CMminmean, CMMaxmean: 						ds := 'average';					CMminmax, CMmaxmax: 						ds := 'maximum';					otherwise						ds := '';				end;				if longname then					ds := concat(ds, ' across trees');				case theKind of					CMminmin, CMminmax, CMminmean: 						ds := concat(ds, ' of minima');					CMmaxmin, CMMaxmean, CMmaxmax: 						ds := concat(ds, ' of maxima');					otherwise						;				end;				if longname then					ds := concat(ds, ' across character reconstructions');{David- recall "character tracings" or "reconstruction of character evolution" used mostly in manual}{Wayne- "reconstruction of character evolution" would be fine, but much too long.  I am not really happy with}{"character tracings".  Perhaps the solution is to use historical pathways more in manual!}{David- The difficulty is that "historical pathways" does not contain the idea of "character"}{The other problem is that some may expect "pathways" to refer to the branching}{lineages, i.e. lineage = the pathway; character = the thing that travels the pathway, }{as opposed to the way we use it, pathways through morphospace.  }{I suspect "character tracing" will be more immediately understood by most people, but}{perhaps it connotes too much the graphical operation, as opposed to the theoretical meaning,}{of the reconstruction.  What about "Character reconstruction"?}			end		else			begin				case theKind of					CMmin: 						ds := 'minimum';					CMstandard: 						ds := 'average';					CMmax: 						ds := 'maximum';					otherwise						ds := ''				end;				if (CWChart = CWCChanges) then					if ChartChangesMode = unambigmode then						ds := concat(ds, ' unambiguous')					else if ChartChangesMode = meanmode then						ds := concat(ds, ' average');				if longname then					if (CWTrees[CWChart] = CWCurrentTree) or MinMaxIrregular then						ds := concat(ds, ' across character reconstructions')					else						ds := concat(ds, ' across trees');			end;		SpotBarName := ds;	end;  {-----------------------------------------------------------------------------}	function StepsChartUnits (toshow: integer; userestriction: boolean): str255;		var			oldState: SignedByte;	begin		case toshow of			CWStepsSteps: 				if allwt1 or CWTraced then					StepsChartUnits := 'Steps'				else					StepsChartUnits := 'Weighted Steps';			CWStepschanges: 				if changesRestricted & userestriction then					begin						LockHandle(CWClassName, oldstate);						StepsChartUnits := CWClassName^^;						ResetHandle(CWClassName, oldstate);					end				else					StepsChartUnits := 'Changes';			CWStepsCI: 				StepsChartUnits := 'CI';			CWStepsRI: 				StepsChartUnits := 'RI';			CWStepsRC: 				StepsChartUnits := 'RC';			otherwise				;		end;	end;{-----------------------------------------------------------------------------}	function CategoryTitle: Str255;		var			ds: str255;	begin		case CWChart of			CWCcst: 				ds := 'Steps';  {DRM CST}			CWCProbSteps: 				ds := 'Steps';			CWCStates: 				ds := CharStateTerm(true, true, false);			CWCSteps: 				if sequencechart then					ds := CharStateTerm(false, true, false)				else if positionchart then					ds := 'Codon Position'				else					ds := StepsChartUnits(CWStepsShow, true);			CWCCTAll: 				ds := 'Treelength';			CWCC2T, CWCC2TF: 				ds := CharStateTerm(false, true, true);			otherwise				;		end;		CategoryTitle := ds;	end;{-----------------------------------------------------------------------------}	procedure SetChartTitleClip;		var			box: rect;	begin		if not (printon or savepicton) then			begin				box := WindowPortRect(chartWindow);				box.right := box.right - scrollwidth - 4;				ClipRect(box);			end;	end;{-----------------------------------------------------------------------------}	procedure AddTrees (var ds: str255);{this simply concats to ds the source of trees used}		var			oldState: SignedByte;	begin		if CWTrees[CWChart] = CWCurrentTree then			if (treename^^ = UnStoredLink) or dirtytree then				ds := concat(ds, 'current tree')			else				begin					LockHandle(treename, oldstate);					ds := concat(ds, 'tree ', treename^^);					ResetHandle(treename, oldstate);				end		else if CWTrees[CWChart] = CWRandomTrees then			begin				case RTKind of					RTResolve: 						ds := concat(ds, 'random resolutions of current tree');					RTpartition: 						ds := concat(ds, 'random partition trees');					RTjoining: 						ds := concat(ds, 'random joining trees');					RTequiprobable: 						ds := concat(ds, 'random equiprobable trees');					otherwise						;				end;			end		else if CWTrees[CWChart] = CWTreeFile then			begin				LockHandle(extratreefilename[1], oldstate);				ds := concat(ds, extratreefilename[1]^^);				ResetHandle(extratreefilename[1], oldstate);			end		else			ds := concat(ds, 'stored trees');	end;{-----------------------------------------------------------------------------}	function ChartTitle: str255;{returns title of chart}		var			ds: str255;	begin		case CWChart of{$IFC DRMCST}			CWCcst: {DRM CST}				ds := 'Steps in All CSTs';{$ENDC}			CWCProbSteps: 				ds := 'Probability of Steps';   			CWCStates: 				begin					ds := concat('Freq. of ', CharStateTerm(true, true, true), ' in Tree');					if CWTraced then						ds := concat(ds, ' for ', AvailCharName(i));				end;			CWCSteps: 				begin					ds := StepsChartUnits(CWStepsShow, false);					if positionchart then						ds := concat(ds, ' in codon positions in ')					else if not CWTraced then						ds := concat(ds, ' in ', CharStateTerm(false, false, true), ' in ')					else						ds := concat(ds, ' in ', AvailCharName(i), ' in ');					AddTrees(ds);				end;			CWCChanges: 				begin					if not CWTraced then						ds := concat('Changes in all ', CharStateTerm(false, false, true), ' in ')					else						ds := concat('Changes in ', AvailCharName(i), ' in ');					AddTrees(ds);				end;			CWCCTAll: 				if (CWTrees[CWChart] = CWRandomTrees) then					ds := 'Lengths of Random Trees'				else if treefile or (CWTrees[CWChart] = CWTreeFile) then					ds := 'Lengths of trees in tree file'				else					ds := 'Lengths of trees in data file';			CWCC2T: 				ds := 'Difference between two trees';			CWCC2TF: 				ds := 'Difference between two tree files';			otherwise				;		end;		ChartTitle := ds;	end;{-----------------------------------------------------------------------------}	function ChartImageTitleHeight: integer;		var			ht: integer;	begin		if ShowChartTitle & (CWView <> infoview) then			begin				ht := FontHeight;				if (CWView = tableview) & (CWChart <> CWCSteps) then					if NumSpotBar(SpotBarSetToShow) > 1 then						ht := ht + FontHeight;				ht := ht + 4;  {little buffer down below}			end		else			ht := 0;		ChartImageTitleHeight := ht;	end;{-----------------------------------------------------------------------------}	procedure DrawChartImageTitle;{this draws the title of the chart above the chart on the image, as opposed to the window title}		var			oldRgn: RgnHandle;			box: rect;			ds: str255;			j, numtoshow: integer;			settoshow: set15;	begin		if showcharttitle & (CWView <> infoview) then			begin				ds := '';				settoshow := SpotBarSetToShow;				numtoshow := NumSpotBar(settoshow);				oldRgn := NewRgn;				GetClip(oldRgn);				if not (printon or savepicton) then					begin						box := WindowPortRect(chartWindow);						box.right := box.right - scrollwidth - 4;						ClipRect(box);					end;				moveto(chartTitleStart.h, chartTitleStart.v + FontHeight);				case CWChart of{$IFC DRMCST}					CWCcst: {DRM CST}						ds := 'Calculated over current tree';{$ENDC}					CWCProbSteps: 						ds := 'Calculated over current tree';					CWCStates: 						begin							ds := 'Calculated over taxa in current tree';						end;					CWCSteps: 						begin							ds := 'Calculated over ';							AddTrees(ds);						end;					CWCChanges: 						begin							if Chartchangesmode = unambigmode then								ds := 'Frequency of unambiguous changes between states in '							else if numtoshow > 1 then								ds := 'Frequency of changes between states in '							else if Chartchangesmode = meanmode then								ds := 'Average frequency of changes between states in '							else if Chartchangesmode = minmaxmode then								ds := 'Minimum and maximum frequencies of changes between states in ';							AddTrees(ds);						end;					CWCCTAll: 						begin							ds := 'Calculated over ';							AddTrees(ds);						end;					CWCC2T: 						ds := 'Differences between two trees';					CWCC2TF: 						ds := 'Minimum differences  between two tree files';					otherwise						;				end;				DrawString(ds);				if (CWView = tableview) & (CWChart <> CWCSteps) & (numtoshow > 1) then					begin						moveto(chartTitleStart.h, chartTitleStart.v + 2 * FontHeight);						DrawString('(');						for j := 1 to numtoshow do							begin								if j > 1 then									DrawString(' - ');								DrawString(SpotBarName(GetSpotBarKind(SetToShow, j), false));							end;						DrawString(')');					end;				ZapRegion(oldRgn);			end;	end;{-----------------------------------------------------------------------------}	procedure ChartMessage (ds: str255);	begin		MoveTo(50, 50);		DrawString(ds);	end;{-----------------------------------------------------------------------------}	procedure SetMaxChangesState;{currently only used in StepsChart and ChangesChart}	begin		if (CWTrees[CWChart] = CWCurrentTree) then			if CWTraced then				maxChangesState := maxReconstructedStatei			else				maxChangesState := maxReconstructedState		else if AnyType([usedef]) then			maxChangesState := MaxStateDefinedAllUseDef(true)   {if other tree, then can't rely on maxReconstructedState}		else			maxChangesState := MOS;	end;{-----------------------------------------------------------------------------}	function MinMaxEnabled: boolean;	begin		MinMaxEnabled := MinMaxOn and (CWView <> infoview);	end;end.