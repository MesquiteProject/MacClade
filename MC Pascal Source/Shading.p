unit Shading;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, TaxonCHUtil, SymbolsNames, Legends, BoxUtil, CharUtil, ColorPicker, Settings, ReadUtil;	procedure FixBrushColor;	function GetPat (inpat: integer; var outpat: integer): boolean;	procedure SetColorKey (ic, nic: integer);	procedure DoPatternsAndColors(overrideExpectedPalette: boolean; overrideDataType: integer);	procedure SmallBranchShades;		var displayedDataType: integer;{еееееееееееееееееееееее}implementation {е$S Shading}	const		patleft = 5;		pattop = 30;		patwidth = 25;		numpats = 32;	var		selB, wholeB, patselB, patwholeB: rect;		selnic, selir, patsel, startleft, starttop, width, gapp: integer;		keyselected, patselected: boolean;		oldT: longint;		displayedNumBytes,displayedMaxState: integer;		displayedMolecular, displayedNucleotides: boolean;{-----------------------------------------------------------------------------}	procedure FixBrushColor;		var			usepat: pattern;			newColor: RGBColor;	begin		if (traceshown = traceDiscrete) & (branchShades[curTrace] <> branchPatterns) then			begin				if branchShades[curTrace] = branchGrayScale then					SetMaxGrayScale;				Findpat(usepat, brushcolor, brushset, i, curTrace);{$R-}				newColor := brushcolor;			end		else			newColor := blackRGB;		if fullbrush.colorH <> nil then			fullbrush.colorH^^.crsrMap^^.pmTable^^.ctTable[1].rgb := newColor;	end;{----------------------------------------------------------------------------}	procedure FrameShade (B: rect);	begin		PenSize(2, 2);		PenMode(patXOR);		FrameRect(B);		PenNormal;	end;{----------------------------------------------------------------------------}	function PatternRect (j: integer): rect;   {j is the pattern numbers}		const			patsinrow = 16;		var			B: rect;	begin		if j < patsinrow then			SetRect(B, patleft + j * (patwidth - 1), pattop, patleft + (j + 1) * (patwidth - 1), pattop + patwidth)		else			SetRect(B, patleft + (j - patsinrow) * (patwidth - 1), pattop + patwidth, patleft + (j - patsinrow + 1) * (patwidth - 1), pattop + 2 * patwidth);		PatternRect := B;	end;{----------------------------------------------------------------------------}	procedure DrawPatterns (theDialog: DialogPtr; itemNo: INTEGER);		var			B: rect;			j: integer;	begin		FrameButton(theDialog, 1);		for j := 0 to numpats - 1 do			begin				B := PatternRect(j);				FillRect(B, pat[j]);				FrameRect(B);			end;		if patselected then			FrameShade(patselB);	end;{----------------------------------------------------------------------------}	function PatternFilter (theDialog: DialogPtr; var Event: EventRecord; var localItemHit: INTEGER): BOOLEAN;		label			1;		var			MouseLoc: Point;			WindoLoc, MyControl: integer;			theChar: char;			B: rect;			j: integer;	begin		MouseLoc := Event.Where;		WindoLoc := FindWindow(MouseLoc, Whichwindow);		PatternFilter := FALSE;		if (Event.what = keyDown) then			if HitReturn(Event) then				begin					localItemHit := PressButton(theDialog, 1);					PatternFilter := true;				end;		if (Event.what = mouseDown) then			begin				GlobalToLocal(Event.where);				if PTINRECT(event.where, patwholeB) then					begin						if patselected then							begin								FrameShade(patselB);								patselected := false;							end;						for j := 0 to numpats - 1 do							begin								B := PatternRect(j);								if PTINRECT(event.where, B) then									begin										patselB := B;										patselected := true;										InsetRect(patselB, -2, -2);										FrameShade(patselB);										patsel := j;										PatternFilter := FALSE;										localItemHit := NotInDialog;										if ((Event.when - oldT) < GetDblTime) then											begin												PatternFilter := TRUE;												localItemHit := 1;											end;										goto 1;									end;							end;						PatternFilter := FALSE;						localItemHit := NotInDialog;1:						oldT := Event.when;					end;				LocaltoGlobal(Event.where);			end;	end;{-----------------------------------------------------------------------------}	function GetPat; {(inpat: integer; var outpat: integer): boolean}		var			theDialog: DialogPtr;			tempH, itemsH: Handle;			box: RECT;			itemtype: integer;			tempP: WindowPtr;			localItemHit: integer;			UserItemUProcP: UniversalProcPtr;			DLOGFilterUPP: UniversalProcPtr;	begin{save old values}		oldT := Event.when;		patselected := true;		StartDLOG(340, theDialog, tempP);		myShowDialog(theDialog);		patsel := inpat;		SetRect(box, 1, 1, 2, 2);		SetRect(patwholeB, 0, pattop, 600, pattop + mnsts * patwidth);		patselB := PatternRect(patsel);		InsetRect(patselB, -2, -2);		UserItemUProcP := MyNewUserItemUPP(@DrawPatterns);  		tempH := Handle(UserItemUProcP);		SetDialogItem(theDialog, 3, UserItem, tempH, box);		DLOGFilterUPP := MyNewModalFilterUPP(@PatternFilter);  		repeat			myModalDialog(DLOGFilterUPP, localItemHit);		until localItemHit in [1, 2];		MyDisposeUserItemUPP(UserItemUProcP);		MyDisposeModalFilterUPP(DLOGFilterUPP);		EndDLOG(theDialog, tempP);		outpat := patsel;		if localItemHit = OK then			GetPat := true		else if localItemHit = 2 then			GetPat := false;	end;{----------------------------------------------------------------------------}	procedure SetColorKey (ic, nic: integer);		var			pos: point;			incolor, outcolor: RGBColor;			inpat, outpat: integer;	begin		if branchShades[curTrace] = branchColors then			begin				pos.v := 45;				pos.h := 110;  {v3.06:  was 40 }				if(treeopen & (traceshown=traceAllChanges)) then					incolor := summarycolors^[ic]				else if displayedDataType=protein then					incolor := proteinColorKey^[ic]				else if displayedNucleotides then					incolor := nucleotideColorKey^[ic]				else					incolor := colorkey^[nic, ic];				if GetColor(pos, 'select color', incolor, outcolor) then					if(treeopen & (traceshown=traceAllChanges)) then						summarycolors^[ic] := outcolor					else if displayedDataType=protein then						proteinColorKey^[ic] := outcolor					else if displayedNucleotides then						nucleotideColorKey^[ic] := outcolor					else						colorkey^[nic, ic] := outcolor;			end		else			begin				if(treeopen & (traceshown=traceAllChanges)) then					inpat := summarypat^[ic]				else					inpat := patkey^[nic, ic];				if GetPat(inpat, outpat) then					if(treeopen & (traceshown=traceAllChanges)) then						summarypat^[ic] := outpat					else						patkey^[nic, ic] := outpat;			end;		FlushEvents(mdownmask + keydownmask, 0);	end;{----------------------------------------------------------------------------}	function ShadingRect (numstates, thestate: integer): rect;		var			B: rect;	begin		SetRect(B, startleft + numstates * (width + gapp), starttop + thestate * (width - 1), startleft + width + numstates * (width + gapp), starttop + width + thestate * (width - 1));		ShadingRect := B;	end;{----------------------------------------------------------------------------}	procedure DrawColorRect (numstates, thestate: integer);		var			B: rect;	begin		B := ShadingRect(numstates, thestate);		FillRect(B, QDBlack);		RGBForeColor(blackRGB);		FrameRect(B);	end;{----------------------------------------------------------------------------}	procedure DrawPatternRect (numstates, thestate, patnumber: integer);		var			B: rect;	begin		B := ShadingRect(numstates, thestate);		FillRect(B, pat[patnumber]);		FrameRect(B);	end;{----------------------------------------------------------------------------}	procedure DrawShading (theDialog: DialogPtr; itemNo: INTEGER);		var			B: rect;			nic, ir, lf, dn: integer;	begin		if (displayedNumBytes = 4) & not(treeopen & (traceshown=traceAllChanges)) then			begin				TextFont(kFontIDGeneva);				TextSize(9);			end;		if (displayedNumBytes = 4) & not(treeopen & (traceshown=traceAllChanges)) then {and (displayedDataType <> protein)}			begin				lf := 6;				dn := 12;			end		else			begin				lf := 12;				dn := 16;			end;		FrameButton(theDialog, 1);		if treeopen & (traceshown = traceAllChanges) then			for ir := 0 to maxchangesshown do				begin					if branchShades[curTrace] = branchColors then						begin							RGBForeColor(summarycolors^[ir]);							DrawColorRect(2, ir);						end					else if branchShades[curTrace] = branchGrayScale then						begin							RGBForeColor(GrayScale(maxchangesshown, ir));							DrawColorRect(2, ir);						end					else						DrawPatternRect(2, ir, summarypat^[ir]);					B := ShadingRect(2, ir);					moveto(B.left - 10, B.bottom - 4);					DrawChar(chr(ir + 48));				end		else			begin				if displayedDataType in [standard, standard32] then					begin						moveto(startleft + (width + gapp) + lf, starttop + (width - 4));						DrawChar(CharOfNum(0));						moveto(startleft + (width + gapp) + lf, starttop + width + (width - 4));						DrawChar(CharOfNum(1));						for nic := 2 to maxstbit + 1 do							begin								for ir := 0 to nic - 1 do									if branchShades[curTrace] = branchColors then										begin											RGBForeColor(GetStateColor(nic, ir));											DrawColorRect(nic, ir);										end									else if branchShades[curTrace] = branchGrayScale then										begin											RGBForeColor(GrayScale(nic - 1, ir));											DrawColorRect(nic, ir);										end									else										DrawPatternRect(nic, ir, patkey^[nic, ir]);								if nic < maxstbit + 1 then									begin										B := ShadingRect(nic, nic - 1);										moveto(B.left + lf, B.bottom + dn);										drawchar(charofnum(nic));									end;							end;					end				else if displayedMolecular then					for ir := 0 to displayedMaxState do						begin							if branchShades[curTrace] = branchColors then								begin									if displayedDataType=protein then										RGBForeColor(proteinColorKey^[ir])									else										RGBForeColor(GetStateColor(displayedMaxState, ir));									DrawColorRect(2, ir);								end							else if branchShades[curTrace] = branchGrayScale then								begin									RGBForeColor(GrayScale(displayedMaxState, ir));									DrawColorRect(2, ir);								end							else								DrawPatternRect(2, ir, patkey^[displayedMaxState + 1, ir]);							moveto(startleft + (width + gapp) + lf, starttop + ir * (width - 1) + (width - 4));							if displayedDataType = protein then								begin									DrawChar(ProtCharOfNum(ir));									moveto(startleft + (3 * width + gapp + 3) + lf, starttop + ir * (width - 1) + (width - 4));									DrawString(CharStateName(1, ir));		{doesn't matter what character we pass}								end							else								DrawChar(CharOfNum(ir));						end;			end;		if keyselected then			FrameShade(selB);		TextFont(0);		TextSize(12);	end;{----------------------------------------------------------------------------}	function BranchFilter (theDialog: DialogPtr; var Event: EventRecord; var localItemHit: INTEGER): BOOLEAN;		label			1;		var			MouseLoc: Point;			WindoLoc, MyControl: integer;			nic, ir: integer;			B: rect;	begin		MouseLoc := Event.Where;		WindoLoc := FindWindow(MouseLoc, Whichwindow);		BranchFilter := FALSE;		if (Event.what = keyDown) then			if HitReturn(Event) then				begin					localItemHit := PressButton(theDialog, 1);					BranchFilter := true;				end;		if (Event.what = mouseDown) then			begin				GlobalToLocal(Event.where);				if PTINRECT(event.where, wholeB) and (branchShades[curTrace] <> branchGrayScale) then					begin						if keyselected then							begin								FrameShade(selB);								keyselected := false;							end;						if(treeopen & (traceshown=traceAllChanges)) then							begin								for ir := 0 to maxchangesshown do									begin										B := ShadingRect(2, ir);										if PTINRECT(event.where, B) then											begin												selB := B;												keyselected := true;												InsetRect(selB, -2, -2);												FrameShade(selB);												if ((Event.when - oldT) < GetDblTime) and (selir = ir) then													begin														SetColorKey(selir, selnic);														EraseRect(wholeB);														InvalidateWindowRect(myGetWindowPtrForDialog(theDialog),wholeB,false);													end;												selir := ir;												goto 1;											end;									end							end						else if displayedMolecular then							for ir := 0 to displayedMaxState do								begin									B := ShadingRect(2, ir);									if PTINRECT(event.where, B) then										begin											selB := B;											keyselected := true;											InsetRect(selB, -2, -2);											FrameShade(selB);											if ((Event.when - oldT) < GetDblTime) and (selnic = displayedMaxState + 1) and (selir = ir) then												begin													SetColorKey(selir, selnic);													EraseRect(wholeB);													InvalidateWindowRect(myGetWindowPtrForDialog(theDialog),wholeB,false);												end;											selnic := displayedMaxState + 1;											selir := ir;											goto 1;										end;								end						else if (displayedDataType in [standard, standard32]) then							for nic := 2 to maxstbit + 1 do								for ir := 0 to nic - 1 do									begin										B := ShadingRect(nic, ir);										if PTINRECT(event.where, B) then											begin												selB := B;												keyselected := true;												InsetRect(selB, -2, -2);												FrameShade(selB);												if ((Event.when - oldT) < GetDblTime) and (selnic = nic) and (selir = ir) then													begin														SetColorKey(selir, selnic);														EraseRect(wholeB);														InvalidateWindowRect(myGetWindowPtrForDialog(theDialog),wholeB,false);													end;												selnic := nic;												selir := ir;												goto 1;											end;									end;1:						oldT := Event.when;						EnableDisableDLOGItem(theDialog, 3, keyselected and (branchShades[curTrace] <> branchGrayScale), false);					end;				BranchFilter := FALSE;				localItemHit := NotInDialog;				LocaltoGlobal(Event.where);			end;	end;{-----------------------------------------------------------------------------}	procedure SetNucleotideColorsToSequencherOld (theDialog: DialogPtr);	begin  		nucleotideColorKey^[0].red := 0;  {0/128/17}		nucleotideColorKey^[0].green := 32767;		nucleotideColorKey^[0].blue := 4369;		nucleotideColorKey^[1].red := 0;  {0/0//212}		nucleotideColorKey^[1].green := 0;		nucleotideColorKey^[1].blue := 54484;		nucleotideColorKey^[2].red := 65535;		nucleotideColorKey^[2].green := 65535;		nucleotideColorKey^[2].blue := 65535;		nucleotideColorKey^[3].red := 56797;  {221/8/6}		nucleotideColorKey^[3].green := 2056;		nucleotideColorKey^[3].blue := 1542;		EraseRect(wholeB);		InvalidateWindowRect(myGetWindowPtrForDialog(theDialog),wholeB,false);	end;{-----------------------------------------------------------------------------}{These are more in line with Chromaseq colors}	procedure SetNucleotideColorsToSequencher (theDialog: DialogPtr);	begin  		nucleotideColorKey^[0].red := 0;  {0/128/17}		nucleotideColorKey^[0].green := 65535;		nucleotideColorKey^[0].blue := 0;		nucleotideColorKey^[1].red := 0;  {0/0//212}		nucleotideColorKey^[1].green := 0;		nucleotideColorKey^[1].blue := 65535;		nucleotideColorKey^[2].red := 65535;		nucleotideColorKey^[2].green := 65535;		nucleotideColorKey^[2].blue := 65535;		nucleotideColorKey^[3].red := 65535;  {221/8/6}		nucleotideColorKey^[3].green := 0;		nucleotideColorKey^[3].blue := 0;		EraseRect(wholeB);		InvalidateWindowRect(myGetWindowPtrForDialog(theDialog),wholeB,false);	end;{-----------------------------------------------------------------------------}	procedure SetColorKeyToDNA (theDialog: DialogPtr);	var nic, ic, maxNuc: integer;	begin  		for nic := 2 to maxstbit + 1 do			begin				maxNuc := 3;				if nic < maxNuc then maxNuc := nic;				for ic := 0 to maxNuc do					colorkey^[nic, ic] := nucleotideColorKey^[ic];			end;		EraseRect(wholeB);		InvalidateWindowRect(myGetWindowPtrForDialog(theDialog),wholeB,false);	end;{-----------------------------------------------------------------------------}	procedure DoPatternsAndColors(overrideExpectedPalette: boolean; overrideDataType: integer);		var			oldVRefNum: integer;			oldDirID: longint;			theDialog: DialogPtr;			tempH, itemsH, colorH: Handle;			box: RECT;			itemtype, refNum: integer;			tempP: WindowPtr;			curvol: integer;			oldSameForAll , oldUseMOS : boolean;			usepat: pattern;			t: restype;			savefullcolor, doRevert: integer;			tbranchShades: tracetype;			success, fromMC: boolean;			oldcurTrace: integer;			tcolorkey: colorKeyPtr;			tpatkey: PatKeyPtr;			tsummarycolors: sumcolorPtr;			tsummarypat: sumPatPtr;			tnucleotidecolorkey : NucleotideColorKeyPtr;			tproteincolorkey : ProteinColorKeyPtr;			localItemHit: integer;			UserItemUProcP: UniversalProcPtr;			DLOGFilterUPP: UniversalProcPtr;{...........}		procedure CheckShadings;		begin			if treeopen then				begin					ItemCheckMark(theDialog, 10, branchShades[curTrace] = branchGrayScale);					ItemCheckMark(theDialog, 5, branchShades[curTrace] = branchColors);					ItemCheckMark(theDialog, 4, branchShades[curTrace] = branchPatterns);				end;			if not displayedMolecular then				begin					ItemCheckMark(theDialog, 11, sameStateColorsForAllCharacters);					ItemCheckMark(theDialog, 12, useMOSForSameColorsForAll);					EnableDisableDLOGItem (theDialog,12,sameStateColorsForAllCharacters,false);					EnableDisableDLOGItem (theDialog,13, not treeopen | (branchShades[curTrace] = branchColors),false);				end;		end;{...........}	begin		if overrideExpectedPalette then			begin				displayedDatatype :=protein;				displayedNumBytes := 4;				displayedMaxState := maxAAstate;				displayedMolecular := true;				displayedNucleotides := false;			end		else			begin				displayedDatatype :=datatype;				displayedNumBytes := numBytes;				displayedMaxState := maxState;				displayedMolecular := molecular;				displayedNucleotides := nucleotides;			end;					oldcurTrace := curTrace;		if treeopen then			Paramtext('and Patterns','','','')		else			Paramtext('','','','');		if not treeopen then 			curTrace := traceCellColors 		else if nex7on & (curTrace = tracenothing) then			curTrace := traceDiscrete;		width := 20;		gapp := 5;		tcolorkey := ColorKeyPtr(NewPtr(SizeOf(colorkeytype)));		tnucleotidecolorkey := NucleotideColorKeyPtr(NewPtr(SizeOf(NucleotideColorKeyType)));		tproteincolorkey := ProteinColorKeyPtr(NewPtr(SizeOf(ProteinColorKeyRecord)));		tpatkey := PatKeyPtr(NewPtr(SizeOf(patkeytype)));		tsummarycolors := sumColorPtr(NewPtr(SizeOf(sumcolortype)));		tsummarypat := sumPatPtr(NewPtr(SizeOf(sumpattype)));		tcolorkey^ := colorkey^;		tnucleotidecolorkey^ := nucleotidecolorkey^;		tproteincolorkey^ := proteincolorkey^;		tpatkey^ := patkey^;		tsummarycolors^ := summarycolors^;		tsummarypat^ := summarypat^;		oldSameForAll := sameStateColorsForAllCharacters;		oldUseMOS := useMOSForSameColorsForAll;		oldtime := Event.when;		tbranchShades := branchShades;		keyselected := false;{$IFC FALSE}		if colorQDexists then			begin				SetRect(box, 77, 64, 487, 346);				itemsH := GetResource('DITL', 329);				if ResError <> noErr then					oops('didnt read it in');			end;{$ENDC}		if treeopen & (traceshown = traceAllChanges) then			begin				startleft := 20;				starttop := 50;				StartDLOG(400, theDialog, tempP);				SetRect(wholeB, startleft, starttop, startleft + width + 2 * (width + gapp), starttop + width + maxchangesshown * (width - 1));			end		else if displayedDataType = protein then			begin				startleft := 64;				starttop := 34;				StartDLOG(564, theDialog, tempP);				width := 12;				SetRect(wholeB, startleft, starttop, startleft + width + 2 * (width + gapp), starttop + width + displayedMaxState * (width - 1));			end		else if displayedNucleotides then			begin				startleft := 50;				starttop := 70;				StartDLOG(5143, theDialog, tempP);				SetRect(wholeB, startleft, starttop, startleft + width + 2 * (width + gapp), starttop + width + displayedMaxState * (width - 1));			end		else if displayedNumBytes = 4 then			begin				startleft := -10;				starttop := 30;				StartDLOG(562, theDialog, tempP);				width := 10;				gapp := 4;				SetRect(wholeB, startleft, starttop, startleft + width + (maxstbit + 1) * (width + gapp), starttop + width + maxstbit * (width - 1));			end		else			begin				startleft := 0;				starttop := 40;				StartDLOG(329, theDialog, tempP);				SetRect(wholeB, startleft, starttop, startleft + width + (maxstbit + 1) * (width + gapp), starttop + width + maxstbit * (width - 1));			end;					if not treeopen then			begin				HideDialogItem(theDialog,4);				HideDialogItem(theDialog,5);				HideDialogItem(theDialog,10);			end;				myShowDialog(theDialog);				SetRect(box, 1, 1, 2, 2);UserItemUProcP := MyNewUserItemUPP(@DrawShading);  tempH := Handle(UserItemUProcP);		SetDialogItem(theDialog, 6, UserItem, tempH, box);		if not ScreenInColor then			begin				if treeopen then 					EnableDisableDLOGItem(theDialog, 5, false, false);				EnableDisableDLOGItem(theDialog, 10, false, false);			end;		CheckShadings;		EnableDisableDLOGItem(theDialog, 3, false, false);		DLOGFilterUPP := MyNewModalFilterUPP(@BranchFilter);  		repeat			myModalDialog(DLOGFilterUPP, localItemHit);			case localItemHit of				3:   {change}					begin						if keyselected then							SetColorKey(selir, selnic);						EraseRect(wholeB);						InvalidateWindowRect(myGetWindowPtrForDialog(theDialog),wholeB,false);					end;				4: 					if branchShades[curTrace] <> branchPatterns then						begin							branchShades[curTrace] := branchPatterns;							if keyselected then								FrameShade(selB);							DrawDialog(theDialog);						end;				5: 					if branchShades[curTrace] <> branchColors then						begin							if keyselected then								FrameShade(selB);							branchShades[curTrace] := branchColors;							DrawDialog(theDialog);						end;				10: 					if branchShades[curTrace] <> branchGrayScale then						begin							branchShades[curTrace] := branchGrayScale;							if keyselected then								FrameShade(selB);							keyselected := false;							EnableDisableDLOGItem(theDialog, 3, false, false);							DrawDialog(theDialog);						end;				11: 					begin						if displayedNucleotides then							SetNucleotideColorsToSequencher(theDialog)						else							sameStateColorsForAllCharacters:= not sameStateColorsForAllCharacters;					end;				12: 					begin						useMOSForSameColorsForAll:= not useMOSForSameColorsForAll;					end;				13: 					begin						SetColorKeyToDNA(theDialog);						sameStateColorsForAllCharacters := true;					end;				8: 					begin						doRevert := DoAlert(138, noteA);						if doRevert <> 1 then							begin								fromMC := doRevert = 3;								if fromMC then									begin										if(treeopen & (traceshown=traceAllChanges)) then											if branchShades[curTrace] = branchColors then												SetPreferenceValues(nil,sumcolorid, preferencesFactory,true)											else												SetPreferenceValues(nil,sumpatid, preferencesFactory,true)										else if branchShades[curTrace] = branchColors then											begin												if displayedDataType=protein then													SetPreferenceValues(nil,proteinColorsid, preferencesFactory,true)												else if displayedNucleotides then													SetPreferenceValues(nil,nucleotideColorsid, preferencesFactory,true)												else													SetPreferenceValues(nil,colorkeyid, preferencesFactory,true);											end										else											SetPreferenceValues(nil,patkeyid, preferencesFactory,true);									end								else									begin										if(treeopen & (traceshown=traceAllChanges)) then											if branchShades[curTrace] = branchColors then												SetPreferenceValues(GetSettingsPtrFromID(programSettings,sumcolorid),0, preferencesRead,true)											else												SetPreferenceValues(GetSettingsPtrFromID(programSettings,sumpatid),0, preferencesRead,true)										else if branchShades[curTrace] = branchColors then											begin												if displayedDataType=protein then													SetPreferenceValues(GetSettingsPtrFromID(programSettings,proteinColorsid),0, preferencesRead,true)												else if displayedNucleotides then													SetPreferenceValues(GetSettingsPtrFromID(programSettings,nucleotideColorsid),0, preferencesRead,true)												else													SetPreferenceValues(GetSettingsPtrFromID(programSettings,colorkeyid),0, preferencesRead,true);											end										else											SetPreferenceValues(GetSettingsPtrFromID(programSettings,patkeyid),0, preferencesRead,true);									end;								currentioposition := 121;								EraseRect(wholeB);								InvalidateWindowRect(myGetWindowPtrForDialog(theDialog),wholeB,false);							end;					end;				9: 					begin						if ScreenInColor & treeopen then							begin								if(treeopen & (traceshown=traceAllChanges)) then									savefullcolor := TraceChangesColorid								else if (traceshown = traceDiscrete) then									savefullcolor := TraceCharColorid								else if (traceshown = traceContinuous) then									savefullcolor := TraceContsColorid;							end						else							savefullcolor := 0;						if (traceshown = traceAllChanges) & treeopen then							begin								if branchShades[curTrace] = branchColors then									SetDialogValuesAsDefaults(theDialog, sumcolorid, savefullcolor, 0)								else									SetDialogValuesAsDefaults(theDialog, sumpatid, savefullcolor, 0);							end						else if (traceshown = traceContinuous) & treeopen then  {but note continuous doesn't use this dialog}							SetDialogValuesAsDefaults(theDialog, savefullcolor, 0, 0)						else if branchShades[curTrace] = branchColors then							begin								if displayedDataType=protein then									SetDialogValuesAsDefaults(theDialog, proteinColorsID, 0, 0)								else if displayedNucleotides then									SetDialogValuesAsDefaults(theDialog, nucleotideColorsID, 0, 0)								else									SetDialogValuesAsDefaults(theDialog, colorkeyid, savefullcolor, colorOptionsID);							end						else							SetDialogValuesAsDefaults(theDialog, patkeyid, savefullcolor, 0);					end;				otherwise					;			end;			CheckShadings;		until localItemHit in [1, 2];		MyDisposeUserItemUPP(UserItemUProcP);		MyDisposeModalFilterUPP(DLOGFilterUPP);		EndDLOG(theDialog, tempP);		if localItemHit = OK then			begin				userBranchShades[curTrace] := branchShades[curTrace];				if treeopen and ((traceshown = traceDiscrete) or nex7on or (traceshown = traceAllChanges)) then					begin						godraw := true;						if (traceshown = traceDiscrete) or (traceshown = traceAllChanges) then							InvalidateWindow(chlegwindow, false);						if (traceshown = traceDiscrete) and (currentTool[treeTools] = paintT) then							FixBrushColor;					end				else if editorOpen & EditorCellsColoredByState then					begin						InvalidateWindow(editorWindow,true);					end;			end		else if localItemHit = 2 then			begin				branchShades := tbranchShades;				colorkey^ := tcolorkey^;				nucleotidecolorkey^ := tnucleotidecolorkey^;				proteincolorkey^ := tproteincolorkey^;				patkey^ := tpatkey^;				summarycolors^ := tsummarycolors^;				summarypat^ := tsummarypat^;				sameStateColorsForAllCharacters := oldSameForAll;				useMOSForSameColorsForAll := oldUseMOS;			end;		ZapPointer(tcolorkey);		ZapPointer(tnucleotidecolorkey);		ZapPointer(tproteincolorkey);		ZapPointer(tpatkey);		ZapPointer(tsummarycolors);		ZapPointer(tsummarypat);		curTrace := oldCurTrace;	end;{-----------------------------------------------------------------------------}	procedure SmallBranchShades;		var			theDialog: DialogPtr;			oldBranchShades: tracetype;			tempP: WindowPtr;			localItemHit: integer;			oldCurTrace: integer;{............}		procedure CheckSmallBranchShades;		begin			ItemCheckMark(theDialog, 3, branchShades[curTrace] = branchPatterns);			ItemCheckMark(theDialog, 4, branchShades[curTrace] = branchColors);			ItemCheckMark(theDialog, 5, branchShades[curTrace] = branchGrayScale);		end;{............}	begin		oldcurTrace := curTrace;		if nex7on & (curTrace = tracenothing) then			curTrace := traceDiscrete;		oldBranchShades := branchShades;		StartDLOG(129, theDialog, tempP);		if not ScreenInColor then			begin				branchShades[curTrace] := branchPatterns;				EnableDisableDLOGItem(theDialog, 4, false, false);				EnableDisableDLOGItem(theDialog, 5, false, false);			end;		CheckSmallBranchShades;		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			if localItemHit = 3 then				branchShades[curTrace] := branchPatterns			else if localItemHit = 4 then				branchShades[curTrace] := branchColors			else if localItemHit = 5 then				branchShades[curTrace] := branchGrayScale			else if localitemhit = 7 then				if ScreenInColor then					SetDialogValuesAsDefaults(theDialog, TraceContsColorid, 0, 0);			CheckSmallBranchShades;		until localItemHit in [1, 2];		if localItemHit = 2 then			branchShades := oldbranchShades		else			begin				userBranchShades[curTrace] := branchShades[curTrace];				if branchShades[curTrace] <> oldbranchShades[curTrace] then					begin						InvalidateWindow(treewindow, false);						InvalidateWindow(chlegwindow, true);					end;			end;		EndDLOG(theDialog, tempP);		curTrace := oldCurTrace;	end;end.