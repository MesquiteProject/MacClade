unit MPR;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  UtilLibInterface, SetLibInterface,   		MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, 		BoxUtil, TaxonCHUtil, CharUtil, TreeUtil, TypeUtil, Dollo, Prohibitions, 		MenuUtil, Polycalc, CalcUtil, Calc, Count,		Genchar, fp;	procedure savests (N: Nptr; ic: integer; traced: boolean);	function TripleCombEquiv (s1, s2, s3: lgsetchars; ctype: integer): lgsetchars;	function TerminalUnordEquiv (N: Nptr; ic: integer; ancSet: lgsetChars): lgsetchars;	function TerminalOrdEquiv (Nset1, Nancset2: lgsetchars): lgsetchars;	function GenTripleCombEquiv (dn: gentype; origset: lgsetchars; ancstate, ctype: integer): lgsetchars;	function MoreMPRsThanMaxLongint (N: Nptr; ic: integer; traced: boolean): boolean;	function NumberOfResolutions (N: Nptr; ic: integer; traced: boolean; var useDouble: boolean; var res: double): longint;	function CalcDescendentPolymStates(N: Nptr; ancState, ic, ctyp: integer): lgsetChars;	procedure CalcMinMaxMPRStorage(ancState: integer; minValueForDescendentState,maxValueForDescendentState: GenType; tsts: lgsetChars; var minValue, maxValue: longint; doRestrict: boolean);	function OriginalNodeAssignment(N: Nptr; ancState, ic: integer): lgsetchars;	procedure PrepareForMPRRecursion(ic: integer; traced: boolean; var ctyp: integer);	procedure NumMPRs(ic: integer; var numResD: double);	function SingleMPR(ic: integer; traced,alreadyPrepared: boolean): boolean;	function MPRTotalAbove(MPRFreq: genRealTypePtr; MPRSet: lgSetChars; max: integer): double;{еееееееееееееееееееееее}implementation {е$S Equivocal}{-----------------------------------------------------------------------------}	procedure savests (N: Nptr; ic: integer; traced: boolean);{FROZEN 3.0}{stores in original the final state set since this will be used in calculations and final will be modified for screen display}{under current tangled system}	begin		if traced then			begin				N^.original := NewSetFromOld(N^.final);				N^.dnequiv := NewSetFromOld(N^.down); {useless but harmless if user-defined}			end		else			begin				N^.original := NewSetFromOld(GetStsLargest(N, ic));				N^.dnequiv := NewSetFromOld(GetDnstLargest(N, ic));{useless but harmless if user-defined}			end;		{			begin				N^.original := NewSetFromOld(CharStatesLargest(ic));				N^.dnequiv := NewSetFromOld(CharStatesLargest(ic));			end;}		if NodeIsInternal(N) then			begin				savests(N^.lf, ic, traced);				savests(N^.rt, ic, traced);			end;	end;{-----------------------------------------------------------------------------}	procedure PrepareForMPRRecursion(ic: integer; traced: boolean; var ctyp: integer);	begin		if allowCursorChange then SetCursor(clockCursor);		ctyp := typeofchar(ic);		if ctyp>= usedef then  {need to call downpass to restore gdnsts needed for equiv cycling}			begin				typehdl := getTypeHdl(ctyp);				ddist := TypeHdl^^.dist; {getting type matrix}				GenDownPass(R, ic, traced);			end;		savests(R, ic, traced);	end;{-----------------------------------------------------------------------------}{-----------------------------------------------------------------------------}	function TripleCombEquiv (s1, s2, s3: lgsetchars; ctype: integer): lgsetchars;{FROZEN 3.0}{combines state sets s1 , s2 , s3 into final state set;    }{designed specifically for equivocal cycling.}{For unordered, ordered, irreversible characters}{Compare to TripleCombineCore in CalcUtil.}{Note that s3 is not upstate but final resolved state at node below.  Normal triple combine calculations can be done}{however since state fixed below is as good a upst.}		var			rset: lgsetchars;	begin		rset := Intersect3(s1, s2, s3);		case ctype of			unordered: 				if rset = nil then					begin						rset := Un3ofInt2(s1, s2, s3);						if rset = nil then							rset := Union3(s1, s2, s3);					end;			ordered: 				if rset = nil then					rset := NewSetFromOld(TripleOrdOpLargest(OldSetFromNew(s1), OldSetFromNew(s2), OldSetFromNew(s3)));			otherwise {only irrev since Dollo, u-d done elsewhere; fisher not done}				begin					if MinG(s1) > MinG(s2) then  {see TripleIrrevOplargest in CalcUtil}						begin							if minG(s3) <= minG(s1) then  {asked because of problems with fixing uncertain regions to higher state}								rset := Union2(rset, Intersect2(s2, MakeSpan(MinG(s3), MinG(s1)))) {recall Makespan asumes first less than second; since s3 is anc is save}						end					else						begin							if minG(s3) <= minG(s2) then								rset := Union2(rset, Intersect2(s1, MakeSpan(MinG(s3), MinG(s2))));						end;	{triple intersection done above}				end;		end;		TripleCombEquiv := rset;	end;{-----------------------------------------------------------------------------}	function TerminalUnordEquiv (N: Nptr; ic: integer; ancSet: lgsetChars): lgsetchars;{FROZEN 3.0}{for multistate terminal taxa, unordered chars, considers state resolved}{below to assign new state set to terminal}	begin  										{borrowed from TerminalFilterCore}		if (OldSetFromNew(ancSet) <= OldSetFromNew(N^.dnequiv)) | (MSl in GetTaxonStsLargest(N^.name, ic)) then			TerminalUnordEquiv := ancSet  {use below if a subset}		else  {if there are any states below not in taxonsts, any in taxonsts allowed}			if UCl in GetTaxonStsLargest(N^.name, ic) then				TerminalUnordEquiv := N^.dnequiv			else				TerminalUnordEquiv := (Union2(N^.dnequiv, ancSet));	end;{-----------------------------------------------------------------------------}	function TerminalOrdEquiv (Nset1, Nancset2: lgsetchars): lgsetchars;{FROZEN 3.0}{For terminal taxa with multiple states in an ordered/irrev/dollo character,}{resolves state to that closest to state at ancestor}		var			Nset2: lgsetchars;	begin		if Intersect2(Nset1, Nancset2) <> nil then			Nset2 := Nancset2 {overlap, thus use overlap=ancestor's state since ancestor has only one state}		else			begin {no overlap, thus use state closest to ancestor's}				if MinG(Nset1) > MinG(Nancset2) then					Nset2 := SetfromMin(Nset1)				else					Nset2 := MakeSet(MaxG(Nset1));				if Nset2 = nil then					NewError(75, 0);			end;		TerminalOrdEquiv := Nset2;	end;{-----------------------------------------------------------------------------}	function GenTripleCombEquiv (dn: gentype; origset: lgsetchars; ancstate, ctype: integer): lgsetchars;{FROZEN 3.0}{For user-defined type, finds most parsimonious states given preference from above (costs for each state at node are stored in dn)}{state assigned to ancestor (ancstate), and original states at the node - that is, the states in the MPR set.  This can be used either for}{internal nodes (since dN summarizes preference from both left and right descendants) or for}{terminal nodes (since dN summarizes cost of basal state at node).}		var			iq, maxdef: integer;			stepsforstate, mint: longint;			rset: lgsetchars;	begin		maxdef := MaxStateDefined(ctype);		rset := nil;		mint := infinity;		for iq := 0 to maxdef do			if EnSet(iq, origset) then  {only checks states in original state set}				begin					stepsforstate := AddGenDist(ddist[ancstate, iq], dN[iq]);					if stepsforstate <> infinity then						begin							if (mint = infinity) or (stepsforstate < mint) then   {check if lowest so far}								begin									rset := MakeSet(iq);        {lowest so far found}									mint := stepsforstate;								end							else if stepsforstate = mint then								rset := AddToSet(rset, iq); {as low as others found}						end;				end;		GenTripleCombEquiv := rset;	end;{-----------------------------------------------------------------------------}	function MoreMPRsThanMaxLongint (N: Nptr; ic: integer; traced: boolean): boolean;	var 	dL: longint;		useDouble: boolean;		res: Double;	begin		dL := NumberOfResolutions(screenR, ic, true, useDouble,res);		MoreMPRsThanMaxLongint := useDouble;	end;{-----------------------------------------------------------------------------}	procedure CalcMinMaxMPRStorage(ancState: integer; minValueForDescendentState,maxValueForDescendentState: GenType; tsts: lgsetChars; var minValue, maxValue: longint; doRestrict: boolean);{for the node N, if ancState is the state of its ancestor, then tsts is its state set.  in minValue will be stored the minimum number of changes, maxValue the maximum number.  the value of these are set entirely within this procedure}	var descendantState : integer;	begin		minValue := maxlongint;		maxValue := 0;		for descendantState := 0 to maxstate do			if EnSet(descendantState, tsts) then   {state descendantState is present in the MPR set for the node}				begin					if (ancState=descendantState) then  {in this case, the ancestral state is the same as that currently being considered in the MPR set}						begin							if (minValue>minValueForDescendentState[descendantState]) then								minValue:=minValueForDescendentState[descendantState];  {store minimum value}						end					else if (not doRestrict | (not changesRestricted | (changesSel^[ancState, descendantState]))) & (minValue>=minValueForDescendentState[descendantState] + 1) then  {the ancestral state is not in the MPR set}						minValue:=minValueForDescendentState[descendantState] + 1  {store minimum value}					else if doRestrict & (minValue>minValueForDescendentState[descendantState]) then    {even if it doesn't count, we need to carry the measurements down}						minValue:=minValueForDescendentState[descendantState]; {store minimum value}					if (ancState=descendantState) then						begin 							if (maxValue<maxValueForDescendentState[descendantState]) then								maxValue:=maxValueForDescendentState[descendantState];  {store maximum value}						end					else  if (not doRestrict | (not changesRestricted | (changesSel^[ancState, descendantState]))) & (maxValue<=maxValueForDescendentState[descendantState] + 1) then						maxValue:=maxValueForDescendentState[descendantState] + 1  {store maximum value}					else  if doRestrict & (maxValue<maxValueForDescendentState[descendantState]) then  {even if it doesn't count, we need to carry the measurements down}						maxValue:=maxValueForDescendentState[descendantState];  {store maximum value}				end;		if minValue = maxlongint then			begin				minValue := 0;				maxValue := 0;			end;	end;{-----------------------------------------------------------------------------}	function OriginalNodeAssignment(N: Nptr; ancState, ic: integer): lgsetchars;	{this finds the original node value for a particular node}	{this might never be used for terminal nodes, actually}	begin		if NodeIsTerminal(N) then			begin				if QTaxon(N,ic) then					begin						OriginalNodeAssignment := MakeSet(ancState);						if MakeSet(ancState)<> N^.original then							begin								NewError(444,ic);								//InstantInfo('ancState not same as original - report to David');								//errorflag := true;							end;					end				else					OriginalNodeAssignment := N^.original;			end		else			OriginalNodeAssignment := N^.original;	end;{-----------------------------------------------------------------------------}	function CalcDescendentPolymStates(N: Nptr; ancState, ic, ctyp: integer): lgsetChars;	var tsts: lgsetChars;	begin		if NodeIsTerminal(N) then			begin				if MonomorphG(N^.original) then					tsts := N^.original				else if ctyp = unordered then					tsts := TerminalUnordEquiv(N, ic,MakeSet(ancState))				else if ctyp < usedef then					tsts := TerminalOrdEquiv(N^.original, MakeSet(ancState))				else					tsts := GenTripleCombEquiv(N^.gdnst, N^.original, ancState, ctyp);			end		else if ctyp < dollo then			tsts := TripleCombEquiv(N^.lf^.dnequiv, N^.rt^.dnequiv, NewSetFromOld([ancState]), ctyp)		else if ctyp = dollo then			tsts := NewSetFromOld(FinalCombineDollo(OldSetFromNew(N^.lf^.dnequiv), OldSetFromNew(N^.rt^.dnequiv), OldSetFromNew(N^.dnequiv), [ancState], N = R, ic))		else			tsts := GenTripleCombEquiv(N^.gdnst, N^.original, ancState, ctyp);		CalcDescendentPolymStates := tsts;	end;{-----------------------------------------------------------------------------}	function NumberOfResolutions (N: Nptr; ic: integer; traced: boolean; var useDouble: boolean; var res: double): longint;{DRM method:  uses the same principle as user-defined types}		label 1;		var			ir, ij: longint;			ctyp: integer;			{hiddenDLOG: DialogPtr;}			theDialog: DialogPtr;			tempP: WindowPtr;			tstsLeft, tstsRight,tsts: lgsetchars;			leftRes, rightRes: longint;			leftResDouble, rightResDouble: double;			calculateLongintValue: boolean;{...............................}		procedure NumberResAbove (N: Nptr); 			var				iUp, ik: integer;		begin			if NodeIsInternal(N) then				begin					NumberResAbove(N^.lf);					NumberResAbove(N^.rt);					for ik := 0 to maxstate do						begin							N^.MPR1[ik] := 0;							N^.MPRreal[ik] :=0.0;							if EnSet(ik, N^.original) then								begin									if MonomorphG(N^.original) then										begin											tstsLeft := OriginalNodeAssignment(N^.lf,ik,ic);											tstsRight := OriginalNodeAssignment(N^.rt,ik,ic);										end									else										begin											tstsLeft := CalcDescendentPolymStates(N^.lf, ik, ic, ctyp);											tstsRight := CalcDescendentPolymStates(N^.rt, ik, ic, ctyp);										end;{we now know that if ik is the state at node N, then the left and right descendent states are tstsLeft & tstsRight}																		if calculateLongintValue then										begin											leftRes := 0;											for iUp := 0 to maxstate do												if EnSet(iUp, tstsLeft) then													leftRes := leftRes + N^.lf^.MPR1[iUp];											rightRes := 0;											for iUp := 0 to maxstate do												if EnSet(iUp, tstsRight) then													rightRes := rightRes + N^.rt^.MPR1[iUp];											N^.MPR1[ik] := multaddC(0, leftRes, RightRes);																																	if N^.MPR1[ik] < 0 then												begin													calculateLongintValue := false;													useDouble := true;												end;										end;																			leftResDouble := 0.0;									for iUp := 0 to maxstate do										if EnSet(iUp, tstsLeft) then											leftResDouble := leftResDouble + N^.lf^.MPRreal[iUp];									rightResDouble := 0.0;									for iUp := 0 to maxstate do										if EnSet(iUp, tstsRight) then											rightResDouble := rightResDouble + N^.rt^.MPRreal[iUp];									N^.MPRreal[ik] :=leftResDouble*rightResDouble;									if N=R then 										N^.MPRUp[ik] := leftResDouble;  {note: using the convention that the uppass storage at the root stores 																			the number of resolutions on left side of root; 																			this is used only for Trace All Changes}								end;						end;				end			else				begin					 for ik := 0 to maxstate do						if EnSet(ik, N^.original) then							begin								N^.MPR1[ik] := 1;								N^.MPRreal[ik] := 1.0;							end						else							begin								N^.MPR1[ik] := 0;								N^.MPRreal[ik] := 0.0;							end;				end;		end;{...............................}	begin		calculateLongintValue := true;		useDouble := false;		PrepareForMPRRecursion(ic,traced, ctyp);		NumberResAbove(N);		ir := 0;		res := 0;		for ij := 0 to maxstate do			if EnSet(ij,N^.original) then				begin					ir := ir + N^.MPR1[ij];					res := res + N^.MPRreal[ij];				end;						1:		NumberOfResolutions := ir;	end;{-----------------------------------------------------------------------------}	procedure GoToMPR (N: Nptr; ic: integer; traced: boolean; MPRNumber: longint);{DRM method:  uses the same principle as user-defined types}		var			theState: integer;			ctyp: integer;			{hiddenDLOG: DialogPtr;}			tstsLeft, tstsRight,tsts: lgsetchars;			leftRes, rightRes: longint;			lowerBoundary, upperBoundary,totalMPRs: longint;			targetMPR : longint;			calculateLongintValue: boolean;			useDouble: boolean;			res: double;			startMPRBoundary, endMPRBoundary,totalMPRsAtNode, MPRvalueAtNode: longint;{...............................}		procedure FindResAbove (N: Nptr); 			var				ik: integer;		begin			if NodeIsInternal(N) then				begin					FindResAbove(N^.lf);					FindResAbove(N^.rt);					totalMPRsAtNode := 0;					for ik := 0 to maxstate do						if EnSet(ik, N^.original) then 							totalMPRsAtNode := totalMPRsAtNode + N^.MPR1[ik];					MPRvalueAtNode := TruncateValue(totalMPRsAtNode * (double(1.000*targetMPR)/totalMPRs));					startMPRBoundary := 0;					endMPRBoundary := 0;					theState := -1;					for ik := 0 to maxstate do						if EnSet(ik, N^.original) then 							begin								startMPRBoundary := endMPRBoundary;								endMPRBoundary := endMPRBoundary+N^.MPR1[ik];								if (MPRValueAtNode >=StartMPRBoundary) & (MPRValueAtNode < endMPRBoundary) then									begin										theState := ik;										leave;									end;							end;					if theState >= 0 then						begin						end;				end			else				begin				end;		end;{...............................}	begin		lowerBoundary := 1;		targetMPR := MPRNumber;		totalMPRs := NumberOfResolutions (N,ic,traced,useDouble,res);  {Note: This also sets up ALL the memory!}		upperBoundary := totalMPRs;		PrepareForMPRRecursion(ic,traced, ctyp);		FindResAbove(screenR);	end;{-----------------------------------------------------------------------------}	function MPRTotalAbove(MPRFreq: genRealTypePtr; MPRSet: lgSetChars; max: integer): double;	var 	totalMPRs: double;		nodeState: integer;	begin		totalMPRs := 0.0;		for nodeState := 0 to max do			if EnSet(nodeState,MPRSet) then				totalMPRs := totalMPRs + MPRFreq^[nodeState];   {now we have totalMPRs}		MPRTotalAbove := totalMPRs;	end;{-----------------------------------------------------------------------------}	procedure NumMPRs(ic: integer; var numResD: double);	var useDouble: boolean;		dL: longint;	begin		dL := NumberOfResolutions (R,ic,false,useDouble,numResD);	end;{-----------------------------------------------------------------------------}	function SingleMPR(ic: integer; traced,alreadyPrepared: boolean): boolean;	var ctyp: integer;		oneMPR: boolean;	{.........}		procedure SingleMPRRec(N: Nptr);		begin			if oneMPR then			 	begin					 if NodeIsInternal(N) then						begin							SingleMPRRec(N^.lf);							SingleMPRRec(N^.rt);						end;					if BranchExists(N) then						if not MonomorphG(N^.original) then							oneMPR := false;				end;		end;	{.........}	begin		oneMPR := true;		if not alreadyPrepared then			PrepareForMPRRecursion(ic,traced, ctyp);		SingleMPRRec(R);		SingleMPR := oneMPR;	end;{-----------------------------------------------------------------------------}end.