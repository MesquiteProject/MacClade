unit BranchListWindow;{еееееееееееееееееееееее}interface	uses		QuickDraw, Printing,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, 		ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, WriteUtil, TaxonCHUtil, SymbolsNames, 		CharUtil, TypeUtil, TreeUtil, MenuUtil, SpreadUtil, Activates, PrintingUtil;	procedure DetermineTickClass(N: Nptr; ic: integer; var tickClass, tickBelow,tickAbove, changeClass: integer);	procedure AppendChangeReporttoHandle(H: Handle; N: Nptr; ic: integer);	procedure PrepareCharAndStates(var ds: str255);	function GetCharAndStates (N: Nptr; ffset, ttset: largestsetchars; isroot: boolean; ic: integer; usestatenames: boolean): str255;	function ChangeToShow (N1, N2: Nptr; ic: integer; blm: integer; crossroot: boolean): boolean;	procedure MakeBranchList (N: Nptr; var pg, currentline: longint; lineW, numLines: integer; listDest: integer);	procedure OpenBranchListWindow;	procedure CloseBranchListWindow;	procedure DrawBranchListWindow;	procedure GrowBranchList (width, height: integer);	type		NumStateArray = array[0..absmaxstate] of integer;	procedure CalcNumStateFrequency(N: Nptr; var numStates, maxNumStates: NumStateArray);	procedure DrawNodeListHeading (var currentLine: longint; lineW: integer);	function NodeLengthString (N: Nptr): str255;	procedure DrawNodeInfo (tN: Nptr; nodenum, lineW, numlines: integer; var currentLine, pg: longint);	const		listToWindow = 0;		listPrint = 1;		listFile = 2;	var		BranchList: ListHandle;		firstcharLine: integer;{еееееееееееееееееееееее}implementation {е$S BranchListWindow}{-----------------------------------------------------------------------------}	procedure DetermineTickClass(N: Nptr; ic: integer; var tickClass, tickBelow,tickAbove, changeClass: integer);	var 	nodeStates, ancestralStates, curStates: largestsetchars;		allAncestralStates, allOutsideStates, allInsideStates, allSingletonAncestralStates, allAwayStates: largestsetchars;		nodestate : integer;		found, foundAncestral,inClade, badAbove, badBelow: boolean;		abovePurine,belowPurine,abovePyrimidine,belowPyrimidine, insideNotUniform: boolean;		aN,NAnc: Nptr;{............}	procedure CheckStatesInTree(bN: Nptr);	begin		if (bN<> Nanc) & (bN<>N) & BranchExists(bN) then {it is not the immediate ancestor, it is not the node, and it exists}			begin				if NodeIsTerminal(bN) then					curStates := gettaxonstsLargest(bN^.name,ic)				else					curStates := getstsLargest(bN,ic);				if (curStates<>[MSl,GAl]) & (curStates<>[MSl]) then  {v4.04}					if IsAnc(N, bN) then   {we are inside the clade}						begin							if (allInsideStates <> []) & (allInsideStates<>curStates) then								insideNotUniform := true;							allInsideStates := allInsideStates + curStates;						end					else						allOutsideStates := allOutsideStates + curStates;			end;		if NodeIsInternal(bN) then			begin				CheckStatesInTree(bN^.lf);				CheckStatesInTree(bN^.rt);			end;	end;{............}	begin		changeClass := changeUnknown;		insideNotUniform := false;		tickClass := tickOther;		tickAbove := tickAboveOther;		tickBelow := tickBelowOther;		NAnc:= NotNullAnc(N);		nodeStates := getstslargest(N, ic);		ancestralStates := getstslargest(NAnc, ic);		abovePurine := nodeStates - purine*nodeStates = [];		belowPurine := ancestralStates - purine*ancestralStates = [];		abovePyrimidine := nodeStates - pyrim*nodeStates = [];		belowPyrimidine := ancestralStates - pyrim*ancestralStates = [];				if (abovePurine & belowPyrimidine) | (belowPurine & abovePyrimidine) then			changeClass := changeTransversion		else if (abovePurine & belowPurine) | (belowPyrimidine & abovePyrimidine) then			changeClass := changeTransition;				if  (branchlistmode <> unambigmode) & not ChangeToShow(N, NAnc, ic, unambigmode, false) then			tickClass := tickAmbiguous		else			begin				nodeState:= MinLg(nodeStates);				allOutsideStates := [];				allInsideStates := [];				allAwayStates := [];				allAncestralStates := [];				allSingletonAncestralStates := [];				aN := NAnc;				while aN <> subR do    {now let's go down tree from node to root and see what is there}					begin						curStates := getstslargest(aN, ic);						allAncestralStates := allAncestralStates+curStates;						if CardLg(curStates) = 1 then							allSingletonAncestralStates := allSingletonAncestralStates+curStates;						aN := NotNullAnc(aN);					end;				CheckStatesInTree(R);   {this accumulates all of the states inside the clade, and all outside the clade}				allAwayStates := allOutsideStates + allInsideStates;								if NodeIsTerminal(N) then					tickAbove := tickAboveUniform				else if (allInsideStates <> [])  then					if allInsideStates=nodeStates then   						if insideNotUniform then							tickAbove := tickAboveOther						else							tickAbove := tickAboveUniform					else if allSingletonAncestralStates*(allInsideStates-nodeStates)-[MSl,GAl] <> []  then {there is another state inside which was definitely in an ancestor}						tickAbove := tickAboveAncestral					else if allAncestralStates*(allInsideStates-nodeStates)-[MSl,GAl] <> [] then {there is another state inside which may have been in an ancestor, but was definitely outside}						tickAbove := tickAboveMaybeAncestral					else if allOutsideStates*(allInsideStates-nodeStates)-[MSl,GAl] <> []  then {there is another state inside which was not in an ancestor, but was definitely outside}						tickAbove := tickAboveConvergent					else if (allInsideStates-nodeStates-[MSl,GAl]) <> [] then {there is another state inside which was not outside} 						tickAbove := tickAboveNovel;				if CardLg(allOutsideStates) = 1 then					tickBelow := tickBelowUniform				else if allSingletonAncestralStates*nodeStates-[MSl,GAl] <> []  then {the nodestate was definitely in an ancestor, current occurence must be a reversal}					tickBelow := tickBelowAncestral				else if allAncestralStates*nodeStates-[MSl,GAl] <> [] then {the nodestate may have been in an ancestor, but was definitely outside}					tickBelow := tickBelowMaybeAncestral				else if allOutsideStates * nodeStates-[MSl,GAl] <> [] then  {the nodestate was not in an ancestor, but was definitely outside}					tickBelow := tickBelowConvergent;				 if cardLg(nodeStates) = 1 then					begin						if nodeState in ancestralStates then 							tickClass := tickAmbiguous						else							begin								inClade := false;																badAbove := not (tickAbove in [tickAboveUniform, tickAboveNovel, tickAboveOther]);								badBelow := not  (tickBelow in [tickBelowUniform, tickBelowOther]);																if badAbove & badBelow then									tickClass := tickPointBoth								else if badAbove then									tickClass := tickPointUp								else if badBelow then									tickClass := tickPointDown								else if (tickAbove = tickAboveNovel) then									tickClass := tickChangedAbove								else if tickABove = tickAboveUniform then									tickClass := tickUnique								else									tickClass := tickOther;								{$IFC FALSE}								if (nodeState in AllAwayStates) | NodeIsTerminal(N) then {node state is in at least one other node}									begin										if allInsideStates <> [] then											if allInsideStates<> nodeStates then {there are new states above}												if allOutsideStates*(allInsideStates-nodeStates)-[MSl,GAl] <> []  then 													tickClass := tickPointUp											else if (allInsideStates-nodeStates-[MSl,GAl]) <> [] then {there is another state inside which was not outside} 												tickClass := tickChangedAbove;																					if nodeState in allOutsideStates then											if allOutsideStates * nodeStates-[MSl,GAl] <> [] then  												begin													if tickClass = tickPointUp then 														tickClass := tickPointBoth													else														tickClass := tickPointDown;												end;									end								else									begin										tickClass := tickUnique;									end;{$ENDC}							end;					end				else					begin						tickClass := tickDerivedUnclear;					end;			end;	end;{-----------------------------------------------------------------------------}	procedure AppendAboveCladeInfo(H: Handle; tickAbove: integer);	begin		AppendToHandle(H,chr(13));		case tickAbove of 			tickAboveAncestral:				AppendToHandle(H,'Reversed above to a state found in an ancestor');			tickAboveMaybeAncestral:				begin					AppendToHandle(H,'Reversed above to a state found in an ancestor');					AppendToHandle(H,chr(13));					AppendToHandle(H,'  OR changed above to a state convergent with a state outside this clade');				end;			tickAboveConvergent:				AppendToHandle(H,'Changed above to a state convergent with a state outside this clade');			tickAboveUniform:				AppendToHandle(H,'Character is uniform within this clade');			tickAboveOther:				AppendToHandle(H,'Two or more other states found within this clade');			otherwise;		end;	end;{-----------------------------------------------------------------------------}	procedure AppendBelowCladeInfo(H: Handle; tickBelow: integer);	begin		AppendToHandle(H,chr(13));		case tickBelow of 			tickBelowAncestral:				AppendToHandle(H,'State at this node found in an ancestor, thus representing a reversal');			tickBelowMaybeAncestral:				begin					AppendToHandle(H,'State at this node found in an ancestor, thus representing a reversal,');					AppendToHandle(H,chr(13));					AppendToHandle(H,'  OR convergent with a state outside this clade');				end;			tickBelowConvergent:				AppendToHandle(H,'State at this node convergent with a state outside this clade');			tickBelowUniform:				AppendToHandle(H,'Character is uniform outside this clade');			tickBelowOther:				AppendToHandle(H,'Two or more other states found outside this clade');			otherwise;		end;	end;{-----------------------------------------------------------------------------}	procedure AppendChangeReporttoHandle(H: Handle; N: Nptr; ic: integer);	var	ir, tickClass, tickBelow, tickAbove, foundchar, oldi, changeClass: integer;		index: double;		ds, ds2: str255;	begin		if nucleotides then			begin				AppendToHandle(H,chr(13));				case CharCodPos(ic) of					1: AppendToHandle(H, 'Codon position: 1');					2: AppendToHandle(H, 'Codon position: 2');					3: AppendToHandle(H, 'Codon position: 3');					codeNotSet:  AppendToHandle(H, 'Codon position: unspecified');					otherwise						AppendToHandle(H, 'Non-coding'); 				end;			end;		if ((colorTicksClass=colorTicksIndex) | calcRI | calcCI | calcRC) & MinMaxLenLegalChar(ic, minlength) then			begin				if ((colorTicksClass=colorTicksIndex) & (colorTicksIndexClass=colorTicksCI)) | calcCI then					begin						AppendToHandle(H,chr(13));						AppendToHandle(H,'CI: ');						index := getchhdl(ic)^^.ci;						RealToString(index, ds2, 10.0, sigindices, true);						AppendToHandle(H,ds2);					end;				if MinMaxLenLegalChar(ic, maxlength) then					begin						if ((colorTicksClass=colorTicksIndex) & (colorTicksIndexClass=colorTicksRI)) | calcRI then							begin								AppendToHandle(H,chr(13));								AppendToHandle(H,'RI: ');								index := getchhdl(ic)^^.ri;								RealToString(index, ds2, 10.0, sigindices, true);								AppendToHandle(H,ds2);							end;						if ((colorTicksClass=colorTicksIndex) & (colorTicksIndexClass=colorTicksRC)) | calcRC then							begin								AppendToHandle(H,chr(13));								AppendToHandle(H,'RC: ');								index := getchhdl(ic)^^.ri * getchhdl(ic)^^.ci;								RealToString(index, ds2, 10.0, sigindices, true);								AppendToHandle(H,ds2);							end;					end;			end;		DetermineTickClass(N,ic,tickClass, tickBelow, tickAbove,changeClass);		if nucleotides then			begin				AppendToHandle(H,chr(13));				case changeClass of 					changeTransversion: 						AppendToHandle(H,'Transversion');					changeTransition: 						AppendToHandle(H,'Transition');					otherwise						AppendToHandle(H,'Unclear if transition or transversion');				end;			end;		case tickClass of			tickUnique:				begin					AppendToHandle(H,chr(13));					AppendToHandle(H,'Uniquely derived state, unchanged above');					AppendBelowCladeInfo(H, tickBelow);				end;			tickChangedAbove:				begin					AppendToHandle(H,chr(13));					AppendToHandle(H,'Uniquely derived state, but changed above to a state not found outside this clade');				end;			tickPointUp:				begin					AppendAboveCladeInfo(H, tickAbove);				end;			tickPointDown:				begin					AppendBelowCladeInfo(H, tickBelow);				end;			tickPointBoth:				begin					AppendAboveCladeInfo(H, tickAbove);					AppendBelowCladeInfo(H, tickBelow);				end;			tickAmbiguous:				begin					AppendToHandle(H,chr(13));					AppendToHandle(H,'Change not present in all MPRs');				end;			tickDerivedUnclear:				begin					AppendToHandle(H,chr(13));					AppendToHandle(H,'Derived state unclear');					AppendBelowCladeInfo(H, tickBelow);				end;			otherwise				;		end;	end;{-----------------------------------------------------------------------------}	procedure CheckForNewPrintPage(numLines: integer; var pg,currentLine: longint);	var db: boolean;	begin		if currentline > numlines then			begin				ClosePrinterPage;				if NoPrinterError then					db := OpenPrinterPage;				currentline := 1;  {v3.02: changed from 0 to 1}				pg := pg + 1;			end;	end;{-----------------------------------------------------------------------------}	procedure DrawPrintHandle(H: Handle;listDest, numLines: integer; var pg,currentLine: longint; addTab: boolean);	var ds: str255;		HSize, posInHandle, lastReturn: longint;	begin		HSize := GetHandleSize(H);		posInHandle:= 1;		lastReturn := posInHandle;		repeat			if HChar(H,posInHandle) = chr(13) then				begin					if posInHandle>lastReturn then						begin							ds := StringFromHandle(H,lastReturn,posInHandle-1);							if addTab then ds := concat(chr(9), ds);							DrawWriteString(ds);						end;					PrintWriteReturn(currentline);					if listDest = listPrint then						CheckForNewPrintPage(numLines,pg,currentLine);					lastReturn := posInHandle;				end;			posInHandle := posInHandle+1;		until posInHandle >= HSize;		if lastReturn < HSize-1 then			begin				ds := StringFromHandle(H,lastReturn,HSize);				if addTab then ds := concat(chr(9), ds);				DrawWriteString(ds);			end;	end;{-----------------------------------------------------------------------------}	procedure PlaceAdditionalTraceAllChangesText(N: Nptr; ic, listDest, numLines: integer; var pg,currentLine: longint);	var H: Handle;	begin		H := NewHandle(0);		AppendChangeReporttoHandle(H,N,ic);		DrawPrintHandle(H,listDest, numLines, pg,currentLine, true);		ZapHandle(H);	end;{-----------------------------------------------------------------------------}	procedure  PrepareCharAndStates(var ds: str255);	var ds2: str255;	begin		ds2 := ds;		Insert(':', ds2, pos(NoName, ds2));		Delete(ds2, pos(NoName, ds2),1);		ds := ds2;	end;{-----------------------------------------------------------------------------}	function GetCharAndStates (N: Nptr; ffset, ttset: largestsetchars; isroot: boolean; ic: integer; usestatenames: boolean): str255;{FROZEN 3.0}{if BranchListN = R, then ffset is from left node, ttset is from right node}		var			fset, tset: largestsetchars;			ds, tds: str255;	begin		fset := ffset;		tset := ttset;		ds := charname(ic);		NumToString(ic, tds);		if not usestatenames or (ds = '') then  {just use character number}			ds := tds		else			ds := concat(tds, '. ', ds);   {use character number and name}		ds := concat(ds, NoName);		ds := concat(ds, '  ');		if isroot then			begin				ds := concat(ds, StsToString(addUCLtoSet(fset, N^.lf, ic), ic, usestatenames,false), '<->');				ds := concat(ds, StsToString(addUCLtoSet(tset, N^.rt, ic), ic, usestatenames,false))			end		else			begin				ds := concat(ds, StsToString(addUCLtoSet(fset, NotNullAnc(N), ic), ic, usestatenames,false), '->');				ds := concat(ds, StsToString(addUCLtoSet(tset, N, ic), ic, usestatenames,false));			end;		GetCharAndStates := ds;	end;{-----------------------------------------------------------------------------}	function ChangeToShow (N1, N2: Nptr; ic: integer; blm: integer; crossroot: boolean): boolean;{FROZEN 3.0}{with branchlistmode blm, finds out if there is a change to show between N1 and N2.  }{If not crossroot, then N1=N, N2=anc , but if crossroot, then N1=R^.lf, N2=R^.rt}	begin		if blm = unambigmode then  {change to show only if no overlap}			changetoshow := getstslargest(N1, ic) * getstslargest(N2, ic) = []		else if blm = ambigmode then  {change to show only if sets not the same}			changetoshow := getstslargest(N1, ic) <> getstslargest(N2, ic)		else if (not crossroot) then {(blm = maxmode) or blm=minmaxmode}			changetoshow := Ftl in GetStsliteralLargest(N1, ic)  {change to show only if marked by FTl bit}		else			changetoshow := false;	end;{-----------------------------------------------------------------------------}{-----------------------------------------------------------------------------}	procedure CalcNumStateFrequency(N: Nptr; var numStates, maxNumStates: NumStateArray);	var ir, ic: integer;		useset: largestsetchars;		isUncertain: boolean;	begin		for ir := 0 to maxstate do  {initializing sums to zero}			begin				numStates[ir] := 0;				MaxnumStates[ir] := 0;			end;		for ic := 1 to numchars do			if charincluded(ic) then				if not Qtaxon(N, ic) then					begin						useset := getstsLargest(N, ic);						isuncertain := TreatAsUncertainty(useset, N, ic);{Note that terminal polymorphisms not counted as certain}{because resolves to state at mrca of terminal taxon, and thus can be treated as uncertain.}						for ir := 0 to maxstbit do							if ir in useset then								begin									if not isuncertain then										NumStates[ir] := NumStates[ir] + 1;									MaxNumStates[ir] := MaxNumStates[ir] + 1								end;					end;	end;{-----------------------------------------------------------------------------}	procedure MakeBranchList (N: Nptr; var pg, currentline: longint; lineW, numLines: integer; listDest: integer);{FROZEN 3.0}{makes the branch list for node N, either by rebuilding the list, }{or if printing, by drawing the list to the printer}		label			1;		const			maxlines = 2500;		var			ic, ir: integer;			useset: largestsetchars;			afN: Nptr;			ds, tds: str255;			thecell: point;			isuncertain, somethingwasshown, titleshown: boolean;			MaxNumStates, NumStates: numstatearray;{..........}		procedure PlaceLine;		begin			if listDest = listToWindow then				begin					thecell.v := LAddRow(1, -1, BranchList);					LSetCell(Pointer(ord4(@ds) + 1), length(ds), thecell, BranchList);					if thecell.v > maxlines then						begin							NewError(105, 0);							goto 1;						end;				end			else				begin					PrintWriteReturn(currentline);					DrawWriteString(ds);					if listDest = listPrint then						CheckForNewPrintPage(numLines,pg,currentLine);				end;		end;{..........}{..........}	begin		somethingwasshown := false;		firstcharLine := 0;		SetCursor(clockCursor);		afN := NotNullAnc(N);		if listDest = listToWindow then			begin				LSetDrawingMode(false, BranchList);				thecell.v := 0;				thecell.h := 0;				while BranchList^^.databounds.bottom > 0 do					LDelRow(1, 0, BranchList);			end;		if (traceshown = traceAllStates) then  {TRACE ALL STATES ======================}			begin				somethingwasshown := true;				if BLSWhat = BLSstatesum then  {FREQUENCIES OF STATES AT NODE}					begin						CalcNumStateFrequency(N,numStates, maxNumStates);						ds := 'State:  Frequency';						PlaceLine;						for ir := 0 to maxstate do							begin								if NumStates[ir] <> MaxNumStates[ir] then									ds := concat(CharOfNum(ir), ':  ', StringFromNum(NumStates[ir]), '-', StringFromNum(MaxNumStates[ir]))								else									ds := concat(CharOfNum(ir), ':  ', StringFromNum(NumStates[ir]));								PlaceLine;							end					end				else						{LIST OF STATES AT NODE}					begin						ds := 'Character:  States';						PlaceLine;						firstcharLine := 1;						for ic := 1 to numchars do							begin								if charincluded(ic) then									begin										ds := charname(ic);										NumToString(ic, tds);										if not BranchListStatesByNames or (ds = '') then											ds := tds										else											ds := concat(tds, '. ', ds);										ds := concat(ds, ':  ');										ds := concat(ds, StsToString(addUCLtoSet(getstsLargest(N, ic), N, ic), ic, BranchListStatesByNames,false));										PlaceLine;									end;							end					end			end		else if PartOfPolytomy(N) and not polyreal then  {TRACE ALL CHANGES ======================}			begin				somethingwasshown := true;				ds := 'Not calculated';				PlaceLine;			end		else if (N <> R) then {Trace All Changes}			if (N^.chg > 0) or (N^.anc = R) then				begin					somethingwasshown := false;					titleshown := false;					if (N^.anc = R) & not NodeIsPolytomous(R) then  {immediate desc of root; look to see if any cross root changes to be shown}						for ic := 1 to numchars do							if charincluded(ic) & not (TypeOfChar(ic) in [fisher, irreversible]) then								begin									if ChangeToShow(R^.rt, R^.lf, ic, branchlistmode, true) & not changetoshow(N, afN, ic, branchlistmode, false) then										begin											ds := 'Character:  Change';											placeline;											ds := '(* indicates character';											placeline;											ds := '   with change on left or';											placeline;											ds := '   right descendent of root)';											placeline;											firstcharLine := 4;											titleshown := true;											leave;										end								end;					for ic := 1 to numchars do						if charincluded(ic) & (TypeOfChar(ic) <> fisher) then							begin								if changetoshow(N, afN, ic, branchlistmode, false) then									begin										if not titleshown then											begin												ds := 'Character:  Change';												placeline;												firstcharLine := 1;												titleshown := true;											end;										ds := GetCharAndStates(N, getstslargest(afN, ic), getstslargest(N, ic), false, ic, BranchListChgbynames);										if ambigdistinguish & (branchlistmode <> unambigmode) & not ChangeToShow(N, afN, ic, unambigmode, false) then											begin												Insert('(', ds, pos(NoName, ds) + 3);												ds := concat(ds, ')');											end;										PrepareCharAndStates(ds);										PlaceLine;										if listDest <> listToWindow then											PlaceAdditionalTraceAllChangesText(N,ic, listDest,numLines,pg,currentLine);										somethingwasshown := true;									end								else if (N^.anc = R) & not NodeIsPolytomous(R) & not (Typeofchar(ic) = irreversible) then									begin										if changetoshow(R^.lf, R^.rt, ic, branchlistmode, true) then											begin												if not titleshown then													begin														ds := 'Character:  Change';														placeline;														firstcharLine := 1;														titleshown := true;													end;												ds := GetCharAndStates(R, getstslargest(R^.lf, ic), getstslargest(R^.rt, ic), true, ic, BranchListChgbynames);												PrepareCharAndStates(ds);												ds := concat(ds, ' *');												PlaceLine;												somethingwasshown := true;											end									end;							end;				end;		if not somethingwasshown then			begin				if BranchListmode = unambigmode then					ds := 'no unambiguous changes'				else if BranchListmode = ambigmode then					ds := 'no apparent changes'				else					ds := 'no changes';				PlaceLine;			end;1:		if listDest = listToWindow then			begin				LSetDrawingMode(true, BranchList);				LUpdate(myGetVisRgn(BranchListwindow), BranchList);			end;	end;{-----------------------------------------------------------------------------}	procedure OpenBranchListWindow;		var			width: integer;			cellsize: point;			BranchListrect, databounds: rect;	begin		firstcharLine := 0;		MoveWindow(BranchListwindow, toolPalettePoint[treeTools].h, toolPalettePoint[treeTools].v + toolCellWidth * 2, false);		ShowWindow(BranchListWindow);		{^&* theWindow := BranchListWindow;}		genericSetPort(BranchListWindow);		BranchListlw := FontHeight;		SelectWindow(BranchListWindow);		FixTreeShadingMenus;{setting up the list}		BranchListrect := WindowPortRect(branchListWindow);		BranchListrect.right := BranchListrect.right - scrollwidth;		BranchListrect.bottom := BranchListrect.bottom - scrollwidth;		cellsize.h := ScreenBoundsRect.right - ScreenBoundsRect.left;		cellsize.v := BranchListlw;		SetRect(databounds, 0, 0, 1, 0);		BranchList := LNew(BranchListrect, databounds, cellsize, 0, BranchListWindow, false, false, false, true);		BranchList^^.selFlags := lonlyone;		BranchListon := true;	end;{----------------------------------------------------------------------------}	procedure CloseBranchListWindow;	begin		LDispose(BranchList);		HideWindow(BranchListWindow);		BranchListon := false;	end;{-----------------------------------------------------------------------------}	procedure DrawBranchListWindow;		var			tport: windowptr;			oldClip: RgnHandle;	begin		oldClip := NewRgn;		genericGetPort(tport);		genericSetPort(BranchListwindow);		GetClip(oldclip);		cliprect(WindowPortRect(branchListWindow));		EraseRect(WindowPortRect(branchListWindow));		LUpdate(myGetVisRgn(BranchListwindow), BranchList);		DrawGrowIcon(BranchListWindow);		SetClip(oldclip);		genericSetPort(tport);		ZapRegion(oldClip);	end;{-----------------------------------------------------------------------------}	procedure GrowBranchList (width, height: integer);{ grow branch list window to size width, height}		var			tport: windowptr;	begin		genericGetPort(tport);		genericSetPort(BranchListwindow);		height := ((height - scrollwidth) div BranchListlw) * BranchListlw + scrollwidth;		SizeWindow(BranchListWindow, width, height, TRUE);		ClipRect(WindowPortRect(branchListWindow));		EraseREct(WindowPortRect(branchListWindow));		LSize(width - scrollwidth, height - scrollwidth, BranchList);		LUpdate(myGetVisRgn(BranchListwindow), BranchList);		DrawGrowIcon(BranchListWindow);		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	procedure DrawNodeListHeading (var currentLine: longint; lineW: integer);		var			ds: str255;	begin		MoveTo(20, currentline * LineW + 22);		PrintWriteReturn(currentLine);		DrawWriteString(MacCladeStamp);		PrintWriteReturn(currentLine);		DrawWriteString(UserStamp(true, true, false));		PrintWriteReturn(currentLine);		DrawWriteString(TimeStamp);		PrintWriteReturn(currentLine);		PrintWriteReturn(currentLine);		DrawWriteString(DataFileStamp);		PrintWriteReturn(currentLine);		DrawWriteString(CurrentTreeStamp);		PrintWriteReturn(currentLine);		PrintWriteReturn(currentLine);		PrintWriteReturn(currentLine);		if (traceshown = traceAllChanges) then			begin				DrawWriteString('Reconstructed changes along branches (from node below to node at top of branch)');				PrintWriteReturn(currentLine);				case branchlistmode of					unambigmode: 						DrawWriteString('(Unambiguous)');					ambigmode: 						DrawWriteString('(Almost all possible)');					maxmode: 						DrawWriteString('(All possible)');					minmaxmode: 						DrawWriteString('(Unambiguous and (All possible))');					otherwise						;				end;				PrintWriteReturn(currentLine);				if branchlistmode <> unambigmode then					begin						DrawWriteString('Ambiguous changes shown in parentheses');						PrintWriteReturn(currentLine);					end;{$IFC FALSE}				if resolveoption <> allpossible then					begin						if resolveoption = acctran then							DrawWriteString('ACCTRAN')						else if resolveoption = deltran then							DrawWriteString('DELTRAN');						DrawWriteString(' reconstruction shown for unordered and ordered characters.  ')					end;{$ENDC}			end		else if (traceshown = traceAllStates) then			DrawWriteString('Reconstructed states in all characters at nodes (at top of branches)')		else if (traceshown = traceDiscrete) then			begin				DrawWriteString(concat('Reconstructed states at nodes (at top of branches) for ', AvailCharName(i)));				PrintWriteReturn(currentLine);				DrawWriteString(concat('Character''s type: ', typeName(typeofChar(i)), '     Number of steps: ', stringfromnum(isteps)));				PrintWriteReturn(currentLine);				if fixon then					begin						DrawWriteString('States at some nodes are fixed.  ');						PrintWriteReturn(currentLine);					end;				if resolveoption = acctran then					begin						DrawWriteString('ACCTRAN reconstruction shown.  ');						PrintWriteReturn(currentLine);					end				else if resolveoption = deltran then					begin						DrawWriteString('DELTRAN reconstruction shown.  ');						PrintWriteReturn(currentLine);					end;				if equivcycle then					begin						DrawWriteString(concat('Equivocal cycling on.  Reconstruction ', StringFromNum(equivcycleNum), ' listed.  '));						PrintWriteReturn(currentLine);					end;			end		else if (traceshown = traceContinuous) then			begin				DrawWriteString(concat('Reconstructed states at nodes (at top of branches) for continuous character ', StringFromNum(icont)));				PrintWriteReturn(currentLine);				DrawWriteString('Criterion: ');				case Continuousmode of					manhattan: 						DrawWriteString('Linear/Wagner parsimony (full ranges)');					manhatmin: 						DrawWriteString('Linear/Wagner parsimony (minimum values)');					manhatmax: 						DrawWriteString('Linear/Wagner parsimony (maximum values)');					sqrooted: 						DrawWriteString('Squared-change parsimony (rooted)');					squnrooted: 						DrawWriteString('Squared-change parsimony (unrooted)');					sqFelsX: 						DrawWriteString('Felsenstein''s X''s'); {ввв}					sqFelsContrast: 						DrawWriteString('Felsenstein''s Contrasts'); {ввв}					sqFelsContrastSTD: 						DrawWriteString('Fels. Contrasts (Std.)'); {ввв}					otherwise						;				end;				PrintWriteReturn(currentLine);			end		else if (traceshown = traceProbability) then			begin				DrawWriteString('Probabilities ');				case probRecitem of					stateexact: 						DrawWriteString('that state at node is reconstructed correctly, given model.');					statenotwrong: 						DrawWriteString('that MPR set includes true state at node, given model.');					changecorrect: 						DrawWriteString('that change along branch is reconstructed correctly, given model.');					numchangeUnamb: 						DrawWriteString('that unambiguous change is reconstructed along branch, given model.');					numchangeAllowed: 						DrawWriteString('that allowed change is reconstructed along branch, given model.');					otherwise						;				end;				PrintWriteReturn(currentLine);				PrintWriteReturn(currentLine);				DrawWriteString('Model of character evolution used:');				PrintWriteReturn(currentLine);				DrawWriteString('Probabilities of change or stasis per');				if seglistenProb then					DrawWriteString(' segment:')				else					DrawWriteString(' branch:');				PrintWriteReturn(currentLine);				RealToString(probChangeRec[0, 0], ds, 1000, 4, true);				DrawWriteString(concat('0->0:   ', ds));				PrintWriteReturn(currentLine);				RealToString(probChangeRec[0, 1], ds, 1000, 4, true);				DrawWriteString(concat('0->1:   ', ds));				PrintWriteReturn(currentLine);				RealToString(probChangeRec[1, 0], ds, 1000, 4, true);				DrawWriteString(concat('1->0:   ', ds));				PrintWriteReturn(currentLine);				RealToString(probChangeRec[1, 1], ds, 1000, 4, true);				DrawWriteString(concat('1->1:   ', ds));				PrintWriteReturn(currentLine);			end;	end;{-----------------------------------------------------------------------------}	function NodeLengthString (N: Nptr): str255;   {returns info about length of node}		var			dms, ds: str255;	begin		ds := '';		if (branchlistmode = minmaxmode) & (N^.length2 > 0) then			begin				if N^.length2 = N^.length1 then					ds := LengthString(N^.length1, branchlengthsWeighted)				else					begin						RealToString(N^.lengthmean, dms, 1000, 4, true);						ds := concat(LengthString(N^.length1, branchlengthsWeighted), ' - ', dms, ' - ', LengthString(N^.length2, branchlengthsWeighted));					end			end		else if (Branchlistmode <> minmaxmode) & (N^.length1 > 0) then			ds := LengthString(N^.length1, branchlengthsWeighted);		NodeLengthString := ds;	end;{-----------------------------------------------------------------------------}	function NodeHasTraceValue (N: Nptr): boolean;		var			tv: boolean;	begin		tv := true;		if N = R then			begin				if (traceshown = traceContinuous) & (Continuousmode = squnrooted) then					tv := false;				if (traceshown = traceProbability) & (probRecitem in [changecorrect, numchangeUnamb, numchangeAllowed]) then					tv := false;			end		else if NodeIsTerminal(N) then			begin				if (traceshown = traceContinuous) & (continuousmode in [sqFelsContrast, sqFelsContrastSTD]) then					tv := false;				if (traceshown = traceProbability) & (probRecitem in [stateexact, statenotwrong]) then					tv := false;			end;		NodeHasTraceValue := tv;	end;{-----------------------------------------------------------------------------}	procedure DrawNodeInfo (tN: Nptr; nodenum, lineW, numlines: integer; var currentLine,  pg: longint);		var			ds: str255;			useset: largestsetchars;	begin		if (tn <> subR) & BranchExists(tN) & NodeHasTraceValue(tN) then			begin				PrintWriteReturn(currentLine);				if (traceshown = traceAllChanges) or (traceshown = traceAllStates) then					PrintWriteReturn(currentLine);				DrawWriteString('=============');  {v3.02}				PrintWriteReturn(currentLine);				if NodeIsInternal(tN) then					begin						if tN^.fixanc then							begin								DrawWriteString(TaxonName(TermOfFixanc(tN)^.name));								DrawWriteString(' (ancestral)');							end						else							begin								DrawWriteString('below ');								DrawWriteString(TaxonName(LeftMostDescendant(tn)^.name));								DrawWriteString(' - ');								DrawWriteString(TaxonName(RightMostDescendant(tn)^.name));							end					end				else					DrawWriteString(TaxonName(tN^.name));				DrawWriteString(concat('  (branch number ', StringFromNum(nodenum), '):   '));				if (traceshown = traceAllChanges) or (traceshown = traceAllStates) then					begin						if PartofPolytomy(tN) and not polyreal then							DrawWriteString('Not Available')						else							begin								if (traceshown = traceAllChanges) then  {v3.02: write node length string in listing}									begin										PrintWriteReturn(currentLine);										if branchlengthsWeighted then											DrawWriteString('Total weighted changes along branch: ')										else											DrawWriteString('Total changes along branch: ');										DrawWriteString(NodeLengthString(tN));										PrintWriteReturn(currentLine);									end;								if DrawToFile then									MakeBranchList(tN, pg, currentline, lineW, numLines, listFile)								else									MakeBranchList(tN, pg, currentline, lineW, numLines, listPrint);							end;					end				else if (traceshown = traceDiscrete) then					begin						useset := tN^.final;						if not tN^.fix then							useset := AddUclToSet(tN^.final, tn, i);						DrawWriteString(StsToString(useset, i, true,true));						if tN^.fix then							DrawWriteString('  FIXED');					end				else if (traceshown = traceContinuous) then					begin						if NodeHasTraceValue(tN) then {ввв}							begin								RealToString(tN^.finalC, ds, 1000, sigcontinuous, true);								DrawWriteString(ds);								if (continuousmode = manhattan) & (abs(tN^.finalC - tN^.finalD) > 0.001) then									begin										DrawWriteString(' - ');										RealToString(tN^.finalD, ds, 1000, sigcontinuous, true);										DrawWriteString(ds);									end;							end;					end				else if (traceshown = traceProbability) then					begin						if NodeHasTraceValue(tN) then							begin								RealToString(tN^.finalC, ds, 1000, 5, true);								DrawWriteString(ds);							end						else							DrawWriteString('not applicable');					end;			end;	end;{-----------------------------------------------------------------------------}end.