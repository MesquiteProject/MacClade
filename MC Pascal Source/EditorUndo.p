unit EditorUndo;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{ееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, 		TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  UtilLibInterface, MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, 		ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, TypeUtil, CharUtil, TreeUtil, 		MenuUtil, SymbolsNames, FootNote, SpreadUtil, InfoWindowsUtil;	function CellBlockString(cellBlock: CellBlockPtr; singleSequenceOnly: boolean): str255;	function StoreDataIntoCellBlock(cellBlock: CellBlockPtr; BR,TL: point; mustBeOneTaxon,mustBeMultipleChars,reportMemory, RNARC, compact, compactGapChars: boolean): boolean;	procedure StoreSingleCellForUndo(it,ic: integer);	procedure StoreSelectedSingleCellForUndo;	procedure StoreRowNameForUndo(whichinfo,theRow: integer);	function StoreCellBlockForUndo(st,et,sc,ec: integer; fullTaxon, fullCharacters, storeSelection: boolean): boolean;	function StoreSelectedCellBlockForUndo(fullTaxon, fullCharacters, storeSelection: boolean): boolean;	procedure ReBuildUndoMatrixMemory;	procedure StoreMatrixForUndo;	procedure UndoWholeMatrix;{ееееееееееееееееееееее}implementation {е$S SpreadUtil} {things that can be done: 	AddNewCharacter 	InsertNewCharacter 	MoveCharacter 	 	AddNewTaxon 	InsertNewTaxon 	MoveTaxon 	 	changing of matrix cells 		- alignment tools 		- paint bucket, stamppaste, paintbrush		 	 	 	DestroyCharacter 		- will lose footnotes, footpicts, weightset, typeset info  	DestroyTaxon   		- will lose footnotes, footpicts, taxa in trees, etc	 	editing data cells 	 	 	Reorder Taxa 	 }{-----------------------------------------------------------------------------}	procedure StoreMatrixForUndo;	begin	end;{-----------------------------------------------------------------------------}	procedure UndoWholeMatrix;	begin	end;{-----------------------------------------------------------------------------}	function StoreDataIntoCellBlock(cellBlock: CellBlockPtr; BR,TL: point; mustBeOneTaxon,mustBeMultipleChars,reportMemory, RNARC, compact, compactGapChars: boolean): boolean;	{if compact is true, then the the block should be stripped of all gaps, except any necessary trailing gaps, and should be minimized in length}		var			sc, st, it, ic: longint;			SetPtrTS, positionInCellBlock: Ptr;			dhdl: Handle;			oldstate: SignedByte;			amountneeded: longint;			maxDataCells, numDataCells: integer;	begin		StoreDataIntoCellBlock := true;		if (TaxonOfCell(BR) <= 0) or (CharOfCell(BR) <= 0) then  {no data cells included}			begin				StoreDataIntoCellBlock := false;				Beep;			end		else			with cellBlock^ do				begin					if not editorTransposed then						begin							starttaxa := TL.v;							if mustBeOneTaxon then								endtaxa := starttaxa							else								endtaxa := BR.v;							startchars := TL.h;							endchars := BR.h;						end					else						begin							starttaxa := TL.h;							if mustBeOneTaxon then								endtaxa := starttaxa							else								endtaxa := BR.h;							startchars := TL.v;							endchars := BR.v;						end;					if compact then						begin							maxDataCells:= 0;							for it := starttaxa to endTaxa do								begin									numDataCells := numNonGaps(starttaxa, endtaxa,startchars,endchars,editorToolsTreatMissingAsGaps);									if numDataCells > maxDataCells then										maxDataCells := numDataCells;								end;						end;					if mustBeMultipleChars & (startchars = endchars) then						begin							StoreDataIntoCellBlock := false;							Beep;							Exit(StoreDataIntoCellBlock);						end;					blocktcb := tcb;					blocknumbytes := numbytes;					st := starttaxa;					if st <= 0 then						st := 1;					sc := startchars;					if sc <= 0 then						sc := 1;					ntax := endtaxa-st+1;					if mustBeOneTaxon then						ntax := 1;					if compactGapChars then						begin							maxDataCells:= endchars-sc+1;							for ic := sc to endChars do								begin									if AllGapsInTaxa(st, endtaxa,ic,editorToolsTreatMissingAsGaps) then									 maxDataCells := maxDataCells-1;								end;						end;					if compact or compactGapChars then						nchar := maxDataCells					else						nchar := endchars - sc + 1;					if (ntax < 1)|(nchar < 1) then						beep;					UnLockHandle(cellBlock^.H, oldstate);					if not EnoughMemory(ord4(tcb) * ord4(ntax)* nchar+1024, amountneeded) then						begin							if reportMemory then InstantErrorPlus(171, concat(StringFromNum(amountneeded div 1024), 'K'));							errorflag := true;							StoreDataIntoCellBlock:= false;							Exit(StoreDataIntoCellBlock);						end;					if SetHandleSizeSuccessful(cellBlock^.H, ord4(tcb) * ord4(ntax) * nchar) then						begin							HLock(cellBlock^.H);							positionInCellBlock := Ptr(GetMaster(cellBlock^.H));							if RNARC then								positionInCellBlock := Ptr(ord4(positionInCellBlock) + (nchar-1)* tcb);							for it := st to endtaxa do								begin									dhdl := GetTaxStsHdl(it);									HLock(dhdl);									SetPtrTS := Ptr(ord4(GetMaster(dhdl)) + ord4(sc - 1) * tcb);  //source									for ic := sc to endchars do										begin		{this will pick up FT's, FP's, but they are not pasted in}											if (not compactGapChars | not AllGapsInTaxa(st, endtaxa, ic,editorToolsTreatMissingAsGaps)) then												if (not compact | not IsLargestSetCharsGapLike(GetLargestFromPtr(SetPtrTS),editorToolsTreatMissingAsGaps)) then													if RNARC then														begin															TransferStatesRNARC(positionInCellBlock, SetPtrTS);															positionInCellBlock := Ptr(ord4(positionInCellBlock) - tcb);  // reversing, so have to go down														end													else														begin															TransferStates(positionInCellBlock, SetPtrTS);  															positionInCellBlock := Ptr(ord4(positionInCellBlock) + tcb);														end;											SetPtrTS := Ptr(ord4(SetPtrTS) + tcb);										end;									HUnLock(dhdl);								end;							ResetHandle(cellBlock^.H, oldstate);						end;					if compact then						endchars := maxDataCells;				end;	end;{-----------------------------------------------------------------------------}	function CellBlockString(cellBlock: CellBlockPtr; singleSequenceOnly: boolean): str255;	var oldstate: SignedByte;		H: Handle;		statePtr: LIP;		tsts: LargestSetChars;		ic, maxchar: longint;		ds, theString: str255;		c: char;		iomissing,iogap,iomatchchar: char;	begin		CalcSolidIOSymbols(iomissing,iogap,iomatchchar);		theString := '';		LockHandle(cellBlock^.H, oldstate);		maxchar := cellBlock^.nchar;		if maxchar > 255 then maxchar := 255;		for ic := 1 to cellBlock^.nchar do			begin				statePtr := LIP(GetMaster(cellBlock^.H)+ord4(cellBlock^.blocktcb)*ord4(ic-1));				if cellBlock^.blocknumbytes = 2 then					tsts := set15to31(IP(statePtr)^)				else					tsts := LargestSetPointer(statePtr)^;				StateSetToNexusStates(tsts,0,0,absmaxstate,false, iomissing,iogap,iomatchchar,c,ds);				if c <> ' ' then					theString := concat(theString,c)				else					theString := concat(theString,ds);			end;		ResetHandle(cellBlock^.H, oldstate);		CellBlockString := theString;	end;{----------------------------------------------------------------------------}	function StoreCellBlockForUndo(st,et,sc,ec: integer; fullTaxon, fullCharacters, storeSelection: boolean): boolean;	var botRight, topLeft: point;		success: boolean;	begin		StoreCellBlockForUndo := false;		if editorTransposed then			begin				if fullTaxon then					begin						topLeft.v := 1;						botRight.v := numchars;					end				else					begin						if ec < 1 then Exit(StoreCellBlockForUndo);						topLeft.v := sc;						botRight.v := ec;					end;				if fullCharacters then					begin						topLeft.h := 1;						botRight.h := numtaxa;					end				else					begin						if et < 1 then Exit(StoreCellBlockForUndo);						topLeft.h := st;						botRight.h := et;					end;			end		else			begin				if fullTaxon then					begin						topLeft.h := 1;						botRight.h := numchars;					end				else					begin						if ec < 1 then Exit(StoreCellBlockForUndo);						topLeft.h := sc;						botRight.h := ec;					end;				if fullCharacters then					begin						topLeft.v := 1;						botRight.v := numtaxa;					end				else					begin						if et < 1 then Exit(StoreCellBlockForUndo);						topLeft.v := st;						botRight.v := et;					end;			end;		SetLastChangeInEditor(lastChangeCellBlock);  		success := StoreDataIntoCellBlock(EWUndoBlockP,botRight,topLeft,false,false, false, false,false,false);  		if not success then				begin					SetLastChangeInEditor(lastChangeCantUndo);					success := WarnCantUndoLowMemory;				end		else			begin				if storeSelection then					begin						undoSelectionTopLeft := editorSelectionTopLeft;						undoSelectionBotRight:= editorSelectionBotRight;						undoSelectionValid := true;					end				else					begin						undoSelectionTopLeft.h := 0;						undoSelectionTopLeft.v := 0;						undoSelectionBotRight.h := 0;						undoSelectionBotRight.v := 0;						undoSelectionValid := false;					end;			end;		StoreCellBlockForUndo := success;	end;{----------------------------------------------------------------------------}	function StoreSelectedCellBlockForUndo(fullTaxon, fullCharacters, storeSelection: boolean): boolean;	var st,et,sc,ec: integer;	begin		CalcSelectedTaxaCharacters(st, et, sc, ec,true);		StoreSelectedCellBlockForUndo := StoreCellBlockForUndo(st, et, sc, ec, fullTaxon, fullCharacters, storeSelection);	end;	{-----------------------------------------------------------------------------}	procedure StoreSingleCellForUndo(it,ic: integer);	var oldState: SignedByte;	begin		undoCellTaxon := it;		undoCellCharacter := ic;		if someDataSel then			begin				undoCellStates := gettaxonstsLargestCase(undoCellTaxon, undoCellCharacter);				SetLastChangeInEditor(lastChangeDataCell);			end		else			begin				LockHandle(undoNameCellStringH, oldState);				if undoCellTaxon> 0 then					undoNameCellStringH^^ := TaxonName(undoCellTaxon)				else					undoNameCellStringH^^ := CharName(undoCellCharacter);				SetLastChangeInEditor(lastChangeNameCell);				ResetHandle(undoNameCellStringH, oldState);			end;	end;{-----------------------------------------------------------------------------}	procedure StoreRowNameForUndo(whichinfo,theRow: integer);	var oldState: SignedByte;	begin		undoNameRow := theRow;		undoWhichInfo := whichInfo;		LockHandle(undoNameCellStringH, oldState);		undoNameCellStringH^^ := InfoNameString(whichinfo,theRow);		SetLastChangeInEditor(lastChangeNameRow);		ResetHandle(undoNameCellStringH, oldState);	end;{-----------------------------------------------------------------------------}	procedure StoreSelectedSingleCellForUndo;	begin		StoreSingleCellForUndo(TaxonOfCell(editorSelectionTopLeft),CharOfCell(editorSelectionTopLeft));	end;end.