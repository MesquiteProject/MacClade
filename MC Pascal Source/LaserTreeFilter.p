unit LaserTreeFilter;{еееееееееееееееееееееее}interface	uses		Printing, QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, BoxUtil, StrUtil, TraceAllChangesCalc, TreeUtil, TypeUtil, MenuUtil, TreeGet, Count, Coloring, TreeDrawer, Fonts, PrintingUtil, PrintingMisc, LaserTreeUtil, LaserDLOGDraw, LaserDraw, LaserCommands;	function LaserFilter (theDialog: DialogPtr; var Event: EventRecord; var localItemHit: INTEGER): BOOLEAN;	var		alreadydone: boolean;		justmag: boolean;		hasprinted: boolean;{еееееееееееееееееееееее}implementation {е$S LaserTreeFilter}{-----------------------------------------------------------------------------}	procedure SetLaserBoxMenuName (theLaserBox: integer);	begin		case theLaserBox of			taxanameB: 				SetMenuItemText(TextMHdl, 1, 'Taxon Names');			TreeB: 				SetMenuItemText(TextMHdl, 1, 'Text On Branches');			treestatsB: 				SetMenuItemText(TextMHdl, 1, 'Treelength, etc.');			treenamB: 				SetMenuItemText(TextMHdl, 1, 'Tree Name');			treenumB: 				SetMenuItemText(TextMHdl, 1, 'Tree Number');			commentB: 				SetMenuItemText(TextMHdl, 1, 'Comment');			legB: 				SetMenuItemText(TextMHdl, 1, 'Legend');			otherwise				;		end;	end;{----------------------------------------------------------------------------}	procedure PopUpTextM (theLaserBox: integer; theSpot: point);		var			menucode: longint;			ItemNo, Menu_No, currentsel: integer;	begin		InsertMenu(TextMHdl, -1);		SetLaserBoxMenuName(theLaserBox);		FixLaserFontMenus(laser^.fonts[theLaserBox]);		EnableDisableItem(dlogStyleMHdl, 0, not ((theLaserBox = TreeB) & (traceshown = traceAllChanges) & (summaryview = asticks) & ambigdistinguish & (branchlistmode <> unambigmode)));  {v3.04: disable this, as not allowed to change if (traceshown = traceAllChanges)}		LocalToGlobal(thespot);		currentsel := 1;		menucode := PopUpMenuSelect(TextMHdl, thespot.v + 5, thespot.h, currentsel);		Menu_No := HighWord(menucode);		ItemNo := LowWord(menucode);		updateFontChangedWindows := false;		if ItemNo > 0 then			begin				with laser^.fonts[theLaserBox] do					case Menu_No of						dlogFontMenu: 							DoFontMenu(dlogFontMHdl, ItemNo, font);						dlogStyleMenu: 							DoStyleMenu(dlogStyleMHdl, ItemNo, face);						dlogSizeMenu: 							DoSizeMenu(dlogSizeMHdl, ItemNo, size);						otherwise							;					end;				InvalidateWindowRect(myGetWindowPtrForDialog(LaserTreeDialog),previewB,false);			end;		updateFontChangedWindows := true;		myEnableItem(StyleMHdl, 0);  {v3.04: enable this back again}{    DeleteMenu(TextMenu);}{    ReleaseResource(Handle(TextMHdl));}	end;{----------------------------------------------------------------------------}	procedure MouseInLaserBox (theDialog: DialogPtr; startpt: point; theBox: integer; trashable: boolean; var adjH, adjV: integer);		var			theRgn: RgnHandle;			limitrect, sloprect: rect;			Lpos: longint;			wh: point;	begin		theRgn := NewRgn;		limitrect := drawbox;		sloprect := limitrect;		InsetRect(sloprect, -20, -20);		RectRgn(theRgn, LaserBoxes^[theBox].R);		ClipRect(drawbox);		adjV := 0;		adjH := 0;		if not closeupon then			begin				Lpos := DragGrayRgn(theRgn, startpt, limitRect, slopRect, 0, nil);				GetMouse(wh);				if PtInRect(wh, drawbox) then					begin						adjV := TruncateValue(HighWord(Lpos) / shrink);						adjH := TruncateValue(LowWord(Lpos) / shrink);					end;			end;		ZapRegion(theRgn);	end;{----------------------------------------------------------------------------}	procedure MouseInStandardLB (theBox: integer; theDialog: DialogPtr; wh: point);		var			adjV, adjH: integer;	begin		MouseInLaserBox(theDialog, wh, theBox, true, adjH, adjV);		if (adjV <> 0) or (adjH <> 0) then			with laser^.starts[theBox] do				begin					v := v + adjV;					h := h + adjH;					InvalidateWindowRect(myGetWindowPtrForDialog(LaserTreeDialog),previewB,false);				end;		ClipRect(WindowPortRect(myGetWindowPtrForDialog(theDialog)));		if LaserCursor = LaserRuler then			with laser^.starts[theBox] do				WriteBottom(theDialog, concat('left: ', StringFromNum(h), '  top: ', StringFromNum(v)));	end;{----------------------------------------------------------------------------}	procedure ClickInCursorR (inLaserCurs: integer; var oldLaserCursor: integer);	begin		if LaserCursor <> inlasercurs then			begin				InvertRect(laserCursorR[laserCursor]);				LaserCursor := inlaserCurs;				InvertRect(laserCursorR[laserCursor]);				oldLaserCursor := inlasercurs;			end;	end;{----------------------------------------------------------------------------}	procedure MouseInAngle (var owh: point);		var			divid: extended;			wh: point;			anglept: point;	begin		repeat			repeat				GetMouse(wh);			until (wh.h <> owh.h) or (wh.v <> owh.v) or not button;			CallWaitNextEventForDrawing;			PenMode(patBic);			DrawAngleControl;			PenMode(patcopy);			DrawAngleBar;			if laser^.treeshape[circletree] then				begin					anglept.h := anglehor - wh.h;					anglept.v := anglever - wh.v;				end			else				begin					AnglePt.h := wh.h - anglehor;					AnglePt.v := wh.v - anglever;				end;{    if anglept.v > -10 then anglept.v := -10;}			if AnglePt.v > 0 then				begin					anglept.v := 0;					anglept.h := anglelen;				end			else if AnglePt.h < 0 then				begin					anglept.v := -anglelen;					anglept.h := 0;				end;			if laser^.treeshape[circletree] & (anglept.h < 2) then				anglept.h := 2;			divid := sqrt(sqr(1.0 * anglept.h) + sqr(1.0 * anglept.v));			anglept.h := LowWord(TruncateValue(40.0 * anglept.h / divid));			anglept.v := LowWord(TruncateValue(40.0 * anglept.v / divid));			if laser^.treeshape[circletree] then				laser^.circleanglept := anglept			else				laser^.nameAnglePt := anglePt;			SetAngleControlBox;			PenMode(patcopy);			DrawAngleControl;			owh := wh;		until not button;	end;{----------------------------------------------------------------------------}	function OnlyChangeTreeWidth: boolean;	begin		OnlyChangeTreeWidth := (laser^.printbranchlengths and (traceshown = traceAllChanges) and laser^.LPPCconstant);	end;{----------------------------------------------------------------------------}	function LaserFilter (theDialog: DialogPtr; var Event: EventRecord; var localItemHit: INTEGER): BOOLEAN;		var			wh, owh: Point;			tev: EventRecord;			adjH, adjV, j: integer;			box, oldtreeB: rect;			treeRgn: RgnHandle;			Lpos: longint;			oldLaserCursor: integer;			inbox: integer;			db: boolean;	begin		GetMouse(wh);		oldLaserCursor := LaserCursor;		if CommandEvent(Event) then			LaserCursor := LaserArrow		else if OptionEvent(Event) then			LaserCursor := LaserFonts		else if ShiftEvent(Event) then			LaserCursor := LaserRuler;		if hasprinted then  {This polls for null events so that control can be passed to the background}			begin				if haswaitnextevent then					db := WaitNextEvent(0, tev, 10, nil)				else					begin{$IFC NOT CARBON}						SystemTask;{$ENDC}						db := GetNextEvent(0, tev);					end;				if db then					hasprinted := false;			end;{======= Cursors =========}		if PtInRect(wh, angleB) and (laser^.postscripton or laser^.treeshape[circletree]) then				SetCursH(handcurs)			else if closeupon and PtInRect(wh, drawbox) then				SetCursID(shrinkMagID)			else if (LaserCursor = lasermag) and PtInRect(wh, drawbox) then				SetCursH(tool^[treeTools,expandT].curs)			else if closeupon then				SetCursorToArrow			else if (LaserCursor = laserruler) and PtInRect(wh, drawbox) then				SetCursID(23847)			else if (LaserCursor = laserFonts) and PtInRect(wh, drawbox) then				SetCursID(1499)			else if PtInRect(wh, LaserBoxes^[legB].R) and ReallyShowLegend(legB) then				SetCursH(handcurs)			else if PtInRect(wh, LaserBoxes^[treenamB].R) and laser^.showbox[treenamB] then				SetCursH(handcurs)			else if PtInRect(wh, LaserBoxes^[treenumB].R) and laser^.showbox[treenumB] then				SetCursH(handcurs)			else if PtInRect(wh, LaserBoxes^[treestatsB].R) and laser^.showbox[treestatsB] then				SetCursH(handcurs)			else if PtInRect(wh, LaserBoxes^[commentB].R) and laser^.showbox[commentB] then				SetCursH(handcurs)			else if PtInRect(wh, treesizeB) then				SetCursorToArrow			else if PtInRect(wh, LaserBoxes^[treeB].R) then				SetCursH(handcurs)			else				SetCursorToArrow;		localItemHit := NotInDialog;{justmag checked to prevent dblclicking on closeupon from remagnifying view}		if not justmag and ((Event.when - oldtime) < GetDblTime) then			dblclick := true;		TreeRgn := NewRgn;		LaserFilter := FALSE;		GlobalToLocal(Event.where);{======= Keydown =========}		if (Event.what = keyDown) then			if HitReturn(Event) then				begin					LaserFilter := true;					localItemHit := PressButton(theDialog, 1);					if not PrinterOK and LaserTreePrint then						localItemHit := 3;{note that button 3 won't flash}				end;{v4:  have a quick way to delete a box by holding down a key, say shift-option, and clicking on it!}{======= mouseDown =========}		if (Event.what = mouseDown) then			begin				justmag := false;				ClipRect(drawbox);				ClipRect(WindowPortRect(myGetWindowPtrForDialog(theDialog)));				if not alreadydone then					begin						SetButtonTitle(theDialog, 2, 'Done');						alreadydone := true;					end;				WriteBottom(theDialog, '');				if PtInREct(event.where, angleB) and (laser^.postscripton or laser^.treeshape[circletree]) then						begin							MouseInAngle(Event.where);							LaserFilter := TRUE;							localItemHit := NotInDialog;							InvalidateWindowRect(myGetWindowPtrForDialog(LaserTreeDialog),previewB,false);						end					else if PtInREct(event.where, LaserCursorR[lasermag]) then						ClickInCursorR(lasermag, oldlaserCursor)					else if PtInREct(event.where, LaserCursorR[laserarrow]) then						ClickInCursorR(laserarrow, oldLaserCursor)					else if PtInREct(event.where, LaserCursorR[laserruler]) then						ClickInCursorR(laserruler, oldLaserCursor)					else if PtInREct(event.where, LaserCursorR[laserFonts]) then						ClickInCursorR(laserFonts, oldlaserCursor)					else if PtInREct(event.where, BranchWidthB) then						MouseInBranchWidth(event.where.v - BranchWidthB.top)					else if PtInRect(event.where, drawbox) and (dblclick or (LaserCursor = lasermag) or closeupon) then						begin							justmag := closeupon;							closeupon := not closeupon;							InsetRect(drawbox, 1, 1);							EraseRect(drawbox);							InsetRect(drawbox, -1, -1);							if closeupon then								begin									closeuppt.v := TruncateValue((event.where.v - pictB.top) / shrink);									closeuppt.h := TruncateValue((event.where.h - pictB.left) / shrink);								end;							InvalidateWindowRect(myGetWindowPtrForDialog(LaserTreeDialog),previewB,false);						end					else if not closeupon and PtInRect(event.where, drawbox) then    {can't do any more things if magnified}						begin							inbox := -1;							for j := 0 to numlaserB do								if PtInRect(event.where, LaserBoxes^[j].R) and (ReallyShowLegend(j) or (j = taxanameB)) then									begin										inBox := j;										leave;									end;							if inbox >= 0 then								if inBox in [treestatsB, commentB, treenamB, treenumB, legB] then									if (LaserCursor = LaserFonts) then										PopUpTextM(inBox, Event.where)									else										MouseInStandardLB(inBox, theDialog, Event.where)								else if (inBox = taxanameB) & (LaserCursor = LaserFonts) then									PopUpTextM(inBox, Event.where)								else if (inBox = treeB) and not PtinRect(event.where, treesizeB) then									if (LaserCursor = LaserFonts) then										PopUpTextM(inBox, Event.where)									else										begin											MouseInLaserBox(theDialog, Event.where, treeB, false, adjH, adjV);											if (adjV <> 0) or (adjH <> 0) then												begin													TSP.v := TSP.v + adjV;													TSP.h := TSP.h + adjH;													firsttx := TSP.h;													topmargin := TSP.v;													InvalidateWindowRect(myGetWindowPtrForDialog(LaserTreeDialog),previewB,false);												end;											ClipRect(WindowPortRect(myGetWindowPtrForDialog(theDialog)));											if LaserCursor = LaserRuler then												with TSP do													WriteBottom(theDialog, concat('left: ', StringFromNum(h), '  top: ', StringFromNum(v)));										end								else if PtInRect(event.where, treesizeB) and not closeupon then {v3.04: removed: and not (laser^.printbranchlengths and (traceshown = traceAllChanges) and laser^.LPPCconstant)}									begin										oldtreeB := LaserBoxes^[treeB].R;										box := LaserBoxes^[treeB].R;										box.right := pictB.right;										box.bottom := pictB.bottom;										owh := event.where;										if LaserCursor = LaserRuler then											with LaserBoxes^[treeB].R do												WriteBottom(theDialog, concat('width: ', StringFromNum(right - left), '  height: ', StringFromNum(bottom - top)));										repeat											owh := wh;											GetMouse(wh);											if OnlyChangeTreeWidth then   {v3.04: }												wh.v := LaserBoxes^[treeB].R.botright.v;											if PtInRect(wh, box) and not EqualPt(wh, owh) then												begin													PenPat(QDBlack);													SetTreeSizeB(true);													PenMode(patXor);													PenPat(QDGray);													FrameRect(LaserBoxes^[treeB].R);													LaserBoxes^[treeB].R.botright := wh;													PenPat(QDGray);													FrameRect(LaserBoxes^[treeB].R);													PenPat(QDBlack);													SetTreeSizeB(true);													if LaserCursor = LaserRuler then														with LaserBoxes^[treeB].R do															WriteBottom(theDialog, concat('width: ', StringFromNum(right - left), '  height: ', StringFromNum(bottom - top)));												end;										until not stilldown;										PenMode(pator);										PenPat(QDBlack);										Lpos := PinRect(box, wh);										wh.v := HighWord(Lpos);										wh.h := LowWord(Lpos);										if not EqualPt(wh, event.where) then											begin												laser^.txsp := TruncateValue((wh.h - oldtreeB.left) / (oldtreeB.right - oldtreeB.left) * laser^.txsp);												if laser^.txsp < 1 then													laser^.txsp := 1;												laser^.versp := TruncateValue((wh.v - oldtreeB.top) / (oldtreeB.bottom - oldtreeB.top) * laser^.versp);												if laser^.versp < 1 then													laser^.versp := 1;												if not laser^.square then													laser^.versp := laser^.txsp;												MakeSpacingsEven;												box := previewB;												box.bottom := WindowPortRect(myGetWindowPtrForDialog(theDialog)).bottom;												InvalidateWindowRect(myGetWindowPtrForDialog(LaserTreeDialog),box,false);												if LaserCursor = LaserRuler then													pleaseWriteBottom := true;											end;									end;						end;				oldtime := event.when;			end;		LocaltoGlobal(Event.where);		ZapRegion(treeRgn);		dblclick := false;		LaserCursor := oldLaserCursor;	end;end.