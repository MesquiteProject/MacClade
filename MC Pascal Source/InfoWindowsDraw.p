unit InfoWindowsDraw;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}interface	uses		QuickDraw, 		Types, Events, QuickDrawText, OSUtils, Menus, TextUtils, Windows,		 Controls, Dialogs, TextEdit, Lists, ToolUtils, Memory, Fonts, Resources, Scrap, 		Globals, MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, 		SetLibInterface, UtilLibInterface, TaxonCHUtil, CharUtil, WriteUtil, TreeUtil, MenuUtil, SpreadUtil,TypeUtil, 		LinkUtil, InfoWindowsUtil, InfoWindowsMisc,  NexusBlocks,MPR,CharPartitions;	function InfoCellBoolean (whichinfo, columnID, ij: longint): boolean;	function InfoCellDouble (whichinfo, columnID, ij: longint): double;	function InfoCellLongint (whichinfo, columnID, ij: longint): longint;	function InfoCellString (whichinfo, whichColumn, ij: longint): str255;	procedure DrawInfoWindowLock (whichInfo: integer);	procedure DrawPictureSymbol (box: rect; id: integer);	procedure PictureSymbolInfo (var width: integer; id: integer);	procedure InnerShadowedBox (box: rect);	procedure DrawSmallTriangleAtPen (lineWidth: integer);	procedure DrawInfoTitle (whichinfo, titleTop, titleHeight: integer; drawNames: boolean);	procedure DrawInfoLine (whichinfo, ij, height: longint; drawNames: boolean);	procedure DrawButtonRow (whichinfo: integer);	procedure DrawInfoWindow (whichinfo: integer; includeNames: boolean);{еееееееееееееееееееееее}implementation {е$S InfoWindows}{v4: have user able to see Weighted character steps in char status window}{-----------------------------------------------------------------------------}	procedure PlotIconAtPoint(iconID: integer; top, left: integer);	var box: rect;		theIcon: CIconHandle;		theBWIcon: Handle;	begin		SetRect(box,left,top,left+32,top+32);		theIcon := GetCIcon(iconID);		if theIcon <> nil then			begin				PlotCIcon(box, theIcon);				DisposeCIcon(theIcon);			end;	end;{-----------------------------------------------------------------------------}	procedure DrawInfoWindowLock (whichInfo: integer);		var			oldBack: RGBColor;	begin		if ColorPort then			SetGrayBackground(oldBack,grayPale)		else			GetBackColor(oldBack);		case whichinfo of				taxinfo,charinfo:					DrawLock2(InfoWindowLockBox(whichInfo), true,true,infoLocked[whichinfo]|Locked(lockData));				wtsetinfo,exsetinfo,typesetinfo:					DrawLock2(InfoWindowLockBox(whichInfo), true,true,infoLocked[whichinfo]|Locked(lockAssumptions));				treeinfo:					DrawLock2(InfoWindowLockBox(whichInfo), true,true,infoLocked[whichinfo]|Locked(lockTrees));			otherwise				DrawLock2(InfoWindowLockBox(whichInfo), true,true,infoLocked[whichinfo]);		end;		SetRGBBackground(oldBack);	end;{-----------------------------------------------------------------------------}		const			expandRightID = 140;			expandDownID = 141;			includeID = 142;			excludeID = 143;			symbolsWidthStandard = 12;{-----------------------------------------------------------------------------}	procedure DrawIncludeExclude (box: rect; id: integer);		var			innerBox: rect;			cornerPos, side: integer;	begin		innerBox := box;		InsetRect(innerBox,4,4);		innerBox.left := innerBox.left+4;		side := (innerBox.bottom-innerBox.top);		if side < 4 then			begin				side := 4;				innerBox.top := box.top+2;			end;		innerBox.right := innerBox.left+side; {make it square}		innerBox.bottom := innerbox.top+side;		if side < 6 then			PenSize(1,1)		else			PenSize(2,2);		case id of 			includeID:				begin					{if not printon then						begin							RGBForeColor(GrayScale(5,2));							PenSize(1,1);							MoveTo(innerBox.left,innerBox.top+(innerBox.bottom-innerBox.top) * 3 div 4-1);							LineTo(innerBox.left + (innerBox.right-innerBox.left) div 4-1,innerBox.bottom-1);							LineTo(innerBox.right-1,innerBox.top);							RGBForeColor(blackRGB);						end;}					MoveTo(innerBox.left,innerBox.top+(innerBox.bottom-innerBox.top) * 3 div 4);					cornerPos := (innerBox.right-innerBox.left) div 4;					LineTo(innerBox.left + cornerPos,innerBox.bottom);					LineTo(innerBox.right,innerBox.top+cornerPos);				end;			excludeID:				begin					MoveTo(innerBox.left,innerBox.top);					LineTo(innerBox.right,innerBox.bottom);					MoveTo(innerBox.right,innerBox.top);					LineTo(innerBox.left,innerBox.bottom);				end;		otherwise;		end;		PenNormal;	end;{-----------------------------------------------------------------------------}	procedure DrawPictureSymbol (box: rect; id: integer);		var			picBox: rect;			picH: PicHandle;			width, height: integer;			left, top: integer;			innerBox: rect;			cornerPos: integer;	begin		if (id=includeID) | (id=excludeID) then			DrawIncludeExclude(box,id)		else			begin				picH := GetPicture(id);				if picH <> nil then					begin						width := picH^^.picFrame.right - picH^^.picFrame.left;						height := picH^^.picFrame.bottom - picH^^.picFrame.top;						if box.right > box.left + width then							left := box.left + (box.right - box.left - width) div 2						else							left := box.left;						if box.bottom > box.top + height then							top := box.top + (box.bottom - box.top - height) div 2						else							top := box.top;						SetRect(picBox, left, top, left + width, top + height);						OffSetRect(picBox, 1, 1);						DrawPicture(picH, picBox);						ReleaseResource(Handle(picH));					end;			end;	end;{-----------------------------------------------------------------------------}	procedure PictureSymbolInfo (var width: integer; id: integer);		var			box: rect;			picH: PicHandle;	begin		picH := GetPicture(id);		if picH <> nil then			width := picH^^.picFrame.right - picH^^.picFrame.left		else			width := 0;		ReleaseResource(Handle(picH));	end;{-----------------------------------------------------------------------------}	procedure DrawResourcePicture (box: rect; id: integer);	var picH: PicHandle;	begin		picH := GetPicture(id);		if picH <> nil then			begin				DrawPicture(picH, box);				ReleaseResource(Handle(picH));			end;	end;{-----------------------------------------------------------------------------}	procedure DrawSmallTriangleAtPen (lineWidth: integer);		var			dR: RgnHandle;			pn: point;			oldColor: RGBColor;	begin		GetPen(pn);		pn.v := lineWidth-8;		DrawSmallTriangle(pn,blackRGB);	end;{-----------------------------------------------------------------------------}	var		minlegal, maxlegal: boolean;{-----------------------------------------------------------------------------}	procedure DrawInfoCellPicture (whichinfo, whichColumn, ij, height: longint);		var			box: rect;			numitems: longint;			drawBox: rect;			infoWindowColumn: infoWindowColumnPtr;	begin		box := InfoCellBox(whichinfo, whichColumn, height);		infoWindowColumn := InfoColumnPtr(whichinfo, whichColumn);		if infoWindowColumn<> nil then		with infoWindowColumn^ do			case whichinfo of				charinfo: 					begin						case columnID of							CharInfoExpand: 								begin									if statesWindowOpen & (statesWindowCharacter = ij) then										DrawPictureSymbol(box, expandDownID)									else										DrawPictureSymbol(box, expandRightID);								end;							CharInfoIncExc: 								begin									if DrawToFile then										begin											if CharIncluded(ij) then												putSingleChar('е');											puttab;										end									else if CharIncluded(ij) then										DrawPictureSymbol(box, includeID)									else										DrawPictureSymbol(box, excludeID);								end;							otherwise								;						end;					end;				taxinfo: 					begin						case columnID of							TaxInfoIncExc: 								begin									if DrawToFile then										begin											if TaxonInTree(ij) then												putSingleChar('е');											puttab;										end									else if TaxonInTree(ij) then										DrawPictureSymbol(box, includeID)									else										DrawPictureSymbol(box, excludeID);								end;							otherwise								;						end;					end;				treeinfo: 					begin						case columnID of							TreeInfoExpand: 								begin									if false then										DrawPictureSymbol(box, expandDownID)									else										DrawPictureSymbol(box, expandRightID);								end;							TreeInfoIncExc: 								begin									if DrawToFile then										begin											putSingleChar('е');											puttab;										end									else if true then										DrawPictureSymbol(box, includeID)									else										DrawPictureSymbol(box, excludeID);								end;							otherwise								;						end;					end;				typeinfo: 					begin						case columnID of							otherwise								;						end;					end;				otherwise					;			end;	end;const	notCalculatedDouble = -2.0;	unknownCalculatedDouble = -1.0;	notCalculatedLongint = -2;	{-----------------------------------------------------------------------------}	function InfoCellDouble (whichinfo, columnID, ij: longint): double;		var			value: double;			charHdl: chHdl;			clen: integer;			dL, dL2: longint;	begin		value := 0.0;		InfoCellDouble := 0.0;		case whichinfo of			charinfo: 				begin					charHdl := GetChHdl(ij);					case columnID of						CharInfoCI:   {CI}							if not CharIncluded(ij) or not minlegal then								value := notCalculatedDouble							else if MultipleStatesLg(CharStatesLargest(ij)) then								begin																		clen := CharSteps(ij);  									if clen < charHdl^^.minlen then										value := unknownCalculatedDouble									else if clen > 0 then										value :=charhdl^^.ci;								end;						CharInfoRI:   {RI}							if not CharIncluded(ij) or not (minlegal and maxlegal) then								value:= notCalculatedDouble							else if MultipleStatesLg(CharStatesLargest(ij)) then								begin																		clen := CharSteps(ij);  									if (clen > charHdl^^.maxlen) or (clen < 0) then										value := unknownCalculatedDouble									else if clen > 0 then										value :=charhdl^^.ri;																		end;						CharInfoRC:   {RC}							if not CharIncluded(ij) or not (minlegal and maxlegal) then								value:= notCalculatedDouble							else if MultipleStatesLg(CharStatesLargest(ij)) then								begin																	clen := CharSteps(ij);  									if (clen > charHdl^^.maxlen) or (clen < 0) then										value := unknownCalculatedDouble									else if clen > 0 then										value := charhdl^^.ri * charHdl^^.ci;;								end;						CharInfoMPRs:   							begin								NumMPRs(ij, value);							end;						otherwise							;					end;				end;			taxinfo: 				begin					case columnID of						TaxInfoLowerCase:							begin								dL := NumLowerCaseInTaxon(ij,taxInfoConsiderAllCharacters);								dL2 := (TotalNumStateCells(ij,taxInfoConsiderAllCharacters));								 if dL2 = 0 then								 	value := notCalculatedDouble								 else								 	value := dL*100.0/dL2;							end;						TaxInfoA:							begin								dL := NumOfStateInTaxon(ij,0,taxInfoConsiderAllCharacters);								dL2 := (TotalNumStateCells(ij,taxInfoConsiderAllCharacters));								 if dL2 = 0 then								 	value := notCalculatedDouble								 else								 	value := dL*100.0/dL2;							end;						TaxInfoC:							begin								dL := NumOfStateInTaxon(ij,1,taxInfoConsiderAllCharacters);								dL2 := (TotalNumStateCells(ij,taxInfoConsiderAllCharacters));								 if dL2 = 0 then								 	value := notCalculatedLongint								 else								 	value := dL*100.0/dL2;							end;						TaxInfoG:							begin								dL := NumOfStateInTaxon(ij,2,taxInfoConsiderAllCharacters);								dL2 := (TotalNumStateCells(ij,taxInfoConsiderAllCharacters));								 if dL2 = 0 then								 	value := notCalculatedLongint								 else								 	value := dL*100.0/dL2;							end;						TaxInfoT:							begin								dL := NumOfStateInTaxon(ij,3,taxInfoConsiderAllCharacters);								dL2 := (TotalNumStateCells(ij,taxInfoConsiderAllCharacters));								 if dL2 = 0 then								 	value := notCalculatedLongint								 else								 	value := dL*100.0/dL2; 							end;						TaxInfoAT:							begin								dL := NumOfStateInTaxon(ij,0,taxInfoConsiderAllCharacters)+NumOfStateInTaxon(ij,3,taxInfoConsiderAllCharacters);								dL2 := (TotalNumStateCells(ij,taxInfoConsiderAllCharacters));								 if dL2 = 0 then								 	value := notCalculatedLongint								 else								 	value := dL*100.0/dL2; 							end;						otherwise							;					end;				end;			otherwise				;		end;		InfoCellDouble := value;	end;{-----------------------------------------------------------------------------}	function InfoCellLongint (whichinfo, columnID, ij: longint): longint;		var			clen: longint;			charHdl: chHdl;			dL, dL2: longint;			value: longint;			ds: str255;	begin		InfoCellLongint := 0;		value:= 0;		case whichinfo of			charinfo: 				begin					charHdl := GetChHdl(ij);					case columnID of						CharInfoWeights:   {weights}							value := CharWeight(ij);						CharInfoStates:  {states}							value := cardLg(CharStatesLargest(ij));						CharInfoSteps:   {steps}							if CharIncluded(ij) then								value := CharSteps(ij)							else								value := notCalculatedLongint;						CharInfoMin:   {min steps}							if not CharIncluded(ij) or not minlegal then								value := notCalculatedLongint							else if MultipleStatesLg(CharStatesLargest(ij)) then								value := charHdl^^.minlen;						CharInfoMax:   {max steps}							if not CharIncluded(ij) or not maxlegal then								value := notCalculatedLongint							else if MultipleStatesLg(CharStatesLargest(ij)) then								value := charHdl^^.maxlen;						CharInfoMissing:							value := NumMissingInCharacter(ij,not treeopen);						CharInfoGaps:							value := NumGapsInCharacter(ij,not treeopen);						CharInfoPartition:   {partition}							value := CharPartition(ij);						otherwise							;					end;				end;			charpartinfo:				begin					case columnID of						CharPartInfoNumParts:							value := NumPartsInPartition(ij);						otherwise;					end;				end;			taxinfo: 				begin					case columnID of						TaxInfoMissing:   							value := NumMissingInTaxon(ij,taxInfoConsiderAllCharacters);						TaxInfoGaps:							value := NumGapsInTaxon(ij,taxInfoConsiderAllCharacters);						TaxInfoSeqLength:							value := SequenceLength(ij,taxInfoConsiderAllCharacters);						TaxInfoStopCodons:							value := NumStopCodonsInTaxon(ij,taxInfoConsiderAllCharacters);						TaxInfoFirstBase:							value := FirstDataInTaxon(ij,taxInfoConsiderAllCharacters);						TaxInfoLastBase:							value := LastDataInTaxon(ij,taxInfoConsiderAllCharacters);						TaxInfoPartTriplets:							value := NumPartTripletsInTaxon(ij,taxInfoConsiderAllCharacters);						TaxInfoUncertainty:							value := NumUncertaintyInTaxon(ij,taxInfoConsiderAllCharacters);						TaxInfoPolymorphism:							value := NumPolymorphismInTaxon(ij,taxInfoConsiderAllCharacters);						otherwise							;					end;				end;			treeinfo: 				begin					case columnID of						TreeInfoNumTaxa:   {number of taxa in tree}							value := GetNumTaxaInLinkTree(LinkNumberFromInfoRow(treeChain,ij),nil); 						otherwise							;					end;				end;			otherwise				;		end;		InfoCellLongint := value;	end;{-----------------------------------------------------------------------------}	function InfoCellBoolean (whichinfo, columnID, ij: longint): boolean;		var			db: boolean;	begin		InfoCellBoolean := false;		case whichinfo of			charinfo: 				begin					case columnID of						CharInfoIncExc: 							db := CharIncluded(ij);						CharInfoPolymorphisms:							db := TerminalMSTaxaInCharacter(ij,treeopen,true);						CharInfoUncertainty:							db := TerminalMSTaxaInCharacter(ij,treeopen,false);						otherwise							;					end;				end;			taxinfo: 				begin					case columnID of						TaxInfoIncExc: 							db:= TaxonInTree(ij);						otherwise							;					end;				end;			treeinfo: 				begin					case columnID of						TreeInfoPoly:   {polytomies}							db := TestLinkBit(treeChain,LinkNumberFromInfoRow(treeChain,ij),nil,polytomybit);						TreeInfoFixAnc:   {fixed ancestors}							db := TestLinkBit(treeChain,LinkNumberFromInfoRow(treeChain,ij),nil,fixancbit);						otherwise							;					end;				end;			typesetinfo:				begin					case columnID of						TypeSetInfoDirected:							db := TypeSetSomeDirected(ij);						TypeSetInfoUserDefined:							db := TypeSetSomeUserDefined(ij);						otherwise;					end;				end;			otherwise				;		end;		InfoCellBoolean := db;	end;{-----------------------------------------------------------------------------}	function InfoCellString (whichinfo, whichColumn, ij: longint): str255;		var			thePos, startDraw, twt: longint;			sH: StringHandle;			ilinks: longint;			ilink: longint;			clen: longint;			charHdl: chHdl;			H: Handle;			hsize: longint;			dL, dL2: longint;			value: double;			ds: str255;			box: rect;			picID, partNumber: integer;			penpt: point;			infoWindowColumn: infoWindowColumnPtr;	begin		picID := 0;		InfoCellString := '';		infoWindowColumn := InfoColumnPtr(whichinfo, whichColumn);		if infoWindowColumn<> nil then		with infoWindowColumn^ do			begin				ds := '';				case whichinfo of					charinfo: 						begin							charHdl := GetChHdl(ij);							case columnID of								CharInfoIncExc: 									begin										 if CharIncluded(ij) then											ds := '+'										else											ds := '-';									end;								CharInfoPolymorphisms:									begin										if TerminalMSTaxaInCharacter(ij,treeopen,true) then											ds := 'е' 										else											ds := '';									end;								CharInfoUncertainty:									begin										if TerminalMSTaxaInCharacter(ij,treeopen,false) then											ds := 'е' 										else											ds := '';									end;								CharInfoWeights:   {weights}									begin										twt := InfoCellLongint(whichinfo,columnid,ij);										if realwt then											ds := RealToIntegerstring(twt, WtInflate)										else											ds := StringFromNum(twt);									end;								CharInfoTypes:   {types}									if charincluded(ij) then										ds := TypeName(TypeOfChar(ij))									else										ds := '(excluded)';								CharInfoStates:  {states}									NumToString(InfoCellLongint(whichinfo,columnid,ij), ds);								CharInfoCodPos:   {codon positions}									if Iscoding(ij) then										begin											thePos := CharCodPos(ij);											if thePos = codeNotSet then												ds := 'C'											else												NumToString(thePos, ds)										end									else										ds := '-';{xxxIFC TRUE}								CharInfoSteps:   {steps}									begin										dL := InfoCellLongint(whichinfo,columnID,ij);										if dL = notCalculatedLongint then											ds := '--'										else											begin												ds := CharStepsString(dL, ij);												if (TypeOfChar(ij) >= usedef) and poly3inchar(ij) then													ds := concat(ds, '*');											end;									end;								CharInfoCI, CharInfoRI, CharInfoRC:   {CI}									begin										value := InfoCellDouble (whichinfo, columnID, ij);										if value = notCalculatedDouble then											ds := '--'										else if value = unknownCalculatedDouble then											ds := '?'										else											RealtoString(value, ds, 10.0, sigindices, CharInfoExpon);									end;								CharInfoMin,CharInfoMax:   {min steps}									begin										dL := InfoCellLongint(whichinfo,columnID,ij);										if dL = notCalculatedLongint then											ds := '--'										else											NumToString(dL, ds);									end;								CharInfoMissing:   									begin										dL := InfoCellLongint(whichinfo,columnID,ij);										 if treeopen then										 	RealtoString(dL*100/numtaxain, ds, 0.0000001, 1, false)										 else										 	RealtoString(dL*100/numtaxa, ds, 0.0000001, 1, false);  									end;								CharInfoGaps:   									begin										dL := InfoCellLongint(whichinfo,columnID,ij);										  if treeopen then										 	RealtoString(dL*100/numtaxain, ds, 0.0000001, 1, false)										 else										 	RealtoString(dL*100/numtaxa, ds, 0.0000001, 1, false);  									end;								CharInfoChgs:   {changes}									if not CharIncluded(ij) | (Typeofchar(ij) = fisher) then										ds := '--'									else										begin											NumToString(charHdl^^.minchg, ds);											if charHdl^^.minchg < charHdl^^.maxchg then												ds := concat(ds, '-', StringFromnum(charHdl^^.maxchg));										end;								CharInfoMPRs:   {changes}									begin										value := InfoCellDouble(whichinfo,columnID,ij);										if value < 10000.0 then											begin												dL := RoundValue(value);												ds := StringFromNum(dL);											end										else											RealtoString(value, ds, 10000, 3, true);  									end;								CharInfoPartition:   {partition}									begin										partNumber := CharPartition(ij);										if partNumber = 1 then											ds := '-'										else											ds := NameOfCharPartNameFromNumber(partNumber);									end;{xxxENDC}								otherwise									;							end;						end;					taxinfo: 						begin							case columnID of								TaxInfoIncExc: 									begin										if TaxonInTree(ij) then											ds := '+'										else											ds := '-';									end;								TaxInfoMissing,TaxInfoGaps:   									begin										dL := InfoCellLongint(whichinfo,columnID,ij);										if not taxInfoConsiderAllCharacters then											RealtoString(dL*100/numcharin, ds, 0.0000001, 1, false)										else											RealtoString(dL*100/numchars, ds, 0.0000001, 1, false); 									end;								TaxInfoSeqLength:									begin										dL := InfoCellLongint(whichinfo,columnID,ij);										ds:= StringFromNum(dL);									end;								TaxInfoA,TaxInfoC,TaxInfoG,TaxInfoT,TaxInfoAT, TaxInfoLowerCase:									begin										value :=  InfoCellDouble(whichinfo,columnID,ij);										 if value = notCalculatedDouble then										 	ds := '--'										 else										 	RealtoString(value, ds, 0.0000001, 1, false);  									end;								TaxInfoStopCodons:									begin										dL := InfoCellLongint(whichinfo,columnID,ij);										ds:= StringFromNum(dL);									end;								TaxInfoFirstBase, TaxInfoLastBase, TaxInfoPartTriplets, TaxInfoUncertainty, TaxInfoPolymorphism:									begin										dL := InfoCellLongint(whichinfo,columnID,ij);										ds:= StringFromNum(dL);									end;								otherwise									;							end;						end;					treeinfo: 						begin							case columnID of								TreeInfoNumTaxa:   {number of taxa in tree}									ds := StringFromNum(InfoCellLongint(whichinfo,columnid,ij)); 								TreeInfoPoly:   {polytomies}									{if GetTreeInList(CurrentTreeList, ij)^.haspolys then}									if TestLinkBit(treeChain,LinkNumberFromInfoRow(treeChain,ij),nil,polytomybit) then										ds := 'е'									else										ds := '';								TreeInfoFixAnc:   {fixed ancestors}									if TestLinkBit(treeChain,LinkNumberFromInfoRow(treeChain,ij),nil,fixancbit) then										ds := 'е';								otherwise									;							end;						end;					wtsetinfo:						begin							case columnID of								WtSetInfoMinWt:									ds := MinWeightInSet(ij);								WtSetInfoMaxWt:									ds := MaxWeightInSet(ij);							{	WtSetInfoReal:									if TestLinkBit(wtsetchain,ij + PreDefLinks[wtsetchain] - 1,nil,wtrealbit) then										ds := 'е';}								otherwise;							end;						end;					charpartinfo:						begin							case columnID of								CharPartInfoNumParts:									ds := StringFromNum(InfoCellLongint(whichinfo,columnid,ij));								otherwise;							end;						end;					exsetinfo:						begin							case columnID of								ExSetInfoNumberChars: 									ds := StringFromNum( GetNumberElementsInLink(exsetchain,LinkNumberFromInfoRow(exsetchain,ij),nil));								otherwise;							end;						end;					charsetinfo:						begin							case columnID of								CharSetInfoNumberChars: 									ds := StringFromNum( GetNumberElementsInLink(charsetchain,LinkNumberFromInfoRow(charsetchain,ij),nil));								otherwise;							end;						end;					taxsetinfo:						begin							case columnID of								TaxSetInfoNumberTaxa: 									ds := StringFromNum(GetNumberElementsInLink(taxsetchain,LinkNumberFromInfoRow(taxsetchain,ij),nil));								otherwise;							end;						end;					nexusBlockInfo:						begin							case columnID of								NexusBlockInfoForeign:									if not NexusBlockForeign(ij) then										ds := 'е';								NexusBlockInfoWithForeignLines:									if ForeignLinesInBlockNumber(ij) then										ds := 'е';								NexusBlockInfoWillWrite:									if NexusBlockWillWrite(ij) then										ds := 'е';								NexusBlockInfoTitle:									{if NexusBlockForeign(ij) then										ds := '-'									else}										ds := NexusBlockTitle(ij);								NexusBlockInfoLinkText:									{if NexusBlockForeign(ij) then										ds := '-'									else}										ds := NexusBlockLinkText(ij);								otherwise;							end;						end;					typesetinfo:						begin							case columnID of								TypeSetInfoDirected:									if TypeSetSomeDirected(ij) then										ds := 'е';								TypeSetInfoUserDefined:									if TypeSetSomeUserDefined(ij) then										ds := 'е';								otherwise;							end;						end;					typeinfo: 						begin							case columnID of								TypeInfoCategory: 									{case getTypeHdl(NewTypeFromOld(ij))^^.category of										discreteMatrixType: 											ds := 'discrete cost matrix';										realMatrixType: 											ds := 'continuous cost matrix';										stratigraphicType: 											ds := 'stratigraphic';										cstreeType: 											ds := 'character state tree';										otherwise}											ds := TypeName(ij);									{end;}								otherwise									;							end;						end;					otherwise						;				end;				InfoCellString := ds;			end;	end;{-----------------------------------------------------------------------------}	procedure DrawInfoCellString (whichinfo, whichColumn, ij, height: longint);		var			thePos, startDraw, twt: longint;			sH: StringHandle;			ilinks: longint;			ilink: longint;			clen: longint;			charHdl: chHdl;			H: Handle;			hsize: longint;			dL: longint;			ds: str255;			box: rect;			picID: integer;			penpt: point;			infoWindowColumn: infoWindowColumnPtr;	begin		picID := 0;		infoWindowColumn := InfoColumnPtr(whichinfo, whichColumn);		if infoWindowColumn<> nil then		with infoWindowColumn^ do			begin				ds := InfoCellString(whichinfo,whichColumn,ij);{======== end cell entries =========}				if DrawToFile then					begin						puttoken(ds);						puttab;					end				else					begin						startDraw := left + ((right - left) - StringWidth(ds)) div 2;						if startDraw < left then							startDraw := left;						if whichColumn > infoName then							startDraw := startDraw - infoLeft[whichinfo] + 1;						moveto(startDraw, height - 3);						DrawString(ds);						if picID <> 0 then							begin								box := InfoCellBox(whichinfo, whichColumn, height);								GetPen(penpt);								box.left := penpt.h + 2;								DrawPictureSymbol(box, picID);							end;					end;			end;	end;{-----------------------------------------------------------------------------}	procedure DrawInfoCellColor (whichinfo, whichColumn, ij, height: longint);		var			box: rect;			theColor: RGBColor;			oldBack: RGBColor;			colorFound : boolean;			infoWindowColumn: infoWindowColumnPtr;	begin		infoWindowColumn := InfoColumnPtr(whichinfo, whichColumn);		if infoWindowColumn<> nil then		with infoWindowColumn^ do			begin				colorFound := false;				theColor := whiteRGB;				case whichinfo of					charpartnameinfo: 						case columnID of							CharPartNameInfoColor :								begin									theColor := GetPartNameColor(ij);									colorFound := true;								end;							otherwise;						end;					otherwise ;				end;				if colorFound then					begin						box := InfoCellBox(whichinfo, whichColumn, height);						//InsetRect(box,2,2);						GetBackColor(oldBack);						SetRGBBackground(theColor);						EraseRect(box);						SetRGBBackground(oldBack);					end;			end;	end;{-----------------------------------------------------------------------------}	procedure InnerShadowedBox (box: rect);	begin		FrameRect(box);		MoveTo(box.left, box.bottom - 1);		LineTo(box.right - 1, box.bottom - 1);		LineTo(box.right - 1, box.top + 1);	end;{-----------------------------------------------------------------------------}	procedure DrawInfoLineNumber(whichinfo, ij, height: longint);	var	box: rect;	begin		box := InfoCellBox(whichinfo, infoName, height);		box.left := 0;		box.right := infoNameStart[whichinfo] - 1;		box.bottom := box.bottom+1;		{InsetRect(box, -1, -1);}				DressUpBox(box);		TextFace(infoStyle[whichinfo] + [bold]);		moveto(box.left + ((box.right - box.left) - (StringWidth(StringFromNum(ij)))) div 2, box.bottom - 3);		DrawString(StringFromNum(ij));		TextFace(infoStyle[whichinfo]);		{InnerShadowedBox(box);}	end;{-----------------------------------------------------------------------------}	procedure SetLineTinge(whichinfo: integer; ij: longint; var oldBack: RGBColor);	var theTinge: integer;	begin		if not printon & ColorPort then			begin				theTinge := infoTinge;				if ij = InfoRowOfCurrentObject(whichinfo) then					theTinge := infoCurrentTinge;				GetRGBSetTingeBackground(oldBack, theTinge);			end		else			GetBackColor(oldBack);	end;{-----------------------------------------------------------------------------}	procedure DrawInfoLine (whichinfo, ij, height: longint; drawNames: boolean);		var			ici, ir: longint;			box, cellbox: rect;			clenp: LIP;			cstatesP: Ptr;			prevClip: RgnHandle;			lockedName: boolean;			objectNumber: longint;			oldBack: RGBColor;			theColumn: integer;			infoColPtr: infoWindowColumnPtr;			oldClip: RgnHandle;			infoWindowColumn: infoWindowColumnPtr;	begin{query: what about infoLeft and printing??}{note: don't get and set ports, as this messes up textfile output and printing}		if whichinfo = treeinfo then			objectNumber := ij		else			objectNumber := ij;		TextFont(infoFont[whichinfo]);		TextSize(infoFontSize[whichinfo]);		if drawNames then			begin{============  Number ===========}				if not DrawToFile then					DrawInfoLineNumber(whichinfo, ij, height);{============  Name ===========}				infoWindowColumn := InfoColumnPtr(whichinfo, infoName);				if infoWindowColumn<> nil then				if infoWindowColumn^.show then					with infoWindowColumn^ do						if DrawToFile then							begin								puttoken(StringFromNum(ij));								putSingleChar('.');								puttab;								puttoken(InfoNameString(whichinfo, ij));								puttab;							end						else							begin								lockedName := infoLocked[whichInfo] or InfoNameLocked(whichinfo, ij);{$IFC COLORINFOBACKGROUND}								if lockedName & not printon then									SetLineTinge(whichinfo,ij, oldBack);{$ENDC}								prevClip := NewRgn;								GetClip(prevClip);								box := InfoCellBox(whichinfo, infoName, height);								ClipRect(box);								Eraserect(box);								if lockedName & not printon then{$IFC COLORINFOBACKGROUND}									if not WindowInColor(infowindow[whichinfo]) then										TextFace([underline]);{$ELSEC}								TextFace([underline]);{$ENDC}								moveto(left + 3, height - 3);								if InfoRowDimmed(whichinfo,ij) & not drawToFile & not printon then									RGBForeColor(GrayScale(5,3));								drawstring(InfoNameString(whichinfo, ij));								RGBForeColor(blackRGB);								MoveTo(box.right - 1, box.top);								LineTo(box.right - 1, box.bottom + 1);								if infoEditing[whichinfo] & (infoEditRow[whichinfo] = ij) & not printon then									TEUpdate(box, infoTE[whichinfo]);								SetClip(prevClip);								ZapRegion(prevClip);{$IFC COLORINFOBACKGROUND}								if lockedName & not printon then									SetRGBBackground(oldBack);{$ENDC}								TextFace([]);							end;			end;{$IFC COLORINFOBACKGROUND}		if not printon then			SetLineTinge(whichinfo,ij, oldBack);{$ENDC}		if whichInfo = charinfo then			begin{$IFC TRUE}				minlegal := MinMaxLenLegalChar(ij, minlength);				maxlegal := MinMaxLenLegalChar(ij, maxlength);{$ENDC}			end;		if not DrawToFile & not printon then{if infoLeft[whichInfo] > 1 then}			begin				oldClip := NewRgn;				GetClip(OldClip);				SetRect(cellbox, InfoColumnRight(whichinfo, infoName) + 1, 0, infoDrawRect[whichinfo].right - scrollwidth - 1, infoDrawRect[whichinfo].bottom);				ClipRect(cellbox);			end;		if InfoRowDimmed(whichinfo,ij) & not drawToFile then			RGBForeColor(GrayScale(5,3));		for theColumn := 1 to MaximumInfoColumns(whichinfo) do			begin				infoColPtr := infoColumnPtr(whichinfo, theColumn);				if (infoColPtr <> nil) & infoColPtr^.show then					begin						if not DrawToFile then							begin								box := InfoCellBox(whichinfo, theColumn, height);								Eraserect(box);							end;						if infoColPtr^.columnType=columnIsColor then							DrawInfoCellColor(whichInfo, theColumn, objectNumber, height)						else if infoColPtr^.isString then							DrawInfoCellString(whichInfo, theColumn, objectNumber, height)						else 								DrawInfoCellPicture(whichInfo, theColumn, objectNumber, height);					end;			end;				if not DrawToFile & not printon then{if infoLeft[whichInfo] > 1 then}			begin				SetClip(OldClip);				RGBForeColor(blackRGB);			end;{$IFC COLORINFOBACKGROUND}		if not printon then			SetRGBBackground(oldBack);{$ENDC}{=======================}		if not DrawToFile then			begin				if ij <> MaximumInfoRows(whichinfo) then					PenPat(QDltGray);				moveto(InfoColumnLeft(whichinfo, infoName), height);{ClipRect(WindowPortRect(QDThePort));}{    LineTo(infoDrawRect[whichinfo].right - scrollwidth - 2, height);}				GridLineTo(infoDrawRect[whichinfo].right - scrollwidth - 2, height, false);{ThinLine(InfoColumnLeft(whichinfo,infoName), height, infoDrawRect[whichinfo].right - scrollwidth - 2, height);}				PenPat(QDBlack);				if not DrawToFile and not DrawNames then					ClipRect(cellbox);				if (frontwindow = infoWindow[whichinfo]) & not printon then					if InfoRowSelected(whichinfo, ij) then{$IFC COLORINFOBACKGROUND}						InvertRect(InfoRowBox(whichinfo, height));{$ELSEC}				InvertHiliteRect(InfoRowBox(whichinfo, height));{$ENDC}			end		else			putreturn;		if not DrawToFile & not printon then{if infoLeft[whichInfo] > 1 then}			begin				SetClip(OldClip);				ZapRegion(oldClip);			end;		PenNormal;{    textfont(TWFont);}	end;{-----------------------------------------------------------------------------}	procedure DrawInfoGrayBoxes (whichinfo, titleHeight: integer);		var			box: rect;			oldBack: RGBColor;			oldClip: RgnHandle;	begin		if ColorPort then			SetGrayBackground(oldBack,grayPlain)		else			GetBackColor(oldBack);		SetRect(box, infoDrawRect[whichinfo].right - scrollwidth - 2, 0, WindowPortRect(infowindow[whichInfo]).right, titleHeight + 2);		oldClip := NewRgn;		GetClip(OldClip);		ClipRect(box);		EraseRect(box);		SetRect(box,myGetControlRect(infoHScroll[whichinfo]).right,myGetControlRect(infoHScroll[whichinfo]).top,WindowPortRect(infowindow[whichInfo]).right,myGetControlRect(infoHScroll[whichinfo]).bottom);		ClipRect(box);		EraseRect(box);		SetClip(oldClip);		SetRGBBackground(oldBack);	end;{-----------------------------------------------------------------------------}	procedure DrawInfoTitle (whichinfo, titleTop, titleHeight: integer; drawNames: boolean);		var			j: longint;			box: rect;			oldBack: RGBColor;			oldClip: RgnHandle;			startCol: integer;			infoWindowColumn: infoWindowColumnPtr;	begin		if not printon & ColorPort then			SetGrayBackground(oldBack,grayPlain)		else			GetBackColor(oldBack);		if drawNames then			SetRect(box, 0, titleHeight - infoLW[whichinfo], infoDrawRect[whichinfo].right - scrollwidth - 2, titleHeight + 2)		else			SetRect(box, InfoColumnRight(whichinfo, infoname), titleHeight - infoLW[whichinfo], infoDrawRect[whichinfo].right - scrollwidth - 2, titleHeight + 2);		if not DrawToFile then{if infoLeft[whichinfo] > 1 then}			begin				oldClip := NewRgn;				GetClip(OldClip);			end;		EraseRect(box);		box.left := InfoColumnRight(whichinfo, infoName);		textface([bold]);		textfont(infoFont[whichinfo]);		if drawNames then			startCol := 0		else   {hor scroll}			startCol := infoName + 1;		for j := startCol to MaximumInfoColumns(whichInfo) do			begin				infoWindowColumn := InfoColumnPtr(whichinfo, j);				if infoWindowColumn<> nil then					with infoWindowColumn^ do						if show then							if DrawToFile then								begin									puttab;									puttoken(title);								end							else								begin									if (j > infoName) then {and (infoLeft[whichinfo] > 1)}										begin											ClipRect(box);											moveto(left + ((right - left) - StringWidth(title)) div 2 - infoLeft[whichinfo] + 1, titleHeight);										end									else										moveto(left + ((right - left) - StringWidth(title)) div 2, titleHeight);									DrawString(title);									if not printon and menu then										if not (Locked(lockAssumptions) & (whichinfo=charinfo) & (columnID<>infoName)) then											DrawSmallTriangleAtPen(infoLW[whichinfo]);								end;			end;		if not DrawToFile then			begin{if infoLeft[whichinfo] > 1 then}				SetClip(OldClip);				ZapRegion(oldClip);				moveto(0, titleHeight + 2);				PenNormal;				LineTo(infoDrawRect[whichinfo].right - scrollwidth - 2, titleHeight + 2);				if not printon then					begin						MoveTo(infoDrawRect[whichinfo].right - scrollwidth - 1, 0);						Line(0, infoDrawRect[whichinfo].bottom);					end;				MoveTo(InfoColumnRight(whichinfo, infoName), titleTop);				Line(0, titleHeight + 2);			end		else			putreturn;		textface([]);{textfont(genevafont);}		if not printon then			SetRGBBackground(oldBack);	end;{-----------------------------------------------------------------------------}	procedure DrawButtonRow (whichinfo: integer);	var buttonRowBox: rect;		box: rect;		oldBack: RGBColor;		j: longint;	begin		{SetGrayBackground(oldBack,grayPale);}		buttonRowBox := infoButtonRowBox(whichinfo);		{EraseRect(buttonRowBox);}		FrameRect(buttonRowBox);				for j := 0 to numInfoTools do			begin				{if currentInfoTool[whichinfo]=j then}				DrawToolBox(infoTools^[whichinfo,j].R,true);				if infoTools^[whichinfo,j].cursorID = 0 then					DropCursor(ArrowCursor, infoTools^[whichinfo,j].R.left+6, infoTools^[whichinfo,j].R.top+3, srcor)				else 					if infoTools^[whichinfo,j].hasOptionCursor & OptionIsDown then						DropCursorID(infoTools^[whichinfo,j].optionCursorID, infoTools^[whichinfo,j].R.left+3, infoTools^[whichinfo,j].R.top+3, srcor)					else if infoTools^[whichinfo,j].hasControlCursor & ControlDown then						DropCursorID(infoTools^[whichinfo,j].controlCursorID, infoTools^[whichinfo,j].R.left+3, infoTools^[whichinfo,j].R.top+3, srcor)					else						DropCursorID(infoTools^[whichinfo,j].cursorID, infoTools^[whichinfo,j].R.left+3, infoTools^[whichinfo,j].R.top+3, srcor);				if not infoTools^[whichinfo,j].enabled then					DimBox(infoTools^[whichinfo,j].R);				{FrameRect (infoTools^[whichinfo,j].R);}				if currentInfoTool[whichinfo]=j then					InvertInsideRect(infoTools^[whichinfo,j].R);			end;				//	if infoWithButtons[whichinfo] & ((whichinfo<>charinfo)|treeopen) then	//		 DrawResourcePicture (InfoUseButtonBox[whichinfo], InfoWindowButtonResID(whichinfo)); 		if infoWithButtons[whichinfo] & ((whichinfo<>charinfo)|treeopen) then			 ShowControl (infoWindowButton[whichinfo]); 		{PenMode(Copy);}	{	SetRGBBackground(oldBack);}	end;{-----------------------------------------------------------------------------}	function AnyInfoRowsSortable(whichinfo: integer): boolean;	var theColumn: integer;	begin		AnyInfoRowsSortable := false;		for theColumn := 1 to MaximumInfoColumns(whichinfo) do			if InfoColumnSortable(whichinfo, InfoColumnID(whichinfo, theColumn)) then				begin					AnyInfoRowsSortable := true;					leave;				end;	end;{-----------------------------------------------------------------------------}	function AnyInfoRowsWandable(whichinfo: integer): boolean;	var theColumn: integer;	begin		AnyInfoRowsWandable := false;		for theColumn := 1 to MaximumInfoColumns(whichinfo) do			if InfoColumnWandable(whichinfo, InfoColumnID(whichinfo, theColumn)) then				begin					AnyInfoRowsWandable := true;					leave;				end;	end;{-----------------------------------------------------------------------------}	procedure DrawInfoWindow (whichinfo: integer; includeNames: boolean);		var			ir, ic, numElements: longint;			tport: WindowPtr;			oldBack: RGBColor;			drawNames: boolean;			box: rect;	begin		allowCursorChange := false;		numElements := MaximumInfoRows(whichinfo);		drawNames := includeNames or infoDirtyNames[whichinfo];		infoTools^[whichinfo,infoScissorsT].enabled := InfoRowsDeletable(whichinfo);		infoTools^[whichinfo,infoWandT].enabled := AnyInfoRowsWandable(whichinfo);		infoTools^[whichinfo,infoSortDescendingT].enabled := AnyInfoRowsSortable(whichinfo);		infoTools^[whichinfo,infoSortAscendingT].enabled := infoTools^[whichinfo,infoSortDescendingT].enabled;		SetCursor(clockCursor);		genericGetPort(tport);		genericSetPort(infoWindow[whichinfo]);		ClipRect(WindowPortRect(infowindow[whichInfo]));	{	ClipRect(infoDrawRect[whichinfo]);}		if drawNames then			begin				if ColorPort then					SetGrayBackground(oldBack,grayPale)				else					GetBackColor(oldBack);				EraseRect(InfoWindowMessageBox(whichinfo));				SetRGBBackground(oldBack);			end;					if not printon and not DrawToFile then			DrawInfoGrayBoxes(whichinfo,infoLW[whichinfo] - 4);		DrawInfoTitle(whichinfo, 0, infoLW[whichinfo] - 4, drawNames);		if not printon then			begin				moveTo(infoDrawRect[whichinfo].right - scrollwidth, infoLW[whichinfo]);				LineTo(infoDrawRect[whichinfo].right - scrollwidth, infoDrawRect[whichinfo].bottom);				moveTo(0, infoDrawRect[whichinfo].bottom - scrollwidth);				Line(infoNameEnd[whichinfo], 0);			end;		textfont(infoFont[whichinfo]);		ir := 1;		if infoTop[whichinfo] > numElements then			infoTop[whichinfo] := 1;		infoBottom[whichinfo] := infoTop[whichinfo] + infoRows[whichinfo]-1;		ic := infoTop[whichinfo];		if numElements > 0 then			if (ir <= infoRows[whichinfo]) or (ic <= numElements) then				repeat					DrawInfoLine(whichinfo, ic, InfoHeight(whichinfo, ic), drawNames);					ir := ir + 1;					ic := ic + 1;				until (ir > infoRows[whichinfo]) or (ic > numElements);		if not printon & (ir <= infoRows[whichinfo]) & (ic > numElements) then			begin				MoveTo(0,InfoHeight(whichinfo, numElements)+1);				LineTo(infoDrawRect[whichinfo].right-scrollwidth-1, InfoHeight(whichinfo, numElements)+1);				if ColorPort then					SetGrayBackground(oldBack,grayPale)				else					GetBackColor(oldBack);				SetRect(box,0,InfoHeight(whichinfo, numElements)+1,infoDrawRect[whichinfo].right-scrollwidth-1,infoDrawRect[whichinfo].bottom-scrollwidth);				EraseRect(box);				SetRGBBackground(oldBack);			end;{    textfont(genevafont);}		if not printon then			begin				if drawnames then					DrawInfoWindowLock(whichInfo);				DrawGrowBox(infoWindow[whichinfo]);				if infoWithToolRow[whichinfo] then					DrawButtonRow(whichinfo);			end;		myValidRect(infoWindow[whichinfo],infoDrawRect[whichinfo]);		genericSetPort(tport);		allowCursorChange := true;	end;end.