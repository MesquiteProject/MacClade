unit CHUNK;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface, 		 MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, CharUtil, TreeUtil, 		 TypeUtil, ReadUtil,NexusBlocks;	function CHUNKelements (CHUNKHandleBlock: Handle): longint;	procedure AddCHUNKs (CHUNKHandleBlock: Handle; quantity: longint; sizeofchunks: longint);	procedure InsertCHUNKs (CHUNKHandleBlock: Handle; where, quantity: longint; sizeofchunks: longint);{procedure TEtoCHUNK (TE: TEHandle; CHUNKHandleBlock: Handle; CHUNKnumber: integer);}	procedure copyCHUNK (fromCHUNKs, toCHUNKs: Handle; fromCHUNK, toCHUNK: longint);	procedure copyCHUNKs (fromCHUNKs, toCHUNKs: Handle; startnum, endnum: longint);	procedure MoveHandlePieces (H: Handle; piecesize, pstart, pend, too, offset: longint);	procedure DeleteCHUNKs (CHUNKHandleBlock: Handle; CHUNKnumber, quantity: longint);	procedure DestroyCHUNKs (CHUNKHandleBlock: Handle);	procedure DestroyChain (theChain: Integer);	procedure DestroyAllCharacterChains;	procedure RemoveLink (theChain: Integer; theLink: longint);	procedure DataToTreeChain;	function AsteriskPresent (tH: Handle): boolean;	procedure ReadstrCHUNK (theCHUNKs: Integer);	procedure LoadCHUNK;{еееееееееееееееееееееее}implementation{CHUNK memory storage in MacClade: }{several structures in MacClade use what we call the CHUNK system. These}{include the chains of links (wtsets, typesets, exsets, charsets, trees)}{statenames, the basic taxon and character storage, and storage}{of information about each character}{the chunk system works like this:   }{ there is a block of memory,  whose size is HandleSize * (number of chunks)}{This block of memory is full of (number of chunks) handles, each a 4-byte longint}{Thus, if there are 5 chunks, the block of memory will look like this:}{    ----     :  Handle to chunk system}{      |         }{    ---- ---- ---- ---- ----     :  Handles to storage of each CHUNK or LINK  }{each of these handles points to a storage location, where the basic information is stored:}{    ---- ---- ---- ---- ---- }{       |        \                                                                                            }{       |           \                                                                                        }{       |               \                                                                                    }{       |                  \                                                                                  }{    ----------- ----------- ----------- ----------- -----------  } {е$S CHUNK}{----------------------------------------------------------------------------}	function CHUNKelements (CHUNKHandleBlock: Handle): longint;	begin		CHUNKelements := GetHandleSize(CHUNKHandleBlock) div HdlSize;	end;{----------------------------------------------------------------------------}	procedure AddCHUNKs (CHUNKHandleBlock: Handle; quantity: longint; sizeofchunks: longint);{adds QUANTITY chunks of size SIZEOFCHUNKS to the end of CHUNKHandleBlock}		var			k, oldCHUNKs, numadded: longint;			dhp: HdlPtr;			oldstate: SignedByte;	begin		oldCHUNKs := GetHandleSize(CHUNKHandleBlock) div HdlSize;		UnlockHandle(CHUNKHandleBlock, oldstate);		SetHandleSize(CHUNKHandleBlock, HdlSize * ord4(oldCHUNKS + quantity));  {adding room for the Handles}		if not MemoryOK then			Exit(AddCHUNKS);		HLock(CHUNKHandleBlock);		dhp := HdlPtr(GetMaster(CHUNKHandleBlock) + HdlSize * ord4(oldCHUNKs));		for k := 1 to quantity do			begin				dhp^ := NewHandle(sizeofchunks);      {creating the new LINKS or CHUNKS}				if not MemoryOK then					begin						numadded := k - 1;						Leave;					end;				dhp := HdlPtr(ord4(dhp) + HdlSize);			end;		if badmemory then			begin				HUnLock(CHUNKHandleBlock);				SetHandleSize(CHUNKHandleBlock, HdlSize * ord4(oldCHUNKS + numadded));			end;		ResetHandle(CHUNKHandleBlock, oldstate);	end;{----------------------------------------------------------------------------}	procedure InsertCHUNKs (CHUNKHandleBlock: Handle; where, quantity: longint; sizeofchunks: longint);{inserts 'quantity' CHUNKS just beside CHUNK number 'where' in the CHUNKHandleBlock}		var			k, numadded, L1, L2: longint;			ds: str255;			dL: longint;			dhp: HdlPtr;			dsLoc : Ptr;			oldstate: SignedByte;	begin		ds := '   ';		UnlockHandle(CHUNKHandleBlock, oldState);{insert a piece into the CHUNKHandleBLOCK, filled with junk:}		L1:=  ord4(HdlSize * ord4(where - 1));		L2 := ord4(ord4(quantity) * HdlSize);		//if where-1<1 then where:= 2;//		dL := Munger(CHUNKHandleBlock, L1, dsLoc, 0,dsLoc, L2);		InsertEmptyPieceIntoHandle(CHUNKHandleBlock, L1, L2);		Hlock(CHUNKHandleBlock);		dhp := HdlPtr(GetMaster(CHUNKHandleBlock) + ord4(HdlSize * ord4(where - 1)));		for k := 1 to quantity do			begin				dhp^ := NewHandle(sizeofchunks);				if not MemoryOK then					begin						numadded := k - 1;						Leave;					end;				dhp := HdlPtr(ord4(dhp) + HdlSize);			end;		if badmemory then			begin{note that this will probably not be used, as InsertCHUNKS is only called in RowColumn.p, where it is protected}{remove quantity-numadded units, beginning at where + numadded -1 from start}				HUnlock(CHUNKHandleBlock);				DeletePieceOfHandle(CHUNKHandleBlock, HdlSize * ord4(where + numadded - 1), ord4(quantity - numadded) * HdlSize);			end;		ResetHandle(CHUNKHandleBlock, oldstate);	end;{----------------------------------------------------------------------------}	procedure copyCHUNK (fromCHUNKs, toCHUNKs: Handle; fromCHUNK, toCHUNK: longint);{this procedure copies one chunk, number FromCHUNK, from the chunkblock fromCHUNKs,}{to the single chunk (number toCHUNK) in the toCHUNKs chunkblock}		var			fromH, toH: Handle;			dL: longint;			oldstate: SignedByte;	begin		fromH := HdlPtr(GetMaster(fromCHUNKs) + HdlSize * ord4(fromCHUNK - 1))^; 		{from Link Handle}		toH := HdlPtr(GetMaster(toCHUNKs) + HdlSize * ord4(toCHUNK - 1))^; 					{to Link Handle}		CopyHandles(fromH, toH);		HdlPtr(GetMaster(toCHUNKs) + HdlSize * ord4(toCHUNK - 1))^ := toH;//		LockHandle(fromH, oldstate);//		ReplaceHandleContentsWithPointer(toH, Pointer(GetMaster(fromH)), GetHandleSize(fromH));//		ResetHandle(fromH, oldstate);	end;{----------------------------------------------------------------------------}	procedure copyCHUNKs (fromCHUNKs, toCHUNKs: Handle; startnum, endnum: longint);{this procedure copies all chunks from startnum to endnum from the chunkblock fromCHUNKS}{to the SAME chunks in the chunkblock toCHUNKs}		var			thisCHUNK: longint;	begin		for thisCHUNK := startnum to endnum do			copyCHUNK(fromCHUNKs, toCHUNKs, thisCHUNK, thisCHUNK);	end;{----------------------------------------------------------------------------}	procedure MoveHandlePieces (H: Handle; piecesize, pstart, pend, too, offset: longint);{moves chunks from pstart to pend to new position too}		var			numpieces: longint;			sz: longint;			dL: longint;			ddH: Handle;			dp: Ptr;			oldstate: SignedByte;	begin		numpieces := pend - pstart + 1;		sz := numpieces * piecesize;		LockHandle(H, oldstate);		dp := Pointer(GetMaster(H) + offset + piecesize * ord4(pstart - 1));		currentIOPosition := 63;   {v3.05}		if OSSuccessful(PtrToHand(dp, ddH, sz)) then			begin				HUnlock(H);				DeletePieceOfHandle(H, offset + piecesize * ord4(pstart - 1), sz);				if pstart <= too then					too := too - numpieces + 1;				Hlock(ddH);				InsertPieceIntoHandle(H, offset + piecesize * ord4(too - 1), Pointer(GetMaster(ddH)), sz);				ResetHandle(H, oldstate);				HUnlock(ddH);				ZapHandle(ddH);			end		else			ResetHandle(H, oldstate);	end;{----------------------------------------------------------------------------}	procedure DeleteCHUNKs (CHUNKHandleBlock: Handle; CHUNKnumber, quantity: longint);{note that CHUNKnumber is 1-based!!!!}		var			dL: longint;			j: longint;			dhp: HdlPtr;			oldstate: SignedByte;	begin		if GetHandleSize(CHUNKHandleBlock) >= HdlSize then			begin				LockHandle(CHUNKHandleBlock, oldstate);				dhp := HdlPtr(GetMaster(CHUNKHandleBlock) + HdlSize * ord4(CHUNKnumber - 1));				for j := 1 to quantity do					begin						ZapHandle(dhp^);						dhp := HdlPtr(ord4(dhp) + HdlSize);					end;				HUnlock(CHUNKHandleBlock);				DeletePieceOfHandle(CHUNKHandleBlock, HdlSize * ord4(CHUNKnumber - 1), ord4(quantity) * HdlSize);				ResetHandle(CHUNKHandleBlock, oldstate);			end;	end;{----------------------------------------------------------------------------}	procedure DestroyCHUNKs (CHUNKHandleBlock: Handle);	begin		DeleteCHUNKs(CHUNKHandleBlock, 1, GetHandleSize(CHUNKHandleBlock) div HdlSize);		ZapHandle(CHUNKHandleBlock);	end;{----------------------------------------------------------------------------}	procedure RemoveLink (theChain: Integer; theLink: longint);{removes a specific link in a chain}	begin		DeleteChunks(strchunks[theChain], theLink + 1, 1);		if Defaultlink[theChain] = theLink then			Defaultlink[theChain] := -1		else if theLink < Defaultlink[theChain] then  {v3.05}			Defaultlink[theChain] := Defaultlink[theChain] - 1;				UserLinks[theChain] := UserLinks[theChain] - 1;	end;{----------------------------------------------------------------------------}	procedure DestroyChain (theChain: Integer);{empties all userlinks from a chain}	begin		if UserLinks[theChain] > 0 then			begin				DeleteChunks(strChunks[theChain], StartUserLink(theChain) + 1, UserLinks[theChain]);				if theChain in [datafilechain, treefilechain] then					defaultlink[thechain] := -1				else					defaultLink[theChain] := 0;				UserLinks[theChain] := 0;			end;	end;{----------------------------------------------------------------------------}	procedure DestroyAllCharacterChains;{destroys all charset, exset, typeset, wtset}	begin		DestroyChain(CharPartitionchain);		DestroyChain(wtsetchain);		DestroyChain(typesetchain);		DestroyChain(exsetchain);		DestroyChain(charsetchain);	end;{||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}{----------------------------------------------------------------------------}	procedure DataToTreeChain;{copies all elements in datatreechain to treefilechain}	begin		UserLinks[treefilechain] := UserLinks[datafilechain];		AddCHUNKs(strCHUNKs[treefileChain], UserLinks[treefileChain], 2);		if badmemory then			UserLinks[treefilechain] := CHUNKelements(strCHUNKs[treefileChain]);  {reset UserLinks}		CopyCHUNKs(strCHUNKs[datafileChain], strCHUNKs[treefileChain], StartUserLink(treefilechain) + 1, EndUserLink(treefilechain) + 1);		{have to add 1 as copychunks presumes 1-based system}	end;{$IFC FALSE}{----------------------------------------------------------------------------}	procedure SetStartBytes (theCHAIN, theLink: longint);{initializes the starting bytes of a link}		var			dL: longint;			ds: str255;			H: Handle;	begin		H := HdlPtr(GetMaster(strCHUNKs[theCHAIN]) + HdlSize * ord4(theLink - 1))^;		ds := '                     ';		dL := Munger(H, 0, @ds, 0, Pointer(ord(@ds) + 1), SLB);	end;{$ENDC}{----------------------------------------------------------------------------}	function AsteriskPresent (tH: Handle): boolean;{checks if asterisk is present on a link, and, if so, it deletes it}{also, skips CHUNKpos to after the name of the link}		var			ds: str255;			dL: longint;			oldstate: SignedByte;	begin		AsteriskPresent := false;		CHUNKpos := 0;		ds := GetHToken(tH);		if ds = '*' then	{it's a default; otherwise, ds is the name of the CHUNK}			begin				UnlockHandle(tH, oldstate);				DeletePieceOfHandle(tH, 0, CHUNKpos);  {deleting asterisk}				ResetHandle(tH, oldstate);				CHUNKpos := 0;				ds := GetHToken(tH); {skipping name of CHUNK}				AsteriskPresent := true;			end;	end;{----------------------------------------------------------------------------}	function MacCladeReadableFormat (ds: str255; theChunks: longint): boolean;	begin		case theCHUNKs of			taxsetchain: 				MacCladeReadableFormat := (ds = 'VECTOR');			typesetchain, exsetchain, charsetchain: 				MacCladeReadableFormat := (ds = 'VECTOR');			CharPartitionchain: 				MacCladeReadableFormat := (ds = 'VECTOR') or  (ds = 'NOTOKENS');			wtsetchain: 				MacCladeReadableFormat := (ds = 'VECTOR') or (ds = 'REAL') or (ds = 'INTEGER');			otherwise				MacCladeReadableFormat := false;		end;	end;{----------------------------------------------------------------------------}	function MacCladeReadableLink (tH: Handle; theChunks: longint): boolean;{at this point, CHUNK pos is sitting just before either the = sign or the format description of the link}{need here to check to see if format can be read by MacClade.  }{Will presume that MacClade can read all standard formats.}		var			ds: str255;			OKformat: boolean;	begin		ds := MakeCaps(GetHToken(tH));		if (ds = '=') then			MacCladeReadableLink := true		else if (ds = ';') then			MacCladeReadableLink := true		else if (ds = 'STANDARD') then			MacCladeReadableLink := true		else if (ds = '(') then			begin				OKformat := true;				repeat					ds := MakeCaps(GetHToken(tH));					if ds <> ')' then						OKformat := MacCladeReadableFormat(ds, theChunks);				until (ds = ')') or not OKformat or (CHUNKpos >= GetHandleSize(tH));				MacCladeReadableLink := OKformat;			end		else			MacCladeReadableLink := MacCladeReadableFormat(ds, theChunks);	end;{----------------------------------------------------------------------------}	procedure ReadstrCHUNK (theCHUNKs: Integer);{reads a link from the file into the link system}		var			thisCHUNK: longint;			H: Handle;			dhp: HdlPtr;			c: char;			mcchunk, isasterisk, foreignAssump: boolean;			ds: str255;			startpos, endpos, dl: longint;			db: boolean;			oldstate: SignedByte;	begin		thisCHUNK := LinksInChain(theCHUNKs) + 1;{====== read in chunk into memory ======}		H := NewHandle(0);		LineToH(H);		if badmemory then			begin				ZapHandle(H);				Exit(ReadStrCHUNK);			end;{====== scan CHUNK ======}		isasterisk := AsteriskPresent(H);		if MacCladeReadableLink(H, theCHUNKs) then			begin				if isasterisk then					DefaultLink[theCHUNKs] := thisCHUNK - 1;{====== add CHUNK ======}				AddCHUNKs(strCHUNKs[theCHUNKs], 1, 2);				if badmemory then					begin						ZapHandle(H);						Exit(ReadstrCHUNK);					end				else					UserLinks[theCHUNKs] := UserLinks[theCHUNKs] + 1;				LockHandle(strCHUNKs[theCHUNKs], oldstate);				dhp := HdlPtr(GetMaster(strCHUNKs[theCHUNKs]) + HdlSize * ord4(thisCHUNK - 1));				CopyHandles(H, dhp^);				ResetHandle(strCHUNKs[theCHUNKs], oldstate);{===== SettingStartingBytes =====}{don't need this as unpacked handle nowhere has starting bytes-  SetStartBytes(theCHUNKS, thisCHUNK);}			end		else			begin				foreignAssump := true;				AppendNewLineToBlock(assumptionsBlock);				case theCHUNKs of					wtsetchain: 						AppendStringToBlock(assumptionsBlock, 'WTSET ');					CharPartitionchain: 						AppendStringToBlock(assumptionsBlock, 'CHARPARTITION ');					typesetchain: 						AppendStringToBlock(assumptionsBlock, 'TYPESET ');					exsetchain: 						AppendStringToBlock(assumptionsBlock, 'EXSET ');					charsetchain: 						AppendStringToBlock(assumptionsBlock, 'CHARSET ');					taxsetchain: 						AppendStringToBlock(assumptionsBlock, 'TAXSET ');					otherwise						foreignAssump := false;				end;				currentIOPosition := 65;   {v3.05}				if foreignAssump then					AppendHandleToBlock(assumptionsBlock,H);			end;		ZapHandle(H);	end;{----------------------------------------------------------------------------}	procedure LoadCHUNK;	begin	end;end.