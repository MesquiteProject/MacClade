unit TreeMenu;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil,		 GenUtil, StrUtil, MenuUtil, BoxUtil, TreeUtil, ChartWWrite, TreeMover, Settings, TaxonCHUtil, 		 Randomtree, CharUtil, CHUNK, SpreadUtil, LinkUtil, TraceControl, TreeCycle, Count, InfoWindows,		 Legends, TreeMaker, Swap, Windows, TreeGet, ReadTreeFile, WriteTreeFile, IncExcTaxa, ExportUtil, 		 MouseInTree, WriteUtil, ClickInInfoWindow;	procedure DoExpTreeMenu (ItemNo: integer);	procedure DoTreeMenu (ItemNo: integer);	procedure DoCreateTreeMenu (ItemNo: integer);{еееееееееееееееееееееее}implementation {е$S TreeMenu}{-----------------------------------------------------------------------------}	procedure DoWarnings;		var			theDialog: DialogPtr;			oldWarnUnstored: boolean;			tempP: WindowPtr;			localitemHit: integer;	begin		oldWarnUnstored := warnIfUnstoredTreeWillDisappear;		StartDLOG(176, theDialog, tempP);		ItemCheckMark(theDialog, 5, warnIfUnstoredTreeWillDisappear);		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			case localItemHit of 				4: SetDialogValuesAsDefaults(theDialog, warningsID, 0, 0);				5: 					begin						warnIfUnstoredTreeWillDisappear := not warnIfUnstoredTreeWillDisappear;						ItemCheckMark(theDialog, 5, warnIfUnstoredTreeWillDisappear);					end;				otherwise;			end;		until localItemHit in [1, 2];		if localItemHit = 2 then			warnIfUnstoredTreeWillDisappear := oldWarnUnstored;		EndDLOG(theDialog, tempP);	end;{-----------------------------------------------------------------------------}	procedure SearchOptions;		var			theDialog: DialogPtr;			tQuickestdescent, oldshowpath, oldslow: boolean;			tempP: WindowPtr;			localitemHit: integer;	begin		tQuickestdescent := quickestdescent;		oldshowpath := showbranchswappath;		oldslow := slowbranchswap;		StartDLOG(702, theDialog, tempP);		ItemCheckMark(theDialog, 3, quickestdescent);		ItemCheckMark(theDialog, 4, not quickestdescent);		ItemCheckMark(theDialog, 7, showbranchswappath);		ItemCheckMark(theDialog, 8, slowbranchswap);		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			if localItemHit in [3, 4] then				begin					quickestdescent := (localItemHit = 3);					ItemCheckMark(theDialog, 3, quickestdescent);					ItemCheckMark(theDialog, 4, not quickestdescent);				end			else if localItemHit = 6 then				SetDialogValuesAsDefaults(theDialog, searchid, 0, 0)			else if localItemHit = 7 then				begin					showbranchswappath := not showbranchswappath;					ItemCheckMark(theDialog, 7, showbranchswappath);				end			else if localItemHit = 8 then				begin					slowbranchswap := not slowbranchswap;					ItemCheckMark(theDialog, 8, slowbranchswap);				end;		until localItemHit in [1, 2];		if localItemHit = 2 then			begin				quickestdescent := tquickestdescent;				showbranchswappath := oldshowpath;				slowbranchswap := oldslow;			end;		EndDLOG(theDialog, tempP);	end;{-----------------------------------------------------------------------------}{$IFC FALSE}	function CommonAnc (a, b: integer): Nptr;		var			taxonHdl: thdl;			n1, n2, na: Nptr;	begin		taxonhdl := gettaxonhdl(a);		n1 := taxonhdl^^.n;		taxonhdl := gettaxonhdl(b);		n2 := taxonhdl^^.n;		na := n2;		repeat			na := na^.anc		until isanc(na, n1);		commonanc := na;	end; {$ENDC}{-----------------------------------------------------------------------------}	procedure DoTreeTransfer;{ transfers trees from treefile to datafile, or from datafile to new treefile}		var			itree, trees: integer;			fromChain, toChain: Integer;	begin		if charton & ((CWChart = CWCC2T) | (CWTrees[CWChart] = CWStoredTrees)) & not treefile then			if CWarning('Starting a new tree file will force the chart to close.', 'Continue', 'Cancel') then				PleaseOffChart := true			else				Exit(DoTreeTransfer);		{InitTreeBits;}{v4: have option to transfer from treefile to new tree file}		if treefile then			begin				{ParamText('Transfer trees to data file:', '', '', '');}				fromChain := treefilechain;				toChain := datafilechain;			end		else			begin				{ParamText('Transfer trees to new tree file:', '', '', '');}				fromChain := datafilechain;				toChain := treefilechain;			end;		numtreeschosen := NumberInfoRowsSelected(treeinfo);{		if GetTree(GTtransfer) then			begin}				{itree := 0;}				if treefile then					dirtyfile := true				else					dirtytreefile := true;				if not treefile then   {we're tranferring to new treefile, have to create it}					begin						treeFileLastModified := 0;						treefilename^^ := 'Untitled';						treefileSaved := false;						UserLinks[treeFileChain] := 0;					end;				for trees := 1 to MaximumInfoRows(treeinfo) do					if infoRowSelected(treeinfo,trees) then						begin							{itree := itree + 1;}							AddCHUNKs(strCHUNKs[toChain], 1, 2);							if badmemory then								leave;							UserLinks[toChain] := UserLinks[toChain] + 1;							CopyCHUNK(strCHUNKs[fromChain], strCHUNKs[toChain], trees + StartUserLink(fromChain), EndUserLink(toChain) + 1);							if badmemory then								begin									UserLinks[toChain] := UserLinks[toChain] - 1;									leave;								end;						end;				if not treefile then   {we're tranferring to new treefile, have to create it}					begin						treefile := true;						treeChain := treefileChain;						if treeopen then							InvalidateWindow(tlegwindow, false);					end;			InvalidateInfoWindow(treeinfo);	{		end;		DisposeTreeBits;}	end;{-----------------------------------------------------------------------------}	procedure DoExpTreeMenu (ItemNo: integer);	begin		case ItemNo of			HennigTreesItem: 				WriteExportTrees(hennig);			PHYLIPTreesItem: 				begin					phylipversion := 33;					WriteExportTrees(phylip);				end;			PHYLIP34TreesItem: 				begin					phylipversion := 34;					WriteExportTrees(phylip);				end;			otherwise				;		end;	end;{-----------------------------------------------------------------------------}	procedure DoTreeMenu (ItemNo: integer);	var whichRow: longint;		olddirtytree: boolean;	begin		case ItemNo of			TreeListItem: 				if numtaxa < minTaxaIn then					NewError(107, 0)				else					OpenOrSelectInfoWindow(treeinfo);								ShowTreeItem: 				if FirstInfoRowSelected(treeinfo,whichRow) then					UseSelectedObject(treeinfo,whichRow);			StoreTreeItem: 				begin					NewStoreTree;					{if SaveLinkDLOG(treeCHAIN) then						InvalidateWindow(tlegwindow, false);}				end;							WarningsItem:				begin					DoWarnings;				end;			NewTreeFileItem: 				StartNewTreeFile;							OpenTreeFileItem: 				begin					olddirtytree:= dirtytree;					GetTreeFile;					if not errorflag & (UserLinks[treeChain] > 0) then						if olddirtytree then							OpenFirstUserTree						else							OpenOrSelectInfoWindow(treeinfo);										{if not errorflag and (userlinks[treechain] > 0) then						DoGetTree;}				end;			TransferTreeItem: 				if TransferTreesAvailable then					DoTreeTransfer;			CloseTreeFileItem: 				begin					if CloseTreeFile('closing?') then						DeSelectAllInfo(treeinfo);				end;			SaveTreeFileItem: {$IFC DEMO}				InstantInfo('You cannot save files with this demonstration version of MacClade.');{$ELSEC}			SaveTreeFile; {$ENDC}			SaveAsTreeFileItem: {$IFC DEMO}				InstantInfo('You cannot save files with this demonstration version of MacClade.');{$ELSEC}			SaveTreeFileAs;{$ENDC}		{	SearchOptionsItem: 				SearchOptions;}			IncExcTaxaItem: 				OpenOrSelectInfoWindow(taxinfo);			PolyRealItem: {$IFC SHADOWTREE}				if OptionEvent(Event) then					begin						shadowTree := not shadowTree;						InvalidateWindow(chlegwindow, false);						godraw := true;					end				else{$ENDC}					PolyOptions;			AllTermItem: 				begin					setcursor(clockCursor);					fullundo := true;					undotype := justmove;					noundo := false;					justundid := false;					StoreOldTreeForUndo;					SetDirtyTree;					dirtyfile := true;					ancon := FALSE;					myDisableItem(TreeMHdl, AllTermItem);					OffAnc(R);					SetFixon;					godraw := true;					RearrangeTreeGoList;					justchanc := true;					FixTreeShadingMenus;				end;			otherwise				;		end;		if ItemNo in [SaveTreeFileItem, SaveAsTreeFileItem, CloseTreeFileItem, TransferTreeItem, NewTreeFileItem, OpenTreeFileItem] then			begin				SizeTextWindowText(AboutTreesText,false, true, false);  				SizeTextWindowText(AboutTreeFileText,false, true, false);				InvalidateWindow(textWindow[AboutTreesText], true);				InvalidateWindow(textWindow[AboutTreeFileText], true);				EnableDisableItem(TreeMHdl, TransferTreeItem, TransferTreesAvailable);			end;	end;{-----------------------------------------------------------------------------}	procedure DoCreateTreeMenu (ItemNo: integer);	var db: boolean;	begin		case ItemNo of			DefaultLadderItem:				db := GoToTree(0);			DefaultBushItem:				db := GoToTree(1) ;						RandomTreeItem: 				if numtaxa < minTaxaIn then					NewError(107, 0)				else					DoRandomTrees;								AllRootingsItem: 				if numtaxa < minTaxaIn then					NewError(107, 0)				else  if treeopen then					AllReRoots(screenR);								otherwise				;		end;		if ItemNo in [RandomTreeItem, AllRootingsItem] then			begin				SizeTextWindowText(AboutTreesText,false, true, false); 				SizeTextWindowText(AboutTreeFileText,false, true, false);				InvalidateWindow(textWindow[AboutTreesText], true);				InvalidateWindow(textWindow[AboutTreeFileText], true);				EnableDisableItem(TreeMHdl, TransferTreeItem,TransferTreesAvailable);			end;	end;end.