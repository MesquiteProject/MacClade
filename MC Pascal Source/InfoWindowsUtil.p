unit InfoWindowsUtil;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}interface	uses		QuickDraw, 		Types, Events, QuickDrawText, OSUtils, Menus, TextUtils, Windows,		 Controls, Dialogs, TextEdit, Lists, ToolUtils, Memory, Fonts, Resources, Scrap, 		Globals, MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, 		SetLibInterface, UtilLibInterface, TaxonCHUtil, CharUtil, WriteUtil, TreeUtil, MenuUtil, SpreadUtil,TypeUtil, 		LinkUtil, NexusBlocks,CharPartitions;	const		infoRowsPreferredMinimum = 4;  {\\\ WH}{$IFC CARBON}		infoButtonRowHeight = 35;{$ELSEC}		infoButtonRowHeight = 27;{$ENDC}	procedure AdjustInfoRowsIfBelowMinimum(whichinfo: integer);	function InfoRowsLessThanPreferredMinimum (numElements: longint): boolean; {\\\ WH}	function InfoNameString (whichinfo, ic: longint): str255;	function infoRowFromHeight (whichInfo: integer; vert: integer): integer;	function InfoColumnRight (whichInfo, whichColumn: integer): integer;	function InfoColumnLeft (whichInfo, whichColumn: integer): integer;	function InfoColumnFromIDRight (whichInfo, colID: integer): integer;	function InfoColumnFromIDLeft (whichInfo, colID: integer): integer;	function InfoRowTop (whichInfo, whichRow: integer): integer;	function InfoRowBottom (whichInfo, whichRow: integer): integer;	procedure SetInfoColumnWidth(whichinfo,whichColumn, theWidth: integer);	function ShowInfoColumnFromID (whichInfo, colID: integer): boolean;	procedure SetInfoColumnIDShow (whichInfo, colID: integer; show: boolean);	function InfoColumnPtr (whichInfo, whichColumn: integer): infoWindowColumnPtr;	function InfoColumnID (whichInfo, whichColumn: integer): integer;	function InfoColumnPtrFromColID (whichInfo, colID: integer): infoWindowColumnPtr;	procedure CreateInfoColumn (whichInfo: integer; colID: longint; width: integer; title: str15; isString, show, menu,candoMagicWand: boolean; columnType: integer);	procedure DestroyInfoColumn (whichInfo, whichColumn: integer);	function InfoColumnWandable(whichinfo,whichColumn: integer): boolean;	function AnyInfoWindowWasOpen: boolean;	function InfoRowVisible (whichinfo: integer; ir: longint): boolean;	function MaximumInfoRows (whichinfo: integer): longint;	function MaximumInfoColumns (whichinfo: integer): integer;	function InfoRowsDeletable (whichinfo: integer): boolean;	function InfoNameLocked (whichinfo: integer; ir: longint): boolean;	procedure LockInfoName (whichinfo: integer; ir: longint; value: boolean);	function InfoRowSelectable (whichinfo: integer; ir: longint): boolean;	function InfoRowDimmed (whichinfo: integer; ir: longint): boolean;	function InfoRowsMassMovable (whichinfo: integer): boolean;	function InfoColumnType (whichinfo, columnID: integer): integer;	function InfoColumnNumerical (whichinfo, columnID: integer): boolean;	function InfoColumnSortable (whichinfo, columnID: integer): boolean;	function InfoToolWorksOnNames(whichTool: integer): boolean;	procedure CheckInfoSomeSelected (whichinfo: integer);	function AnyInfoRowSelected (whichinfo: integer): boolean;	function InfoRowSelected (whichinfo: integer; ir: longint): boolean;	function FirstInfoRowSelected (whichinfo: integer; var theRow: longint): boolean;	function TwoInfoRowsSelected (whichinfo: integer; var theRow1, theRow2: longint): boolean;	function SingleInfoRowSelected (whichinfo: integer; var theRow: longint): boolean;	function NumberInfoRowsSelected (whichinfo: integer): longint;	function InfoRowSelectedRange(whichinfo: integer; var irstart,irend: longint): boolean;	procedure SelectInfoRow (whichinfo: integer; ir: longint; value: boolean);	procedure SetAllInfoDeSelected (whichinfo: integer);	procedure DeSelectAllInfo (whichinfo: integer);		function InfoRowOfCurrentObject(whichinfo: integer): longint;	function InfoEditingOutOfView (whichinfo: integer; var theRow: longint): boolean;	procedure InvalidateInfoRow (whichinfo, irstart, irend: longint);	procedure InvalidateInfoColumn (whichinfo, columnID, icstart, icend: longint);		function InfoWindowLockBox (whichinfo: integer): rect;//	procedure CalcInfoUseButtonBox (whichinfo: integer);	procedure CalcInfoTrashButtonBox (whichinfo: integer);	procedure CalcInfoButtonRowBoxes (whichinfo: integer);	function InfoWindowButtonResID(whichinfo: integer): integer;	function infoButtonRowBox (whichinfo: integer): rect;	function InfoHeight (whichinfo, ir: longint): longint;	function InfoRowBox (whichinfo: integer; height: longint): rect;	function InfoCellBox (whichinfo, whichColumn: integer; height: longint): rect;	procedure InvertInsideRect(box: rect);	function InfoWindowMessageBox (whichinfo: integer): rect;	function DefaultInfoObjectName(whichInfo: integer):  str255;	const		infoTitleLines = 1;		infoTinge = yellowTinge;{$SETC COLORINFOBACKGROUND=TRUE}{еееееееееееееееееееееее}implementation {е$S InfoWindows}{v4: have user able to see Weighted character steps in char status window}{-----------------------------------------------------------------------------}	procedure AdjustInfoRowsIfBelowMinimum(whichinfo: integer);	begin		if infoRows[whichinfo] < infoRowsPreferredMinimum then infoRows[whichinfo] :=infoRowsPreferredMinimum;		infoBottom[whichinfo] := infoTop[whichinfo] + infoRows[whichinfo]-1;	end;{-----------------------------------------------------------------------------}	function InfoColumnPtr (whichInfo, whichColumn: integer): infoWindowColumnPtr;		var			infoColPtr: infoWindowColumnPtr;			j: integer;	begin		InfoColPtr := infoCol[whichInfo];		for j := 1 to whichColumn do			if InfoColPtr = nil then				leave			else				infoColPtr := infoColPtr^.nextLink;		InfoColumnPtr := infoColPtr;{infoWindowColumnPtr(@InfoColumns[whichinfo]^[whichColumn]);}	end;{-----------------------------------------------------------------------------}	function InfoColumnRight (whichInfo, whichColumn: integer): integer;	var	infoColPtr: infoWindowColumnPtr;	begin		InfoColPtr := InfoColumnPtr(whichinfo,whichColumn);		if infoColPtr = nil then			InfoColumnRight := 0		else			InfoColumnRight := infoColPtr^.right;	end;{-----------------------------------------------------------------------------}	function InfoColumnLeft (whichInfo, whichColumn: integer): integer;	var	infoColPtr: infoWindowColumnPtr;	begin		InfoColPtr := InfoColumnPtr(whichinfo,whichColumn);		if infoColPtr = nil then			InfoColumnLeft := 0		else			InfoColumnLeft := infoColPtr^.left;	end;	{-----------------------------------------------------------------------------}	function InfoRowTop (whichInfo, whichRow: integer): integer;	var top: longint;	begin		top := InfoHeight(whichinfo, whichRow) - infoLW[whichinfo];		InfoRowTop  := top;	end;	{-----------------------------------------------------------------------------}	function infoRowFromHeight (whichInfo: integer; vert: integer): integer;	begin		infoRowFromHeight := infoTop[whichinfo] + (vert - infoLW[whichinfo] * infoTitleLines) div infoLW[whichinfo];	end;{-----------------------------------------------------------------------------}	function InfoRowBottom (whichInfo, whichRow: integer): integer;	var bottom: longint;	begin		bottom :=  InfoHeight(whichinfo, whichRow);		InfoRowBottom  := bottom;	end;{-----------------------------------------------------------------------------}	function InfoColumnFromIDRight (whichInfo, colID: integer): integer;	var	infoColPtr: infoWindowColumnPtr;	begin		InfoColPtr := InfoColumnPtrFromColID(whichinfo,colID);		if infoColPtr = nil then			InfoColumnFromIDRight := 0		else			InfoColumnFromIDRight := infoColPtr^.right;	end;{-----------------------------------------------------------------------------}	function InfoColumnFromIDLeft (whichInfo, colID: integer): integer;	var	infoColPtr: infoWindowColumnPtr;	begin		InfoColPtr := InfoColumnPtrFromColID(whichinfo,colID);		if infoColPtr = nil then			InfoColumnFromIDLeft := 0		else			InfoColumnFromIDLeft := infoColPtr^.left;	end;	{-----------------------------------------------------------------------------}	procedure SetInfoColumnWidth(whichinfo,whichColumn, theWidth: integer);	var	infoColPtr: infoWindowColumnPtr;	begin		InfoColPtr := InfoColumnPtr(whichinfo,whichColumn);		if infoColPtr <> nil then			infoColPtr^.width := theWidth;	end;{-----------------------------------------------------------------------------}	procedure SetInfoColumnIDShow (whichInfo, colID: integer; show: boolean);	var	infoColPtr: infoWindowColumnPtr;	begin		InfoColPtr := InfoColumnPtrFromColID(whichinfo,colid);		if infoColPtr <> nil then			infoColPtr^.show := show;	end;{-----------------------------------------------------------------------------}	function ShowInfoColumnFromID (whichInfo, colID: integer): boolean;	var	infoColPtr: infoWindowColumnPtr;	begin		ShowInfoColumnFromID := false;		InfoColPtr := InfoColumnPtrFromColID(whichinfo,colid);		if infoColPtr <> nil then			ShowInfoColumnFromID := infoColPtr^.show;	end;{-----------------------------------------------------------------------------}	function InfoColumnID (whichInfo, whichColumn: integer): integer;	var infoColPtr: infoWindowColumnPtr;	begin		InfoColumnID := notAColumn;		if whichColumn >= 0 then			begin				infoColPtr := InfoColumnPtr(whichinfo,whichColumn);				if infoColPtr <> nil then					InfoColumnID := infoColPtr^.columnID;			end;	end;{-----------------------------------------------------------------------------}	function InfoColumnPtrFromColID (whichInfo, colID: integer): infoWindowColumnPtr;		var			infoColPtr: infoWindowColumnPtr;			j: integer;	begin		InfoColumnPtrFromColID := nil;		InfoColPtr := infoCol[whichInfo];		if infoColPtr <> nil then			begin				for j := 0 to MaximumInfoColumns(whichInfo) do					if colID = infoColPtr^.columnID then						begin							InfoColumnPtrFromColID := infoColPtr;							leave;						end					else						infoColPtr := infoColPtr^.nextLink;			end;	end;{-----------------------------------------------------------------------------}	function InfoColumnWandable(whichinfo,whichColumn: integer): boolean;	var theColumn:infoWindowColumnPtr;	begin		InfoColumnWandable := false;		theColumn := InfoColumnPtr(whichinfo,whichColumn);		if theColumn<> nil then			InfoColumnWandable := theColumn^.canDoMagicWand;	end;{-----------------------------------------------------------------------------}	procedure CreateInfoColumn (whichInfo: integer; colID: longint; width: integer; title: str15; isString, show, menu,candoMagicWand: boolean; columnType: integer);		var			maxColumn: integer;			infoColPtr: infoWindowColumnPtr;	begin		maxColumn := MaximumInfoColumns(whichInfo);		if maxColumn < 0 then {no columns at all; create the first one}			begin				infoCol[whichInfo] := infoWindowColumnPtr(NewPtr(SizeOf(infoWindowColumnType)));				infoColPtr := infoCol[whichInfo];			end		else			begin				infoColPtr := InfoColumnPtr(whichInfo, maxColumn);				infoColPtr^.nextLink := infoWindowColumnPtr(NewPtr(SizeOf(infoWindowColumnType)));				infoColPtr := infoColPtr^.nextLink;			end;		if infoColPtr <> nil then			begin				infoColPtr^.width := width;				infoColPtr^.nextLink := nil;				infoColPtr^.title := title;				infoColPtr^.show := show;				infoColPtr^.menu := menu;				infoColPtr^.columnID := colID;				infoColPtr^.isString := isString;				infoColPtr^.canDoMagicWand := canDoMagicWand;				infoColPtr^.columnType := columnType;			end;	end;{-----------------------------------------------------------------------------}	procedure DestroyInfoColumn (whichInfo, whichColumn: integer);		var			infoColPtr: infoWindowColumnPtr;			nextLink: infoWindowColumnPtr;			prevLink: infoWindowColumnPtr;	begin		infoColPtr := InfoColumnPtr(whichInfo, whichColumn);		if whichColumn > 0 then			prevLink := InfoColumnPtr(whichInfo, whichColumn - 1)		else			prevLink := nil;		if infoColPtr <> nil then			begin				nextLink := infoColPtr^.nextLink;				if prevLink <> nil then					PrevLink^.nextLink := nextLink;				ZapPointer(infoColPtr);			end;	end;{-----------------------------------------------------------------------------}	procedure MoveInfoColumn (whichInfo, whichColumn, afterColumn: integer);{moves the column whichColumn in the infoWindwo whichInfo to just after Column afterColumn}	begin	end;{-----------------------------------------------------------------------------}	function MaximumInfoColumns (whichinfo: integer): integer;		var			whichColumn: integer;	begin		whichColumn := -1;		repeat			whichColumn := whichColumn + 1;		until infoColumnPtr(whichinfo, whichColumn) = nil;		MaximumInfoColumns := whichColumn - 1;  {subtract 1 as end up with last counted column being nil, which isn't a column}	end;{-----------------------------------------------------------------------------}	function AnyInfoWindowWasOpen: boolean;		var			j: integer;	begin		AnyInfoWindowWasOpen := false;		for j := 1 to numInfoWindows do			if infoWasOpen[j] then				begin					AnyInfoWindowWasOpen := true;					leave;				end;	end;{-----------------------------------------------------------------------------}	function MaximumInfoRows (whichinfo: integer): longint;{returns the maximum number of rows for a particular information window, 1-based}	begin		case whichinfo of			taxinfo: 				MaximumInfoRows := numTaxa;			charinfo: 				MaximumInfoRows := numChars;			treeinfo: 				MaximumInfoRows := UserLinks[treechain];			typeInfo: 				MaximumInfoRows := numTypes;			nexusblockinfo:				MaximumInfoRows := numNexusBlocks;			charpartnameinfo:				MaximumInfoRows:= numCharPartNames;			wtsetinfo,typesetinfo,exsetinfo,charsetinfo,taxsetinfo,charpartinfo:				MaximumInfoRows := UserLinks[ChainFromInfo(whichInfo)];			otherwise				MaximumInfoRows := 0;		end;	end;{----------------------------------------------------------------------------}	function InfoRowVisible (whichinfo: integer; ir: longint): boolean;	begin		InfoRowVisible := (ir >= infoTop[whichinfo]) & (ir <= infoBottom[whichinfo] );	end;{-----------------------------------------------------------------------------}	function InfoTitleWidth (whichInfo: integer): integer;	begin		InfoTitleWidth := infoLW[whichinfo] * 2;	end;{-----------------------------------------------------------------------------}	function InfoHeight (whichinfo, ir: longint): longint;	var height: longint;	begin		height :=ord4(infoLW[whichinfo]) * longint(ir - infoTop[whichinfo] + 1 + infoTitleLines) - 2;		if height > WindowPortRect(infowindow[whichInfo]).bottom then height := WindowPortRect(infowindow[whichInfo]).bottom;		InfoHeight := height;	end;{-----------------------------------------------------------------------------}	function InfoRowBox (whichinfo: integer; height: longint): rect;		var			box: rect;			tempHeight: longint;	begin		if (height>32766) then			tempHeight := 32766		else			tempHeight := height;		SetRect(box, infoDrawRect[whichinfo].left, tempHeight - infoLW[whichinfo] + 1, infoDrawRect[whichinfo].right - scrollwidth - 1, tempHeight);		InfoRowBox := box;	end;{-----------------------------------------------------------------------------}	function InfoCellBox (whichinfo, whichColumn: integer; height: longint): rect;		var			box: rect;			tempHeight: longint;	begin		if (height>32766) then			tempHeight := 32766		else			tempHeight := height;		SetRect(box, InfoColumnLeft(whichinfo, whichColumn)-1, tempHeight - infoLW[whichinfo] + 1, InfoColumnRight(whichinfo, whichColumn)+1, tempHeight);		if whichColumn > infoName then			OffSetRect(box, -infoLeft[whichinfo]+1, 0);		InfoCellBox := box;	end;{-----------------------------------------------------------------------------}	function InfoNameLocked (whichinfo: integer; ir: longint): boolean;	begin		case whichinfo of			nexusBlockInfo: 				InfoNameLocked := not NexusBlockForeign(ir)|Locked(lockData);			taxinfo, charinfo:				InfoNameLocked := Locked(lockData);			exsetinfo, wtsetinfo, typesetinfo:				InfoNameLocked := Locked(lockAssumptions);			treeinfo:				InfoNameLocked := Locked(lockTrees);			charpartnameinfo:				InfoNameLocked := ir=1;			otherwise				InfoNameLocked := false;		end;	end;{-----------------------------------------------------------------------------}	function InfoRowsMassMovable (whichinfo: integer): boolean;	begin		case whichinfo of			charinfo: 				InfoRowsMassMovable := not Locked(lockData); 			treeinfo:				InfoRowsMassMovable:= not Locked(lockTrees);			taxinfo:				InfoRowsMassMovable:= not Locked(lockData);			wtsetinfo, exsetinfo, typesetinfo:				InfoRowsMassMovable:= not Locked(lockAssumptions);			charsetinfo,taxsetinfo,charpartinfo, charpartnameinfo:				InfoRowsMassMovable := true;			nexusblockinfo:				InfoRowsMassMovable := false;			otherwise				InfoRowsMassMovable := false;		end;	end;{-----------------------------------------------------------------------------}	function InfoRowsDeletable (whichinfo: integer): boolean;	begin		case whichinfo of			nexusBlockInfo: 				InfoRowsDeletable :=  not Locked(lockData);			taxinfo, charinfo:				InfoRowsDeletable := not Locked(lockData);			exsetinfo, wtsetinfo, typesetinfo:				InfoRowsDeletable := not Locked(lockAssumptions);			treeinfo:				InfoRowsDeletable := not Locked(lockTrees);			otherwise				InfoRowsDeletable := true;		end;	end;{-----------------------------------------------------------------------------}	function InfoRowSelectable (whichinfo: integer; ir: longint): boolean;	begin		case whichinfo of			nexusBlockInfo: 				InfoRowSelectable := NexusBlockIsEditable(NexusBlock(ir));			{taxinfo, charinfo:				InfoRowSelectable := not Locked(lockData);}			{charinfo:				InfoRowSelectable := not (Locked(lockAssumptions) & Locked(lockData));}			exsetinfo, wtsetinfo, typesetinfo:				InfoRowSelectable := not Locked(lockAssumptions);			charpartnameinfo:				InfoRowSelectable := (ir<> 1);			{treeinfo:				InfoRowSelectable := not Locked(lockTrees);}			otherwise				InfoRowSelectable := true;		end;	end;{-----------------------------------------------------------------------------}	function InfoRowDimmed (whichinfo: integer; ir: longint): boolean;	begin		case whichinfo of			nexusBlockInfo: 				InfoRowDimmed := not NexusBlockIsEditable(NexusBlock(ir));			otherwise				InfoRowDimmed := false;		end;	end;{-----------------------------------------------------------------------------}	procedure LockInfoName (whichinfo: integer; ir: longint; value: boolean);		var			H: Handle;	begin	{	case whichinfo of			treeinfo: 				begin					if value then						BSet(GetTreeInList(CurrentTreeList,ir)^.status, lockedNameBit)					else						BClr(GetTreeInList(CurrentTreeList,ir)^.status, lockedNameBit);				end;			typeinfo: 				GetModelFromSequenceNumber(ir, magicP)^.lockedName := value;			otherwise				;		end;}			end;{-----------------------------------------------------------------------------}	function InfoRowSelected (whichinfo: integer; ir: longint): boolean;		var			H: Handle;	begin		if ir > MaximumInfoRows(whichinfo) then			InfoRowSelected := false		else		case whichinfo of			taxinfo: 				InfoRowSelected := gettaxonhdl(ir)^^.infoSelected;			charinfo: 				InfoRowSelected := getchhdl(ir)^^.infoSelected;			typeinfo: 				begin 					{InfoRowSelected := GetModelFromSequenceNumber(ir, magicP)^.infoSelected;}				end;			nexusblockinfo:				InfoRowSelected := NexusBlockSelected(ir);			charpartnameinfo:				InfoRowSelected := CharPartNameSelected(ir);			treeinfo, wtsetinfo,typesetinfo,exsetinfo,charsetinfo,taxsetinfo,charpartinfo: 				begin					InfoRowSelected :=TestLinkBit(ChainFromInfo(whichinfo), LinkNumberFromInfoRow(ChainFromInfo(whichinfo),ir), nil, selectedbit);				end;			otherwise				InfoRowSelected := false;		end;	end;{-----------------------------------------------------------------------------}	function AnyInfoRowSelected (whichinfo: integer): boolean;		var			ir: longint;	begin		AnyInfoRowSelected := false;		for ir := 1 to MaximumInfoRows(whichinfo) do			begin				if InfoRowSelected(whichinfo, ir) then					begin						AnyInfoRowSelected := true;						leave;					end;			end;	end;{-----------------------------------------------------------------------------}	procedure CheckInfoSomeSelected (whichinfo: integer);		var			ir: longint;	begin		infoSomeSelected[whichinfo] := false;		for ir := 1 to MaximumInfoRows(whichinfo) do			if InfoRowSelected(whichinfo, ir) then				begin					infoSomeSelected[whichinfo] := true;					leave;				end;	end;{-----------------------------------------------------------------------------}	function FirstInfoRowSelected (whichinfo: integer; var theRow: longint): boolean;		var			ir: longint;			someSelected: boolean;	begin		someSelected := false;		theRow := 0;		for ir := 1 to MaximumInfoRows(whichinfo) do			begin				if InfoRowSelected(whichinfo, ir) then					begin						theRow := ir;						infoSomeSelected[whichinfo] := true;						someSelected := true;						leave;					end;			end;		FirstInfoRowSelected := someSelected;	end;{-----------------------------------------------------------------------------}	function SingleInfoRowSelected (whichinfo: integer; var theRow: longint): boolean;		var			ir, numselected: longint;	begin		numselected := 0;		theRow := 0;		for ir := 1 to MaximumInfoRows(whichinfo) do			begin				if InfoRowSelected(whichinfo, ir) then					begin						theRow := ir;						infoSomeSelected[whichinfo] := true;						numselected := numSelected + 1;						if numSelected > 1 then							leave;					end;			end;		SingleInfoRowSelected := numselected = 1;	end;{-----------------------------------------------------------------------------}	function TwoInfoRowsSelected (whichinfo: integer; var theRow1, theRow2: longint): boolean;		var			ir, numselected: longint;	begin		numselected := 0;		theRow1 := 0;		theRow2 := 0;		for ir := 1 to MaximumInfoRows(whichinfo) do			begin				if InfoRowSelected(whichinfo, ir) then					begin						numselected := numSelected + 1;						infoSomeSelected[whichinfo] := true;						if numSelected = 1 then							theRow1 := ir						else if numSelected = 2 then							theRow2 := ir;						if numSelected > 2 then							leave;					end;			end;		TwoInfoRowsSelected := numselected = 2;	end;{-----------------------------------------------------------------------------}	function NumberInfoRowsSelected (whichinfo: integer): longint;		var			ir, numselected: longint;	begin		numselected := 0;		for ir := 1 to MaximumInfoRows(whichinfo) do			if InfoRowSelected(whichinfo, ir) then				begin					numselected := numSelected + 1;					infoSomeSelected[whichinfo] := true;				end;		NumberInfoRowsSelected := numselected;	end;{-----------------------------------------------------------------------------}	function InfoRowOfCurrentObject(whichinfo: integer): longint;	{returns value of -1 if current object is not in list}	var theChain: integer;	begin		InfoRowOfCurrentObject := -1;		case whichInfo of			treeinfo:				if  not dirtytree then					InfoRowOfCurrentObject := InfoRowFromLinkNumber(treeChain,linknumber[treechain]);			typesetinfo, wtsetinfo, exsetinfo,charpartinfo:				begin					theChain := ChainFromInfo(whichinfo);					if not dirtyLink[theChain] then						InfoRowOfCurrentObject := InfoRowFromLinkNumber(theChain,linknumber[theChain]);				end;			charinfo:				if (traceshown=tracediscrete) & treeopen then					infoRowOfCurrentObject := i;			otherwise;		end;		 		end;{-----------------------------------------------------------------------------}	function InfoRowSelectedRange(whichinfo: integer; var irstart,irend: longint): boolean;	var ir: longint;	begin		irStart := 0;		irEnd := 0;		for ir := 1 to MaximumInfoRows(whichinfo) do			begin				if InfoRowSelected(whichinfo, ir) then					begin						if irStart = 0 then							irStart := ir;						irEnd := ir;					end;			end;		InfoRowSelectedRange := irStart > 0;	end;{-----------------------------------------------------------------------------}	function InfoEditingOutOfView (whichinfo: integer; var theRow: longint): boolean;	begin	end;{-----------------------------------------------------------------------------}	procedure SelectInfoRow (whichinfo: integer; ir: longint; value: boolean);		var			H: Handle;	begin		if not value | infoRowSelectable(whichinfo,ir) then		case whichinfo of			taxinfo: 				gettaxonhdl(ir)^^.infoSelected := value;			charinfo: 				getchhdl(ir)^^.infoSelected := value;			{treeinfo: 				begin					if value then						BSet(GetTreeInList(CurrentTreeList,ir)^.status, selectedbit)					else						BClr(GetTreeInList(CurrentTreeList,ir)^.status, selectedbit);				end;}			nexusblockinfo:				begin					SelectNexusBlock(ir,value);				end;			charpartnameinfo:				begin					SelectCharPartName(ir,value);				end;			typeInfo: 				begin 					{ GetModelFromSequenceNumber(ir, magicP)^.infoSelected := value;}				end;			wtsetinfo,typesetinfo,exsetinfo,charsetinfo,taxsetinfo, treeinfo,charpartinfo: 				begin					H := GetDirectLinkH(ChainFromInfo(whichinfo), LinkNumberFromInfoRow(ChainFromInfo(whichinfo),ir));					HLock(H);					if value then						BitSet(ptr(GetMaster(H)), selectedbit)					else						BitClr(ptr(GetMaster(H)), selectedbit);					HUnlock(H);				end;			otherwise				;		end;	end;{-----------------------------------------------------------------------------}	procedure SetAllInfoDeSelected (whichinfo: integer);		var			ir: longint;	begin		for ir := 1 to MaximumInfoRows(whichinfo) do			SelectInfoRow(whichinfo, ir, false);		infoSomeSelected[whichinfo] := false;	end;{-----------------------------------------------------------------------------}	procedure DeSelectAllInfo (whichinfo: integer);		var			ic, ir, numElements: longint;			tport: windowptr;	begin		numElements := MaximumInfoRows(whichinfo);		genericGetPort(tport);		genericSetPort(infoWindow[whichinfo]);		ir := 1;		ic := infoTop[whichinfo];		repeat			if InfoRowSelected(whichinfo, ic) then{$IFC COLORINFOBACKGROUND}				InvertRect(InfoRowBox(whichinfo, InfoHeight(whichinfo, ic)));{$ELSEC}			InvertHiliteRect(InfoRowBox(whichinfo, InfoHeight(whichinfo, ic)));{$ENDC}			ir := ir + 1;			ic := ic + 1;		until (ir > infoRows[whichinfo]) or (ic > numElements);		SetAllInfoDeSelected(whichinfo);		genericSetPort(tport);	end;{-------------------------------------------------------------------------}	function InfoColumnType (whichinfo, columnID: integer): integer;	var infoColumnP : infoWindowColumnPtr;	begin		infoColumnP := InfoColumnPtrFromColID (whichInfo, columnID);		if infoColumnP <> nil then			InfoColumnType := infoColumnP^.columnType		else			InfoColumnType := columnIsString;	end;{-------------------------------------------------------------------------}	function InfoColumnNumerical (whichinfo, columnID: integer): boolean;	var columnType : integer;	begin		columnType := InfoColumnType (whichInfo, columnID);		InfoColumnNumerical := (columnType=columnIsInteger)|(columnType=columnIsLongint)|(columnType=columnIsDouble)|(columnType=columnIsSingle);	end;{-------------------------------------------------------------------------}	function InfoColumnBoolean (whichinfo, columnID: integer): boolean;	var columnType : integer;	begin		columnType := InfoColumnType (whichInfo, columnID);		InfoColumnBoolean := (columnType=columnIsBoolean);	end;{-------------------------------------------------------------------------}	function InfoColumnSortable (whichinfo, columnID: integer): boolean;	begin		InfoColumnSortable := InfoColumnNumerical (whichinfo, columnID) | InfoColumnBoolean(whichinfo,columnID) | (columnID=infoName);	end;{-------------------------------------------------------------------------}	function InfoToolWorksOnNames(whichTool: integer): boolean;	begin		InfoToolWorksOnNames := (whichTool = infoScissorsT) |  (whichTool = infoSortAscendingT) |  (whichTool = infoSortDescendingT);	end;{-------------------------------------------------------------------------}	procedure InvalidateInfoColumn (whichinfo, columnID, icstart, icend: longint);		var			box: rect;			top, bottom,sc,ec: longint;			tport: WindowPtr;{$IFC COLORINFOBACKGROUND}			oldBack: RGBColor;{$ENDC}	begin		if infoOpen[whichinfo] then			if ShowInfoColumnFromID(whichinfo, columnID) then				begin					genericGetPort(tport);					genericSetPort(infoWindow[whichinfo]);					if icstart<infoTop[whichinfo] then						sc := infoTop[whichinfo]					else						sc := icstart;					top := InfoHeight(whichinfo, sc) - infoLW[whichinfo];					if top < infoLW[whichinfo] - 1 then						top := infoLW[whichinfo] - 1;					if icend > infoBottom[whichinfo] then						ec := infoBottom[whichinfo]					else						ec := icend;					bottom := InfoHeight(whichinfo, ec);					if bottom > infoDrawRect[whichinfo].bottom - scrollwidth then						bottom := infoDrawRect[whichinfo].bottom - scrollwidth;					SetRect(box, InfoColumnFromIDLeft(whichinfo, columnID), top, InfoColumnFromIDRight(whichinfo, columnID), bottom);					InvalidateWindowRect(infoWindow[whichinfo],box,false);{$IFC COLORINFOBACKGROUND}					if columnID <> infoname then						GetRGBSetTingeBackground(oldBack, infoTinge);{$ENDC}					EraseRect(box);{$IFC COLORINFOBACKGROUND}					if columnID <> infoname then						SetRGBBackground(oldBack);{$ENDC}					genericSetPort(tport);				end;	end;{-----------------------------------------------------------------------------}	procedure InvalidateInfoRow (whichinfo, irstart, irend: longint);		var			box: rect;			top, bottom: longint;			tport: WindowPtr;{$IFC COLORINFOBACKGROUND}			oldBack: RGBColor;			theRight: integer;{$ENDC}	begin		if infoOpen[whichinfo] then			begin				genericGetPort(tport);				genericSetPort(infoWindow[whichinfo]);				top := InfoHeight(whichinfo, irstart) - infoLW[whichinfo];				if top < infoLW[whichinfo] - 1 then					top := infoLW[whichinfo] - 1;				bottom := InfoHeight(whichinfo, irend);				if bottom > infoDrawRect[whichinfo].bottom then					bottom := infoDrawRect[whichinfo].bottom;				SetRect(box, infoDrawRect[whichinfo].left, top, infoDrawRect[whichinfo].right - scrollwidth - 1, bottom);				InvalidateWindowRect(infoWindow[whichinfo],box,false);{$IFC COLORINFOBACKGROUND}				theright := box.right;				box.right := infoNameEnd[whichinfo];				EraseRect(box);				box.right := theRight;				box.left := InfoNameEnd[whichinfo];				GetRGBSetTingeBackground(oldBack, infoTinge);				EraseRect(box);				SetRGBBackground(oldBack);{$ELSEC}				EraseRect(box);{$ENDC}				genericSetPort(tport);			end;	end;{-----------------------------------------------------------------------------}	function InfoWindowMessageBox (whichinfo: integer): rect;		var			box: rect;	begin		{if infoWithButtons[whichinfo] then}			SetRect(box, 0, infoDrawRect[whichinfo].bottom - scrollwidth, infoNameEnd[whichinfo], infoDrawRect[whichinfo].bottom - scrollwidth + 16)		;{else			SetRect(box, 0, WindowPortRect(infowindow[whichInfo]).bottom - scrollwidth, infoNameEnd[whichinfo], WindowPortRect(infowindow[whichInfo]).bottom - scrollwidth + 16);		}InfoWindowMessageBox := box;	end;{-----------------------------------------------------------------------------}	function InfoWindowLockBox (whichinfo: integer): rect;		const			leftadjust = 0;		var			box: rect;	begin		SetRect(box, infoNameStart[whichinfo] + leftAdjust, infoDrawRect[whichinfo].bottom - scrollwidth, infoNameStart[whichinfo] + leftAdjust + lockBoxWidth, infoDrawRect[whichinfo].bottom - scrollwidth + lockBoxWidth);		InfoWindowLockBox := box;	end;{-----------------------------------------------------------------------------}	function infoButtonRowBox (whichinfo: integer): rect;	var box: rect;	begin		box := WindowPortRect(infowindow[whichInfo]);		box.top := infoDrawRect[whichinfo].bottom+1;		{InsetRect(box,1,1);}		infoButtonRowBox := box;	end;{-----------------------------------------------------------------------------}	procedure FitBoxToPicture(id: integer; var box: rect);		var			picH: PicHandle;	begin		picH := GetPicture(id);		if picH <> nil then			begin				box.right := box.left+picH^^.picFrame.right - picH^^.picFrame.left;				box.bottom := box.top + picH^^.picFrame.bottom - picH^^.picFrame.top;				ReleaseResource(Handle(picH));			end;	end;{-----------------------------------------------------------------------------}	procedure InvertInsideRect(box: rect);	var oldClip: RgnHandle;	begin		oldClip := NewRgn;		GetClip(oldClip);		ClipRect(box);		InsetRect(box,1,1);		InvertRect(box);		SetClip(oldClip);	end;{-----------------------------------------------------------------------------}	function InfoWindowButtonResID(whichinfo: integer): integer;	begin		case whichinfo of			treeinfo: 				InfoWindowButtonResID := 159;			charinfo: 				InfoWindowButtonResID := 158;			otherwise				InfoWindowButtonResID := 137;		end;	end;{-----------------------------------------------------------------------------}	procedure CalcInfoButtonRowBoxes (whichinfo: integer);		var			box: rect;			j: integer;	begin		box := infoButtonRowBox(whichinfo);		box.top := box.top +2;		box.left := box.left+2;		box.bottom := box.top+22;		box.right := box.left+22;		for j := 0 to numInfoTools do			begin				infoTools^[whichinfo,j].R := box;				OffsetRect(infoTools^[whichinfo,j].R,21*j,0);			end;		if infoWithButtons[whichinfo] then			begin				box := infoButtonRowBox(whichinfo);  {this is the entire buttom row box}				box.top := box.top+4;				box.left := box.right-90;				FitBoxToPicture(InfoWindowButtonResID(whichinfo), box);				OffSetRect(box,WindowPortRect(infowindow[whichInfo]).right-scrollwidth-box.right-5,0);//				InfoUseButtonBox[whichinfo] := box;{$IFC CARBON}				MoveControl(infoWindowButton[whichinfo], WindowPortRect(infowindow[whichInfo]).right-scrollwidth-100,box.top+1);{$ELSEC}				MoveControl(infoWindowButton[whichinfo], WindowPortRect(infowindow[whichInfo]).right-scrollwidth-100,box.top);{$ENDC}//				MoveControl(infoWindowButton[whichinfo], 0,0);			end;	//	else	//		SetRect(InfoUseButtonBox[whichinfo],0,0,0,0);	end;{----------------------------------------------------------------------------}	function InfoNameString (whichinfo, ic: longint): str255;	var	begin		case whichinfo of			charinfo: 				InfoNameString := CharName(ic);			taxinfo: 				InfoNameString := TaxonName(ic);			treeinfo: 				{InfoNameString := GetTreeInList(CurrentTreeList, ic)^.name;}				InfoNameString := LinkNameFromChain(treechain, LinkNumberFromInfoRow(treeChain,ic));			typeinfo: 				InfoNameString := TypeName(ic);			wtsetinfo,typesetinfo,exsetinfo,charsetinfo,taxsetinfo,charpartinfo: 				InfoNameString := LinkNameFromChain(ChainFromInfo(whichInfo), LinkNumberFromInfoRow(ChainFromInfo(whichInfo),ic) );			nexusblockinfo :				InfoNameString := NexusBlockDisplayName(ic);			charpartnameinfo :				InfoNameString := NameOfCharPartNameFromNumber(ic);			otherwise				InfoNameString := '';		end;	end;		{----------------------------------------------------------------------------}	function DefaultInfoObjectName(whichInfo: integer):  str255;	var ds: str255;	begin		if whichinfo=charpartnameinfo then			ds := concat('group ',StringFromNum(MaximumInfoRows(whichInfo)+1))		else			ds := concat('stored ',StringFromNum(MaximumInfoRows(whichInfo)+1));		DefaultInfoObjectName := ds;	end;end.