unit Export;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, 		Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, 		ErrorUtil, EventUtil, GenUtil, StrUtil, TaxonCHUtil, SymbolsNames, ImpForeignFiles, 		TypeUtil, ExportUtil, SpreadUtil, CharUtil, TreeUtil, CHUNK, ReadWriteUtil, ReadUtil, 		WriteUtil, LinkUtil, TreeMaker, TreeCycle, ExportHTML, StatesWindow;	procedure WriteExportData (filetype: integer);{еееееееееееееееееееееее}implementation {е$S Export}{----------------------------------------------------------------------------}	function MixedTypes (filetype: integer): boolean;		var			ic: integer;			testtype: integer;	begin		if filetype = phylip then			testtype := irreversible		else if (filetype = hennig)| (filetype = nona) then			testtype := unordered;		MixedTypes := false;		for ic := 1 to numchars do			if TrueTypeOfChar(ic) = testtype then				begin					MixedTypes := true;					leave;				end;	end;{----------------------------------------------------------------------------}	const		ccodewt = 0;		ccodetypes = 1;		ccodeexc = 2;{----------------------------------------------------------------------------}	procedure CCodeList (outH: Handle; searchi, ccodekind: integer);		var			charHdl: chHdl;			ds: str255;			secondone, firstone, morethanone: boolean;			ic, startic, endic, oldstartic, oldendic, testi: integer;	begin		secondone := false;		firstone := true;		morethanone := false;		startic := 0;		endic := 0;		for ic := 1 to numchars do			begin				oldstartic := startic;				oldendic := endic;				startic := endic + 1;				endic := startic;				case ccodekind of					ccodewt: 						testi := CharWeight(ic);					ccodetypes: 						testi := TrueTypeOfChar(ic);					ccodeexc: 						if CharIncluded(ic) then							testi := 1						else							testi := 0;					otherwise						;				end;				if testi = searchi then					begin						if ccodekind = ccodewt then							begin								charHdl := getchHdl(ic);								CharHdl^^.extra := true;							end;						if firstone then							begin								NumToString(startic - 1, ds);  {has to be -1 because of Hennig86's 0-based numbering}								AppendToHandle(outH, Concat(' ', ds));								secondone := true;								firstone := false;							end						else if secondone then							begin								AppendToHandle(outH, '.');								secondone := false;								morethanone := true;							end					end				else					begin						if morethanone or (not firstone and (oldstartic <> oldendic)) then							begin								NumToString(oldendic - 1, ds);								AppendToHandle(outH, ds);							end;						secondone := false;						firstone := true;						morethanone := false;					end;			end;		if morethanone or (not firstone and (oldstartic <> oldendic)) then			begin				if morethanone then					oldendic := oldendic + 1;				NumToString(oldendic - 1, ds);				AppendToHandle(outH, ds);			end;	end;{----------------------------------------------------------------------------}	procedure WriteCNames(fileType: integer);		var			state, j: integer;			chunksize: longint;			ic, laststate: integer;			ds: str255;			firstthru, writetheChar: boolean;	begin		firstthru := true;		for ic := 1 to numchars do			begin				laststate := LastStateName(ic);				writetheChar := (not molecular & (laststate >= 0)) |  (CharName(ic) <> '');				if writetheChar then					begin						if firstthru then							begin								putExportReturn(fileType);								putExportReturn(fileType);								PutToken('cnames  ');								putExportReturn(fileType);								firstthru := false;							end;						putTab;						putSingleChar('{');						puttoken(StringFromNum(ic-1));						putSpace;						ds := CharName(ic);						BlanksToUnderline(ds);						puttoken(ds);						putSpace;						if not molecular then							if laststate >= 0 then								begin									CHUNKpos := 0;									for state := 0 to laststate do										begin											ds := GetNextStateName(ic);											if ds = NoName then												ds := '_'											else if ds = EndNames then												leave											else												BlanksToUnderline(ds);											puttoken(ds);											if state <> laststate then												putSpace;										end;								end;						putSingleChar(';');						putExportReturn(fileType);					end;			end;		if not firstthru then			begin				putSingleChar(';');				putExportReturn(fileType);			end;	end;{----------------------------------------------------------------------------}	procedure WriteCCodes;		var			charHdl: chHdl;			H: Handle;			it, ic, j, maxwt, biggestwt, wt, writewt: integer;			goahead, putasterisk: boolean;	begin		H := NewHandle(0);		StringToH('ccode ', H);		putasterisk := false;		if not allwt1 then   {write CCode for wts}			begin				biggestwt := 0;				for ic := 1 to numchars do					begin						wt := CharWeight(ic);						if wt > biggestwt then							biggestwt := wt;						charHdl := GetChHdl(ic);						charHdl^^.extra := wt = 1;					end;				ic := 0;				while ic <= numchars do					begin						repeat							ic := ic + 1;							if ic > numchars then								leave;							charHdl := GetChHdl(ic);						until not charHdl^^.extra;						if ic > numchars then							leave;						wt := IP(GetMaster(chstorewtH) + chwb * longint(ic - 1))^;						if biggestwt > 100 then							writewt := RoundValue(100.0 * wt / biggestwt)						else							writewt := wt;						AppendToHandle(H, concat(' /', StringFromNum(writewt), ' '));						CCodeList(H, wt, ccodewt);					end;				putasterisk := true;			end;		if MixedTypes(hennig) then   {write CCode for types}			begin				if putasterisk then					AppendToHandle(H, ' * ');				AppendToHandle(H, ' -');				CCodeList(H, unordered, ccodetypes);				putasterisk := true;			end;		if numchars <> numcharin then   {write CCode for exc}			begin				if putasterisk then					AppendToHandle(H, ' * ');				AppendToHandle(H, ' ]');				CCodeList(H, 0, ccodeexc);			end;		AppendToHandle(H, ';');		WriteHandle(H,ExportDelimiter[hennig]);		ZapHandle(H);	end;{----------------------------------------------------------------------------}	procedure WriteHennigNonaFile(filetype: integer);		var			it, ic, j: integer;			ds: str255;			tsts: largestsetchars;			writeMatchChar: char;	begin		if filetype<> nona then WriteFileComments;				if matchchar = ' ' then			writeMatchChar := '.'		else		      writeMatchChar := matchChar;		if (filetype=nona) & nucleotides then			begin				puttoken('dread ');				puttoken('gap ? match ');				putSingleChar(writeMatchChar);			end		else			puttoken('xread');		putExportReturn(filetype);		NumToString(numchars, ds);		puttoken(ds);		putSpace;		NumToString(numtaxa, ds);		puttoken(ds);		putExportReturn(filetype);		for it := 1 to numtaxa do			begin				putToken(exportTaxonName(filetype, it, 25));				putSingleChar(' ');				for ic := 1 to numchars do					begin						tsts := gettaxonstsLargest(it, ic);						if (CharMaxstOBS(ic) > 1) then  {multistate character}							begin								if gal in tsts then									putSingleChar('-')								else if msl in tsts then									putSingleChar('?')								else if MultipleStatesLg(tsts) & (filetype=nona) then									begin										putSingleChar('[');										for j := 0 to maxstate do											if j in tsts then												putSingleChar(CharOfNum(j));										putSingleChar(']');									end								else if (filetype=nona)&nucleotides then									if matchcharon & (it <> 1) & (tsts = gettaxonstsLargest(1, ic)) then										putSingleChar(writeMatchChar)									else										putSingleChar(DNARNACharOfSet(tsts))								else									puttoken(StringFromNum(minLg(tsts)));							end						else if gal in tsts then							putSingleChar('-')						else if msl in tsts then							putSingleChar('?')						else if (filetype=nona) then							begin								if MultipleStatesLg(tsts) then									begin										putSingleChar('[');										for j := 0 to maxstate do											if j in tsts then												putSingleChar(CharOfNum(j));										putSingleChar(']');									end								else if nucleotides then									putSingleChar(DNARNACharOfSet(tsts))								else									puttoken(StringFromNum(minLg(tsts)));							end						else if tsts = [0, 1] then							putSingleChar('?')						else if 1 in tsts then							putSingleChar('1')						else if 0 in tsts then							putSingleChar('0')					end;				putExportReturn(filetype);			end;		putSingleChar(';');		putExportReturn(filetype);		WriteCCodes;		if filetype=nona then WriteCNames(fileType);		putExportReturn(filetype);		if UserLinks[datafilechain] > 0 then			WriteForeignTrees(filetype, datafilechain, true);		puttoken('proc/;');	end;{----------------------------------------------------------------------------}	procedure WriteNBRFFastaFile (writegaps: boolean; isNBRF: boolean);		var			it, ic, iwrite: integer;			tsts: largestsetchars;			c: char;			ds: str255;			exportType: integer;	begin		if isNBRF then			exportType := nbrf		else			exportType := fasta;		for it := 1 to numtaxa do			begin				putSingleChar('>');				if (isNBRF) then 					if datatype = protein then						puttoken('P1; ')					else						puttoken('DL; ');				ds := TaxonName(it);				PrepareToken(ds, tnw);				putToken(ds);{v 3.06:  removed following two lines:   putTab;   puttoken(StringFromNum(it));}				putExportReturn(exportType);				if isNBRF then					begin						putToken(ds);						putExportReturn(exportType);					end;				iwrite := 0;				for ic := 1 to numchars do					begin						tsts := gettaxonstsLargestCase(it, ic);						if not (gal in tsts) or writegaps then							begin								iwrite := iwrite + 1;								if (gal in tsts) then									putSingleChar('-')								else if nucleotides then										putSingleChar(DNARNACharOfSet(tsts))								else if datatype = protein then									begin										if tsts=[MSl] then											putSingleChar('X')										else											begin												c := ProteinCharOfSet(tsts);												if c = missing then													c := 'X'												else if c = '*' then   {no use writing any more for this taxon if NBRF}													if isNBRF then 														begin															NewError(468,0);															leave;														end;												putSingleChar(c);											end;									end;								if iwrite mod 75 = 0 then									putExportReturn(exportType);							end;					end;				if isNBRF then					putSingleChar('*');				putExportReturn(exportType);			end;	end;{----------------------------------------------------------------------------}	procedure WritePhylipWeights;	var j,cw: integer;		c: char;	begin		for j := 1 to numchars do			begin				cw := CharWeight(j);				if cw<= 9 then 					c := char(cw + 48)				else if cw <= 37 then					c := char(cw+55)				else c := 'Z';				if molecular & (phylipversion<36) then					if c <> '0' then						begin							if c <> '1' then								NewError(100, 0);							c := '1';						end;		{PHYLIP 3.3-3.5 allows only 0 and 1 as weights in sequence programs}				putSingleChar(c);			end;		putExportReturn(phylip);	end;{----------------------------------------------------------------------------}	procedure WritePhylipFile;		var			it, ic, j, blockstart, blockend: integer;			tsts: largestsetchars;			ds: str255;			domatch, firstblock: boolean;			c: char;{.............}		procedure WritePHYLIPtsts (it, ic: integer);		begin			tsts := gettaxonstsLargestCase(it, ic);{check to see if multistate; check to see if DNA/RNA format}			if domatch & (tsts = gettaxonstsLargest(1, ic)) then				putSingleChar('.')			else if gal in tsts then				putSingleChar('-')			else if nucleotides then				putSingleChar(DNARNACharOfSet(tsts))			else if datatype = protein then				putSingleChar(ProteinCharOfSet(tsts))			else if CharMaxstObs(ic) > 1 then				begin					if gal in tsts then						putSingleChar('-')					else if msl in tsts then						putSingleChar('?')					else						putSingleChar(StandardCharOfNum(minLg(tsts)));				end			else if tsts >= [0, 1] then				putSingleChar('P')			else if 1 in tsts then				putSingleChar('1')			else if 0 in tsts then				putSingleChar('0')			else if msl in tsts then				putSingleChar('?')			else				putSingleChar('?');		end;{.............}	begin		NumToString(numtaxa, ds);		puttoken(ds);		putSpace;		NumToString(numchars, ds);		puttoken(ds);		if phylipversion < 34 then			if UserLinks[datafilechain] > 0 then				puttoken(' U');		if phylipversion <=34 then			begin				if not allwt1 then					puttoken(' W');				if MixedTypes(phylip) then					puttoken(' M')				else if (deftype = dollo) and (phylipversion < 34) then					puttoken(' D');				putExportReturn(phylip);				if not allwt1 then					begin						puttoken('Weights   ');						WritePhylipWeights;					end;				if MixedTypes(phylip) then					begin						puttoken('Mixed     ');						for j := 1 to numchars do							if TrueTypeOfChar(j) = irreversible then								putSingleChar('S')							else								putSingleChar('?');						putExportReturn(phylip);					end;			end		else			putExportReturn(phylip);		if interleave and molecular then			begin				ic := 1;				firstblock := true;				repeat					blockstart := ic;					blockend := ic + interleavelength - 1;					if blockend > numchars then						blockend := numchars;					for it := 1 to numtaxa do						begin							ic := blockstart;							if firstblock then								putToken(exportTaxonName(phylip, it, 10));		{v4: user-specifiable phylip name length}							domatch := matchcharon & molecular & (it > 1);							repeat								WritePHYLIPtsts(it, ic);								ic := ic + 1;							until ic > blockend;							putExportReturn(phylip);						end;					putExportReturn(phylip);					if firstblock then						firstblock := false;				until ic > numchars;  {3.07}			end		else			for it := 1 to numtaxa do				begin					putToken(exportTaxonName(phylip, it, 10));					domatch := matchcharon & molecular & (it > 1);					for ic := 1 to numchars do						WritePHYLIPtsts(it, ic);					putExportReturn(phylip);				end;		if phylipversion <= 34 then			if UserLinks[datafilechain] > 0 then				WriteForeignTrees(phylip, datafilechain, true);	end;{----------------------------------------------------------------------------}	procedure WriteMalignFile;		var			it, ic, icWritten, lasticWritten: longint;			tsts: largestsetchars;			j, blockstart, blockend: longint;			oldstate: SignedByte;			readyForSpace : boolean;{.............}		procedure WriteMaligntsts (it, ic: longint);		begin			tsts := gettaxonstsLargestCase(it, ic);			if gal in tsts then				begin				end			else 				begin					if msl in tsts then						if nucleotides then							putSingleChar('N')						else							putSingleChar('?')					else if nucleotides then						putSingleChar(DNARNACharOfSet(tsts))					else if datatype = protein then						putSingleChar(ProteinCharOfSet(tsts));					icWritten := icWritten+1;				end;		end;{.............}	begin		for it := 1 to numtaxa do			begin				putToken(exportTaxonName(malign, it, tnw + 4));				putExportReturn(malign);				putTab;				putSingleChar('1');				putSpace;				icWritten := 1;				readyForSpace := false;				for ic := 1 to numchars do					begin						lasticWritten := icWritten;						if readyforSpace & (icWritten mod 10 = 0) then 							begin								putSingleChar(' ');							end;						WriteMaligntsts(it, ic);						readyforSpace := icWritten<>lasticWritten;						if readyforSpace& (icWritten mod 60 = 0) then							begin								putExportReturn(malign);								putTab;								putToken(StringFromNum(icWritten+1));								putSpace;							end;											end;				putExportReturn(malign);				putExportReturn(malign);			end;	end;{$SETC MEGA=TRUE}{$IFC MEGA}	var		convertToMissing: boolean;{----------------------------------------------------------------------------}	procedure WriteMEGAFile;		var			it, ic: integer;			tsts: largestsetchars;			j, blockstart, blockend: integer;			oldstate: SignedByte;{.............}		procedure WriteMEGAtsts (it, ic: integer);		begin			tsts := gettaxonstsLargestCase(it, ic);			if matchcharon & (it > 1) & (tsts = gettaxonstsLargest(1, ic)) then				putSingleChar('.')			else if gal in tsts then				putSingleChar('-')			else if msl in tsts then				if nucleotides & AlternativeSymbol(it,ic) then					putSingleChar('N')				else					putSingleChar('?')			else if convertToMissing & (CardLg(tsts) > 1) then				putSingleChar('?')			else if nucleotides then				putSingleChar(DNARNACharOfSet(tsts))			else if datatype = protein then				putSingleChar(ProteinCharOfSet(tsts));		end;{.............}	begin		putToken('#MEGA');		putExportReturn(mega);		putToken('TITLE  exported by MacClade from file ');		LockHandle(filename, oldstate);		putToken(filename^^);		UnLockHandle(filename, oldstate);		putExportReturn(mega);		putExportReturn(mega);		if interleave and molecular then			begin				ic := 1;				repeat					blockstart := ic;					blockend := ic + interleavelength - 1;					if blockend > numchars then						blockend := numchars;					for it := 1 to numtaxa do						begin							ic := blockstart;							putSingleChar('#');							putToken(exportTaxonName(mega, it, tnw + 4));							repeat								WriteMEGAtsts(it, ic);								ic := ic + 1;							until ic > blockend;							putExportReturn(mega);						end;					putExportReturn(mega);				until ic >= numchars;			end		else			for it := 1 to numtaxa do				begin					putSingleChar('#');					putToken(exportTaxonName(mega, it, tnw + 4));					for ic := 1 to numchars do						WriteMEGAtsts(it, ic);					putExportReturn(mega);				end;	end;{----------------------------------------------------------------------------}	procedure CheckMEGALegality;		label			1;		var			it, ic: integer;	begin		if not molecular then			begin				errorflag := true;				InstantInfo('Only molecular sequence data can be exported to MEGA.');			end		else			for it := 1 to numtaxa do				for ic := 1 to numchars do					if MultipleStatesLg(gettaxonstsLargest(it, ic)) then						begin							case DoAlert(160, CautionA) of								1: 									errorFlag := true;								2: 									convertToMissing := true;								otherwise									;							end;							goto 1;						end;1:	end;{$ENDC}{----------------------------------------------------------------------------}	procedure CheckHennigLegality(isNona:boolean);		label			1;		var			it, ic: integer;	begin		if AnyType([dollo, fisher, irreversible, usedef]) then			begin				errorflag := true;				InstantError(211);			end;		for ic := 1 to numchars do			if CharMaxstOBS(ic) > 9 then				begin					InstantError(212);					errorflag := true;					leave;				end;		if not isNona then			for it := 1 to numtaxa do				for ic := 1 to numchars do					if MultipleStatesLg(gettaxonstsLargest(it, ic)) then						begin							errorFlag := true;							InstantError(213);							goto 1;						end;1:	end;{----------------------------------------------------------------------------}	function ExtraProteinStates: boolean;		var			extraaapresent: aaset;			tsts: largestSetChars;			j: integer;	begin		extraaapresent := [];		for j := 1 to 4 do			{if extraAAstates[j] >= 0 then }				extraaapresent := extraaapresent + [maxAAstate + j];		ExtraProteinStates := CheckAAInMatrix(extraaapresent,false,tsts);	end;{----------------------------------------------------------------------------}	procedure CheckPhylipLegality;		label			1;		var			it, ic: integer;	begin{v4: what about if dollo and DNA file; this is not acceptable either (although very unlikely to cause problems)}		if AnyType([fisher, usedef]) then			begin				errorflag := true;				InstantError(214);			end;		if datatype in [standard, standard32] then			for ic := 1 to numchars do				if CharMaxstOBS(ic) > 1 then					begin						InstantError(215);						errorflag := true;						leave;					end;		if (datatype = protein) & ExtraProteinStates then			begin				InstantError(234);				errorflag := true;			end;		if not nucleotides then  {3.06: not nucleotides added}			for it := 1 to numtaxa do				for ic := 1 to numchars do					if (MultipleStatesLg(gettaxonstsLargest(it, ic))) & (CharMaxstOBS(ic) > 1) then						begin							errorFlag := true;							InstantError(216);							goto 1;						end;1:	end;{----------------------------------------------------------------------------}	procedure WriteForeignFile(filetype: integer; dotitles, dostates, maccladereadable, dostatenames, doFeet: boolean);	begin		StartWrite;		case filetype of			simpletext: 				WriteTextFile(dotitles, dostates, maccladereadable, dostatenames, doFeet);			descriptions: 				WriteDescriptionsFile;{$IFC MEGA}			mega: 				WriteMEGAFile;{$ENDC}			hennig,nona: 				WriteHennigNonaFile(filetype);			phylip: 				WritePhylipFile;			NBRF: 				WriteNBRFFastaFile(true,true);			NBRFNoGaps: 				WriteNBRFFastaFile(false,true);			FASTA:				WriteNBRFFastaFile(false,false);			malign:				WriteMalignFile;			otherwise				;		end;  {end case of filetype}		EndWrite;		end;{----------------------------------------------------------------------------}	function QueryNBRFOptions:boolean;	begin		nbrfCondenseNames := true;		nbrfCreateTranslationTable := true;		QueryNBRFOptions := true;	end;{----------------------------------------------------------------------------}	function QueryExportOptions(filetype: integer; var dotitles, dostates, maccladereadable, dostatenames, doFeet: boolean):boolean;	begin		QueryExportOptions := true;		case filetype of			simpletext: 				QueryExportOptions := QueryText(dotitles, dostates, maccladereadable, dostatenames, doFeet);			descriptions: 				;{$IFC MEGA}			mega: 				;{$ENDC}			hennig,nona: 				;			phylip: 				;			NBRF: 				QueryExportOptions := QueryNBRFOptions;			NBRFNoGaps: 				QueryExportOptions := QueryNBRFOptions;			otherwise				;		end;  {end case of filetype}	end;{----------------------------------------------------------------------------}	procedure SaveExtraFiles(ds: str255; filetype: integer);	var oldexists, db: boolean;		Freply: StandardFileReply;		tempFs: FSSpec;	begin		case filetype of			phylip:				SFPutSuffixedFile(ds, '.wts', 'Save PHYLIP weights file as:', fReply);			otherwise;		end;		if Freply.sfgood then			begin				FSpCreateSaveFile(Freply.sfFile, oldexists, 'ttxt', 'TEXT');					if not Errorflag then						begin							if oldexists then   								tempFs:= Freply.sffile;													StartWrite;							case filetype of								phylip:									WritePhylipWeights;								otherwise;							end;							EndWrite;							if oldexists then								FSpExchangeFilesDeleteTemp(tempFs)							else 								tempFs:= FDI^[writeFileFDI].fs; 						end					else						begin							currentIOPosition := 48;   {v3.05}							db := IOSuccessful(resultcode);						end;			end;	end;{----------------------------------------------------------------------------}	function ShouldSaveExtraFiles(filetype: integer):boolean;	begin		ShouldSaveExtraFiles:= false;		case filetype of			phylip:				ShouldSaveExtraFiles :=  (phylipversion>34) & not allwt1;			nbrf, nbrfnogaps:				ShouldSaveExtraFiles := false;			otherwise;		end;	end;{----------------------------------------------------------------------------}	procedure WriteExportData (filetype: integer);		label			1;		var			theInfo: FInfo;			thefile: integer;			writename, ds: str255;			oldexists, db: boolean;			dostates, dotitles, dostatenames, maccladereadable, olddrawstates, doFeet: boolean;			Freply: StandardFileReply;			tempFs: FSSpec;			response: integer;			dataP:  Ptr;	begin		if dirtymaxst then   {note: this will only be called if currentDataP^.editorOpen}			ReCalcMaxstAndStates(1,numchars);		ReturnAllInfoValues;		if statesWindowOpen then			begin				TurnOffSymbolsEditing;				TurnOffStatesEditing;			end;		convertToMissing := false;		oldexists := false;		ds := filename^^;		maccladereadable := false;		if not QueryExportOptions(filetype,dotitles, dostates, maccladereadable, dostatenames, doFeet) then goto 1;				case filetype of			simpletext: 				SFPutSuffixedFile(ds, '.table', 'Save table file as:', Freply);{$IFC MEGA}			mega: 				SFPutSuffixedFile(ds, '.MEG', 'Save MEGA file as:', fReply);{$ENDC}			hennig: 				SFPutSuffixedFile(ds, '.HNG', 'Save HENNIG86 file as:', fReply);			nona: 				SFPutSuffixedFile(ds, '.NON', 'Save Nona/PiWe file as:', fReply);			phylip: 				SFPutSuffixedFile(ds, '.PHYLIP', 'Save PHYLIP file as:', fReply);			descriptions: 				SFPutSuffixedFile(ds, '.desc', 'Save descriptions as:', fReply);			NBRF, NBRFNoGaps: 				SFPutSuffixedFile(ds, '.NBRF', 'Save NBRF file as:', fReply);			FASTA:				SFPutSuffixedFile(ds, '.fas', 'Save FASTA file as:', fReply);			malign: 				SFPutSuffixedFile(ds, '.mal', 'Save MALIGN file as:', fReply);			htmlMatrix: 				begin					if  QueryExportData(filetype, dataP, response) then						SFPutSuffixedFile(ds, '.html', 'Save HTML file(s) as:', fReply)					else						Exit(WriteExportData);				end;							otherwise				;		end;		ShowCursor;		if Freply.sfgood then			begin				case filetype of					hennig,nona: 						CheckHennigLegality(filetype=nona);					phylip: 						CheckPhylipLegality;{$IFC MEGA}					mega: 						CheckMEGALegality;{$ENDC}					malign:						begin							if not molecular then errorflag := true;						end;					otherwise						;				end;				if not errorflag then					if filetype = htmlMatrix then						begin							ExportData(htmlMatrix,fReply.sfFile,dataP);						end					else						begin							FSpCreateSaveFile(Freply.sfFile, oldexists, 'ttxt', 'TEXT');							if not Errorflag then								begin									if oldexists then   										tempFs:= Freply.sffile;  {this is the ultimate destination}																	WriteForeignFile(filetype,dotitles, dostates, maccladereadable, dostatenames, doFeet);									if oldexists then										FSpExchangeFilesDeleteTemp(tempFs)  									else 										tempFs:= FDI^[writeFileFDI].fs; 								end							else								begin									currentIOPosition := 48;   {v3.05}									db := IOSuccessful(resultcode);								end;						end;			end		else			Errorflag := true;					if not errorFlag  & ShouldSaveExtraFiles(fileType) then			SaveExtraFiles(ds,fileType);		1:	end;end.