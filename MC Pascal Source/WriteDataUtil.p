unit WriteDataUtil;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  		ReadMisc, MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, 		Thermos, FootNote, GeneticCode, SymbolsNames, Settings, TypeUtil, CharUtil, TreeUtil, SpreadUtil, DrawSpread, 		LinkUtil, Windows, WriteUtil, NexusBlocks,ReadWriteGeneticCode;	var		mst: boolean;		saveAsStationery: boolean;	function NeedMacCladeInfoStart: boolean;	procedure WriteMacCladeInfoStart;	procedure WriteCharTaxList (extendH: Handle; searchi, inc: integer; characterChain: boolean);	procedure WriteFORMAT;	procedure WriteIGNORE;	procedure WriteOPTIONS;	procedure WriteUserTypes;	procedure WriteTaxLabels;	procedure WriteCharLabels;	procedure WriteStateLabels;	procedure WriteCharStateLabels (includeCharacterNames: boolean);	procedure WriteDecimalRGB (theColor: RGBColor);	procedure WriteNotesBlock;	procedure WriteCODONSBlock;	procedure	WriteForeignNexusBlock(theNexusBlock: NexusBlockPtr);	procedure	WriteForeignBlocksAfterMacCladeBlock(blocktype: integer);{	procedure WriteForeignBlock (var fb: integer);}	procedure WriteFileSettings;	{еееееееееееееееееееееее}implementation {е$S WriteDataUtil}{----------------------------------------------------------------------------}	function NeedMacCladeInfoStart: boolean;	begin		NeedMacCladeInfoStart := (datatype = standard32);	end;{----------------------------------------------------------------------------}	procedure WriteMacCladeInfoStart;	begin		putTokenReturn('BEGIN MacCladeStart;');		if (datatype = standard32) then			begin				putTab;				putTokenReturn('Extended;');			end;		putEndOfBlock;	end;{----------------------------------------------------------------------------}	procedure WriteTripletList (startpatch, lastOneInPatch: integer);	begin		if lastOneInPatch = startpatch + 3 then {v3.05}			begin				putSpace;				puttoken(StringFromNum(lastOneInPatch));			end		else			begin				putSingleChar('-');				puttoken(StringFromNum(lastOneInPatch));				puttoken('\3');			end;	end;{----------------------------------------------------------------------------}	function CheckIntAtPointer (P: univ Ptr; value: longint; inc: integer): boolean;	begin		CheckIntAtPointer := false;		if inc = 2 then			CheckIntAtPointer := IP(P)^ = value		else if inc = 4 then			CheckIntAtPointer := LIP(P)^ = value;	end;{----------------------------------------------------------------------------}	procedure WriteCharTaxList (extendH: Handle; searchi, inc: integer; characterChain: boolean);{procedure looks at extendH for characters with value searchi  (where each character takes up}{inc bytes in extendH, and appends onto compactH a NEXUS charlist for all characters having }{searchi}{also works for taxsets; in this case, characterChain is set to false}		label			1, 2;		var			charHdl: chHdl;			taxonHdl: tHdl;			ds: str255;			secondone, firstone, morethanone, twoInRow: boolean;			putHyphen: boolean;			ir, startpatch, lastOneMatched, lastOneInPatch: integer;			P: Ptr;			writeNextir: boolean;			numElements: integer;			offset: integer;			oldState: SignedByte;	begin		if characterChain then			numElements := numchars		else			numElements := numtaxa;		twoInRow := false;		putHyphen := false;		secondone := false;		offset := LinkOffset(extendH);		firstone := true;		morethanone := false;		LockHandle(extendH, oldstate);		P := Ptr(GetMaster(extendH) + offset);		ir := 1;1:		repeat			if CheckIntAtPointer(P, searchi, inc) then				begin					if characterChain then						begin							charHdl := getchHdl(ir);							CharHdl^^.extra := true;  {v4: this is currently only used for wtset; for others, it is not used, and is}											{currently not zeroed before writing. !!!!!     mark that this one is already done}						end					else						begin							taxonHdl := gettaxonHdl(ir);							taxonHdl^^.extra := true;		{v4: this is currently only used for wtset; for others, it is not used, and is}												{currently not zeroed before writing. !!!!! }						end;					if firstone then   {this is our first one in a patch}						begin							putSpace;							puttoken(StringFromNum(ir));							secondone := true;							firstone := false;{================= nucleotide \3 writing  ================}							if nucleotides & characterChain then  {v3.04: added this section to write /3 for nucleotides}								begin									startpatch := ir;									lastOneMatched := ir;									lastOneinPatch := ir;{== this loop looks for patches of \3 ==}									repeat										writeNextir := false;										ir := ir + 1;										if ir > numchars then  {can be greater than numchars if have gone back to 1}											begin{ir := numchars;  v3.06}												leave;											end;										P := Ptr(ord4(P) + inc);										if CheckIntAtPointer(P, searchi, inc) then											begin												charHdl := getchHdl(ir);  {v3.05}												CharHdl^^.extra := true;  {v3.05}												twoInRow := lastOneMatched = ir - 1;												lastOneMatched := ir;											end;										if CheckIntAtPointer(P, searchi, inc) & ((ir - startpatch) mod 3 = 0) then											lastOneInPatch := ir;   {this is the last one in the triplet patch}									until (ir >= numChars) or (CheckIntAtPointer(P, searchi, inc) <> ((ir - startpatch) mod 3 = 0));{== we have bailed out of this loop, let's process ==}{if (intP^ = searchi) <> ((ir - startpatch) mod 3 = 0) then}{we have something unexpected, not a multiple of 3 since startpatch}{so we will process what we have then start again}									if lastOneInPatch = startpatch then  {previous patch consists of only one element}																				{so we don't need to write \3}										begin											if twoInRow & CheckIntAtPointer(P, searchi, inc) then {two in a row - we have taken care of first, which was}{written as a single entry (this we know as lastOneInPatch=startpatch), so let's worry about the next one.}												begin													secondone := true;													firstone := false;													morethanone := true;{    if ir = numchars then begin putSpace; puttoken(StringFromNum(ir)); end;}												end											else  {not two in a row - but we have taken care of the previous patch.  Now we just need}{to worry about ir, which may or may not be one of the set.  let's just go back to the start...}												begin													secondone := false;													firstone := true;{morethanone := false;}  {v 3.06}													if ir <= numchars then														goto 1; {we want to start the whole cycle again to pick up this one}												end;{if intP^ = searchi then }										end									else    {previous patch consists of more than one element, we will need to write \3}										begin											secondone := false;											firstone := true;											WriteTripletList(startpatch, LastOneInPatch);{if intP^ = searchi then}											if ir <= numchars then												goto 1; {we want to start the whole cycle again to pick up this one}										end;								end;{================= end nucleotide \3 writing  ================}						end					else if secondone then  {this is second one in a patch}						begin{    putSingleChar('-');}							secondone := false;							morethanone := true;							twoInRow := false;							putHyphen := true;						end				end			else				begin   {we are just past the end of a patch}					secondone := false;					firstone := true;					if morethanone then						begin							if putHyphen then								putSingleChar('-')							else								putSpace;							puttoken(StringFromNum(ir - 1));						end;					putHyphen := false;					morethanone := false;				end;2:			P := Ptr(ord4(P) + inc);			ir := ir + 1;		until ir > numElements;		if ir > numElements + 1 then  {v3.06}			ir := numElements + 1;		if morethanone then			begin				if putHyphen then					putSingleChar('-')				else					putSpace;				puttoken(StringFromNum(ir - 1));			end;		ResetHandle(extendH, oldState);	end;{-----------------------------------------------------------------------------}	function CheckMSTaxa: boolean; {returns true if there are multistate taxa, false if not}{function also serves to set value of mstaxa}		label			1;		var			it, ic: integer;			tsts: largestsetchars;			polyfound, uncertfound: boolean;	begin		checkMSTaxa := true;		polyfound := false;		uncertfound := false;		for it := 1 to numtaxa do			for ic := 1 to numchars do				begin					tsts := gettaxonstsLargest(it, ic);					if MultipleStatesLg(tsts) then						begin							if UCl in tsts then								uncertfound := true							else								polyfound := true;							if uncertfound and polyfound then								begin									mstaxa := mstVariable;									goto 1;								end;						end;				end;		if uncertfound then			mstaxa := mstUncertain		else if polyfound then			mstaxa := mstPolymorph		else			begin				mstaxa := mstVariable;				CheckMSTaxa := false;			end;1:	end;{-----------------------------------------------------------------------------}	procedure WriteIGNORE;	begin		if (ignore = uninform) or (ignore = invar) or (ignore = ignorenone) then			case ignore of				uninform: 					puttoken(' IGNORE=UNINFORM ');				invar: 					puttoken(' IGNORE=INVAR ');				ignorenone: 					puttoken(' IGNORE=NONE ');				otherwise					;			end;	end;{-----------------------------------------------------------------------------}	procedure WriteOPTIONS;  {old DATA block options}	begin		if not fullNexus1 then			begin				mst := CheckMSTaxa;				if mst or (ignore = uninform) or (ignore = invar) or (ignore = ignorenone) then					begin						puttoken('OPTIONS ');						if mst then							case mstaxa of								mstVariable: 									puttoken(' MSTAXA=VARIABLE ');								mstUncertain: 									puttoken(' MSTAXA=UNCERTAIN ');								mstPolymorph: 									puttoken(' MSTAXA=POLYMORPH ');							end;						WriteIGNORE;						putSingleChar(';');						putReturn;					end;			end;	end;{-----------------------------------------------------------------------------}	function MaxFileState: integer;		var			maxmax, j: integer;			oldsymbols: str255;	begin		maxmax := MOS;{=== checking types ===}		if numtypes >= usedef then			maxmax := MaxStateDefinedAllUseDef(false);{=== check symbols ===}		oldsymbols := symbols;		symbols := CopyString(symbols, 1, MOS + 1);		FillRestSymbols;		if symbols <> oldsymbols then   {then the symbols after MOS are not what one would expect from default symbol filling}			begin				for j := IntegerMin(length(symbols), length(oldsymbols)) downto 1 do					if symbols[j] <> oldsymbols[j] then						leave;				symbols := oldsymbols;				if j - 1 > maxmax then					maxmax := j - 1;			end;		if maxmax < 1 then			maxmax := 1;		MaxFileState := maxmax;	end;{-----------------------------------------------------------------------------}	procedure WriteFORMAT;		var			c: char;			j: integer;			MFS: integer;	begin		putTabtoken('FORMAT');		if datatype = DNA then			puttoken(' DATATYPE=DNA ')		else if datatype = RNA then			puttoken(' DATATYPE=RNA ')		else if datatype = protein then			begin				puttoken(' DATATYPE=PROTEIN ');				puttoken(' SYMBOLS = " 1 2 3 4" ');			end		else			begin				MFS := MaxFileState;				if (MFS > 1) | (datatype = standard32) | ((length(symbols) > 0) & (symbols[1] <> '0')) | ((length(symbols) > 1) & (symbols[2] <> '1')) then					begin						puttoken(' SYMBOLS');{if (datatype = standard32) and (MFS < 10) then puttoken(MCFlagString);}						puttoken('= "');						for j := 0 to MFS do							begin								putSpace;								putSingleChar(CharOfNum(j));							end;						putSingleChar('"');					end;			end;		c := missing;		if c = ' ' then			c := '?';		puttoken(' MISSING=');		putSingleChar(c);		putSpace;		if gap <> UndefinedGap then			begin				puttoken('GAP=');				putSingleChar(gap);				putSpace;			end;		if matchcharon then			begin				puttoken(' MATCHCHAR=');				c := matchchar;				if c = ' ' then					c := '.';				putSingleChar(c);				putSpace;			end;		if interleave and not editorTransposed then			puttoken(' INTERLEAVE ')		else if editorTransposed then			puttoken(' TRANSPOSE ');		putSingleChar(';');{    putReturn;}	end;{-----------------------------------------------------------------------------}	procedure WriteUserTypes;		var			di: str255;			cr: integer;			j, k, mm, isto, isfrom, dspos, qsum, qj, maxdist: integer;			tname: str255;			itsreal: boolean;			ddist: distancetype;{.....................}		procedure SaveDesc (iat, ifrom: integer);			var				ir: integer;				first: boolean;		begin			putSingleChar('(');			first := true;			for ir := 0 to maxCS do				if ir in (typeHdl^^.nbors[iat] - [ifrom]) then					begin						if not first then							putSingleChar(',');						first := false;						if typeHdl^^.nbors[ir] - [iat] <> [] then							SaveDesc(ir, iat);						if ir <= maxstate then							begin								putSingleChar(CharOfNum(ir));							end;					end;			putSingleChar(')');		end;{.....................}		procedure WriteTypeDistValue (j, k: integer);		begin			if (j = k) and (ddist[j, k] = 0) then				begin					if itsreal then						di := ' . '					else						di := '.';				end			else if (ddist[j, k] = infinity) then				begin					if itsreal then						di := ' i '					else						di := 'i';				end			else				begin					qsum := ddist[j, k];					if itsreal then						di := concat(StringFromNum(qsum div TypeInflate), '.', StringFromNum(qsum mod TypeInflate))					else						NumToString(qsum, di);				end;			putSpace;			puttoken(di);		end;{.....................}		procedure TypeHeader;			var				j: integer;		begin			puttoken(tname);			if fullNexus1 then				Puttoken(' (STEPMATRIX) = ')  {v3.05: parentheses}			else if itsreal then				Puttoken(' REALMATRIX = ')			else				Puttoken(' STEPMATRIX= ');			puttoken(StringFromNum(mm));			putReturn;			putTab;			puttoken('    ');			for j := 0 to maxdist do				if j in typeHdl^^.setdefined then					begin						putSpace;						if itsreal then							putSpace;						putSingleChar(CharOfNum(j));						if itsreal then							putSpace;					end;			putReturn;			putTab;		end;{...................}		procedure PutSideSymbol (num: integer);		begin			putSpace;			putSingleChar('[');			putSingleChar(CharOfNum(num));			putSingleChar(']');		end;{.....................}	begin		for cr := fisher to numtypes do  {fisher and user-defined types}			begin				if ErrorFlag then					Exit(WriteUserTypes);				if cr <> dollo then					begin						maxdist := MaxStateDefined(cr);						typeHdl := GetTypeHdl(cr);						if (cr <> fisher) or (fisheredited) then							begin								WriteUnit := WriteUnit + 1;								UpdateThermo(iothermo, 0, WriteUnit, TotWriteUnits, true);								tname := typeHdl^^.name;								PrepareToken(tname, typesig);								if typeHdl^^.root < 0 then	{it's a stepmatrix or STRATTYPE}{||||||||||||||| STRATTYPE ||||||||||||||||}									if cr = fisher then										begin											ddist := typeHdl^^.dist;											putTab;											puttoken('USERTYPE ');											puttoken(tname);											if fullNexus1 then												PutToken(' (STRATTYPE) = ') {NEXUS: v3.05: parentheses}											else												PutToken(' STRATTYPE = ');											puttoken(StringFromNum(maxdist));											putReturn;											putTab;											for k := 0 to maxdist - 1 do												begin													if (ddist[k, k + 1] = infinity) then														di := 'i'													else														begin															qsum := ddist[k, k + 1];															di := concat(StringFromNum(qsum div TypeInflate), '.', StringFromNum(qsum mod TypeInflate))														end;													putSpace;													puttoken(di);												end;											putSingleChar(';');											putReturn;										end{||||||||||||||| STEPMATRIX ||||||||||||||||}									else										begin											ddist := typeHdl^^.dist;											itsreal := typeHdl^^.isreal;											putTab;											puttoken('USERTYPE ');											mm := NumSetDefined(cr);											if mm > maxstate + 1 then  {has to be plus 1, eg. for DNA maxstate = 3, but mm = 4}												mm := maxstate + 1;											TypeHeader;											for j := 0 to maxdist do												if j in typeHdl^^.setdefined then													begin														PutSideSymbol(j);														for k := 0 to maxdist do															if k in typeHdl^^.setdefined then																WriteTypeDistValue(j, k);														putReturn;														putTab;													end;											putSingleChar(';');											putReturn;										end{||||||||||||||| CSTREE ||||||||||||||||}								else		{it's a cstree}									begin										putTab;										puttoken('USERTYPE  ');										puttoken(tname);										if fullNEXUS1 then											puttoken(' (CSTREE) = ') {NEXUS: v3.05: parentheses}										else											puttoken(' CSTREE = ');										k := typeHdl^^.root;										SaveDesc(k, k);										if k <= maxstate then											putSingleChar(CharOfNum(k));										putSingleChar(';');										putReturn;									end;							end;					end;				putReturn;			end;	end;{----------------------------------------------------------------------------}	procedure WriteTaxLabels;		var			it: integer;			ds: str255;	begin{    putReturn;}		putTabToken('TAXLABELS');		for it := 1 to numtaxa do			begin				putReturn;				putTab;				ds := TaxonName(it);				PrepareToken(ds, tnw);				if ItalicTaxon(it) then					puttoken('[\i]');				puttoken(ds);{    if ItalicTaxon(it) then putToken(MCFlagString);}				if ItalicTaxon(it) then					puttoken('[\p]');				if ErrorFlag then					Exit(WriteTaxLabels);			end;		putSingleChar(';');		putReturn;	end;{----------------------------------------------------------------------------}	procedure WriteCharLabels;		var			ic, endchar: integer;			ds: str255;	begin		endchar := numchars;		while (endchar > 0) and (CharName(endchar) = '') do			endchar := endchar - 1;		if endchar > 0 then			begin				putReturn;				puttoken('CHARLABELS');				for ic := 1 to endchar do					begin						ds := CharName(ic);						PrepareToken(ds, cnw);						if singleCharNamePerLine | ((ic - 1) mod 5 = 0) then							putReturn;						putTab;						putSingleChar('[');						puttoken(StringFromNum(ic));						putSingleChar(']');						putTab;						puttoken(ds);						if ErrorFlag then							Exit(WriteCharLabels);					end;				PutReturn;				PutTab;				putSingleChar(';');				putReturn;			end;	end;{----------------------------------------------------------------------------}	procedure WriteStateLabels;		var			state, j: integer;			chunksize: longint;			ic, laststate: integer;			ds: str255;			firstthru: boolean;	begin		if not molecular then			begin				firstthru := true;				for ic := 1 to numchars do					begin						laststate := LastStateName(ic);						if laststate >= 0 then							begin								if firstthru then									begin										PutTokenReturn('STATELABELS  ');										firstthru := false;									end;								putTab;								puttoken(StringFromNum(ic));								putSpace;								putSpace;								CHUNKpos := 0;								for state := 0 to laststate do									begin										ds := GetNextStateName(ic);										if ds = NoName then											ds := '_'										else if ds = EndNames then											leave										else											PrepareToken(ds, stnw);										puttoken(ds);										if state <> laststate then											putSpace;									end;								putSingleChar(',');								putReturn;							end;					end;				if not firstthru then					begin						putSingleChar(';');						putReturn;					end;			end;	end;{----------------------------------------------------------------------------}	procedure WriteCharStateLabels (includeCharacterNames: boolean);		var			state, j: integer;			chunksize: longint;			ic, laststate: integer;			ds: str255;			firstthru, writetheChar: boolean;	begin		firstthru := true;		for ic := 1 to numchars do			begin				laststate := LastStateName(ic);				writetheChar := (not molecular & (laststate >= 0)) | (includeCharacterNames & (CharName(ic) <> ''));				if writetheChar then					begin						if firstthru then							begin								putReturn;								putTab;								PutTokenReturn('CHARSTATELABELS  ');							end;						if singleCharNamePerLine or firstThru then							begin								putTab;								putTab;							end						else 							begin								putSpace;								putSpace;							end;						firstthru := false;						puttoken(StringFromNum(ic));						putSpace;						putSpace;						if includeCharacterNames then							begin								ds := CharName(ic);								PrepareToken(ds, cnw);								puttoken(ds);							end;						if not molecular then							if laststate >= 0 then								begin									puttoken(' / ');									CHUNKpos := 0;									for state := 0 to laststate do										begin											ds := GetNextStateName(ic);											if ds = NoName then												ds := '_'											else if ds = EndNames then												leave											else												PrepareToken(ds, stnw);											puttoken(ds);											if state <> laststate then												putSpace;										end;								end;						if ic <> numchars then							putSingleChar(',');						if singleCharNamePerLine then {single per line}							putReturn						else if molecular & ((ic - 1) mod 5 = 0) then							putReturn						else if not molecular & ((((ic - 1) mod 5 = 0) & (ic>1)) | (laststate >= 0) | (ic >= numchars) | (LastStateName(ic + 1) > 0)) then							putReturn;					end;			end;		if not firstthru then			begin				putTab;				putTab;				putSingleChar(';');				putReturn;			end;	end;{----------------------------------------------------------------------------}	procedure WriteNote (it, ic: integer; theFoot: integer);		var			dL: longint;			ds: str255;			resID: integer;	begin		puttab;		if theFoot = footText then			putToken('TEXT ')		else if theFoot = footPict then			putToken('PICTURE ');{$IFC FOOTSOUNDS}		else if theFoot = footSound then			putToken('SOUND ');{$ENDC}		if it > 0 then			begin				putToken(' TAXON=');				putToken(StringFromNum(it));			end;		if ic > 0 then			begin				putToken(' CHARACTER=');				putToken(StringFromNum(ic));			end;		if theFoot = footText then			begin				if GetFootString(footText, it, ic, ds) then					begin						putToken(' TEXT= ');						putLegalToken(ds);					end;			end		else if theFoot = footPict then			begin				if GetFootLongint(footPict, it, ic, dL) then					begin						putToken(' FORMAT=PICT SOURCE=RESOURCE ');						putToken(' PICTURE= ');						WriteFootResource(footPict, dL, resID);						putToken(StringFromNum(resID));					end;			end;{$IFC FOOTSOUNDS}		else if theFoot = footSound then			begin				if GetFootLongint(footSound, it, ic, dL) then					begin						putToken(' FORMAT=MACSND SOURCE=RESOURCE ');						putToken(' SOUND= ');						putToken(StringFromNum(dL));					end;			end;{$ENDC}		putSingleChar(';');		putReturn;	end;{----------------------------------------------------------------------------}	procedure WriteFeet (theFoot: integer);{writes all of the feet of type theFoot}		var			it, ic: integer;			startFoot, curPos: longint;			footlength: integer;			oldstate: SignedByte;	begin		LockHandle(footH[theFoot], oldstate);		putReturn;		startFoot := GetMaster(footH[theFoot]);		curPos := 0;		repeat			GetFootTaxChar(it, ic, startFoot, curPos);			WriteNote(it, ic, theFoot);			if footBytes[theFoot] = variableFeet then				footlength := IP(startFoot + curPos + 4)^ + 2   {+2 for the 2 length bytes themselves}			else				footlength := footBytes[theFoot];			curPos := curpos + 4 + footlength;			if odd(footlength) then				curPos := curPos + 1;		until curpos >= GetHandleSize(footH[theFoot]);		UnLockHandle(footH[theFoot], oldstate);	end;{----------------------------------------------------------------------------}	procedure WriteDecimalRGBComponent(RGBValue: integer);	var 	colorValue: double;		RGBValueLong: longint;		ds: str255;	begin		RGBValueLong := RGBValue;		if RGBValue<0 then			RGBValueLong := 32767+(32767+RGBValueLong);		colorValue := 1.0* (RGBValueLong)/65535;		RealtoString (colorValue, ds, 10000000, 5, false);		puttoken(ds);		putSpace;	end;{----------------------------------------------------------------------------}	procedure WriteDecimalRGB (theColor: RGBColor);	var 	colorValue: double;		RGBValueLong: longint;		ds: str255;	begin		WriteDecimalRGBComponent(theColor.red);		WriteDecimalRGBComponent(theColor.green);		WriteDecimalRGBComponent(theColor.blue);	end;{----------------------------------------------------------------------------}	procedure WriteNotesBlock;		var			theFoot: integer;			somefeet: boolean;			ds : str255;			theNexusBlock: NexusBlockPtr;	begin		if ShouldWriteNexusBlock(notesBlock) then			begin				puttoken('BEGIN NOTES;');				putReturn;				theNexusBlock := NexusBlockFromBlockType(notesBlock);				WriteNexusBlockTitle(theNexusBlock);				WriteNexusBlockLinkText(theNexusBlock);				for theFoot := 0 to maxfoottype do					if AnyFeet(theFoot) then						WriteFeet(theFoot);				WriteForeignLinesInBlock(notesBlock);				putEndOfBlock;			end;	end;{----------------------------------------------------------------------------}	procedure WriteCODONSBlock;		type			bools3 = array[-1..3] of boolean;		var			extendH: Handle;			exP: IP;			ic, thePos, j: integer;			pospresent: bools3;{    somecoding: boolean;}			lastpospresent: integer;			offset: integer;			theNexusBlock: NexusBlockPtr;	begin		pospresent[-1] := false;		pospresent[0] := false;		pospresent[1] := false;		pospresent[2] := false;		pospresent[3] := false;{$IFC FALSE}{don't need this anymore as someCoding is kept globally up to date}		somecoding := false;		for ic := 1 to numchars do			if not (CharCodPos(ic) = codeNotSet) then				begin					somecoding := true;					leave;				end;{$ENDC}		if nucleotides then			symbols := 'ACDEFGHIKLMNPQRSTVWY*1234';		PutTokenReturn('BEGIN CODONS;');		theNexusBlock := NexusBlockFromBlockType(codonsBlock);		WriteNexusBlockTitle(theNexusBlock);		WriteNexusBlockLinkText(theNexusBlock);		if nucleotides and someCodPosSet then			begin				putTabtoken('CODONPOSSET * CodonPositions = ');  {v3.05: changed to CODONPOSSET format}				extendH := NewHandle(0);				ClearLinkBytes(extendH);				SetLinkName(extendH, 'CodonPositions');				offset := LinkOffset(extendH);				SetHandleSize(extendH, offset + ord4(numchars) * chwb);				HLock(extendH);				for ic := 1 to numchars do					begin						exP := IP(GetMaster(extendH) + offset + chwb * longint(ic - 1));						thepos := CharCodPos(ic);						exP^ := thePos;						if thePos >= -1 then							pospresent[thePos] := true;					end;				HUnLock(extendH);				for j := 3 downto -1 do					//if j <> codeNotSet then						if pospresent[j] then						begin							lastpospresent := j;							leave;						end;				for j := -1 to 3 do					//if j <> codeNotSet then					if pospresent[j] then						begin							putSingleChar(chr(13));							putSingleChar(chr(9));							putSingleChar(chr(9));							if j = codeNotSet then								putSingleChar('?')							else if j = nonCoding then								putSingleChar('N')							else								puttoken(StringFromNum(j));							putSingleChar(':');							WriteCharTaxList(extendH, j, chwb, true);							if j <> lastpospresent then								puttoken(', ');						end;				ZapHandle(extendH);				putSingleChar(';');				putreturn;			end;		if theGeneticCode = customCode then			begin				PutTabtoken('GENETICCODE');				WriteCustomGeneticCode;				putSingleChar(';');				putreturn;			end;		PutTabtoken('CODESET ');		WriteSetGeneticCode;		putSingleChar(';');		putReturn;		WriteForeignLinesInBlock(codonsBlock);		putEndOfBlock;		if datatype = DNA then			symbols := 'ACGT'		else if datatype = RNA then			symbols := 'ACGU';	end;{----------------------------------------------------------------------------}	procedure WriteForeignBlock (var fb: integer);		var			dhdl: Handle;			oldState: SignedByte;	begin		{if fb <= GetHandleSize(foreignCHUNKs) div HdlSize then			begin				putReturn;				LockHandle(foreignCHUNKs, oldState);				dhdl := HdlPtr(GetMaster(foreignCHUNKs) + HdlSize * (fb - 1))^;				if GetHandleSize(dhdl) > 2 then					WriteHandle(dhdl);				ResetHandle(foreignCHUNKs, oldState);				fb := fb + 1;			end		else			putReturn;}	end;{----------------------------------------------------------------------------}	procedure	WriteForeignNexusBlock(theNexusBlock: NexusBlockPtr);	begin		if theNexusBlock<> nil then			begin				putReturn;				putReturn;				putToken ('BEGIN ');				putLegalToken(theNexusBlock^.blockname);				putSingleChar(';');				putReturn;								WriteHandle(theNexusBlock^.H,NexusDelim);								putReturn;				putEndOfBlock;				putReturn;			end;	end;{----------------------------------------------------------------------------}	procedure	WriteForeignBlocksAfterMacCladeBlock(blocktype: integer);	{writes all foreign blocks between block blocktype and the next MacClade block}	var 	theNexusBlock: NexusBlockPtr;	begin		if blocktype = notABlock then			theNexusBlock := NexusBlocks		else			begin				theNexusBlock := NexusBlockFromBlockType(blocktype);				if theNexusBlock<> nil then					theNexusBlock := theNexusBlock^.next;			end;		while (theNexusBlock<> nil ) & not theNexusBlock^.nativeBlock do			begin				WriteForeignNexusBlock(theNexusBlock);				theNexusBlock := theNexusBlock^.next;			end;	end;{-----------------------------------------------------------------------------}	procedure WriteFileSettings;		var			it,j, whichText: integer;			someitalics: boolean;	begin		FSpStampCLAD(FDI^[writefileFDI].fs);		WriteMacCladeBlockStart;{$IFC FALSE}{v3.05: this whole someitalics section is new}		someitalics := false;		for it := 1 to numtaxa do			if ItalicTaxon(it) then				begin					someitalics := true;					leave;				end;		if someitalics then			begin				puttoken('Italics ');				for it := 1 to numtaxa do					if ItalicTaxon(it) then						putSingleChar('1')					else						putSingleChar('0');				putSingleChar(';');				putReturn;			end;{$ENDC}		if GetHandleSize(fixdataH) > 1 then			begin				PutTabToken('Fixed ');				WriteHandle(fixdataH,NexusDelim);{putReturn;}				putSingleChar(';');				putReturn;			end;		if GetHandleSize(segdataH) > 1 then			begin				PutTabToken('Segments ');				WriteHandle(segdataH,NexusDelim); {Segments:}				putReturn;			end;		if GetHandleSize(realBranchLengthsDataH) > 1 then			begin				PutTabToken('BranchLengths ');				WriteHandle(realBranchLengthsDataH,NexusDelim); {Segments:}				putReturn;			end;					SetSettingsWillWrite(fileSettings,editorToolsPositionID,notASubID,toolPalettePositionRead[editorTools] | toolPaletteOpenOnce[editorTools]);		SetSettingsWillWrite(fileSettings,treeToolsPositionID,notASubID,toolPalettePositionRead[treeTools]| toolPaletteOpenOnce[treeTools]);		for whichText := 1 to numTextWindows do			SetSettingsWillWrite(fileSettings,textWindowsID,whichText,textWindowInfo[whichText]^.open );		SetSettingsWillWrite(fileSettings,chLegPositionID,notASubID,WindowVisible(chlegwindow)); 		SetSettingsWillWrite(fileSettings,treeLegPositionID,notASubID,treeopen);		PrepareAllSettingsCommands(fileSettings,false);		WriteAllSettingsCommands(fileSettings,false);		if ConsensusSequenceVisible then			for j := 1 to editorNumConsensusSequences do				ReadWriteConsensusSettings(false,j,0);		putEndOfBlock;	end;end.