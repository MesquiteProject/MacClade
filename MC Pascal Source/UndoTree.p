unit UndoTree;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, TypeUtil, TreeMakerUtil, MenuUtil, CharUtil, Prohibitions, TreeUtil, LinkUtil, InfoWindows, Legends, TreeMaker, TreeMover;	procedure UndoMove;{еееееееееееееееееееееее}implementation {е$S UndoTree}{###################===UNDO====##########################################}	procedure UndoFromSaved;		var			ic, oldoldlinknumber: INTEGER;			wastrace: boolean;			status, querycyclepoly: boolean;	begin		wastrace := (traceshown = traceDiscrete);		ic := i;		oldoldlinknumber := oldlinknumber[treechain];		CopyHandles(oldtreeH, treedataH);		dirtytree := GetLinkName(oldtreeH) = UnStoredLink;		if fixon then			NewError(131, 0);		StoreOldTreeForUndo;		linknumber[treechain] := oldoldlinknumber;		fullundo := true;		noundo := false;		myEnableItem(EditMHdl, UndoItem);		status := true;		querycyclepoly := false;		ancon := false; {so that Polytomieslegal doesn't squawk}		Maketree(status, querycyclepoly, false, PolytomiesLegal(false), FixancLegal(subR, false),true,true);		godraw := true;{$IFC USETRACEMODE}		if wastrace then			begin				traceshown := tracediscrete;				curTrace := tracediscrete;			end;{$ELSEC}		traceon := wastrace;  {v4: check to see if this is not needed}		if traceon then			curTrace := traceChar;{$ENDC}		FullTreeOnScreenGoList; {full go list request}		if infoOpen[taxinfo] then			InvalidateWindow(infoWindow[taxinfo], false);		i := ic;		dirtyfile := true;	end;{-----------------------------------------------------------------------------}	procedure UndoMove;     {undoes branch move}		var			sideN: Nptr;			doshrink: boolean;			numout, wasnull: integer;			DRloc: LongPoint;	begin		if fixlostbyundo then			NewError(131, 0);		setcursor(clockCursor);		doshrink := false;		SetDirtyTree;		dirtyfile := true;		godraw := true;		RearrangeTreeGoList;  {default is to do at least these; may do more if requested below}		justundid := not justundid;{UndoType constants are justmove, justgot, justreroot, justswap, justcollapseall, justRootnullmove,justinex, redo}{for justreroot, reroot is called again}		if fullundo or (undotype in [justswap, justgot, justInEx, justCollapseAll]) then			begin				UndoFromSaved;				doshrink := true;			end		else if undotype = justreroot then  {last move was reroot}			begin				DRloc := ScreenR^.loc;				if isAnc(reNR, ScreenR) and (reNR <> ScreenR) then					doshrink := true;				if isAnc(ScreenR, reNR) and (reNR <> ScreenR) then					DRloc := reNR^.loc;				if not (isAnc(ScreenR, reNR) or isAnc(reNR, ScreenR)) then					godraw := false;				oldNR := ScreenR;				ScreenR := reNR;				Reroot(reN, screenR);				ScreenR := oldNR;				DrawRloc := DRloc;			end		else if nomove then {justmove, justrootnullmove}			begin				undotoN^.null := not undotoN^.null;				if undotoN^.null and Anytype([irreversible, fisher, dollo, usedef]) then					begin						InstantError(250);						undotoN^.null := false;						doshrink := false;					end				else					begin						if undotoN^.null then							undotonull := 0						else							undotoNull := down;						DrawR := NotNullAnc(undotoN);						DrawRloc := DrawR^.loc;						if not IsAnc(ScreenR, DrawR) then							doshrink := true;					end;			end		else			begin				if (((undotype = justrootnullmove) & (undotoNull = up)) | (undotoNull = down) | (undotoNull = up)) & not PolytomiesLegal(true) then					begin						doshrink := false;{Warning('Polytomies allowed only with characters of unordered and ordered type.');}					end				else					begin						toN := undotoN;						fromN := undofromN;						wasnull := undotoNull;						numout := 0;						if not isAnc(ScreenR, toN) then							numout := 1;						if not isAnc(ScreenR, fromN) then							numout := numout + 1;						if numout = 1 then							doshrink := true;						MoveEdge;						if undotype = justrootnullmove then							begin								doshrink := true;								if wasNull = up then									begin										fromN^.null := true;										CheckSetLengthsToDefaults(fromN);									end;							end						else if wasNull = down then							begin								undofromN^.anc^.null := true;								CheckSetLengthsToDefaults(undofromN^.anc);								doshrink := true;							end						else if wasNull = up then							begin								sideN := sis(undofromN);								sideN^.null := true;								CheckSetLengthsToDefaults(sideN);							end;						if numout = 2 then							godraw := false;					end;			end;		if doshrink then			ShrinkTree;		SetNullson;		SetAncOn;		FixTreeShadingMenus;		dirtyTreeTaxNames := true;	end;end.