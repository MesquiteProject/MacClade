unit TraceAllChangesOptions;{еееееееееееееееееееееее}interface	uses		QuickDraw, Printing,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, 		Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  UtilLibInterface, SetLibInterface,   MemoryUtil, 		CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, Thermos, BoxUtil, SetStates, 		typeutil, Settings, CharUtil, TreeUtil, taxonchutil, Legends, BranchListWindow, Calc, CalcUtil, 		Equivocal, Count, TraceControl, TreeMaker, TreeDrawer, TreeMover, InfoWindows,TraceAllChangesCalc;	function SummaryViewPrintLegal (theSummary: integer): boolean;	procedure QueryChangeTreeShapeForTicks;	function TicksDisplay: boolean;	function ChangesDisplay (prohibcalc: BOOLEAN): boolean;	procedure SummaryModeOptions (prohibdisplay: boolean);	{еееееееееееееееееееееее}implementation {е$S TraceAllChangesOptions}{-----------------------------------------------------------------------------}	const 		showChgAsTicksIconItem= 3;		showChgAsPatternIconItem=4;		showChgAsLengthIconItem = 5;		showChgAsBlackIconItem = 12;		showChgAsTicksTextItem = 9;		showChgAsPatternTextItem=8;		showChgAsLengthTextItem = 10;		showChgAsBlackTextItem = 13;		showChgBarOptionsItem = 16;		showChgUserItem = 15;		showChgBranchListChByNamesItem = 14;		showChgSetDefaultsBranchItem = 7;		showChgCalculationsItem = 11;				showChgTickNamesItem = 5;		showChgTickStatesItem = 6;		showChgTickBoxesItem = 7;		showChgAmbigDistinguishItem = 8;		showChgTickNoNamesItem = 9;		showChgShowTickClassItem = 19;		showChgPopUpTickColorItem = 11;		showChgLowValueColorItem = 13;		showChgHighValueColorItem = 14;		showChgHighestValueColorItem = 18;		showChgSetDefaultsTicksItem = 4;		ticksColorBarsNoneItem = 21;		ticksColorBarsIndexItem = 12;		ticksColorBarsCodPosItem = 20;		ticksColorBarsTiTvItem = 22;		ticksColorBarsPartitionItem = 29;		ticksColorBarsThicknessItem = 28;		ticksBarsSpacingItem = 26;		ticksFrameColorBarsItem = 24;		TicksUserItem = 10;				{-----------------------------------------------------------------------------}	procedure CheckChangesDisplay (theDialog: DialogPtr);	begin		if not printon then			ItemCheckMark(thedialog, showChgBranchListChByNamesItem, BranchListChgbynames); { }	end;{-----------------------------------------------------------------------------}	procedure FixChangesDisplayIcons (theDialog: DialogPtr);	begin		case summaryview of			asticks: 				InvertDLOGitem(theDialog, showChgAsTicksIconItem);			aspattern: 				InvertDLOGitem(theDialog, showChgAsPatternIconItem);			asLengthNum: 				InvertDLOGitem(theDialog, showChgAsLengthIconItem);			asBlack: 				InvertDLOGitem(theDialog, showChgAsBlackIconItem);		end;		EnableDisableDLOGItem(theDialog,showChgBarOptionsItem,summaryview=asticks,false);	end;{----------------------------------------------------------------------------}	function SummaryViewPrintLegal (theSummary: integer): boolean;{you can't have (traceshown = traceAllChanges) in minmaxmode}{ showing the trace as a pattern and printing with branchlengths (reason for this is you can no longer}{see indications of min avg max amounts of change, and if you have those indications turned off, then }{it is very confusing to have the branch lengths proportional to, say min length, but have the shading}{indicate average length).}	begin		SummaryViewPrintLegal := true;		if laser^.printbranchlengths & (traceshown = traceAllChanges) & (branchlistmode = minmaxmode) then			if (theSummary = aspattern) or (theSummary = asLengthNum) then				SummaryViewPrintLegal := false;{    summaryview := asBlack;}	end;{$IFC COLORTICKS}{-----------------------------------------------------------------------------}	const		colorTicksIndexClassMenu = 13;	var		colorTicksIndexClassMHdl: MenuHandle;{-----------------------------------------------------------------------------}	procedure DrawValueBox(theDialog: DialogPtr; itemNo: integer; theColor: RGBColor);	var box: rect;	begin		if ColorPort then			begin				box := GetDLOGITemBox(theDialog, itemNo);				RGBForeColor(theColor);				FillRect(box,QDBlack);				RGBForeColor(blackRGB);				RGBForeColor(blackRGB);				FrameRect(box);			end		else			;  {Davidv4.1: support different patterns}	end;{-----------------------------------------------------------------------------}	procedure ChangeValueColor( theDialog: DialogPtr; itemNo: integer; var theColor: RGBColor);	var pos: point;		incolor,outcolor: RGBColor;		box: rect;	begin		if ColorPort then			begin				pos.v := 45;				pos.h := 110;  				inColor := theColor;				box := GetDLOGITemBox(theDialog, itemNo);				if GetColor(pos, 'select color', incolor, outcolor) then					begin						theColor := outcolor;						DrawValueBox(theDialog,itemNo,theColor);					end;			end;	end;{-----------------------------------------------------------------------------}	procedure DrawPopUpgrayticksMenu (theDialog: DialogPtr);		var			box: rect;			ds: str255;	begin		box := GetDLOGITemBox(theDialog, showChgPopUpTickColorItem);		GetMenuItemText(colorTicksIndexClassMHdl, colorTicksIndexClass + 1, ds);		DrawPopUpRect(box, ds);	end;{$ENDC}{-----------------------------------------------------------------------------}	procedure ChangesDisplayUser (theDialog: DialogPtr; itemNo: Integer);	var box: rect;	begin		FrameButton(theDialog, 1);		FixChangesDisplayIcons(theDialog);		CheckChangesDisplay(theDialog);		if not printon then			begin				DimBox(GetDLOGItemBox(theDialog, showChgAsBlackTextItem));				DimBox(GetDLOGItemBox(theDialog, showChgAsBlackIconItem));			end;	end;{$IFC COLORTICKS}{----------------------------------------------------------------------------}	procedure PopUpcolorTicksIndexClassMenu (theDialog: DialogPtr);		var			box: rect;			spot: point;			menucode: longint;			ItemNo: integer;	begin		box := GetDLOGITemBox(theDialog, showChgPopUpTickColorItem);		spot.v := box.top;		spot.h := box.left;		LocalToGlobal(spot);		menucode := PopUpMenuSelect(colorTicksIndexClassMHdl, spot.v, spot.h, colorTicksIndexClass + 1);		ItemNo := LowWord(menucode);		if ItemNo > 0 then			begin				colorTicksIndexClass := ItemNo - 1;				colorTicksClass := colorTicksIndex;			end;		DrawPopUpGrayTicksMenu(theDialog);	end; {$ENDC}{-----------------------------------------------------------------------------}	procedure QueryChangeTreeShapeForTicks;	begin		if (summaryView=asTicks) & (not squareBranches | not showbranchLengths) & CWarning('Do you want to set the tree shape so that the bars are more easily visible?','Yes', 'No') then			begin				squareBranches := true;				showbranchlengths := true;				treescalevert := 1.0;				centerSquareBranches := true;				if not printon then					InvalidateWindow(treewindow, false);			end;	end;		{-----------------------------------------------------------------------------}	procedure CheckTicksDisplay (theDialog: DialogPtr);	begin		EnableDisableDLOGitem(thedialog, showChgTickNamesItem, not ticksNoNames, false); {full names?}		EnableDisableDLOGitem(thedialog, showChgTickStatesItem,  not ticksNoNames, false);{states changing?}		EnableDisableDLOGitem(thedialog, showChgTickBoxesItem,not ticksNoNames, false);{frame in boxes?}		ItemCheckMark(thedialog, showChgTickNamesItem, ticknames); {names/states}		ItemCheckMark(thedialog, showChgTickStatesItem, tickstates); { names/states}		ItemCheckMark(thedialog, showChgTickBoxesItem, tickboxes); {}		ItemCheckMark(thedialog, showChgAmbigDistinguishItem, ambigdistinguish); { }		ItemCheckMark(thedialog, showChgTickNoNamesItem, not ticksNoNames); {label bars?}		ItemCheckMark(thedialog, showChgShowTickClassItem, showtickClass); { }		EnableDisableDLOGitem(thedialog, ticksColorBarsCodPosItem, nucleotides, true);		EnableDisableDLOGitem(thedialog, ticksColorBarsTiTvItem, nucleotides, true);		EnableDisableDLOGitem(thedialog, ticksColorBarsPartitionItem, not onePartition, true);		ItemCheckMark(thedialog, ticksColorBarsNoneItem, colorTicksClass=colorTicksNone); 		ItemCheckMark(thedialog, ticksColorBarsIndexItem,colorTicksClass=colorTicksIndex); 		ItemCheckMark(thedialog, ticksColorBarsCodPosItem, colorTicksClass=colorTicksCodPos);		ItemCheckMark(thedialog, ticksColorBarsTiTvItem, colorTicksClass=colorTicksTiTv);		ItemCheckMark(thedialog, ticksColorBarsPartitionItem, colorTicksClass=colorTicksPartition);		EnableDisableDLOGitem(thedialog, ticksFrameColorBarsItem, colorTicksClass<>colorTicksNone, true);		ItemCheckMark(thedialog, ticksFrameColorBarsItem, colorTicksFramed);			end;{-----------------------------------------------------------------------------}	procedure TicksDisplayUser (theDialog: DialogPtr; itemNo: Integer);	var box: rect;	begin		FrameButton(theDialog, 1);{$IFC COLORTICKS}		DrawPopUpGrayTicksMenu(theDialog);		DrawValueBox(theDialog,showChgLowValueColorItem,lowValueColor);		DrawValueBox(theDialog,showChgHighValueColorItem,highValueColor);		DrawValueBox(theDialog,showChgHighestValueColorItem,highestValueColor); {$ENDC}		CheckTicksDisplay(theDialog);	end;{-----------------------------------------------------------------------------}	function TicksDisplay:boolean;		var			oldsummaryview: integer;			oldShowTickClass: boolean;			oldticknames, oldtickstates, oldtickboxes: boolean;			OldBranchListChgbynames, oldambigdistinguish, oldTicksNoNames: boolean;			d1, d2: longint;			theDialog: DialogPtr;			box: RECT;			itemtype: integer;			H: Handle;			tempP: WindowPtr;			oldcolorTicksFramed: boolean;			localItemHit: integer;			oldNeedRoom: integer;			oldColorTicksClass: integer;			oldcolorTicksIndexClass: integer;			oldLowRGB,oldHighRGB, oldHighestRGB: RGBColor;			ds: str255;UserItemUProcP: UniversalProcPtr;	begin		TicksDisplay:= false;		oldNeedRoom := RoomNeededOnRight;{$IFC COLORTICKS}		colorTicksIndexClassMHdl := GetMenu(colorTicksIndexClassMenu);		InsertMenu(colorTicksIndexClassMHdl, -1);		oldColorTicksClass := colorTicksClass;		oldcolorTicksIndexClass := colorTicksIndexClass;		oldLowRGB := lowValueColor;		oldHighRGB := highValueColor;		oldHighestRGB := highestValueColor;		oldcolorTicksFramed := colorTicksFramed;{$ENDC}		oldshowTickClass := showTickClass;		oldticknames := ticknames;		oldtickstates := tickstates;		oldtickboxes := tickboxes;		oldticksNoNames := ticksNoNames;		oldambigdistinguish := ambigdistinguish;		StartDLOG(157, theDialog, tempP);		if not ColorPort then			begin				HideDialogItem(theDialog,15);				HideDialogItem(theDialog,16);				HideDialogItem(theDialog,17);				HideDialogItem(theDialog,23);			end;		myShowDialog(theDialog);UserItemUProcP := MyNewUserItemUPP(@TicksDisplayUser);  H := Handle(UserItemUProcP);		SetRect(box, 0, 0, 10, 10);		SetDialogItem(theDialog, TicksUserItem, UserItem, H, box);		if printon then			begin				HideButton(theDialog, showChgSetDefaultsTicksItem);		{hiding save preferences button}			end;					SetEditTextNum (theDialog,ticksBarsSpacingItem, 0.0,colorTicksMinSpaceBetween, false, false);		SetEditTextNum (theDialog,ticksColorBarsThicknessItem, 0.0, colorTicksBarWidth, false, false);		CheckTicksDisplay(theDialog);		repeat			ModalDialog(nil, localItemHit);			case localItemHit of				showChgTickStatesItem: 					tickstates := not tickstates;				showChgTickNamesItem: 					ticknames := not ticknames;				showChgTickBoxesItem: 					tickboxes := not tickboxes;				showChgAmbigDistinguishItem: 					ambigdistinguish := not ambigdistinguish;				showChgTickNoNamesItem: 					ticksNoNames := not TicksNoNames				showChgPopUpTickColorItem:					PopUpcolorTicksIndexClassMenu(theDialog);				showChgLowValueColorItem:					ChangeValueColor(theDialog,showChgLowValueColorItem,lowValueColor);				showChgHighValueColorItem:					ChangeValueColor(theDialog,showChgHighValueColorItem,highValueColor);				showChgHighestValueColorItem:  ChangeValueColor(theDialog,showChgHighestValueColorItem,highestValueColor);				showChgShowTickClassItem: showTickClass := not showTickClass;				showChgSetDefaultsTicksItem: 					SetDialogValuesAsDefaults(theDialog, tickOptionsID, 0, 0);				ticksColorBarsNoneItem:					colorTicksClass := colorTicksNone;				ticksColorBarsIndexItem:					colorTicksClass := colorTicksIndex;				ticksColorBarsCodPosItem:					colorTicksClass := colorTicksCodPos;				ticksColorBarsTiTvItem:					colorTicksClass := colorTicksTiTv;				ticksColorBarsPartitionItem:					colorTicksClass := colorTicksPartition;				ticksFrameColorBarsItem:					colorTicksFramed := not colorTicksFramed;				otherwise					;			end;			CheckTicksDisplay(theDialog);		until (localItemHit in [1, 2]);		if localItemHit = 2 then			begin				ticknames := oldticknames;				tickstates := oldtickstates;				tickboxes := oldtickboxes;				colorTicksFramed := oldcolorTicksFramed;				ambigdistinguish := oldambigdistinguish;				ticksNoNames := oldticksNoNames;				showTickClass := oldshowTickClass;{$IFC COLORTICKS}				colorTicksClass := oldColorTicksClass;				colorTicksIndexClass := oldcolorTicksIndexClass;				lowValueColor := oldLowRGB;				highValueColor := oldHighRGB;				highestValueColor := oldHighestRGB;{$ENDC}			end		else			begin				if (traceshown = traceAllChanges) then					begin						colorTicksBarWidth := EditTextInt (theDialog,ticksColorBarsThicknessItem, true);						if colorTicksBarWidth < 1 then colorTicksBarWidth := 1;						colorTicksMinSpaceBetween := EditTextInt (theDialog,ticksBarsSpacingItem, true);						if colorTicksMinSpaceBetween < 0 then colorTicksMinSpaceBetween := 0;						if not printon then							begin								if showbranchlengths & squarebranches then									TicksDisplay := true;								if (ticksnoNames <> oldTicksNoNames) | (ambigdistinguish <> oldambigdistinguish) | (ticknames <> oldticknames) | (tickstates <> oldtickstates) | (tickboxes <> oldtickboxes)  then									TicksDisplay := true;							end;{$IFC COLORTICKS}						if (oldColorTicksClass <> colorTicksClass) or (colorTicksIndexClass <> oldcolorTicksIndexClass) then							SetColorTicksGoList;{$ENDC}						if (ambigdistinguish <> oldambigdistinguish)then							begin								if BranchListon then									begin										MakeBranchList(BranchListN, d1, d2, 0, 0, listToWindow);										InvalidateWindow(branchlistwindow, true);									end;							end;						if not printon & (RoomNeededOnRight < oldNeedRoom) & (traceshown = traceAllChanges) then							ZeroTreeOrigin;						godraw := true;					end;			end;MyDisposeUserItemUPP(UserItemUProcP);		EndDLOG(theDialog, tempP);{$IFC COLORTICKS}		ZapMenu(colorTicksIndexClassMenu,colorTicksIndexClassMHdl);{$ENDC}			end;{-----------------------------------------------------------------------------}	function ChangesDisplay (prohibcalc: boolean): boolean;		var			oldsummaryview: integer;			oldShowTickClass: boolean;			oldticknames, oldtickstates, oldtickboxes: boolean;			OldBranchListChgbynames, oldambigdistinguish, oldTicksNoNames: boolean;			d1, d2: longint;			theDialog: DialogPtr;			box: RECT;			itemtype: integer;			H: Handle;			tempP: WindowPtr;			localItemHit: integer;			oldNeedRoom: integer;			oldgrayticks: boolean;			treeinvalidate: boolean;			oldcolorTicksIndexClass: integer;			oldLowRGB,oldHighRGB, oldHighestRGB: RGBColor;			ds: str255;UserItemUProcP: UniversalProcPtr;			os: OSStatus;	begin		oldNeedRoom := RoomNeededOnRight;		treeinvalidate := false;		oldsummaryview := summaryview;		OldBranchListChgbynames := BranchListChgbynames;		StartDLOG(139, theDialog, tempP);		myShowDialog(theDialog);UserItemUProcP := MyNewUserItemUPP(@ChangesDisplayUser);  H := Handle(UserItemUProcP);		SetRect(box, 0, 0, 10, 10);		SetDialogItem(theDialog, showChgUserItem, UserItem, H, box);		if prohibcalc then			HideButton(theDialog, showChgCalculationsItem);  	{hiding calc button}		if printon then			begin				HideButton(theDialog, showChgSetDefaultsBranchItem);		{hiding save preferences button}				HideButton(theDialog, showChgBranchListChByNamesItem); 		{branch list by names checkbox}			end;		FixChangesDisplayIcons(theDialog);		SetBasicDLOGFilterHandling(theDialog,1,2,false);		CheckChangesDisplay(theDialog);//				os :=   SetModalDialogEventMask (theDialog, everyEvent-updateMask);		repeat			myModalDialog(UniversalDLOGFilterUPP, localItemHit);			if localItemHit in [showChgAsTicksIconItem,showChgAsPatternIconItem,showChgAsLengthIconItem,showChgAsPatternTextItem,showChgAsTicksTextItem,showChgAsLengthTextItem,showChgAsBlackIconItem,showChgAsBlackTextItem] then				FixChangesDisplayIcons(theDialog);			case localItemHit of				showChgAsTicksIconItem, showChgAsTicksTextItem: 					begin						summaryview := asticks;					end;				showChgAsPatternIconItem, showChgAsPatternTextItem: 					begin						summaryview := aspattern;					end;				showChgAsLengthIconItem, showChgAsLengthTextItem: 					begin						summaryview := asLengthNum;					end;				showChgAsBlackIconItem, showChgAsBlackTextItem: 					if printon then						begin							summaryview := asBlack;						end					else						InstantInfo('Allowed only for printing.');				showChgBranchListChByNamesItem: 					BranchListChgbynames := not BranchListChgbynames;				showChgBarOptionsItem:					if TicksDisplay then treeinvalidate := true;				showChgCalculationsItem: 					begin						SummaryModeOptions(true);						FrameButton(theDialog, 1);					end;				showChgSetDefaultsBranchItem: 					SetDialogValuesAsDefaults(theDialog, traceAllChangesDisplayID, 0, 0);				otherwise					;			end;			if localItemHit in [showChgAsTicksIconItem,showChgAsPatternIconItem,showChgAsLengthIconItem,showChgAsPatternTextItem,showChgAsTicksTextItem,showChgAsLengthTextItem,showChgAsBlackIconItem,showChgAsBlackTextItem] then				FixChangesDisplayIcons(theDialog);			CheckChangesDisplay(theDialog);		until (localItemHit in [1, 2]);		if localItemHit = 2 then			begin				BranchListChgbynames := OldBranchListChgbynames;				summaryview := oldsummaryview;			end		else			begin				if (traceshown = traceAllChanges) then					begin						if not printon then							begin								if showbranchlengths & squarebranches then									InvalidateWindow(treewindow, true);								if  (summaryview <> oldsummaryview) then									InvalidateWindow(treewindow, false);							end;{$IFC COLORTICKS}						if (colorTicksClass=colorTicksIndex) & (summaryview=asticks) & (summaryview <> oldsummaryview) then							SetColorTicksGoList;{$ENDC}						if (BranchListChgbynames <> OldBranchListChgbynames) then							begin								if BranchListon then									begin										MakeBranchList(BranchListN, d1, d2, 0, 0, listToWindow);										InvalidateWindow(branchlistwindow, true);									end;							end;						if not printon & (RoomNeededOnRight < oldNeedRoom) & (traceshown = traceAllChanges) then							ZeroTreeOrigin;					end;			end;MyDisposeUserItemUPP(UserItemUProcP);		if treeinvalidate then			InvalidateWindow(treewindow, true);		EndDLOG(theDialog, tempP);		ChangesDisplay := (localItemHit = 1);	end;{-----------------------------------------------------------------------------}	procedure SummaryModeOptions (prohibdisplay: boolean);		var			theDialog: DialogPtr;			tempP: WindowPtr;			oldBranchListmode, oldmeanbymode: SignedByte;			j, d1, d2: integer;			graphicschanged: boolean;			oldweighted: boolean;			box: rect;			H: Handle;			localItemHit: integer;			os: OSStatus;{........}		procedure FixModeChecks;		begin{3,6 unambig       4,7 ambig       5,8 max   15,16 minmeanmax}{17 byres 18 byclass}{20 number/weighted}			EnableDisableDLOGItem(theDialog, 17, branchlistmode = minmaxmode, false);			EnableDisableDLOGItem(theDialog, 18, branchlistmode = minmaxmode, false);			ItemCheckMark(theDialog, 3, BranchListmode = unambigmode);			ItemCheckMark(theDialog, 4, BranchListmode = ambigmode);			ItemCheckMark(theDialog, 5, BranchListmode = maxmode);			ItemCheckMark(theDialog, 15, BranchListmode = minmaxmode);			ItemCheckMark(theDialog, 17, meanBymode = meanByResolutions);			ItemCheckMark(theDialog, 18, meanBymode = meanBychangeclass);			ItemCheckMark(theDialog, 9, branchlengthsweighted);		end;{........}		procedure AdjustTextForWeighting (weighted: boolean);		begin			if weighted then				begin					SetDLOGText(theDialog, 6, 'Unambiguous changes only (Minimum amount of change)', false);					SetDLOGText(theDialog, 7, 'Almost all possible changes (Approx. maximum amount)', false);					SetDLOGText(theDialog, 8, 'All possible changes (Maximum amount of change)', false);					SetDLOGText(theDialog, 16, 'Minimum-Average-Maximum amount of change', false);				end			else				begin					SetDLOGText(theDialog, 6, 'Unambiguous changes only (Minimum # changes)', false);					SetDLOGText(theDialog, 7, 'Almost all possible changes (Approximate maximum #)', false);					SetDLOGText(theDialog, 8, 'All possible changes (Maximum # changes)', false);					SetDLOGText(theDialog, 16, 'Minimum-Average-Maximum# changes', false);				end;		end;{........}	begin		oldBranchListmode := BranchListmode;		oldweighted := branchlengthsweighted;		oldmeanbymode := meanbymode;		graphicschanged := false;		StartDLOG(344, theDialog, tempP);		if prohibdisplay then			HideControl(controlHandle(GetDLOGItemHandle(theDialog, 19)));  {hiding display button}		if printon or prohibdisplay or (traceshown = traceAllChanges) then			HideControl(controlHandle(GetDLOGItemHandle(theDialog, 21)));  {hiding trace button}		FixModeChecks;		AdjustTextForWeighting(branchlengthsweighted);		myShowDialog(theDialog);		if (branchlistmode = minmaxmode) or (BranchListmode = maxmode) then			begin				if nullson or ancon then					begin						Branchlistmode := unambigmode;						InstantError(316);					end {$IFC FALSE}				else if (resolveoption <> allpossible) then					begin						Branchlistmode := unambigmode;						InstantError(338);					end;{$ENDC}			end;		FrameButton(theDialog, 1);//				os :=   SetModalDialogEventMask (theDialog, everyEvent-updateMask);		SetBasicDLOGFilterHandling(theDialog,1,2,false);		repeat			myModalDialog(UniversalDLOGFilterUPP, localItemHit);			case localItemHit of				3, 6: 					BranchListmode := unambigmode;				4, 7: 					begin						if branchlengthsweighted then							InstantError(337)  {cannot use most possible if amounts of change are weighted}						else							BranchListmode := ambigmode;					end;				5, 8: 					if nullson or ancon then						InstantError(316) {Cannot show maximum possible if polytomies or ancestors fixed}{$IFC FALSE}					else if (Resolveoption <> allpossible) then						InstantError(338) {cannot show maximum possible if ACCTRAN/DELTRAN in use}{$ENDC}					else						BranchListmode := maxmode;				13:   {Make Default}					SetDialogValuesAsDefaults(theDialog, summodeid, 0, 0);				15, 16: 					if nullson or ancon then						InstantError(316){$IFC FALSE}					else if (Resolveoption <> allpossible) then						InstantError(338) {cannot show maximum possible if ACCTRAN/DELTRAN in use}{$ENDC}					else						BranchListmode := minmaxmode;				17: 					meanBymode := meanbyResolutions;				18: 					meanBymode := meanbyChangeClass;				19: 					begin						if ChangesDisplay(true) then							begin								graphicschanged := true;								QueryChangeTreeShapeForTicks;							end;						FrameButton(theDialog, 1);					end;				9, 20: 					if not branchlengthsweighted & (branchlistmode = ambigmode) then						InstantError(318)  {'Branches cannot be weighted when most possible in use'}					else						begin							branchlengthsweighted := not branchlengthsweighted;							AdjustTextForWeighting(branchlengthsweighted);						end;				otherwise					;			end;			FixModeChecks;		until localItemHit in [1, 2, 21];		EndDLOG(theDialog, tempP);		if localItemHit = 2 then			begin				BranchListmode := oldBranchListmode;				branchlengthsweighted := oldweighted;				meanbymode := oldmeanbymode;			end		else if (traceshown = traceAllChanges) then			begin				if ((branchlengthsweighted <> oldweighted) or (BranchListmode <> oldBranchListmode) or ((oldmeanbymode <> meanbymode) and (branchlistmode = minmaxmode))) then					if not printon then						begin							InvalidateWindow(treewindow, false);{FROZEN 3.0}							golist := golist + [brchangesall];{if Changes Options changed in important way, send note to update changes calculations}						end					else						InvalidateWindowRect(myGetWindowFromPort(QDThePort),WindowPortRect(myGetWindowFromPort(QDThePort)),false);			end		else if (localitemhit = 21) then			begin				equivpres := false;				TurnOnShowChanges;			end;	end;end.