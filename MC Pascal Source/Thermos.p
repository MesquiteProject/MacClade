unit Thermos;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, 		Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  Printing, MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, BoxUtil, StrUtil, 		TreeUtil, MenuUtil, Prohibitions, CharUtil, Activates, Legends, SpreadUtil, TreeDrawer, 		InfoWindows, BranchListWindow, ChartWindow, DrawSpread, InfoWindows, TextWindows, StatesWindow, Flash;	procedure DealWithUpdates (Event: EventRecord; setCursorToClock: boolean);	procedure DoSuspendResume (Event: EventRecord);	procedure ResetThermoWindowBars(theDialog: DialogPtr);	function ThermoWasAborted (theDialog: DialogPtr): boolean;	procedure CheckThermo (theDialog: DialogPtr);	procedure ThermoEvents (theDialog: DialogPtr; var cancel: boolean);	procedure ZeroStandardThermoBar (theDialog: DialogPtr);	procedure DrawStandardThermo (theDialog: DialogPtr; itemNo: Integer);	procedure UpdateThermo (theDialog: DialogPtr; min, value, max: longint;  aspercent: boolean);	procedure StartThermo (var theDialog: DialogPtr; var tempP: WindowPtr; min, max: longint; title, comment: str255; aspercent: boolean);	procedure EndThermo (var theDialog: DialogPtr; tempP: WindowPtr; dobeep: boolean);	procedure UpdateSearchThermo (theDialog: DialogPtr; value: longint);	procedure StartSearchThermo (var theDialog: DialogPtr; var tempP: WindowPtr; value: longint);	procedure EndSearchThermo (var theDialog: DialogPtr; tempP: WindowPtr; dobeep: boolean);	procedure UpdateButtonThermo (theDialog: DialogPtr);	procedure StartButtonThermo (var theDialog: DialogPtr; var tempP: WindowPtr; titleString: str255);	procedure EndButtonThermo (var theDialog: DialogPtr; tempP: WindowPtr; dobeep: boolean);	function UniversalDLOGFilter (theDialog: DialogPtr; var Event: EventRecord; var localItemHit: Integer): BOOLEAN;	const		thermoCheckTime = 20;	var		backgroundable: boolean;		thermoLastCheck: longint;		allowReturnAsCancel: boolean;{еееееееееееееееееееееее}implementation {е$S Thermos}var	 thermoMin, thermovalue, thermomax: array[1..2] of longint; 	 thermoaspercent: array [1..2] of boolean;	StandardThermo1UserItemUProcP: UniversalProcPtr;	StandardThermo2UserItemUProcP: UniversalProcPtr;		oldThermoNumberValue, oldThermoBarValue: array [1..2] of longint;		resetDrawR: boolean;{-----------------------------------------------------------------------------}	procedure UpdateInfoWindow (whichinfo: integer);	begin		ClipRect(WindowPortRect(infowindow[whichInfo]));		if infoDirtyNames[whichinfo] then			SizeInfoWindow(whichinfo,false, true);		DrawInfoWindow(whichinfo, true);		if isForeGround then			if infoEditing[whichinfo] then				TEUpdate(infoTE[whichinfo]^^.viewrect, infoTE[whichinfo]);		DrawControls(infoWindow[whichinfo]);		DrawGrowBox(infoWindow[whichinfo]);	end; {-----------------------------------------------------------------------------}	procedure ZeroStandardThermoBar (theDialog: DialogPtr);		var			itemtype: integer;			H: handle;			box: rect;			tempP: WindowPtr;	begin		if theDialog=thermo1Window then			thermovalue[1] := thermoMin[1]		else			thermovalue[2] := thermoMin[2];		genericGetPort(tempP);		genericSetPort(myGetWindowPtrForDialog(theDialog));		GetDialogItem(theDialog, 1, itemtype, H, box);		EraseRect(box);		FrameRect(box);		genericSetPort(tempP);	end;{-----------------------------------------------------------------------------}	procedure ResetThermoWindowBars(theDialog: DialogPtr);	begin		if (theDialog <> nil) then			begin				if theDialog=thermo1Window then					begin						oldThermoBarValue[1] := -1;						oldThermoNumberValue[1] := -1;					end				else if theDialog=thermo2Window then					begin						oldThermoBarValue[2] := -1;						oldThermoNumberValue[2] := -1;					end;			end;	end;{-----------------------------------------------------------------------------}	procedure CheckAndUpdateThermoWindow(updateWindow: WindowPtr;theDialog: DialogPtr);	begin		if (UpdateWindow=myGetWindowPtrForDialog(theDialog)) & (theDialog <> nil) then			begin				ResetThermoWindowBars(theDialog);				DrawDialog(theDialog);			end;	end;{-----------------------------------------------------------------------------}	procedure DealwithUpdates (Event: EventRecord; setCursorToClock: boolean);		var			UpDateWindow, TempP: WindowPtr;			box: rect;			pt: point;			whichinfo: integer;	begin		UpDateWindow := myGetWindowPtrFromEventMessage(Event);		if updateWindow = nil then			Exit(DealwithUpdates);		genericGetPort(TempP);		genericSetPort(UpDateWindow);		ClipRect(WindowPortRect(UpDateWindow));{$IFC FALSE}		if (UpDateWindow = editorWindow) then			begin				pt.v := 0;				pt.h := 0;				LocalToGlobal(pt);				OffsetRgn(myGetUpdateRgn(editorWindow), -pt.h, -pt.v);				EraseRgn(myGetUpdateRgn(editorWindow));				OffsetRgn(myGetUpdateRgn(editorWindow), pt.h, pt.v);			end;{$ENDC}		BeginUpDate(UpDateWindow);{$IFC FALSE}	writeln(tempFile, 'Update 3');	writeln(tempFile, concat('      updatewindow: ',StringFromNum(longint(updateWindow))));	writeln(tempFile, concat('      editorWindow: ',StringFromNum(longint(editorWindow))));	writeln(tempFile, concat('      chlegwindow: ',StringFromNum(longint(chlegwindow))));	writeln(tempFile, concat('      tlegwindow: ',StringFromNum(longint(tlegwindow))));	writeln(tempFile, concat('      treewindow: ',StringFromNum(longint(treewindow))));	writeln(tempFile, concat('      BranchListwindow: ',StringFromNum(longint(BranchListwindow))));	writeln(tempFile, concat('      stateswindow: ',StringFromNum(longint(stateswindow))));	if IsInfoWindow(updateWindow) then		writeln(tempFile, 'updateWindow is an infoWindow');	if IsTextWindow(updateWindow) then		writeln(tempFile, 'updateWindow is a textWindow');	if IsPaletteWindow(updateWindow) then		writeln(tempFile, 'updateWindow is a paletteWindow');	writeln(tempFile, concat('      pictwindow: ',StringFromNum(longint(pictwindow))));	writeln(tempFile, concat('      ChartWindow: ',StringFromNum(longint(ChartWindow))));	writeln(tempFile, concat('      twmesswindow: ',StringFromNum(longint(twmesswindow))));{$ENDC}		if WindowVisible(updateWindow) & not EmptyRgn(myGetVisRgn(updatewindow)) & CanUpdateWindow(updateWindow) then			begin				if setCursorToClock & not IsPaletteWindow(UpDateWindow) then					SetCursor(clockCursor);				if (UpDateWindow = editorWindow) then					begin													genericSetPort(editorWindow);						SetClip(myGetUpdateRgn(editorWindow));						EraseRgn(myGetVisRgn(updatewindow));						if editorSelected and SingleCell then							ReturnValue(editorSelectionTopLeft,false);						CalcEditorMatrixRect;						SetEWClip(noscroll);						DrawCells(true, true,true);						SetClip(EWClip);						if isforeground then							begin								if editorSelected and SingleCell then									begin										if CellVisible(editorSelectionTopLeft, editorSelectionBotRight) then											TEUpdate(editorSelectionRect, editorCellTE);										ClipRect(WindowPortRect(editorWindow));										if footTexton then											TEUpdate(noteTE^^.destrect, noteTE);									end;								ClipRect(WindowPortRect(editorWindow));								if IsEditorWindow(frontwindow) then									begin										ShowControl(editorVScroll);										ShowControl(editorHScroll);									end;								DrawControls(editorWindow);							end;						SetClip(EWClip);					end				else if UpdateWindow = chlegwindow then					DrawchLeg				else if treeopen and (UpDateWindow = treewindow) then					begin						DrawTreeWindow;					end				else if IsInfoWindow(UpDateWindow) then					begin						whichInfo := WhichInfoWindow(UpdateWindow);						if infoOpen[whichinfo] then							UpdateInfoWindow(whichinfo);					end				else if BranchListon and (UpDateWindow = BranchListwindow) then					begin						DrawBranchListWindow;					end				else if (UpDateWindow = stateswindow) then					begin						DrawStatesWindow(true);						if isForeGround then							if statesEditing then								TEUpdate(statesTE^^.viewRect, statesTE);						DrawControls(statesWindow);						DrawGrowBox(stateswindow);					end				else if IsTextWindow(updateWindow) then					begin						DrawTextWindow(WhichTextWindow(updateWindow));						DrawGrowBox(updateWindow);					end				else if IsPaletteWindow(UpDateWindow) then					DrawPalette(WhichPaletteWindow(UpdateWindow))				else if (UpdateWindow = pictwindow) then					begin						box := grabpicture^^.picframe;						OffSetRect(box, -box.left + pictmargin, -box.top + pictmargin);						DrawPicture(grabpicture, box);						DrawGrowBox(pictWindow);					end				else if UpdateWindow = ChartWindow then					DrawChartWindow(WindowPortRect(chartWindow))				else if UpdateWindow = twmesswindow then					DrawTWMessWindow				else if UpdateWindow = tlegwindow then					begin						DrawTreeLeg;					end				else 					begin						CheckAndUpdateThermoWindow(updateWindow,searchThermo);						CheckAndUpdateThermoWindow(updateWindow,ioThermo);						CheckAndUpdateThermoWindow(updateWindow,thermo1Window);						CheckAndUpdateThermoWindow(updateWindow,thermo2Window);					end;			end;		EndUpDate(UpDateWindow);{    if (updatewindow = chlegwindow) or (updatewindow = tlegwindow) then} {this patch is needed because EndUpDate restores the old visRgn saved by BeginUpdate before chlegwindow changed size}		CalcVis(WindowRef(updatewindow)); {for some reason CW uses WindowRefs; see its Quickdraw.p; I hope this is correct}		genericSetPort(TempP);	end;{-----------------------------------------------------------------------------}	procedure DoSuspendResume (Event: EventRecord);		var			myErr: OSErr;			db: boolean;	begin		case BAnd(BRotL(event.message, 8), $FF) of			suspendResumeMessage: 				if Band(Event.message, resumeFlag) <> 0 then   {coming to the foreground}					begin						GetFreshMenuHandles;						isforeground := true;						ReadDeskScrap;						DoActivates(frontwindow);						cancelCheckFreq := 30;						if notificationPosted then							RemoveBackGroundNotification;						{if goerror then							showerrors('');}					end				else													{going to the background}					begin						GetFreshMenuHandles;						isforeground := false;						WriteDeskScrap;						DoDeActivates(frontwindow,true); 						HideFlash;						cancelCheckFreq := 500;					end;			mouseMovedMessage:				;			otherwise				;		end;	end;{-----------------------------------------------------------------------------}const 	thermoStopButtonItem=2;	{-----------------------------------------------------------------------------}	procedure ProcessThermoEvent (theEvent: EventRecord; theDialog: DialogPtr; var cancel: boolean);		var			whichWindow: WindowPtr;			tport: WindowPtr;			MouseLoc: Point;			windowLoc,t: integer;			codeWord: longint;			dragArea: rect;			itemtype: integer;			H: handle;			box: rect;	begin		case theEvent.what of			keydown: 				begin					if KeyBoardCancel(theEvent) | (allowReturnAsCancel & (theEvent.message mod 256=13)) then						begin							cancel := true;						end;				end;			updateEvt: 				begin					if resetDrawR then						DrawR := R;					DealwithUpdates(theEvent,false); 				end;			 {this needs to be fixed!!!}						osEvent: 				begin					DoSuspendResume(theEvent);				end;			mousedown:{if isforeground then}				begin					MouseLoc := theEvent.Where;					windowLoc := FindWindow(MouseLoc, WhichWindow);					case windowLoc of						inMenuBar: 							begin 								codeWord := MenuSelect(mouseloc);							end;{$IFC NOT CARBON}						inSysWindow: 							SystemClick(theEvent, WhichWindow);{$ENDC}						inContent: 							if (whichwindow = myGetWindowPtrForDialog(theDialog)) | (thermo2 & ((whichWindow=myGetWindowPtrForDialog(thermo1Window))|(whichWindow=myGetWindowPtrForDialog(thermo2Window)))) then								begin									genericGetPort(tPort);									genericSetPort(whichWindow);									GetDialogItem(myGetDialogPtrForWindow(whichWindow),thermoStopButtonItem, itemtype, H, box);									wh := theEvent.where;									GlobalToLocal(wh);									if PtInRect(wh,box) then										begin{$IFC CARBON}											t := myTrackControl(ControlHandle(H), wh, nil);											cancel := t<>0;{$ELSEC}											cancel :=true;											InvertRoundRect(box, 16, 16);											if not Button then												InvertRoundRect(box, 16, 16);{$ENDC}										end;									genericSetPort(tport);								end;						inDrag: 							if whichwindow = myGetWindowPtrForDialog(theDialog) then								if StillDown then									begin										DragArea := ScreenRectangle;										InsetREct(DragArea, 4, 4);										DragArea.top := DragArea.top + 12;										DragWindow(whichwindow, mouseLoc, @DragArea)									end;						otherwise							;					end;				end;			otherwise				;		end;	end;{----------------------------------------------------------------------------}	function ThermoCommandPeriod: BOOLEAN;		var			tev: EventRecord;			cancel: boolean;	begin		cancel := false;{v4: beware, this will eat up keydown events}		if isforeground then			{if doUpdates then				begin }					while GetEvent(everyevent, tev) do						ProcessThermoEvent(tev, nil, cancel);			{	end}			{else				while GetEvent(everyevent-updatemask, tev) do					ProcessThermoEvent(tev, nil, cancel)};		ThermoCommandPeriod := cancel;	end;{----------------------------------------------------------------------------}	procedure ThermoEvents (theDialog: DialogPtr;  var cancel: boolean);		const			osMask = -32768;		var			tev: EventRecord;			itemtype: integer;			H: handle;			box: rect;			theSleep: longint;			db: boolean;	begin{v4: beware, this will eat up keydown events}		if backgroundable then			begin				cancel := false;						if isforeground then							while GetEvent(everyevent, tev) do								ProcessThermoEvent(tev, theDialog, cancel)						else							if GetEvent(everyevent, tev) then								ProcessThermoEvent(tev, theDialog, cancel);			end		else			if isforeground then				if button then					begin						GetDialogItem(theDialog, thermoStopButtonItem, itemtype, H, box);						GetMouse(wh);						cancel := PtInRect(wh, box);						if cancel then							InvertRoundRect(box, 8, 8);					end				else					cancel := ThermoCommandPeriod;	end;{-----------------------------------------------------------------------------}	procedure RedrawThermoNumber(theDialog: DialogPtr; value: longint);	var	box: rect;	begin		with WindowPortRect(myGetWindowPtrForDialog(theDialog)) do			begin				SetRect(box, left + 5, bottom - 20, left + 60, bottom - 2);				EraseRect(box);				moveto(left + 5, bottom - 5);				DrawString(StringFromNum(value));			end;	end;{-----------------------------------------------------------------------------}	procedure CheckThermo (theDialog: DialogPtr);	var cancel: boolean;	begin		if (thermoAbortable | BackGroundable) & ((TickCount >= ThermoLastCheck + ThermoCheckTime) | not isforeground) then			begin{$IFC CARBON}				if ThermoAbortable & CheckEventQueueForUserCancel then					abortedThermo := true				else					begin{$ENDC}						ThermoEvents(theDialog, cancel);						if ThermoAbortable & cancel then							abortedThermo := true;{$IFC CARBON}					end;{$ENDC}				ThermoLastCheck := TickCount;			end;	end;{-----------------------------------------------------------------------------}	function ThermoWasAborted (theDialog: DialogPtr): boolean;	begin		if theDialog=nil then			begin				ThermoWasAborted := CommandPeriod;			end		else			begin				CheckThermo (theDialog);				ThermoWasAborted := abortedThermo;			end;	end; {-----------------------------------------------------------------------------}	procedure ReDrawMaxNumber(theDialog: DialogPtr; j: integer);	var		itemtype: integer;			H: handle;			box: rect;			ds: str255;	begin		GetDialogItem(theDialog, 4, itemtype, H, box);		if thermoAsPercent[j] then			ds := '100%'		else			ds := StringFromNum(thermoMax[j]);		TETextBox(Pointer(ord4(@ds) + 1), length(ds), box, teJustRight);	end; {-----------------------------------------------------------------------------}	procedure DrawStandardThermo (theDialog: DialogPtr; itemNo: Integer);		var			itemtype, j: integer;			H: handle;			box: rect;			boxlen, percentlen,old,new,oldpercentlen: longint;			tempP: WindowPtr;			cancel: boolean;	begin		if theDialog=thermo1Window then			j := 1		else			j := 2;		genericGetPort(tempP);		genericSetPort(myGetWindowPtrForDialog(theDialog));		GetDialogItem(theDialog, 1, itemtype, H, box); {max < 0 is a signal to not draw the thermometer, instead drawing only the numerical values}		if thermoValue[j] < 0 then  {don't show anything}			begin			end		else if thermoMax[j] < 0 then			begin				EraseRect(box);				MoveTo(box.left + 50, box.bottom - 3);				DrawString(StringFromNum(thermoValue[j]));			end		else if thermoMax[j] > thermoMin[j] then			begin				FrameRect(box);				boxlen := box.right - box.left;				oldpercentlen := RoundValue((1.0 * (oldThermoBarValue[j] - thermoMin[j]) / (thermoMax[j] - thermoMin[j])) * boxlen);				percentlen := RoundValue((1.0 * (thermoValue[j] - thermoMin[j]) / (thermoMax[j] - thermoMin[j])) * boxlen);				box.right := box.left + percentlen;				if oldpercentlen<>percentlen then					begin						FillBlackRect(box);						oldThermoBarValue[j] := thermoValue[j];					end;				if thermoAsPercent[j] then					begin						old := RoundValue(100 * (1.0 * oldThermoNumberValue[j] / thermoMax[j]));						new := RoundValue(100 * (1.0 * (thermoValue[j]) / thermoMax[j]));						if old<> new then							begin								RedrawThermoNumber(theDialog,new);								oldThermoNumberValue[j] := thermoValue[j];							end;					end				else if thermoMax[j] <= 1000 then					RedrawThermoNumber(theDialog,thermoValue[j])				else if thermoValue[j] mod 10 = 0 then						RedrawThermoNumber(theDialog,thermoValue[j]);				ReDrawMaxNumber(theDialog,j);			end;		genericSetPort(tempP);	end;{-----------------------------------------------------------------------------}	procedure UpdateThermo (theDialog: DialogPtr; min, value, max: longint; aspercent: boolean);		var			itemtype: integer;			H: handle;			box: rect;			boxlen, percentlen,old,new,oldpercentlen: longint;			tempP: WindowPtr;			cancel: boolean;	begin		if theDialog=thermo1Window then			begin				thermoMin[1]:= min;				thermoValue[1] := value;				thermoMax[1] := max;				thermoAsPercent[1]:= aspercent;			end		else			begin				thermoMin[2]:= min;				thermoValue[2] := value;				thermoMax[2] := max;				thermoAsPercent[2]:= aspercent;			end;		genericGetPort(tempP);		genericSetPort(myGetWindowPtrForDialog(theDialog));		if UpdatePending(myGetWindowPtrForDialog(theDialog)) then {V3.01}			begin				DrawDialog(theDialog);				myValidRect(myGetWindowPtrForDialog(theDialog),WindowPortRect(myGetWindowPtrForDialog(theDialog)));			end;		CheckThermo(theDialog);		DrawStandardThermo(theDialog,1);		genericSetPort(tempP);	end;{-----------------------------------------------------------------------------}	procedure StartThermo (var theDialog: DialogPtr; var tempP: WindowPtr; min, max: longint; title, comment: str255; aspercent: boolean); {max < 0 is a signal to not draw the thermometer, instead drawing only the numerical values}		var			hor, ver: integer;			box: rect;			dlogid: integer;			tempH: Handle;	begin		resetDrawR:= false;		thermoLastCheck := TickCount;		if backgroundable then			dlogid := 132		else			dlogid := 450;		if treeopen & nodes & ((drawR <> ScreenR) | (DrawR <> R)) then			drawR := screenR;		if thermo1 then			begin				thermo2 := true;  {this is the second of 2 thermo DLOGs}				thermo2TimeStart := TickCount;			end		else			begin				thermo1 := true;				thermo1TimeStart := TickCount;			end;		if thermo2 then  {have to bypass the normal StartDLOG, so can offset it down underneath first thermo}			begin				thermoMin[2]:= min;				thermoValue[2] := min;				thermoMax[2] := max;				thermoAsPercent[2]:= aspercent;				oldThermoNumberValue[2] := min;				oldThermoBarValue[2] := min;				genericGetPort(tempP);				theDialog := GetNewDialog(dlogid, nil, Pointer(-1));				with WindowPortRect(myGetWindowPtrForDialog(theDialog)) do					begin						hor := (ScreenRectangle.right - (right - left)) div 2;						ver := (ScreenRectangle.bottom - (bottom - top) - GetMBarHeight) div 3 + GetMBarHeight + (bottom - top) + 50;					end;				MoveWindow(myGetWindowPtrForDialog(theDialog), hor, ver, false);				standardThermo2UserItemUProcP := MyNewUserItemUPP(@DrawStandardThermo);  				tempH := Handle(standardThermo2UserItemUProcP);				SetDialogItem(theDialog,7, UserItem, tempH, box);			end		else			begin				thermoMin[1]:= min;				thermoValue[1] := min;				thermoMax[1] := max;				thermoAsPercent[1]:= aspercent;				oldThermoNumberValue[1] := min;				oldThermoBarValue[1] := min;				StartDLOG(dlogid, theDialog, tempP);				standardThermo1UserItemUProcP := MyNewUserItemUPP(@DrawStandardThermo);  				tempH := Handle(standardThermo1UserItemUProcP);				SetDialogItem(theDialog,7, UserItem, tempH, box);			end;					if thermo2 then			thermo2Window := theDialog		else			thermo1Window := theDialog;{v3.01:  do text with SetDLOGTExt, not ParamText}		if backgroundable then			SetWTitle(myGetWindowPtrForDialog(theDialog), title)		else			SetDLOGText(theDialog,6, title, false);		if max >= 0 then			begin				if aspercent then					begin						SetDLOGText(theDialog, 3, '0', false);						{SetDLOGText(theDialog, 4, '100%', false);}					end				else					begin						SetDLOGText(theDialog, 3, StringFromNum(min), false);						{SetDLOGText(theDialog, 4, StringFromNum(max), false);}						SetDLOGText(theDialog, 5, comment, false);					end;			end		else			;		SetCursorToArrow;		myShowDialog(theDialog);		if not ThermoAbortable then			HideDialogItem(theDialog, thermoStopButtonItem);		ScreenInColor := WindowInColor(myGetWindowPtrForDialog(theDialog));		DrawDialog(theDialog);		abortedThermo := false;		UpdateThermo(theDialog, min, min, max,aspercent);		EnableDisablePrimaryMenus(false);	end;{-----------------------------------------------------------------------------}	procedure EndThermo (var theDialog: DialogPtr; tempP: WindowPtr; dobeep: boolean);	begin		if theDialog= nil then			Exit(EndThermo);		EndDLOG(theDialog, tempP);		theDialog := nil;		if not thermo2 then			PostBackGroundNotification;		if thermo2 then			begin				MyDisposeUserItemUPP(StandardThermo2UserItemUProcP);				thermo2 := false;				thermo2Window := nil;			end		else			begin				MyDisposeUserItemUPP(StandardThermo1UserItemUProcP);				thermo1 := false;				if dobeep & ((TickCount - thermo1TimeStart) > 900) & isforeground then   {v3.02: }					Beep;				InvalidateAllWindowsMarkedUnupdatable;				thermo1Window := nil;			end;		SetCursorToArrow;		abortedThermo := false;		EnableDisablePrimaryMenus(true);		DoActivates(frontWindow);{    backgroundable := false;}	end;{-----------------------------------------------------------------------------}	var		SearchThermoUserItemUProcP: UniversalProcPtr;		searchThermoValue: longint;{-----------------------------------------------------------------------------}	procedure DrawSearchThermo (theDialog: DialogPtr; itemNo: Integer);	var tempP: WindowPtr;			H: handle;			box: rect;			itemtype: integer;	begin		genericGetPort(tempP);		genericSetPort(myGetWindowPtrForDialog(theDialog));		GetDialogItem(theDialog, 5, itemtype, H, box);		EraseRect(box);		MoveTo(box.left, box.bottom - 3);		DrawString(LengthString(searchThermoValue,true));		genericSetPort(tempP);	end;{-----------------------------------------------------------------------------}	procedure UpdateSearchThermo (theDialog: DialogPtr; value: longint);		var			tempP: WindowPtr;	begin		genericGetPort(tempP);		genericSetPort(myGetWindowPtrForDialog(theDialog));		searchThermoValue := value;		if isForeground then			HiliteWindow(myGetWindowPtrForDialog(theDialog),true);				if UpdatePending(myGetWindowPtrForDialog(theDialog)) then {V3.01}			begin				DrawDialog(theDialog);				myValidRect(myGetWindowPtrForDialog(theDialog),WindowPortRect(myGetWindowPtrForDialog(theDialog)));			end;		CheckThermo(theDialog);		genericSetPort(tempP);		DrawSearchThermo(theDialog,6);	end;{-----------------------------------------------------------------------------}{-----------------------------------------------------------------------------}	procedure StartSearchThermo (var theDialog: DialogPtr; var tempP: WindowPtr;value: longint); {max < 0 is a signal to not draw the thermometer, instead drawing only the numerical values}		var			hor, ver: integer;			box: rect;			dlogid: integer;			tempH: Handle;	begin		resetDrawR:= true;		thermoLastCheck := TickCount;		if treeopen & nodes & ((drawR <> ScreenR) | (DrawR <> R)) then			drawR := screenR;		thermo1 := true;					thermo1TimeStart := TickCount;		StartDLOG(172, theDialog, tempP);SearchThermoUserItemUProcP := MyNewUserItemUPP(@DrawSearchThermo);  tempH := Handle(SearchThermoUserItemUProcP);SetDialogItem(theDialog,6, UserItem, tempH, box);		SetCursorToArrow;		myShowDialog(theDialog);		SetDLOGText(theDialog, 4, LengthString(value,true), false);		if not ThermoAbortable then			HideDialogItem(theDialog, thermoStopButtonItem);		ScreenInColor := WindowInColor(myGetWindowPtrForDialog(theDialog));		DrawDialog(theDialog);		abortedThermo := false;		UpdateSearchThermo(theDialog, value);		EnableDisablePrimaryMenus(false);	end;{-----------------------------------------------------------------------------}	procedure EndSearchThermo (var theDialog: DialogPtr; tempP: WindowPtr; dobeep: boolean);	begin		SetCursorToArrow;		if not abortedThermo & isforeground then			begin				Beep;				Beep;				SetButtonTitle(theDialog,2,'Close');				FrameButton(theDialog,2);				{DrawDialog(theDialog);}				allowReturnAsCancel := true;				repeat					CheckThermo(theDialog);				until abortedthermo;				allowReturnAsCancel := false;			end;				MyDisposeUserItemUPP(SearchThermoUserItemUProcP);		EndDLOG(theDialog, tempP);		theDialog := nil;		EnableDisablePrimaryMenus(true);				PostBackGroundNotification;		InvalidateAllWindowsMarkedUnupdatable;		abortedThermo := false;		thermo1 := false;{    backgroundable := false;}		resetDrawR:= false;		DoActivates(frontWindow);	end;{-----------------------------------------------------------------------------}{-----------------------------------------------------------------------------}	procedure UpdateButtonThermo (theDialog: DialogPtr);		var			tempP: WindowPtr;	begin		genericGetPort(tempP);		genericSetPort(myGetWindowPtrForDialog(theDialog));		if isForeground then			HiliteWindow(myGetWindowPtrForDialog(theDialog),true);				if UpdatePending(myGetWindowPtrForDialog(theDialog)) then {V3.01}			begin				DrawDialog(theDialog);				myValidRect(myGetWindowPtrForDialog(theDialog),WindowPortRect(myGetWindowPtrForDialog(theDialog)));			end;		CheckThermo(theDialog);		genericSetPort(tempP);	end;{-----------------------------------------------------------------------------}{-----------------------------------------------------------------------------}	procedure StartButtonThermo (var theDialog: DialogPtr; var tempP: WindowPtr; titleString: str255);		var			box: rect;			dlogid: integer;			tempH: Handle;	begin		resetDrawR:= true;		thermoLastCheck := TickCount;		if treeopen & nodes & ((drawR <> ScreenR) | (DrawR <> R)) then			drawR := screenR;		thermo1 := true;					thermo1TimeStart := TickCount;		StartDLOG(184, theDialog, tempP);		ParamText(titleString, '', '', '');		SetCursorToArrow;		myShowDialog(theDialog);		ScreenInColor := WindowInColor(myGetWindowPtrForDialog(theDialog));		DrawDialog(theDialog);		CallWaitNextEventForDrawing;		abortedThermo := false;		UpdateButtonThermo(theDialog);		EnableDisablePrimaryMenus(false);	end;{-----------------------------------------------------------------------------}	procedure EndButtonThermo (var theDialog: DialogPtr; tempP: WindowPtr; dobeep: boolean);	begin		SetCursorToArrow;				EndDLOG(theDialog, tempP);		theDialog := nil;		EnableDisablePrimaryMenus(true);				InvalidateAllWindowsMarkedUnupdatable;		abortedThermo := false;		thermo1 := false;{    backgroundable := false;}		resetDrawR:= false;		DoActivates(frontWindow);	end;{-----------------------------------------------------------------------------}{----------------------------------------------------------------------------}	function UniversalDLOGFilter (theDialog: DialogPtr; var Event: EventRecord; var localItemHit: Integer): BOOLEAN;	var updateWindow: WindowPtr;		os: OSStatus;		standardProc: ModalFilterUPP;	begin		UniversalDLOGFilter := FALSE;		case Event.what of			updateEvt:				begin					UpDateWindow := myGetWindowPtrFromEventMessage(Event);					if (updateWindow<>myGetWindowPtrForDialog(theDialog)) then						DealwithUpdates(Event,false);				end;{$IFC NOT POWERPC}			keyDown:				if HitReturn(Event) then					begin						localItemHit := PressButton(theDialog, 1);						UniversalDLOGFilter := true;					end				else if KeyBoardCancel(Event) then					begin						localItemHit := PressButton(theDialog, 2);						UniversalDLOGFilter := true;					end;{$ENDC}  			otherwise{$IFC POWERPC}  				begin  					os := GetStdFilterProc(standardProc);  					if (os=noErr) then  						UniversalDLOGFilter := InvokeModalFilterUPP (theDialog, Event, localItemHit,standardProc);  				end{$ENDC}  				;		end;	end;end.