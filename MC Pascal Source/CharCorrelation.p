unit CharCorrelation;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{This unit performs the concentrated-changes character correlation test described}{by W. Maddison (1990, Evolution)}{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, UtilLibInterface, SetLibInterface,   StrUtil, BoxUtil, TaxonCHUtil, Thermos, CharUtil, TreeUtil, WriteUtil;	procedure DoCharCorrel (N: Nptr);{еееееееееееееееееееееее}implementation {е$S CharCorrelation}	const{=====items in AskForResults dialog box}		OKitem = 1;		ZeroAncItem = 2;		OneAncItem = 3;		EitherAncItem = 4;		gainsItem = 7;		lossesitem = 8;		distareaitem = 9;		gainsBlackItem = 10;		lossesBlackItem = 11;		moregainsItem = 13;		asmanygainsItem = 15;		fewergainsitem = 23;		morelossesItem = 14;		asmanylossesItem = 16;		fewerlossesitem = 24;		probitem = 17;{=====items in AskForParameters dialog box}		ZeroBlackitem = 3;		EquivBlackitem = 4;		OneBlackitem = 5;		exactcountitem = 8;		simulitem = 11;		statedgainsitem = 10;		statedlossesitem = 14;		Cancel356item = 15;		samplesizeitem = 16;		actualitem = 17;		firstresitem = 18;		lastresitem = 19;		SeedItem = 22;		Comp0item = 24;		Comp1item = 25;		Comp2item = 26;		Comp3item = 27;		ZeroAncSIMitem = 30;		OneAncSIMitem = 31;		samp0item = 32;		samp1item = 33;		samp01item = 34;{====== The maximum number of gains and losses allowed}		maxgains = 60;		maxlosses = 60;		storsize = 4;   {4 if storage=single or longint; 8 if =double; 10 if =extended; note storage is set at longint}	type		storage = longint; {storage of results is longint for speed}		lptr = ^storage;	var{Pointers to basic storage at root (node pN) of clade selected.}{pNMz stores the number of ways to have certain numbers of gains and losses in the whole clade;}{		assumes zero ancestral but one-ancestral case for i,j given by looking at zero-ancestral case for j,i}{		USED FOR EXACT COUNT}{pNMbz stores the number of ways to have certain numbers of gains and losses in the QDBlack areas of the}{		clade given certain numbers of gains and losses in total in the whole clade}{		assumes zero ancestral but one-ancestral case for i,j given by looking at zero-ancestral case for j,i}{		USED FOR EXACT COUNT}{ pNMs0 and pNMs1 store the number of simulated instances which had a certain numbers of gains and losses}{		in the QDBlack areas of the 	clade given certain numbers of gains and losses in total in the whole clade}{		and given either 0 or 1 was	ancestral; USED FOR SIMULATIONS; the number of instances in which }{		the certain numbers of gains and losses were observed in the simulations is contained in samplesize}{		Note: Currently don't need both pNMs0 and pNMs1, since simulations now allow only one pre-specified ancestor; however}{		both are maintained so as not to require changes throughout code}		pNMz, pNMbz, pNMs0, pNMs1: Ptr;		samplesize: longint;  {samplesize achieved in simulation}		oneancestral, zeroancestral, incr1, incr2, incr3, incr4, maxGainsLosses: integer;		querygains, querylosses, querygainsBlk, querylossesBlk: longint;		numtaxainclade: longint;		moregains, asmanygains, fewergains, morelosses, asmanylosses, fewerlosses: boolean;		lp, rp, npp, npz: lptr;		abort: boolean;		zerosize, blackzerosize: size;		samplesize0, samplesize1: longint;{-----------------------------------------------------------------------------}{=========The following procedures are the critical ones:   }{=========CountGainsLosses, AskForResults, AskForBlack, DoStatistics}{-----------------------------------------------------------------------------}{The following several functions and procedures are utility procedures that write and read from}{the Mz and Mbz matrices.  Since these matrices are not used as pascal arrays, we use pointer}{arithmetic using the incr1, incr2, incr3, and incr4 to move through the 4 dimensions of the}{matrices}	function GetZero (igns, ilos: integer): storage;{Gets the number of ways to have igns and ilos on tree (using pNMz); for use after calculations to present results}		var			npt: lptr;	begin		npt := lptr(ord4(pNMz) + igns * incr3 + ilos * incr4);		getzero := npt^;	end;{--------------------------------------------------}	function GetBlackZero (anc: integer; igns, ilos, ignsblk, ilosblk: longint): storage;{Gets the number of ways to have ignsblk and ilosblk in QDBlack areas of tree given}{ igns gains and ilos losses in total on tree, and given state anc (0 or 1) is ancestral; }{for use during simulations to bump up by 1 the number, and after calculations to present results}		var			npt: lptr;	begin		if exactcount then			begin				if anc = 0 then					npt := lptr(ord4(pNMbz) + igns * incr1 + ilos * incr2 + ignsblk * incr3 + ilosblk * incr4)				else					npt := lptr(ord4(pNMbz) + igns * incr2 + ilos * incr1 + ignsblk * incr4 + ilosblk * incr3)			end		else			begin				if anc = 0 then					npt := lptr(ord4(pNMs0) + ignsblk * incr3 + ilosblk * incr4)				else					npt := lptr(ord4(pNMs1) + ignsblk * incr3 + ilosblk * incr4);			end;		getblackzero := npt^;	end;{--------------------------------------------------}	procedure setBlackZero (anc: integer; ignsblk, ilosblk: longint; sset: storage);{Sets to sset the number of ways to have ignsblk and ilosblk in QDBlack areas of tree given}{ igns gains and ilos losses in total on tree, and given state anc (0 or 1) is ancestral; }		var			npt: lptr;	begin		if anc = 0 then			npt := lptr(ord4(pNMs0) + ignsblk * incr3 + ilosblk * incr4)		else			npt := lptr(ord4(pNMs1) + ignsblk * incr3 + ilosblk * incr4);		npt^ := sset;	end;{--------------------------------------------------}	function NodeInBlack (N: Nptr): integer;{returns 1 if node N is in the QDBlack region of the tree (i.e., the region of interest), 0 otherwise}	begin{the tree booleans, oneBlack, ZeroBlack and equivBlack, }{store whether areas with 0, 1, or 01 are to be considered areas of interest}		if (oneBlack & (N^.final = [1])) | (zeroBlack & (N^.final = [0]) | (equivBlack & (N^.final = [0, 1]))) then			NodeInBlack := 1		else			NodeinBlack := 0;	end;{-----------------------------------------------------------------------------------}{--------------------          EXACT CALCULATIONS         -------------------------------}{-----------------------------------------------------------------------------------}	function CountGainsLosses (pN: Nptr): boolean;{FROZEN 3.0}{The main exact count procedure; returns true if successfully completed counting gains and losses.}{This procedure recurses through the tree, calculating numbers of ways to have gains and losses total and}{in QDBlack area according to the formulae of W.Maddison (1990).  }{Note the idea is to ask given x gains and y losses, what is the probability of having w gains and z losses}{in the QDBlack area of the cladogram.  The number of terminal taxa with states 0 and 1 is NOT a given;}{it is allowed to vary as the changes are assigned randomly to the branches}		var			InBlackNlf, InBlackNrt: integer;			quitcount: boolean;			tempP: WindowPtr;			theDialog: DialogPtr;			numunits, totunits: longint;			monitor: longint;			parachute: boolean;{...........................}		procedure CombineLeftRightCore (var npp: lptr; lefMbz, rtMbz: ptr; ilos, ilosblk, nlosblk, nlos, ngns: integer; leftONE, rightONE: boolean);{this procedure combines Mbz matrices of node's left & right descendants into Mbz matrix of node}{It thus cycles through various possible numbers of gains in the QDBlack in the whole clade, gains in QDBlack in the left clade,}{and gains in the left clade, multiplying and adding the numbers of ways to have these distributions over}{all possibilites.  It thus outputs the number of ways to have various numbers of gains and losses in the QDBlack part}{of the clade given a certain number of gains and losses in the clade}			label				1;			var				lp, rp, lpINIT, rpINIT: lptr;				ngnsblk, igns, ignsblk: integer;				incrB1, incrB2: longint;				lfincr1, lfincr2, lfincr3, lfincr4, rtincr1, rtincr2, rtincr3, rtincr4: longint;		begin{if left or right node has state 1, we need to use its matrix in transposed form which is what is needed}{for the case given ancestral state is 1.}{To use matrix in transposed form, the element for i gains, j losses, k gains in QDBlack, l losses in QDBlack}{is looked for in element jilk of matrix.  For this reason, when dealing with any node with state 1,}{ incr1 and incr2 are interchanged; incr3 and incr4 are interchanged}			if leftONE then				begin					lfincr1 := incr2;					lfincr2 := incr1;					lfincr3 := incr4;					lfincr4 := incr3;				end			else				begin					lfincr1 := incr1;					lfincr2 := incr2;					lfincr3 := incr3;					lfincr4 := incr4;				end;			if rightONE then				begin					rtincr1 := incr2;					rtincr2 := incr1;					rtincr3 := incr4;					rtincr4 := incr3;				end			else				begin					rtincr1 := incr1;					rtincr2 := incr2;					rtincr3 := incr3;					rtincr4 := incr4;				end;{Increment definitions when matrix is viewed in native ij form:}{incr1	increment to go to next gains total}{incr2	increment to go to next losses total}{incr3	increment to go to next gains in QDBlack}{incr4	increment to go to next losses in QDBlack}	{setting initial position of lp at 0 gains QDBlack & total; and ilos losses total &  ilosblk losses QDBlack}			lpINIT := lptr(ord4(lefMbz) + ilos * lfincr2 + lfincr4 * ilosblk);	{setting initial position of rp at ngns gains total & ngnsblk gains QDBlack;}	{and (nlos - ilos) losses total &  (nlosblk - ilosblk) losses QDBlack}			rpINIT := lptr(ord4(rtMbz) + ngns * rtincr1 + rtincr2 * (nlos - ilos) + rtincr4 * (nlosblk - ilosblk));			for ngnsBlk := 0 to ngns do				begin					lp := lpINIT;	{resetting initial position of lp}					rp := lptr(ord4(rpINIT) + rtincr3 * ngnsblk);					incrB1 := -lfincr3 * (ngnsBlk + 1) + lfincr1; {this increment undoes inner loop, then adds incr1 to move to next igns}					incrB2 := rtincr3 * (ngnsBlk + 1) - rtincr1;  {this increment undoes inner loop, then subtracts incr1 to move to previous igns}					for igns := 0 to ngns do						begin							for ignsBlk := 0 to ngnsBlk do								begin									npp^ := multaddC(npp^, lp^, rp^);									if npp^ < 0 then  {if multaddC has indicated that longint overflow, set flag}										begin											monitor := npp^; {MONITOR is changed to negative if longinteger overflow occurred}											quitcount := true;											goto 1;										end;									lp := lptr(ord4(lp) + lfincr3);  {incr3; from one ignsblk to subsequent}									rp := lptr(ord4(rp) - rtincr3);  {-incr3; from one ignsblk to previous}								end;							lp := lptr(ord4(lp) + incrB1); {incrB1; move to start of subsequent igns (see incrB1 definition above)}							rp := lptr(ord4(rp) + incrB2); {incrB2; move to start of previous igns (see incrB2 definition above)}						end;					npp := lptr(ord4(npp) + incr3);  {incr3; from one ngnsblk to subsequent}				end;1:		end;{...........................}		procedure CombineMatrices (NMbz, lefMbz, rtMbz: ptr; InBlackNLF, InBlackNrt, ngns, nlos: integer);{This procedure takes the 4-dimensional matrices at left and right nodes, lefMbz and rtMbz, which store the number of ways there}{are to have certain numbers of gains and losses in the QDBlack areas of their clades given certain numbers of}{gains and losses total in the clade, and calculates the same matrix for the node N itself}{(the combinatorics which don't take into account blackness, only the number of ways to have a number of gains and losses}{in total in the clade, are done in the main part of InGainsLosses)}			var				npp: lptr;				nlosblk, ilos, ilosblk: integer;		begin			nlosBlk := 0;			while nlosBlk <= Nlos do				begin					ilos := 0;					while ilos <= nlos do						begin							ilosBlk := 0;							while ilosBlk <= nlosBlk do								begin{The four possibilities for states at left and right nodes have to be considered, and for each their contributions to}{numbers of ways to have gains and losses is added into sums in NMbz}{ o   o  ---- Suppose both Left and right descendants of N  have state 0}				{start pointer for N at ngns,nlos,nlosblk locations (for ngnsblk, adjustments will be made in CombineLeftRightCore)}									npp := lptr(ord4(NMbz) + ngns * incr1 + nlos * incr2 + nlosblk * incr4);									CombineLeftRightCore(npp, lefMbz, rtMbz, ilos, ilosblk, nlosblk, nlos, ngns, false, false);									npp := lptr(ord4(npp) - incr3 * (ngns + 1));  {undoes outer loop's changing of npp}{ е   o  ---- Suppose Left descendant of N has state 1, right has state 0}									npp := lptr(ord4(npp) + incr3 * InBlackNlf);  {if left node is in QDBlack then one QDBlack gain is accounted for}								{on this left branch, thus we will begin filling npp at one QDBlack gain instead of zero}									ngns := ngns - 1;  {since one gain accounted for between N, left and right, deal with one less in left and right clades}									CombineLeftRightCore(npp, lefMbz, rtMbz, ilos, ilosblk, nlosblk, nlos, ngns, true, false);									npp := lptr(ord4(npp) - incr3 * (ngns + 1 + inBlackNlf)); {undoes outer loop's changing of npp as wel as initial jump by inblackNlf}{ o   е  ----  Suppose Left descendant of N has state 0, right has state 1}{Thus one gain is accounted for locally (N has 0)} {Recall ngns still set at ngns-1 since one gain accounted for between N, left and right}									npp := lptr(ord4(npp) + incr3 * InBlackNrt);  {if right node is in QDBlack then one QDBlack gain is accounted for}								{on this right branch, thus we will begin filling npp at one QDBlack gain instead of zero}									CombineLeftRightCore(npp, lefMbz, rtMbz, ilos, ilosblk, nlosblk, nlos, ngns, false, true);									npp := lptr(ord4(npp) - incr3 * (ngns + 1 + InBlackNrt));{undoes outer loop's changing of npp as wel as initial jump by inblackNlf}{ е   е  ----  Suppose Left and right descendants of N have state 1}{Thus two gains accounted for locally (N has 0) }{Recall ngns still set at ngns-1; now we subtract one more since two gains accounted for between N, left and right,}{ deal with one less in left and right clades}									ngns := ngns - 1;									npp := lptr(ord4(npp) + incr3 * (InBlackNrt + InBlackNlf)); {if both nodes are in QDBlack then two QDBlack gains are accounted for}								{on these branches, thus we will begin filling npp at two QDBlack gain instead of zero}									CombineLeftRightCore(npp, lefMbz, rtMbz, ilos, ilosblk, nlosblk, nlos, ngns, true, true);									ngns := ngns + 2;  {restore ngns to original value}									ilosBlk := ilosBlk + 1; {bump up to next number of ilosBlk}								end;							ilos := ilos + 1;{bump up to next number of ilos}						end;					nlosBlk := nlosBlk + 1;{bump up to next number of nlosBlk}				end;		end;{..............}		procedure ZeroZbZmatrices (NMz, NMbz: ptr);{initializes at zero the matrices for gains and losses, both total and in QDBlack given total}			var				igns, ilos, ngns, nlos: integer;		begin			npp := lptr(NMbz);			npz := lptr(NMz);			for ngns := 0 to maxgainslosses do				for nlos := 0 to maxgainslosses do					begin						Npz^ := 0;						for igns := 0 to maxgainslosses do							for ilos := 0 to maxgainslosses do								begin									npp^ := 0;									npp := lptr(ord4(npp) + incr4);								end;						npz := lptr(ord4(npz) + incr4);					end;		end;{...........................}		procedure CombineTotal (var nsum: longint; lefMz, rtMz: ptr; ngnss, nlos, ilos: integer; leftone, rightone: boolean);{combines matrices regarding gains and losses total in left and right subclades}{into matrix for gains and losses total in clade. }			var				lfincInit, lfincCycle, rtincInit, rtincCycle: longint;				lp, rp: lptr;				igns: integer;		begin			if leftOne then  {if one basal in a clade then use matrix in transposed form }				begin					lfincInit := incr3;					lfincCycle := incr4;				end			else				begin					lfincInit := incr4;					lfincCycle := incr3;				end;			if rightOne then				begin					rtincInit := incr3;					rtincCycle := incr4;				end			else				begin					rtincInit := incr4;					rtincCycle := incr3;				end;{given the ngns, nlos, and ilos passed, this procedure tries all values of igns (number of gains in left hand clade)}{and keeps running total of number of ways to have ngns gains and nlos losses}			lp := lptr(ord4(lefMz) + ilos * lfincInit); {init at 0 gains in left, ilos losses}			rp := lptr(ord4(rtMz) + ngnss * rtincCycle + (nlos - ilos) * rtincInit); {and therefore ngnss in right, nlos-ilos losses}			for igns := 0 to ngnss do				begin					nsum := multaddC(nsum, lp^, rp^);					if nsum < 0 then						monitor := nsum; {MONITOR is changed to negative if longinteger overflow occurred}					lp := lptr(ord4(lp) + lfincCycle);					rp := lptr(ord4(rp) - rtincCycle);				end;		end;{...................................-----------------------------------}		procedure InGainsLosses (N: Nptr; var NMz, NMbz: Ptr);{This is the main recursive procedure which moves through the tree to calculate the numbers of}{ways to have various distributions of gains and losses}{Note that this procedure has to carefully dispose of memory as it parachutes out in case of an}{overflow or user-abort}			label				2, 3;			var				lefMz, lefMBZ, rtMz, rtMBZ: Ptr;				ilos, ngns, nlos: integer;				nsum: longint;		begin			if (NodeIsInternal(N)) then   {INTERNAL NODE =======================}				begin					if FirstCladeIsBigger(N^.lf, N^.rt) then						begin  {left clade is bigger, go there first to save memory}							InGainsLosses(N^.lf, lefMz, lefMbz); {rule is, if quitcount is set in run of this procedure, node's storage is zapped}							if not quitcount then								begin									InGainsLosses(N^.rt, rtMz, rtMbz); {not quitcount, thus go up right also}									if quitcount then {quitcount encountered in right; thus zap left and later skip out}										begin											ZapPointer(lefMz);											ZapPointer(lefMbz);										end;								end;						end					else						begin							InGainsLosses(N^.rt, rtMz, rtMbz);							if not quitcount then								begin									InGainsLosses(N^.lf, lefMz, lefMbz); {not quitcount, thus go up left also}									if quitcount then {quitcount encountered in left; thus zap right and later skip out}										begin											ZapPointer(rtMz);											ZapPointer(rtMbz);										end;								end;						end;					if quitcount then						goto 3;					NMz := newptr(zerosize);					if HeapResult <> 0 then						begin							parachute := true;							quitcount := true;							goto 2 {Quitcount; goto 2 and zap storage above}						end;					NMbz := newptr(blackzerosize);					if HeapResult <> 0 then						begin							ZapPointer(NMz); {zap previous storage}							parachute := true;							quitcount := true;							goto 2 {Quitcount; goto 2 and zap storage above}						end;					if not quitcount then {Now let's get to business calculating}						begin							ZeroZbZmatrices(NMz, NMbz);							for ngns := 0 to maxgainslosses do								begin									for nlos := 0 to maxgainslosses do										begin{about to calc num ways ngns GAINS and nlos LOSSES total in clade given 0 at N}											npp := lptr(ord4(NMz) + ngns * incr3 + nlos * incr4);											for ilos := 0 to nlos do												begin													nsum := npp^;													CombineTotal(nsum, lefMz, rtMz, ngns, nlos, ilos, false, false);{ o   o }													CombineTotal(nsum, lefMz, rtMz, ngns - 1, nlos, ilos, true, false);{ е   o }													CombineTotal(nsum, lefMz, rtMz, ngns - 1, nlos, ilos, false, true);{ o   е }													CombineTotal(nsum, lefMz, rtMz, ngns - 2, nlos, ilos, true, true);{ е   е }													npp^ := nsum;													if (checkabortoften & commandperiod) | (monitor < 0) then														begin															quitcount := true;															ZapPointer(NMz);															ZapPointer(NMbz);															goto 2;														end;												end;{    NM^.zero[ngns, nlos] := NM^.zero[ngns, nlos] + toadd;}{about to calc num ways ngns GAINS and nlos LOSSES given 1 at N}											if (traceshown = traceDiscrete) then  {test can only be run with (traceshown = traceDiscrete), but asked here just in case}												begin{  to calc num ways for p gains q losses in QDBlack are given ngns and nlos totals }{  use BlackZero and BlackOne for N^.lf and N^.rt depending on which of 4 cases}{  if either of N^.lf or!N^.rt are in QDBlack then their gains/losses can be added otherwise not}													InBlackNlf := NodeInBlack(N^.lf);													InBlackNrt := NodeInBlack(N^.rt);													CombineMatrices(NMbz, lefMbz, rtMbz, InBlackNLF, InBlackNrt, ngns, nlos);													if checkabortoften then														UpdateThermo(thedialog, 0, numunits, totunits,true);													if (abortedthermo) or (monitor < 0) then														begin															quitcount := true;															ZapPointer(NMz);															ZapPointer(NMbz);															goto 2;														end;													numunits := numunits + 1;												end;										end;								end;						end;2:					ZapPointer(lefMz); {disposing descendant storage}					ZapPointer(lefMbz);					ZapPointer(rtMz);					ZapPointer(rtMbz);3:					if not parachute & not checkabortoften then						UpdateThermo(thedialog, 0, numunits, totunits,true);				end  {INTERNAL NODE =======================}			else  {TERMINAL NODE =======================}				begin					NMz := newptr(zerosize);					if HeapResult <> 0 then						begin							parachute := true;							quitcount := true;						end;					if not quitcount then						begin							NMbz := newptr(blackzerosize);							if HeapResult <> 0 then								begin									parachute := true;									quitcount := true;									ZapPointer(NMz);								end;							if not quitcount then								begin									ZeroZbZmatrices(NMz, NMbz);  {initializing terminals with zero}									npp := lptr(Nmbz);									npp^ := 1;  {except for 0,0,0,0 element}									npz := lptr(NMz); {except for 0,0 element}									npz^ := 1;								end;						end;				end; {TERMINAL NODE =======================}		end;	begin		monitor := 0;		parachute := false;		quitcount := false;		numunits := 0;		totunits := (numtaxainclade - 1) * (maxgainslosses + 1) * (maxgainslosses + 1); {for thermometer's sake}		StartThermo(theDialog, tempP, 0, totunits, 'Calculating probabilities', 'percent', true);		InGainsLosses(pN, pNMz, pNmbz);		if parachute then			InstantError(181);		if monitor < 0 then {MONITOR is changed to negative if longinteger overflow occurred}			InstantError(149);		Beep; {beep to say done}		CountgainsLosses := not quitcount;		EndThermo(theDialog, tempP, true);	end;{-----------------------------------------------------------------------------------}{--------------------                 SIMULATIONS                -------------------------------}{-----------------------------------------------------------------------------------}{These simulations epeatedly generate character evolution, assigning changes to branches}{with equal probability, and count in how many instances the changes occurred in QDBlack and }{white areas of the tree. It also allows one to count reconstructed changes instead of actual }{changes. }{NOTE ABOUT ANCESTRAL STATE: Note that whereas the exact calculations do not start off }{assuming ancestral state, the simulations do.  The ancestral state assumed is that at the }{node selected, i.e. the "ingroup node" of the clade selected, NOT at the node just before }{this. }{In the EXACT count one does not need to prespecify an ancestral state.  By assigning gains }{and losses randomly to the branches, as a side consequence one ends up implying an }{ancestral state  at the root node of the clade selected.  This state will be sometimes 0, }{sometimes 1.   If there are more ways to put 0 at the base and have a certain number of }{gains and losses than there are to put 1 at the base and have this many gains and losses, }{then the conditional probability of 0 versus 1 being at the base will be higher for 0.  This }{will slant any summed probabilities towards the 0 cases. }{With the SIMULATIONS,  it is not clear whether a change is a gain or a loss until one }{recurses up the tree with an ancestral state assumed.  It would be easy simply to assume }{an ancestral state, then count gains and losses.  But is there any way we can exactly }{duplicate the exact situation, in which the ancestral state could be either 0 or 1 with }{probabilities depending on ways to  distribute gains and losses?  Suppose one assigned }{changes to branches then tried both 0 and 1 ancestors.  If the number of gains and losses }{desired were different, and the appropriate number of gains and losses appeared assuming }{0 was ancestral, then this could be counted as an instance  of the correct numbers and }{ancestor.  That is, we would assign the ancestor according to what allows the number of }{gains and losses to be correct. }{The probabilities obtained from counting cases of changes interpretable as a certain }{numbers of gains and losses will match those from redistributing gains and losses directly.  }{suppose we are asking about the case of 4 gains 2 losses overall.  Every distn of 6 changes }{interpretable as 4/2/0 is interpretable as only one particular distribution 4/2/0 [because }{given any one particular distn of 4/2/0, if any one gain was changed to a loss, all of the }{changes would have to be inverted to maintain sense of gains and losses, thus yielding a }{2/4/1 case].  Therefore #ways to distribute 6 changes interp as 4/2/0 = # ways 4/2/0.  }{Therefore ratio of #ways 6 changes interp as 4/2/0 to #ways 6 changes interp as 4/2/1 }{is equal to ratio of #ways 4/2/0 to  #ways 4/2/1.   Thus if for each distn of changes we }{ask if it is interpretable as 4/2/0 or 4/2/1, the relative frequency of each will match }{exactly the frequency of 4/2/0 versus 4/2/1 had we been examining the different ways }{to distribute 4 gains and 2 losses directly.  Within each of these classes, e.g. 4/2/0, the }{different ways to distribute the 4 gains and 2 losses will be each represented once each }{among the different ways to distribute 6 changes.  Thus the probabilities under reshuffling }{of changes interpretable as 4/2 of different numbers of gains and losses in the QDBlack area, }{and the probabilities of placing 0 or 1 at the base, will reflect the true probabilites in }{reshuffling 4 gains 2 losses.}{If the number of gains and losses overall are the same, e.g., 3/3, then each distribtuion of }{changes interpretable as 3/3/0 is also interpretable as 3/3/1.  Since in fact #ways }{3/3/0 = #ways 3/3/1 we can count each such case as an example of both 3/3/0 and }{3/3/1 and the desired 1:1 ratio of such instances will be maintained.  Each distribution of }{6 gains interpretable as 3/3/0 or 3/3/1 will be interpretable as only one particular }{distribution of 3/3/0 or 3/3/1.  Within each case, e.g. 3/3/0, the probabilities of }{different numbers of gains and losses in the QDBlack area will reflect the true probabilities }{under reshuffling of changes.}{All this applies for simulation of actual changes.  For simulation of RECONSTRUCTED }{CHANGES we need to assume an ancestral state in the simulation so as to assign states to }{terminal taxa from which to reconstruct changes.  The simulations can still ask about }{different distributions of 4/2/0 and 4/2/1, e.g. "Given that we have reconstructed 4 }{gains 2 losses and 0 at the base, what is the probability of so many gains in the QDBlack?".  }{However, one must realize that the assumed simulation ancestral state may not be the}{reconstructed one, and may get different probabilities from 4/2/0 given true ancestor 0 }{versus true ancestor 1}	procedure SimulateGainsLosses (pN: Nptr);{FROZEN 3.0}{The main simulations procedure; }{see notes above}		label			1;		var			sampleused: LIP;			lgsetZERO, lgsetONE, lgsetANC: lgsetchars;			dontstop: boolean;			np0, np1: lptr;			scp: SetPointer15;			setTocheck: setchars15;			Setnodes: ptr;			numns, numwords, bitnum, ngns, nlos: integer;			ag, al, agB, alB: longint;			theDialog0: DialogPtr;			tempP0: WindowPtr;			numchangeswanted, statedchanges: integer;			SumObservedChanges, NumberObservations: longint;			averagegap: double;{=====================}{Changes are assigned randomly to the nodes by first assigning 1's bits randomly into a}{block of memory initialized to all 0's; }{then the tree is recursed and node is assigned a change if its corresponding  bit is set.}{An alternative, more direct way, would be to assign to node using treeblock structure}{and placing the changes directly on the nodes, but this would require care if taxa are excluded}		procedure ChooseRandomChanges;			var				irr, trybit: integer;		begin			ZeroBlockWords(setnodes, numwords);			for irr := 1 to numchangeswanted do				begin					repeat {set random bit; if already set try again}						trybit := randombetween(1, numns); {note bit offset 0 never gets set because this is root}					until not Bittst(setnodes, trybit);					Bitset(setnodes, trybit);				end;		end;{..............}{This function returns whether next bit in setnodes is set; if so then we know a change goes on }{corresponding branch (see LocateGainsLosses)}		function NextBitisOne: boolean;		begin			bitnum := bitnum - 1;			if bitnum < 0 then				begin					bitnum := 15;					scp := SetPointer15(ord4(scp) + 2);					SetTocheck := scp^;				end;			NextbitIsOne := bitnum in settocheck;		end;{...................................................................................}{If the user has requested reconstructed changes instead of actual changes, then}{this procedure goes through tree and finds what changes would have been reconstructed to}{have occurred given the actual changes were as simulated.}{The reconstruction is done as follows: the changes are assigned to the branches.  Assuming}{the simulationancestor is the state at the node selected for the simulation test, these changes}{imply states in the terminal taxa.  Using these terminal states the ancestral states in the}{clade selected are reconstructed using the typical downpass, uppass, final pass.  Ambiguity}{in these states is resolved using either MINSTATE or MAXSTATE; this is done instead of acctran/}{deltran which can leave ambiguities unresolved. }{One issue of concern is whether or not to reconstruct the states of the selected clade in isolation.}{We don't know what the dependent character looks like, so we don't know its distribution outside the}{group in question.  Thus what do we do about pN's uppass state, i.e. the preference from below}{the chosen node?  Do we treat it as unknown and do the reconstruction on pN's clade in isolation?}{Do we suppose that the specification of ancestral state for pN (simulationancestor) implies}{knowledge of states from outside pN's clade, and thus we reconstruct using the state }{simulationancestor as the preference from below pN?  The former is what we have done.}		procedure RecolorTree;			var				sisN: Nptr;{.......Downpass sets used are bset1}			procedure simDownPass (N: Nptr);			begin				if NodeIsInternal(N) then					begin						simDownPass(N^.lf);						simDownPass(N^.rt);						N^.bset1 := UnordOperator2(N^.lf^.bset1, N^.rt^.bset1);					end				else					N^.bset1 := N^.bset3;  {for terminals get state assigned by LocateGainsLosses from actual changes}			end;{.......Uppass sets used are bset2}			procedure simUpPass (N: Nptr);			begin				if NodeIsInternal(N) then					begin						if N <> pN then {pN is root of clade}							begin								sisN := sis(N);								if N^.anc = pN then									N^.bset2 := sisN^.bset1								else									N^.bset2 := UnordOperator2(sisN^.bset1, N^.anc^.bset2);							end;						simUpPass(N^.lf);						simUpPass(N^.rt);					end;			end;{.......Final sets used are bset3}			procedure simFinalPass (N: Nptr);			begin				if NodeIsInternal(N) then					begin						if N <> pN then							N^.bset3 := UnordOperator3(N^.rt^.bset1, N^.lf^.bset1, N^.bset2);						if firstres then  {MINSTATE resolution, choose minimum value}							begin								if Enset(0, N^.bset3) then									N^.bset3 := lgsetZERO								else									N^.bset3 := lgsetONE;							end						else if lastres then {MAXSTATE resolution, choose maximum value}							begin								if Enset(1, N^.bset3) then									N^.bset3 := lgsetONE								else									N^.bset3 := lgsetZERO;							end;						simFinalPass(N^.lf);						simFinalPass(N^.rt);					end;				if N <> pN then {changes not allowed on root}					begin						if Intersect2(N^.bset3, N^.anc^.bset3) = nil then  {change is reconstructed on branch}							begin								if (N^.bset3 = lgsetONE) then {N is 1, thus 0->1 change, a gain}									begin										ag := ag + 1;										if NodeInBlack(N) = 1 then											agB := agB + 1;									end								else if (N^.bset3 = lgsetZero) then {N is 0, thus 1->0 change, a loss}									begin										al := al + 1;										if NodeInBlack(N) = 1 then											alB := alB + 1;									end;							end;					end;			end;{...}		begin			simDownPass(pN);			pN^.bset3 := pN^.bset1;			simUpPass(pN);			simFinalPass(pN);		end;{.........................................................................................}{This procedure begins at the root assuming its state is simulationancestor, then}{moves up the tree changing the node's states whenever an assigned change is encountered.}{If the simulation is using actual changes, this procedure will have calculated the correct}{number of these in ag, agB, etc.}{If the simulation will use reconstructed changes, then this procedure will have yielded}{the observed states in terminal taxa, to be later used for the reconstruction}		procedure LocateGainsLosses (ppN: Nptr);		begin			if NextBitisOne then  {i.e., a change was placed on the branch}				begin					if ppN^.anc^.bset3 = lgsetONE then						ppN^.bset3 := lgsetZERO					else						ppN^.bset3 := lgsetONE;					ppN^.length1 := ppN^.length1 + 1;					if actual then						begin							if ppN^.bset3 = lgsetONE then								begin  {must be a gain}									ag := ag + 1;									if NodeInBlack(ppN) = 1 then										agB := agB + 1;								end							else								begin  {must be a loss}									al := al + 1;									if NodeInBlack(ppN) = 1 then										alB := alB + 1;								end;						end;				end			else				ppN^.bset3 := ppN^.anc^.bset3;  {no change; pull state up from ancestor}			if NodeIsInternal(ppN) then				begin					LocateGainsLosses(ppN^.lf);					LocateGainsLosses(ppN^.rt);				end;		end;{.........................................................................................}{These two procedures perform a crude check to see if the simulation}{actually succeeded in placing changes on the branches more or less evenly.}{If there was a gross problem, i.e. one branch was missed entirely or was hit}{twice as much as another, then a warning will be given}		procedure EvenInit (ppN: Nptr);  {Initialize storage for how many hits on branch}		begin			ppN^.length1 := 0;			if NodeIsInternal(ppN) then				begin					EvenInit(ppN^.lf);					EvenInit(ppN^.rt);				end;		end;		procedure EvenCheck;  {checking to see if some branches hit or missed disproportionately}			var				largest, smallest: longint;			procedure EvenCRec (ppN: Nptr);			begin				if PPN <> pN then					begin						if ppn^.length1 > largest then							largest := ppn^.length1;						if ppn^.length1 < smallest then							smallest := ppn^.length1;					end;				if NodeIsInternal(ppN) then					begin						EvenCRec(ppN^.lf);						EvenCRec(ppN^.rt);					end;			end;		begin			largest := 0;			smallest := maxlongint;			EvenCREc(pN);			if (largest > 100) and (largest > 2 * smallest) then				InstantError(182);		end;{...........................................................................................}	begin		StartThermo(theDialog0, tempP0, 0, maxsample, 'Simulations', 'Sample size', false);		lgsetONE := Makeset(1);		lgsetZERO := Makeset(0);		lgsetANC := makeset(simulationancestor);		dontstop := false;		FlushEvents(everyevent, 0);		numns := (2 * numtaxainclade - 1);  {number of nodes}		numwords := numns div 16 + 1; {number of words in setnodes storage}		setnodes := NewPtr(numwords * 2);		statedchanges := (statedgains + statedlosses);		case bywhichsamplesize of  {finding what variable is sample size for completion of simulation}			0: 				sampleused := @samplesize0;			1: 				sampleused := @samplesize1;			2: 				sampleused := @samplesize;		end;{zeroing everything==============}		np0 := lptr(pNMs0);		np1 := lptr(pNMs1);		for ngns := 0 to maxgainslosses do			for nlos := 0 to maxgainslosses do				begin					np0^ := 0;					np1^ := 0;					np0 := lptr(ord4(np0) + incr4);					np1 := lptr(ord4(np1) + incr4);				end;		samplesize := 0;		samplesize0 := 0;		samplesize1 := 0;		SumObservedChanges := 0;		NumberObservations := 0;		EvenInit(pN);  {zeroing storage for error check on evenness of change distribution}		repeat			if actual then				numchangeswanted := statedchanges			else				numchangeswanted := statedchanges + compensation;			ChooseRandomChanges;			ag := 0;			agB := 0;			al := 0;			alB := 0;			if actual then  {if actual changes, start ancestor with 0; otherwise with state specified}				pN^.bset3 := lgsetZERO			else				pN^.bset3 := lgsetANC;			bitnum := 15;  {see NextBitIsOne, above}			scp := SetPointer15(setnodes);			SetTocheck := scp^;			LocateGainsLosses(pN^.lf); {find what are actual gains/losses}			LocateGainsLosses(pN^.rt);			if not actual then				begin					Recolortree;  {reconstruct changes}		{the following is designed to check to warn user if compensation is appropriate}		{"Compensation" is a variable indicating how many extra changes are desired.}		{It is needed because parsimony reduces the number of changes; thus if you are asking}		{about a case of 6 changes, if you throw down 7 or 8 actual changes parsimony will}		{have a better chance of reconstructing 6 than if you had thrown down 6 actual.}		{Note that this is not just an issue of speed; it could affect probabilities}					SumObservedChanges := SumObservedChanges + (ag + al);					NumberObservations := NumberObservations + 1;					if (numberObservations > 1000) then						begin							if not dontstop then								begin									averagegap := (1.0 * (statedchanges * numberobservations) - SumObservedChanges) / (1.0 * NumberObservations);				{in last thousand tries, on average reconstructed more than one extra or one too few changes,}				{thus perhaps decrease or increase compensation}									if abs(averagegap) > 1 then										begin											if (averagegap < 0) then												begin													if compensation > 0 then														begin															if Cwarning('The simulation may go faster if you reduce compensation.  Do you want to stop simulation?', 'Stop', 'Continue') then																goto 1;															dontstop := true;														end;												end											else if compensation < 3 then												begin													if Cwarning('The simulation may go faster if you increase compensation.  Do you want to stop simulation?', 'Stop', 'Continue') then														goto 1;													dontstop := true;												end;										end;								end;							SumObservedChanges := 0;							NumberObservations := 0;							UpdateThermo(thedialog0, 0, sampleused^, maxsample, false);						end;				end;			if actual then				begin  {cases interpretable as statedgains and statedlosses could either have this many gains or losses, or}		{the numbers could be inverted in which case could be interpreted as this many gains and losses with 1 ancestral}					if (((ag = statedgains) & (al = statedlosses)) | ((al = statedgains) & (ag = statedlosses))) then						begin							if ((ag = statedgains) and (al = statedlosses)) then								begin									SetBlackZero(0, agB, alB, (GetBlackZero(0, ag, al, agB, alB) + 1));									samplesize0 := samplesize0 + 1;								end;							if ((al = statedgains) and (ag = statedlosses)) then								begin									SetBlackZero(1, alB, agB, (GetBlackZero(1, al, ag, alB, agB) + 1));									samplesize1 := samplesize1 + 1;								end;							samplesize := samplesize + 1;							UpdateThermo(thedialog0, 0, sampleused^, maxsample,false);						end;				end			else if ((ag = statedgains) and (al = statedlosses)) then   {reconstructed changes: check for gains, losses & anc state}				begin					if pN^.bset3 = lgsetzero then						begin							SetBlackZero(0, agB, alB, (GetBlackZero(0, ag, al, agB, alB) + 1));							samplesize0 := samplesize0 + 1;						end					else						begin							SetBlackZero(1, agB, alB, (GetBlackZero(1, ag, al, agB, alB) + 1));							samplesize1 := samplesize1 + 1;						end;					samplesize := samplesize + 1;					UpdateThermo(thedialog0, 0, sampleused^, maxsample,false);				end;		until abortedThermo or (sampleused^ = maxsample);1:		ZapPointer(setnodes);		EndThermo(theDialog0, tempP0, true);		EvenCheck;	end;{-----------------------------------------------------------------------------}{This procedure checks numbers of gains and losses specified in dialog boxes to}{make sure they are within limits}	procedure CheckGainsLosses (theDialog: DialogPtr; itemnum: integer; var gl: longint; maxallowed: longint);		var			tempgl, j: longint;			tds, ds: str255;	begin		{ds := GetEditText(theDialog, itemnum);		tds := concat(ds, ' 0 ');		j := 0;		repeat			j := j + 1;		until ((tds[j] <= '9') and (tds[j] >= '0'));		tempgl := 0;		repeat			tempgl := 10 * tempgl + ord(tds[j]) - 48;			j := j + 1;		until ((tds[j] > '9') or (tds[j] < '0'));}				tempgl := EditTextInt(theDialog,itemNum,false);				if (tempgl < 0) or (tempgl > maxallowed) then			begin				NumToString(gl, ds);				SetDLOGText(theDialog, itemnum, ds, false);			end		else			begin				gl := tempgl;				NumToString(gl, ds);				SetDLOGText(theDialog, itemnum, ds, false);			end;	end;{-----------------------------------------------------------------------------}{Given querygains gains querylosses losses overall, calculates probability of observing fewer/asmany/more gains}{and fewer/asmany/more losses than qgB gains and qlB losses in the QDBlack area.}{Thus to make histogram showing probability for various numbers of gains in QDBlack area}{ given the user's specification of the number of losses in QDBlack, ask for: }{ ProbGainsLosses(ggg, querylossesBlk, false, true, false, fewerlosses, asmanylosses, morelosses)}{varying ggg from 0 to querygains to fill in the columns of the histogram}{and to make histogram showing probability for various numbers of losses in QDBlack area}{ given the user's specification of the number of gains in QDBlack, ask for: }{ ProbGainsLosses(querygainsBLK, lll, fewergains, asmanygains, moregains, false, true, false)}{varying lll from 0 to querylosses to fill in the columns of the histogram.}{To make scattergram showing prob. for various numbers of gains and losses in QDBlack area, ask for}{ ProbGainsLosses(ggg, lll, false, true, false, false, true, false)}{varying ggg from 0 to querygains and lll from 0 to querylosses to fill in the scattergram}	function ProbGainsLosses (qgb, qlb: integer; fewerg, asmanyg, moreg, fewerl, asmanyl, morel: boolean): double;		label			1;		var			irgains, irlosses: integer;			tot, totways, totwaysblack: storage;	begin		if exactcount then			begin				totways := multaddC(Getzero(querylosses, querygains) * oneancestral, Getzero(querygains, querylosses) * zeroancestral, 1);				if totways < 0 then					begin						totways := 0;						InstantError(149);						goto 1;					end;			end		else			begin {simulation}				totways := zeroancestral * samplesize0 + oneancestral * samplesize1;			end;		totwaysblack := 0;		if oneancestral = 1 then			totwaysBlack := totwaysBlack + GetBlackZero(1, querygains, querylosses, qgB, qlB);		if zeroancestral = 1 then			totwaysBlack := totwaysBlack + GetBlackZero(0, querygains, querylosses, qgB, qlB);		tot := 0;		for irgains := 0 to querygains do			for irlosses := 0 to querylosses do				if (((irgains < qgB) and fewerg) or ((irgains = qgB) and asmanyg) or ((irgains > qgB) and moreg)) then					if (((irlosses < qlB) and fewerl) or ((irlosses = qlB) and asmanyl) or ((irlosses > qlB) and morel)) then						begin							if oneancestral = 1 then								tot := tot + GetBlackZero(1, querygains, querylosses, irgains, irlosses);							if zeroancestral = 1 then								tot := tot + GetBlackZero(0, querygains, querylosses, irgains, irlosses);						end;1:		if (totways = 0) or (tot = 0) then			ProbGainsLosses := 0.0		else			ProbGainsLosses := tot / totways;	end;{-----------------------------------------------------------------------------}	procedure SaveProbToFile (disting: str255; N: Nptr);		label			1;		var			ig, il: integer;			theInfo: FInfo;			thefile: integer;			oldexists, db: BOOLEAN;			ds, writename: str255;			H: Handle;			dL: longint;			oldzero, oldone, ij: integer;			oldState: SignedByte;			Freply: StandardFileReply;{............}		procedure WriteEvenCheck (qN: Nptr);		begin			if NodeIsInternal(qN) then				begin					PutToken('(');					WriteEvenCheck(qN^.lf);					PutToken(',');					WriteEvenCheck(qN^.rt);					PutToken('):');				end;			PutToken(StringFromNUm(qN^.length1));		end;{............}	begin		oldexists := false;		ds := 'Correl.test results';		PutStandardFile('Save file of probabilities as:', 'Untitled Status', Freply);		ShowCursor;		if Freply.sfgood then			FSpCreateSaveFile(Freply.sfFile, oldexists, 'ttxt', 'TEXT')		else			Errorflag := true;		if errorflag then			goto 1;		StartWrite;		PutTokenReturn('Results from concentrated-changes correlation test');		PutTokenReturn(Maccladestamp);		PutTokenReturn(UserStamp(true, true, false));		PutTokenReturn(TimeStamp);		PutReturn;		PutTokenReturn(DataFileStamp);		PutTokenReturn(concat('Character traced: ', StringFromNum(i)));		PutTokenReturn(CurrentTreeStamp);		if N <> R then			begin				PutTokenReturn(concat('Number of taxa in clade: ', StringFromNUM(numtaxainclade)));				PutTokenReturn(concat('Clade includes taxa: ', TaxonName(LeftMostDescendant(N)^.name), ' through ', TaxonName(RightMostDescendant(N)^.name)));			end;		PutReturn;		putreturn;		if exactcount then			puttoken('Calculated by EXACT probability formula')		else			begin				PutToken('Calculated by SIMULATION of ');				if actual then					puttoken('actual changes')				else if firstres then					puttoken('MINSTATE-reconstructed changes')				else					puttoken('MAXSTATE-reconstructed changes');				PutReturn;				Puttoken(concat(' with total sample size ', stringfromnum(samplesize)));				putreturn;				if not actual then					begin						PutTokenReturn(concat('Initial state in simulation at basal node of clade chosen is ', stringfromnum(simulationancestor)));						PutToken('Compensation: ');						Puttoken(stringfromnum(compensation));					end;			end;		putreturn;		putreturn;		PutTokenReturn('----------------------------');		PutTokenReturn('Probabilities of observing various numbers of');		puttoken('gains and losses ');		puttoken(disting);		putReturn;		putToken(concat('given ', stringfromnum(querygains), ' gains and ', stringfromnum(querylosses), ' losses'));		if not exactcount and not actual then			puttoken(' reconstructed');		puttoken(' over whole clade,');		putReturn;{===}		oldzero := zeroancestral;		oldone := oneancestral;		for ij := 1 to 3 do			begin				PutReturn;				zeroancestral := ij mod 2;  {1,0,1}				oneancestral := ij div 2;  {0,1,1}				if zeroancestral = 1 then					begin						if oneancestral = 1 then							putToken('given either state 0 or 1')						else							putToken('given state 0');					end				else					putToken('given state 1');				if not exactcount and not actual then					puttoken(' reconstructed');				PutToken(' at ancestral node of clade:');				putreturn;				if not exactcount then					begin						Puttoken('Sample size: ');						if zeroancestral = 1 then							begin								if oneancestral = 1 then									Puttoken(stringfromnum(samplesize))								else									Puttoken(stringfromnum(samplesize0));							end						else							Puttoken(stringfromnum(samplesize1));						putreturn;					end;				puttoken(concat('Gains', chr(9), 'Losses'));				for il := 0 to querylosses do					begin						puttab;						puttoken(stringfromnum(il));					end;				PutReturn;				for ig := 0 to querygains do					begin						puttoken(stringfromnum(ig));						puttab;						for il := 0 to querylosses do							begin								puttab;								RealToString(probgainslosses(ig, il, false, true, false, false, true, false), ds, 10, 6, true);								puttoken(ds);							end;						putreturn;					end;			end;		zeroancestral := oldzero;		oneancestral := oldone;		if not exactcount then			begin				PutReturn;				PutTokenReturn('Report on total number of changes assigned to each node during simulation.');				PutTokenReturn('This can be used as a check that changes were assigned uniformly');				PutTokenReturn('(but note that root of clade receives no changes).');				WriteEvenCheck(N);				PutReturn;			end;{===}		EndWrite;		if errorflag then			goto 1;		if oldexists then			FSpExchangeFilesDeleteTemp(Freply.sfFile);1:	end;{-----------------------------------------------------------------------------}{This procedure shows dialog box giving results of calculations}	procedure AskForResults (var donestats: boolean; N: Nptr);		var			theDialog: DialogPtr;			tempP: WindowPtr;			localItemHit, j, ir, irgains, irlosses: integer;			ds, tds, disting: str255;			second: boolean;			prob, oldprob: double;			sse: longint;{................}		procedure CheckAskForResults;		begin			ItemCheckMark(theDialog, fewerlossesItem, fewerlosses);			ItemCheckMark(theDialog, asmanylossesItem, asmanylosses);			ItemCheckMark(theDialog, morelossesItem, morelosses);			ItemCheckMark(theDialog, fewergainsItem, fewergains);			ItemCheckMark(theDialog, asmanygainsItem, asmanygains);			ItemCheckMark(theDialog, moregainsItem, moregains);			ItemCheckMark(theDialog, ZeroancItem, (ZeroAncestral = 1) and (OneAncestral = 0));			ItemCheckMark(theDialog, OneancItem, (ZeroAncestral = 0) and (OneAncestral = 1));			ItemCheckMark(theDialog, eitherancItem, (ZeroAncestral = 1) and (OneAncestral = 1));			if not exactcount then				begin					if (ZeroAncestral = 1) and (OneAncestral = 0) then						begin							Numtostring(samplesize0, ds);							ds := concat('Sample size for 0 ancestral: ', ds);						end					else if (ZeroAncestral = 0) and (OneAncestral = 1) then						begin							Numtostring(samplesize1, ds);							ds := concat('Sample size for 1 ancestral: ', ds);						end					else						begin							Numtostring(samplesize, ds);							ds := concat('Sample size for either ancestral: ', ds);						end;					if not actual then						begin							numtostring(simulationancestor, tds);							ds := concat(ds, chr(13), 'State ', tds, ' assumed ancestral in simulations');						end;					SetDLOGText(theDialog, 26, ds, false)				end;		end;{................}	begin		StartDLOG(355, theDialog, tempP);		tds := 'on branches distinguished by';		if zeroblack then			begin				tds := concat(tds, ' state');				if oneblack then					tds := concat(tds, 's');				tds := concat(tds, ' 0');			end;		if equivblack then			begin				if zeroblack then					tds := concat(tds, ' or');				tds := concat(tds, ' equivocal');			end;		if oneblack then			begin				if zeroblack then					tds := concat(tds, ' or')				else if equivblack then					tds := concat(tds, ' or state')				else					tds := concat(tds, ' state');				tds := concat(tds, ' 1');			end;		ds := concat(tds, ' in character traced,');		disting := ds;		SetDLOGText(theDialog, distareaitem, ds, false);		ds := 'the probability of having';		if not exactcount & not actual then			if firstres then				ds := concat(ds, ' reconstructed using MINSTATE option')			else				ds := concat(ds, ' reconstructed using MAXSTATE option');		SetDlogText(theDialog, 20, ds, false);		SetDLOGText(theDialog, gainsBlackitem, '0', false);		SetDLOGText(theDialog, lossesBlackitem, '0', false);		SetDLOGText(theDialog, 26, '  ', false);		SetDLOGText(theDialog, gainsitem, StringFromNum(statedgains), false);		SetDLOGText(theDialog, lossesitem, StringFromNum(statedlosses), false);		if not actual then			begin				SetDLOGText(theDialog, 28, 'is reconstructed as ancestral,', false);				SetDLOGText(theDialog, 29, 'reconstructed,', false);			end;		querygains := statedgains;		querylosses := statedlosses;		OneAncestral := 1;		zeroAncestral := 1;{Note: here all boxes checked to present user with number that should be 1; if not}{then bug}		moregains := true;		asmanygains := true;		fewergains := true;		morelosses := true;		asmanylosses := true;		fewerlosses := true;		prob := ProbGainsLosses(0, 0, true, true, true, true, true, true);		oldprob := prob;		if (ZeroAncestral = 1) & (OneAncestral = 0) then			sse := samplesize0		else if ((ZeroAncestral = 0) & (OneAncestral = 1)) then			sse := samplesize1		else			sse := samplesize;		if ((prob > 1.1) | (prob < 0.9)) & (exactcount | (sse > 0)) then			InstantError(183);		RealToString(prob, ds, 10, 6, true);		SetDLOGText(theDialog, probitem, ds, false);		CheckAskForResults;		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			oldprob := prob;			ModalDialog(nil, localItemHit);			case localItemHit of				ZeroancItem: 					begin						OneAncestral := 0;						ZeroAncestral := 1;					end;				oneancItem: 					begin						OneAncestral := 1;						ZeroAncestral := 0;					end;				eitherancItem: 					begin						OneAncestral := 1;						ZeroAncestral := 1;					end;				moregainsItem: 					moregains := not moregains;				asmanygainsItem: 					asmanygains := not asmanygains;				fewergainsItem: 					fewergains := not fewergains;				morelossesItem: 					morelosses := not morelosses;				asmanylossesItem: 					asmanylosses := not asmanylosses;				fewerlossesItem: 					fewerlosses := not fewerlosses;				27: 					begin						SaveProbToFile(disting, N);						FrameButton(theDialog, 1);					end;				otherwise					;			end;			CheckAskForResults;			if exactcount then				begin					CheckGainsLosses(theDialog, gainsitem, querygains, maxgainslosses);					CheckGainsLosses(theDialog, lossesitem, querylosses, maxgainslosses);				end			else				begin					SetDLOGText(theDialog, gainsitem, StringFromNum(statedgains), false);   {set back to old number}					SetDLOGText(theDialog, lossesitem, StringFromNum(statedlosses), false);   {set back to old number}				end;			CheckGainsLosses(theDialog, gainsblackitem, querygainsBlk, maxgainslosses);			CheckGainsLosses(theDialog, lossesblackitem, querylossesBlk, maxgainslosses);{GetZero}			prob := ProbGainsLosses(querygainsBlk, querylossesBlk, fewergains, asmanygains, moregains, fewerlosses, asmanylosses, morelosses);			if oldprob <> prob then				begin					RealToString(prob, ds, 10, 6, true);					SetDLOGText(theDialog, probitem, ds, false);   {set back to old number}				end		until (localItemHit = Okitem);		EndDLOG(theDialog, tempP);		donestats := (localItemHit = Okitem);	end;{-----------------------------------------------------------------------------}	procedure CorrelInfo (theDialog: DialogPtr; itemNo: Integer);	begin		DrawResourceTEXT(theDialog, 7, 21282);		FrameButton(theDialog, 1);	end;{-----------------------------------------------------------------------------}	procedure AskForParameters;		label			1;		var			theDialog: DialogPtr;			box: RECT;			tdH: handle;			tempP: WindowPtr;			localItemHit: integer;			ds: str255;			UserItemUProcP: UniversalProcPtr;{............}		procedure CheckAskForParameters;		begin			ItemCheckMark(theDialog, zeroblackitem, zeroblack);			ItemCheckMark(theDialog, equivblackitem, equivblack);			ItemCheckMark(theDialog, oneblackitem, oneblack);			ItemCheckMark(theDialog, exactcountitem, exactcount);			ItemCheckMark(theDialog, simulitem, not exactcount);			ItemCheckMark(theDialog, actualitem, actual);			ItemCheckMark(theDialog, firstresitem, firstres);			ItemCheckMark(theDialog, lastresitem, lastres);			itemcheckmark(thedialog, 23, checkabortoften);			itemcheckmark(theDialog, comp0item, compensation = 0);			itemcheckmark(theDialog, comp1item, compensation = 1);			itemcheckmark(theDialog, comp2item, compensation = 2);			itemcheckmark(theDialog, comp3item, compensation = 3);			itemcheckmark(theDialog, samp0item, bywhichSampleSize = 0);			itemcheckmark(theDialog, samp1item, bywhichSampleSize = 1);			itemcheckmark(theDialog, samp01item, bywhichSampleSize = 2);			itemcheckmark(theDialog, ZeroAncSimitem, SimulationAncestor = 0);			itemcheckmark(theDialog, OneAncSimitem, SimulationAncestor = 1);		end;{.............}		procedure EnableDisableSimulationItems;			var				nena: boolean;		begin			NENA := not exactcount;			EnableDisableDLOGItem(theDialog, actualitem, NENA, false);			EnableDisableDLOGItem(theDialog, lastresitem, NENA, false);			EnableDisableDLOGItem(theDialog, firstresitem, NENA, false);			EnableDisableDLOGItem(theDialog, samp0item, NENA, false);			EnableDisableDLOGItem(theDialog, samp1item, NENA, false);			EnableDisableDLOGItem(theDialog, samp01item, NENA, false);			EnableDisableDLOGItem(theDialog, 23, exactcount, false);			NENA := not exactcount and not actual;			EnableDisableDLOGItem(theDialog, comp0item, NENA, false);			EnableDisableDLOGItem(theDialog, comp1item, NENA, false);			EnableDisableDLOGItem(theDialog, comp2item, NENA, false);			EnableDisableDLOGItem(theDialog, comp3item, NENA, false);			EnableDisableDLOGItem(theDialog, ZeroAncSimItem, NENA, false);			EnableDisableDLOGItem(theDialog, OneAncSimItem, NENA, false);			if exactcount or actual then				begin					DimBox(GetDLOGItemBox(theDialog, 28));					DimBox(GetDLOGItemBox(theDialog, 29));				end			else				begin					InvalidateWindowRect(myGetWindowPtrForDialog(theDialog),GetDLOGItemBox(theDialog, 28),false);					InvalidateWindowRect(myGetWindowPtrForDialog(theDialog),GetDLOGItemBox(theDialog, 29),false);				end;		end;{.............}	begin		StartDLOG(356, theDialog, tempP);		box := GetDLOGItemBox(theDialog, 7);UserItemUProcP := MyNewUserItemUPP(@correlinfo);  tdH := Handle(UserItemUProcP);		SetDialogItem(theDialog, 7, UserItem, tdH, box);		bywhichsamplesize := 2;		SetDLOGText(theDialog, statedgainsitem, StringFromNum(statedgains), false);		SetDLOGText(theDialog, statedlossesitem, StringFromNum(statedlosses), false);		SetDLOGText(theDialog, samplesizeitem, StringFromNum(maxsample), false);		EnableDisableSimulationItems;		CheckAskForParameters;		myShowDialog(theDialog);		SetCursorToArrow;		genericSetPort(myGetWindowPtrForDialog(theDialog));		repeat			ModalDialog(nil, localItemHit);			case localItemHit of				statedgainsitem: 					CheckGainsLosses(theDialog, statedgainsitem, statedgains, maxgains);				statedlossesitem: 					CheckGainsLosses(theDialog, statedlossesitem, statedlosses, maxlosses);				exactcountitem, simulitem: 					begin						exactcount := (localItemHit = exactcountitem);						EnableDisableSimulationItems;					end;				ZeroBlackitem: 					zeroblack := not zeroblack;				equivBlackitem: 					equivblack := not equivblack;				oneBlackitem: 					oneblack := not oneblack;				samplesizeitem: 					CheckGainsLosses(theDialog, samplesizeitem, maxsample, 1000000);				cancel356item: 					abort := true;				actualitem, firstresitem, lastresitem: 					begin						actual := (localItemHit = actualitem);						firstres := (localItemHit = firstresitem);						lastres := (localItemHit = lastresitem);						EnableDisableSimulationItems;					end;				comp0item, comp1item, comp2item, comp3item: 					compensation := localItemHit - comp0item;				samp0item, samp1item, samp01item: 					bywhichsamplesize := localItemHit - samp0item;				ZeroAncSimitem, OneAncSimitem: 					simulationAncestor := localItemHit - ZeroAncSimitem;				seeditem: 					GetRandomSeed;				23: 					checkabortoften := not checkabortoften;{ 32: SetDialogValuesAsDefaults(theDialog, correlationid, 0, 0);}				otherwise					;			end;			CheckAskForParameters;		until (localItemHit = OKitem) or (localItemHit = cancel356item);MyDisposeUserItemUPP(UserItemUProcP);		EndDLOG(theDialog, tempP);		if statedgains < statedlosses then			maxgainslosses := statedlosses		else			maxgainslosses := statedgains;		if not (localItemHit = cancel356item) then			begin		{Here check to see likely limits of longint overflow; warn user if seems likely to fail}				if exactcount & (((maxgainslosses >= 3) & (numtaxainclade > 80)) | ((maxgainslosses >= 4) & (numtaxainclade > 36)) | ((maxgainslosses >= 5) & (numtaxainclade > 24))) then					begin						if not Cwarning('Calculations appear likely to overflow the limits for exact calculations.  Do you want to proceed regardless?', 'Proceed', 'Cancel') then							begin								abort := true;								goto 1;							end;					end;				if (statedgains + statedlosses = 0) then					begin						InstantError(184);						abort := true;						goto 1;					end				else if (statedgains + statedlosses > numtaxainclade * 2 - 2) then					begin						InstantError(185);						abort := true;						goto 1;					end;			end;		if localItemHit = 1 then			oldrandseed := OurRandSeed;1:	end;{-----------------------------------------------------------------------------}{-----------------------------------------------------------------------------}	procedure DoCharCorrel; {N : Nptr}		var			donestats: boolean;			tport: WindowPtr;			ds: str255;	begin		NewRandomSeed;		doneStats := false;		genericGetPort(tport);{exactcount := true;}		SetCursorToArrow;		abort := false;		numtaxainclade := SizeOfClade(N, true);		if not (traceshown = traceDiscrete) then			begin				abort := true;				InstantError(150);			end		else if charmaxstOBS(i) > 1 then			begin				abort := true;				InstantError(151);			end		else if Anynulls(N) then			begin				abort := true;				InstantError(305);			end		else if AnyFixanc(N) then			begin				abort := true;				InstantError(186);			end;		if not abort then			AskForParameters;		if not abort then			begin				incr1 := (maxgainslosses + 1) * (maxgainslosses + 1) * (maxgainslosses + 1) * storsize;				incr2 := (maxgainslosses + 1) * (maxgainslosses + 1) * storsize;				incr3 := (maxgainslosses + 1) * storsize;				incr4 := storsize;				zerosize := storsize * (maxgainslosses + 1) * (maxgainslosses + 1);				blackzerosize := zerosize * (maxgainslosses + 1) * (maxgainslosses + 1);				if exactcount then					begin						pNMbz := NewPtr(blackzerosize);						pNMz := NewPtr(zerosize);					end				else					begin						pNMs0 := NewPtr(zerosize);						pNMs1 := NewPtr(zerosize);					end;				repeat					setcursor(clockCursor);					if exactcount then						begin							if not CountGainsLosses(N) then								donestats := true;						end					else						SimulateGainsLosses(N);					if not donestats then						begin							SetCursorToArrow;							AskForResults(donestats, N);						end;				until donestats;				if exactcount then					begin						ZapPointer(pNMz);						ZapPointer(pNMbz);					end				else					begin						ZapPointer(pNMs0);						ZapPointer(pNMs1);					end;			end;		genericSetPort(tport);	end;end.