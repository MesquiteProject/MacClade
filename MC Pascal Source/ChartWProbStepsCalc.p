unit ChartWProbStepsCalc;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, BoxUtil, CharUtil, StrUtil, ChartWUtil, ChartWWrite, ProbReconstruct, Thermos, Prohibitions, TreeUtil, Count, RandomTree, TreeCycle, TaxonCHUtil;	procedure CalcProbStepsChart;{еееееееееееееееееееееее}implementation {е$S ChartWProbStepsCalc}{====================================================================}{$IFC PROBSTEPCHART}	procedure CalcProbStepsChart;		var			maxs, ss, aa, pp: integer;			subtotal: double;			nnum: integer;			ds: str255;			min1, max1, min2, max2: single;{  stepsarray = array[0..100, 0..2, 0..1] of real; }{}		procedure InCalcProbsSteps (N: Nptr);			var				s, a, b, rs: integer;				P, lfP, rtP: stepsptr;		begin			N^.bset2 := NewPtr(SizeOf(stepsarray));			P := stepsptr(N^.bset2);			if NodeIsTerminal(N) then				begin {initialize for terminals}					for s := 0 to maxs do						for a := 0 to 2 do							for b := 0 to 1 do								P^[s, a, b] := 0;					P^[0, 0, 0] := 1;					P^[0, 1, 1] := 1;				end			else				begin					InCalcProbsSteps(N^.lf);					InCalcProbsSteps(N^.rt);					lfP := stepsptr(N^.lf^.bset2);					rtP := stepsptr(N^.rt^.bset2);					for s := 0 to maxs do						begin{N's state reconstructed [0] or [1]}							for a := 0 to 1 do  {[0] or [1] at N}								for b := 0 to 1 do  {0 or 1 true states at N}									begin										P^[s, a, b] := 0; {initialize to 0}										for rs := 0 to s do  {distributions of s steps on left and right}											begin							{ case 1: [a] at both left and right}												P^[s, a, b] := P^[s, a, b] + ((lfP^[rs, a, 0] * ProbChangeBranch(N^.lf, b, 0) + lfP^[rs, a, 1] * ProbChangeBranch(N^.lf, b, 1)) * (rtP^[s - rs, a, 0] * ProbChangeBranch(N^.rt, b, 0) + rtP^[s - rs, a, 1] * ProbChangeBranch(N^.rt, b, 1)));							{ case 2: [01] at left and [a] at right}												P^[s, a, b] := P^[s, a, b] + ((lfP^[rs, 2, 0] * ProbChangeBranch(N^.lf, b, 0) + lfP^[rs, 2, 1] * ProbChangeBranch(N^.lf, b, 1)) * (rtP^[s - rs, a, 0] * ProbChangeBranch(N^.rt, b, 0) + rtP^[s - rs, a, 1] * ProbChangeBranch(N^.rt, b, 1)));							{ case 3: [a] at left and [01] at right}												P^[s, a, b] := P^[s, a, b] + ((lfP^[rs, a, 0] * ProbChangeBranch(N^.lf, b, 0) + lfP^[rs, a, 1] * ProbChangeBranch(N^.lf, b, 1)) * (rtP^[s - rs, 2, 0] * ProbChangeBranch(N^.rt, b, 0) + rtP^[s - rs, 2, 1] * ProbChangeBranch(N^.rt, b, 1)));											end;									end;{N's state reconstructed [01]; i.e. a=2}							for b := 0 to 1 do								begin									P^[s, 2, b] := 0;									for rs := 0 to s do  { case 1: [01] at both left and right}										P^[s, 2, b] := P^[s, 2, b] + ((lfP^[rs, 2, 0] * ProbChangeBranch(N^.lf, b, 0) + lfP^[rs, 2, 1] * ProbChangeBranch(N^.lf, b, 1)) * (rtP^[s - rs, 2, 0] * ProbChangeBranch(N^.rt, b, 0) + rtP^[s - rs, 2, 1] * ProbChangeBranch(N^.rt, b, 1)));									for rs := 0 to s - 1 do										begin											P^[s, 2, b] := P^[s, 2, b] + ((lfP^[rs, 0, 0] * ProbChangeBranch(N^.lf, b, 0) + lfP^[rs, 0, 1] * ProbChangeBranch(N^.lf, b, 1)) * (rtP^[s - rs - 1, 1, 0] * ProbChangeBranch(N^.rt, b, 0) + rtP^[s - rs - 1, 1, 1] * ProbChangeBranch(N^.rt, b, 1)));											P^[s, 2, b] := P^[s, 2, b] + ((lfP^[rs, 1, 0] * ProbChangeBranch(N^.lf, b, 0) + lfP^[rs, 1, 1] * ProbChangeBranch(N^.lf, b, 1)) * (rtP^[s - rs - 1, 0, 0] * ProbChangeBranch(N^.rt, b, 0) + rtP^[s - rs - 1, 0, 1] * ProbChangeBranch(N^.rt, b, 1)));										end;								end;						end;				end;			AutoThermocursor(nnum, 0, numtaxain * 2 - 1);		end;		procedure CleanMemory2 (N: Nptr);		begin			DisposePtr(N^.bset2);			if not NodeIsTerminal(N) then				begin					CleanMemory2(N^.lf);					CleanMemory2(N^.rt);				end;		end;		procedure CalcMinMaxProbSteps;			var				ss, aa: integer;		begin			min1 := 0;			max1 := -100000;			min2 := 0;			max2 := -100000;			for ss := 0 to maxs do				if probstepsvalues[ss] > 0 then					begin						max1 := ss;						if probstepsvalues[ss] > max2 then							max2 := probstepsvalues[ss];					end;			if max2 < 0 then				max2 := 0;			if max1 < 0 then				max1 := 0;		end;{............................................................................}	begin		maxs := Numtaxain div 2;		if nullson or ancon then			begin				InstantInfo('Can''t calculate probability distribution for steps if tree has polytomies or some observed taxa are fixed as ancestors');			end		else if maxs > maxtaxasteps then			begin				numtostring(maxtaxasteps * 2, ds);				InstantInfo(concat('Can''t calculate probability distribution for steps since more than ', ds, ' taxa in tree'))			end		else			begin				SetCursor(clockCursor);				if seglistenProb then					New(probchgsegs);				if seglistenProb then					CalculateSegmentProbs;				nnum := 0;				InCalcProbsSteps(R);{maxs= maximum conceivable number of steps = numtaxain div 2  (local to procedure ) }{max1 = maximum value of s needed for graph ( max s with prob > 0; local to procedure )}{max2 = maximum value of prob ( s ) in graph ( local to procedure ) }				mean := 0;				for ss := 0 to maxs do					begin						subtotal := 0;						for aa := 0 to 2 do							subtotal := subtotal + stepsptr(R^.bset2)^[ss, aa, 0];						probstepsvalues[ss] := subtotal;   {this contains the probability of ss steps}						mean := mean + ss * subtotal;					end;				CleanMemory2(R);				CalcMinMaxProbSteps;				if ChartCalcToText then					begin						WriteCalcHeadings(-1);						ChartWriteString('For binary character, with probability of changes being');						ChartWriteChar(chr(13));						ChartWriteString('0->0: ');						RealToString(probchangeRec[0, 0], ds, 10, 4, false);						ChartWriteString(ds);						ChartWriteChar(chr(13));						ChartWriteString('0->1: ');						RealToString(probchangeRec[0, 1], ds, 10, 4, false);						ChartWriteString(ds);						ChartWriteChar(chr(13));						ChartWriteString('1->0: ');						RealToString(probchangeRec[1, 0], ds, 10, 4, false);						ChartWriteString(ds);						ChartWriteChar(chr(13));						ChartWriteString('1->1: ');						RealToString(probchangeRec[1, 1], ds, 10, 4, false);						ChartWriteString(ds);						ChartWriteChar(chr(13));						ChartWriteChar(chr(13));						ChartWriteString('Steps');						ChartWriteChar(chr(9));						ChartWriteString('Probability');						ChartWriteChar(chr(13));						for ss := 0 to maxs do							begin								ChartWriteInteger(ss);								ChartWriteChar(chr(9));								ChartWriteReal(probstepsvalues[ss], 8, 7);  								ChartWriteChar(chr(13));							end;					end;				minChartLinearCat := 0;				AddLinearChart(CLkind, maxS + 1, false, minChartLinearCat);{now assign chart values}				maxChartLinearcat := maxS;				for ss := 0 to maxs do					SetChartLinearData(CLkind, ss, RoundValue(DataInflation * probstepsvalues[ss]));				SetCursorToArrow;				if seglistenProb then					Dispose(probchgsegs);			end;	end;{$ENDC}end.