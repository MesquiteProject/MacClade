unit DisplayMenu; {еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, 		TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, 		ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, ChartWindow, 		CharUtil, SymbolsNames, WriteUtil, TraceAllChangesOptions, MCFonts, MenuUtil, TreeDrawer, 		TreeMakerUtil, IncExcTaxa, Coloring, Settings, SymbolsNames, StatesWindow, 		TaxonCHUtil, TreeUtil, DrawSpread, SpreadUtil, Footnote, LinkUtil, Legends, 		MCWindows, TreeGet, ReadMisc, TreeMaker, TypeDLOG, Shading, ClickInInfoWindow, MouseInTree;	procedure DoColorCodPosMenu (ItemNo: integer);	procedure DoColorPartitionsMenu (ItemNo: integer);	procedure DoAATranslateMenu (ItemNo: integer);	procedure DoWindowsMenu (ItemNo: integer);	procedure DoColorCellsMenu (ItemNo: integer);	procedure DoShowMenu (ItemNo: integer);	procedure DoConsensusTaxSetMenu (ItemNo: Integer);	procedure DoShadeCharSetMenu (ItemNo: Integer);	procedure DoDataMatrixStyleMenu(ItemNo: integer);	procedure DoColumnWidthMenu (ItemNo: integer);	procedure DoDisplayMenu (ItemNo: integer); {еееееееееееееееееееееее}implementation  {е$S DisplayMenu} {-----------------------------------------------------------------------------}	procedure CheckEditTextSingle (theDialog: DialogPtr; num: integer; illegal: wstype; replacechar: char; isMissing: boolean); {check legality of edit text items in symbols dialog box; specifically for single-character entries}		var			j: integer;			ds: str255;			newC, oldC: char;			bad: boolean;	begin		ds := GetEditText(theDialog, num);		if ds <> '' then			newC := ds[1];		bad := (ds <> '') & ((newC in illegal) | (length(ds) > 1));		if not bad then			begin				bad := pos(newC, symbols) > 0;				if molecular & not bad then   {v3.04: check to see if in protein symbols too - otherwise screws up}												{genetic code}					begin						if nucleotides & isMissing & ((newC = 'n') | (newC = 'N')) then   {v3.05: it's OK}						else							bad := CharIsMolecularChar(newC);					end;			end;		if bad then			begin				Beep;				SetDLOGText(theDialog, num, replacechar, true);			end;	end; {-----------------------------------------------------------------------------}	function SetASymbol (ds: str255; blankok: boolean; oldchar: char): char;	begin		if ds = '' then			if blankok then				SetASymbol := ' '			else				SetASymbol := oldchar		else			SetASymbol := ds[1];	end; {-----------------------------------------------------------------------------}	procedure GetOtherSymbols (theDialog: DialogPtr; oldmissing, oldgap: char);	begin		missing := SetASymbol(GetEditText(theDialog, 3), true, ' ');		if (missing <> oldmissing) and (fillchar = oldmissing) then			fillchar := missing;		gap := SetASymbol(GetEditText(theDialog, 6), false, oldgap);		andsep := SetASymbol(GetEditText(theDialog, 4), true, ' ');		orsep := SetASymbol(GetEditText(theDialog, 5), true, ' ');	end; {-----------------------------------------------------------------------------}	procedure SymbolsDLOG;		label			1;		var			theDialog: DialogPtr;			j, num: integer;			tempP: WindowPtr;			tmissing, tandsep, torsep, tgap: char;			localItemHit: integer;	begin		tmissing := missing;		tgap := gap;		tandsep := andsep;		torsep := orsep;		StartDLOG(27065, theDialog, tempP);		myShowDialog(theDialog);		SetDLOGText(theDialog, 3, missing, false);		SetDLOGText(theDialog, 4, andsep, false);		SetDLOGText(theDialog, 5, orsep, false);		if gap <> UndefinedGap then			SetDLOGText(theDialog, 6, gap, false); {||||||||||||||||||||||||||||||||||||||||||}1:		FrameButton(theDialog, 1);		repeat			missing := SetASymbol(GetEditText(theDialog, 3), true, ' ');			gap := SetASymbol(GetEditText(theDialog, 6), false, tgap);			andsep := SetASymbol(GetEditText(theDialog, 4), true, ' ');			orsep := SetASymbol(GetEditText(theDialog, 5), true, ' ');			ModalDialog(nil, localItemHit);			case localItemHit of				1: {check incase they hit the number etc DLOG and that conflicts}					begin						CheckEditTextSingle(theDialog, 3, illegalSymbols, missing,  true);						CheckEditTextSingle(theDialog, 4, [], andsep,  false);						CheckEditTextSingle(theDialog, 5, [], orsep,  false);						if tgap <> UndefinedGap then							CheckEditTextSingle(theDialog, 6, [' '] + illegalSymbols, tgap,  false)						else							CheckEditTextSingle(theDialog, 6, [' '] + illegalSymbols, ' ',  false);					end;				3:    {missing}					CheckEditTextSingle(theDialog, 3, [orsep, gap, andsep] + illegalSymbols, missing,  true);				4:     {and separator}					CheckEditTextSingle(theDialog, 4, [orsep, missing, gap], andsep,  false);				5:      {or separator}					CheckEditTextSingle(theDialog, 5, [missing, gap, andsep], orsep,  false);				6:      {and gap}					if gap <> UndefinedGap then						CheckEditTextSingle(theDialog, 6, [orsep, missing, andsep, ' '] + illegalSymbols, gap,  false)					else						CheckEditTextSingle(theDialog, 6, [orsep, missing, gap, andsep, ' '] + illegalSymbols, tgap,  false);				otherwise					if  (localItemHit = 11)  then						begin							GetOtherSymbols(theDialog, tmissing, tgap);							SetDialogValuesAsDefaults(theDialog, othersymbolsid, 0, 0)							{		GetSymbolsFromDLOG(theDialog, tsymbols);									SetDialogValuesAsDefaults(theDialog, symbolsid, othersymbolsid, 0);}						end;			end;		until (localItemHit in [1, 2]); {||||||||||||||||||||||||||||||||||||||||||}		if localItemHit = 1 then			begin				if StateNamesHaveSeparators then					goto 1;				GetOtherSymbols(theDialog, tmissing, tgap);				EndDLOG(theDialog, tempP);				if (missing <> tmissing) or (gap <> tgap) or (tandsep <> andsep) or (torsep <> orsep) then					begin						EraseRect(WindowPortRect(editorWindow));						InvalidateWindowRect(editorWindow,WindowPortRect(editorWindow),false);						if editorSelected and SingleCell then							FillsTE(editorCellTE, CellString);						datachanged := true;					end;				CheckStateNamesAreSymbols;			end		else if localItemHit = 2 then			begin				EndDLOG(theDialog, tempP);				missing := tmissing;				gap := tgap;				andsep := tandsep;				orsep := torsep;			end;	end; {$IFC SQUAREBRANCHES} {-----------------------------------------------------------------------------}	procedure InvertCurrentTreeShape (theDialog: DialogPtr);	begin		if squareBranches then			if (traceshown = traceAllChanges) & showbranchlengths then				InvertDLOGItem(theDialog, 13)			else				InvertDLOGitem(theDialog, 3)		else			InvertDLOGitem(theDialog, 9);	end;{-----------------------------------------------------------------------------}	procedure WriteTreeShape (thedialog: DialogPtr);		var			ds: str255;			oldfont, oldsize: integer;			box: rect;	begin		if not squarebranches then			ds := '(angled branches)'		else if showbranchlengths & (traceshown = traceAllChanges) then			ds := '(branch lengths proportional to changes)'   {note doesn't specify, as user may change later}{$IFC FALSE}			if branchlengthsweighted then				ds := '(branch lengths proportional to weighted amount of change)'			else				ds := '(branch lengths proportional to number of changes)' {$ENDC}		else			ds := '(square branches)';		oldfont := QDThePortTextFont;		oldsize := QDThePortTextSize;		textfont(kFontIDGeneva);		textsize(9);		box := GetDLOGITemBox(theDialog, 16);		EraseRect(box);		TETextBox(Pointer(ord4(@ds) + 1), length(ds), box, teJustCenter);		textfont(oldfont);		textsize(oldsize);	end; {-----------------------------------------------------------------------------}	procedure ShapeAndDisplayUser (theDialog: DialogPtr; itemNo: Integer);	begin		FrameButton(theDialog, 1);		InvertCurrentTreeShape(theDialog);		WriteTreeShape(theDialog);		if not (traceshown = traceAllChanges) then			DimBox(GetDLOGITemBox(theDialog, 13));	end; {-----------------------------------------------------------------------------}	procedure SetTreeScaleVertToOne (thedialog: DialogPtr);	begin		treescalevert := 1.0;		SetDLOGText(theDialog, 10, '1.0', false);	end; {-----------------------------------------------------------------------------}	procedure ShapeAndSizeDLOG;		label			1;		var			theDialog: DialogPtr;			tempP: WindowPtr;			oldcenterSquareBranches, oldSquareBranches, oldShowBranchLengths: boolean;			oldCondensedBranches: boolean;			oldtreeScale, oldTreeScaleVert: single;			ds: str255;			localItemHit: integer;			box: rect;			H: Handle;UserItemUProcP: UniversalProcPtr; {.....}		procedure CheckSizeAndShape;		begin			ItemCheckMark(theDialog, 14, centerSquareBranches);			ItemCheckMark(theDialog, 17, condensedBranches);			EnableDisableDLOGItem(theDialog, 14, squareBranches, false);			EnableDisableDLOGItem(theDialog, 17, squareBranches & not showBranchLengths, false);		end; {.....}		procedure GrabTreeScale;		begin			ds := GetEditText(theDialog, 4);			if (ds = '') or (ds = ' ') then				treeScale := 1.0			else				begin					treeScale := TokenToReal(ds);					if treeScale <= 0.1 then						begin							treeScale := 1.0;							SetDLOGText(theDialog, 4, '1.0', true);							Beep;							LocalItemHit := notInDialog;						end;				end;			ds := GetEditText(theDialog, 10);			if (ds = '') or (ds = ' ') then				treescaleVert := 1.0			else				begin					treescaleVert := TokenToReal(ds);					if (treescaleVert < 1.0) or (treescaleVert > 5.0) then {v3.04: added 5.0}						begin							if squarebranches then								begin									InstantError(393);									LocalItemHit := notInDialog;								end							else								Beep;							treescaleVert := 1.0;							SetDLOGText(theDialog, 10, '1.0', true);						end;				end;		end; {.....}	begin		oldcenterSquareBranches := centerSquareBranches;		oldtreescale := treeScale;		oldTreeScaleVert := treescaleVert;		oldShowBranchLengths := showBranchLengths;		oldcondensedBranches := condensedBranches;		oldsquareBranches := squareBranches;		StartDLOG(141, theDialog, tempP);UserItemUProcP := MyNewUserItemUPP(@ShapeAndDisplayUser);  H := Handle(UserItemUProcP);		SetRect(box, 0, 0, 10, 10);		SetDialogItem(theDialog, 15, UserItem, H, box);		RealToString(treeScale, ds, 10000, 1, false);		SetDLOGText(theDialog, 4, ds, true);		RealToString(treescaleVert, ds, 10000, 1, false);		if squareBranches & showbranchlengths & (traceshown = traceAllChanges) then			SetTreeScaleVertToOne(theDialog)		else			SetDLOGText(theDialog, 10, ds, true);		myShowDialog(theDialog);		CheckSizeAndShape;1:		repeat			ModalDialog(nil, localItemHit);			case localItemHit of				3: 					if not (squarebranches & not showbranchlengths) then						begin							InvertCurrentTreeShape(theDialog);							squareBranches := true;							if (traceshown = traceAllChanges) then								showbranchlengths := false;							InvertCurrentTreeShape(theDialog);							WriteTreeShape(theDialog);						end;				9: 					if squarebranches then						begin							InvertCurrentTreeShape(theDialog);							squareBranches := false;							if (traceshown = traceAllChanges) then								showbranchlengths := false;							InvertCurrentTreeShape(theDialog);							WriteTreeShape(theDialog);						end;				10: 					if squareBranches & showbranchlengths & (traceshown = traceAllChanges) then						begin							SetTreeScaleVertToOne(theDialog);							InstantError(404); {v3.04}						end;				13: 					if (traceshown = traceAllChanges) then						if not (squarebranches & showbranchlengths) then							begin								InvertCurrentTreeShape(theDialog);								squareBranches := true;								showbranchlengths := true;								if squareBranches & showbranchlengths then									SetTreeScaleVertToOne(theDialog);								InvertCurrentTreeShape(theDialog);								WriteTreeShape(theDialog);							end;				7: 					begin						GrabTreeScale;						SetDialogValuesAsDefaults(theDialog, treeShapeid, 0, 0);					end;				14: centerSquareBranches := not centerSquareBranches;				17: condensedBranches := not condensedBranches;				otherwise					;			end;			CheckSizeAndShape;		until localItemHit in [1, 2];		if (localItemHit = 1) then			begin				GrabTreeScale;				if localItemHit = notInDialog then					goto 1;			end;MyDisposeUserItemUPP(UserItemUProcP);		EndDLOG(theDialog, tempP);		if localItemHit = 2 then			begin				squareBranches := oldSquareBranches;				condensedBranches := oldcondensedBranches;				treescaleVert := oldTreeScaleVert;				treeScale := oldTreeScale;				centerSquareBranches := oldCenterSquareBranches;				ShowBranchLengths := oldShowBranchLengths;			end		else if (((centerSquareBranches <> oldCenterSquareBranches) | (condensedBranches <> oldcondensedBranches)) & squareBranches) | (squareBranches <> oldSquareBranches) | (oldtreeScale <> treeScale) | (oldtreeScaleVert <> treescaleVert) | (showbranchlengths <> oldshowbranchlengths) then			begin {$IFC FALSE}				if (squareBranches <> oldSquareBranches) & not ((traceshown = traceAllChanges) & laser^.printbranchlengths) & (laser^.treeshape[slanttree] or laser^.treeshape[squaretree]) then {note that shouldn't change this if printbranchlengths and (traceshown = traceAllChanges) is on} {and only change if squaretree or slanttree}					begin						laser^.treeshape[slanttree] := not squareBranches;						laser^.treeshape[squaretree] := squareBranches;						laser^.square := squareBranches;					end; {$ENDC}{$IFC FALSE}				if not squarebranches & (traceshown = traceAllChanges) & showbranchlengths then					showbranchlengths := false;{$ENDC}				if (oldtreeScale <> treeScale) or (oldtreeScaleVert <> treescaleVert) or (condensedBranches <> oldcondensedBranches) then					begin						TWOrigin.h := 0;						TWOrigin.v := 0;						SetDrawTWRControls;					end;				godraw := true;				dirtyfile := true;			end;	end; {$ENDC} {-----------------------------------------------------------------------------}	procedure MatchDLOG;		const			matchonitem = 3;			matchcharitem = 4;			dontmatchitem = 5;		var			theDialog: DialogPtr;			tmatchchar: char;			tempP: WindowPtr;			tmatchcharon: boolean;			ds: str255;			localItemHit: integer; {........}		procedure CheckMatchCharSingle (theDialog: DialogPtr; num: integer; illegal: wstype; replacechar: char); {check legality of edit text item matchchar dialog box; specifically for single-character entries}			var				ds: str255;				bad: boolean;		begin			ds := GetEditText(theDialog, num);			bad := (ds <> '') & ((ds[1] in illegal) | (ds[1] in illegalSymbols) | (pos(ds[1], symbols) > 0) | (length(ds) > 1));			if bad then				begin					Beep;					SetDLOGText(theDialog, num, replacechar, true);				end;		end; {........}		procedure CheckMatchCharDLOG;		begin			ItemCheckMark(theDialog, matchonitem, matchcharon);			ItemCheckMark(theDialog, dontmatchitem, not matchcharon);			CheckMatchCharSingle(theDialog, matchcharitem, [missing, gap, andsep, orsep, ' '], matchchar);		end; {........}		procedure GrabMatchchar;		begin			ds := GetEditText(theDialog, matchcharitem);			if (ds = '') or (ds = ' ') then				ds := '.';			matchchar := ds[1];		end; {........}	begin		tmatchcharon := matchcharon;		tmatchchar := matchchar;{$IFC FALSE}		if matchchar = notASymbol then			begin				if (gap <> '.') & (missing <> '.') & not CharInSymbols('.', false) then					matchchar := '.'				else					SetSymbolToVacant(matchchar, [gap, missing]);			end;{$ENDC}		StartDLOG(334, theDialog, tempP);		SetDLOGText(theDialog, matchcharitem, matchchar, true);		CheckmatchCharDLOG;		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			case localItemHit of				matchcharItem, matchonitem, 7: 					matchcharon := true;				dontmatchitem: 					matchcharon := false;				8: 					begin						GrabMatchchar;						SetDialogValuesAsDefaults(theDialog, matchCharid, 0, 0);					end;				otherwise					;			end;			CheckmatchCharDLOG;		until localItemHit in [1, 2];		if (localItemHit = 1) then			GrabMatchchar;		EndDLOG(theDialog, tempP);		if localItemHit = 2 then			begin				matchchar := tmatchchar;				matchcharon := tmatchcharon;			end		else if (matchcharon <> tmatchcharon) or (matchchar <> tmatchchar) then			InvalidateWindow(editorWindow, true);	end; {-----------------------------------------------------------------------------}	procedure CheckTipLabels (theDialog: DialogPtr; whichradio: integer);	begin		ItemCheckMark(theDialog, 3, whichradio = 3);		ItemCheckMark(theDialog, 4, whichradio = 4);		ItemCheckMark(theDialog, 5, whichradio = 5);	end; {-----------------------------------------------------------------------------}	procedure TipLabelsDLOG;		var			theDialog: DialogPtr;			j: integer;			oldtiplabel: integer;			tempP: WindowPtr;			whichradio: integer;			box: rect;			localItemHit: integer;			mleft, mtop: integer;			oldFonts: fontset;	begin		StartDLOG(557, theDialog, tempP);		oldtiplabel := tipLabel;		myShowDialog(theDialog);		if not (traceshown = traceDiscrete) then			EnableDisableDLOGItem(theDialog, 4, false, false);		if tiplabel = tipTaxa then			whichradio := 3		else if (tiplabel = tipState) then			whichradio := 4		else if (tiplabel = tipTaxNum) then			whichradio := 5;		CheckTipLabels(theDialog, whichradio);		repeatModalDialog(nil, localItemHit);			if localItemHit in [3, 4, 5] then				whichradio := localItemHit			else if localItemHit = 7 then				begin					if whichradio = 3 then						tiplabel := TipTaxa					else if whichradio = 4 then						tiplabel := tipState					else if whichradio = 5 then						tiplabel := TipTaxNum;					SetDialogValuesAsDefaults(theDialog, tipLabelid, 0, 0);				end;			CheckTipLabels(theDialog, whichradio);		until (localItemHit in [1, 2]);		EndDLOG(theDialog, tempP);		if localItemHit = 1 then			begin				oldtiplabel := tiplabel;				if whichradio = 3 then					tiplabel := TipTaxa				else if whichradio = 4 then					tiplabel := tipState				else if whichradio = 5 then					tiplabel := TipTaxNum;				InvalTaxonNames;{CalcTaxonHeight;}				SetDrawTWRControls;				godraw := true;			end		else			tiplabel := oldtipLabel;	end; {-----------------------------------------------------------------------------}	procedure TipLabelsDLOG2;		var			theDialog: DialogPtr;			j: integer;			oldtiplabel: integer;			tempP: WindowPtr;			whichradio: integer;			tempH: Handle;			box: rect;			localItemHit: integer;			mleft, mtop: integer;			oldFonts: fontset;UserItemUProcP: UniversalProcPtr;DLOGFilterUPP: UniversalProcPtr;	begin		oldFonts.face := treetaxastyle;		oldFonts.font := treetaxafont;		oldFonts.size := treetaxafontsize;		dlogFonts.face := treetaxastyle;		dlogFonts.font := treetaxafont;		dlogFonts.size := treetaxafontsize;		StartDLOG(557, theDialog, tempP);UserItemUProcP := MyNewUserItemUPP(@ChooseFontUser);  tempH := Handle(UserItemUProcP);		box := GetDLOGItemBox(theDialog, 8);		mleft := box.left;		mtop := box.top;		SetDialogItem(theDialog, 8, UserItem, tempH, box);		myShowDialog(theDialog);		if not (traceshown = traceDiscrete) then			EnableDisableDLOGItem(theDialog, 4, false, false);		if tiplabel = tipTaxa then			whichradio := 3		else if (tiplabel = tipState) then			whichradio := 4		else if (tiplabel = tipTaxNum) then			whichradio := 5;		SetRect(FontFontBox, mleft, mtop, mleft + 80, mtop + FontHeight);		SetRect(FontSizeBox, mleft, mtop + 29, mleft + 80, mtop + 29 + FontHeight);		SetRect(FontFaceBox, mleft, mtop + 58, mleft + 80, mtop + 58 + FontHeight);		FixLaserFontMenus(dlogFonts);		myEnableItem(StyleMHdl, 0);   {stick this here, because if in editor, this will be disabled}		CheckTipLabels(theDialog, whichradio);DLOGFilterUPP := MyNewModalFilterUPP(@ChooseFontFilter);  		repeatmyModalDialog(DLOGFilterUPP, localItemHit);			if localItemHit in [3, 4, 5] then				whichradio := localItemHit			else if localItemHit = 7 then				begin					treetaxastyle := dlogFonts.face;					treetaxafont := dlogFonts.font;					treetaxafontsize := dlogFonts.size;					SetDialogValuesAsDefaults(theDialog, tipLabelid, 0, 0);				end;			CheckTipLabels(theDialog, whichradio);		until (localItemHit in [1, 2]);MyDisposeUserItemUPP(UserItemUProcP);MyDisposeModalFilterUPP(DLOGFilterUPP);		EndDLOG(theDialog, tempP);		if localItemHit = 1 then			begin				oldtiplabel := tiplabel;				if whichradio = 3 then					tiplabel := TipTaxa				else if whichradio = 4 then					tiplabel := tipState				else if whichradio = 5 then					tiplabel := TipTaxNum;				InvalTaxonNames;				treetaxastyle := dlogFonts.face;				treetaxafont := dlogFonts.font;				treetaxafontsize := dlogFonts.size;{CalcTaxonHeight;}				SetDrawTWRControls;				godraw := true;			end		else			begin				treetaxastyle := oldFonts.face;				treetaxafont := oldFonts.font;				treetaxafontsize := oldFonts.size;			end;	end;{-----------------------------------------------------------------------------}	procedure DoOtherColumnWidthDialog;		label 1;		var			theDialog: DialogPtr;			tcolumnWidth: integer;			tempP: WindowPtr;			ds: str255;			localItemHit, maxColumnWidth: integer;	begin		maxColumnWidth := ScreenRectangle.right - ScreenRectangle.left-editorFirstColumnLeft - scrollwidth -10 ;		tcolumnWidth := editorColumnWidth;		StartDLOG(165, theDialog, tempP);		myShowDialog(theDialog);1:		SetDLOGText(theDialog, 3,StringFromNum(editorColumnWidth), true);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);		until localItemHit in [1, 2];		if localItemHit = 1 then			begin				tcolumnWidth := EditTextInt(theDialog, 3,false);				if (tcolumnWidth <= 0) or (tcolumnWidth >= maxColumnWidth) then					begin						Beep;						goto 1;					end				else					editorColumnWidth := tcolumnWidth;			end;					EndDLOG(theDialog, tempP);	end;{-----------------------------------------------------------------------------}	procedure DoColumnWidthMenu (ItemNo: integer);	var oldcw: integer;		ds: str255;	begin{NOTE: if you change column width submenu items, then search for DoColumnWidthMenu, and change relevant values	- also need to change OtherColumnWidthItem in Globals}		dirtyfile := true;		oldcw := editorColumnWidth;		if itemNo < OtherColumnWidthItem then			begin				GetMenuItemText(ColumnWidthMHdl, ItemNo, ds);				if StringIsLongint(ds) then					editorColumnWidth := TokenToInteger(ds, false);			end		else			DoOtherColumnWidthDialog;		if oldcw <> editorColumnWidth then			begin				ReSizeEditorWindow;				CheckColumnWidthMenu;			end;	end;			{-----------------------------------------------------------------------------}	procedure DoColorPartitionsMenu (ItemNo: integer);	var oldMode : integer;	begin		case ItemNo of			PartTitlesItem:				begin					editorColorPartitionTitle:= not editorColorPartitionTitle;					InvalidateWindow(editorWindow, true);					myCheckMenuItem(ColorCharPartitionMHdl,PartTitlesItem, editorColorPartitionTitle);				end;			PartCellsItem:				begin					editorColorPartitionCells:= not editorColorPartitionCells;					InvalidateWindow(editorWindow, true);					myCheckMenuItem(ColorCharPartitionMHdl,PartCellsItem, editorColorPartitionCells);				end;			PartNumbersItem:				begin					editorColorPartitionNumbers:= not editorColorPartitionNumbers;					InvalidateWindow(editorWindow, true);					myCheckMenuItem(ColorCharPartitionMHdl,PartNumbersItem, editorColorPartitionNumbers);				end;			otherwise;		end;	end;{-----------------------------------------------------------------------------}	procedure DoColorCodPosMenu (ItemNo: integer);	var oldMode : integer;	begin		case ItemNo of			PartTitlesItem:				begin					editorColorCodPosTitle:= not editorColorCodPosTitle;					InvalidateWindow(editorWindow, true);					myCheckMenuItem(ColorCodPosMHdl,PartTitlesItem, editorColorCodPosTitle);				end;			PartCellsItem:				begin					editorColorCodPosCells:= not editorColorCodPosCells;					InvalidateWindow(editorWindow, true);					myCheckMenuItem(ColorCodPosMHdl,PartCellsItem, editorColorCodPosCells);				end;			PartNumbersItem:				begin					editorColorCodPosNumbers:= not editorColorCodPosNumbers;					InvalidateWindow(editorWindow, true);					myCheckMenuItem(ColorCodPosMHdl,PartNumbersItem, editorColorCodPosNumbers);				end;			otherwise;		end;	end;{-----------------------------------------------------------------------------}	procedure DoAATranslateMenu (ItemNo: integer);	var oldMode : integer;	begin		case ItemNo of			AATranslateShowItem:				if editorTransposed then					InstantInfo('Amino acid translation can not be shown with a transposed matrix')				else					SwitchEditorShowAAWithDNA;			AATranslateColorItem:				begin					editorColorAAwithDNA := not editorColorAAwithDNA;					InvalidateWindow(editorWindow, true);					myCheckMenuItem(AATranslateMHdl,AATranslateColorItem, editorColorAAwithDNA);				end;			AATranslateDimNucItem:				begin					editorDimDNAwithAA := not editorDimDNAwithAA;					InvalidateWindow(editorWindow, true);					myCheckMenuItem(AATranslateMHdl,AATranslateDimNucItem, editorDimDNAwithAA);				end;			otherwise;		end;	end;{-----------------------------------------------------------------------------}	procedure DoColorCellsMenu (ItemNo: integer);	var oldMode : integer;		redraw: boolean;	begin		oldMode := editorColorCellsMode;		redraw := false;		case ItemNo of			ColorCellsOffItem:				editorColorCellsMode := editorColorCellsOff;			ColorCellsByStateItem:				editorColorCellsMode := editorColorCellsState;			ColorCellsMatchFirstItem:				editorColorCellsMode := editorColorCellsMatchFirst;			ColorCellsByAAStateItem:				editorColorCellsMode := editorColorCellsAAState;			ColorCellsDimLowerCaseItem:				begin					editorColorCellsDimLowerCase := not editorColorCellsDimLowerCase;					redraw := true;				end;							ColorCellsStateColorItem:				begin					DoPatternsAndColors(false,0);					InvalidateWindow(toolPaletteWindow[editorTools],false);				end;								ColorCellsProteinStateColorItem:				DoPatternsAndColors(true,protein);			ColorCellsLettersOnlyItem:				begin					editorColorCellsByFillRect := not editorColorCellsByFillRect;					redraw := true;				end;							{ColorCellsByCodPosItem:				editorColorCellsMode := editorColorCellsCodPos;}			otherwise;		end;		if (oldMode <> editorColorCellsMode) | redraw then			begin				CheckColorCellsMenu;				InvalidateWindow(toolPaletteWindow[editorTools],false);				InvalidateWindow(editorWindow, true);			end;		oldmode := editorOrigin.h;	end;{-----------------------------------------------------------------------------}	procedure DoShowMenu (ItemNo: integer);		var			theWindow: WindowPtr;			showmenubase, j: integer;			redrawn: boolean;	begin		theWindow := frontWindow;		dirtyfile := true;		if (theWindow=chartWindow) then			DoChartShowMenu (ItemNo)		else if treeopen then			begin				showmenubase := 3;				case ItemNo of								BranchNumbersItem: 						begin							shownodenumbers := not shownodenumbers;							myCheckMenuItem(ShowMHdl, BranchNumbersItem, showNodeNumbers);							godraw := true;						end;					EvolveSegsItem: {evolve segments}						begin							showEvolveSegments := not showEvolveSegments;							myCheckMenuItem(ShowMHdl, EvolveSegsItem, showEvolveSegments);							godraw := true;						end;{$IFC REALLENGTHS}					EvolveRealLengthsItem: 						begin							showEvolveRealLengths := not showEvolveRealLengths;							myCheckMenuItem(ShowMHdl, EvolveRealLengthsItem, showEvolveRealLengths);							godraw := true;						end;{$ENDC}					Nex7onItem:   						begin							Nex7OnOff(not nex7on);							myCheckMenuItem(ShowMHdl, Nex7onItem, nex7on);						end;					ShrinkItem: 						begin							ShrinkTree;							godraw := true;							FixTreeShadingMenus;						end;					otherwise						;				end;			end		else if editorOpen then			begin				case ItemNo of					EWGridItem: 						begin							grid := not grid;							InvalidateWindow(editorWindow, true);							myCheckMenuItem(ShowMHdl, EWGridItem, grid);						end;					EWTaxonNumbersItem: 						begin							showtaxnum := not showtaxnum;							InvalidateWindow(editorWindow, true);							myCheckMenuItem(ShowMHdl, EWTaxonNumbersItem, showtaxnum);						end;					EWTaxonNamesItem: 						begin							showtaxname := not showtaxname;							InvalidateWindow(editorWindow, true);							myCheckMenuItem(ShowMHdl, EWTaxonNamesItem, showtaxname);						end;					EWCharacterNumbersItem: 						begin							showcharnum := not showcharnum;							InvalidateWindow(editorWindow, true);							myCheckMenuItem(ShowMHdl, EWCharacterNumbersItem, showcharnum);						end;					EWCellSymbolsItem: 						begin							editorShowCellSymbol := not editorShowCellSymbol;							InvalidateWindow(editorWindow, true);							myCheckMenuItem(ShowMHdl, EWCellSymbolsItem, editorShowCellSymbol);						end;					EWStateNamesItem: 						begin							editorShowFullStateNames := not editorShowFullStateNames;							CheckStateNamesSymbolsDanger(true, redrawn);							if not redrawn then								DrawStatesChangedReDrawEditor;  {v3.04}						end;											EWUseIUPACItem:						begin							editorShowIUPACSymbols := not editorShowIUPACSymbols;							CheckStateNamesSymbolsDanger(true, redrawn);							if not redrawn then								DrawStatesChangedReDrawEditor;  {v3.04}						end;					{EWAAColorCellsItem: 						begin							editorColorAAwithDNA := not editorColorAAwithDNA;							InvalidateWindow(editorWindow, true);							myCheckMenuItem(ShowMHdl,EWAAColorCellsItem, editorColorAAwithDNA);						end;}					otherwise						;				end;				showmenubase := 6;			end;	end; {-----------------------------------------------------------------------------}	procedure DoWindowsMenu (ItemNo: integer);		var			TaxonHdl: thdl;			oldsaved, onenormal, opentreeanyway: boolean;			itstart, itend, it: integer;			box: rect;			cc, growsize: size;			tport: WindowPtr;			amountneeded: longint;			db: boolean;			whichText, whichToolPalette: integer;	begin	case ItemNo of		TreeWindowItem:			GoToTreeWindow(-1);		DataEditorItem:			begin {    if thewindow = commwindow then HideWindow(commwindow);}				if treeopen then					begin						CloseTreeWindow(true);						ReCalcEditorStatesH (1,numchars);					end;				if editorOpen then 					begin						if not IsEditorWindow(frontwindow)then							SelectEditorWindows;					end				else					OpenEdit;			end;		ToolPaletteItem:			begin				if treeopen then 					whichToolPalette := treeTools				else 					whichToolPalette := editorTools;				toolPaletteOpen[whichToolPalette] := not toolPaletteOpen[whichToolPalette];				if not toolPaletteOpen[whichToolPalette] then					ClosePaletteWindow(whichToolPalette)				else					OpenPaletteWindow(whichToolPalette);			end;					LastToolItem:			begin				if treeopen then 					whichToolPalette := treeTools				else 					whichToolPalette := editorTools;				if (lastTool[whichToolPalette] <> currentTool[whichToolPalette]) & tool^[whichToolPalette,lastTool[whichToolPalette]].enabled then					SetTool(whichToolPalette,lastTool[whichToolPalette]);			end;		{CharInfoItem:			if (fileopen) then				OpenOrSelectInfoWindow(charinfo);		TaxInfoItem:			if (fileopen) then				OpenOrSelectInfoWindow(taxinfo);		CharSetInfoItem:			if (fileopen) then				OpenOrSelectInfoWindow(charsetinfo);		TaxSetInfoItem:			if (fileopen) then				OpenOrSelectInfoWindow(taxsetinfo);		WtSetInfoItem:			if (fileopen) then				OpenOrSelectInfoWindow(wtsetinfo);		TypeSetInfoItem:			if (fileopen) then				OpenOrSelectInfoWindow(typesetinfo);		ExSetInfoItem:			if (fileopen) then				OpenOrSelectInfoWindow(exsetinfo);		TreeInfoItem:			if (fileopen) and treeopen then				OpenOrSelectInfoWindow(treeinfo);}							{StateNamesItem: 					if statesWindowOpen then						SelectWindow(statesWindow)					else						OpenStatesWindow(false, 0, 0);}		{ChartWindowItem:			if charton then				begin				SelectWindow(chartWindow);				end;}						FileNotesItem: 				begin					{if curcom <> filecom then						begin							commOrigin := 0;							curcom := filecom;							SetControlValueLong(commScroll, 0);							SizeCommWindowText(false, true, false);						end;					OpenCommWindow;}					if not textWindowInfo[aboutFileText]^.open then						OpenTextWindow(aboutFileText)					else						SelectWindow(textWindow[aboutFileText]);				end;		TreeNotesItem: 				begin					{if curcom = filecom then						begin							if treefile then								curcom := treefilecom							else								curcom := treedatacom;							commOrigin := 0;							SetControlValueLong(commScroll, 0);							SizeCommWindowText(false, true, false);						end;					OpenCommWindow;}					if treeFile then						whichText := aboutTreeFileText					else						whichText := aboutTreesText;					if not textWindowInfo[whichText]^.open then						OpenTextWindow(whichText)					else						SelectWindow(textWindow[whichText]);				end;		{PAUPBlockItem:				if not textWindowInfo[NexusBlockText]^.open then					OpenTextWindow(NexusBlockText)				else					SelectWindow(textWindow[NexusBlockText]);}		otherwise			if ItemNo >= OpenWindowsFirstItem then				if MacCladeWindowList[ItemNo-OpenWindowsFirstItem+1] <> nil then					SelectWindow(MacCladeWindowList[ItemNo-OpenWindowsFirstItem+1]);		end;	end;{-----------------------------------------------------------------------------}	procedure DoDataMatrixStyleMenu(ItemNo: integer);	begin		case itemNo of 				styleStandardItem:					begin						if not grid then DoShowMenu(EWGridItem);						if not showtaxnum then DoShowMenu(EWTaxonNumbersItem);						if not showtaxname then DoShowMenu(EWTaxonNamesItem);						if not showcharnum then DoShowMenu(EWCharacterNumbersItem);						if (editorColorCellsMode<>editorColorCellsOff) then DoColorCellsMenu(ColorCellsOffItem);						if not editorShowCellSymbol then DoShowMenu(EWCellSymbolsItem);						if editorColorAAwithDNA then DoAATranslateMenu(AATranslateColorItem);						if editorShowAAwithDNA then							DoAATranslateMenu(AATranslateShowItem);						DoShadeCharSetMenu(ShadeNoneItem); 						if editorShowFullStateNames then DoShowMenu(EWStateNamesItem);						DoColumnWidthMenu(6);					end;				styleMolecularItem:					begin						if not grid then DoShowMenu(EWGridItem);						if not showtaxnum then DoShowMenu(EWTaxonNumbersItem);						if not showtaxname then DoShowMenu(EWTaxonNamesItem);						if not showcharnum then DoShowMenu(EWCharacterNumbersItem);						if not editorShowCellSymbol then DoShowMenu(EWCellSymbolsItem);						if editorColorAAwithDNA then DoAATranslateMenu(AATranslateColorItem);						if editorShowAAwithDNA then							DoAATranslateMenu(AATranslateShowItem);						DoShadeCharSetMenu(ShadeNoneItem); 						if (editorColorCellsMode<>editorColorCellsState) then DoColorCellsMenu(ColorCellsByStateItem);						DoColumnWidthMenu(4); 					end;				styleShadedMolecularItem:					begin						DoDataMatrixStyleMenu(styleMolecularItem);						DoShadeCharSetMenu(ShadeLighterItem); 						DoShadeCharSetMenu(ShadeExcludedItem); 						if (not editorColorCellsDimLowerCase) then 							DoColorCellsMenu(ColorCellsDimLowerCaseItem);					end;				styleDNAwithAAItem:					begin						if (editorColorCellsMode<>editorColorCellsState) then DoColorCellsMenu(ColorCellsByStateItem);						if not editorShowAAwithDNA then							DoAATranslateMenu(AATranslateShowItem);						if not editorDimDNAwithAA then							DoAATranslateMenu(AATranslateDimNucItem);						if not editorShowCellSymbol then DoShowMenu(EWCellSymbolsItem);						if not editorColorAAwithDNA then DoAATranslateMenu(AATranslateColorItem);					end;				styleDNAwithAAColorsItem:					begin						if grid then DoShowMenu(EWGridItem);						if (editorColorCellsMode<>editorColorCellsAAState) then 							DoColorCellsMenu(ColorCellsByAAStateItem);						if not editorShowCellSymbol then DoShowMenu(EWCellSymbolsItem);						if editorShowAAwithDNA then							DoAATranslateMenu(AATranslateShowItem);						DoColumnWidthMenu(3); 					end;				styleShadedDNAwithAAColorsItem:					begin						DoDataMatrixStyleMenu(styleDNAwithAAColorsItem);						DoShadeCharSetMenu(ShadeLighterItem); 						DoShadeCharSetMenu(ShadeExcludedItem); 						if (not editorColorCellsDimLowerCase) then 							DoColorCellsMenu(ColorCellsDimLowerCaseItem);					end;				styleBirdsEyeItem:					begin						if grid then DoShowMenu(EWGridItem);						if (editorColorCellsMode=editorColorCellsOff) then DoColorCellsMenu(ColorCellsByStateItem);						if (not editorColorCellsByFillRect) then DoColorCellsMenu(ColorCellsLettersOnlyItem);						if  editorShowCellSymbol then DoShowMenu(EWCellSymbolsItem);						DoColumnWidthMenu(1);					end;				styleWideNamesItem:					begin						if not grid then DoShowMenu(EWGridItem);						DoColumnWidthMenu(9); 						if not editorShowCellSymbol then DoShowMenu(EWCellSymbolsItem);						if not editorShowFullStateNames then DoShowMenu(EWStateNamesItem);					end;				styleDimExcludedItem:					begin						DoShadeCharSetMenu(ShadeLighterItem); 						DoShadeCharSetMenu(ShadeExcludedItem); 					end;			otherwise;		end;	end; {-----------------------------------------------------------------------------}	procedure DoConsensusTaxSetMenu (ItemNo: Integer);	begin		if ItemNo > 0 then			begin				dirtyfile := true;				if itemNo=1 then					begin						editorConsensusTaxSet := AllTaxSet;						if ConsensusSequenceVisible then							InvalidateWindow(editorWindow, true);  					end				else					begin						if (editorConsensusTaxSet <> itemNo-1) then							if ConsensusSequenceVisible then								InvalidateWindow(editorWindow,true);						editorConsensusTaxSet := ItemNo-1;					end;				CheckConsensusTaxSetMenu;			end;	end; {-----------------------------------------------------------------------------}	procedure DoShadeCharSetMenu (ItemNo: Integer);	var newset: integer;	begin		dirtyfile := true;		case itemNo of 			ShadeNumbersItem: 				begin					editorShadeCharSetNumbers := not editorShadeCharSetNumbers;					InvalidateWindow(editorWindow,true);				end;			ShadeTitlesItem:				begin					editorShadeCharSetTitle := not editorShadeCharSetTitle;					InvalidateWindow(editorWindow,true);				end;			ShadeCellsItem:				begin					editorShadeCharSetCells := not editorShadeCharSetCells;					InvalidateWindow(editorWindow,true);				end;			ShadeDarkerItem:				begin					if editorShadeCharSetLighter then						InvalidateWindow(editorWindow,true);					editorShadeCharSetLighter := false;				end;			ShadeLighterItem:				begin					if not editorShadeCharSetLighter then						InvalidateWindow(editorWindow,true);					editorShadeCharSetLighter := true;				end;			otherwise 				begin					newSet := itemNo -FirstShadeCharSetItem+1;					if editorCharacterSetToShade <> newSet then						InvalidateWindow(editorWindow,true);					editorCharacterSetToShade := newSet;					if (editorCharacterSetToShade>= FirstUserShadeCharSet) & (editorCharacterSetToShade <= LastUserShadeCharSet) then						SetShadeCharSetBooleans(editorCharacterSetToShade - FirstUserShadeCharSet);				end;		end;		CheckShadeCharSetMenu;	end;{-----------------------------------------------------------------------------}	procedure SetEditorSelectionColor;		var			theDialog: DialogPtr;			tempP: WindowPtr;			localItemHit: integer;			OldStandardSelectionWeight: integer; {........}		procedure CheckSelectionColors;		var j : integer;		begin			for j := 1 to 8 do 				ItemCheckMark(theDialog, 2+j, standardSelectionColorNumber=j);		end; {........}	begin		OldStandardSelectionWeight := standardSelectionColorNumber;		StartDLOG(154, theDialog, tempP);		CheckSelectionColors;		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			if (localitemhit>=3) & (localitemhit<=10) then				begin					standardSelectionColorNumber := localitemhit - 2;					CheckSelectionColors;				end			else if localitemhit=12 then				SetDialogValuesAsDefaults(theDialog, editorSelectionColorID, 0, 0);		until localItemHit in [1, 2];		EndDLOG(theDialog, tempP);		if localitemHit = 1 then			begin				SetStandardSelectionColor(standardSelectionColorNumber);				SwitchShade(selectionShade);				if editorSelected then					InvalidateWindow(editorWindow,true)				else					InvalidateSelectionQueryRectangle;			end		else			standardSelectionColorNumber := oldStandardSelectionWeight;	end; {-----------------------------------------------------------------------------}	procedure DoDisplayMenu (ItemNo: Integer);		var			TaxonHdl: thdl;			oldsaved, onenormal: boolean;			itstart, itend, it, consensusNumber: integer;			box: rect;			cc, growsize: size;			tport: WindowPtr;			amountneeded: longint;			db: boolean;	begin {==============  tree Window Display  ================}		if treeopen then			case ItemNo of				TraceLabelItem: 					if (traceshown = traceDiscrete) then						CharTraceLabelDLOG {in Coloring}					else if (traceshown = traceContinuous) then						ContTraceLabelDLOG {in Coloring}					else if (traceshown = traceAllStates) & (BLSWhat <> BLSstatesum) then						AllStatesLabelDLOG {in Coloring}					else if (traceshown = traceAllChanges) & ChangesDisplay(false) then {in TraceAllChangesCalc}						QueryChangeTreeShapeForTicks;										BarDisplayOptionsItem:					if (traceShown=traceAllChanges) & (summaryView=asTicks) then						db := TicksDisplay;				BranchPatternsAndColorsItem:  {$IFC TINKERTOY}					if OptionEvent(Event) then						begin							tinkertoy := not tinkertoy;							godraw := true;						end					else  {$ENDC}						if (traceshown = traceContinuous) then							SmallBranchShades						else							DoPatternsAndColors(false,0); {$IFC SQUAREBRANCHES}				TreeShapeAndSizeItem: 						ShapeAndSizeDLOG; {$ENDC}				TipLabelsItem: 					if LockedToTreeWindow(frontWindow) then						TipLabelsDLOG;{$IFC FALSE}				BranchLengthsItem: 					BranchLengthsDisplay; {$ENDC}				ZoomTWItem: 					if (GetWindowType(FrontWindow) <= TWLoose) or (IsInfoWindow(frontwindow)) then						WindowPop(twfullscreen,true);  {note that windowpop switches value of twfullscreen}										LockLegendsItem: 					SwitchLockLegends;				otherwise					;			end {==============  Edit Window Display  ================}		else if editorOpen then			case ItemNo of				EWStyleItem: 					if (IsEditorWindow(frontwindow)) & editorSelected then						begin							itStart := TaxonOfCell(editorSelectionTopLeft);							itend := TaxonOfCell(editorSelectionBotRight);							if itend > 0 then								begin									if itStart < 1 then itStart := 1;									OneNormal := false;									for it := itstart to itend do										if not ItalicTaxon(it) then											begin												OneNormal := true;												leave;											end;									for it := itstart to itend do										begin											TaxonHdl := gettaxonHdl(it);											taxonHdl^^.isItalic := OneNormal;										end;									myCheckMenuItem(EWDisplayMHdl, EWStyleItem, OneNormal);									if itstart <> itend then										begin											EraseRect(editorSelectionRect);											InvalidateWindowRect(editorWindow,editorSelectionRect,false);										end;								end;						end;				SymbolsItem: 					SymbolsDLOG;									{EWColorsItem:					DoPatternsAndColors;}				MatchCharItem: 						MatchDLOG;			{	AutoAATranslateItem:					begin						editorShowAAwithDNA := not editorShowAAwithDNA;						InvalidateWindow(editorWindow, true);						ReSizeEditorWindow;						myCheckMenuItem(EWDisplayMHdl,AutoAATranslateItem, editorShowAAwithDNA);						EnableDisableItem(ShadeCharSetMHdl,DimDNAwithAAItem, nucleotides & AAAutoTranslationVisible);						EnableDisableItem(ShowMHdl,EWAAColorCellsItem, nucleotides & AAAutoTranslationVisible);					end;}								PICTshowItem:  {$IFC FOOTSOUNDS}					if OptionEvent(Event) and hasSndPlay then						PlayFootSound(TaxonOfCell(editorSelectionTopLeft), CharOfCell(editorSelectionTopLeft))					else  {$ENDC}						ShowFootPict(TaxonOfCell(editorSelectionTopLeft), CharOfCell(editorSelectionTopLeft),0,0);				footTextItem: 					if not foottexton then						begin							foottexton := true;							myCheckMenuItem(EWDisplayMHdl, footTextItem, true);							myCheckMenuItem(EWDisplayMHdl, FootstatesItem, false);							DrawFootText(false, false);							TEActivate(noteTE);							TESetSelect(32767, 32767, noteTE);						end;				FootStatesItem: 					if foottexton then						begin							footediting := false;							foottexton := false;							myCheckMenuItem(EWDisplayMHdl, footTextItem, false);							myCheckMenuItem(EWDisplayMHdl, FootstatesItem, true);							DrawFootText(false, false);						end;				EditorTransposedItem:					SwitchEditorTransposed;									SetEditorSelectionColorItem: 					SetEditorSelectionColor;				ConsensusItem:					begin						if not SomeConsensusSelected(consensusNumber) then							consensusNumber := 0;						if ConsensusDialog(consensusNumber) then							begin								InvalidateWindow(editorWindow, true);								ReSizeEditorWindow;							end;					end;			{	FrequentRedrawItem:					begin						editorFrequentRedraw := not editorFrequentRedraw;						if editorFrequentRedraw then							InvalidateWindow(editorWindow, true);						myCheckMenuItem(EWDisplayMHdl,FrequentRedrawItem, editorFrequentRedraw);					end;}				otherwise					;			end;	end;end.