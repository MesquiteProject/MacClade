unit Dollo;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, UtilLibInterface, SetLibInterface,   TypeUtil, CharUtil, TreeUtil, Polycalc;{Dollo utilities}	function PackDollo3 (lns0, lns1, s: lgsetchars): lgsetchars;	procedure UnpackDollo3 (src: lgsetchars; var lns0, lns1, s: lgsetchars);	function SetToPackedDolloCert (iset: largestsetchars; charmaxst: integer): largestsetchars;	function SetToPackedDolloUnCert (iset: largestsetchars; charmaxst: integer): largestsetchars;	function FinalCombineDollo (dnLo, dnRo, dNo, ancsto: largestsetchars; atroot: boolean; ic: integer): largestsetchars;	function DolloCombineAndPack (setLo, setRo: largestsetchars; isroot: boolean; ic: integer): largestsetchars;{еееееееееееееееееееееее}implementation {е$S CalcUtil}{==================================================================}{------------DOLLO UTILITIES--------------------------------------------------}{Dollo characters require special storage and manipulation.  Some basic utilities are here.}{Dollo Storage:  Recall that Dollo requires two sets to be stored on downpass, an LNS set}{(last non-missing split) and an sts set (local final set).  Because these algorithms are}{worked out for binary characters only, the characters are first recoded into binary}{factors.  MacClade ends up storing three sets: lns0, whose bits store whether or not}{0 is included in the LNS set of the various factors (the ith bit for the ith factor); lns1,}{whose bits store whether 1 is included in the LNS set of the factors, and s, the sts set.}{Thus if there are three factors and lns0 = [off,on,on], lns1 = [off,off,on] (bits off or on) then the LNS of}{the first factor is [], of the second factor is [0] and of the third factor is [0,1].  }{For compactness of storage MacClade does not store three full sets; rather the sets are concatenated}{(packed) and squeezed into a single setchars.  Thus the bit usage of a set15 stored character}{is:  [lns0,lns0,lns0,lns1,lns1,lns1,sts,sts,sts,unused,FP,FT,GA,UC,ER,MS].}{The maximum number of states in a dollo character is less than in other characters,}{namely one third as large.}{Dollosize is thus three for set15 characters; 8 for set31 characters.}{}{NOTE: These dollo algorithms are complex and remain at least slightly mysterious.  They}{have been thoroughly checked but some unease remains, particularly regarding }{BinaryDecodeLargest and its interaction with missing data}	function PackDollo3 (lns0, lns1, s: lgsetchars): lgsetchars;{FROZEN 3.0}{packs 0's bits set, 1's bits set, and sts from dollo calculations into single setchars}		var			ts: lgsetchars;	begin		ts := Intersect2(lns0, MakeSpan(0, dollosize - 1)); {place lns0 in first subset}		if Intersect2(lns1, MakeSpan(0, absmaxstate)) <> nil then			ts := Union2(ts, MakeSpan(minG(lns1) + dollosize, maxG(lns1) + dollosize)); {place lns1 in second subset}		if Intersect2(s, MakeSpan(0, absmaxstate)) <> nil then			ts := Union2(ts, MakeSpan(minG(s) + dollosize * 2, maxG(s) + dollosize * 2));  {place s in third subset}		packdollo3 := ts;	end;{------------------------------------------------------}	procedure UnpackDollo3 (src: lgsetchars; var lns0, lns1, s: lgsetchars);{FROZEN 3.0}{unpacks 0's bits set, 1's bits set, and sts from single setchars into three resulting sets, for Dollo calculations}	begin		lns0 := Intersect2(src, MakeSpan(0, dollosize - 1));  {mask to get first subset}		lns1 := Intersect2(src, MakeSpan(dollosize, dollosize * 2 - 1));  {mask to get second subset}		if lns1 <> nil then			lns1 := MakeSpan(minG(lns1) - dollosize, maxG(lns1) - dollosize); {shift bits down by one dollosize}		s := Intersect2(src, MakeSpan(dollosize * 2, dollosize * 3 - 1));  {mask to get third subset}		if s <> nil then			s := MakeSpan(minG(s) - dollosize * 2, maxG(s) - dollosize * 2) {shift bits down by two dollosizes}	end;{------------------------------------------------------}{Following two functions:}{used in settaxdnst (SetStates) and in DownPassTraced for setting downstates of terminal}{nodes from set observed in taxon.  Recall Dollo downstates are packed so that first bits are}{0's of binary recoded LastNonMissing-split, second set of bits ar 1's of LNS, while third}{set of bits are states that would have been reconstructed according to clade alone}{Factor i refers to breakpoint between i and i+1;  }{thus 0 is in factor i if rs contained element less than or equal to i,}{and 1 is in factor i if rs contained element greater than i}	function SetToPackedDolloCert (iset: largestsetchars; charmaxst: integer): largestsetchars;{FROZEN 3.0}		var			maxL: integer;			nset, spset: lgsetchars;	begin		if ZeroHighbitsLg(iset) = [] then			SetToPackedDolloCert := OldSetFromNew(packDollo3(nil, nil, MakeSpan(0, CharMaxst)))		else			begin				nset := NewSetFromOld(iset);				MaxL := MaxG(nset);				spset := MakeSpan(MinG(nset), CharMaxst);{since state at terminal taxon is certain, resulting LNS contains in 0's and 1's as follows:}{if original set observed was}{--2345--		original}{then packed will be}{--234567		0's bits}{01234---		1's bits}				if maxL >= 1 then					SetToPackedDolloCert := OldSetFromNew(packDollo3(spset, MakeSpan(0, maxL - 1), nset))				else					SetToPackedDolloCert := OldSetFromNew(packDollo3(spset, nil, nset));			end;	end;{------------------------------------------------------}	function SetToPackedDolloUnCert (iset: largestsetchars; charmaxst: integer): largestsetchars;{FROZEN 3.0}		var			minL: integer;			nset, spset: lgsetchars;	begin		if ZeroHighbitsLG(iset) = [] then			SetToPackedDolloUnCert := OldSetFromNew(packDollo3(nil, nil, MakeSpan(0, CharMaxst)))		else			begin				nset := NewSetFromOld(iset);				MinL := MinG(nset);				spset := MakeSpan(MaxG(nset), CharMaxst);{since state at terminal taxon is uncertain, resulting LNS contains in 0's and 1's as follows:}{if original set observed was}{--2345--		original}{then packed will be}{-----567		0's bits}{01------		1's bits}				if minL >= 1 then					SetToPackedDolloUnCert := OldSetFromNew(packDollo3(spset, MakeSpan(0, minL - 1), nset))				else					SetToPackedDolloUnCert := OldSetFromNew(packDollo3(spset, nil, nset));			end;	end;{------------------------------------------------------}	procedure BinaryEncodeLargest (rs: lgsetchars; var ts0, ts1: lgsetchars; ic: integer);{FROZEN 3.0}{Performs additive binary coding on set rs and places results in ts0 (0's bits) and ts1 (1's bits).}{Used currently for dollo calculations.}{Used only in this unit, in FinalCombineDollo and DolloCombineAndPack, to deal with}{sts calculations (not used in LNS calculations)}{Note This is currently equivalent in its basic encoding to SetToPackedDolloCert in CharUtil,}{i.e. it treats all sets as containing their elements with certainty in some sense, because}{it is only used in STS Calculations}		var			minL, maxL: integer;	begin		if rs = nil then			begin				ts0 := nil;				ts1 := nil;			end		else			begin	{Factor i refers to breakpoint between i and i+1;  }	{thus 0 is in factor i if rs contained element less than or equal to i,}	{and 1 is in factor i if rs contained element greater than i}				minL := minG(rs);				maxL := maxG(rs);	{0's bits: every factor from minL to maximum is has 0's bit, since for each such factor i}	{rs had an element less than or equal to i}				ts0 := MakeSpan(minL, CharMaxstOBS(ic));	{1's bits: every factor from 0 to maxL-1 is has 1's bit, since for each such factor i}	{rs had an element greater than i (unless maxL was 0, in which case no factors have 1's bit)}				if maxL > 0 then					ts1 := maKeSpan(0, maxL - 1)				else					ts1 := nil;			end;	end;{------------------------------------------------------}	function BinaryDecodeLargest (ts0, ts1: lgsetchars; ic: integer): lgsetchars;{FROZEN 3.0}{Decodes additive binary coded ts0 (0's bits) and ts1 (1's bits) and returns native set}{Note that BinaryDecodeLargest is more elaborate than BinaryEncodeLargest because BEL is not}{used to encode uncertainty in the set, while BDL may encounter a set whose states are uncertain.}{Since BEL and BDL are used only on STS calculations, whose sets are always stored as }{presences and not uncertainties, BDL will only encounter uncertainties due to missing}{data (or due to incomplete intermediate calculations?),}{since only these have STS coded as with uncertainties at the terminal taxa.}{The coding of these will ensure that uncertainties will have style of coding indicated by}{cases 1,2,3 and 5 below, but in fact it is probably true that case 2 will never be}{encountered in these algorithms.}{Used only in this unit, in FinalCombineDollo and DolloCombineAndPack, to deal with}{STS calculations (not used in LNS calculations)}		var			rset: lgsetchars;	begin{Note that any 0's bits set must be on right hand side of set; any 1's on left hand side.}		rset := Intersect2(ts0, ts1);{When there is no overlap in the 0's and 1's bits (unless they just miss each other) then}{there is uncertainty in the state set.  That is, one can say for some high value that there exists}{an element ▓ this value, and that for some low value that there exists an element > this value,}{but for intermediate values it cannot be said for certain whether there exist elements higher or lower;}{it can only be said that somewhere in this range is at least one element}		if rset = nil then			begin{recall 0 is in factor i if rset contains element less than or equal to i,}{and 1 is in factor i if rset contains element greater than i}				if ts0 <> nil then					begin  {there are 0's; question is whether there are 1's}						if ts1 = nil then{0123456:	CASE 1}{++++000    becomes [01234] because all we know is that set contains elements ▓ 4}{+++++++ }{Note: this interpretation is consistent with and what is required by the way missing and}{uncertainties were coded at terminal taxa; this interpretation is apparently retained by}{the operations of DolloCombineandPack as one moves down the tree}							rset := MakeSpan(0, minG(ts0))						else{0123456:	CASE 2}{++++000    becomes [234] because contains elements ▓4, >1; though allows for ▓5 also, no need}{11+++++ }{0123456:	CASE 3}{++++000    becomes [4] because contains elements ▓4, >3, with no indication of anything else}{1111+++ }							rset := MakeSpan((maxG(ts1) + 1), minG(ts0));					end				else if ts1 = nil then  {no 0's, thus no upper limit on first state}{0123456:	CASE 4}{+++++++    becomes []}{+++++++ }					rset := nil  {if both sets empty then result is empty}				else{0123456:	CASE 5}{+++++++    becomes [3456]}{111++++ }					rset := MakeSpan((maxG(ts1) + 1), charMaxstOBS(ic));  {otherwise states must be larger than }			end		else{On the other hand if there is overlap, then the set is polymorphic, and }{result is overlap plus one larger than max in overlap;}{this is equivalent to [minLg(ts0)..maxLg(ts1)+1]; see above BinaryEncode}{0123456:	CASE 6}{++00000    becomes [234]}{1111+++ }			rset := AddToSet(rset, maxG(rset) + 1);		BinaryDecodeLargest := rset;	end;{----------------------------------------------------------------------------------------------}	function Complement (s, fullset: lgsetchars): lgsetchars;{FROZEN 3.0}	begin		Complement := Intersect2(lgsetchars(BNot(ord4(s))), fullset);	end;{----------------------------------------------------------------------------------------------}{	Given LNS at L and R of:		On down pass assign N:}{		LNS L  		LNS R			LNS N		STS N	}{1		[0] 		[0]				[0]			[0]		}{2		[0] 		[0,1]			[0,1]		[0]		}{3		[0] 		[1]				[0,1]		[0,1]	}{4		[0] 		?				[0]			[0]		}{5		[0,1]		[0,1]			[1]			[1]		}{6		[0,1]		[1]				[1]			[1]		}{7		[0,1]		?				[0,1]		STS L	}{8		[1]			[1]				[1]			[1]		}{9		[1]			?				[1]			[1]		}{10	? 			?				?			?		}	function DolloCombineAndPack (setLo, setRo: largestsetchars; isroot: boolean; ic: integer): largestsetchars;{FROZEN 3.0}{used in Downpasses of Calc and Calctraced}		var			setL, setR, tsts0, tsts1, rtsts0, rtsts1, lfsts0, lfsts1, missonleft, missonright, fullset: lgsetchars;			NL1, NL0, Nls, NR1, NR0, Nrs, N1, N0, Ns: lgsetchars;	begin		setL := NewSetFromOld(setLo);		setR := NewSetFromOld(setRo);		fullset := MakeSpan(0, charmaxstOBS(ic)); {get full set for later subraction}		UnPackDollo3(setL, NL0, NL1, Nls);		UnPackDollo3(setR, NR0, NR1, Nrs);{calculating LNS N}		N1 := lgsetchars(Union2((NL1), (NR1)));  {LNS N has 1 if 1 in LNS from either left or right}		N0 := lgsetchars(Intersect2(Union2((NL0), (NR0)), Complement(Intersect2((NL1), (NR1)), (fullset)))); {LNS N has 0 if 0 in LNS from either left or right unless 1 in both}{calculating STS N}{preliminary: STS N has 0 if 0 in either descendant LNS, unless 1 in both}		tsts0 := N0;  {STS N has 0 if 0 in either descendant LNS unless 1 in both, exactly as for N0}{preliminary: STS N has 1 if 1 in either descendant LNS, unless 0 in both, unless 1 in both}		tsts1 := lgsetchars(Union2(Intersect2(Union2((NL1), (NR1)), Complement(Intersect2((NL0), (NR0)), (fullset))), Intersect2((NL1), (NR1))));{ at this point STS N would have been calculated correctly except for case 7, which would be [0,1].}{thus go through cases where missing in one descendant, and assign STS in other descendant}		missonleft := lgsetchars(Complement(Union2((NL0), (NL1)), (fullset)));  {get bits which are missing in left descendant}		missonright := lgsetchars(Complement(Union2((NR0), (NR1)), (fullset)));  {get bits which are missing in right descendant}		BinaryEncodeLargest(Nls, lfsts0, lfsts1, ic); { factorize STS of left descendant into 0 and 1 bits}		BinaryEncodelargest(Nrs, rtsts0, rtsts1, ic); { factorize STS of right descendant into 0 and 1 bits}{replace 0's bits of tsts by 0's bits of  left and right descendant STS where missing is opposite them}		tsts0 := lgsetchars(Union2(Intersect2(Union2(Intersect2((tsts0), Complement((missonleft), (fullset))), Intersect2((missonleft), (rtsts0))), Complement((missonright), (fullset))), Intersect2((missonright), (lfsts0))));{replace 1's bits of tsts by 1's bits of  left and right descandant STS where missing is opposite them}		tsts1 := lgsetchars(Union2(Intersect2(Union2(Intersect2((tsts1), Complement((missonleft), (fullset))), Intersect2((missonleft), (rtsts1))), Complement((missonright), (fullset))), Intersect2((missonright), (lfsts1))));{decode results back to into result set Ns}		Ns := BinaryDecodeLargest(tsts0, tsts1, ic);{at root check to see that sts came out non-empty; if empty replace by fullset and re-encode}{for subsequent packing}		if isroot then			begin				if Ns = nil then					Ns := fullset;				BinaryEncodeLargest(Ns, N0, N1, ic);			end;		DolloCombineAndPack := OldSetFromNew(PackDollo3(N0, N1, Ns));	end;{----------------------------------------------------------------------------------------------}{								 Final set at N given set at ancestor:}{		LNS L  		LNS R		[0] at A	[1] at A		[0,1] at A}{1		[0] 		[0]			[0]			[0]				[0]}{2		[0] 		[0,1]		[0]			[1]				[0,1]}{3		[0] 		[1]			[0]			[1]				[0,1]}{4		[0] 		?			[0]			[0,1]			[0,1]}{5		[0,1]		[0,1]		[1]			[1]				[1]}{6		[0,1]		[1]			[1]			[1]				[1]}{7		[0,1]		?			[0]			[1]				[0,1]}{8		[1]			[1]			[1]			[1]				[1]}{9		[1]			?			[0,1]		[1]				[0,1]}{10	? 			?			[0]			[1]				[0,1]}	function FinalCombineDollo (dnLo, dnRo, dNo, ancsto: largestsetchars; atroot: boolean; ic: integer): largestsetchars;{FROZEN 3.0}{Takes packed dollo sets for left, right, and node, and final state set assignment at ancestor,}{and calculates final state set for node}{Used in TriplePasses of Calc and Calctraced, and in Equivocal}		var			fullset, ancsts0, ancsts1, sts0, sts1, dummy: lgsetchars;			NL1, NL0, NR1, NR0, N1, N0, ns: lgsetchars;			dnl, dnR, dn, ancst: lgsetchars;	begin		dnl := NewSetFromOld(dNLo);		dnR := NewSetFromOld(dnRo);		dn := NewSetFromOld(dNo);		ancst := NewSetFromOld(ancsto);		UnPackDollo3(dN, N0, N1, ns); {extract three components from downstate storage}		if not atroot then			begin  {=======  Not Root}				fullset := MakeSpan(0, charmaxstOBS(ic));				UnPackDollo3(dnL, NL0, NL1, dummy);				UnPackDollo3(dnR, NR0, NR1, dummy);				BinaryEncodeLargest(ancst, ancsts0, ancsts1, ic);{if anc states have 0, then 0 in sts unless 1 in both}				sts0 := lgsetchars(Intersect2((ancsts0), (Complement(Intersect2((NL1), (NR1)), (fullset)))));{also if anc states are 1, then add case where 0 in at least one of desc. and 1 in neither}				sts0 := lgsetchars(Union2((sts0), Intersect2(Complement(Union2((NL1), (NR1)), (fullset)), Union2((NL0), (NR0)))));{ If 1 in both L and R, then 1 must be in sts;}				sts1 := lgsetchars(Intersect2((NL1), (NR1)));{also if 1 in A then 1 must be in sts unless 0 in both L and R, unless 1 in either L or R}				sts1 := lgsetchars(Union2((sts1), Intersect2((ancsts1), Complement(Intersect2(Intersect2((NL0), (NR0)), Complement(Union2((NL1), (NR1)), (fullset))), (fullset)))));{also if descendants include no 0's and some 1's (e.g., case 9) }				sts1 := lgsetchars(Union2((sts1), Intersect2(Complement(Union2((NL0), (NR0)), (fullset)), Union2((NL1), (NR1)))));				FinalCombineDollo := OldSetFromNew(BinaryDecodeLargest(sts0, sts1, ic));			end		else			FinalCombineDollo := OldSetFromNew(ns);	end;end.