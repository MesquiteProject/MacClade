unit TypeNewDLOG;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, GeneticCode, TypeUtil, SymbolsNames, CharUtil, MenuUtil, CHUNK, TypeDLOGUtil, TypeDLOGDraw;	function CreateType (theDialog: DialogPtr): boolean;	procedure ReNameType;	procedure ReSizeType (theDialog: DialogPtr);	procedure SymmetrizeType;{еееееееееееееееееееееее}implementation {е$S TypeNewDLOG}{-----------------------------------------------------------------------------}	function CheckTypeName (ds: str255): boolean;		var			typenumber, j: integer;	begin		CheckTypeName := false;		typeNumber := 0;{ first check to see if it matches MacClade's names for types}		for j := 1 to usedef - 1 do			if ds = MakeSmall(TypeName(j)) then				begin					typenumber := 1;					leave;				end;{now check to see if it matches any of the NEXUS names of types, or names of user-defined types}		if typenumber = 0 then			typenumber := GetTypNum(ds);{now process what we've found}		if (typenumber <> 0) then			if typenumber < usedef then				InstantError(254)			else				CheckTypeName := CWarning('A type by that name already exists. Are you sure you want to create another?', 'Create', 'Cancel')		else			CheckTypeName := true;	end;{-----------------------------------------------------------------------------}	function CreateType (theDialog: DialogPtr): boolean;		label			1;		var			TD: DialogPtr;			namestr: str255;			firstrow: integer;			cell: point;			tempP: WindowPtr;			createprotpars: boolean;			localItemHit: integer;	begin		CreateType := false;		createprotpars := false;		StartDLOG(341, TD, tempP);		myShowDialog(TD);		namestr := 'Untitled';		SetDLOGText(TD, 4, namestr, true);		EnableDisableDLOGItem(TD, 5, (datatype = protein) and showmatrix, false);		ItemCheckMark(TD, 5, (datatype = protein) & createprotpars);1:		FrameButton(TD, 1);		repeat			ModalDialog(nil, localItemHit);			if datatype = protein then				if localItemHit = 5 then					if editorOpen then						begin							createprotpars := not createprotpars;							ItemCheckMark(TD, 5, createprotpars);						end					else						begin							InstantInfo('This function is only available when the data editor is on the screen.');   {v3.01}							FrameButton(TD, 1);						end;		until localItemHit in [1, 2];		if localItemHit = 1 then			begin				namestr := GetEditText(TD, 4);				UnderLineToBlanks(namestr);				if not CheckTypeName(namestr) then					goto 1;			end;		EndDLOG(TD, tempP);		if localItemHit = 1 then			begin				AddType(namestr);				if badmemory then					exit(CreateType);{cell.h := 0;}{cell.v := ListCellofType(curType);}				LSetSelect(false, curTypeCell, typList);				specchanged := true;				if createprotpars then					begin						CreateProtParsType(namestr);{InvalidateWindowRect(myGetWindowPtrForDialog(theDialog),WindowPortRect(myGetWindowPtrForDialog(theDialog)),false);}					end;				firstrow := LAddRow(1, -1, typList);				curType := numTypes;				CurTypeHdl := gettypeHdl(CurType);				curtypeCell.v := ListCellofType(curType);				if not showmatrix then					curtypeCell.v := curtypeCell.v + 1;     { as ListCellOfType will not catch the last , empty cst }{    curtypeCell := cell;}				namestr := CopyString(namestr, 1, typesig);				LSetCell(Pointer(ord4(@namestr) + 1), length(namestr), curtypeCell, typList);				LSetSelect(true, curtypeCell, typList);				LAutoScroll(typList);				anyTypeChanged := true;			end;		CreateType := localitemhit = 1;	end;{-----------------------------------------------------------------------------}	procedure RenameType;		label			1;		var			TD: DialogPtr;			tempP: WindowPtr;			namestr: str255;			thecell: point;			db: boolean;			localItemHit: integer;	begin		StartDLOG(320, TD, tempP);		ParamText('type', '', '', '');		myShowDialog(TD);{get selected cell}		thecell := ListCellSelected(typList, true);		namestr := CurTypeHdl^^.name;		UnderLineToBlanks(namestr);		SetDLOGText(TD, 4, namestr, true);1:		FrameButton(TD, 1);		repeat			ModalDialog(nil, localItemHit);		until (localItemHit = OK) or (localItemHit = Cancel);		if localItemHit = OK then			begin				namestr := GetEditText(TD, 4);				UnderLineToBlanks(namestr);				namestr := CopyString(namestr, 1, typesig);				if not CheckTypeName(namestr) then					goto 1;			end;		EndDLOG(TD, tempP);		if localItemHit = OK then			begin				CurTypeHdl^^.name := namestr;				namestr := TypeListName(curtype);				LSetCell(Pointer(ord4(@namestr) + 1), length(namestr), thecell, typList);				if CurTypeHdl^^.inuse then					begin						if (traceshown = traceDiscrete) then							InvalidateWindow(chlegwindow, false);						if infoOpen[charinfo] then							InvalidateWindow(infoWindow[charinfo], true);					end;			end;	end;{-----------------------------------------------------------------------------}	procedure ChangeMaxMat (theDialog: DialogPtr; num: integer);		var			isfrom, isto: integer;	begin		if (num >= 1) and (num <= maxstate) then			begin				ZeroStepMatrixPos;				if num < maxmat then					begin						maxmat := num;						specchanged := true;						CurTypeHdl^^.max := num;						CurTypeHdl^^.setdefined := CurTypeHdl^^.setdefined * [0..num];						CheckMaxMat;						ButHilite(theDialog);						ReDrawTypeSpecs(theDialog, 8);						DrawMatScrolls;					end				else if num > maxmat then					begin						for isfrom := (maxmat + 1) to num do							for isto := 0 to isfrom - 1 do								if curtypeHdl^^.isreal then									CurTypeHdl^^.dist[isfrom, isto] := TypeInflate								else									CurTypeHdl^^.dist[isfrom, isto] := 1;						for isto := (maxmat + 1) to num do							for isfrom := 0 to isto - 1 do								if curtypeHdl^^.isreal then									CurTypeHdl^^.dist[isfrom, isto] := TypeInflate								else									CurTypeHdl^^.dist[isfrom, isto] := 1;						for isto := (maxmat + 1) to num do							CurTypeHdl^^.dist[isto, isto] := 0;						CurTypeHdl^^.max := num;						CurTypeHdl^^.setdefined := CurTypeHdl^^.setdefined + [maxmat + 1..num];						maxmat := num;						specchanged := true;						CheckMaxMat;						ButHilite(theDialog);						ReDrawTypeSpecs(theDialog, 8);						DrawMatScrolls;					end;				TypeEdited(curTypeHdl);			end		else			Beep;	end;{-----------------------------------------------------------------------------}	procedure ReSizeType (theDialog: DialogPtr);		label			1;		var			TD: DialogPtr;			matsize: integer;			tempP: WindowPtr;			ds: str255;			localItemHit: integer;	begin		StartDLOG(566, TD, tempP);		myShowDialog(TD);		SetDLOGText(TD, 4, CharOfNum(maxmat), true);1:		SelectDialogItemText(TD, 4, 0, 32767);		FrameButton(TD, 1);		repeat			ModalDialog(nil, localItemHit);		until localItemHit in [1, 2];		if localItemHit = 1 then			begin				ds := GetEditText(TD, 4);				if (length(ds) > 1) & NumericalToken(ds) then   {accepts integers 10 or more}					matsize := TokenToInteger(ds, false)				else					matsize := NumOfChar(ds[1], 0, 0);				if (matsize < 1) or (matsize > maxstate) then					begin						InstantError(255);						goto 1;					end;			end;		EndDLOG(TD, tempP);		if (localItemHit = 1) and (matsize <> maxmat) then			ChangeMaxMat(theDialog, matsize);	end;{-----------------------------------------------------------------------------}	procedure SymmetrizeType;		const			copyup = 3;			copydown = 4;			average = 5;		var			TD: DialogPtr;			tempP: WindowPtr;			toreal: boolean;			symby, avg, j, t, inflatevalue: integer;			localItemHit: integer;{..........}		procedure CheckSym;		begin			ItemCheckMark(TD, 3, symby = copyup);			ItemCheckMark(TD, 4, symby = copydown);			ItemCheckMark(TD, 5, symby = average);			EnableDisableDLOGITem(TD, 9, (symby = average) and not (curtypeHdl^^.isreal), true);			ItemCheckMark(TD, 9, toreal);		end;{..........}	begin		symby := average;		toreal := true;		StartDLOG(592, TD, tempP);		myShowDialog(TD);		FrameButton(TD, 1);		CheckSym;		repeat			ModalDialog(nil, localItemHit);			if localItemHit in [3..5] then				symby := localItemHit			else if localItemHit = 9 then				toreal := not toreal;			CheckSym;		until localItemHit in [1, 2];		EndDLOG(TD, tempP);		if localItemHit = 1 then			begin				if symby = copyup then					begin						for t := 0 to maxmat do							for j := t + 1 to maxmat do								CurTypeHdl^^.dist[t, j] := CurTypeHdl^^.dist[j, t];					end				else if symby = copydown then					begin						for t := 0 to maxmat do							for j := t + 1 to maxmat do								CurTypeHdl^^.dist[j, t] := CurTypeHdl^^.dist[t, j];					end				else if symby = average then					begin						if toreal and not CurTypeHdl^^.isreal then							begin								inflatevalue := typeinflate;								curTypeHdl^^.isreal := true;							end						else							inflatevalue := 1;						for t := 0 to maxmat do							for j := t + 1 to maxmat do								begin									if (CurTypeHdl^^.dist[t, j] = infinity) or (CurTypeHdl^^.dist[j, t] = infinity) then										avg := infinity									else										avg := ((CurTypeHdl^^.dist[t, j] + CurTypeHdl^^.dist[j, t]) * inflatevalue) div 2;									CurTypeHdl^^.dist[t, j] := avg;									CurTypeHdl^^.dist[j, t] := avg;								end;					end;				InvalidateWindowRect(myGetWindowPtrForDialog(editTypeDialog),SpecRect,false);				TypeEdited(curTypeHdl);			end;	end;end.