unit NexusBlocks;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{ееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, 		TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  UtilLibInterface, MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, 		ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, TypeUtil, CharUtil, TreeUtil, 		MenuUtil,ReadWriteUtil,ReadUtil,WriteUtil;	procedure ReturnNexusBlockText;	procedure CloseTextWindow (whichText: integer; returnText: boolean);	procedure CloseTextWindowIfOpen (whichText: integer; returnText: boolean);	procedure SetContinuousBlockName;	function FindEndofBlock(theBlock: integer; storeForeign: boolean): boolean;	procedure AppendNewLineToBlock (blockType: integer);	procedure AppendStringToBlock (blockType: integer; token: str255);	procedure AppendHandleToBlock (blockType: integer; H: Handle);	procedure ReadForeignLineIntoNexusBlockPtr (theNexusBlock: NexusBlockPtr; firsttoken: str255);	procedure ReadForeignLine (blockType: integer; firsttoken: str255);	procedure WriteForeignLinesInBlock (blockType: integer);	procedure EmptyForeignBlockText (blockType: integer);	function ForeignLinesInBlockNumber(blockNumber: integer): boolean;	function ForeignLinesInBlock(blockType: integer): boolean;	function SizeOfNexusBlockText(blockType: integer): longint;	function NexusBlock(blockNumber: integer): NexusBlockPtr;		procedure InitNexusBlockPtr(theNexusBlock: NexusBlockPtr);	procedure InitNexusBlock(blockNumber: integer);	procedure SetNexusBlockCursor(blockType: integer);	procedure AddNewNexusBlock(name: str255; blockType: integer; nativeBlock: boolean);	procedure InsertNexusBlock(beforeBlock: NexusBlockPtr; var newBlock: NexusBlockPtr; blockType: integer; nativeBlock: boolean; name: str255);	procedure AddNativeNexusBlock(blockType: integer);	procedure AddForeignNexusBlock(blockName: str255; var newBlock: NexusBlockPtr);	procedure AddRemainingNativeNexusBlocks;		function NativeBlockName(blockType: integer): str255;	function BlockTypeFromNativeBlockName(blockName: str255): integer;	function MatchesActiveNexusBlock(title: str255; blockType: integer): boolean;	procedure DestroyNexusBlockPtr( theNexusBlock: NexusBlockPtr);	procedure DestroyNexusBlock(blockNumber: integer);	procedure EmptyNexusBlocks;		function NexusBlockNumberFromBlockName(blockName: str255): integer;	function NexusBlockFromBlockType(blockType: integer): NexusBlockPtr;	function NextNativeNexusBlock(theNexusBlock: NexusBlockPtr): NexusBlockPtr;	procedure SetNexusBlockTitle(blockType: integer; title: str255);	procedure SetNexusBlockLinkText(blockType: integer; linkText: str255);	function NexusBlockTitle(nexusBlockNumber: integer): str255;	function NexusBlockLinkText(nexusBlockNumber: integer): str255;	procedure WriteNexusBlockTitle(theNexusBlock: NexusBlockPtr);	procedure WriteNexusBlockLinkText(theNexusBlock: NexusBlockPtr);{	procedure ReadNexusBlockTitle(theNexusBlock: NexusBlockPtr);	procedure ReadNexusBlockLinkText(theNexusBlock: NexusBlockPtr);}	procedure QueryUserNexusBlockTitle(nexusBlockNumber: integer);	procedure SetNexusBlockName(blockNumber: integer; name: str255);	procedure SetNexusBlockWrite(blockNumber: integer; doWrite: boolean);	procedure SelectNexusBlock(blockNumber: integer; on: boolean);	function NexusBlockSelected(blockNumber: integer): boolean;	function NexusBlockForeign(blockNumber: integer): boolean;	function NexusBlockWillWrite(blockNumber: integer): boolean;	function NexusBlockDisplayName(blockNumber: integer): str255;	function NexusBlockIsEditable (theNexusBlock: NexusBlockPtr): boolean;	function ShouldWriteNexusBlock(blockType: integer): boolean;	procedure AdjustAllNexusBlockWillWrites;	{$SETC NEWNEXUSBLOCK=TRUE}	{ееееееееееееееееееееее}implementation {е$S NEXUSBlocks} {----------------------------------------------------------------------------}	procedure AppendNewLineToNexusBlockPtr (theNexusBlock: NexusBlockPtr);	begin		if theNexusBlock<> nil then			if NexusDelim = ExpCR then				AppendToHandle(theNexusBlock^.H, concat(chr(13), chr(9)))			else if NexusDelim = ExpLF then				AppendToHandle(theNexusBlock^.H, concat(chr(10), chr(9)))			else if NexusDelim = ExpCRLF then				AppendToHandle(theNexusBlock^.H, concat(chr(13), chr(10), chr(9)));	end;{----------------------------------------------------------------------------}	procedure AppendNewLineToBlock (blockType: integer);	var theNexusBlock: NexusBlockPtr;	begin		theNexusBlock := NexusBlockFromBlockType(blockType);		if theNexusBlock<> nil then			AppendNewLineToNexusBlockPtr(theNexusBlock);	end;{----------------------------------------------------------------------------}	procedure AppendStringToBlock (blockType: integer; token: str255);	var theNexusBlock: NexusBlockPtr;	begin		theNexusBlock := NexusBlockFromBlockType(blockType);		if theNexusBlock<> nil then			AppendToHandle(theNexusBlock^.H, token);	end;{----------------------------------------------------------------------------}	procedure AppendHandleToBlock (blockType: integer; H: Handle);	var db: boolean;		theNexusBlock: NexusBlockPtr;	begin		theNexusBlock := NexusBlockFromBlockType(blockType);		if theNexusBlock<> nil then			db := OSSuccessful(HandAndHand(H, theNexusBlock^.H));	end;{----------------------------------------------------------------------------}	procedure ReadForeignLineIntoNexusBlockPtr (theNexusBlock: NexusBlockPtr; firsttoken: str255);		var			H: Handle;			db: boolean;	begin		if theNexusBlock<> nil then			begin				H := NewHandle(0);				StringToH(firsttoken, H);				AppendToHandle(H, ' ');				LineToH(H);				if not badmemory then					begin						AppendNewLineToNexusBlockPtr(theNexusBlock);						currentIOPosition := 64;   {v3.05}						db := OSSuccessful(HandAndHand(H, theNexusBlock^.H));					end;				ZapHandle(H);			end;	end;{----------------------------------------------------------------------------}	procedure ReadForeignLine (blockType: integer; firsttoken: str255);		var			theNexusBlock: NexusBlockPtr;	begin		SetCursID(fish);		theNexusBlock := NexusBlockFromBlockType(blockType);		if theNexusBlock<> nil then			ReadForeignLineIntoNexusBlockPtr(theNexusBlock,firstToken);		SetNexusBlockCursor(blockType);	end;{----------------------------------------------------------------------------}	procedure WriteForeignLinesInBlock (blockType: integer);	var theNexusBlock: NexusBlockPtr;	begin		if ForeignLinesInBlock(blockType) then			begin				theNexusBlock := NexusBlockFromBlockType(blockType);				if theNexusBlock<> nil then					begin						SetCursID(fish);					{	putReturn;}						WriteHandle(theNexusBlock^.H,NexusDelim);						putReturn;						SetNexusBlockCursor(blockType);					end;			end;	end;{-----------------------------------------------------------------------------}	procedure EmptyForeignBlockText (blockType: integer);	var oldState: SignedByte;		theNexusBlock: NexusBlockPtr;	begin		theNexusBlock := NexusBlockFromBlockType(blockType);		if theNexusBlock<> nil then			begin				UnlockHandle(theNexusBlock^.H, oldstate);				SetHandleSize(theNexusBlock^.H, 0);				ResetHandle(theNexusBlock^.H, oldstate);			end;	end;{-----------------------------------------------------------------------------}	function ForeignLinesInBlock(blockType: integer): boolean;	var theNexusBlock: NexusBlockPtr;	begin		theNexusBlock := NexusBlockFromBlockType(blockType);		if theNexusBlock<> nil then			ForeignLinesInBlock := GetHandleSize(theNexusBlock^.H) >= 4;	end;{-----------------------------------------------------------------------------}	function ForeignLinesInBlockNumber(blockNumber: integer): boolean;	var theNexusBlock: NexusBlockPtr;	begin		theNexusBlock := NexusBlock(blockNumber);		if theNexusBlock<> nil then			ForeignLinesInBlockNumber := GetHandleSize(theNexusBlock^.H) >= 4;	end;{-----------------------------------------------------------------------------}	function SizeOfNexusBlockText(blockType: integer): longint;	var theNexusBlock: NexusBlockPtr;	begin		theNexusBlock := NexusBlockFromBlockType(blockType);		if theNexusBlock<> nil then			SizeOfNexusBlockText := GetHandleSize(theNexusBlock^.H);	end;	{-----------------------------------------------------------------------------}{-----------------------------------------------------------------------------}{-----------------------------------------------------------------------------}	function NexusBlock(blockNumber: integer): NexusBlockPtr;	var theNexusBlock: NexusBlockPtr;		j : integer;	begin		if blockNumber<=0 then			theNexusBlock :=nil		else			begin				theNexusBlock := NexusBlocks;				if blockNumber>1 then					for j := 1 to blockNumber-1 do						if theNexusBlock <> nil then							theNexusBlock := theNexusBlock^.next;			end;		NexusBlock := theNexusBlock;	end;{-----------------------------------------------------------------------------}	procedure InitNexusBlockPtr(theNexusBlock: NexusBlockPtr);	begin		if theNexusBlock <> nil then			with theNexusBlock^ do				begin					prev:= nil;					next := nil;					selected:= false;					blockType := notABlock;					nativeBlock := false;					willWriteBlock := false;					blockName := '';					linkText := '';					title := '';					SetHandleSize(H,0);				end;	end;{-----------------------------------------------------------------------------}	procedure InitNexusBlock(blockNumber: integer);	var theNexusBlock: NexusBlockPtr;	begin		theNexusBlock := NexusBlock(blockNumber);		InitNexusBlockPtr(theNexusBlock);	end;{-----------------------------------------------------------------------------}	procedure AddNewNexusBlock(name: str255; blockType: integer; nativeBlock: boolean);	var theNexusBlock: NexusBlockPtr;	begin		theNexusBlock := NexusBlocks;		if theNexusBlock <> nil then			while theNexusBlock^.next <> nil do				begin					theNexusBlock := theNexusBlock^.next;				end;		theNexusBlock^.next := NexusBlockPtr(NewPtrClear(SizeOf(NexusBlockRecord)));		InitNexusBlockPtr(theNexusBlock^.next);		theNexusBlock^.next^.blockName := name;		theNexusBlock^.next^.blockType := blockType;		theNexusBlock^.next^.nativeBlock := nativeBlock;		if not nativeBlock then			theNexusBlock^.next^.willWriteBlock := true;		theNexusBlock^.next^.H := NewHandle(0);						theNexusBlock^.next^.prev := theNexusBlock;		numNexusBlocks:= numNexusBlocks+1;			end;		{-----------------------------------------------------------------------------}	procedure AddForeignNexusBlock(blockName: str255; var newBlock: NexusBlockPtr);	begin		AddNewNexusBlock(blockName,maximumBlock,false);		newBlock:= NexusBlock(numNexusBlocks);	end; {-----------------------------------------------------------------------------}	procedure SetContinuousBlockName;	var theNexusBlock: NexusBlockPtr;	begin		theNexusBlock := NexusBlockFromBlockType(continuousBlock);		if theNexusBlock <> nil then			if fullNexus1 then  				theNexusBlock^.blockName := NativeBlockName(charactersBlock)			else				theNexusBlock^.blockName := NativeBlockName(continuousBlock);	end;{-----------------------------------------------------------------------------}	function NativeBlockName(blockType: integer): str255;	begin		case blockType of 			maccladeStartBlock: 		NativeBlockName := 'MacCladeStart';			taxaBlock: 		NativeBlockName := 'Taxa';			charactersBlock: 	NativeBlockName := 'Characters';			dataBlock:			NativeBlockName := 'Data';			continuousBlock:	NativeBlockName := 'Continuous';			codonsBlock:		NativeBlockName := 'Codons';			setsBlock:			NativeBlockName := 'Sets';			labelsBlock:		NativeBlockName := 'Labels';			assumptionsBlock:	NativeBlockName := 'Assumptions';			treesDataBlock,treeFileBlock:		NativeBlockName := 'Trees';			notesBlock:			NativeBlockName := 'Notes';			MacCladeBlock:		NativeBlockName := 'MacClade';			otherwise			NativeBlockName:= '';		end;	end;{-----------------------------------------------------------------------------}	function NativeBlockNameSynonym(blockType: integer): str255;	begin		case blockType of 			maccladeStartBlock: NativeBlockNameSynonym := 'notABlock';			taxaBlock: 		NativeBlockNameSynonym := 'Taxon';			charactersBlock: 	NativeBlockNameSynonym := 'Character';			dataBlock:			NativeBlockNameSynonym := 'Data';			continuousBlock:	NativeBlockNameSynonym := 'notABlock';			codonsBlock:		NativeBlockNameSynonym := 'Codon';			setsBlock:			NativeBlockNameSynonym := 'Set';			labelsBlock:		NativeBlockNameSynonym := 'Label';			assumptionsBlock:	NativeBlockNameSynonym := 'Assumption';			treesDataBlock,treeFileBlock:		NativeBlockNameSynonym := 'Tree';			notesBlock:		NativeBlockNameSynonym := 'Note';			MacCladeBlock:		NativeBlockNameSynonym := 'MacClade.Block';			otherwise			NativeBlockNameSynonym:= 'notABlock';		end;	end;{-----------------------------------------------------------------------------}	procedure SetNexusBlockCursor(blockType: integer);	begin		case blockType of 			maccladeStartBlock: 	SetCursID(scallop);			taxaBlock: 		SetCursID(mushrooms);			charactersBlock: 	SetCursID(carabid);			dataBlock:			SetCursID(carabid);			continuousBlock:	SetCursID(owlfly);			codonsBlock:		SetCursID(DNAcurs);			labelsBlock:		SetCursID(fern);			setsBlock:			SetCursID(virus);			assumptionsBlock:	SetCursID(anemone);			treesDataBlock:	SetCursID(tree);			treeFileBlock:		SetCursID(tree);			notesBlock:		SetCursID(starfish);			MacCladeBlock:		SetCursID(scallop);			otherwise			SetCursID(fish);		end;	end;{-----------------------------------------------------------------------------}	function BlockTypeFromBlockNumber(blockNumber: integer): integer;	var theNexusBlock: NexusBlockPtr;	begin		BlockTypeFromBlockNumber := notABlock;		theNexusBlock := NexusBlock(blockNumber);		if theNexusBlock <> nil then			BlockTypeFromBlockNumber := theNexusBlock^.blocktype;	end;{-----------------------------------------------------------------------------}	function BlockTypeFromNativeBlockName(blockName: str255): integer;	var nativeName, synonym: str255;		blockType: integer;	begin		BlockTypeFromNativeBlockName := foreignBlock;		for blockType := 0 to numblocks do			begin				nativeName := NativeBlockName(blockType);				synonym :=NativeBlockNameSynonym(blockType);				if StringsEqual(@blockName,@nativeName,maxTok) | StringsEqual(@blockName,@synonym,maxTok) then					begin						BlockTypeFromNativeBlockName := blockType;						leave;					end;			end;	end;{-----------------------------------------------------------------------------}	procedure AddNativeNexusBlock(blockType: integer);	begin		AddNewNexusBlock(NativeBlockName(blockType),blocktype,true);	end;{-----------------------------------------------------------------------------}	function BlocksThatMustBeBeforeBlock(blockType: integer): blockSet;	begin		case blockType of 			taxaBlock: 		BlocksThatMustBeBeforeBlock := [maccladeStartBlock];			charactersBlock: 	BlocksThatMustBeBeforeBlock := [maccladeStartBlock,taxaBlock, dataBlock];			dataBlock:			BlocksThatMustBeBeforeBlock := [maccladeStartBlock, taxaBlock];			continuousBlock:	BlocksThatMustBeBeforeBlock := [maccladeStartBlock,taxaBlock, dataBlock];			codonsBlock:		BlocksThatMustBeBeforeBlock := [maccladeStartBlock,taxaBlock,charactersBlock, dataBlock];			setsBlock:			BlocksThatMustBeBeforeBlock := [maccladeStartBlock,taxaBlock,charactersBlock, dataBlock, continuousBlock,codonsBlock];			labelsBlock:		BlocksThatMustBeBeforeBlock := [maccladeStartBlock,taxaBlock,charactersBlock, dataBlock, continuousBlock];			assumptionsBlock:	BlocksThatMustBeBeforeBlock := [maccladeStartBlock,taxaBlock,charactersBlock, dataBlock, continuousBlock,codonsBlock, setsBlock];			treesDataBlock:	BlocksThatMustBeBeforeBlock := [maccladeStartBlock,taxaBlock, dataBlock];			notesBlock:		BlocksThatMustBeBeforeBlock := [maccladeStartBlock,taxaBlock,charactersBlock, dataBlock, continuousBlock, setsBlock];			MacCladeBlock:		BlocksThatMustBeBeforeBlock := [maccladeStartBlock,taxaBlock,charactersBlock, dataBlock];			otherwise 		BlocksThatMustBeBeforeBlock := [];		end;	end;{-----------------------------------------------------------------------------}	function BlocksThatRequireNativeBlock(blockType: integer): blockSet;	begin		case blockType of 			taxaBlock: 		BlocksThatRequireNativeBlock := [dataBlock,charactersBlock, continuousBlock,setsBlock,labelsBlock,treesDataBlock, notesBlock, MacCladeBlock];			charactersBlock: 	BlocksThatRequireNativeBlock := [codonsBlock, setsBlock,labelsBlock,assumptionsBlock, notesBlock, MacCladeBlock];			dataBlock:			BlocksThatRequireNativeBlock := [charactersBlock, continuousBlock,codonsBlock, setsBlock,labelsBlock,assumptionsBlock,treesDataBlock, notesBlock, MacCladeBlock];			continuousBlock:	BlocksThatRequireNativeBlock := [continuousBlock,setsBlock,labelsBlock,assumptionsBlock,notesBlock, MacCladeBlock];			codonsBlock:		BlocksThatRequireNativeBlock := [setsBlock,labelsBlock,assumptionsBlock,MacCladeBlock];			setsBlock:			BlocksThatRequireNativeBlock := [assumptionsBlock,MacCladeBlock];			labelsBlock:		BlocksThatRequireNativeBlock := [setsBlock,assumptionsBlock,MacCladeBlock];			assumptionsBlock:	BlocksThatRequireNativeBlock := [MacCladeBlock];			treesDataBlock:	BlocksThatRequireNativeBlock := [MacCladeBlock];			notesBlock:		BlocksThatRequireNativeBlock := [MacCladeBlock];			MacCladeBlock:		BlocksThatRequireNativeBlock := [];			otherwise 		BlocksThatRequireNativeBlock := [];		end;	end;{-----------------------------------------------------------------------------}	function LastOfBlockSet(beforeBlocks: blockSet; var beforeBlockNumber: integer): NexusBlockPtr;	var lastBlock: NexusBlockPtr;	begin		lastBlock:= NexusBlock(numNexusBlocks);		beforeBlockNumber := numNexusBlocks;		repeat			if lastBlock^.blockType in beforeBlocks then				leave;			lastBlock := lastBlock^.prev;			beforeBlockNumber := beforeBlockNumber - 1;		until (lastBlock = nil);		LastOfBlockSet := lastBlock;	end;{-----------------------------------------------------------------------------}	function FirstOfBlockSet(afterBlocks: blockSet; var afterBlockNumber: integer): NexusBlockPtr;	var firstBlock: NexusBlockPtr;	begin		firstBlock:= NexusBlock(1);		afterBlockNumber := 1;		repeat			if firstBlock^.blockType in afterBlocks then				leave;			firstBlock := firstBlock^.next;			afterBlockNumber := afterBlockNumber + 1;		until (firstBlock = nil);		FirstOfBlockSet := firstBlock;	end;{-----------------------------------------------------------------------------}	procedure InsertNativeBlockBetweenExisitingBlocks(blockType: integer);	var afterBlocks,beforeblocks: blockSet;		blockToInsertBefore, LastOfBeforeBlocks, FirstOfAfterBlocks: NexusBlockPtr;		newBlock: NexusBlockPtr; 		beforeBlockNumber, afterBlockNumber: integer;	begin		 if NexusBlockFromBlockType(blockType)=nil then			begin				beforeblocks := BlocksThatMustBeBeforeBlock(blockType);				afterBlocks := BlocksThatRequireNativeBlock(blockType);				LastOfBeforeBlocks := LastOfBlockSet(beforeBlocks, beforeBlockNumber);				FirstOfAfterBlocks := FirstOfBlockSet(afterBlocks, afterBlockNumber);				if beforeBlockNumber >= afterBlockNumber then					NewError(427,0);				InsertNexusBlock(FirstOfAfterBlocks,newBlock,blockType, true, NativeBlockName(blockType));			end	end;{-----------------------------------------------------------------------------}	procedure AddRemainingNativeNexusBlocks;			begin		 InsertNativeBlockBetweenExisitingBlocks(taxaBlock);		 InsertNativeBlockBetweenExisitingBlocks(charactersBlock);		 InsertNativeBlockBetweenExisitingBlocks(dataBlock);		 InsertNativeBlockBetweenExisitingBlocks(continuousBlock);		 InsertNativeBlockBetweenExisitingBlocks(codonsBlock);		 InsertNativeBlockBetweenExisitingBlocks(labelsBlock);		 InsertNativeBlockBetweenExisitingBlocks(setsBlock);		 InsertNativeBlockBetweenExisitingBlocks(assumptionsBlock);		 InsertNativeBlockBetweenExisitingBlocks(treesDataBlock);		 InsertNativeBlockBetweenExisitingBlocks(notesBlock);		 if NexusBlockFromBlockType(MacCladeBlock)=nil then		 	AddNativeNexusBlock(MacCladeBlock);		 SetContinuousBlockName;		 AdjustAllNexusBlockWillWrites;	end;{-----------------------------------------------------------------------------}	procedure InsertNexusBlock(beforeBlock: NexusBlockPtr; var newBlock: NexusBlockPtr; blockType: integer; nativeBlock: boolean; name: str255);	var theNexusBlock,prevBlock: NexusBlockPtr;	begin		if beforeBlock=nil then			begin				AddNewNexusBlock(name,blockType,nativeBlock);				newBlock:= NexusBlock(numNexusBlocks);			end		else			begin				theNexusBlock := NexusBlockPtr(NewPtrClear(SizeOf(NexusBlockRecord)));				InitNexusBlockPtr(theNexusBlock);				theNexusBlock^.blockName := name;				theNexusBlock^.blockType := blockType;				theNexusBlock^.nativeBlock := nativeBlock;				if not nativeBlock then					theNexusBlock^.willWriteBlock := true;				theNexusBlock^.H := NewHandle(0);					prevBlock := beforeBlock^.prev;				beforeBlock^.prev := theNexusBlock;				theNexusBlock^.next := beforeBlock;				theNexusBlock^.prev := prevBlock;				numNexusBlocks:= numNexusBlocks+1;				if prevBlock<> nil then					prevBlock^.next := theNexusBlock				else					NexusBlocks := theNexusBlock;				newBlock := theNexusBlock;			end;	end;{-----------------------------------------------------------------------------}	procedure DestroyNexusBlockPtr( theNexusBlock: NexusBlockPtr);	begin		if theNexusBlock = nexusBlockBeingEdited then				CloseTextWindow(nexusBlockText, false);		if (theNexusBlock = NexusBlocks) then			begin				if  (numNexusBlocks>1) then					begin						NexusBlocks := theNexusBlock^.next;						NexusBlocks^.prev := nil;						numNexusBlocks:= numNexusBlocks-1;						ZapHandle(theNexusBlock^.H);						ZapPointer(theNexusBlock);					end				else					begin						InitNexusBlockPtr(theNexusBlock);					end;			end		else if theNexusBlock <> nil then			begin				if theNexusBlock^.next <> nil then					theNexusBlock^.next^.prev := theNexusBlock^.prev;				if theNexusBlock^.prev <> nil then					theNexusBlock^.prev^.next := theNexusBlock^.next;				numNexusBlocks:= numNexusBlocks-1;				ZapHandle(theNexusBlock^.H);				ZapPointer(theNexusBlock);			end;	end;{-----------------------------------------------------------------------------}	procedure DestroyNexusBlock(blockNumber: integer);	var theNexusBlock: NexusBlockPtr;	begin		theNexusBlock := NexusBlock(blockNumber);		DestroyNexusBlockPtr(theNexusBlock);	end;{-----------------------------------------------------------------------------}	procedure EmptyNexusBlocks;	var theNexusBlock, nextBlock: NexusBlockPtr;	begin		theNexusBlock := NexusBlocks^.next;		while theNexusBlock<> nil do			begin				nextBlock := theNexusBlock^.next;				DestroyNexusBlockPtr(theNexusBlock);				theNexusBlock:= nextBlock;			end;{		theNexusBlock := NexusBlocks;		while theNexusBlock<> nil do			begin				if not theNexusBlock^.nativeBlock then					begin						nextBlock := theNexusBlock^.next;						DestroyNexusBlockPtr(theNexusBlock);						theNexusBlock:= nextBlock;					end				else					begin						SetHandleSize(theNexusBlock^.H, 0);						theNexusBlock := theNexusBlock^.next;					end;			end;}	end;{----------------------------------------------------------------------------}	function NexusBlockFromBlockType(blockType: integer): NexusBlockPtr;	var theNexusBlock: NexusBlockPtr;		j : integer;	begin		NexusBlockFromBlockType := nil;		theNexusBlock := NexusBlocks;		while theNexusBlock<> nil do			begin				if theNexusBlock^.blockType= blockType then					begin						NexusBlockFromBlockType := theNexusBlock;						leave;					end				else					theNexusBlock:= theNexusBlock^.next;			end;	end;{----------------------------------------------------------------------------}	function NexusBlockNumberFromBlockName(blockName: str255): integer;	var theNexusBlock: NexusBlockPtr;		j : integer;		blocknumber: integer;	begin		NexusBlockNumberFromBlockName := 0;		theNexusBlock := NexusBlocks;		blockNumber := 1;		while theNexusBlock<> nil do			begin				if StringsEqual(@theNexusBlock^.blockName,@blockName,255) then					begin						NexusBlockNumberFromBlockName := blockNumber;						leave;					end				else					begin						theNexusBlock:= theNexusBlock^.next;						blockNumber := blockNumber+1;					end;			end;	end;{----------------------------------------------------------------------------}	function NexusBlockNumberFromBlockType(blockType: integer): integer;	{returns the FIRST block of that type}	var theNexusBlock: NexusBlockPtr;		j : integer;		blocknumber: integer;	begin		NexusBlockNumberFromBlockType := 0;		theNexusBlock := NexusBlocks;		blockNumber := 1;		while theNexusBlock<> nil do			begin				if theNexusBlock^.blockType= blockType then					begin						NexusBlockNumberFromBlockType := blockNumber;						leave;					end				else					begin						theNexusBlock:= theNexusBlock^.next;						blockNumber := blockNumber+1;					end;			end;	end;{----------------------------------------------------------------------------}	function NextNativeNexusBlock(theNexusBlock: NexusBlockPtr): NexusBlockPtr;	begin		NextNativeNexusBlock := nil;		if theNexusBlock = nil then 			NextNativeNexusBlock := NexusBlocks		else			begin				theNexusBlock:= theNexusBlock^.next;				while theNexusBlock<> nil do					begin						if theNexusBlock^.nativeBlock then							begin								NextNativeNexusBlock := theNexusBlock;								leave;							end						else							theNexusBlock:= theNexusBlock^.next;					end;			end;	end;{----------------------------------------------------------------------------}	procedure SetNexusBlockTitle(blockType: integer; title: str255);	var theNexusBlock: NexusBlockPtr;	begin		theNexusBlock := NexusBlockFromBlockType(blockType);		if theNexusBlock <> nil then			theNexusBlock^.title := title;	end;{-----------------------------------------------------------------------------}	procedure SetNumberedNexusBlockTitle(nexusBlockNumber: integer; title: str255);	var theNexusBlock: NexusBlockPtr;	begin		theNexusBlock := NexusBlock(nexusBlockNumber);		if theNexusBlock <> nil then			theNexusBlock^.title := title;	end;{----------------------------------------------------------------------------}	procedure SetNexusBlockLinkText(blockType: integer; linkText: str255);	var theNexusBlock: NexusBlockPtr;	begin		theNexusBlock := NexusBlockFromBlockType(blockType);		if theNexusBlock <> nil then			theNexusBlock^.linkText := linkText;	end;{-----------------------------------------------------------------------------}	function NexusBlockTitle(nexusBlockNumber: integer): str255;	var theNexusBlock: NexusBlockPtr;	begin		NexusBlockTitle := '';		theNexusBlock := NexusBlock(nexusBlockNumber);		if theNexusBlock <> nil then			NexusBlockTitle := theNexusBlock^.title;	end;{-----------------------------------------------------------------------------}	function NexusBlockLinkText(nexusBlockNumber: integer): str255;	var theNexusBlock: NexusBlockPtr;	begin		NexusBlockLinkText := '';		theNexusBlock := NexusBlock(nexusBlockNumber);		if theNexusBlock <> nil then			NexusBlockLinkText := theNexusBlock^.linkText;	end;{-----------------------------------------------------------------------------}	procedure QueryUserNexusBlockTitle(nexusBlockNumber: integer);	var ds: str255;	begin		ds := NexusBlockTitle(nexusBlockNumber);		if GetSimpleString("Rename NEXUS block:", ds) then			SetNumberedNexusBlockTitle(nexusBlockNumber,ds);	end;{-----------------------------------------------------------------------------}	procedure WriteNexusBlockTitle(theNexusBlock: NexusBlockPtr);	var ds: str255;	begin		if theNexusBlock<> nil then			begin				ds := theNexusBlock^.title;				if ds <> '' then					begin						putTabToken('TITLE ');						PrepareToken(ds,tnw);						puttoken(ds);						putSingleChar(';');						putReturn;					end;			end;	end;{-----------------------------------------------------------------------------}	function MatchesActiveNexusBlock(title: str255; blockType: integer): boolean;	var theNexusBlock: NexusBlockPtr;		ds: str255;	begin		MatchesActiveNexusBlock:= false;		theNexusBlock := NexusBlockFromBlockType(blockType);		if theNexusBlock<> nil then			begin				ds := theNexusBlock^.title;				MatchesActiveNexusBlock := StringsEqual(@ds,@title, 255);			end;	end;{-----------------------------------------------------------------------------}	procedure WriteNexusBlockLinkText(theNexusBlock: NexusBlockPtr);	var ds: str255;	begin		if theNexusBlock<> nil then			begin				ds := theNexusBlock^.linkText;				if ds <> '' then					begin						putTabToken('LINK ');						puttoken(ds);						putSingleChar(';');						putReturn;					end;			end;	end;{-----------------------------------------------------------------------------}	procedure ReadNexusBlockTitle(theNexusBlock: NexusBlockPtr);	var ds: str255;	begin		ds := GetFileToken(255);  		UnderlineToBlanks(ds);		if (theNexusBlock <> nil) & (ds<>';') then			begin				theNexusBlock^.title := ds;				Skipper([';'], true);				nexusBlockInfoShowTitleLink:= true;  			end;	end;{-----------------------------------------------------------------------------}	procedure ReadNexusBlockLinkText(theNexusBlock: NexusBlockPtr);	var startpos, endpos: longint;		ds: str255;	begin		startPos := fPos;		Skipper([';'], false);		endPos := fpos;		if (theNexusBlock <> nil) & (startPos<>endPos) then			begin				FilePiecetoP(startpos, endpos, Ptr(ord4(@ds)+1));				ds[0] := char(endPos-startPos);				theNexusBlock^.linkText := ds;				nexusBlockInfoShowTitleLink:= true;			end;		if next=';' then			next := nextchar;	end;{-----------------------------------------------------------------------------}	procedure SetNexusBlockName(blockNumber: integer; name: str255);	var theNexusBlock: NexusBlockPtr;	begin		theNexusBlock := NexusBlock(blockNumber);		if theNexusBlock <> nil then			begin				theNexusBlock^.blockName := name;				if (theNexusBlock = nexusBlockBeingEdited) & textWindowInfo[NexusBlockText]^.open then					SetWTitle(textWindow[NexusBlockText], concat('NEXUS Block: ', nexusBlockBeingEdited^.blockname));			end;			end;{-----------------------------------------------------------------------------}	procedure SetNexusBlockWrite(blockNumber: integer; doWrite: boolean);	var theNexusBlock: NexusBlockPtr;	begin		theNexusBlock := NexusBlock(blockNumber);		if theNexusBlock <> nil then			theNexusBlock^.willWriteBlock := doWrite;	end;{-----------------------------------------------------------------------------}	procedure SelectNexusBlock(blockNumber: integer; on: boolean);	var theNexusBlock: NexusBlockPtr;	begin		theNexusBlock := NexusBlock(blockNumber);		if theNexusBlock <> nil then			theNexusBlock^.selected := on;	end;{-----------------------------------------------------------------------------}	function NexusBlockSelected(blockNumber: integer): boolean;	var theNexusBlock: NexusBlockPtr;	begin		theNexusBlock := NexusBlock(blockNumber);		NexusBlockSelected := (theNexusBlock<> nil ) & theNexusBlock^.selected;	end;{-----------------------------------------------------------------------------}	function NexusBlockForeign(blockNumber: integer): boolean;	var theNexusBlock: NexusBlockPtr;	begin		theNexusBlock := NexusBlock(blockNumber);		NexusBlockForeign := (theNexusBlock<> nil ) & not theNexusBlock^.nativeBlock;	end;{-----------------------------------------------------------------------------}	function NexusBlockWillWrite(blockNumber: integer): boolean;	var theNexusBlock: NexusBlockPtr;	begin		theNexusBlock := NexusBlock(blockNumber);		NexusBlockWillWrite := (theNexusBlock<> nil ) &  theNexusBlock^.willWriteBlock;	end;{-----------------------------------------------------------------------------}	function NexusBlockDisplayName(blockNumber: integer): str255;	var theNexusBlock: NexusBlockPtr;		name: str255;	begin		theNexusBlock := NexusBlock(blockNumber);		if theNexusBlock = nil then			name := ''		else 			begin				name := theNexusBlock^.blockName;				if (theNexusBlock^.blockType = continuous) & fullnexus1 then					name := concat(name,' (conts.)');			end;		NexusBlockDisplayName := name;	end;{----------------------------------------------------------------------------}	function NexusBlockIsEditable (theNexusBlock: NexusBlockPtr): boolean;	begin		NexusBlockIsEditable := (theNexusBlock <> nil) & (not theNexusBlock^.nativeBlock | (theNexusBlock^.blocktype in [maccladeStartBlock,codonsBlock,setsBlock,labelsBlock,assumptionsBlock,treesDataBlock,notesBlock]));	end;{-----------------------------------------------------------------------------}	function ShouldWriteNexusBlock(blockType: integer): boolean;	begin		case blockType of			notABlock:				ShouldWriteNexusBlock := false;			maccladeStartBlock:				ShouldWriteNexusBlock := (datatype = standard32);			taxaBlock:				ShouldWriteNexusBlock := writeTaxaCharBlocks;			charactersBlock:				ShouldWriteNexusBlock := writeTaxaCharBlocks;			dataBlock:				ShouldWriteNexusBlock := not writeTaxaCharBlocks;			continuousBlock:				ShouldWriteNexusBlock := (numcontinuous > 0);   {| ForeignLinesInBlock(blockType)}					codonsBlock:				ShouldWriteNexusBlock := molecular | ForeignLinesInBlock(blockType);			setsBlock:				ShouldWriteNexusBlock := ForeignLinesInBlock(blockType) | (UserLinks[CharPartitionchain] > 0) |(UserLinks[charSetchain] > 0) | (UserLinks[taxSetchain] > 0) ; 			labelsBlock:				ShouldWriteNexusBlock := ForeignLinesInBlock(blockType) | (numCharPartNames > 1); 			assumptionsBlock:				ShouldWriteNexusBlock := true;					treesDataBlock:				ShouldWriteNexusBlock :=ForeignLinesInBlock(blockType)| nodes | (GetHandleSize(treedataH) > 2) | (UserLinks[datafileChain] > 0);			treefileblock:				ShouldWriteNexusBlock := false;			notesBlock:				ShouldWriteNexusBlock := SomeFeetPresent|ForeignLinesInBlock(blockType);			MacCladeBlock:				ShouldWriteNexusBlock := true;			foreignBlock:				ShouldWriteNexusBlock := true;			otherwise				ShouldWriteNexusBlock:= ForeignLinesInBlock(blockType);		end;	end;{-----------------------------------------------------------------------------}	procedure AdjustAllNexusBlockWillWrites;	var theBlock: integer;	begin		for theBlock := 1 to numNexusBlocks do			SetNexusBlockWrite(theBlock,ShouldWriteNexusBlock(BlockTypeFromBlockNumber(theBlock)));		if infoOpen[nexusblockinfo] then			invalidateWindow(infoWindow[nexusblockinfo], true);	end;{----------------------------------------------------------------------------}	procedure ReturnNexusBlockText;	var H: Handle;	begin		if (nexusBlockBeingEdited <> nil) then			begin				H := Handle(TEGetText(textWindowInfo[NexusBlockText]^.TE));				CopyHandles(H,nexusBlockBeingEdited^.H);				AdjustAllNexusBlockWillWrites;			end;	end;{----------------------------------------------------------------------------}	procedure CloseTextWindow (whichText: integer; returnText: boolean);	begin		if frontwindow = textWindow[whichText] then			begin				SetMenuItemText(FileMHdl, PrintingItem, 'Print...');				myDisableItem(FileMHdl, PrintingItem);			end;		HideWindow(textWindow[whichText]);		if quit then Exit(CloseTextWindow);		ReturnComplexDisplayMenu;		if returnText & (whichText=NexusBlockText) then			ReturnNexusBlockText;		textWindowInfo[whichText]^.open := false;	end;{----------------------------------------------------------------------------}	procedure CloseTextWindowIfOpen (whichText: integer; returnText: boolean);	begin		if textWindowInfo[whichText]^.open then			CloseTextWindow(whichText, returnText);	end;{-----------------------------------------------------------------------------}	function FindEndofBlock(theBlock: integer; storeForeign: boolean): boolean;{same as FindFileToken, but specialized for end of NEXUS blocks}		var			ds: str255;			found: boolean;	begin		repeat			ds := MakeCaps(GetFileToken(maxtok));			found := EndOfBlock(ds);			if (not found & storeForeign & (ds<>';')) then				ReadForeignLine(theBlock, ds);		until found or (fpos >= mcFileLength) or errorflag;		if not found and not errorflag then			InstantErrorPlus(244, ' END or ENDBLOCK');		FindEndofBlock := found;	end;end.