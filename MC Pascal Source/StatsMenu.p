unit StatsMenu;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, 		Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, 		Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, 		WindowUtil, ErrorUtil, EventUtil, GenUtil,  Thermos, TypeUtil, Equivocal, 		MenuUtil, BoxUtil, SetStates, ChartToType, StrUtil, Settings, TreeUtil, 		CharUtil, ChartMenu, Prohibitions, ChartWWrite, TaxonCHutil, SpreadUtil, 		WriteUtil, TreeDrawer, TraceAllChangesCalc, TraceControl, Coloring, Count,		LinkUtil, InfoWindows, Legends, TreeMaker, Windows, TreeGet, ReadTreeFile, 		WriteTreeFile, IncExcTaxa, Export, ChartWUtil, ChartWCalc, ChartWTable, ChartWindow,		Processes;	procedure DoCalcMenu (ItemNo: integer);{еееееееееееееееееееееее}implementation {е$S StatsMenu}{$SETC PAUPCOMM=FALSE}{$IFC PAUPCOMM}	const		kMacCladeClass = 'CLAD';		kPAUPClass = 'PAUP';		kQueryEventID = 'qury';		kCalcEventID = 'calc';		kIsFileOpenID = 'FOQC';		kSaveToLID = 'SToL';		kMCCommandID = 'MCcd';		kPAUPCommandID ='POPc';		kCloseFileNoDialogID = 'CFnd';		kSaveToLTTID = 'STTT';		keyRoot = 'root';		keyDiscreteData = 'disc';		keyResult = 'rslt';		keyRemoteType = 'remt';		remoteType = 1;{----------------------------------------------------------------------------}	procedure DoRemoteError (myErr: OsErr);		var			db: boolean;	begin		db := IOSuccessful(myErr);	end;{----------------------------------------------------------------------------}	procedure LaunchAnApplication (mySFReply: StandardFileReply);{from IM VI   p. 29-14}		var			launchParameters: LaunchParamBlockRec;			launchedProcessSN: ProcessSerialNumber;			launchErr: OSErr;			prefSize: longint;			minSize: longint;			availSize: longint;	begin		with launchParameters do			begin				launchBlockID := extendedBlock;				launchEPBLength := extendedBlockLen;				launchFileFlags := 0;				launchControlFlags := launchContinue + launchNoFileFlags + launchDontSwitch;				launchAppSpec := @mySFReply.sfFile;				launchAppParameters := nil;			end;		launchErr := LaunchApplication(@launchParameters);		prefSize := launchParameters.launchPreferredSize;		if launchErr = noErr then			launchedProcessSN := launchParameters.launchProcessSN		else if launchErr = memFullErr then			availSize := launchParameters.launchAvailableSize		else			DoRemoteError(launchErr);	end;{$IFC FALSE}{----------------------------------------------------------------------------}	procedure ChooseAndLaunchApplication;		var			reply: StandardFileReply;			typeList: SFTypelist;	begin		if hasSys7StandFile then			begin					typeList[0] := 'APPL';				StandardGetFile(nil, 1, @typeList, reply);				if reply.sfGood then					LaunchAnApplication(reply);			end;	end;	{$ENDC}{----------------------------------------------------------------------------}	function SendPAUPCommand(command: str255): boolean;		var			theAppleEvent: AppleEvent;			reply: AppleEvent;			ReturnedType: DescType;			actualSize: longint;			myErr: OsErr;			errStr: Str255;			errNumber: longint;			targetAddress: AEAddressDesc;			theSignature: OStype;			theValue: longint;	begin		SendPAUPCommand := false;		theSignature := 'PAUP';		myErr := AECreateDesc(typeApplSignature, @thesignature, SizeOf(theSignature), targetAddress);		if myErr = noErr then			begin				myErr := AECreateAppleEvent(kPAUPClass, kPAUPcommandID, targetAddress, kAutoGenerateReturnID, kAnyTransactionID, theAppleEvent);				if myErr = noErr then					begin						myErr := AEPutParamPtr(theAppleEvent, keyDirectObject, typeChar, ptr(ord4(@command)+1), length(command));						DoRemoteError(myErr);						if myErr = noErr then							begin								myErr := AESend(theAppleEvent, reply, kAEWaitReply, kAENormalPriority, kNoTimeOut, nil, nil);								DoRemoteError(myErr);							end;						myErr := AEDisposeDesc(targetAddress);						SendPAUPCommand := true;					end				else					DoRemoteError(myErr);			end		else			DoRemoteError(myErr);	end;{----------------------------------------------------------------------------}	procedure SendPAUPcommands(ds: str255);	begin		if not SendPAUPCommand(ds) then 			InstantInfo('paup command unsuccessful');	end;{$ENDC}(*{-----------------------------------------------------------------------------}	procedure NChangesAllReconstructions(ic: integer);		label			1;		var			ctyp,numberInternalBranches: integer;			nthis, numRes : longint;			statesAvailable: largestSetChars;{.............}		procedure CountNumChanges (N: Nptr);		begin			if (N^.resolved <> N^.anc^.resolved) then				begin					nthis := nthis + 1;				end;			if NodeIsInternal(N) then				begin					CountNumChanges(N^.lf);					CountNumChanges(N^.rt);				end;		end;{.............}		procedure TryAllReconstructionsRec(N: Nptr);		begin			if NodeIsInternal(N) then				begin					TryAllReconstructionsRec(N^.lf);					TryAllReconstructionsRec(N^.rt);				end;		end;{.............}	begin		aborted := false;		ctyp := typeofchar(ic);		statesAvailable := CharStatesLargest(ic);		numStates := CardLg(statesAvailable);		numberInternalBranches := numtaxain-1;		maxReconstruction := TotalNumberReconstructions;		{calc total number of reconstructions}		{set to all of lowest state}		numRes := 0;		repeat			numRes := numRes + 1;			if (numRes mod cancelCheckFreq = 0) & CommandPeriod then				begin					aborted := not chartbeingcalculated | (not checkifcontinueabit);					if aborted then						goto 1					else						abortedThermo := false;				end;			if numRes mod 10 = 0 then				EquivocalCursor(True);			nthis := 0;			if NodeIsInternal(R) then {count how many changes}				begin					CountNumChanges(R^.lf);					CountNumChanges(R^.rt);				end;			{output nthis to file}			{build next reconstruction}					until numRes = maxReconstruction;1:	end;{-----------------------------------------------------------------------------}	procedure TryAllReconstructions(baseN: Nptr);	begin		TryAllReconstructionsRec(baseN);	end;*){-----------------------------------------------------------------------------}		procedure WriteTaxaNotInClade(N, cladeN: Nptr);		begin			if cladeN <> N then				if NodeIsInternal(N) then					begin						WriteTaxaNotInClade(N^.lf, cladeN);						WriteTaxaNotInClade(N^.rt, cladeN);					end				else if {NodeIsVisible(N) & } (N<>R) then					begin						putLegalToken(TaxonName(N^.name));						putToken(',');					end;		end;{-----------------------------------------------------------------------------}		function RightMostInClade(N, cladeN: NPtr): boolean;			var rightN : NPtr;		begin			RightMostInClade := false;			if NodeIsInternal(cladeN) then  {presumably well protected, but...}				begin					rightN := cladeN^.rt;					while NodeIsInternal(rightN) do						rightN := rightN^.rt;					RightMostInClade := rightN  = N;				end;		end;{-----------------------------------------------------------------------------}		procedure WriteTaxaInClade(N, cladeN: NPtr);		begin			if NodeIsInternal(N) then				begin					WriteTaxaInClade(N^.lf, cladeN);					WriteTaxaInClade(N^.rt, cladeN);				end			else {if NodeIsVisible(N) & }if (N<>R) then				begin					putLegalToken(TaxonName(N^.name));					if not RightMostInClade(N, cladeN) then						putToken(',');				end;		end;{-----------------------------------------------------------------------------}		procedure WriteCladeName(N: NPtr; cladenum: longint);		var cladename: str255;		begin			{cladename := TreeNodeLabel(N);			if cladename <> '' then				begin					OutputNexusToken (taskP^.textOutputP,cladename);				end			else				begin}					putToken('clade');					putSimpleLongint(cladenum);					putSingleChar('.');					putSimpleLongint(NumberOfNode(N));				{end;}		end;{-----------------------------------------------------------------------------}		procedure OutputConstraint(N: NPtr; cladenum: longint);		begin			putToken('constraint ');			WriteCladeName(N,cladenum);			putToken(' = ');			putToken('(');			WriteTaxaNotInClade(R,N);			putToken('(');			WriteTaxaInClade(N,N);			putTokenReturn('));');		end;{-----------------------------------------------------------------------------}		procedure WriteDecayIndexFile(writeFilterDecay: boolean);				var					it, cladenum: longint;					numInClade: integer;		{.................}			procedure WriteDecayForNode (N: NPtr);			begin				if NodeIsInternal(N) then					begin						WriteDecayForNode(N^.lf);						WriteDecayForNode(N^.rt);						 if BranchExists(N) & (N<>R) then							begin								numInClade := SizeofClade(N, false);								if (numInClade<numtaxain-1) & (numInClade<>1) then									begin										putToken('[!============= ');										putToken('clade ');										putSimpleLongint(cladenum);										putToken(', node number ');										putSimpleLongint(NumberOfNode(N));										putTokenReturn(' =============]');																				OutputConstraint(N, cladenum);																				putToken('showconstr ');										WriteCladeName(N,cladenum);										putTokenReturn(';');										if writeFilterDecay then											begin												putTokenReturn('gettrees file=xxx;');												putToken('filter reverse permdel constraint=');											end										else if decaySearchHS then											putToken('HSearch enforce converse constraint=')										else											putToken('BandB enforce converse constraint=');										WriteCladeName(N,cladenum);										putTokenReturn(';');										putTokenReturn('filter best permdel;');																				putToken('savetrees file=');										WriteCladeName(N,cladenum);										putTokenReturn('.tree;');										putTokenReturn('pscore 1/scorefile=''scores'' append;');																				putReturn;										cladenum := cladenum+1;									end;							end;					end;			end;		{.................}		begin						if treeopen & (R <> nil) then				begin					cladenum := 1;					putTokenReturn('#NEXUS');					putReturn;					putTokenReturn('begin paup;');					putTokenReturn('set autoclose nowarnreset nowarntree;');					if decaySearchSubcommandStr<>'' then						begin							putToken('defaults ');							if decaySearchHS then								putToken('HSearch ')							else								putToken('BandB ');							putToken(decaySearchSubcommandStr);							putTokenReturn(';');						end;					putReturn;					WriteDecayForNode(R);								putTokenReturn('end;');					putReturn;				end;		end;{-----------------------------------------------------------------------------}	function DecayIndexOptions: boolean; 		var			theDialog: DialogPtr;			tempP: WindowPtr;			localItemHit: integer;			oldDecaySearchHS: boolean;			oldString: str255;	begin		oldDecaySearchHS:= decaySearchHS;		oldString := decaySearchSubcommandStr;		StartDLOG(708, theDialog, tempP);		SetDLOGText(theDialog, 5, decaySearchSubcommandStr, false);		ItemCheckMark(theDialog,3,decaySearchHS);		ItemCheckMark(theDialog,4,not decaySearchHS);		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			if localitemhit = 3 then				begin					decaySearchHS := true;					ItemCheckMark(theDialog,3,decaySearchHS);					ItemCheckMark(theDialog,4,not decaySearchHS);				end			else if localitemhit = 4 then				begin					decaySearchHS := false;					ItemCheckMark(theDialog,3,decaySearchHS);					ItemCheckMark(theDialog,4,not decaySearchHS);				end			else if localitemhit = 10 then				begin					decaySearchSubcommandStr := GetEditText(theDialog, 5);					SetDialogValuesAsDefaults(theDialog,decayIndexID,0,0);				end;		until localItemHit in [1, 2];		if localItemHit = 1 then			begin 				decaySearchSubcommandStr := GetEditText(theDialog, 5);			end		else			begin				decaySearchHS:= oldDecaySearchHS;				decaySearchSubcommandStr := oldString;			end;		DecayIndexOptions := localitemhit = 1;		EndDLOG(theDialog, tempP);	end;{-----------------------------------------------------------------------------}	procedure IndexNotation;		label			1;		var			theDialog: DialogPtr;			oldCharInfoExpon: boolean;			oldsigindices: integer;			localitemHit: integer;			tempP: WindowPtr;			tempsig: integer;{............}		procedure GrabIndexText;		begin			tempsig := EditTextInt(thedialog, 3,true);			if (tempsig < 1) or (tempsig > 4) then				begin					InstantError(249);					localItemHit := NotInDialog;					goto 1;				end			else				sigindices := tempsig;		end;{............}		procedure CheckOtherCalc;		begin			ItemCheckMark(theDialog, 5, CharInfoExpon);		end;{............}	begin		StartDLOG(587, theDialog, tempP);		SetDLOGText(theDialog, 3, StringFromNum(sigindices), true);		SelectDialogItemText(theDialog, 3, 0, 32767);		CheckOtherCalc;		myShowDialog(theDialog);		oldsigindices := sigindices;		oldCharInfoExpon := CharInfoExpon;{oooooooooooooooooooooooooooooooooooooo}1:		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			case localItemHit of				5, 6: 					CharInfoExpon := not CharInfoExpon;				7: 					begin						GrabIndexText;						SetDialogValuesAsDefaults(theDialog, calcNotationid, 0, 0);					end;				otherwise					;			end;			CheckOtherCalc;		until localItemHit in [1, 2];{oooooooooooooooooooooooooooooooooooooo}		if localItemHit = 2 then			begin				charInfoExpon := oldcharinfoexpon;				sigindices := oldsigindices;			end		else			GrabIndexText;		EndDLOG(theDialog, tempP);		if (oldsigindices <> sigindices) then   {v3.04:}			InvalidateWindow(tlegwindow, true);		if (not CharInfoExpon and (oldsigindices <> sigindices)) or (oldCharInfoExpon <> CharInfoExpon) then			if infoOpen[charinfo] then				SizeInfoWindow(charinfo, true,true);	end;{-----------------------------------------------------------------------------}	procedure SaveDecayIndexFile(Event: EventRecord);	label 1;		var			theInfo: FInfo;			thefile: integer;			oldexists, writeFilterDecay: BOOLEAN;			writename, prompt: str255;			Freply: StandardFileReply;	begin		oldexists := false;		writeFilterDecay := false;		if treeopen & DecayIndexOptions then			begin				PutStandardFile('Save Decay Index file as', 'PAUP Decay Commands', Freply);			end		else			Exit(SaveDecayIndexFile);		ShowCursor;		if Freply.sfgood then			FSpCreateSaveFile(Freply.sfFile, oldexists, 'PAUP', 'TEXT')		else			Errorflag := true;		if errorflag then			goto 1;		StartWrite;		DrawToFile := true;		WriteDecayIndexFile(writeFilterDecay);		EndWrite;		DrawToFile := false;		if errorflag then			goto 1;		if oldexists then			FSpExchangeFilesDeleteTemp(Freply.sfFile);1:	end;{-----------------------------------------------------------------------------}	procedure DoCalcMenu (ItemNo: integer);	begin		case ItemNo of			LengthItem: 				begin					SetOnOffCount(not count);					ResetInfoWindow(charinfo);					InvalidateWindow(tlegwindow, false);					//SendPAUPcommands('set autoclose; hs;');				end;			ChangesItem: 				if calctreechanges | CalcMenuItemLegal(ItemNo) then					begin						calctreechanges := not calctreechanges;						if calctreechanges then							begin{FROZEN 3.0}								if not count then									SetOnOffCount(true);								AddToGoListIfNotInGoMask([countall, reconstructall, changesall]);							end;						ResetInfoWindow(charinfo);						resetGoMask;						InvalidateWindow(tlegwindow, false);					end;			CIItem: 				if calcCI | CalcMenuItemLegal(ItemNo) then					begin						calcCI := not calcCI;{FROZEN 3.0}						if calcCI then							golist := golist + [ciall, calcminlenall];  {if calcRI CI changed then call for calculations}						if calcCI & not count then							SetOnOffCount(true);						SetInfoColumnIDShow(charinfo, CharInfoCI,calcCI);						ResetInfoWindow(charinfo);						resetGoMask;						InvalidateWindow(tlegwindow, false);					end;			RIItem: 				if calcRI | CalcMenuItemLegal(ItemNo) then					begin						calcRI := not calcRI;{FROZEN 3.0}						if calcRI then							golist := golist + [riall, calcmaxlenall, calcminlenall];						if calcRI & not count then							SetOnOffCount(true);						SetInfoColumnIDShow(charinfo, CharInfoRI,calcRI);						ResetInfoWindow(charinfo);						resetGoMask;						InvalidateWindow(tlegwindow, false);					end;			RCItem: 				if calcRC | CalcMenuItemLegal(ItemNo) then					begin						calcRC := not calcRC;{FROZEN 3.0}						if calcRC then							golist := golist + [riall, ciall, calcmaxlenall, calcminlenall];						if calcRC & not count then							SetOnOffCount(true);						SetInfoColumnIDShow(charinfo, CharInfoRC,calcRC);						ResetInfoWindow(charinfo);						resetGoMask;						InvalidateWindow(tlegwindow, false);					end;			MinPosItem: 				if showMinSteps | CalcMenuItemLegal(ItemNo) then					begin						showMinSteps := not showMinSteps;{FROZEN 3.0}						if showMinSteps then							golist := golist + [calcminlenall];						SetInfoColumnIDShow(charinfo, CharInfoMin,ShowMinSteps);						InvalidateWindow(tlegwindow, true);						resetGoMask;					end;			MaxPosItem: 				if showMaxSteps | CalcMenuItemLegal(ItemNo) then					begin						showMaxSteps := not showMaxSteps;{FROZEN 3.0}						if showMaxSteps then							golist := golist + [calcmaxlenall];						SetInfoColumnIDShow(charinfo,CharInfoMax,ShowMaxSteps);						InvalidateWindow(tlegwindow, true);						resetGoMask;					end;			DecayIndexItem:				SaveDecayIndexFile(Event);			IndexNotationItem: 				IndexNotation;			otherwise				;		end;		if infoOpen[charinfo] then			begin				SizeInfoWindow(charinfo,true, true);				InvalidateWindow(tlegwindow, true);			end;		CheckCalcMenu;	end;end.