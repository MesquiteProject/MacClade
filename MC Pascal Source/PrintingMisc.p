unit PrintingMisc;{еееееееееееееееееееееее}interface	uses		Printing, QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, FixMath, Windows, 		Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, 		GenUtil, BoxUtil, StrUtil, TaxonCHUtil, MCFonts, Settings, CharUtil, TreeUtil, N7on, SpreadUtil, TreeDrawer,		PrintingUtil, FixMath;	const		anglelen = 40;	var		TSP: point;	function DegreesFromRadians (angle: single): integer;	procedure CalcTreeCenter;	procedure NodePolarToLoc (polarlength, angle: single; var loc: LongPoint);	procedure NodePolarToSingleLoc (polarlength, angle: single; var loc: SinglePt);	function CalcAngle (anglept: point): integer;	procedure SetBoxFont (thebox: integer);	procedure DrawTaxonNames (fortree, forscreen, calclocs, drawtaxnames, forpict, calcboxes: boolean);	procedure PrintDataBoxesPage (var icstart: integer; itstart, itend: integer; var pg: longint; pgheight, pgwidth: integer);	procedure PrintDataBoxesTree (var icstart: integer; var pg: longint; pgheight, pgwidth: integer; forpict: boolean);	function PrintFontFilter (theDialog: DialogPtr; var Event: EventRecord; var localItemHit: INTEGER): BOOLEAN;	procedure PrintFontUser (theDialog: DialogPtr; itemNo: INTEGER);	function ChooseFontDLOG: boolean;	procedure SetPrintFonts;	var		printLastTx: integer;		circleslice: single;		treeCenter: LongPoint;		fliptree: boolean;{еееееееееееееееееееееее}implementation {е$S PrintingMisc}{	function DegreesFromRadians (angle: single): integer; begin end;	procedure CalcTreeCenter;begin end;	procedure NodePolarToLoc (polarlength, angle: single; var loc: LongPoint);  begin end;	procedure NodePolarToSingleLoc (polarlength, angle: single; var loc: SinglePt);  begin end;	function CalcAngle (anglept: point): integer;begin end;	procedure SetBoxFont (thebox: integer);begin end;	procedure DrawTaxonNames (fortree, forscreen, calclocs, drawtaxnames, forpict, calcboxes: boolean); begin end;	procedure PrintDataBoxesPage (var icstart: integer; itstart, itend: integer; var pg: longint; pgheight, pgwidth: integer); begin end;	procedure PrintDataBoxesTree (var icstart: integer; var pg: longint; pgheight, pgwidth: integer; forpict: boolean); begin end;	function PrintFontFilter (theDialog: DialogPtr; var Event: EventRecord; var localItemHit: INTEGER): BOOLEAN; begin end;	procedure PrintFontUser (theDialog: DialogPtr; itemNo: INTEGER); begin end;	function ChooseFontDLOG: boolean; begin end;	procedure SetPrintFonts; begin end; } {$SETC PRINTNAMES=TRUE}{$SETC CANVAS21=FALSE}{-----------------------------------------------------------------------------}	procedure SetBoxFont;	begin		TextFont(laser^.fonts[thebox].font);		TextFace(laser^.fonts[thebox].face);		TextSize(laser^.fonts[thebox].size);	end;{-----------------------------------------------------------------------------}	function DegreesFromRadians (angle: single): integer;	begin		DegreesFromRadians := RoundValue(angle * 180.0 / pi);	end;{-----------------------------------------------------------------------------}	procedure CalcTreeCenter;	begin		treeCenter.h := firsttx + (laser^.txsp * (ntscreen - 1)) div 2;		treeCenter.v := topmargin + (laser^.txsp * (ntscreen - 1)) div 2;	end;{-----------------------------------------------------------------------------}	procedure NodePolarToLoc (polarlength, angle: single; var loc: LongPoint);{remember: sin = opp/hyp, cos = adj/hyp, tan = opp/adj}	begin		loc.h := treeCenter.h + RoundValue(polarlength * sin(angle));		loc.v := treeCenter.v - RoundValue(polarlength * cos(angle));	end;{-----------------------------------------------------------------------------}	procedure NodePolarToSingleLoc (polarlength, angle: single; var loc: SinglePt);{remember: sin = opp/hyp, cos = adj/hyp, tan = opp/adj}	begin		loc.h := treeCenter.h + polarlength * sin(angle);		loc.v := treeCenter.v - polarlength * cos(angle);	end;{-----------------------------------------------------------------------------}	procedure CalcNamePositions (N: Nptr; calclocs, calcboxes: boolean);		var			TaxonHdl: thdl;			trect: rect;			pt: LongPoint;			firstangle, lastangle: single;			ang: integer;	begin		if calclocs then			begin				pt.h := lasttx;				lasttx := laser^.txsp + lasttx;				pt.v := topmargin;				if laser^.treeshape[circletree] then					begin						ang := CalcAngle(laser^.circleanglept);						if fliptree then							begin								firstangle := pi + (ang / 180) * pi;								lastangle := pi - (ang / 180) * pi;								N^.angle := firstangle + (2 * pi + lastangle - firstangle) * (pt.h - firsttx) / (laser^.txsp * (ntscreen - 1));  {angle in radians horizontal from vertical}								if N^.angle > 2 * pi then									N^.angle := N^.angle - 2 * pi;							end						else							begin								firstangle := (ang / 180) * pi;								lastangle := 2 * pi - (ang / 180) * pi;								N^.angle := firstangle + (lastangle - firstangle) * (pt.h - firsttx) / (laser^.txsp * (ntscreen - 1));  {angle in radians horizontal from vertical}							end;						N^.polarLength := (laser^.txsp * (ntscreen - 1)) / 2.0;						NodePolarToLoc(N^.polarlength, N^.angle, N^.loc);						NodePolarToSingleLoc(N^.polarlength, N^.angle, N^.sloc);					end				else					N^.loc := pt;			end;		if calcboxes then			begin				TaxonHdl := gettaxonHdl(N^.name);				SETRECT(trect, pt.h, pt.v - 8, pt.h + boxedw, pt.v - 1);				taxonHdl^^.b := trect;			end;	end;{-----------------------------------------------------------------------------}	function CalcAngle (anglept: point): integer;	begin		if anglept.h = 0 then			CalcAngle := 0		else			CalcAngle := AngleFromSlope(FixRatio(anglept.h, anglept.v));	end;{$IFC TRUE}{-----------------------------------------------------------------------------}	procedure CalcTextCenter (swidth, ang: integer);  {for canvas only now}		var			verinc, horinc: integer;			y: real;			info: FontInfo;			radAngle, offsetRadAngle: single;			adj: single;	begin{remember: sin = opp/hyp, cos = adj/hyp, tan = opp/adj}{and 1б = ╕/180 radians}		GetFontInfo(info);		y := (info.ascent + info.descent + info.leading) - info.descent + info.leading;		radAngle := ang * pi / 180.0;		offsetRadAngle := pi / 2 - radAngle;		verinc := RoundValue(10.0 * (y + swidth / 2.0) * sin(offsetRadAngle));		horinc := RoundValue(10.0 * (swidth / 2.0 - y) * cos(offsetRadAngle));		TTC^^.x := FixRatio(horinc, 10);		TTC^^.y := FixRatio(-verinc, 10);		move(RoundValue(FontHeight * cos(offsetRadAngle)), RoundValue(FontHeight * sin(offsetRadAngle)));	end;{$ENDC}{-----------------------------------------------------------------------------}	const		circleNameGap = 5;{-----------------------------------------------------------------------------}	procedure MoveToCircleAngledName (N: NPtr; startofname: boolean; nameWidth: integer; var ang: integer; var loc: LongPoint);	var	adjustmentAngle: single;	begin		adjustmentAngle := (Fontheight / 4.0) / (N^.polarlength);		if N^.angle > pi then			begin				ang := DegreesFromRadians(N^.angle - adjustmentAngle) - 180;				if startofname then					NodePolarToLoc(N^.polarlength + circleNameGap + nameWidth, N^.angle - adjustmentAngle, loc)				else					NodePolarToLoc(N^.polarlength + circleNameGap, N^.angle - adjustmentAngle, loc);				moveto(loc.h, loc.v);			end		else			begin				NodePolarToLoc(N^.polarlength + circleNameGap, N^.angle + adjustmentAngle, loc);				ang := DegreesFromRadians(N^.angle + adjustmentAngle);				moveto(loc.h, loc.v);			end;	end;{-----------------------------------------------------------------------------}	procedure MakeStick (loc: LongPoint; h, v, len,fh,nameWidth: integer; leftside: boolean);		var			sL: longint;	begin		sL := nameWidth;		if laser^.treeshape[circletree] then			if leftside then				move(-fh * v div len, +fh * h div len);		Line(sL * h div len, sL * v div len);		Line(fh * v div len, -fh * h div len);		Line(-sL * h div len, -sL * v div len);		Line(-fh * v div len, fh * h div len);	end;{-----------------------------------------------------------------------------}	function TaxNameForTree(N: Nptr; forTree: boolean): str255;	var taxName: str255;	begin		if (traceshown = traceDiscrete) & (tiplabel = tipState) & fortree then			taxname := CopyString(StsToString(GetTaxonStsLargest(N^.name, i), i, true,true), 1, tnw - 1)		else if (tiplabel = tipTaxNum) & fortree then			taxname := StringFromNum(N^.name)		else			taxname := TaxonName(N^.name);{$IFC FALSE}		if length(taxname) < tnw - 1 then			taxname := concat(taxname, '  ');  {v4: added this as otherwise problems in Canvas 3.02}{$ENDC}		TaxNameForTree := taxName;	end;{-----------------------------------------------------------------------------}	procedure DrawTaxonNames (fortree, forscreen, calclocs, drawtaxnames, forpict, calcboxes: boolean);		var			StickRgn: RgnHandle;			pstate: PenState;			fh, dh: integer;			taxname: str255;			info: fontinfo;			nilrect: rect;			dopostscript, dopixels: boolean;			oldClipRgn: RgnHandle;			oldface: style;			verinc, horinc: integer;			nameLoc: LongPoint;			y, ang: integer;			hor, ver: integer;			box: rect;			loc, loc2: LongPoint;			adjustmentAngle: single;{......................................................................................................}		procedure DrawAngledCircleNames (N: Nptr; angleNames: boolean);		begin{===========}			if angleNames then				begin					MoveToCircleAngledName(N, true,StringWidth(taxname),ang,loc);{$IFC CANVAS21}					if saveCanvas & forpict then						CalcTextCenter(StringWidth(taxname), ang);{$ENDC}					TextMode(srcor);					TTPR^^.tAngle := 270 + ang;					TTPR^^.tAngleFixed := Long2Fix(TTPR^^.tAngle);					BeginPostScriptRotatedText;{    ClipRect(nilrect);}					DrawString(taxname);{    SetClip(OldClipRgn);}{v4: draw quickdraw name here with copybits}					EndPostScriptRotatedText;					TextMode(srcor);				end			else				begin{===== QUICKDRAW NAME======}					ver := N^.loc.v + FontHeight div 2;					if N^.angle <= pi then	{on right side of circle}						begin							hor := N^.loc.h + 3;{if within pi/4 of vertical, then shift hor over so taxname written more toward center}							if (N^.angle < 0.25 * pi) then								adjustmentAngle := 0.25 * pi - N^.angle							else if (N^.angle > 0.75 * pi) then								adjustmentAngle := N^.angle - 0.75 * pi							else								adjustmentAngle := 0.0;							hor := hor - RoundValue((adjustmentAngle / (pi / 4)) * StringWidth(taxname) / 1.5);						end					else   					{on left side of circle}						begin							hor := N^.loc.h - 3 - StringWidth(taxname);							if (N^.angle < 1.25 * pi) then								adjustmentAngle := 1.25 * pi - N^.angle							else if (N^.angle > 1.75 * pi) then								adjustmentAngle := N^.angle - 1.75 * pi							else								adjustmentAngle := 0.0;							hor := hor + RoundValue((adjustmentAngle / (pi / 4)) * StringWidth(taxname) / 1.5);						end;					if (N^.angle > pi / 2) and (N^.angle < 1.5 * pi) then   {on bottom of circle}						begin							ver := ver + RoundValue((adjustmentAngle / (pi / 4)) * FontHeight / 2.0) + 2;{$IFC FALSE}							if (N^.loc.h > hor) and (N^.loc.h < hor + StringWidth(taxname)) and (ver < N^.loc.v + FontHeight) then								ver := N^.loc.v + FontHeight + 2;   {node horizontally between start and end of string, and vertically below}										{top of string, which means string needs to be moved down}{$ENDC}						end					else						begin							ver := ver - RoundValue((adjustmentAngle / (pi / 4)) * FontHeight / 2.0) - 2;							if (N^.loc.h > hor) and (N^.loc.h < hor + StringWidth(taxname)) and (ver > N^.loc.v) then								ver := N^.loc.v - 2;   {node horizontally between start and end of string, and vertically above bottom}										{of string, which means string needs to be moved up}						end;					moveto(hor, ver);					TextMode(srcor);					DrawString(taxname);{========== END QUICKDRAW NAME ==========}				end;		end;{......................................................................................................}		procedure DrawLaserNames (var N: Nptr);		var nameWidth, adjust: integer;		begin			if NodeIsTerminal(N) then				begin					CalcNamePositions(N, calclocs, calcboxes);					if drawtaxnames then						begin							taxName := TaxNameForTree(N,forTree);							if ItalicTaxon(N^.name) & (tipLabel = tipTaxa) then								TextFace(oldFace + [italic]);							nameWidth := StringWidth(taxName);							if fortree & laser^.treeshape[circletree] then								DrawAngledCircleNames(N, dopostscript)							else								begin									nameLoc := N^.loc;									adjust := edw - (edw - fh) div 2 - dh;{$IFC MINMAXIN}									if laser^.printbranchlengths & (branchlistmode = minmaxmode) & (laser^.mmShow <> mmDontShow) & fortree then  {v3.04: added & fortree}										nameLoc.v := N^.anc^.loc.v - RoundValue(N^.length2 * laser^.pixelperchg);{$ENDC}{===== do postscript text =======}									if dopostscript then										begin{$IFC TRUE}											if (traceshown = traceDiscrete) then												moveto(printLastTx, nameLoc.v - 10)											else												moveto(printLastTx, nameLoc.v - 3);																							{$IFC CANVAS21}											if saveCanvas & forpict then												CalcTextCenter(nameWidth, ang);{$ENDC}{$IFC PRINTNAMES}											TextMode(srcor);											BeginPostScriptRotatedText;											ClipRect(nilrect);											DrawString(taxname);											SetClip(OldClipRgn);											moveto(nameLoc.h + adjust, nameLoc.v - 10);											VerticalString(taxname, true);											EndPostScriptRotatedText;{$ENDC}											printLastTx := printLastTx + laser^.txsp;{$ENDC}{DrawCanvasNames;}										end{======= do bitmapped text ========}									else if doPixels then										begin											moveto(nameLoc.h + adjust, nameLoc.v - 10);											VerticalString(taxname, true);										end;								end;							TextFace(oldFace);						end;				end			else				begin					DrawLaserNames(N^.lf);					DrawLaserNames(N^.rt);				end;		end;{.................}		procedure DrawStickNames (var N: Nptr);		var nameWidth: integer;		begin			if NodeIsTerminal(N) then				begin					CalcNamePositions(N, calclocs, calcboxes);					if drawtaxnames then						begin							if ItalicTaxon(N^.name) & (tipLabel = tipTaxa) then								TextFace(oldFace + [italic]);							nameWidth := StringWidth(TaxNameForTree(N, fortree));							SetEmptyRgn(StickRgn);							OpenRgn;							if laser^.treeshape[circletree] then								begin									NodePolarToLoc(N^.polarlength + circleNameGap, N^.angle, loc);									NodePolarToLoc(N^.polarlength + circleNameGap + nameWidth, N^.angle, loc2);									MoveToCircleAngledName(N, false,nameWidth,ang,loc);									MakeStick(loc, (loc2.h - loc.h), (loc2.v - loc.v), nameWidth,fh, nameWidth, N^.angle > pi);								end							else								begin									nameLoc := N^.loc;{$IFC MINMAXIN}									if laser^.printbranchlengths & (branchlistmode = minmaxmode) & (laser^.mmShow <> mmDontShow) then										nameLoc.v := N^.anc^.loc.v - RoundValue(N^.length2 * laser^.pixelperchg);{$ENDC}									if (traceshown = traceDiscrete) then										MOVETO(nameLoc.h - dh * laser^.nameAnglePt.v div anglelen + edw div 2, nameLoc.v - 10 + dh * laser^.nameAnglePt.h div anglelen)									else										MOVETO(nameLoc.h - dh * laser^.nameAnglePt.v div anglelen + edw div 2, nameLoc.v - 5 + dh * laser^.nameAnglePt.h div anglelen);									MakeStick(nameLoc, laser^.nameAnglePt.h, laser^.nameAnglePt.v, anglelen,fh, nameWidth, false);								end;							CloseRgn(StickRgn);							FillRgn(StickRgn, QDBlack);							TextFace(oldFace);						end;				end			else				begin					DrawStickNames(N^.lf);					DrawStickNames(N^.rt);				end;		end;{................}	begin{===== taxon names =====}		if laser^.treeshape[circletree] then			CalcTreeCenter;		if laser^.treeshape[circletree] then			ang := CalcAngle(laser^.circleanglept)		else			ang := CalcAngle(laser^.nameanglept);		OldClipRgn := NewRgn;		GetClip(oldClipRgn);		SetRect(nilrect, 0, 0, 0, 0);		GroupBegin;		if fortree then			SetBoxFont(taxanameB);		GetFontInfo(info);		TTC^^.x := Long2Fix(0);		TTC^^.y := Long2Fix(0);		dh := info.descent;		fh := FontHeight;		doPostscript := false;		doPixels := false;		oldface := QDThePortTextFace;		if laser^.postscripton then			begin				PenMode(PatCopy);				if forscreen then					begin						StickRgn := newrgn;						GetPenState(pstate);						PenSize(1, 1);						DrawStickNames(screenR);						SetPenState(pstate);						ZapRegion(StickRgn);					end				else					begin						doPostscript := true;						DrawLaserNames(screenR);					end;			end		else			begin				Textmode(srcor);				doPixels := true;				DrawLaserNames(screenR);			end;		GroupEnd;{    SetClip(OldClipRgn);}		ZapRegion(oldcliprgn);	end;{-----------------------------------------------------------------------------}	procedure PrintDataBoxesPage (var icstart: integer; itstart, itend: integer; var pg: longint; pgheight, pgwidth: integer);		var			TaxonHdl: thdl;			btaxname: str255;			currentLine, NumLines, basespot, ic, oldtopmargin: Integer;			it: Integer;			icend: integer;			trect: rect;			oldClipRgn: RgnHandle;			oldlasttx: integer;			oldBranchShades: integer;	begin		oldBranchShades := branchShades[traceDiscrete];		branchShades[traceDiscrete] := laser^.branchShades[traceDiscrete];		oldtopmargin := topmargin;		oldlasttx := lasttx;		OldClipRgn := NewRgn;		GetClip(oldClipRgn);		if NoPrinterError then			begin				topmargin := MaxTaxNameLength(false) + 20;{$IFC FALSE}				if printStampLine then					topmargin := topmargin + printStampWidth;{$ENDC}{if not PaintedBranches then edw := 10;}				if OpenPrinterPage then					begin						firsttx := 44;						lasttx := firsttx + 8;						for it := itstart to itend do							begin								TaxonHdl := gettaxonHdl(it);								SETRECT(trect, lasttx, topmargin - 8, lasttx + boxedw, topmargin - 1);   {v4: not tied to edw}								taxonHdl^^.b := trect;								btaxname := TaxonName(it);								if ItalicTaxon(it) then									TextFace(PrintOtherFonts.face + [italic]);								DualVerticalString(btaxname, oldClipRgn, lasttx + edw, topmargin + 2);								TextFace(PrintOtherFonts.face);								lasttx := txsp + lasttx;							end;						ClipRect(CurrentDrawingPortRect);						NumLines := ((pgHeight - topmargin) div n7LW) - 2;						icend := icstart + numlines;						if icend > numchars then							icend := numchars;						ic := icstart;						basespot := topmargin + 5;						currentline := 1;						repeat							Nex7Line(ic, itstart, itend, screenR, basespot + currentLine * n7LW, false);							ic := ic + 1;							currentLine := currentLine + 1;						until (currentLine > NumLines) or (ic > icend);					end;				ClosePrinterPage;			end;		icstart := ic;	{icstart is left as the next character}		topmargin := oldtopmargin;		lasttx := oldlasttx;		ZapRegion(oldClipRgn);		branchShades[traceDiscrete] := OldbranchShades;	end;{-----------------------------------------------------------------------------}	procedure PrintDataBoxesTree (var icstart: integer; var pg: longint; pgheight, pgwidth: integer; forpict: boolean);		var			TaxonHdl: thdl;			itend, taxaperpage: integer;			currentLine, NumLines, basespot, ic, oldtopmargin: Integer;			it, horpages, hpg: Integer;			box, trect: rect;			oldClipRgn: RgnHandle;			oldlasttx: integer;			oldTTCy: integer;			oldBranchShades: integer;	begin		oldBranchShades := branchShades[traceDiscrete];		branchShades[traceDiscrete] := laser^.branchShades[traceDiscrete];    {v3.02: added}		oldtopmargin := topmargin;		oldlasttx := lasttx;		OldClipRgn := NewRgn;		GetClip(oldClipRgn);		oldTTCy := printLastTx;		if NoPrinterError then			begin				topmargin := MaxTaxNameLength(true) + 20;				firsttx := tsp.h;				lasttx := firsttx;				horpages := laser^.treepages.h;				NumLines := ((pgHeight - topmargin) div n7LW) - 2;				box := printPageR;				hpg := 1;				repeat				{horizontal, cycling through tree}					ic := icstart;					repeat				{vertical, cycling through characters}						if OpenPrinterPage then							begin								OffSetRect(CurrentDrawingPortRect, (hpg - 1) * pgwidth, 0);								trect := printPageR;								OffSetRect(trect, (hpg - 1) * pgwidth, 0);								printPageR := trect;	{note: this can only be called when print tree is on, otherwise TTCHdl etc undefined}								lasttx := firsttx;{ if not PaintedBranches then edw := 10;}								printLastTx := oldTTCy;								DrawTaxonNames(false, false, true, true, forpict, true);								ClipRect(CurrentDrawingPortRect);								basespot := topmargin + 5;								currentline := 0;								repeat									Nex7Line(ic, 1, numchars, screenR, basespot + currentLine * n7LW, true);									ic := ic + 1;									currentLine := currentLine + 1;								until (currentLine > NumLines) or (ic > numchars);								OffSetRect(CurrentDrawingPortRect, -(hpg - 1) * pgwidth, 0);								printPageR := box;								ClosePrinterPage;							end;						pg := pg + 1;					until ((PrinterError) or (ic > numchars));					hpg := hpg + 1;				until ((PrinterError) or (hpg > horpages));			end;		icstart := ic;	{icstart is left as the next character}		topmargin := oldtopmargin;		lasttx := oldlasttx;		ZapRegion(oldClipRgn);		branchShades[traceDiscrete] := OldbranchShades;	end;{-----------------------------------------------------------------------------}	function ChooseFontDLOG: boolean;{Currently used for PrintBranchList, PrintDataBoxes, PrintOther}		var			theDialog: DialogPtr;			tempP: WindowPTr;			tempH: Handle;			box: rect;			localItemHit: integer;			mleft, mtop: integer;			oldFonts: fontSet;			UserItemUProcP: UniversalProcPtr;			DLOGFilterUPP: UniversalProcPtr;	begin		oldFonts := printOtherFonts;		dlogFonts := printOtherFonts;		SetCursorToArrow;		StartDLOG(706, theDialog, tempP);		UserItemUProcP := MyNewUserItemUPP(@ChooseFontUser);  		tempH := Handle(UserItemUProcP);		box := GetDLOGItemBox(theDialog, 7);		mleft := box.left;		mtop := box.top;		SetDialogItem(theDialog, 7, UserItem, tempH, box);		myShowDialog(theDialog);						SetRect(FontFontBox, mleft, mtop, mleft + 80, mtop + FontHeight);		SetRect(FontSizeBox, mleft, mtop + 29, mleft + 80, mtop + 29 + FontHeight);		SetRect(FontFaceBox, mleft, mtop + 58, mleft + 80, mtop + 58 + FontHeight);		updateFontChangedWindows := false;		FixLaserFontMenus(PrintOtherFonts);{$IFC CARBON}		//FontMHdl := GetMenuHandle(FontMenu);		//StyleMHdl := GetMenuHandle(StyleMenu);		//SizeMHdl := GetMenuHandle(SizeMenu);{$ENDC}		myEnableItem(dlogFontMHdl, 0);   		myEnableItem(dlogStyleMHdl, 0);   		myEnableItem(dlogSizeMHdl, 0);   		DLOGFilterUPP := MyNewModalFilterUPP(@ChooseFontFilter);  		repeat			myModalDialog(DLOGFilterUPP, localItemHit);			if localItemHit = 8 then				begin					printOtherFonts := dlogFonts;					SetDialogValuesAsDefaults(theDialog, printOtherFontid, 0, 0);				end;		until localItemHit in [1, 2];		if (localItemHit = 1) then			printOtherfonts := dlogFonts		else			printOtherFonts := oldFonts;		updateFontChangedWindows := true;		MyDisposeUserItemUPP(UserItemUProcP);		MyDisposeModalFilterUPP(DLOGFilterUPP);		EndDLOG(theDialog, tempP);		ChooseFontDLOG := localItemHit = 1;	end;{-----------------------------------------------------------------------------}	function ChooseFontDLOGOld: boolean;{Currently used for PrintBranchList, PrintDataBoxes, PrintOther}		var			theDialog: DialogPtr;			tempP: WindowPTr;			tempH: Handle;			box: rect;			localItemHit: integer;			mleft, mtop: integer;			oldFonts: fontSet;			UserItemUProcP: UniversalProcPtr;			DLOGFilterUPP: UniversalProcPtr;	begin		oldFonts := printOtherFonts;		dlogFonts := printOtherFonts;		SetCursorToArrow;		StartDLOG(706, theDialog, tempP);		UserItemUProcP := MyNewUserItemUPP(@ChooseFontUser);  		tempH := Handle(UserItemUProcP);		box := GetDLOGItemBox(theDialog, 7);		mleft := box.left;		mtop := box.top;		SetDialogItem(theDialog, 7, UserItem, tempH, box);		myShowDialog(theDialog);						SetRect(FontFontBox, mleft, mtop, mleft + 80, mtop + FontHeight);		SetRect(FontSizeBox, mleft, mtop + 29, mleft + 80, mtop + 29 + FontHeight);		SetRect(FontFaceBox, mleft, mtop + 58, mleft + 80, mtop + 58 + FontHeight);		updateFontChangedWindows := false;		FixLaserFontMenus(PrintOtherFonts);{$IFC CARBON}		//FontMHdl := GetMenuHandle(FontMenu);		//StyleMHdl := GetMenuHandle(StyleMenu);		//SizeMHdl := GetMenuHandle(SizeMenu);{$ENDC}		myEnableItem(dlogFontMHdl, 0);   		myEnableItem(dlogStyleMHdl, 0);   		myEnableItem(dlogSizeMHdl, 0);   		DLOGFilterUPP := MyNewModalFilterUPP(@ChooseFontFilter);  		repeat			myModalDialog(DLOGFilterUPP, localItemHit);			if localItemHit = 8 then				begin					printOtherFonts := dlogFonts;					SetDialogValuesAsDefaults(theDialog, printOtherFontid, 0, 0);				end;		until localItemHit in [1, 2];		if (localItemHit = 1) then			printOtherfonts := dlogFonts		else			printOtherFonts := oldFonts;		updateFontChangedWindows := true;		MyDisposeUserItemUPP(UserItemUProcP);		MyDisposeModalFilterUPP(DLOGFilterUPP);		EndDLOG(theDialog, tempP);		ChooseFontDLOGOld := localItemHit = 1;	end;{-----------------------------------------------------------------------------}	procedure SetPrintFonts;	begin		textfont(PrintOtherFonts.font);		textSize(PrintOtherFonts.size);		textFace(PrintOtherFonts.face);	end;{-----------------------------------------------------------------------------}end.