unit InfoWindows;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}interface	uses		QuickDraw, 		Types, Events, QuickDrawText, OSUtils, Menus, TextUtils, Windows,ControlDefinitions,		 Controls, Dialogs, TextEdit, Lists, ToolUtils, Memory, Fonts, Resources, Scrap, 		Globals, MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, 		SetLibInterface, UtilLibInterface, TaxonCHUtil, CharUtil, WriteUtil, TreeUtil, MenuUtil, SpreadUtil,TypeUtil, 		LinkUtil,  InfoWindowsUtil, InfoWindowsDraw, EditorSelection, EditorCellEntry, NexusBlocks, TrackThumb,		StatesWindowUtil,EditorGeneralUtil;	procedure MoveInfoTE (whichinfo, ic: longint);	function CalcInfoWindowHeight (whichinfo: integer): integer;	procedure ShrinkWrapInfoWindow (whichinfo: integer; var height: integer; width: integer);	procedure InfoPositions (whichinfo: integer);	procedure SetInfoLW (whichinfo: integer);	procedure ResetInfoWindow (whichinfo: integer);	procedure ShowCharPartitionColumn;	procedure ScrollInfoUpDown (whichControl: ControlRef; theCode: INTEGER);	procedure AdjustInfoScrolls (whichinfo: integer);	procedure ScrollInfoWindow (whichinfo: integer; vertscroll: boolean);	procedure DoInfoScroll (whichinfo: integer);	procedure ScrollInfoWindowToSelectedRow (whichinfo: integer);	procedure ScrollInfoWindowToEditingRow (whichinfo: integer);	procedure ResetVerticalInfoScrollControlMax (whichinfo: integer);	procedure ResetInfoScroll (whichinfo: integer);	procedure SizeInfoWindow (whichinfo: integer; eraseWindow, adjustWidth: boolean);	procedure TurnOnInfoEditing (whichinfo: integer; ic: longint);	procedure TurnOffInfoEditing (whichinfo: integer);	procedure SetInfoRowName (whichinfo: integer; theRow: longint; name: str255);	procedure ReturnInfoValue (whichinfo: integer);	procedure ReturnAllInfoValues;	procedure SetDataFormat (whichformat: integer; resetsymbols: boolean);	procedure CheckCharInfoSelected (var foundnum, onefound: integer);	procedure CharToChange (var foundnum, onefound: integer);	var		currentinfo: integer;{еееееееееееееееееееееее}implementation {е$S InfoWindows}{v4: have user able to see Weighted character steps in char status window}{----------------------------------------------------------------------------}	procedure MoveInfoTE (whichinfo, ic: longint);		var			box: rect;	begin		box := InfoCellBox(whichinfo, infoName, InfoHeight(whichinfo, ic));		box.left := box.left + 2;		box.right := box.right - 1;{insetrect(box, 2, 1);}		infoTE[whichinfo]^^.destRect := box;		infoTE[whichinfo]^^.viewRect := box;	end;{-----------------------------------------------------------------------------}	procedure ScrollInfoWindow (whichinfo: integer; vertscroll: boolean);		var			dv, dh, oldInfotop, oldInfoLeft, ic: longint;			oldClip: RgnHandle;			box: rect;			numElements: longint;			oldPort: WindowPtr;	begin		genericGetPort(oldPort);		genericSetPort(infoWindow[whichinfo]);		oldClip := NewRgn;		GetClip(oldClip);		ClipRect(WindowPortRect(infowindow[whichInfo]));		dv := 0;		dh := 0;		if vertscroll then			begin				numElements := MaximumInfoRows(whichinfo);				oldInfotop := infoTop[whichinfo];				infoTop[whichinfo] := GetControlValueLong(infoScroll[whichinfo]);				infoBottom[whichinfo] := infoTop[whichinfo] + infoRows[whichinfo]-1;				dv := (oldInfotop - infoTop[whichinfo]) * infoLW[whichinfo];				with infoDrawRect[whichinfo] do					SetRect(box, left, infoTitleLines * infoLW[whichinfo] - 1, right - scrollwidth - 1, bottom - scrollwidth);				ScrollRect(box, 0, dv, updateRgn);			end		else			begin				oldInfoLeft := infoLeft[whichinfo];				infoLeft[whichinfo] := GetControlValueLong(infoHScroll[whichinfo]);				dh := oldInfoLeft - infoLeft[whichinfo];				with infoDrawRect[whichinfo] do					SetRect(box, InfoColumnRight(whichinfo, infoName), infoTitleLines * infoLW[whichinfo] - 1, right - scrollwidth - 2, bottom - scrollwidth);				ScrollRect(box, dh, 0, updateRgn);			end;		SetClip(updateRgn);		if dv <> 0 then			if infoEditing[whichinfo] then				MoveInfoTE(whichinfo, infoEditRow[whichinfo]);		if dv = infoLW[whichinfo] then   {scrolling down, therefore adding rows to top}			begin				if infoEditing[whichinfo] then					if (infoEditRow[whichinfo] = infoRows[whichinfo] + infoTop[whichinfo] - 1) then  {edit box disappearing}						TEDeActivate(infoTE[whichinfo])					else if (infoEditRow[whichinfo] = infoTop[whichinfo] - 1) then  {edit box disappearing}						TEActivate(infoTE[whichinfo]);				DrawInfoLine(whichinfo, infoTop[whichinfo], InfoHeight(whichinfo, infoTop[whichinfo]), true);			end		else if (dv = -infoLW[whichinfo]) & WindowBotRightOnScreen(infoWindow[whichinfo], true, infoDrawRect[whichinfo].bottom) then			begin				ic := infoTop[whichinfo] + infoRows[whichinfo] - 1;				if infoEditing[whichinfo] then					if (infoEditRow[whichinfo] = infoRows[whichinfo] + infoTop[whichinfo]) then  {edit box to appear}						TEActivate(infoTE[whichinfo])					else if (infoEditRow[whichinfo] = infoTop[whichinfo] - 1) then  {edit box disappearing}						TEDeActivate(infoTE[whichinfo]);				if ic <= numElements then					DrawInfoLine(whichinfo, ic, InfoHeight(whichinfo, ic), true);			end		else if (dv <> 0) then			DrawInfoWindow(whichinfo, true)		else if (dh <> 0) then			DrawInfoWindow(whichinfo, false);		SetClip(OldClip);		ZapRegion(oldClip);		genericSetPort(oldPort);	end;{----------------------------------------------------------------------------}	procedure ScrollInfoUpDown (whichControl: ControlRef; theCode: INTEGER);	begin		if scrollup then			begin				if theCode = kControlUpButtonPart then					begin						if whichcontrol = infoScroll[currentinfo] then   {vertical scroll}							SetControlValueLong(whichControl, GetControlValueLong(whichControl) - 1)						else							SetControlValueLong(whichControl, GetControlValueLong(whichControl) - 20);						ScrollInfoWindow(currentinfo, whichcontrol = infoScroll[currentinfo])					end			end		else if theCode = kControlDownButtonPart then			begin				if whichcontrol = infoScroll[currentinfo] then   {vertical scroll}					SetControlValueLong(whichControl, GetControlValueLong(whichControl) + 1)				else					SetControlValueLong(whichControl, GetControlValueLong(whichControl) + 20);				ScrollInfoWindow(currentinfo, whichcontrol = infoScroll[currentinfo])			end	end;{-----------------------------------------------------------------------------}	procedure DoInfoScroll (whichinfo: integer);		var			MyControl, t: integer;			mypt: point;			vertscroll: boolean;	begin		currentinfo := whichinfo;		MyControl := FindControl(wh, infoWindow[whichinfo], whichControl);		if whichControl= nil then Exit(DoInfoScroll);		vertscroll := whichControl = infoScroll[whichinfo];		case MyControl of			kControlUpButtonPart: 				begin					scrollup := true;					t := myTrackControl(whichControl, wh, ScrollInfoUpDownUPP);				end;			kControlDownButtonPart: 				begin					scrollup := false;					t := myTrackControl(whichControl, wh, ScrollInfoUpDownUPP);				end;			kControlPageUpPart: 				repeat					GetMouse(myPt);					if TestControl(whichControl, myPt) = mycontrol then						begin							if vertscroll then								SetControlValueLong(whichControl, GetControlValueLong(whichControl) - infoRows[whichinfo])							else								SetControlValueLong(whichControl, GetControlValueLong(whichControl) - (infoDrawRect[whichinfo].right - scrollwidth - InfoColumnRight(whichinfo, infoname)));							ScrollInfoWindow(whichinfo, vertscroll)						end				until not StillDown;			kControlPageDownPart: 				repeat					GetMouse(myPt);					if TestControl(whichControl, myPt) = mycontrol then						begin							if vertscroll then								SetControlValueLong(whichControl, GetControlValueLong(whichControl) + infoRows[whichinfo])							else								SetControlValueLong(whichControl, GetControlValueLong(whichControl) + (infoDrawRect[whichinfo].right - scrollwidth - InfoColumnRight(whichinfo, infoname)));							ScrollInfoWindow(whichinfo, vertscroll)						end				until not StillDown;			kControlIndicatorPart: 				begin					if vertscroll then						TrackFeedbackThumb(whichControl,wh, infoWindow[whichinfo])					else						t := myTrackControl(whichControl, wh, nil);					ScrollInfoWindow(whichinfo, whichcontrol = infoScroll[currentinfo])				end;			otherwise				;		end;	end;	{-----------------------------------------------------------------------------}	procedure ScrollInfoWindowToSelectedRow (whichinfo: integer);	var firstRow, lastRow: longint;	begin		if InfoRowSelectedRange(whichinfo,firstRow, lastRow) then  			begin				if infoTop[whichinfo]>lastRow then {we are scrolled down too far}					begin						if lastRow-firstRow <= infoRows[whichinfo] then {we can fit them all in one view}							SetControlValueLong(infoScroll[whichinfo], lastRow-infoRows[whichinfo]+1)						else							SetControlValueLong(infoScroll[whichinfo], lastRow);						ScrollInfoWindow(whichinfo, true);					end				else if infoTop[whichinfo]+infoRows[whichinfo]-1 < firstRow then					begin						{if lastRow-firstRow <= infoRows[whichinfo] then  							SetControlValueLong(infoScroll[whichinfo], lastRow-infoRows[whichinfo]+1)						else }							SetControlValueLong(infoScroll[whichinfo], firstRow);						ScrollInfoWindow(whichinfo, true);					end;			end;	end;{-----------------------------------------------------------------------------}	procedure ScrollInfoWindowToEditingRow (whichinfo: integer);	begin		if infoEditing[whichinfo] then  			begin				if infoTop[whichinfo]>infoEditRow[whichinfo] then {we are scrolled down too far}					begin						SetControlValueLong(infoScroll[whichinfo], infoEditRow[whichinfo]);						ScrollInfoWindow(whichinfo, true);					end				else if infoTop[whichinfo]+infoRows[whichinfo]-1 < infoEditRow[whichinfo] then					begin						SetControlValueLong(infoScroll[whichinfo], infoEditRow[whichinfo] - infoRows[whichinfo]+1);						ScrollInfoWindow(whichinfo, true);					end;			end;	end;{-----------------------------------------------------------------------------}	procedure ResetVerticalInfoScrollControlMax (whichinfo: integer);	begin		if MaximumInfoRows(whichinfo) > infoRows[whichinfo] then			SetControlMaximumLong(infoScroll[whichinfo], MaximumInfoRows(whichinfo) - infoRows[whichinfo] + 1)		else			SetControlMaximumLong(infoScroll[whichinfo], 1);	end;{-----------------------------------------------------------------------------}	procedure ResetInfoScroll (whichinfo: integer);	begin		if infoWithToolRow[whichinfo] then			HugTwoScrolls(infoWindow[whichInfo], infoNameEnd[whichinfo], infoLW[whichinfo] * infoTitleLines - 2, infoButtonRowHeight, infoHScroll[whichinfo], infoScroll[whichinfo])		else			HugTwoScrolls(infoWindow[whichInfo], infoNameEnd[whichinfo], infoLW[whichinfo] * infoTitleLines - 2, 0, infoHScroll[whichinfo], infoScroll[whichinfo]);		ResetVerticalInfoScrollControlMax(whichinfo);		if InfoColumnRight(whichinfo, MaximumInfoColumns(whichInfo)) + scrollwidth + 1 > infoDrawRect[whichinfo].right then			SetControlMaximumLong(infoHScroll[whichinfo], InfoColumnRight(whichinfo, MaximumInfoColumns(whichInfo)) + scrollwidth + 1 - infoDrawRect[whichinfo].right)		else			SetControlMaximumLong(infoHScroll[whichinfo], 1);	end;{-----------------------------------------------------------------------------}	procedure AdjustInfoScrolls (whichinfo: integer);		var			top: longint;			numElements, extrawidth: longint;	begin		numElements := MaximumInfoRows(whichinfo);		if numElements > infoRows[whichinfo] then   {more characters than can fit in whichinfo at once}			begin				top := numElements - infoRows[whichinfo] + 1;				if infoTop[whichinfo] > top then					infoTop[whichinfo] := top;				SetControlMaximumLong(infoScroll[whichinfo], top)			end		else	{numElements <= infoRows[whichinfo], characters can all fit onto window at once}			begin				infoTop[whichinfo] := 1;				if numElements < infoRows[whichinfo] then					begin						infoRows[whichinfo] := numElements;						AdjustInfoRowsIfBelowMinimum(whichinfo);						SizeInfoWindow(whichinfo,false, false);					end;				SetControlMaximumLong(infoScroll[whichinfo], 1);			end;		ExtraWidth := InfoColumnRight(whichinfo, MaximumInfoColumns(whichInfo)) + scrollwidth + 1 - infoDrawRect[whichinfo].right;		if extraWidth <= 0 then			begin				SetControlMaximumLong(infoHScroll[whichinfo], 1);				infoLeft[whichInfo] := 1;			end		else			begin				if infoLeft[whichinfo] > extrawidth then					infoLeft[whichinfo] := extrawidth;				SetControlMaximumLong(infoHScroll[whichinfo], extrawidth);			end;		infoBottom[whichinfo] := infoTop[whichinfo] + infoRows[whichinfo]-1;		SetControlValueLong(infoHScroll[whichinfo], infoLeft[whichInfo]);	end;{-----------------------------------------------------------------------------}	procedure SetInfoLW (whichinfo: integer);		var			tport: windowptr;	begin		genericGetPort(tport);		genericSetPort(infoWindow[whichinfo]);		TextFont(infoFont[whichinfo]);		TextSize(infoFontSize[whichinfo]);		TextFace(infoStyle[whichinfo]);		CalcLineWidthDescent(infoTE[whichinfo],infoFont[whichinfo],infoLW[whichinfo],infoFontDescent[whichinfo],infoFontAscent[whichinfo]);		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	procedure InfoPositions (whichinfo: integer);		var			j, k, lastend: longint;			minwidth: integer;			infoWindowColumn: infoWindowColumnPtr;	begin		lastend := InfoNameStart[whichinfo];		for j := 0 to MaximumInfoColumns(whichinfo) do			begin				infoWindowColumn := InfoColumnPtr(whichinfo, j);				if infoWindowColumn<> nil then					with infoWindowColumn^ do						begin							minwidth := 14;							if menu then								minwidth := minwidth + 10;							if title <> '' then								minwidth := minwidth + StringWidth(title);							width := IntegerMax(minwidth, width);							if whichinfo = charinfo then								begin									if (InfoColumnID(whichinfo, j) in [CharInfoCI, CharInfoRI, CharInfoRC]) then										begin											width := 10;											if CharInfoExpon then												width := IntegerMax(StringWidth('8.88e-09') + 5, width)											else												begin													width := 12 + StringWidth('0.');													for k := 1 to sigindices do														width := width + CharWidth('0');												end										end;								end;							left := lastend;							if show then								right := left + width							else								right := left;							lastend := right;						end;			end;	end;{-----------------------------------------------------------------------------}	procedure CalcMaxInfoNameW (whichinfo: integer);		const 			minInfoNameWidth = 100;		var			namewidth, ic, numelements: longint;			infoWindowColumn: infoWindowColumnPtr;	begin		if infoDirtyNames[whichinfo] then			begin				namewidth := 0;				TextFont(infoFont[whichinfo]);				TextSize(infoFontSize[whichinfo]);				TextFace(infoStyle[whichinfo]);				infoWindowColumn := InfoColumnPtr(whichinfo, infoName);				if infoWindowColumn<> nil then					infoMaxNameWidth[whichinfo] := StringWidth(infoWindowColumn^.title)				else					infoMaxNameWidth[whichinfo] := 0;				numelements := MaximumInfoRows(whichinfo);				for ic := 1 to numelements do					begin						namewidth := StringWidth(InfoNameString(whichinfo, ic));						if infoMaxNameWidth[whichinfo] < namewidth then							infoMaxNameWidth[whichinfo] := namewidth;					end;				if whichinfo=charpartnameinfo then					begin						if infoMaxNameWidth[whichinfo] < 125 then							infoMaxNameWidth[whichinfo] := 125;					end				else if infoMaxNameWidth[whichinfo] < minInfoNameWidth then					infoMaxNameWidth[whichinfo] := minInfoNameWidth;				infoDirtyNames[whichinfo] := false;			end;	end;{-----------------------------------------------------------------------------}	procedure ResetInfoWindow (whichinfo: integer);		var			width: integer;			tport: WindowPtr;	begin		genericGetPort(tport);		SETCURSOR(clockCursor);		InfoPositions(whichinfo);		width := InfoColumnRight(whichinfo, MaximumInfoColumns(whichInfo)) + scrollwidth;		SizeWindow(infoWindow[whichinfo], width, WindowPortRect(infowindow[whichInfo]).bottom, false);{    MoveControl(infoScroll[whichinfo], width - scrollwidth, infoLW[whichinfo]);}		ResetInfoScroll(whichInfo);		if infoOpen[whichinfo] then			InvalidateWindow(infoWindow[whichinfo], true);		genericSetPort(tport);	end;{----------------------------------------------------------------------------}	function CalcInfoWindowHeight (whichinfo: integer): integer;	begin		if infoWithToolRow[whichinfo] then			CalcInfoWindowHeight := (infoRows[whichinfo] + infoTitleLines) * infoLW[whichinfo] - 1 + scrollwidth+infoButtonRowHeight		else			CalcInfoWindowHeight := (infoRows[whichinfo] + infoTitleLines) * infoLW[whichinfo] - 1 + scrollwidth;	end;{----------------------------------------------------------------------------}	function InfoRowsLessThanPreferredMinimum (numElements: longint): boolean; {\\\ WH}	begin		InfoRowsLessThanPreferredMinimum := (numElements >= 1) & (numElements <= infoRowsPreferredMinimum);	end;{----------------------------------------------------------------------------}	procedure CalcInfoDrawRect(whichinfo,height,width:integer);	begin		infoDrawRect[whichinfo] := WindowPortRect(infowindow[whichInfo]);		infoDrawRect[whichinfo].right := width;		if infoWithToolRow[whichinfo] then			infoDrawRect[whichinfo].bottom := height-infoButtonRowHeight		else			infoDrawRect[whichinfo].bottom := height;		infoAllCellsDrawRect[whichinfo] := infoDrawRect[whichinfo];		infoAllCellsDrawRect[whichinfo].top := infoLW[whichinfo] * infoTitleLines;		infoAllCellsDrawRect[whichinfo].bottom := infoAllCellsDrawRect[whichinfo].bottom-scrollWidth;	end;{----------------------------------------------------------------------------}	procedure ShrinkWrapInfoWindow (whichinfo: integer; var height: integer; width: integer);		var			numElements: longint;	begin		if infoWithToolRow[whichinfo] then			height := height-infoButtonRowHeight;		numElements := MaximumInfoRows(whichinfo);		infoRows[whichinfo] := ((height + 2 - scrollwidth) div infoLW[whichinfo]) - infoTitleLines;		infoBottom[whichinfo] := infoTop[whichinfo] + infoRows[whichinfo]-1;		if numElements < infoRows[whichinfo] then			begin				infoTop[whichinfo] := 1;				infoRows[whichinfo] := numElements;				infoBottom[whichinfo] := infoTop[whichinfo] + infoRows[whichinfo]-1;				{if numElements < 1 then infoRows[whichinfo] := 1;}			end;		AdjustInfoRowsIfBelowMinimum(whichinfo);{so, if the number of rows in the window is less than the total number of objects, }{and the total number of objects is inside some particular limits (e.g. less than}{InfoRowsPerferredMinimum), then the number of rows is increased to that limit}		if (InfoRows[whichinfo] < numElements) & InfoRowsLessThanPreferredMinimum(numElements) then			InfoRows[whichinfo] := numElements;		infoBottom[whichinfo] := infoTop[whichinfo] + infoRows[whichinfo]-1;		height := CalcInfoWindowHeight(whichinfo);		CalcInfoDrawRect(whichinfo, height,width);		infoBottom[whichinfo] := infoTop[whichinfo] + infoRows[whichinfo]-1;	end;{-----------------------------------------------------------------------------}	procedure SizeInfoWindow (whichinfo: integer; eraseWindow, adjustWidth: boolean);		var			width, height: integer;			tport: windowptr;			infoWindowColumn: infoWindowColumnPtr;	begin				genericGetPort(tport);		genericSetPort(infoWindow[whichinfo]);		SetInfoLW(whichinfo);		height := WindowPortRect(infowindow[whichInfo]).bottom;		TextFace(infoStyle[whichinfo] + [bold]);		infoNameStart[whichinfo] := StringWidth(StringFromNum(MaximumInfoRows(whichinfo))) + 8;		TextFace(infoStyle[whichinfo]);		ShrinkWrapInfoWindow(whichinfo, height,WindowPortRect(infowindow[whichInfo]).right);		CalcMaxInfoNameW(whichinfo);		SetInfoColumnWidth(whichinfo, infoName,infoMaxNameWidth[whichinfo] + 10);		infoWindowColumn := InfoColumnPtr(whichinfo, infoName);		if infoWindowColumn = nil then			infoNameEnd[whichinfo] := infoNameStart[whichinfo]		else			infoNameEnd[whichinfo] := infoNameStart[whichinfo] + infoWindowColumn^.width;		case whichinfo of			charinfo: 				begin					SetInfoColumnIDShow(whichinfo, CharInfoCodPos,nucleotides);					SetInfoColumnIDShow(whichinfo, CharInfoExpand,not molecular);					SetInfoColumnIDShow(whichinfo, CharInfoStates,(datatype in [standard, standard32, RNA, DNA, protein]) & (editorOpen | treeopen));					SetInfoColumnIDShow(whichinfo, CharInfoSteps,treeopen & count);					SetInfoColumnIDShow(whichinfo, CharInfoChgs,treeopen & calctreechanges);					SetInfoColumnIDShow(whichinfo, CharInfoCI,treeopen & calcCI);					SetInfoColumnIDShow(whichinfo, CharInfoRI,treeopen & calcRI);					SetInfoColumnIDShow(whichinfo, CharInfoRC,treeopen & calcRC);					SetInfoColumnIDShow(whichinfo, CharInfoMin,treeopen & (ShowMinSteps));					SetInfoColumnIDShow(whichinfo, CharInfoMax,treeopen & (ShowMaxSteps));					SetInfoColumnIDShow(whichinfo, CharInfoMissing,charInfoShowMissing);					SetInfoColumnIDShow(whichinfo, CharInfoGaps,charInfoShowGaps);					SetInfoColumnIDShow(whichinfo, CharInfoPolymorphisms,charInfoShowPolymorphisms);					SetInfoColumnIDShow(whichinfo, CharInfoUncertainty,charInfoShowUncertainty);					SetInfoColumnIDShow(whichinfo, CharInfoPartition,charInfoShowPartition);					// SetInfoColumnIDShow(whichinfo, CharInfoMPRs,treeopen & calctreechanges);				end;			taxinfo: 				begin					SetInfoColumnIDShow(whichinfo, TaxInfoIncExc,treeopen);					SetInfoColumnIDShow(whichinfo, TaxInfoSeqLength,molecular);					SetInfoColumnIDShow(whichinfo, TaxInfoA,nucleotides & taxInfoShowNucFrequencies);					SetInfoColumnIDShow(whichinfo, TaxInfoC,nucleotides & taxInfoShowNucFrequencies);					SetInfoColumnIDShow(whichinfo, TaxInfoG,nucleotides & taxInfoShowNucFrequencies);					SetInfoColumnIDShow(whichinfo, TaxInfoT,nucleotides & taxInfoShowNucFrequencies);					SetInfoColumnIDShow(whichinfo, TaxInfoAT,nucleotides & taxInfoShowNucFrequencies);					SetInfoColumnIDShow(whichinfo, TaxInfoStopCodons,taxInfoShowStopCodons & ((nucleotides & SomeCoding) | (datatype=protein)));					SetInfoColumnIDShow(whichinfo, TaxInfoLowerCase,nucleotides & taxInfoShowLowerCase);					SetInfoColumnIDShow(whichinfo, TaxInfoLastBase,taxInfoShowLastBase);					SetInfoColumnIDShow(whichinfo, TaxInfoFirstBase,taxInfoShowFirstBase);					SetInfoColumnIDShow(whichinfo, TaxInfoPartTriplets,taxInfoShowPartTriplets & (nucleotides & SomeCoding));					SetInfoColumnIDShow(whichinfo, TaxInfoUncertainty,taxInfoShowUncertainty);					SetInfoColumnIDShow(whichinfo, TaxInfoPolymorphism,taxInfoShowPolymorphism);				end;			nexusblockinfo: 				begin					SetInfoColumnIDShow(whichinfo, NexusBlockInfoTitle,nexusBlockInfoShowTitleLink);					SetInfoColumnIDShow(whichinfo, NexusBlockInfoLinkText,nexusBlockInfoShowTitleLink);				end;			otherwise				;		end;		InfoPositions(whichinfo);		if adjustWidth then			begin				width := InfoColumnRight(whichinfo, MaximumInfoColumns(whichInfo)) + scrollwidth + 1;				if width > ScreenBoundsRect.right - ScreenBoundsRect.left - 12 then					width := ScreenBoundsRect.right - ScreenBoundsRect.left - 12;				{if width < 300 then width := 300;}			end		else			width := WindowPortRect(infowindow[whichInfo]).right;		HideControl(infoScroll[whichinfo]);		HideControl(infoWindowButton[whichinfo]);		if infoEditing[whichinfo] then			MoveInfoTE(whichinfo, infoEditRow[whichinfo]);		SizeWindow(infoWindow[whichinfo], width, height, false);		ResetInfoScroll(whichinfo);  		CalcInfoDrawRect(whichinfo,height,width);		CalcInfoButtonRowBoxes(whichinfo);		genericSetPort(tport);		if infoOpen[whichinfo] then			InvalidateWindow(infoWindow[whichinfo],eraseWindow);	end;{-----------------------------------------------------------------------------}	procedure ShowCharPartitionColumn;	begin		charInfoShowPartition := true;		myCheckMenuItem(CharListOptionsMHdl, ShowPartitioninCharListItem, charInfoShowPartition);		SizeInfoWindow (charinfo,false,true);	end;{----------------------------------------------------------------------------}	procedure TurnOnInfoEditing (whichinfo: integer; ic: longint);		var			oldstate: SignedByte;			ds: str255;			box: rect;	begin		DeSelectAllInfo(whichinfo);		LockHandle(infoTE[whichinfo], oldstate);		ds := InfoNameString(whichinfo, ic);		TESetText(Pointer(ORD4(@ds) + 1), ORD4(length(ds)), infoTE[whichinfo]);		infoEditing[whichinfo] := true;		infoEditRow[whichinfo] := ic;		ScrollInfoWindowToEditingRow(whichinfo);				MoveInfoTE(whichInfo, ic);		infoTE[whichinfo]^^.txFont := infoFont[whichinfo];		infoTE[whichinfo]^^.txSize := infoFontSize[whichinfo];		infoTE[whichinfo]^^.txFace := infoStyle[whichinfo];		EndSetUpEdit(infoTE[whichinfo]);		ResetHandle(infoTE[whichinfo], oldstate);{$IFC NOT ALWAYSENABLED}		{Davidundo: myDisableItem(EditMHdl, UndoItem);} {$ENDC}		FixCopyPasteMenuItems;	end;{----------------------------------------------------------------------------}	procedure SetInfoRowName (whichinfo: integer; theRow: longint; name: str255);		var			tempP: WindowPtr;			ds, oldName: str255;			linkH: Handle;			oldBack: RGBColor;			theChain: integer;			j: longint;	begin		genericGetPort(tempP);		genericSetPort(infowindow[whichinfo]);		case whichinfo of			taxinfo: 				begin					oldName := TaxonName(theRow);					if not StringsEqual(@name, @oldname, tnw) then						begin							SetTaxonName(theRow, name);							godraw := true;							InvalidateEditorNames(true);							infoDirtyNames[whichinfo] := true;							dirtyfile := true;						end;				end;			typeinfo: 				begin					oldName := TypeName(theRow);					if not StringsEqual(@name, @oldname, typesig) then						begin							SetTypeName(theRow, name);							infoDirtyNames[whichinfo] := true;							dirtyfile := true;						end;				end;			nexusblockinfo:				begin					SetNexusBlockName(theRow,name);				end;			charpartnameinfo:				begin					SetNameOfCharPartName(theRow,name);					if infoOpen[charinfo] then						InvalidateInfoColumn(charinfo,CharInfoPartition, 1,numchars);				end;			wtsetinfo,typesetinfo,exsetinfo,charsetinfo,taxsetinfo, treeinfo,charpartinfo: 				begin					LinkH := newHandle(2);    {must create as GetLink expects it created}					theChain := ChainFromInfo(whichinfo);					GetLink(theChain, LinkNumberFromInfoRow(theChain,theRow), linkH, false);					SetLinkName(linkH, name);					SetLink(theChain, LinkNumberFromInfoRow(theChain,theRow), linkH);					ZapHandle(linkH);					infoDirtyNames[whichinfo] := true;					if (whichinfo=treeinfo) & not dirtyLink[treechain] & ( linknumber[treechain]=LinkNumberFromInfoRow(treechain,theRow))then						begin							InvalidateWindow(tlegwindow,true);							treeName^^ := name;						end;					dirtyfile := true;					if whichinfo=charsetinfo then						RebuildShadeCharSetMenu					else if whichinfo=taxsetinfo then						RebuildConsensusTaxSetMenu;				end;			charinfo: 				begin					oldName := CharName(theRow);					if not StringsEqual(@name, @oldname, tnw) then						begin							SetCharName(theRow, name);							if (traceshown = traceAllChanges) & (summaryview=asticks) & ticknames then								godraw := true;							if ((CWChart=CWCC2T) | (CWChart=CWCC2TF)) & (CWView = tableView) then								InvalidateWindow(chartwindow, true);							if theRow = statesWindowCharacter then								InvalidateWindow(statesWindow,false);							InvalidateWindow(branchlistwindow, false);							InvalidateEditorNames(false);							InvalidateWindow(chlegwindow, false);							infoDirtyNames[whichinfo] := true;							dirtyfile := true;						end;				end;			otherwise				;		end;		genericSetPort(tempP);	end;{----------------------------------------------------------------------------}	procedure ReturnInfoValue (whichinfo: integer);		var			oldState: SignedByte;			ds: str255;	begin		if infoEditing[whichinfo] then			begin				LockHandle(infoTE[whichinfo], oldstate);				GetDialogItemText(infoTE[whichinfo]^^.hText, ds);				ResetHandle(infoTE[whichinfo], oldstate);				SetInfoRowName(whichinfo,infoEditRow[whichinfo],ds);			end;	end;{----------------------------------------------------------------------------}	procedure ReturnAllInfoValues;	var j: integer;	begin		for j := 1 to numInfoWindows do			if infoOpen[j] then				ReturnInfoValue(j);	end;{----------------------------------------------------------------------------}	procedure TurnOffInfoEditing (whichinfo: integer);		var			tempP: WindowPtr;	begin		if infoEditing[whichinfo] then			begin				genericGetPort(tempP);				genericSetPort(infowindow[whichinfo]);				ReturnInfoValue(whichInfo);				TEDeactivate(infoTE[whichinfo]);				infoEditing[whichinfo] := false;				genericSetPort(tempP);				FixCopyPasteMenuItems;			end;	end;{-----------------------------------------------------------------------------}	procedure SetDataFormat (whichformat: integer; resetsymbols: boolean);{datatype is set only: here, and in ImpForeignFiles (switch from DNA to RNA only)}{if resetsymbols, then will reset symbols to standard}		var			isfrom, oldmaxstate, olddatatype, j: integer;			ic: longint;			charHdl: chHdl;			setcodPos: boolean;			AATranslateWasVisible: boolean;			infoWindowColumn: infoWindowColumnPtr;	begin		oldmaxstate := maxstate;		olddatatype := datatype;		AATranslateWasVisible := fileopen & editorOpen & AAAutoTranslationVisible;		setcodPos := not nucleotides and (whichformat in [DNA, RNA]);		if whichformat in [DNA, RNA, standard] then			numbytes := 2		else if whichformat in [standard32, protein] then			numbytes := 4;		if statesWindowOpen then			if (whichFormat in [DNA,RNA,protein]) then				begin					HideWindow(statesWindow);					statesWindowOpen := false;				end;		DoBitSet;		case whichformat of			DNA: 				begin					datatype := DNA;					maxstate := maxDNAstate;					symbols := 'ACGT';					symbolson := true;				end;			RNA: 				begin					datatype := RNA;					symbols := 'ACGU';					symbolson := true;					maxstate := maxDNAstate;				end;			standard: 				begin					datatype := standard;					maxstate := maxstbit;					if resetsymbols then						symbols := '01';					FillRestSymbols;				end;			standard32: 				begin					datatype := standard32;					maxstate := maxstbit;					if resetsymbols then						symbols := '01';					FillRestSymbols;				end;			protein: 				begin					datatype := protein;					maxstate := maxproteinstate;					symbols := protSymbols;					symbolson := true;				end;			continuous: 				begin					datatype := continuous;					maxstate := 31;					symbols := '';					symbolson := false;				end;			otherwise				;		end;		DoResetTypes;{		datatype:=datatype;				CheckCurrentTypes;}		nucleotides := datatype in [DNA, RNA];		SetStateSetBoundaries(nucleotides);		molecular := datatype in [DNA, RNA, protein];		if setcodPos then			for ic := 1 to numChars do				begin					charHdl := getchhdl(ic);					charHdl^^.coding := false;  {codingcode: was false}										{31March99 codonPos change: coding changed back to false}					charHdl^^.codpos := nonCoding;{31March99 codonPos change: was codeNotSet}				end;		if nucleotides then			randommax := 3		else			randommax := 1;		for j := 0 to RandomMax do			begin				RandomFillH^^[j] := 100 div (randomMax + 1);				RandomObservedFillH^^[j] := 100 div (randomMax + 1);				RandomAncH^^[j] := 100 div (randomMax + 1);			end;		RandomFillMax := RandomMax;		RandomObservedFillMax := RandomMax;		RandomAncMax := RandomMax;		AdjustAllNexusBlockWillWrites;		SetInfoColumnIDShow(charinfo, CharInfoCodPos,nucleotides);				infoWindowColumn := InfoColumnPtr(charinfo, infoName);		if infoWindowColumn <> nil then			if molecular then				infoWindowColumn^.title := 'Site'			else				infoWindowColumn^.title := 'Character';		if infoOpen[charinfo] and ((maxstate <> oldmaxstate) or (datatype <> olddatatype)) then			SizeInfoWindow(charinfo,true, true);		if infoOpen[charinfo] & (frontwindow=infoWindow[charinfo]) then			ConvertToInfoSelectSubMenu(charinfo);		if infoOpen[taxinfo] then			SizeInfoWindow(taxinfo, true, true);		if statesWindowOpen then			begin				InvalidateWindow(statesWindow,true);				SizeStatesWindow;			end;		if datatype <> olddatatype then			begin				EmptyCellBlock(EWFindSequenceBlockP);				editorCharacterSetToShade := defaultCharSetToShade;			end;				if AATranslateWasVisible & not nucleotides then			ReSizeEditorWindow;		if not nucleotides & (editorColorCellsAAState=editorColorCellsMode) then			if molecular then				editorColorCellsMode := editorColorCellsState			else				editorColorCellsMode := editorColorCellsOff;		if editorOpen then			begin				SetStateNamesItem;				CheckToolValidity(editorTools);				InvalidateWindow(toolPaletteWindow[editorTools],false);			end;				fillchar := missing;		FixPrintOtherMenu;	end;{-----------------------------------------------------------------------------}	procedure CheckCharInfoSelected (var foundnum, onefound: integer);		var			ic: integer;	begin		foundnum := 0;		onefound := 1;		for ic := 1 to numChars do			if InfoRowSelected(charinfo, ic) then				begin					if foundnum = 1 then						begin							foundnum := foundnum + 1;							leave;						end;					foundnum := 1;					onefound := ic;				end;	end;{-----------------------------------------------------------------------------}	procedure CharToChange (var foundnum, onefound: integer);	begin		if IsTreeWindow(frontwindow) then			begin				foundnum := 1;				onefound := i;			end		else if IsEditorWindow(frontwindow) then			begin				foundnum := CharOfCell( editorSelectionBotRight) - CharOfCell(editorSelectionTopLeft);				onefound := CharOfCell(editorSelectionTopLeft);			end		else			CheckCharInfoSelected(foundnum, onefound);	end;end.