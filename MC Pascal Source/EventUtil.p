unit EventUtil;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright David R. Maddison & Wayne P. Maddison 1986-1998}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}interface	uses		Quickdraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, 		Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap, 		 Globals, SetLibInterface, UtilLibInterface, MemoryUtil, CarbonUtil, SimpleUtil,   Script;	function GetSleep: longint;	function GetEvent (theMask: integer; var theEvent: EventRecord): boolean;	function OptionEvent (Event: EventRecord): BOOLEAN;	function ShiftEvent (Event: EventRecord): BOOLEAN;	function CommandEvent (Event: EventRecord): BOOLEAN;	function ControlEvent (Event: EventRecord): BOOLEAN;	function CapsLockEvent (Event: EventRecord): BOOLEAN;	function OptionDown: BOOLEAN;	function ShiftDown: BOOLEAN;	function CommandDown: BOOLEAN;	function ControlDown: BOOLEAN;	function CapsLockDown: BOOLEAN;	function KeyBoardCancel (ev: EventRecord): boolean;	function CommandPeriod: BOOLEAN;	function hitReturn (Event: EventRecord): boolean;	procedure InvalidateWindow (WindP: windowPtr; fullerase: boolean);	procedure ValidateWindow (WindP: WindowPtr);	procedure EquivocalCursor (turn: boolean);{еееееееееееееееееееееее}implementation {е$S EventUtil}{-----------------------------------------------------------------------------}{-----------------------------------------------------------------------------}	function hitReturn (Event: EventRecord): boolean;	begin		hitReturn := (((event.message mod 256) = 3) or ((event.message mod 256) = 13));	end;{-----------------------------------------------------------------------------}	function getsleep: longint;	{this specifies the mount of time OTHER applications will get when there are no events pending for MacClade}	begin		if isforeground & (frontwindow <> nil) then			getsleep := 3		else if isMacOSX then			getsleep := 5		else if isforeground then			getsleep := 10		else if thermo2 then			if equivocalCycleCalculation then				getsleep := 5			else				getsleep := 20		else if thermo1 then			if equivocalCycleCalculation then				getsleep := 5			else				getsleep := 30		else 			getsleep := maxlongint;	end;{||||||||||||||||||||||||||||||||||||||  Modifer Keys  ||||||||||||||||||||||||||||||||||||||||}{the ___Event functions can be called anytime}{the ___Down functions should be called only when no relevant Event is available,}{as they are dangerous - the GetNextEvent they contain may lead to unexpected}{Multifinder Swaps, and may cause extreme slowdown if there is background processing}{   They are safest to use when you are in a Modal DLOG}{-----------------------------------------------------------------------------}	function OptionEvent (Event: EventRecord): BOOLEAN;	begin		OptionEvent := (BitAnd(Event.modifiers, optionKey) <> 0);	end;{-----------------------------------------------------------------------------}	function ShiftEvent (Event: EventRecord): BOOLEAN;	begin		ShiftEvent := (BitAnd(Event.modifiers, shiftKey) <> 0);	end;{-----------------------------------------------------------------------------}	function CommandEvent (Event: EventRecord): BOOLEAN;	begin		CommandEvent := (BitAnd(Event.modifiers, cmdKey) <> 0);	end;{-----------------------------------------------------------------------------}	function ControlEvent (Event: EventRecord): BOOLEAN;	begin		ControlEvent := (BitAnd(Event.modifiers, controlKey) <> 0);	end;{-----------------------------------------------------------------------------}	function CapsLockEvent (Event: EventRecord): BOOLEAN;	begin		CapsLockEvent := (BitAnd(Event.modifiers, alphalock) <> 0);	end;{-----------------------------------------------------------------------------}	function GetEvent (theMask: integer; var theEvent: EventRecord): boolean;		var			os: oserr;			eventFound: boolean;	begin		if theMask = app1Mask then			os := PostEvent(app1evt, 0);		if haswaitnextevent then			eventFound := WaitNextEvent(theMask, theEvent, GetSleep, nil)		else			begin{$IFC NOT CARBON}				SystemTask;{$ENDC}				eventFound := GetNextEvent(theMask, theEvent);			end;		GetEvent := eventFound;	end;{-----------------------------------------------------------------------------}	function OptionDown: BOOLEAN;		{tests to see if option key is down}{only called in ReadData and ChartMenu - 20 July 91}{also in various development and BETA stuff}		var			tev: eventrecord;			modifiers : UInt32;	begin{$IFC CARBON}		modifiers := GetCurrentKeyModifiers;		OptionDown := BitAnd(modifiers, optionKey) <> 0;{$ELSEC}		OptionDown := GetEvent(app1Mask, tev) & (BAND(tev.modifiers, optionKey) <> 0);{$ENDC}	end;{----------------------------------------------------------------------------}	function CommandDown: BOOLEAN;		{tests to see if command key is down}{Use GetKeys?}{called only once, in ReadData - 20 July 91}		var			tev: eventrecord;			modifiers : UInt32;	begin{$IFC CARBON}		modifiers := GetCurrentKeyModifiers;		CommandDown := BitAnd(modifiers, cmdKey) <> 0;{$ELSEC}		CommandDown := GetEvent(app1Mask, tev) & (BAND(tev.modifiers, cmdKey) <> 0);{$ENDC}	end;{----------------------------------------------------------------------------}	function ShiftDown: BOOLEAN;	{tests to see if shift key is down}{not called anywhere - 20 July 91}		var			tev: eventrecord;			modifiers : UInt32;	begin{$IFC CARBON}		modifiers := GetCurrentKeyModifiers;		ShiftDown := BitAnd(modifiers, shiftKey) <> 0;{$ELSEC}		ShiftDown := GetEvent(app1Mask, tev) & (BAND(tev.modifiers, shiftKey) <> 0);{$ENDC}	end;{-----------------------------------------------------------------------------}	function ControlDown: BOOLEAN;	{tests to see if control key is down}{not called anywhere - 20 July 91}		var			tev: eventrecord;			modifiers : UInt32;	begin{$IFC CARBON}		modifiers := GetCurrentKeyModifiers;		ControlDown := BitAnd(modifiers, controlKey) <> 0;{$ELSEC}		ControlDown := GetEvent(app1Mask, tev) & (BAND(tev.modifiers, controlKey) <> 0);{$ENDC}	end;{-----------------------------------------------------------------------------}	function CapsLockDown: BOOLEAN;	{tests to see if capslock key is down}{not called anywhere - 20 July 91}		var			tev: eventrecord;			modifiers : UInt32;	begin{$IFC CARBON}		modifiers := GetCurrentKeyModifiers;		CapsLockDown := BitAnd(modifiers, alphalock) <> 0;{$ELSEC}		CapsLockDown := GetEvent(app1Mask, tev) & (BAND(tev.modifiers, alphalock) <> 0){$ENDC}	end;{----------------------------------------------------------------------------}	function KeyBoardCancel (ev: EventRecord): boolean;{returns true if ev is command period or esc}{this works on international keyboards; code follows that of Apple Tech Note # 263}{$IFC CARBON}	begin		KeyBoardCancel := CheckEventQueueForUserCancel;	end;{$ELSEC}		const			KMaskModifier = $FE00;			kMaskVirtualKey = $0000FF00;			kMaskASCII1 = $00FF0000;			kMaskASCII2 = $000000FF;			kKeyUpMask = $0080;			kPeriod = ORD('.');		var			keyCode: integer;			virtualKey, KeyInfo, lowChar, highChar, keyCId: longint;			state: UInt32;			KCHRH: Handle;	begin		KeyBoardCancel := false;		if (ev.what = keydown) | (ev.what = autoKey) then			if ((ev.message mod 256) = 27) then				KeyBoardCancel := true			else				begin					if BAND(ev.modifiers, cmdKey) <> 0 then						begin							virtualKey := BAND(ev.message, kMaskVirtualKey) div 256;							keyCode := BAND(ev.modifiers, kMaskModifier);							keyCode := BOR(keyCode, kKeyUpMask);							keyCode := BOR(keyCode, virtualKey);							state := 0;							KCHRH := nil;							if (KCHRPtr = nil) & hasGetEnvirons then								begin									KCHRPtr := Ptr(GetScriptManagerVariable(smKCHRCache));									if KCHRPtr = nil then										begin											keyCId := GetScriptVariable(GetScriptManagerVariable(smKeyScript), smScriptKeys);											KCHRH := GetResource('KCHR', keyCId);											if KCHRH <> nil then												KCHRPtr := KCHRH^											else												KCHRPtr := nil;										end;								end;							if KCHRPtr <> nil then								begin									keyInfo := KeyTransLate(KCHRPtr, keyCode, state);									if KCHRH <> nil then										ReleaseResource(KCHRH);								end							else								keyInfo := ev.message;							lowChar := BAND(keyInfo, kMaskASCII2);							highChar := BSR(BAND(KeyInfo, kMaskASCII1), 16);							if (lowChar = kPeriod) | (highChar = kPeriod) then								KeyBoardCancel := true;						end;				end;	end;{$ENDC}{----------------------------------------------------------------------------}	function CommandPeriod: BOOLEAN;		var			tev: EventRecord;	begin{$IFC CARBON}		CommandPeriod := CheckEventQueueForUserCancel;{$ELSEC}		CommandPeriod := false;{v4: beware, this will eat up keydown events}		while GetEvent(keydownmask, tev) do			if KeyBoardCancel(tev) then				begin					CommandPeriod := true;					leave;				end;{$ENDC}	end;{-----------------------------------------------------------------------------}{$IFC FALSE}	procedure WriteDeskScrap;		var			oldstate: SignedByte;{called when MacClade quits, when a non-MacClade window is activated, and when MacClade suspends under multifinder}	begin{$IFC NOT DEMO}		if scraptextdirty and not scrapispict then			begin				scrapcompare := zeroscrap;				resultcode := TEToScrap;				scraptextdirty := false;{v4: write tab-delimited  clipboard for a block of cells}{v4: write tab or return delimited clipboard for a set of taxon or character names}			end		else if scrappictdirty and scrapisPICT then			begin				scrapcompare := zeroscrap;				LockHandle(clippicture, oldstate);				resultcode := PutScrap(GetHandleSize(Handle(clippicture)), 'PICT', Ptr(GetMaster(Handle(clippicture))));				ResetHandle(clippicture, oldstate);				scrappictdirty := false;			end;{$ENDC}	end;{$ENDC}{-----------------------------------------------------------------------------}	procedure InvalidateWindow (WindP: windowPtr; fullerase: boolean);		var			tport: windowptr;			oldRgn: RgnHandle;	begin		if WindP <> nil then			begin				genericGetPort(tport);				genericSetPort(WindP);				if fullerase then					begin						oldRgn := NewRgn;						GetClip(oldRgn);						ClipRect(WindowPortRect(windP));						EraseRect(WindowPortRect(windP));						SetClip(oldRgn);						ZapRegion(oldRgn);					end;				InvalidateWindowRect(WindP, WindowPortRect(windP), false);				genericSetPort(tport);			end;	end;{-----------------------------------------------------------------------------}	procedure ValidateWindow (WindP: WindowPtr);		var			tport: windowptr;	begin		genericGetPort(tport);		genericSetPort(WindP);		myValidRect(windP,WindowPortRect(windP));		genericSetPort(tport);	end;{----------------------------------------------------------------------------}	function UpdatePending (WindP: WindowPtr): boolean;	begin		UpdatePending := not EmptyRgn(myGetUpdateRgn(WindP));	end;{|||||||||||||||||||||||||||||||  Cursor  |||||||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	procedure EquivocalCursor (turn: boolean);	begin		if turn then			if cyclecursnum = maxcyclecurs then				cyclecursnum := 0			else				cyclecursnum := cyclecursnum + 1;		SetCursor(cyclecurs[cyclecursnum]);	end;{----------------------------------------------------------------------------}end.