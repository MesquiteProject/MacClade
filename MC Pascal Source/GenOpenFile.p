unit GenOpenFile;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface, 		 MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, TypeUtil, ChartWUtil, 		 TypeDLOGUtil, SymbolsNames, TaxonCHUtil, ReadWriteUtil, ReadUtil, MenuUtil, InfoWindows, TreeMakerUtil, 		 Settings, LinkUtil, CHUNK, TraceControl, ReadDataBlock, GeneticCode, SpreadUtil, RowColumn, TreeMaker, 		 TreeDrawer, Windows, TreeGet, ReadMisc, WriteUtil, ReadData, ReadTreeFile, GenCloseFile,		 ConsensusSequences, CharPartitions;	procedure InitJustProgram;	procedure InitProgramAndFile;	procedure ReadjustWindows;	procedure InitWindowRects;	procedure InitValues;	procedure StartNewFile;	procedure BeginFile(doGetFileIfError: boolean; var success, userCancelled:boolean);	function ImportSequences(fileformat: integer; addAsNewSequences, saveCharSet,nameAsFile: boolean; charSetName: str255) : boolean;	function ChooseImportSequence(fileformat: integer; addAsNewSequences, saveCharSet,nameAsFile: boolean; charSetName: str255): boolean;	function ImpSequenceFileTypeQuery(var fileType: integer): boolean;	procedure GetFile(var userCancelled: boolean);{еееееееееееееееееееееее}implementation {е$S GenOpenFile}{-----------------------------------------------------------------------------}	procedure InitRandom;	begin		EvolveAncState := 0;		EvolveNumChars := 1;		EvolveAncConstant := true;		EvolveSaveOnlyChanged := false;		RTkind := RTequiprobable;		RTallTaxa := false;	end;{-----------------------------------------------------------------------------}	procedure InitChartOptions;		var			j: integer;	begin		CWBlastPolyt := false;		for j := 1 to numcharts do			CWTrees[j] := CWCurrentTree;		CWTrees[CWCCTAll] := CWStoredTrees;		CWTraced := false;		CWView := histoview;		CWUsePostscript := false;{Steps Chart}		sequencechart := false;		positionchart := false;		CWStepsShow := CWSTepsSTeps;{Changes and Stasis Chart}		Chartchangesmode := unambigmode;		CWShowConstant := false;		addPolychanges := true;		BiggestSpot := -1;{Chart To Wts, ChartTo Types}		SACWfunction := SACWInverse;		ChartTypeFunction := ChartTypeLN;	end;{-----------------------------------------------------------------------------}	procedure InitJustProgram;{stick factory defaults in here that are to be initialized only }{at start of program}	begin		InitChartOptions;		InitRandom;		{moveCellBlocks := false;}		randEvolveUseLengths := true;			end;{-----------------------------------------------------------------------------}	procedure InitProgramAndFile;{stick factory defaults in here that are to be initialized }{at start of program AND with each new file}	begin		flashRNARCFirstChar:=0;		flashRNARCLastChar:=0;		flashRNARCFirstTax:=0;		flashRNARCLastTax:=0;		editorFlashMode := flashOff;		editorFrequentRedraw := false;		editorFirstRow:= 1;		editorFirstColumn := 1;		statesWindowCharacter := 1;		spreadstyle := [];		statesSelected := false;		nexusBlockBeingEdited:= nil;		fillchar := missing;		SetRect(editorShimmerRect,0,0,0,0);		brushset := [];		nucleotides := false;		SetStateSetBoundaries(nucleotides);		molecular := false;		numcontinuous := 0;		currentTool[treeTools] := arrowT;		lastTool[treeTools] := arrowT;		currentTool[editorTools] := editorArrowT;		lastTool[editorTools] := editorArrowT;		someCodPosSet := false;		someCodPosSetIncluded := false;		someCoding := false;		someCodingIncluded := false;		drawWriteStringLines := 0;		chartTextLines := 0;		chartAlreadyDrawn := false;		curType := unordered;		StateNamesAreSymbols := false;		CharWithStateNamesAsSymbols := 0;		preDataBlocks := 0;		SetRect(editorSelectionRect,0,0,0,0);		ticksAutoHeighten := true;		ticksSideNames := false;		ticksTextBox := false;		ticksShowReversals := false;		ticksShowUnique := false;		branchLengthSpacing := 2;	end;{-----------------------------------------------------------------------------}	procedure SpreadAdjust;	begin		editorLineWidth := editorFontSize + 3;		editorTitleLineWidth := editorFontSize + 3;		notewidth := editorFontSize + 7;		editorTitlesWidth := editorTitleLineWidth * 2;		editorFirstRowTop:= editorTitlesWidth;		If (editorNumConsensusSequences>0) & editorShowConsensusSequences then			if  not editorTransposed then				editorFirstRowTop := editorFirstRowTop + editorNumConsensusSequences*editorLineWidth;		editorRowNameStart := editorTitlesWidth;		editorRowNameEnd := editorRowNameStart + editorRowNameWidth;		editorFirstColumnLeft := editorRowNameEnd;	end;{-----------------------------------------------------------------------------}	procedure ReadjustWindows;	var j: integer;		os: OSStatus;		idealSize: Point;	begin		SetRect(maxEWR, GetWindowDefaultLeft(editorWindow), GetWindowDefaultTop(editorWindow), GetWindowDefaultLeft(editorWindow)+GetWindowMaxContentWidth(editorWindow), GetWindowDefaultTop(editorWindow)+GetWindowMaxContentHeight(editorWindow));		SetRect(maxTWR, GetWindowDefaultLeft(treeWindow), GetWindowDefaultTop(treeWindow), GetWindowDefaultLeft(treeWindow)+GetWindowMaxContentWidth(treeWindow), GetWindowDefaultTop(treeWindow)+GetWindowMaxContentHeight(treeWindow));		visTWR := maxTWR;		MoveWindow(editorWindow,maxEWR.left, maxEWR.top, false);		SizeWindow(editorWindow,maxEWR.right-maxEWR.left, maxEWR.bottom-maxEWR.top, false);		MoveWindow(treeWindow,maxTWR.left, maxTWR.top, false);		SizeWindow(treeWindow,maxTWR.right-maxTWR.left, maxTWR.bottom-maxTWR.top, false);{$IFC CARBON}		SetPt(idealSize,maxTWR.right-maxTWR.left, maxTWR.bottom-maxTWR.top);		os := ZoomWindowIdeal(treeWindow, inZoomOut, idealSize);		SetPt(idealSize,maxEWR.right-maxEWR.left, maxEWR.bottom-maxEWR.top);		os := ZoomWindowIdeal(editorWindow, inZoomOut, idealSize);{$ENDC}	end;{-----------------------------------------------------------------------------}	procedure InitWindowRects;	var j: integer;	begin		maxEWR := ScreenBoundsRect;		maxTWR := ScreenBoundsRect;		maxTWR.right := maxTWR.right + scrollwidth;		maxTWR.bottom := maxTWR.bottom + scrollwidth;		maxTWR.top := 18;		visTWR := maxTWR;		maxEWR.top := editorWindowTop;		maxEWR.left := 4;		tlegpt.v := 200;		tlegpt.h := 336;		chlegpt.v := 260;  {was 200}		chlegpt.h := 340;		for j := 1 to numToolPalettes do			begin				toolPalettePoint[j].v := 200;				toolPalettePoint[j].h := 10;			end;		SpreadAdjust;	end;{-----------------------------------------------------------------------------}	procedure GrabDefaults;		var			j: integer;			db: boolean;	begin		db := ReadNexusPreferencesFile;				if length(symbols) > maxstbitplusone then  {chop of any extras}			symbols := CopyString(symbols, 1, maxstbitplusone);	end;{-----------------------------------------------------------------------------}	procedure InitValues;		var			j, k, ic: integer;	begin		LoadLinkUtil;		LoadCHUNK;		LoadRowColumn;		treeWindowPositionRead := false;		CharLegendPositionRead:= false;		TreeLegendPositionRead:= false;		justReadANexusFile:= false;		windowOrderRead:= false;		treewasopen := false;		editwasopen := false; {Stern OSErr happens here, so corrupted by here}		InitFilePreferences;		InitProgramAndFile;		EmptyConsenses;		CheckConsensusSequences;		for j := 0 to absmaxstate do			for k := 0 to absmaxstate do				changesSel^[j, k] := true;		changesRestricted := false;		CWClassName^^ := 'all events';		numchars := 0;		numtaxa := 0;		allwt1 := true;		onePartition := true;		dirtycharnames := true;		dirtymaxst := false;		oldnumLasertaxa := 0;		numInfoWindowsThatHaveBeenOpen := 0;		fileLastModified := 0;		treeFileLastModified := 0;		Stopaftertree := false;		chartbeingcalculated := false;		blastpolytomies := false;		realwt := false;		realtypes := false;		fisheredited := false;		numboxes := 7;		contmemorymade := false;		charmemorymade := false;		taxmemorymade := false;		numtypes := usedef - 1;		junkinteger := 0;		uniqueresolution := false;{FROZEN 3.0}		golist := [];{$IFC FALSE} {v3.02:}		for j := 1 to maxerrorswithchars do			for ic := 0 to maxcharsoferrors do				errorswithchars[j, ic] := -1;		ZeroErrorSet(errorsposted);		ZeroErrorSet(errorsturnedoff);		goerror := false;{$ENDC}		MOS := 1;		for j := 0 to maxFootType do			numfeet[j] := 0;		ignore := notgiven;		equateson := false;		polyon := false;		mstaxa := mstVariable;		dirtytaxnames := true;		warnedAboutMovedSequenceSites := false;		edw := 6;		boxedw := edw;		txsp := 12;		mintxsp := 6;		fixon := FALSE;		databoxBHeight := 0;		rootsize := defRootSize;		BranchListon := false;		commreadon := false;		datachanged := false;		anydirected := false;		treedrawn := false;		dirtyfile := false;		dirtytreefile := false;		for j := 0 to numTools[treeTools] do			tool^[treeTools,j].enabled := true;		tool^[treeTools,paintT].enabled := false;		tool^[treeTools,queryT].enabled := false;		tool^[treeTools,traceTickT].enabled := false;		tool^[treeTools,statsTestT].enabled := false;		tool^[treeTools,turpentineT].enabled := false;		tool^[treeTools,treePictureT].enabled := false;		for j := 0 to 255 do			equates^^[j] := [];		newfile := false;		anygenchar := false;		anydirected := false;		treeonscreen := false;		editorShowFullStateNames := false;		symbolson := false;		treeopen := false;	{	aboutopen := false;}		treefile := false;		displace7 := 0;		topmargin := 70;		nattop := topmargin;		SetDataFormat(standard, false);		theGeneticCode := prefGeneticCode;   {v3.05}		SetStandardCode(theGeneticCode);   {v3.05: was nuclearcode}		StringToH('0', treedataH);		noundo := true;		justundid := false;		fullundo := false;		fixlostbyundo := false;		ancon := false;		nullson := false;		expd := false;		i7 := 0;		i := 1;		oldtracei := 1;		for j := 1 to numInfoWindows do			begin				infoRows[j] := 21;				infoSomeSelected[j] := false;				infoTop[j] := 1;				infoBottom[j] := infoTop[j] + infoRows[j]-1;				infoLeft[j] := 1;				infoOpen[j] := false;				infoDirtyNames[j] := true;				infoHasBeenOpen[j] := false;			end;	{	tearoff := false;}		justchanc := false;		nodes := false;		picton := false;		curTypes := [];		for j := 0 to maxchain do			begin				UserLinks[j] := 0;				linknumber[j] := 0;				DefaultLink[j] := -1;				dirtylink[j] := false;				curLinkNames[j]^^ := '';			end;		dirtytree := false;		dirtyfix := false;		oldtreelinknumber := 0;		DefaultLink[typeSetChain] := 0;		DefaultLink[wtSetChain] := 0;		DefaultLink[CharPartitionChain] := 0;		DefaultLink[exSetChain] := 0;		DefaultLink[charSetChain] := 0;		maxlabel[datafilechain] := 0;		maxlabel[treefilechain] := 0;		treechain := datafilechain;		TWscrolling := false;		treefilename^^ := 'Untitled';		autotabright := false;		autotabdown := false;		treeinmemory := false;		treelength := 1;		mySetPortTextFont(statesWindow,kFontIDGeneva);		mySetPortTextSize(statesWindow,9);		TWOrigin.v := 0;		TWOrigin.h := 0;		chLenH := NewHandle(2);		chtypH := NewHandle(2);		chwtH := NewHandle(2);		chPartitionH := NewHandle(2);		chStorePartitionH := NewHandle(2);		chstoretypH := NewHandle(2);		chstorewtH := NewHandle(2);		chpLH := NewHandle(2);		chstatesH := NewHandle(2);		editorSelectionTopLeft.v := 0;		editorSelectionTopLeft.h := 0;		editorSelectionBotRight := editorSelectionTopLeft;		editorOrigin.h := 1;		editorOrigin.v := 1;		SetControlValueLong(editorVScroll, 1);		SetControlValueLong(editorHScroll, 1);		editorSelected := false;		SetRect(editorSelectionRect, 0, 0, 0, 0);		mySetPortTextFont(tLegWindow,kFontIDGeneva);		mySetPortTextSize(tLegWindow,9);		mySetPortTextFont(chlegWindow,kFontIDGeneva);		mySetPortTextSize(chlegWindow,9);		mySetPortTextFont(twmessWindow,kFontIDGeneva);		mySetPortTextSize(twmessWindow,9);		mySetPortTextFont(BranchListWindow,kFontIDMonaco);		mySetPortTextSize(BranchListWindow,9);		for j := 1 to numTextWindows do			begin				textWindowInfo[j]^.open := false;				textWindowInfo[j]^.TE^^.txFont := textWindowInfo[j]^.font;				textWindowInfo[j]^.TE^^.txSize := textWindowInfo[j]^.size;			end;					for j := 1 to numToolPalettes do			toolPalettePositionRead[j] := false;		GrabDefaults;     {===== here is where preferences are recovered =====}		if calcCI or calcRI or calcRC then			count := true;		Resetgomask;	end;{-----------------------------------------------------------------------------}	procedure PostReadProcessing;		var			fnum: integer;			j, ic, it :integer;	begin		FixTotNums;		SpreadAdjust;		SetRect(editorTitleCornerRect, 0, 0, editorRowNameEnd, editorTitlesWidth);		mySetPortTextFont(treeWindow,TWFont);		mySetPortTextSize(treeWindow,TWFontSize);		mySetPortTextFont(ChartWindow,CWFont);		mySetPortTextSize(ChartWindow,CWFontSize);		mySetPortTextFont(editorWindow,editorFont);		mySetPortTextSize(editorWindow,editorFontSize);		resetGoMask;		pictEditable := true;		pictResFileExists := false;		WindowPop(not twfullscreen, not treeWindowPositionRead);		{RebuildSelectMenu(noinfo);}		RebuildShadeCharSetMenu;		RebuildColorCodPosMenu;		CheckColorCharPartitionMenu;		CheckMismatchMenu;		RebuildConsensusTaxSetMenu;		CheckSymbolsConflictFinal;		genericSetPort(treewindow);		SizeTreeWindow;		if (not locklegends | toolPaletteOpen[treeTools]) then			SetPaletteAndLegendPositions(toolPaletteFirstAppearance[treeTools],not TreeLegendPositionRead,not CharLegendPositionRead);		for j := 1 to numToolPalettes do			ReSizeToolPalette(j,horizontalTools[j],verticalTools[j]);		for ic := 1 to numchars do			SetNewlyInsertedCharacter(ic,false);		for it := 1 to numTaxa do			SetNewlyInsertedTaxon(it,false);	end;{-----------------------------------------------------------------------------}	procedure InitFile;	begin		InitValues;		TWMessage := filename^^;		genericSetPort(TreeWindow);		{SetMenuItemText(FileMHdl, AboutFileItem, concat('About ', filename^^, '...'));}		SetUpRect;		ResetFisher;		numchars := 1;		numtaxa := 1;		RebuildCharPartNamesMenu;	end;{-----------------------------------------------------------------------------}	procedure StartNewFile;	begin		AddRemainingNativeNexusBlocks;		InitFile;		ReadjustWindows;				newfile := true;		fileopen := true;		filename^^ := 'Untitled';		{SetMenuItemText(FileMHdl, AboutFileItem, 'About Untitled...');}		noundo := true;		fixlostbyundo := false;		justundid := false;		fileSaved := false;		OpenFileMenus;		numchars := 1;		numtaxa := 1;		if CreateTaxonCharMemory then			begin				ntscreen := 1;				PostReadProcessing;				SetLastChangeInEditor(lastChangeCantUndo);								OpenEdit;			end		else			CleanUpFailedTaxonCharacterMemory;	end; {----------------------------------------------------------------------------}	procedure InitAssumpLinks;		var			j: INTEGER;	begin		if i7 > numchars then			i7 := numchars;		for j := 0 to maxchain do			if not (j in [datafilechain, treefilechain, charsetchain, taxsetchain]) then					begin						linknumber[j] := DefaultLink[j];						ChooseLink(j, false);						ExciseDefaultLink(j);						linknumber[j] := DefaultLink[j];					end;		CheckCurrentTypes;	end;{-----------------------------------------------------------------------------}	procedure BeginFile(doGetFileIfError: boolean; var success, userCancelled:boolean);		var			W, H: integer;			cc, growsize: size;			opentreeanyway: boolean;			oldState: SignedByte;			amountneeded: longint;	begin		success := true;		fileIsStationery := FSpIsStationeryFile(FDI^[readFileFDI].fs);		InitFile;		userCancelled := false;		ReadFile;		if not errorflag then			begin				PostReadProcessing;				OpenFileMenus;				if not errorflag then					begin						if (UserLinks[typeSetChain] > 0) then							linknumber[typeSetChain] := StartUserLink(typeSetChain);						if (UserLinks[wtSetChain] > 0) then							linknumber[wtSetChain] := StartUserLink(wtSetChain);						if (UserLinks[CharPartitionChain] > 0) then							linknumber[CharPartitionChain] := StartUserLink(CharPartitionChain);						if (fileformat <> hennig) & (fileformat <> nona) & (fileformat <> phylip) then							InitAssumpLinks;						if editwasopen then							OpenEdit						else if treewasopen then							begin								opentreeanyway := true;								if not EnoughMemory(MemoryForTree(numtaxa, numchars) + 5000, amountneeded) then									begin										cc := MaxMem(growsize);										if not EnoughMemory(MemoryForTree(numtaxa, numchars) + 5000, amountneeded) then											opentreeanyway := Cwarning('There may not be enough memory to open tree. Do you want to proceed anyway?', 'Proceed', 'Cancel');									end								else if numtaxa < minTaxaIn then									begin										openTreeAnyway := false;										NewError(107, 0);									end;								if not opentreeanyway then									begin										OpenEdit;									end								else									begin										ClosedEditMenus;										if StartTree then   {v3.05: }											FullTreeOnScreenGoList; {send full golist}									end;							end						else							OpenEdit;					end				else					CloseFile;			end		else			begin				CloseFile;				success :=false;				errorFlag := false;				if doGetFileIfError then					GetFile(userCancelled);			end;			end;{----------------------------------------------------------------------------}	function ImportSequences(fileformat: integer; addAsNewSequences, saveCharSet,nameAsFile: boolean; charSetName: str255) : boolean;		var			j: integer;			oldNumChars: longint;			theFile,command: str255;			db: boolean;			tempP: WindowPtr;	begin		FDI^[readFileFDI].fs:= FDI^[extraIOFileFDI].fs;		ImportSequences := false;						fpos := kInitialReadPos;		FDI^[readFileFDI].fs := FDI^[extraIOFileFDI].fs;		ioFileFDI := extraIOFileFDI;		{iofilename^^ := filename^^;}		{ioWorkingDirectoryNumber := WorkingDirectoryNumber; }		SetFileLength(FDI^[readFileFDI].fs);		if errorFlag then Exit(ImportSequences);		command := GetFileToken(maxtok);		if (command='') then			begin				NewError(467,0);				ImportSequences := true;   // set it to true so that we don't prevent reading of later files				Exit(ImportSequences); 			end		else if MakeCaps(command) = '#NEXUS' then			begin				NewError(441,0);				errorFlag := true;				Exit(ImportSequences);			end		else			fpos := kInitialReadPos;		if errorFlag then Exit(ImportSequences);		DisableWindowUpdates(editorwindow);		DisableWindowUpdates(infowindow[charinfo]);		StartThermo(iothermo, tempP, 0, mcFileLength, 'Importing Sequences', 'percent', true);		DrawDialog(iothermo);		SetCursor(clockCursor);		oldNumChars:= numchars;		ReadSequences(fileformat,numtaxa+1,numchars,addAsNewSequences,nameAsFile);		EndThermo(iothermo, tempP, false);		if saveCharSet then 			begin				InitOtherSelected(charSetChain);				for j := oldNumChars+1 to numchars do					SetOtherSelected(charSetChain,j,true);				SaveLinkToChain(charSetChain, charSetName, false,true);				linknumber[charSetChain] := EndUserLink(charSetChain);			end;		InvalidateWindow(editorWindow,true);		ImportSequences := true;		SetLastChangeInEditor(lastChangeCantUndo);	end;{----------------------------------------------------------------------------}	function ChooseImportSequence(fileformat: integer; addAsNewSequences, saveCharSet,nameAsFile: boolean; charSetName: str255): boolean;		label			1;		var			typeList: SFTypelist;  {typelist::}			j: integer;			numItems : longint;			actualSize: Size;			returnedType: DescType;			keywd: AeKeyword;			oldNumChars: longint;			theFile,command: str255;			db: boolean;			tempP: WindowPtr;			 FileSpec: FSSpec;			 os: OSStatus;			 iFile: integer;			 tPort: WindowPtr;	begin		genericGetPort(tPort);		typeList[0] := 'TEXT';		typeList[1] := '????';		ChooseImportSequence := false;		if ChooseFile(2, @typeList, nil, theFile, FDI^[extraIOFileFDI].fs,true,false,false) then			begin				FDI^[readFileFDI].fs:= FDI^[extraIOFileFDI].fs;				ChooseImportSequence := ImportSequences(fileformat,addAsNewSequences, saveCharSet,nameAsFile,charSetName);{$IFC POWERPC}				os := AECountItems(navReply.selection, numItems);				if (os=noErr) & (numItems>1) then					begin						for iFile := 2 to numItems do							begin								os := AEGetNthPtr(navReply.selection, iFile, typeFSS, keywd, returnedType, @ FDI^[extraIOFileFDI].fs, SizeOf( FDI^[extraIOFileFDI].fs), actualSize);								if (os=noErr) then									begin										FDI^[readFileFDI].fs :=  FDI^[extraIOFileFDI].fs;										theFile := FDI^[readFileFDI].fs.name;										db := ImportSequences(fileformat,addAsNewSequences, saveCharSet,nameAsFile,charSetName);										if db then											ChooseImportSequence := true;										errorflag := false;									end;							end;					end;{$ENDC}			end;1:		genericSetPort(tPort);	end;	var impSeqFileType: integer;{-----------------------------------------------------------------------------}	procedure ImportSeqTypeUser (theDialog: DialogPtr; itemNo: Integer);		var			box: rect;			ds: str255;	begin		box := GetDLOGITemBox(theDialog, 4);		GetMenuItemText(dlogImportTaxaMHdl, impSeqFileType, ds);		DrawPopUpRect(box, ds);		FrameButton(theDialog, 1);	end;{-----------------------------------------------------------------------------}	procedure PopUpImpSeqM (theDialog: DialogPtr);		var			menucode: longint;			spot: point;			box: rect;	begin		box := GetDLOGITemBox(theDialog, 4);		spot.v := box.top;		spot.h := box.left;		LocalToGlobal(spot);		menucode := PopUpMenuSelect(dlogImportTaxaMHdl, spot.v, spot.h, impSeqFileType);		if LowWord(menucode) > 0 then			impSeqFileType := LowWord(menucode);		ImportSeqTypeUser(theDialog, 1);	end;{-----------------------------------------------------------------------------}	function ImpSequenceFileTypeQuery(var fileType: integer): boolean;	var			theDialog: DialogPtr;			tempP: WindowPtr;			j: integer;			tempH: Handle;			box: rect;			localItemHit: integer;UserItemUProcP: UniversalProcPtr;	begin		fileType := nbrf;		ImpSequenceFileTypeQuery := true;		impSeqFileType := lastImpSequenceFileType;		//InsertMenu(xxImportTaxaMHdl, -1);		StartDLOG(179, theDialog, tempP);		myEnableItem(dlogImportTaxaMHdl, 0);  		box := GetDLOGITemBox(theDialog, 4);UserItemUProcP := MyNewUserItemUPP(@ImportSeqTypeUser);  tempH := Handle(UserItemUProcP);		SetDialogItem(theDialog, 4, UserItem, tempH, box);		myShowDialog(theDialog);		repeat			ModalDialog(nil, localItemHit);			if localItemHit = 4 then				PopUpImpSeqM(theDialog);		until localItemHit in [1, 2];MyDisposeUserItemUPP(UserItemUProcP);		EndDLOG(theDialog, tempP);		if localItemHit = 2 then			ImpSequenceFileTypeQuery := false		else			begin				case impSeqFileType of					impNBRF:						fileType := nbrf;					impGenbank:						fileType := genbank;					impFASTA:						fileType := fasta;					impNameSeq:						fileType := simpletext;					impSeqOnly:						fileType := sequenceOnly;					otherwise						ImpSequenceFileTypeQuery := false;				end;				lastImpSequenceFileType := impSeqFileType;			end;				end;{----------------------------------------------------------------------------}	function NewButtonHook (localItemHit: integer; theDialog: DialogPtr): integer;	begin		if (localItemHit = sys6NewButton) then			begin				NewButtonHook := getOpen;				makenew := true			end		else			NewButtonHook := localItemHit;	end;{----------------------------------------------------------------------------}	function NewButtonHook7 (localItemHit: integer; theDialog: DialogPtr; myDataPtr: Ptr): integer;	begin		if localItemHit = sys7NewButton then			begin				NewButtonHook7 := sfItemCancelButton;				makenew := true			end		else			NewButtonHook7 := localItemHit;	end;{----------------------------------------------------------------------------}	procedure GetFile(var userCancelled: boolean);		label			1;		var			typeList: SFTypelist;  {typelist::}			typeListPtr :ConstSFTypeListPtr;			theFile: str255;			db: boolean;    		UPP: UniversalProcPtr;    		FileSpec: FSSpec;    			numTypes: integer;    			success: boolean;	begin		if quit then Exit(GetFile);		typeList[0] := 'TEXT';		numTypes := 1;		typeListPtr := ConstSFTypeListPtr(@typeList);		fileIsStationery := false;		userCancelled := true;{$IFC NOT CARBON}		UPP := MyNewDlgHookYDUPP(@NewButtonHook7);  {$ELSEC}		UPP := nil;{$ENDC}		if ChooseFile(numTypes, typeListPtr, UPP, theFile, FileSpec,false,true,false) then			begin				FDI^[dataFileFDI].fs := FileSpec;				userCancelled := false;								//InstantInfo(concat(FileSpec.name,' ',StringFromNum(FileSpec.vrefnum),' ',StringFromNum(FileSpec.parid)));				if makenew then					StartNewFile				else					begin						FDI^[readFileFDI].fs:= FDI^[dataFileFDI].fs;												filename^^ := theFile;						fileSaved := true;						if errorflag then							goto 1;						fileopen := true;						currentIOPosition := 74;   {v3.05}						BeginFile(true,success, userCancelled);					end;			end{$IFC CARBON}		else			begin				SetCloseFileMBar;				FixEditMenu;			end {$ENDC}		;		1:{$IFC NOT CARBON}		MyDisposeDlgHookYDUPP(UPP);{$ENDC}	end;end.