unit Cursor;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, 		GenUtil, StrUtil, BoxUtil, CharUtil, TaxonCHUtil, EditControl, FootNote, Coloring, ScrollSpread, 		TreeUtil, TreeDrawer, ClickInInfoWindow, SpreadUtil, ScrollTree, Equivocal, Legends, StampPasteTool,		Flash, ToolOnBranch;	procedure CursorAdjust (Event: EventRecord);	procedure FixTreeFlash;	var 		noCommandToolOverride: boolean;		timechange: boolean;{еееееееееееееееееееееее}implementation{-----------------------------------------------------------------------------}	function TicksCanBeFlashed: boolean;	begin		TicksCanBeFlashed := TickNamesVisible & tool^[treeTools,currentTool[treeTools]].worksOnTicks;	end;{-----------------------------------------------------------------------------}	procedure TreeFlashing (wh: point);		var			ds: str255;			crect, box: rect;			ir: integer;			tickN: NPtr;			tickChar: integer;	begin		genericSetPort(treewindow);		SetClip(TWClip);		FindBranch(wh, ScreenR,false);		if (currentTool[treeTools] = polyflipT) & not PartOfPolytomy(fN) then			{don't flashbranch if not partofpolytomy}			fn := subR;  		if fn=subR then			begin				if TicksCanBeFlashed & FoundTickNearBranch(tickN, wh, tickChar) then					begin						box := TickCharacterBox(tickN,tickChar);						if EmptyRect(box) then							TurnOffTickFlash						else							begin								if (flashTickN<>tickN)|(flashTickCharacter<>tickChar) then									TurnOffTickFlash;								flashTickBox := box;								flashTickN := tickN;								flashTickCharacter := tickChar;								TurnOnTickFlash;							end;					end				else					TurnOffTickFlash;			end		else			TurnOffTickFlash;		if (fn <> lastselN) or comingback then			begin				TWMessage := ' ';				PENMODE(patXOR);				Penpat(dashpat);				if (lastselN <> subR) then   {turn off last}					begin						SetDataBoxesClip;						OutlinePoly(lastselN);						penmode(patcopy);						ClipRect(WindowPortRect(treeWindow));						WritePalMessageB(treeTools,PaletteString(treeTools,currentTool[treeTools], nil));						if (traceshown = traceDiscrete) then							begin								genericSetPort(chlegwindow);								if not isterminalfixanc(lastselN) then									EraseAsterisksEtc;							end						else if (traceshown = traceAllChanges) then							begin								genericSetPort(chlegwindow);								TEXTMODE(srcBIC);								moveto(5, legMessageBox.bottom - 3);								DrawBranchLength(lastselN);								TEXTMODE(srcOR);							end						else if (traceshown = traceContinuous) then							begin								genericSetPort(chlegwindow);								SetRect(crect, 0, WindowPortRect(chlegwindow).bottom - 33, WindowPortRect(chlegwindow).right - 1, WindowPortRect(chlegwindow).bottom);								InsetRect(crect, 1, 1);								Eraserect(crect);							end;						genericSetPort(treewindow);						setclip(TWClip);						penmode(patxor);					end;				Penpat(dashpat);				if (nex7on and (OrientVert(wh.h, wh.v) < dataBoxB.bottom)) then  {orientvert}					fn := subR;				if (fn <> subR) then  {turn on new branch}					begin						SetDataBoxesClip;						OutlinePoly(fN);						Penpat(QDBlack);						penmode(patcopy);						WritePalMessageB(treeTools,PaletteString(treeTools,currentTool[treeTools], fN));						genericSetPort(treewindow);						if (fn^.name > 0) then							TWmessage := TaxonName(fn^.name)						else if IsFixancedUpon(fn) then {internal fixanced node v3.02}							TWmessage := TaxonName(TermOfFixanc(fn)^.name)  {v3.02}						else							begin								NumToString(SizeOfClade(fN, true), ds);								TWMessage := concat(ds, ' Taxa in clade');							end;						if (traceshown = traceDiscrete) then							begin								if fN^.fix then									flashchar := fixedFlag								else									begin										if TreatAsUncertainty(fN^.final, fN, i) then											flashchar := '?'										else											flashchar := '*';									end;								genericSetPort(chlegwindow);								if not isterminalfixanc(fn) then									DrawAsterisksEtc(fN^.final, i, flashchar);								genericSetPort(TreeWindow);							end						else if (traceshown = traceContinuous) then							begin								genericSetPort(chlegwindow);								SetRect(crect, 0, WindowPortRect(chlegwindow).bottom - 33, WindowPortRect(chlegwindow).right, WindowPortRect(chlegwindow).bottom);								InsetRect(crect, 1, 1);								Eraserect(crect);								InsetRect(crect, -1, -1);								if not ((fN = R) and (continuousmode = squnrooted)) or NodeIsPolytomous(R) then									begin										Framerect(crect);										moveto(5, crect.top + 9);										if NodeIsInternal(fN) then											begin												if ContinuousMode in [sqFelsContrast, sqFelsContrastSTD] then  {ввв}													Drawstring('Across Node   ')												else													Drawstring('At Node   ')											end										else											Drawstring('Observed   ');										moveto(5, crect.top + 19);										RealToString(fN^.finalC, ds, 1000, sigcontinuous, true);										DrawString(ds);										if (continuousmode = manhattan) & (abs(fN^.finalC - fN^.finalD) > 0.001) then											begin												MoveTo(5, crect.top + 29);												Drawstring('to ');												RealToString(fN^.finalD, ds, 1000, sigcontinuous, true);												DrawString(ds);											end;									end;								genericSetPort(TreeWindow);							end						else if (traceshown = traceAllChanges) then							begin								genericSetPort(chlegwindow);								Eraserect(legMessageBox);								framerect(legMessageBox);								moveto(5, legMessageBox.bottom - 3);								insetrect(legMessageBox, 1, 1);								ClipRect(legMessageBox);								DrawBranchLength(fN);								insetrect(legMessageBox, -1, -1);								genericSetPort(TreeWindow);							end;						genericSetPort(treewindow);						setclip(TWClip);					end;				WriteTWMessageB;				lastselN := fn;				Penpat(QDBlack);				PENMODE(patCopy);			end		else if (fN = SubR) and (traceshown = traceDiscrete) then			EraseAsterisksEtc;		ClipRect(WindowPortRect(treeWindow));	end;{-----------------------------------------------------------------------------}	procedure FlashStored;		var			flsn: Nptr;			tport: windowptr;	begin		if nodes then			begin				flsn := storedN;				if (BranchListN <> subR) and BranchListon then					flsn := BranchListN;				if flsN <> subR then					begin						genericGetPort(tport);						genericSetPort(treewindow);						penmode(patxor);						pensize(2, 2);						FlashBranch(flsN);						if not button then							Delay(3, ticks);						FlashBranch(flsN);						pensize(1, 1);						Penpat(QDBlack);						PENMODE(patCopy);						genericSetPort(tport);					end;			end;	end;{-----------------------------------------------------------------------------}	procedure FixTreeFlash;		var			wh: point;	begin		if treeopen & nodes then			if flashbranchon & (lastselN <> subR) & (lastselN <> nil) then {Note: flashbranchon currently always true}				begin					wh.v := 0;					wh.h := 0;					TreeFlashing(wh);				end			else if  (traceshown = traceDiscrete) then				EraseAsterisksEtc;	end;{-----------------------------------------------------------------------------}	procedure DrawCursorTrackingInEditor(overDataCell,overConsensus: boolean; it,ic: integer);	var box: rect;		oldClip: RgnHandle;		oldRGB: RGBColor;		ds: str255;	begin		oldClip := newRgn;		GetClip(oldClip);		ClipRect(editMessageBox);		SetGrayBackground(oldRGB,grayPale);		if ((it<>editorCursorTaxon) | (ic<>editorCursorCharacter)) then			if {((0=editorCursorTaxon)& (0<>editorCursorCharacter)) &} overDataCell | overConsensus then				begin					EraseRect(editMessageBox);					MoveTo(editMessageBox.left + 3, editMessageBox.bottom - 4);					TextSize(9);					TextFont(kFontIDGeneva);					TextFace([]);					if overConsensus then						DrawString(concat(' C ',StringFromNum(ic)))					else if nucleotides then						begin							ds := SimpleCellEntry(it,ic);;							DrawString(concat('T ', StringFromNum(it),' C ',StringFromNum(ic),'  [',ds,']'));						end					else						DrawString(concat('T ', StringFromNum(it),' C ',StringFromNum(ic)));					TextFace(spreadstyle);					TextSize(editorFontSize);					TextFont(editorFont);					editorCursorTaxon:=it;					editorCursorCharacter:=ic;				end			else				begin					EraseRect(editMessageBox);					editorCursorTaxon:=0;					editorCursorCharacter:=0;				end;		RGBBackColor(oldRGB);		SetClip(oldClip);		ZapRegion(oldClip);	end;{-----------------------------------------------------------------------------}	procedure ShowStandardToolInEditor(wh: point; opt,comm,shift,cont: boolean);	begin		if Locked(lockdata) then			SetCursorToArrow		else if (PtInRect(wh, editorBoundaryRect)) and (not PtinRect(wh, editorTitleCornerRect) or (wh.h - editorRowNameEnd > -editorLineSensitivity)) then			begin				if (wh.v < editorTitleLineWidth) then					if not PtinREct(wh, editorSelectionRect) and not (opt and comm) and(wh.h>=editorFirstColumnLeft-editorLineSensitivity) and  (wh.h < editorMatrixRect.right) and (((wh.h - editorRowNameEnd) mod editorColumnWidth < editorLineSensitivity) or (editorColumnWidth - (wh.h - editorRowNameEnd) mod editorColumnWidth < editorLineSensitivity)) then						if cont then							SetCursID(167)						else							SetCursID(10005)  {insert column cursor}					else						SetCursH(handcurs)				else if (wh.h < editorRowNameStart) then					if not PtinREct(wh, editorSelectionRect) and not (opt and comm) and(wh.v>=editorFirstRowTop-editorLineSensitivity)and (wh.v < editorMatrixRect.bottom) and (((wh.v - editorTitleLineWidth * 2) mod editorLineWidth < editorLineSensitivity) or (editorLineWidth - (wh.v - editorTitleLineWidth * 2) mod editorLineWidth < editorLineSensitivity)) then						SetCursID(9207)					else						SetCursH(handcurs)				else if (wh.h > editorRowNameEnd - editorLineSensitivity) and (wh.h < editorRowNameEnd + editorLineSensitivity) and (wh.v < editorMatrixRect.bottom) and (wh.v > editorTitleLineWidth * 2) then					SetCursID(167)				else if not (PtInRect(wh, editorMatrixRect)) then					begin						if (wh.v > editorMatrixRect.bottom) and (wh.v < editorMatrixRect.bottom + editorLineWidth) and (wh.h < editorMatrixRect.right) and not (opt and comm) then							SetCursor(newrowcurs)						else if (wh.h > editorMatrixRect.right) and (wh.h < editorMatrixRect.right + editorLineWidth) and (wh.v < editorMatrixRect.bottom) and not (opt and comm) then							SetCursor(newcolcurs)						else							SetCursorToArrow;					end				else if editorSelected and SingleCell then					begin						if PtInRect(wh, editorSelectionRect) then							SetCursor(ibeam)						else							SetCursorToArrow;					end				else					SetCursorToArrow;			end{$IFC EXPANDFEET}		else if PtinRect(wh, notePullR) then			begin				SetCursor(newrowcurs);			end{$ENDC}		else if PtInRect(wh, editorFootNoteRect) then			begin				if editorSelected and SingleCell and footTexton then					SetCursor(ibeam)				else					SetCursorToArrow;			end		else			SetCursorToArrow;	end;{-----------------------------------------------------------------------------}	procedure ShowCantDoIfInMatrix(wh: point);	begin		if PtInRect(wh,editorMatrixRect) then			SetCursID(cantDoCursorID)		else			SetCursorToArrow;	end;{-----------------------------------------------------------------------------}	procedure CursorAdjust (Event: EventRecord);		var			wh: point;			B, crect, box: rect;			OSError: OSErr;			opt, comm, shift,cont: boolean;			db, turnofflast,overDataCell, overConsensus, flipSort: boolean;			tport: windowptr;			flsn: Nptr;			windowloc, ir, it,ic: integer;			whichinfo, whichColumn, columnID: integer;			secs: longint;			date: DateTimeRec;			oldClip: RgnHandle;	begin		genericGetPort(tport);		opt := OptionEvent(Event);		shift := ShiftEvent(Event);		comm := CommandEvent(Event);		cont := ControlEvent(Event);		if (FrontWindow = nil) | not MacCladeWindow(frontwindow) then			SetCursorToArrow		else			begin				GetMouse(wh);				LocalToGlobal(wh);				windowloc := Findwindow(wh, whichwindow);				genericSetPort(whichwindow);				GlobalToLocal(wh);				if equivcycle & (whichwindow = treewindow) & PtInRgn(wh, TWClip) & not ((shift & not comm) | (currentTool[treeTools] = handT) | (currentTool[treeTools] = expandT)) then  {what about dblclicks to expand}					begin						EquivocalCursor(false);{    Delay(3, ticks);}					end				else					begin						if (whichwindow <> treewindow) and treeopen then							FixTreeFlash;						FlashSimilarSequence;												if MacCladeWindow(FrontWindow)| isforeground then 							begin{||||||||||||||||||| editorWindow||||||||||||||||||||}								if whichwindow=editorWindow then									begin										FlashSimilarSequence;																				{if SplitMultiActive(currentTool[editorTools]) & isforeground then											if not (comm & not noCommandToolOverride) then												FlashSplitMultiActive;}										overDataCell := FindTaxChar(wh,it,ic);										overConsensus:= ((it<-1) & (ic>0) & (ic <= numchars))|((it<-1) & (ic>0) & (ic <= numchars));										{if it < FirstVisibleTaxon then											it := 0;										if ic < FirstVisibleCharacter then											ic := 0;}										if isforeground then 											DrawCursorTrackingInEditor(overDataCell,overConsensus,it,ic);										if PtInEditorTitleCornerRect(wh) then											SetcursID(questionCursorID)										else if PtInRect(wh,editMessageBox) then											SetcursID(questionCursorID)										else if (wh.h > editorRowNameEnd - editorLineSensitivity) and (wh.h < editorRowNameEnd + editorLineSensitivity) and (wh.v < editorMatrixRect.bottom) and (wh.v > editorTitleLineWidth * 2) then											SetCursID(167)										else if (comm & not noCommandToolOverride) | AsArrowOnRCNumber(it,ic,currentTool[editorTools]) then											if AsArrowOnRCNumber(it,ic,currentTool[editorTools]) & (opt & cont) & (ic<0) then												SetcursID(gotoCursorID)											else												ShowStandardToolInEditor(wh,opt,comm,shift,cont)										else if editorShowConsensusSequences & PtInREct(wh, editorMatrixRect) & ((editorTransposed & (wh.h<editorFirstColumnLeft)& (wh.h>editorRowNameEnd))| (not editorTransposed & (wh.v<editorFirstRowTop)& (wh.v>editorTitlesWidth))) then											begin												if editorNumConsensusSequences > 1 then													SetCursH(handcurs) 												else													SetCursorToArrow;											end										else if not tool^[editorTools,currentTool[editorTools]].worksInNameCells &((it=0)|(ic=0))then											SetCursID(cantDoCursorID)										{else if (currentTool[editorTools]=popUpStatesT) &(it=0)  then  											SetCursID(cantDoCursorID)}										else if (currentTool[editorTools] = blockMoveT) then											begin												if blockMoveSplitBlockToo & NearCellLineInEditor(not editorTransposed,wh) & (wh.h <= editorMatrixRect.right) &overDataCell& not IsGapLike(it,ic,editorToolsTreatMissingAsGaps) & (editorColumnWidth>=columnIncrement) then													if not editorTransposed then														SetCursID(166)													else														SetCursID(165)												else  if  PtInREct(wh, editorMatrixRect) & overDataCell & not IsGapLike(it,ic,editorToolsTreatMissingAsGaps) then													if not editorTransposed then															SetCursH(tool^[editorTools,currentTool[editorTools]].curs)														else															SetCursID(156)												else 													ShowCantDoIfInMatrix(wh)											end										else if (currentTool[editorTools] = splitBlockT) then											begin												if UseOptionTool(editorTools,splitBlockT,OptionEvent(Event)) then													if NearSplitMultiBlockLine(not editorTransposed,wh) & (wh.h <= editorMatrixRect.right) &overDataCell then														begin															if not editorTransposed then																SetCursID(618)															else																SetCursID(725);														end													else if PtInRect(wh,editorMatrixRect) & NearCellLineInEditor(not editorTransposed,wh) & overDataCell then														SetCursID(crossHairCursorID)  {cross-hairs}													else 														ShowCantDoIfInMatrix(wh)												else if NearCellLineInEditor(not editorTransposed,wh) & (wh.h <= editorMatrixRect.right) &overDataCell& not IsGapLike(it,ic,editorToolsTreatMissingAsGaps) then													begin														if not editorTransposed then															SetCursH(tool^[editorTools,currentTool[editorTools]].curs)														else															SetCursID(724);													end												else 													ShowCantDoIfInMatrix(wh);											end										{else if (currentTool[editorTools] = splitMultiBlockT) then											begin												if NearSplitMultiBlockLine(not editorTransposed,wh) & (wh.h <= editorMatrixRect.right) &overDataCell then													begin														if not editorTransposed then															SetCursH(tool^[editorTools,currentTool[editorTools]].curs)														else															SetCursID(725);													end												else if PtInRect(wh,editorMatrixRect) then													SetCursID(crossHairCursorID)												else 													SetCursorToArrow;											end}										else if (currentTool[editorTools] = splitBlockOtherT) then											begin												if NearCellLineInEditor(not editorTransposed,wh) & (wh.h <= editorMatrixRect.right) &overDataCell& not IsGapLike(it,ic,editorToolsTreatMissingAsGaps) then													begin														if not editorTransposed then															SetCursH(tool^[editorTools,currentTool[editorTools]].curs)														else															SetCursID(704);													end												else 													ShowCantDoIfInMatrix(wh);											end										else if (currentTool[editorTools] = closeGapsT) then										{if moveCellBlocks & dataP^.editorSelected & not SingleCell(dataP) & PtInRect(wh, dataP^.editorSelectionRect) & not WholeTaxonSel(dataP) & (CharOfCell(dataP, dataP^.editorSelectionTopLeft) > 0) & (wh.h > dataP^.editorRowNameEnd) & (wh.v > dataP^.editorTitlesWidth) & someDataSel(dataP) then}											begin												if editorSelected & PtinREct(wh, editorSelectionRect) then 													begin														if not UseOptionTool(editorTools,currentTool[editorTools],opt) then															begin																if editorTransposed then																	SetCursID(709)																else																	SetCursH(tool^[editorTools,currentTool[editorTools]].curs);															end														else															begin																if editorTransposed then																	SetCursID(710)																else																	SetCursID(707);															end;													end												else if overDataCell then													SetCursID(crossHairCursorID)  {crossHairs}												else													ShowCantDoIfInMatrix(wh);											end										else if (currentTool[editorTools] = selectedBlockMoveT) then										{if moveCellBlocks & dataP^.editorSelected & not SingleCell(dataP) & PtInRect(wh, dataP^.editorSelectionRect) & not WholeTaxonSel(dataP) & (CharOfCell(dataP, dataP^.editorSelectionTopLeft) > 0) & (wh.h > dataP^.editorRowNameEnd) & (wh.v > dataP^.editorTitlesWidth) & someDataSel(dataP) then}											begin												if editorSelected & (PtinREct(wh, editorSelectionRect) | (SelectedBlockMoveMode= selectedBlockMoveClickMode)) then 													begin														if editorTransposed then															SetCursID(706)														else															SetCursH(tool^[editorTools,currentTool[editorTools]].curs);													end												else if overDataCell then													SetCursID(crossHairCursorID)												else													ShowCantDoIfInMatrix(wh);											end										else if (currentTool[editorTools] = editorBucketT) then										{if moveCellBlocks & dataP^.editorSelected & not SingleCell(dataP) & PtInRect(wh, dataP^.editorSelectionRect) & not WholeTaxonSel(dataP) & (CharOfCell(dataP, dataP^.editorSelectionTopLeft) > 0) & (wh.h > dataP^.editorRowNameEnd) & (wh.v > dataP^.editorTitlesWidth) & someDataSel(dataP) then}											begin												 if PtInRect(wh,editorMatrixRect) then													if (paintBucketFillCellsWithState<>[])  then														SetCursID(723)													else														SetCursH(tool^[editorTools,currentTool[editorTools]].curs)												else													SetCursorToArrow;											end										else if (currentTool[editorTools] = selectToEndT) then										{if moveCellBlocks & dataP^.editorSelected & not SingleCell(dataP) & PtInRect(wh, dataP^.editorSelectionRect) & not WholeTaxonSel(dataP) & (CharOfCell(dataP, dataP^.editorSelectionTopLeft) > 0) & (wh.h > dataP^.editorRowNameEnd) & (wh.v > dataP^.editorTitlesWidth) & someDataSel(dataP) then}											begin												 if PtInRect(wh,editorMatrixRect) then													begin														if not editorTransposed then															if (selectToEndMode=selectToLastTaxonMode)|(selectToEndMode=selectToFirstTaxonMode) then																if (wh.v<editorTitlesWidth) then																	if opt=(selectToEndMode=selectToLastTaxonMode) then																		SetCursID(tool^[editorTools,currentTool[editorTools]].optionCursID)																	else																		SetCursH(tool^[editorTools,currentTool[editorTools]].curs)																else if (opt = (selectToEndMode=selectToLastTaxonMode)) then																	SetCursID(721)																else																	SetCursID(702)															else if (wh.h<editorRowNameEnd) then																if  opt=(selectToEndMode=selectToLastCharacterMode) then																	SetCursID(721)																else																	SetCursID(702)															else																if (opt= (selectToEndMode=selectToLastCharacterMode)) & tool^[editorTools,currentTool[editorTools]].hasOptionCurs then																	SetCursID(tool^[editorTools,currentTool[editorTools]].optionCursID)																else																	SetCursH(tool^[editorTools,currentTool[editorTools]].curs)																															else if  (selectToEndMode=selectToLastTaxonMode)|(selectToEndMode=selectToFirstTaxonMode) then															if (wh.h < editorRowNameEnd) then																if  opt=(selectToEndMode=selectToLastTaxonMode) then																	SetCursID(721)																else																	SetCursID(702)															else if opt = (selectToEndMode=selectToLastTaxonMode) then																	SetCursID(tool^[editorTools,currentTool[editorTools]].optionCursID)																else																	SetCursH(tool^[editorTools,currentTool[editorTools]].curs)														else if (wh.v<editorTitlesWidth) then															if opt=(selectToEndMode=selectToLastCharacterMode) then																SetCursID(tool^[editorTools,currentTool[editorTools]].optionCursID)															else																SetCursH(tool^[editorTools,currentTool[editorTools]].curs)														else 															if (opt= (selectToEndMode=selectToLastCharacterMode)) & tool^[editorTools,currentTool[editorTools]].hasOptionCurs then																	SetCursID(721)																else																	SetCursID(702);													end												else													SetCursorToArrow;											end										else if (currentTool[editorTools] = stampPasteT) then											begin												box := editorMatrixRect;												InsetRect(box,-8,-8);												if PtinREct(wh, box) then													begin														SetCursH(tool^[editorTools,currentTool[editorTools]].curs);														ShimmerStampPasteBlock(EWScrapBlockP, wh);													end												else													begin														HideStampPasteBlock;														SetCursorToArrow;													end;											end										else if (currentTool[editorTools] = editorSortT) then											begin												if PtinREct(wh, editorMatrixRect) then													begin														flipSort := ((ic=0) & editorTransposed) |  ((it=0) & not editorTransposed) |  ((ic=-1) & not editorTransposed) |  ((it=-1) & editorTransposed);														if overDataCell then															SetCursorToArrow														else if UseOptionTool(editorTools,currentTool[editorTools],opt) then															if flipSort then																	SetCursID(163)															else																SetCursID(tool^[editorTools,currentTool[editorTools]].optionCursID)														else															if flipSort then																SetCursID(160)															else																SetCursH(tool^[editorTools,currentTool[editorTools]].curs);													end												else													SetCursorToArrow;											end										else if (currentTool[editorTools] <> editorArrowT) then										{if moveCellBlocks & dataP^.editorSelected & not SingleCell(dataP) & PtInRect(wh, dataP^.editorSelectionRect) & not WholeTaxonSel(dataP) & (CharOfCell(dataP, dataP^.editorSelectionTopLeft) > 0) & (wh.h > dataP^.editorRowNameEnd) & (wh.v > dataP^.editorTitlesWidth) & someDataSel(dataP) then}											begin												if PtinREct(wh, editorMatrixRect) then													begin														if currentTool[editorTools]= editorSelectionT then															SetCursID(crossHairCursorID)														else if (currentTool[editorTools]= eyedropperT) & (it=0) then															SetCursID(cantDoCursorID)														else 															begin																if not tool^[editorTools,currentTool[editorTools]].worksInDataCells & overDataCell then																	SetCursorToArrow																else if UseOptionTool(editorTools,currentTool[editorTools],opt) then																	SetCursID(tool^[editorTools,currentTool[editorTools]].optionCursID)																else																	SetCursH(tool^[editorTools,currentTool[editorTools]].curs);															end;													end												else													SetCursorToArrow;											end										else 											ShowStandardToolInEditor(wh,opt,comm,shift,cont);									end{|||||||||||||||||||InfoWindows||||||||||||||||||||}								else if IsInfoWindow(whichwindow) then									begin										HideStampPasteBlock;										whichinfo := WhichInfoWindow(whichwindow);										whichColumn := WhichInfoColumn(whichinfo, wh);										columnID := InfoColumnID(whichinfo, whichColumn);																														if (wh.h>myGetControlRect(infoScroll[whichinfo]).left)|(wh.v>myGetControlRect(infoHScroll[whichinfo]).top) then											SetCursorToArrow										else if (whichColumn=notAColumn) & (wh.v<infoLW[whichinfo])  & (wh.v>0)then											SetcursID(questionCursorID)										else if (wh.h < infonamestart[whichinfo]) & PtInRect(wh,infoAllCellsDrawRect[whichinfo]) & not shift & not comm & (currentInfoTool[whichinfo]<>infoScissorsT) then											if ((whichinfo=charpartnameinfo) | (whichinfo=charinfo) | (whichinfo=taxinfo)) & (opt & cont) then												SetcursID(gotoCursorID)											else												SetCursH(handcurs)										else if (InfoEditing[whichinfo] & PtInRect(wh, infoTE[whichinfo]^^.viewRect))& not InfoToolWorksOnNames(currentInfoTool[whichinfo]) then											SetCursor(ibeam)										else if (currentInfoTool[whichinfo]=infoWandT) & InfoColumnWandable(whichinfo,whichColumn) & PtInRect(wh,infoAllCellsDrawRect[whichinfo])  then											if InfoColumnNumerical(whichinfo,columnID) then												if OptionEvent(Event) then													SetCursID(infoTools^[whichinfo,infoWandT].optionCursorID)												else if ControlEvent(Event) then													SetCursID(infoTools^[whichinfo,infoWandT].controlCursorID)												else													SetCursID(infoTools^[whichinfo,infoWandT].cursorID)											else												SetCursID(infoTools^[whichinfo,infoWandT].cursorID)										else if (currentInfoTool[whichinfo]=infoSortDescendingT) & InfoColumnSortable(whichinfo,columnID) & PtInRect(wh,infoDrawRect[whichinfo])   then											if OptionEvent(Event) then												SetCursID(infoTools^[whichinfo,infoSortDescendingT].optionCursorID)											else 												SetCursID(infoTools^[whichinfo,infoSortDescendingT].cursorID)										else if (currentInfoTool[whichinfo]=infoSortAscendingT) & InfoColumnSortable(whichinfo,columnID) & PtInRect(wh,infoDrawRect[whichinfo])  then											if OptionEvent(Event) then												SetCursID(infoTools^[whichinfo,infoSortAscendingT].optionCursorID)											else 												SetCursID(infoTools^[whichinfo,infoSortAscendingT].cursorID)										else if (currentInfoTool[whichinfo]=infoScissorsT) & PtInRect(wh,infoAllCellsDrawRect[whichinfo])& InfoRowsDeletable(whichinfo) then											SetCursID(infoTools^[whichinfo,infoScissorsT].cursorID)										else											SetCursorToArrow									end{|||||||||||||||||||branchlistwindow||||||||||||||||||||}								else if whichwindow = BranchListwindow then									begin										FlashStored;										SetCursorToArrow;									end{|||||||||||||||||||Chartwindow||||||||||||||||||||}								else if (whichwindow = Chartwindow) then									begin										SetCursorToArrow;									end{|||||||||||||||||||chlegwindow||||||||||||||||||||}								else if (whichwindow = chlegwindow) then									begin										FlashStored;										if (currentTool[treeTools] = treeWandT) & TicksVisible & (wh.v > strect[numCharLegendBoxes].bottom)  then											SetCursH(tool^[treeTools,treeWandT].curs)										else if (currentTool[treeTools] = scissorsT) & TicksVisible & (wh.v > strect[numCharLegendBoxes].bottom)  then											SetCursH(tool^[treeTools,scissorsT].curs)										else if (currentTool[treeTools] = paintT) and (wh.v > strect[1].top - 3) and (wh.v < myGetControlRect(chlegscroll).top - 3) then											SetCursH(tool^[treeTools,paintT].curs)										else if (currentTool[treeTools] = treePictureT) and (wh.v < myGetControlRect(chlegscroll).top - 3) and not ((wh.v < 10) and (wh.h < 10)) then{less than 10,10 put in for go-away box}											SetCursH(tool^[treeTools,treePictureT].curs)										else											SetCursorToArrow;									end{|||||||||||||||||||toolPaletteWindow[treeTools],twmesswindow,tlegwindow||||||||||||||||||||}								else if (whichwindow = toolPaletteWindow[treeTools]) or (whichwindow = twmesswindow) or (whichwindow = tlegwindow) then									begin										FlashStored;										SetCursorToArrow;									end{|||||||||||||||||||toolPaletteWindow[editorTools],twmesswindow,tlegwindow||||||||||||||||||||}								else if (whichwindow = toolPaletteWindow[editorTools])  then									begin										HideStampPasteBlock;										SetCursorToArrow;									end{|||||||||||||||||||text window ||||||||||||||||||||}								else if IsTextWindow(whichwindow) then									begin										HideStampPasteBlock;										if wh.h > WindowPortRect(whichWindow).right - scrollwidth then											SetCursorToArrow										else if PtInREct(wh, WindowPortRect(whichWindow)) & IsEditableTextWindow(whichwindow)  then											SetCursor(ibeam)										else											SetCursorToArrow;									end{|||||||||||||||||||stateswindow||||||||||||||||||||}								else if whichwindow = statesWindow then									begin										HideStampPasteBlock;										if statesEditing & PtInRect(wh, statesTE^^.viewRect) then											SetCursor(ibeam)										else											SetCursorToArrow									end{|||||||||||||||||||treewindow||||||||||||||||||||}								else if (whichwindow = treewindow) and treeonscreen then									begin										turnofflast := true;										FlashStored;										if (OrientVert(wh.h, wh.v) < topmargin) and PtinRgn(wh, TWClip) and not (PtInRect(wh, claspRect) and nex7on) then											begin												if (currentTool[treeTools] = treePictureT) & not (comm | shift) then													SetCursH(tool^[treeTools,treePictureT].curs)												else if (not nex7on | (wh.v > claspRect.bottom)) & ((shift & not comm & not opt) | (currentTool[treeTools] = handT)) & ((GetControlMaximumLong(hTWScroll) > GetControlMinimumLong(hTWScroll)) | (GetControlMaximumLong(vTWScroll) > GetControlMinimumLong(vTWScroll))) then													SetCursH(tool^[treeTools,handT].curs)												else													SetCursorToArrow											end										else if (PtinRect(wh, claspRect)) and nex7on then											begin{$IFC FLIPTREE}												if treeflipped then													SetCursID(153)												else{$ENDC}													SetCursor(clasper);											end										else if not PtInRgn(wh, TWClip) | (nex7on & PtInRect(wh, databoxB)) then											SetCursorToArrow										else if ((shift & not comm & not opt) | ((currentTool[treeTools] = handT) & not comm)) & ((GetControlMaximumLong(hTWScroll) > GetControlMinimumLong(hTWScroll)) | (GetControlMaximumLong(vTWScroll) > GetControlMinimumLong(vTWScroll))) then											SetCursH(tool^[treeTools,handT].curs){$IFC FALSE}{v4: this is for random move}										else if (currentTool[treeTools] = arrowT) and shift and opt and not comm then											SetCursID(22670){$ENDC}										else if (currentTool[treeTools] = treePictureT) and PtInRgn(wh, TWClip) and not (comm or shift) then											SetCursH(tool^[treeTools,treePictureT].curs)										else if PTInrect(wh, visTWR) then											begin												turnofflast := false;												if flashbranchon & nodes then													TreeFlashing(wh);												if comm & not noCommandToolOverride & not shift then													SetCursorToArrow												else if UseOptionTool(treeTools,currentTool[treeTools],opt)  then													SetCursID(tool^[treeTools,currentTool[treeTools]].optionCursID)												else if (currentTool[treeTools] = expandT) and (fn = ScreenR) and (R <> ScreenR) then													SetCursID(shrinkMagID)												else													SetCursH(tool^[treeTools,currentTool[treeTools]].curs);											end										else											SetCursorToArrow;										if turnofflast and (lastselN <> subR) then   {turn off last}											begin												genericSetPort(treewindow);												PENMODE(patXOR);												Penpat(dashpat);												oldClip := NewRgn;												GetClip(oldclip);												SetDataBoxesClip;												OutlinePoly(lastselN);												penmode(patcopy);												Penpat(QDBlack);												ClipRect(WindowPortRect(treeWindow));												WritePalMessageB(treeTools,PaletteString(treeTools,currentTool[treeTools], nil));												if (traceshown = traceDiscrete) then													begin														genericSetPort(chlegwindow);														if not isterminalFixanc(lastselN) then															EraseAsterisksEtc;													end												else if (traceshown = traceAllChanges) then													begin														genericSetPort(chlegwindow);														TEXTMODE(srcBIC);														moveto(5, strect[1].top - 5);														DrawBranchLength(lastselN);														TEXTMODE(srcOR);													end												else if (traceshown = traceContinuous) then													begin														genericSetPort(chlegwindow);														SetRect(crect, 0, WindowPortRect(chlegwindow).bottom - 32, WindowPortRect(chlegwindow).right - 1, WindowPortRect(chlegwindow).bottom - 1);														Eraserect(crect);													end;												genericSetPort(treewindow);												lastselN := subR;												setclip(oldclip);												ZapRegion(oldClip);											end;									end								else									SetCursorToArrow;							end;					end;			end;		genericSetPort(tport);	end;end.