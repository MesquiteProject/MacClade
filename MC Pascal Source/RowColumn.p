unit RowColumn;{ееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, 		TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, TaxonCHUtil, 		TypeUtil, TreeUtil, CharUtil, BoxUtil, WriteUtil, InfoWindows, 		CHUNK, LinkUtil, MenuUtil, Footnote, UtilLibInterface, StatesWindow,		SpreadUtil,EditorCellEntry;	function QueryRemoveWholeRowColumn: boolean;	function ClearSelected (removeWholes: boolean): boolean;	procedure AdjustStuff(eraseInfoWindows: boolean);	procedure FillTaxSts (icstart, icend, itstart, itend: integer; fillwithgap: boolean);	procedure EmptyCharacters (icstart, icend: integer);	procedure AddNewCharacters (howmany: integer; fillwithgap: boolean);	procedure InsertNewCharacters (howmany, where: integer; fillwithgap: boolean);	function MoveCharacters (icstart, icend, too: integer): boolean;	procedure DestroyCharacterInfo (icstart, icend: integer; munch, feet: boolean);	procedure DestroyCharacters (icstart, icend: integer; munch, feet,setCantUndo,eraseInfoWindows: boolean);	procedure IncExcChangePosting (doShrink: boolean);	procedure FillTaxa (itstart, itend: integer; setNewlyInserted: boolean);	procedure AddNewTaxa (howmany: integer; fillwithgap: boolean);	procedure InsertNewTaxa (howmany, where: integer; fillwithgap: boolean);	procedure MoveTaxa (itstart, itend, too: integer);	procedure DestroyTaxa (itstart, itend: integer; setCantUndo,eraseInfoWindows: boolean);	procedure EmptyTaxonCharacterMemory;	procedure CleanUpFailedTaxonCharacterMemory;	function FullMemoryNeeded (ntax, nchar: longint): longint;	function CreateTaxonCharMemory: boolean;	procedure ExpandData;	procedure ContractData;	procedure DeleteNewlyInsertedCharacters;	procedure DeleteNewlyInsertedTaxa;	procedure LoadRowColumn;{ееееееееееееееееееееее}implementation {е$S RowColumn}{this unit deals with the adding, deleting of taxa and characters}{it is a low enough procedure in the calling chain so that we can safely assume that all handles come in to}{it unlocked; this assumption is made}	const		adjustmove = 0;		adjustadd = 1;		adjustdelete = 2;{----------------------------------------------------------------------------}	procedure CheckFullEditorRedrawTaxaChanged;	begin		if editorOpen then			if ShadeCharacterSensitiveToCellChange then				begin					ReCalcMaxstAndStates(1,numchars);					InvalidateWindow(editorWindow,true);				end			else if EditorCellsColoredByState & not molecular  & not sameStateColorsForAllCharacters then				begin					ReCalcMaxstAndStates(1,numchars);					InvalidateWindow(editorWindow,true)				end			else if ConsensusSequenceVisible then				InvalidateWindow(editorWindow,true)			else if UpdateAsSensitiveToFirstTaxonChange(1) then				InvalidateWindow(editorWindow,true);	end;{----------------------------------------------------------------------------}	procedure CheckFullEditorRedrawCharactersChanged;	begin		if editorOpen then			if nucleotides then				if (editorShowAAwithDNA & editorColorAAwithDNA) | (editorColorCellsMode = editorColorCellsAAState) then					InvalidateWindow(editorWindow,true);	end;{-----------------------------------------------------------------------------}	procedure FillLinkUniform (linkH: Handle; fillvalue, bytes: integer);{sets the link to be of size 1 to numchars all with value fillvalue}		var			iptt: ip;			LI: LIP;			j: integer;			offset: integer;			oldstate: SignedByte;	begin		offset := LinkOffset(linkH);		UnlockHandle(linkH, oldstate);		if not SetHandleSizeSuccessful(LinkH, offset + ord4(numchars) * bytes) then Exit(FillLinkUniform);				HLock(linkH);		if bytes = 2 then			for j := 1 to numchars do				begin					iptt := ip(GetMaster(LinkH) + offset + bytes * ord4(j - 1));					iptt^ := fillvalue;				end		else if bytes = 4 then			for j := 1 to numchars do				begin					LI := LIP(GetMaster(LinkH) + offset + bytes * ord4(j - 1));					LI^ := fillvalue;				end;		ResetHandle(linkH, oldstate);	end;{-----------------------------------------------------------------------------}	procedure FillDefaultLinks;		var			linkH: Handle;	begin		linkH := nil;		linkH := NewHandle(0);		ClearLinkBytes(LinkH);		SetLinkName(LinkH, 'All_unordered');		FillLinkUniform(LinkH, unordered, chtB);		if errorflag then Exit(FillDefaultLinks);		SetLink(typeSetChain, 0, linkH);		SetLinkName(LinkH, 'All_ordered');		FillLinkUniform(LinkH, ordered, chtB);		if errorflag then Exit(FillDefaultLinks);		SetLink(typeSetChain, 1, linkH);		SetLinkName(LinkH, 'Equal_weights');		FillLinkUniform(LinkH, 1, chwB);		if errorflag then Exit(FillDefaultLinks);		SetWtLinkBits(linkH, false);		SetLink(wtSetChain, 0, linkH);		SetLinkName(LinkH, 'One Part');		FillLinkUniform(LinkH, 1, chpartB);		if errorflag then Exit(FillDefaultLinks);		SetLink(CharPartitionChain, 0, linkH);		SetLinkName(LinkH, 'All_Included');		FillLinkUniform(LinkH, 1, exB);		if errorflag then Exit(FillDefaultLinks);		SetLink(exSetChain, 0, linkH);		SetLinkName(LinkH, 'All_Excluded');		FillLinkUniform(LinkH, 0, exB);		if errorflag then Exit(FillDefaultLinks);		SetLink(exSetChain, 1, linkH);		ZapHandle(linkH);	end;{-----------------------------------------------------------------------------}	procedure ShrinkDefaultLinks;		var			linkH: Handle;			theLink: longint;			theChain: integer;	begin		linkH := NewHandle(0);		for theChain := typeSetChain to exSetChain do			for theLink := 0 to PreDefLinks[theChain] - 1 do				begin					GetLink(theChain, theLink, linkH, false);					SetHandleSize(linkH, LinkOffset(linkH) + ord4(numchars) * linkBytes[theChain]);					SetLink(theChain, theLink, linkH);				end;		ZapHandle(linkH);	end;{-----------------------------------------------------------------------------}	procedure SetCellsToEmpty(st,et,sc,ec: longint);	var it, ic: longint;	begin		for it := st to et do			for ic := sc to ec do				if molecular then					settaxonstsLargestOverWriteCase(it, ic, [MSl, GAl])				else					settaxonstsLargestOverWriteCase(it, ic, [MSl]);	end;{-----------------------------------------------------------------------------}	function QueryRemoveWholeRowColumn: boolean;{user chooses clear from Edit menu, this does what needs to be done}		var			j, st, et, sc, ec, it, ic: integer;			response: integer;			B: Rect;			okdelete, db: boolean;			ds: str255;	begin		CalcSelectedTaxaCharacters(st, et, sc, ec, true);		okdelete := true;		QueryRemoveWholeRowColumn := true;		SetCursor(clockCursor);		if WholeTaxonSel and WholeCharSel then			begin				response := DoAlert(182, StopA);				case response of					1: 						begin							okdelete := false;							QueryRemoveWholeRowColumn := false;							Exit(QueryRemoveWholeRowColumn);						end;					2: 							begin							DestroyCharacters(2, numchars, true, true,true,true); {retain all taxa, one character}							SetCellsToEmpty(1,numtaxa,1,1);						end;					3: 						begin							DestroyTaxa(2, numtaxa,true,true); {retain all characters, one taxon}							SetCellsToEmpty(1,1,1,numchars);						end;					4: 						begin   {retain one of each}							DestroyCharacters(2, numchars, true, true,true,true);							DestroyTaxa(2, numtaxa,true,true);							SetCellsToEmpty(1,1,1,1);						end;											otherwise;				end;			end		else if WholeTaxonSel then			begin				if (st = 1) and (et >= numtaxa) then					begin						InstantError(173);						okdelete := false;						QueryRemoveWholeRowColumn := false					end				else					begin						if et - st > 0 then							ds := concat(StringFromNum(et - st + 1), ' taxa from matrix')						else							ds := '1 taxon from matrix';						if treeinmemory | ((UserLinks[treefilechain] > 0) | (UserLinks[datafilechain] > 0)) then							ds := concat(ds, ' and from stored and unstored trees');						ParamText(ds, '', '', '');						okdelete := (DoAlert(426, CautionA) = 1);						if okdelete then							DestroyTaxa(st, et,true,true)						else							QueryRemoveWholeRowColumn := false;					end;			end		else if WholeCharSel then			begin				if (sc = 1) and (ec = numchars) then					begin						InstantError(174);						okdelete := false;						QueryRemoveWholeRowColumn := false;					end				else					begin						if ec - sc > 0 then							ParamText(concat(StringFromNum(ec - sc + 1), ' characters'), '', '', '')						else							ParamText('1 character', '', '', '');						okdelete := (DoAlert(426, CautionA) = 1);						if okdelete then							DestroyCharacters(sc, ec, true, true,true,true)						else							QueryRemoveWholeRowColumn := false;					end;			end;		if not okdelete then			Exit(QueryRemoveWholeRowColumn);		ClipRect(editorBoundaryRect);		B := editorBoundaryRect;		if (editorSelectionTopLeft.v = -1) or (editorSelectionTopLeft.v = 0) then			begin				B.left := editorSelectionRect.left;				if B.left < editorFirstColumnLeft then					B.left := editorFirstColumnLeft;			end		else			begin				B.top := editorSelectionRect.top;				if B.top < editorFirstRowTop then					B.top := editorFirstRowTop;			end;		EraseRect(B);		InvalidateWindowRect(editorWindow,B,false);		ZeroSelection;		datachanged := true;		dirtymaxst := true;	end;{-----------------------------------------------------------------------------}	function ClearSelected (removeWholes: boolean): boolean;{user chooses clear from Edit menu, this does what needs to be done}		var			j, st, et, sc, ec, it, ic: integer;			B: Rect;			db: boolean;			ds: str255;	begin		ClearSelected := true;		if editorSelected then			begin				CalcSelectedTaxaCharacters(st, et, sc, ec, true);				if OptionEvent(Event) then   		{user held option down - just remove footnotes and footpicts}					begin						if AnyFeet(footPict) then							RemoveFeetSelected(footPict);						if AnyFeet(footText) then							RemoveFeetSelected(footText);						dirtyfile := true;					end				else if removeWholes & (WholeTaxonSel | WholeCharSel) then    {remove whole taxa or characters}					ClearSelected := QueryRemoveWholeRowColumn				else if ((et > 0) and (ec > 0)) then					begin{ clear an internal block of cells}						if not StoreSelectedCellBlockForUndo(false,false,true) then							begin								ClearSelected := false;								Exit(ClearSelected);							end;						SetCellsToEmpty(st,et,sc,ec);						CheckRedrawFullCharactersInEditor(st,et,sc,ec,true);						{if UpdateAsSensitiveToFirstTaxonChange(st) then							MatchCharUpdate(sc, ec);}						SetDirtyEditor(true);						ClearSelected := true;					end				else					begin						Beep;						ClearSelected :=false;					end;			end;	end;{----------------------------------------------------------------------------}	procedure AdjustStuff(eraseInfoWindows: boolean);{after deletion or addition of taxa and characters, this adjusts various things}	begin		FixTotNums;		datachanged := true;		dirtymaxst := true;		if editorOpen then			begin				CalcEditorMatrixRect;				CalcEditorSelectionRect(editorSelectionTopLeft, editorSelectionBotRight);				SetScrollMax;			end;		AdjustInfoScrolls(charinfo);		AdjustInfoScrolls(taxinfo);		if infoOpen[charinfo] then			InvalidateWindow(infoWindow[charinfo], eraseInfoWindows);		if infoOpen[taxinfo] then			InvalidateWindow(infoWindow[taxinfo], eraseInfoWindows);		UpdateStatesWindowIfCharactersChanged;		ResetStatesScroll;  {///   also add StatesWindow to RowColumn}		if i > numchars then			i := 1;		if statesWindowCharacter > numchars then			begin				TurnOffStatesEditing;				statesWindowCharacter := 1;			end;		if editorPaintReferenceTaxon > numtaxa then			begin				editorPaintReferenceTaxon := 1;				InvalidateWindow(toolPaletteWindow[editorTools], false);			end;		SetControlValueLong(chlegscroll, i);		SetControlValueLong(statesWindowHScroll,statesWindowCharacter);	end;{----------------------------------------------------------------------------}	procedure FillTaxSts (icstart, icend, itstart, itend: integer; fillwithgap: boolean);{this fills all char and taxa within bounds of icstart, icend, itstart, itend with missing data }{(or gap if fillwithgap is true)}		var			it, ic: integer;			tsp: ptr;			taxstsHdlPtr: HdlPtr;			oldstate1, oldstate2: SignedByte;	begin		LockHandle(TaxstsCHUNKs, oldstate1);		TaxstsHdlPtr := HdlPtr(GetMaster(TaxstsCHUNKs) + HdlSize * (itstart - 1));		if fillwithgap then			locSetPtr31^ := [MSl, GAl]		else			locSetPtr31^ := [MSl];		for it := itstart to itend do			begin				LockHandle(taxstsHdlptr^, oldstate2); {***}				tsp := Ptr(GetMaster(TaxStsHdlPtr^) + ord4(icstart - 1) * tcb);				for ic := icstart to icend do					begin						TransferStates(tsp, ptr(locSetPtr31));						tsp := ptr(ord4(tsp) + tcb);					end;				ResetHandle(taxstsHdlptr^, oldstate2); {***}				TaxstsHdlPtr := HdlPtr(ord4(TaxstsHdlPtr) + HdlSize);			end;		ResetHandle(TaxstsCHUNKs, oldstate1);	end;{||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}{----------------------------------------------------------------------------}	procedure CheckAddSingleType (typnum: integer); {checks various type info if one adds a specific type, but does not delete any}	begin		curtypes := curtypes + [typnum];		typeHdl := GetTypeHdl(typnum);		if (typnum >= usedef) then			anygenchar := true;		if typeHdl^^.polar then			anydirected := true;		if typeHDL^^.isreal then			realtypes := true;		CheckInflate;		TypesInUseMenu;	end;{----------------------------------------------------------------------------}	function defaultwt: integer;	begin		if realwt then			defaultwt := WtInflate		else			defaultwt := 1;	end;{----------------------------------------------------------------------------}	procedure FillCharacters (icstart, icend: integer; SetNewlyInsertedCharacter: boolean);{fills character info for newly created characters}		var			charHdl: chHdl;			it, ic: integer;			{ds: str255;			dl: Longint;}			ctypP, cstoretypP, cwtP, cstorewtP,cpartP,cstorePartP: IP;			CstatesP: Ptr;			dhdl: Handle;			oldstate1, oldstate2, oldstate3, oldstate4, oldstate5, oldstate6, oldstate7: SignedByte;	begin		LockHandle(chtypH, oldstate1);		LockHandle(chstoretypH, oldstate2);		LockHandle(chwtH, oldstate3);		LockHandle(chstorewtH, oldstate4);		LockHandle(chpartitionH, oldstate6);		LockHandle(chstorepartitionH, oldstate7);		LockHandle(chstatesH, oldstate5);		ctypP := IP(GetMaster(chtypH) + chtb * ord4(icstart - 1));		cstoretypP := IP(GetMaster(chstoretypH) + chtb * ord4(icstart - 1));		cwtP := IP(GetMaster(chwtH) + chwb * ord4(icstart - 1));		cstorewtP := IP(GetMaster(chstorewtH) + chwb * ord4(icstart - 1));		cpartP := IP(GetMaster(chPartitionH) + chpartb * ord4(icstart - 1));		cstorepartP := IP(GetMaster(chStorePartitionH) + chpartb * ord4(icstart - 1));		cstatesP := Ptr(GetMaster(chstatesH) + chsb * ord4(icstart - 1));		locSetPtr31^ := [];		{ds := concat(' ', NoName, ' ', EndNames);}{    doCodPosQuery := nucleotides;}		for ic := icstart to icend do   {note that some of this is also done in GeneticCode}			begin   {do NOT set unused1 and unused2 here!}				charHdl := getchHdl(ic);				charHdl^^.maxst := 1;				charHdl^^.name := ' ';				charHdl^^.namebackup := ' ';				charHdl^^.newlyInserted := SetNewlyInsertedCharacter;				charHdl^^.deleted := false;				charHdl^^.footText := false;				charHdl^^.footPict := false;				charHdl^^.constant := false;				charHdl^^.charSet := false;				charHdl^^.charSetToShade := false;				charHdl^^.consensusAllTies := [];				charHdl^^.consensusMaxFreq := 0;				charHdl^^.consensusNumValues := 0;				charHdl^^.consensusAreTies := false;				charHdl^^.MSTTree := false;				charHdl^^.MSTData := false;				charHdl^^.infoSelected := false;				charHdl^^.otherSelected := false;				charHdl^^.coding := false;    {codingcode: was false}									{31March99 codonPos change: coding switched from true to false}				charHdl^^.extra := false;				charHdl^^.codpos := nonCoding;  {31March99 codonPos change: was codeNotSet}				InitStateNamesOfCharacter(ic,true);				InitStateNamesOfCharacter(ic, false);				ctypP^ := deftype;				ctypP := IP(ord4(ctypP) + chtb);				cstoretypP^ := deftype;				cstoretypP := IP(ord4(cstoretypP) + chtb);				cwtP^ := defaultwt;				cwtP := IP(ord4(cwtP) + chwb);				cstorewtP^ := defaultwt;				cstorewtP := IP(ord4(cstorewtP) + chwb);				cpartP^ := defaultPartition;				cpartP := IP(ord4(cpartP) + chpartb);				cstorepartP^ := defaultPartition;				cstorepartP := IP(ord4(cstorepartP) + chpartb);				TransferStates(CstatesP, ptr(locSetPtr31));				cstatesP := Ptr(ord4(cstatesP) + chsb);			end;		ResetHandle(chtypH, oldstate1);		ResetHandle(chstoretypH, oldstate2);		ResetHandle(chwtH, oldstate3);		ResetHandle(chstorewtH, oldstate4);		ResetHandle(chpartitionH, oldstate6);		ResetHandle(chstorePartitionH, oldstate7);		ResetHandle(chstatesH, oldstate5);		CheckAddSingleType(deftype);	end;{----------------------------------------------------------------------------}	procedure EmptyCharacters (icstart, icend: integer);		var			it, ic: integer;			thefoot: integer;	begin		FillCharacters(1, 1, false);		for theFoot := 0 to maxFootType do			DestroyFeet(theFoot, icstart, icend, true);		if molecular then			begin				for it := 1 to numtaxa do					for ic := icstart to icend do						settaxonstsLargestOverWriteCase(it, ic, [MSl,GAl]);			end		else			begin				for it := 1 to numtaxa do					for ic := icstart to icend do						settaxonstsLargestOverWriteCase(it, ic, [MSl]);			end;	end;{----------------------------------------------------------------------------}	function NewCharacterMemory (newchars: longint): longint;		var			memoryrequired: longint;	begin		memoryrequired := ord4(newchars) * (tcb * numtaxa + chtb * 2 + chwb * 2 + chpartb * 2+ chlb + chpb + chsb);									{memory for taxsts, chtypH, chwtH, etc}		memoryrequired := memoryrequired + ord4(newchars) * 2 * (4 + (2 * hdlsize + 6));									{the 2* is as there is storage for state names + backup}									{the 4 is for the 4-character default statenames}									{plus for statenames & backup have to add a handle, cost of 2*hdlsize+6}		memoryrequired := memoryrequired + newchars * (2 * hdlsize + 6 + (sizeof(chtype) + 8));									{memory for basic charHdl storage}		if treeopen then	  {add more for tree node storage!}			begin{number of nodes = 2*numtaxain-1  + 1 for subR & need stsH for subsubR}{for each node, require tcb*ord4(newchars)*3  - as need enough for dnstH, upstH, stsH}				memoryrequired := memoryrequired + 2 * ord4(numtaxain) * tcb * ord4(newchars) * 3 + tcb * ord4(newchars);			end;		NewCharacterMemory := memoryrequired + 1024;	end;{----------------------------------------------------------------------------}	procedure MunchSets (theChain: Integer; where, numtodelete, numtoinsert, inc, movestart, moveend: integer);{this munches the type, wt, charset, and exset links when characters are added or deleted}{or taxsets when taxa are added or deleted}		var			oldElements, j, k, offset: integer;			dL: longint;			linkH: Handle;			ds: str255;			intP: IP;			dummy, oldrealwt: boolean;			assignInt: integer;	begin		if not MemoryOK then			Exit(MunchSets);		if theChain = taxsetchain then			oldElements := numtaxa		else			oldElements := numchars;		oldrealwt := realwt;		linkH := NewHandle(2);		if theChain = typesetchain then			assignInt := deftype		else if theChain = wtsetchain then			assignInt := defaultwt		else if theChain = charPartitionChain then			assignInt := defaultPartition		else			assignInt := 1;		for j := StartUserLink(theChain) to EndUserLink(thechain) do			begin				SetHandleSize(linkH, 2);				GetLink(theChain, j, linkH, false);				offset := LinkOffSet(linkH);				if theChain = taxsetchain then					numtaxa := oldElements				else					numchars := oldElements;				if (numtodelete <> 0) then					DeletePieceOfHandle(linkH, offset + inc * ord4(where - 1), ord4(numtodelete) * inc)				else if (numtoinsert <> 0) then	{we're inserting or deleting}					begin						InsertPieceIntoHandle(linkH, offset + inc * ord4(where - 1),@dummy, ord4(numtoinsert) * inc);						HLock(linkH);						intP := IP(GetMaster(linkH) + offset + inc * ord4(where - 1));						for k := 1 to numtoinsert do							begin								intP^ := assignInt;								intP := IP(ord4(intP) + inc);							end;						HUnlock(linkH);					end				else			{we're moving}					MoveHandlePieces(linkH, inc, movestart, moveend, where, offset);				if theChain = taxsetchain then					numtaxa := oldElements - numtodelete + numtoinsert				else					numchars := oldElements - numtodelete + numtoinsert;				SetLink(theChain, j, linkH);				realwt := oldrealwt;			end;		ZapHandle(linkH);		if theChain = taxsetchain then			numtaxa := oldElements		else			numchars := oldElements;	end;{----------------------------------------------------------------------------}	procedure AddNewCharacters (howmany: integer; fillwithgap: boolean);{adds howmany new characters to the end}		var			it: integer;			taxstsHdl: Handle;			amountneeded: longint;	begin		if not EnoughMemory(NewCharacterMemory(howmany), amountneeded) then			begin				badmemory := true;				InstantErrorPlus(347, concat(StringFromNum(amountneeded div 1024), 'K'));				Exit(AddNewCharacters);			end;		TurnOffInfoEditing(charinfo);		AddCHUNKs(chCHUNKs, howmany, sizeof(chtype));		AddCHUNKs(statenamesCHUNKs, howmany, 2);		AddCHUNKs(statenamesCHUNKsBU, howmany, 2);		for it := 1 to numtaxa do			begin				taxstsHdl := gettaxstsHdl(it);				SetHandleSize(taxstsHdl, GetHandleSize(taxstsHdl) + ord4(howmany) * tcb);			end;		SetHandleSize(chtypH, GetHandleSize(chtypH) + ord4(howmany) * chtb);		SetHandleSize(chstoretypH, GetHandleSize(chstoretypH) + ord4(howmany) * chtb);		SetHandleSize(chwtH, GetHandleSize(chwtH) + ord4(howmany) * chwb);		SetHandleSize(chstorewtH, GetHandleSize(chstorewtH) + ord4(howmany) * chwb);		SetHandleSize(chPartitionH, GetHandleSize(chPartitionH) + ord4(howmany) * chpartb);		SetHandleSize(chstorePartitionH, GetHandleSize(chstorePartitionH) + ord4(howmany) * chpartb);		SetHandleSize(chlenH, GetHandleSize(chlenH) + ord4(howmany) * chlb);		SetHandleSize(chpLH, GetHandleSize(chpLH) + ord4(howmany) * chpb);		SetHandleSize(chstatesH, GetHandleSize(chstatesH) + ord4(howmany) * chsb);		MunchSets(typeSetChain, numchars + 1, 0, howmany, chtb, 0, 0);		MunchSets(wtSetChain, numchars + 1, 0, howmany, chwb, 0, 0);		MunchSets(CharPartitionChain, numchars + 1, 0, howmany, chpartb, 0, 0);		MunchSets(exSetChain, numchars + 1, 0, howmany, exb, 0, 0);		MunchSets(charSetChain, numchars + 1, 0, howmany, exb, 0, 0);		FillCharacters(numchars + 1, numchars + howmany,true);		FillTaxSts(numchars + 1, numchars + howmany, 1, numtaxa, fillwithgap);		numchars := numchars + howmany;		numcharin := numcharin + howmany;		SetControlMaximumLong(chlegScroll, numchars);		SetControlMaximumLong(statesWindowHScroll,numchars);		AdjustStuff(false);		FillDefaultLinks;		{if infoOpen[charinfo] then			InvalidateWindow(infoWindow[charinfo], true);}		CheckFullEditorRedrawCharactersChanged;	end;{----------------------------------------------------------------------------}	procedure InsertNewCharacters (howmany, where: integer; fillwithgap: boolean);		var			j, it: integer;			dL: longint;			tsts: largestsetchars;			taxstsHdl: Handle;			amountneeded: longint;			howManyCHLB: longint;			oldState: SignedByte;	begin		if not EnoughMemory(NewCharacterMemory(howmany) + ord4(numchars) * 4, amountneeded) then			begin{numchars * 4 needed for Munching}				badmemory := true;				InstantErrorPlus(347, concat(StringFromNum(amountneeded div 1024), 'K'));				Exit(InsertNewCharacters);			end;					TurnOffInfoEditing(charinfo);		if i > 1 then			if i >= where then				i := i + howmany;		if statesWindowCharacter > 1 then			if statesWindowCharacter>= where then				statesWindowCharacter := statesWindowCharacter+howmany;						tsts := [MSl];		InsertCHUNKs(chCHUNKs, where, howmany, sizeof(chtype));		InsertCHUNKs(statenamesCHUNKs, where, howmany, 2);		InsertCHUNKs(statenamesCHUNKsBU, where, howmany, 2);		for j := 0 to maxFootType do			ShiftFeet(j, where, numchars, howmany, 0, 0, 0, true);		MunchSets(typeSetChain, where, 0, howmany, chtb, 0, 0);		MunchSets(wtSetChain, where, 0, howmany, chwb, 0, 0);		MunchSets(CharPartitionChain, where, 0, howmany, chpartb, 0, 0);		MunchSets(exSetChain, where, 0, howmany, exb, 0, 0);		MunchSets(charSetChain, where, 0, howmany, exb, 0, 0);		for it := 1 to numtaxa do			begin				taxstsHdl := gettaxstsHdl(it);				InsertEmptyPieceIntoHandle(taxstsHdl, tcb * ord4(where - 1),ord4(howmany) * tcb);			end;		InsertEmptyPieceIntoHandle(chlenH, chlb * ord4(where - 1), ord4(ord4(howmany) * chlb));		InsertEmptyPieceIntoHandle(chtypH, chtb * ord4(where - 1), ord4(howmany) * chtb);		InsertEmptyPieceIntoHandle(chstoretypH, chtb * ord4(where - 1), ord4(howmany) * chtb);		InsertEmptyPieceIntoHandle(chwtH, chwb * ord4(where - 1), ord4(howmany) * chwb);		InsertEmptyPieceIntoHandle(chstorewtH, chwb * ord4(where - 1), ord4(howmany) * chwb);		InsertEmptyPieceIntoHandle(chPartitionH, chpartb * ord4(where - 1), ord4(howmany) * chpartb);		InsertEmptyPieceIntoHandle(chstorePartitionH, chpartb * ord4(where - 1), ord4(ord4(howmany) * chpartb));		//UnlockHandle(chlenH,oldstate);		InsertEmptyPieceIntoHandle(chpLH, chpb * ord4(where - 1), ord4(howmany) * chpb);		InsertEmptyPieceIntoHandle(chstatesH, chsb * ord4(where - 1), ord4(howmany) * chsb);		FillCharacters(where, where + howmany - 1, true);		FillTaxSts(where, where + howmany - 1, 1, numtaxa, fillwithgap);		numchars := numchars + howmany;		numcharin := numcharin + howmany;		SetControlMaximumLong(chlegScroll, numchars);		SetControlMaximumLong(statesWindowHScroll,numchars);		AdjustStuff(false);		FillDefaultLinks;		{if infoOpen[charinfo] then			InvalidateWindow(infoWindow[charinfo], true);  this is already done in AdjustStuff}		CheckFullEditorRedrawCharactersChanged;	end;{----------------------------------------------------------------------------}	procedure AdjustCharacterNumberOnMove(var characterNumber: integer; icstart,icend,too: integer);	begin		if too < icstart then			begin				if characterNumber >= too then					if characterNumber < icstart then						characterNumber := characterNumber + (icend - icstart + 1)					else if (characterNumber >= icstart) and (characterNumber <= icend) then						characterNumber := too + (characterNumber - icstart);			end		else			begin				if characterNumber <= too then					if characterNumber > icend then						characterNumber := characterNumber - (icend - icstart + 1)					else if (characterNumber >= icstart) and (characterNumber <= icend) then						characterNumber := too + (characterNumber - icstart) - (icend - icstart);			end;	end;{----------------------------------------------------------------------------}	function MoveCharacters (icstart, icend, too: integer): boolean;{if too < icstart, then move the characters ICSTART to ICEND inclusive to just before character TOO}{if too > icstart, then move the characters ICSTART to ICEND inclusive to just after character TOO}		var			theFoot, it: integer;			taxstsHdl: Handle;			amountneeded: longint;	begin		MoveCharacters := false;		if not warnedAboutMovedSequenceSites & molecular then			if  CWarning('You will be able to undo your rearrangement of sites immediately aftering having done it, but not later.  Are you sure you want to do this?', 'Yes', 'No') then				warnedAboutMovedSequenceSites := true			else				begin					//InvalidateWindow(editorWindow, true);					Exit(MoveCharacters);				end;		if not EnoughMemory(ord4(numchars) * 4, amountneeded) then			begin{numchars * 4 needed for Munching}				badmemory := true;				InstantErrorPlus(347, concat(StringFromNum(amountneeded div 1024), 'K'));				Exit(MoveCharacters);			end;		TurnOffInfoEditing(charinfo);		if not ((too >= icstart) and (too <= icend)) then			begin				SetLastChangeInEditor(lastChangeCantUndo);				AdjustCharacterNumberOnMove(i,icstart,icend,too);				AdjustCharacterNumberOnMove(statesWindowCharacter,icstart,icend,too);				if statesWindowOpen then					InvalidateWindow(statesWindow,false);				if too < icstart then					begin						for theFoot := 0 to maxFootType do							ShiftFeet(theFoot, icstart, icend, -(icstart - too), too, icstart - 1, icend - icstart + 1, true);					end				else					begin						for theFoot := 0 to maxFootType do							ShiftFeet(theFoot, icend + 1, too, -(icend - icstart + 1), icstart, icend, too - icend, true);					end;				MoveHandlePieces(chCHUNKs, HdlSize, icstart, icend, too, 0);				MoveHandlePieces(statenamesCHUNKs, HdlSize, icstart, icend, too, 0);				MoveHandlePieces(statenamesCHUNKsBU, HdlSize, icstart, icend, too, 0);				MoveHandlePieces(chtypH, chtb, icstart, icend, too, 0);				MoveHandlePieces(chstoretypH, chtb, icstart, icend, too, 0);				MoveHandlePieces(chwtH, chwb, icstart, icend, too, 0);				MoveHandlePieces(chstorewtH, chwb, icstart, icend, too, 0);				MoveHandlePieces(chPartitionH, chpartb, icstart, icend, too, 0);				MoveHandlePieces(chstorePartitionH, chpartb, icstart, icend, too, 0);				MoveHandlePieces(chlenH, chlb, icstart, icend, too, 0);				MoveHandlePieces(chpLH, chpb, icstart, icend, too, 0);				MoveHandlePieces(chstatesH, chsb, icstart, icend, too, 0);				MunchSets(typeSetChain, too, 0, 0, chtb, icstart, icend);				MunchSets(wtSetChain, too, 0, 0, chwb, icstart, icend);				MunchSets(CharPartitionChain, too, 0, 0, chpartb, icstart, icend);				MunchSets(exSetChain, too, 0, 0, exb, icstart, icend);				MunchSets(charSetChain, too, 0, 0, exb, icstart, icend);				for it := 1 to numtaxa do					begin						taxstsHdl := gettaxstsHdl(it);						MoveHandlePieces(taxstsHdl, tcb, icstart, icend, too, 0);					end;				CalcEditorMatrixRect;				datachanged := true;				dirtymaxst := true;				SetControlValueLong(chlegScroll, i);				SetControlValueLong(statesWindowHScroll,statesWindowCharacter);			end;		if infoOpen[charinfo] & CanUpdateWindow(infoWindow[charinfo]) then			InvalidateWindow(infoWindow[charinfo], true);		if (traceshown=traceDiscrete) & treeopen then			InvalidateWindow(chlegwindow,false);		if treeopen then			begin				InvalidateWindow(tlegwindow,false);				InvalidateWindow(chlegwindow,false);				godraw:= true;				FullTreeOnScreenGoList;			end;		MoveCharacters := true;		CheckFullEditorRedrawCharactersChanged;	end;{----------------------------------------------------------------------------}	procedure DestroyCharacterInfo (icstart, icend: integer; munch, feet: boolean);		var			quantity: integer;			dL: longint;			theFoot: integer;	begin		quantity := icend - icstart + 1;		DeleteCHUNKs(chCHUNKs, icstart, quantity);		DeleteCHUNKs(statenamesCHUNKs, icstart, quantity);		DeleteCHUNKs(statenamesCHUNKsBU, icstart, quantity);		if feet then			begin				for theFoot := 0 to maxFootType do					begin						DestroyFeet(theFoot, icstart, icend, true);						ShiftFeet(theFoot, icend + 1, numchars, -quantity, 0, 0, 0, true);					end;			end;		if munch then			begin				MunchSets(typeSetChain, icstart, quantity, 0, chtb, 0, 0);				MunchSets(wtSetChain, icstart, quantity, 0, chwb, 0, 0);				MunchSets(CharPartitionChain, icstart, quantity, 0, chpartb, 0, 0);				MunchSets(exSetChain, icstart, quantity, 0, exb, 0, 0);				MunchSets(charSetChain, icstart, quantity, 0, exb, 0, 0);			end;		DeletePieceOfHandle(chtypH, chtb * ord4(icstart - 1), ord4(quantity) * chtb);		DeletePieceOfHandle(chstoretypH, chtb * ord4(icstart - 1), ord4(quantity) * chtb);		DeletePieceOfHandle(chwtH, chwb * ord4(icstart - 1), ord4(quantity) * chwb);		DeletePieceOfHandle(chstorewtH, chwb * ord4(icstart - 1), ord4(quantity) * chwb);		DeletePieceOfHandle(chPartitionH, chpartb * ord4(icstart - 1), ord4(quantity) * chpartb);		DeletePieceOfHandle(chstorePartitionH, chpartb * ord4(icstart - 1), ord4(quantity) * chpartb);		DeletePieceOfHandle(chlenH, chlb * ord4(icstart - 1), ord4(quantity) * chlb);		DeletePieceOfHandle(chpLH, chpb * ord4(icstart - 1), ord4(quantity) * chpb);		DeletePieceOfHandle(chstatesH, chsb * ord4(icstart - 1), ord4(quantity) * chsb);		numchars := numchars - quantity;		SetControlMaximumLong(chlegScroll, numchars);		SetControlMaximumLong(statesWindowHScroll,numchars);	end;{----------------------------------------------------------------------------}	procedure DestroyCharacters (icstart, icend: integer; munch, feet,setCantUndo,eraseInfoWindows: boolean);{if munch is true, then munch typesets, wtsets, etc.}{if feet is true, then destroy all feet}		var			it, quantity: integer;			dL: longint;			H: Handle;			wasSingleincluded: boolean;	begin		if (icstart = 1) and (icend = numchars) then			begin				InstantError(174);				Exit(DestroyCharacters);			end		else if (icstart < 1) | (icend > numchars) then			begin				InstantInfo('Illegal character destruction requested');				Exit(DestroyCharacters);			end;		TurnOffInfoEditing(charinfo);		if setCantUndo then SetLastChangeInEditor(lastChangeCantUndo);		wasSingleincluded := (icstart = icend) & CharIncluded(icstart);		quantity := icend - icstart + 1;				if statesWindowCharacter >= icstart then			if statesWindowOpen then				begin						InvalidateWindow(statesWindow,true);				end;		if (statesWindowCharacter>= icstart) and (statesWindowCharacter <= icend) then			begin				TurnOffStatesEditing;				statesWindowCharacter := icstart-1;				if statesWindowCharacter < 1 then 					statesWindowCharacter := 1;			end 		else if statesWindowCharacter > icend then			statesWindowCharacter := statesWindowCharacter - quantity;					if (i >= icstart) and (i <= icend) then			if treeopen then				pleaseOffTrace := true			else				begin					if (traceshown = tracediscrete) then						gomask := gomask - igos; {turn off i tracing gomask; note charts not remembered on return from editor anyway}					traceshown := tracenothing;  					curTrace := tracenothing;					StringToH('0', fixdataH); 							i := 1;					if (currentTool[treeTools] = paintT) or (currentTool[treeTools] = statsTestT) or (currentTool[treeTools] = turpentineT) then						begin							currentTool[treeTools] := arrowT;   {don't call SetTool as not treeopen}							CheckToolKit(treeTools,paintT);							CheckToolKit(treeTools,statsTestT);							CheckToolKit(treeTools,turpentineT);						end;				end		else if i > icend then			i := i - quantity;		DestroyCharacterInfo(icstart, icend, munch, feet);		for it := 1 to numtaxa do			begin				H := gettaxstsHdl(it);				DeletePieceOfHandle(H, tcb * ord4(icstart - 1), ord4(quantity) * tcb);			end;		if icstart <> icend then			CalcNumCharIncluded		else if wasSingleIncluded then			numcharin := numcharin - 1;				AdjustStuff(eraseInfoWindows);	{	if infoOpen[charinfo] then			InvalidateWindow(infoWindow[charinfo], true); }		UpdateCurTypes;		if nucleotides then			CheckForCodPos(true);		CheckWt1;		CheckAllOnePartition;		ShrinkDefaultLinks;		ChangeExclusionsGolist;		infoDirtyNames[charinfo] := true;		CheckFullEditorRedrawCharactersChanged;{SetRect(editorSelectionRect, 0, 0, 0, 0);}{ZeroSelection}{ Make sure zeroselection called not here but after destroycharacters.  In many cases}{where Destroychars is called, zeroselection is called afterwards anyway, and if you call it here, it changes}{cell stuff which causes boxes to be recalculated wrong etc.}{v4: note that this removes any selection - this is fine if one selects a block}{and hits delete, but may not be quite so good if one uses "Clean Up" or some other function}{that internally destroys characters - note that same applies to destroy taxon}	end;{||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	procedure ShiftPackedTaxaNum (startP: ptr; sizeofblock: longint; ist, iend, ibefore: integer);{This procedure readjusts taxon numbers in packed trees after taxa were moved.}{startP is the pointer to the first byte of the block; sizeofblock is the number of bytes; ist and iend are}{the begining and ending taxa moved; ibefore is the taxon just before the point at which}{the taxa are reinserted}		var			nameofN, isign, it: integer;	begin		for it := 1 to sizeofblock div 2 do			begin				nameofN := getPackedNode(startP, it);				if (nameofN < 0) and (nameofN <> nullpacked) then					isign := -1				else					isign := 1;				nameofN := nameofN * isign;				if ibefore > iend then					begin						if (nameofN >= ist) then							if nameofN <= iend then								SetPackedNode(startP, it, isign * (nameofN + ibefore - iend))							else if nameofN <= ibefore then								SetPackedNode(startP, it, isign * (nameofN - (iend - ist + 1)));					end				else					begin						if (nameofN > ibefore) then		{DRM: changed ">=" to ">" as ibefore can = 0}							if nameofN < ist then								SetPackedNode(startP, it, isign * (nameofN + (iend - ist + 1)))							else if nameofN <= iend then								SetPackedNode(startP, it, isign * (nameofN - ist + ibefore + 1));					end;			end;	end;{-----------------------------------------------------------------------------}	procedure DeletePackedTaxaNum (startP: ptr; sizeofblock: longint; ist, iend: integer; var lengthofblock: longint; var arefixanc, arepolys: boolean; var numleft: integer);{This procedure readjusts taxon number in packed trees after taxa were deleted.}{startP is the pointer to the first byte of the block; sizeofblock is the number of bytes; ist and iend are}{the begining and ending taxa deleted}		var			nameofN, isign, it, ancname: integer;			ancwasfixed: boolean;	begin		lengthofblock := sizeofblock div 2;		it := lengthofblock;		while it > 0 do			begin				nameofN := getPackedNode(startP, it);				if (nameofN < 0) and (nameofN <> nullpacked) then					isign := -1				else					isign := 1;				nameofN := nameofN * isign;				if (nameofN >= ist) and (nameofN <= iend) then					begin						ancname := GetPackedNode(startP, PackedAncestorOf(startP, it));						ancwasfixed := (ancname < 0) and (ancname <> nullpacked);						DeletePackedTaxon(startP, it, lengthofblock);						numleft := numleft - 1;						if isign < 0 then {taxon deleted was fixed ancestor}							lengthofblock := lengthofblock - 1						else if ancwasfixed then {taxon deleted had fixed ancestor}							lengthofblock := lengthofblock - 1						else							begin   {taxon deleted was terminal and node below was not fixanced terminal}								lengthofblock := lengthofblock - 2;								it := it - 1;							end;					end				else if nameofN > iend then					SetPackedNode(startP, it, isign * (nameofN - (iend - ist + 1)));				it := it - 1;			end;		arefixanc := false;		arepolys := false;		for it := 1 to lengthofblock do			begin				if GetPackedNode(startP, it) = nullpacked then					arepolys := true				else if GetPackedNode(startP, it) < 0 then					arefixanc := true;			end;	end;{----------------------------------------------------------------------------}	procedure InsertPackedTaxaNum (startP: ptr; sizeofblock: longint; ibefore, howmany: integer);{This procedure readjusts taxon numbers in packed trees after taxa were inserted.}{startP is the pointer to the first byte of the block; sizeofblock is the number of bytes; ibefore is the }{taxon just before the point at which the taxa are inserted; how many is how many taxa are inserted}		var			nameofN, isign, it: integer;	begin		for it := 1 to sizeofblock div 2 do			begin				nameofN := getPackedNode(startP, it);				if (nameofN < 0) and (nameofN <> nullpacked) then					isign := -1				else					isign := 1;				nameofN := nameofN * isign;				if (nameofN > ibefore) then					SetPackedNode(startP, it, isign * (nameofN + howmany));			end;	end;{----------------------------------------------------------------------------}	procedure ShiftTaxaInCurrentTree(ist, iend, ibefore: integer);	var it: integer;		howmany: integer;	{.................}		procedure ShiftTaxonNumber (N: NPtr);		begin			if NodeIsInternal(N) then				begin					ShiftTaxonNumber(N^.lf);					ShiftTaxonNumber(N^.rt);				end			else				begin					if ibefore < ist then  {moving down}						begin							if N^.name > ibefore then {have to move it to just after ibefore}								if N^.name < ist then {it is before the moved block; just have to add the amount moved}									N^.name := N^.name+howmany								else if N^.name <= iend then   {it is in the moved block}									N^.name := N^.name-(ist-ibefore)+1;						end					else  {moving up}						begin							if N^.name <= ibefore then								if N^.name > iend then {it is after the moved block; just have to subtract the amount moved}									N^.name := N^.name-howmany								else if N^.name >= ist then   {it is in the moved block}									N^.name := N^.name+(ibefore-iend);						end;						{Davidv4.1: adjust this}				end;		end;	{.................}	begin		howmany := iend-ist+1;		ShiftTaxonNumber(R);	end;{-----------------------------------------------------------------------------}	procedure IncExcChangePosting (doShrink: boolean);	begin		FullTreeOnScreenGoList; {include exclude changed; do all golists for tree on screen}		godraw := true;		InvalidateWindow(tlegwindow, false);		if infoOpen[charinfo] then			begin				if charInfoShowMissing then					InvalidateInfoColumn(charinfo,charinfoMissing,1,numchars);				if charInfoShowGaps then					InvalidateInfoColumn(charinfo,charinfoGaps,1,numchars);				if charInfoShowPartition then					InvalidateInfoColumn(charinfo,charinfoPartition,1,numchars);			end;		if infoOpen[taxinfo] then			InvalidateWindow(infoWindow[taxinfo], false);		undotype := justInEx;		justundid := false;		if doShrink then			ShrinkTree;		CheckToolKit(treeTools,handT);		DropTool(treeTools,handT);		noundo := false;{    dirtytree := true;}		setDirtyTree;		dirtyfile := true;		SetAncon;		SetNullson;		myEnableItem(EditMHdl, UndoItem);		FixTreeShadingMenus;	end;{----------------------------------------------------------------------------}	procedure DestroyTaxaInCurrentTree(ist, iend: integer);	var it: integer;		howmany: integer;	{.................}		procedure RenumberTaxonInTree (N: NPtr);		begin			if NodeIsInternal(N) then				begin					RenumberTaxonInTree(N^.lf);					RenumberTaxonInTree(N^.rt);				end			else				begin					if N^.name > iend then 						N^.name := N^.name-howmany					else if N^.name >= ist then   						begin							N^.name := -1;						end;				end;		end;	{.................}		procedure ExciseMarkedTaxa (N: NPtr);		begin			if NodeIsInternal(N) then				begin					ExciseMarkedTaxa(N^.lf);					ExciseMarkedTaxa(N^.rt);				end			else				begin					if N^.name = -1 then						ExciseTaxonFromCurrentTree(N);				end;		end;	{.................}	begin		howmany := iend-ist+1;		RenumberTaxonInTree(R);		ExciseMarkedTaxa(R);		EmptyAssociatedTreeHandles;		IncExcChangePosting(true);	end;{----------------------------------------------------------------------------}	procedure AdjustTaxInTrees (ist, iend, ibefore, howmany, adjusttype: integer);		var			j, Numtaxaleft: integer;			packH: Handle;			arefixanc, arepolys, zapped: boolean;			theChain: integer;			oldstate1, oldstate2: SignedByte;{.................}		function GetTreeHandleSize (tH: handle): longint;		begin			GetTreeHandleSize := GEtHandleSize(th) - ip(GetMaster(th))^;		end;{.................}		procedure doAdjustTaxInTrees (var adjustH: Handle; var zapped: boolean; adjustNumberIfAdd: boolean);			var				startP: Ptr;				lengthofblock: longint;		begin			zapped := false;			LockHandle(adjustH, oldstate1);			startP := startofpackedtree(0, 0, adjustH);			case adjusttype of				adjustmove: 					ShiftPackedTaxaNum(startP, GetTreeHandleSize(adjustH), ist, iend, ibefore);				adjustadd: 					begin						InsertPackedTaxaNum(startP, GetTreeHandleSize(adjustH), ibefore, howmany);						if adjustNumberIfAdd then							SetNumTaxaInPackedTree(adjustH, GetNumTaxaInPackedTree(adjustH) + howmany);					end;				adjustdelete: 					begin						Numtaxaleft := GetNumTaxaInPackedTree(adjustH);						DeletePackedTaxaNum(startP, GetTreeHandleSize(adjustH), ist, iend, lengthofblock, arefixanc, arepolys, numtaxaleft);						if lengthofblock = 0 then							zapped := true						else if (lengthofblock < 8) & (numtaxaleft < mintaxain) then							zapped := true						else							begin								SetNumTaxaInPackedTree(adjustH, numtaxaleft);								HUnLock(adjustH);								SetHandleSize(adjustH, GetHandleSize(adjustH) - GetTreeHandleSize(adjustH) + (lengthofblock * 2));								HLock(adjustH);								if not arepolys then									Bitclr(ptr(getmaster(adjustH)), polytomybit);								if not arefixanc then									Bitclr(ptr(getmaster(adjustH)), fixancbit);								Bitclr(ptr(getmaster(adjustH)), charfixedbit);							end;					end;				otherwise					;			end;			ResetHandle(adjustH, oldstate1);		end;	begin		if UserLinks[datafileChain] > 0 then			dirtyfile := true;		if UserLinks[treefileChain] > 0 then			dirtytreefile := true;		for theChain := datafilechain to treefilechain do			for j := EndUserLink(theChain) downto StartUserLink(theChain) do  {have to go in reverse as otherwise}																							{j will be incorrect if trees zapped}				begin					LockHandle(strCHUNKs[theChain], oldstate2);					packH := HdlPtr(GetMaster(strCHUNKs[theChain]) + HdlSize * ord4(j))^;					doAdjustTaxInTrees(packH, zapped, false);					if zapped then						begin							RemoveLink(theChain, j);							NewError(39, 0);						end;					ResetHandle(strCHUNKs[theChain], oldstate2);				end;		if GetTreeHandleSize(treedataH) > 2 then			begin{treechanged := true;}				EmptyAssociatedTreeHandles;				doAdjustTaxInTrees(treedataH, zapped, true);				if zapped then					begin						treeinmemory := false;						LinkNumber[treechain] := 0;						if UserLinks[treechain] <> 0 then							begin								GetLink(treechain, 0, treedataH, true);								NewError(40, 0);							end						else							begin								StringToH(' ', treedataH);  {v4: make this a function like ZapCurrentTree}								NewError(350, 0);								dirtytree := false;								dirtyfix := false;							end;					end;			end;		if treeopen then			begin				case adjusttype of					adjustmove: 						ShiftTaxaInCurrentTree(ist, iend, ibefore);					adjustdelete:						DestroyTaxaInCurrentTree(ist,iend);					otherwise						;				end;			end;	end;{||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}{----------------------------------------------------------------------------}	procedure FillTaxa (itstart, itend: integer; setNewlyInserted: boolean);		var			TaxonHdl: thdl;			it, ir: integer;	begin		for it := itstart to itend do			begin				TaxonHdl := gettaxonHdl(it);				taxonHdl^^.name := ' ';				taxonHdl^^.deleted := false;				taxonHdl^^.footText := false;				taxonHdl^^.footPict := false;				taxonHdl^^.taxSet := false;				taxonHdl^^.newlyInserted := setNewlyInserted;				taxonHdl^^.extra := false;				taxonHdl^^.infoSelected := false;				taxonHdl^^.otherSelected := false;				taxonHdl^^.isItalic := false;				taxonHdl^^.newTaxon := false;				taxonHdl^^.freqP := nil;				for ir := 1 to mncontinuous do					begin						taxonHdl^^.contsmin[ir] := -1;						taxonHdl^^.contsmax[ir] := -1;					end;				taxonHdl^^.N := nil;   {put here so easier to catch bugs}			end;	end;{----------------------------------------------------------------------------}	function NewTaxonMemory (newtaxa: longint): longint;	begin		NewTaxonMemory := ord4(newtaxa) * (sizeof(ttype) + tcb * ord4(numchars));	end;{----------------------------------------------------------------------------}	procedure AddNewTaxa (howmany: integer; fillwithgap: boolean);		var			it: integer;			amountneeded: longint;	begin		if not EnoughMemory(NewTaxonMemory(howmany), amountneeded) then			begin				badmemory := true;				InstantErrorPlus(347, concat(StringFromNum(amountneeded div 1024), 'K'));				Exit(AddNewTaxa);			end;		TurnOffInfoEditing(taxinfo);		AddCHUNKs(taxonCHUNKs, howmany, sizeof(ttype));		AddCHUNKs(taxstsCHUNKs, howmany, tcb * ord4(numchars));		FillTaxa(numtaxa + 1, numtaxa + howmany,true);		for it := numtaxa + 1 to numtaxa + howmany do			SetAsNewTaxon(it);		FillTaxSts(1, numchars, numtaxa + 1, numtaxa + howmany, fillwithgap);		MunchSets(taxSetChain, numtaxa + 1, 0, howmany, exb, 0, 0);{    AdjustTaxInTrees(0, 0, numtaxa, howmany, adjustadd); not needed since new taxa always "added" to end}		numtaxa := numtaxa + howmany;		dirtytaxnames := true;		AdjustStuff(false);		CheckFullEditorRedrawTaxaChanged;	end;{----------------------------------------------------------------------------}	procedure InsertNewTaxa (howmany, where: integer; fillwithgap: boolean);		var			theFoot, it: integer;			amountneeded: longint;	begin		if not EnoughMemory(NewTaxonMemory(howmany), amountneeded) then			begin				badmemory := true;				InstantErrorPlus(347, concat(StringFromNum(amountneeded div 1024), 'K'));				Exit(InsertNewTaxa);			end;		TurnOffInfoEditing(taxinfo);		for theFoot := 0 to maxFootType do			ShiftFeet(theFoot, where, numtaxa, howmany, 0, 0, 0, false);		if editorPaintReferenceTaxon > 1 then			if editorPaintReferenceTaxon >= where then				begin					editorPaintReferenceTaxon := editorPaintReferenceTaxon + howmany;					InvalidateWindow(toolPaletteWindow[editorTools], false);				end;		InsertCHUNKs(taxonCHUNKs, where, howmany, sizeof(ttype));		InsertCHUNKs(taxstsCHUNKs, where, howmany, tcb * ord4(numchars));		FillTaxa(where, where + howmany - 1, true);		for it := where to where + howmany - 1 do			SetAsNewTaxon(it);		FillTaxSts(1, numchars, where, where + howmany - 1, fillwithgap);		MunchSets(taxSetChain, where, 0, howmany, exb, 0, 0);		AdjustTaxInTrees(0, 0, where - 1, howmany, adjustadd);		numtaxa := numtaxa + howmany;		dirtytaxnames := true;		AdjustStuff(false);		CheckFullEditorRedrawTaxaChanged;	end;{----------------------------------------------------------------------------}	procedure MoveTaxa (itstart, itend, too: integer);		var			theFoot: integer;	begin{this is confusing, as if too < itstart, too is the number of the taxon immediately before}{which the taxa are to be moved; however, if too > itstart, then too is that taxon immediately after}{with the taxa are to be moved}		if not ((too >= itstart) and (too <= itend)) then			begin				TurnOffInfoEditing(taxinfo);				if too < itstart then					begin						if  editorPaintReferenceTaxon>= too then							if editorPaintReferenceTaxon < itstart then								editorPaintReferenceTaxon := editorPaintReferenceTaxon + (itend - itstart + 1)							else if (editorPaintReferenceTaxon >= itstart) and (editorPaintReferenceTaxon <= itend) then								editorPaintReferenceTaxon := too + (editorPaintReferenceTaxon - itstart);						for theFoot := 0 to maxFootType do							ShiftFeet(theFoot, itstart, itend, -(itstart - too), too, itstart - 1, itend - itstart + 1, false);						AdjustTaxInTrees(itstart, itend, too - 1, 0, adjustmove);					end				else					begin						if editorPaintReferenceTaxon <= too then							if editorPaintReferenceTaxon > itend then								editorPaintReferenceTaxon := editorPaintReferenceTaxon - (itend - itstart + 1)							else if (editorPaintReferenceTaxon >= itstart) and (editorPaintReferenceTaxon <= itend) then								editorPaintReferenceTaxon := too + (editorPaintReferenceTaxon - itstart) - (itend - itstart);						for theFoot := 0 to maxFootType do							ShiftFeet(theFoot, itstart, itend, too - itend, itend + 1, too, -(itend - itstart + 1), false);						AdjustTaxInTrees(itstart, itend, too, 0, adjustmove);  {has to be too, not too-1; see note above}					end;				MoveHandlePieces(taxonCHUNKs, HdlSize, itstart, itend, too, 0);				MoveHandlePieces(taxstsCHUNKs, HdlSize, itstart, itend, too, 0);				MunchSets(taxSetChain, too, 0, 0, exb, itstart, itend);				CalcEditorMatrixRect;				datachanged := true;				dirtymaxst := true;				InvalidateWindow(toolPaletteWindow[editorTools], false);				if infoOpen[taxinfo] & CanUpdateWindow(infoWindow[taxinfo]) then					InvalidateWindow(infoWindow[taxinfo], true);				if treeopen then					begin						InvalidateWindow(tlegwindow,false);						godraw:= true;						FullTreeOnScreenGoList;					end;				SetLastChangeInEditor(lastChangeCantUndo);			end;	end;{----------------------------------------------------------------------------}	procedure DestroyTaxa (itstart, itend: integer; setCantUndo,eraseInfoWindows: boolean);		var			quantity: integer;			theFoot, it: integer;	begin		TurnOffInfoEditing(taxinfo);		if setCantUndo then 			SetLastChangeInEditor(lastChangeCantUndo);		quantity := itend - itstart + 1;		for it := itstart to itend do			ZapPointer(getTaxonHdl(it)^^.freqP);		for theFoot := 0 to maxFootType do			begin				DestroyFeet(theFoot, itstart, itend, false);				ShiftFeet(theFoot, itend + 1, numtaxa, -quantity, 0, 0, 0, false);			end;		DeleteCHUNKs(taxonCHUNKs, itstart, quantity);		DeleteCHUNKs(taxstsCHUNKs, itstart, quantity);		AdjustTaxInTrees(itstart, itend, 0, quantity, adjustdelete);		MunchSets(taxSetChain, itstart, quantity, 0, exb, 0, 0);		numtaxa := numtaxa - quantity;		infoDirtyNames[taxinfo] := true;		if paintBucketPaint = [] then			if editorPaintReferenceTaxon >itend then 				begin					editorPaintReferenceTaxon := editorPaintReferenceTaxon-quantity;					InvalidateWindow(toolPaletteWindow[editorTools], false);				end			else if editorPaintReferenceTaxon >= itstart then 				begin					editorPaintReferenceTaxon := 1;					paintBucketPaint := [MSl, GAl];					InvalidateWindow(toolPaletteWindow[editorTools], false);				end;		AdjustStuff(eraseInfoWindows);		CheckFullEditorRedrawTaxaChanged;	end;{----------------------------------------------------------------------------}	function FullMemoryNeeded (ntax, nchar: longint): longint;		var			memoryNeeded: longint;	begin		memoryNeeded := longint(SizeOf(ttype) + hdlsize * 2 + 6) * longint(ntax);   {taxonHdl Storage}		memoryNeeded := memoryNeeded + (hdlsize * 2 + 6) * longint(ntax);   {taxonStsHandle overhead}		memoryNeeded := memoryNeeded + longint(ntax) * longint(nchar) * numbytes;  {raw data}		memoryNeeded := memoryNeeded + longint(chlb*2 + chsb + chpb + chtb * 2 + 2 * chwb + 2*chpartb) * ord4(nchar); {chwtH etc.}		memoryNeeded := memoryNeeded + longint(SizeOf(chtype) + hdlsize * 2 + 6) * longint(nchar);   {charHdl Storage}		memoryNeeded := memoryNeeded + 2 * longint(nchar) * (hdlsize * 2 + 6);  {stateNamesHandles overhead}		memoryNeeded := memoryNeeded + 2 * longint(nchar) * 4;  {stateNamesHandles storage}{now, memory for wtset, typeset, etc.}		memoryNeeded := memoryNeeded + longint(nchar) * 68 + longint(ntax)* 16 + 32768; {buffer}		{don't exactly know why 42 is what is needed in the above line; I determined it emprically}				FullMemoryNeeded := memoryNeeded;	end;{----------------------------------------------------------------------------}	procedure EmptyTaxonCharacterMemory;	var it: integer;	begin		if taxmemorymade then			begin				for it := 1 to numtaxa do					ZapPointer(getTaxonHdl(it)^^.freqP);				DeleteCHUNKs(taxonCHUNKs, 1, numtaxa);				DeleteCHUNKs(taxstsCHUNKs, 1, numtaxa);				if charmemorymade then					begin						DeleteCHUNKs(chCHUNKs, 1, numchars);						DeleteCHUNKs(statenamesCHUNKs, 1, numchars);						DeleteCHUNKs(statenamesCHUNKsBU, 1, numchars);					end				else					begin						DeleteCHUNKs(chCHUNKs, 1, 1);						DeleteCHUNKs(statenamesCHUNKs, 1, 1);						DeleteCHUNKs(statenamesCHUNKsBU, 1, 1);					end;			end;		SetHandleSize(taxonCHUNKs, 2);		SetHandleSize(taxstsCHUNKs, 2);		SetHandleSize(chCHUNKs, 2);		SetHandleSize(statenamesCHUNKs, 2);		SetHandleSize(statenamesCHUNKsBU, 2);	end;{----------------------------------------------------------------------------}	procedure CleanUpFailedTaxonCharacterMemory;	begin		NewError(431,0);		errorFlag := true;		EmptyTaxonCharacterMemory;	end;{----------------------------------------------------------------------------}{||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}	function CreateTaxonCharMemory: boolean;{initial creation of taxon and character memory}		var			ic, it: integer;			dhp, dhp2: HdlPtr;			dhdl: Handle;			taxonHdlPtr: ThdlPtr;			taxstsHdlPtr: HdlPtr;			charHdlPtr: chHdlPtr;			oldstate1, oldstate2, oldstate3: SignedByte;	begin		CreateTaxonCharMemory := false;		if numbytes = 2 then			SetCursID(memory16)		else			SetCursID(memory32);		UnLockHandle(taxstsCHUNKs, oldstate1);		UnLockHandle(taxonCHUNKs, oldstate2);		if not SetHandleSizeSuccessful(taxstsCHUNKs, hdlsize * ord4(numtaxa)) then 			Exit(CreateTaxonCharMemory);		if not SetHandleSizeSuccessful(taxonCHUNKs, hdlsize *  ord4(numtaxa)) then 			Exit(CreateTaxonCharMemory); 					HLock(taxstsCHUNKs);		HLock(taxonCHUNKs);		taxstsHdlPtr := HdlPtr(GetMaster(taxstsCHUNKs));		taxonHdlPtr := THdlPtr(GetMaster(taxonCHUNKs));		for it := 1 to numtaxa do			begin				taxstsHdlPtr^ := NewHandle(tcB * ord4(numchars));				taxstsHdlPtr := HdlPtr(ord4(taxstsHdlPtr) + HdlSize);				taxonHdlptr^ := THdl(NewHandle(Sizeof(ttype)));				taxonHdlptr := THdlPtr(ord4(taxonHdlptr) + HdlSize);			end;		ResetHandle(taxstsCHUNKs, oldstate1);		ResetHandle(taxonCHUNKs, oldstate2);		taxmemorymade := not errorFlag;		FillTaxa(1, numtaxa, false);		FillTaxSts(1, numchars, 1, numtaxa, false);		if not SetHandleSizeSuccessful(chLenH, chlb * ord4(numchars)) then Exit(CreateTaxonCharMemory);		if not SetHandleSizeSuccessful(chstoretypH, chtb * ord4(numchars)) then Exit(CreateTaxonCharMemory);		if not SetHandleSizeSuccessful(chtypH, chtb * ord4(numchars)) then Exit(CreateTaxonCharMemory);		if not SetHandleSizeSuccessful(chwtH, chwb * ord4(numchars)) then Exit(CreateTaxonCharMemory);		if not SetHandleSizeSuccessful(chstorewtH, chwb * ord4(numchars)) then Exit(CreateTaxonCharMemory);		if not SetHandleSizeSuccessful(chPartitionH, chpartb * ord4(numchars)) then Exit(CreateTaxonCharMemory);		if not SetHandleSizeSuccessful(chstorePartitionH, chpartb * ord4(numchars)) then Exit(CreateTaxonCharMemory);		if not SetHandleSizeSuccessful(chpLH, chpb * ord4(numchars)) then Exit(CreateTaxonCharMemory);		if not SetHandleSizeSuccessful(chstatesH, chsb * ord4(numchars)) then Exit(CreateTaxonCharMemory);		UnLockHandle(chCHUNKs, oldstate1);		UnLockHandle(statenamesCHUNKs, oldstate2);		UnLockHandle(statenamesCHUNKsBU, oldstate3);		if not SetHandleSizeSuccessful(chCHUNKs, hdlsize * ord4(numchars)) then Exit(CreateTaxonCharMemory);		if not SetHandleSizeSuccessful(statenamesCHUNKs, hdlsize * ord4(numchars)) then Exit(CreateTaxonCharMemory);		if not SetHandleSizeSuccessful(statenamesCHUNKsBU, hdlsize * ord4(numchars)) then Exit(CreateTaxonCharMemory);		HLock(chCHUNKs);		HLock(statenamesCHUNKs);		HLock(statenamesCHUNKsBU);		charHdlptr := chHdlPtr(GetMaster(chCHUNKs));		dhp := HdlPtr(GetMaster(statenamesCHUNKs));		dhp2 := HdlPtr(GetMaster(statenamesCHUNKsBU));		for ic := 1 to numchars do			begin				charHdlptr^ := chHdl(NewHandle(Sizeof(chtype)));				dhp^ := NewHandle(2);				dhp2^ := NewHandle(2);				charHdlptr := chHdlPtr(ord4(charHdlptr) + HdlSize);				dhp := HdlPtr(ord4(dhp) + HdlSize);				dhp2 := HdlPtr(ord4(dhp2) + HdlSize);			end;		ResetHandle(chCHUNKs, oldstate1);		ResetHandle(statenamesCHUNKs, oldstate2);		ResetHandle(statenamesCHUNKsBU, oldstate3);		FillCharacters(1, numchars, false);		charmemorymade := not ErrorFlag;		editorTotalRows := numtaxa;		editorTotalColumns := numchars;		numcharin := numchars;		numtaxain := numtaxa;		ntscreen := numtaxa;		oldnumtaxain := numtaxa;		SetControlMaximumLong(chlegScroll, numchars);		SetControlMaximumLong(statesWindowHScroll,numchars);		FillDefaultLinks;				CreateTaxonCharMemory := true;	end;{-----------------------------------------------------------------------------}	procedure ContractData;		var			H, dhdl: Handle;			oldHp: HdlPtr;			it: integer;			SP: SetPointer15;			lookoutforDollo, chopdollo, looknomore: boolean;			oldState: SignedByte;		procedure DoDolloContract (SP: setPointer15);			var				ic: integer;		begin			for ic := 1 to numchars do				begin					if not looknomore then						if typeofchar(ic) = dollo then							if sp^ * [3..maxstate] <> [] then								begin									if chopdollo | CWarning('Some Dollo characters with states > 2, too high for current data format.  Do you want to cut out such states?', 'Cut out', 'Leave as is') then										begin											sp^ := sp^ * [0..2, 10, 11, 12, 13, 15]; {v4: these are two byte highbits}											chopdollo := true;											if SP^ * [0..9] = [] then												SP^ := SP^ + [15];										end									else										looknomore := true;								end;					SP := SetPointer15(ord4(SP) + tcb);				end;		end;	begin		SetCursID(memory16);		H := NewHandle(tcb * ord4(numchars));		lookoutforDollo := not nucleotides and anytype([dollo]);		LockHandle(TaxstsCHUNKs, oldState);		HLock(H);		chopdollo := false;		looknomore := false;		for it := 1 to numtaxa do			begin				oldHp := HdlPtr(GetMaster(TaxstsCHUNKs) + HdlSize * (it - 1));				dhdl := oldHp^;				Hlock(dhdl);				contractCHBlock(maxstate, Pointer(GetMaster(H)), Pointer(GetMaster(dhdl)), numchars);	{!!! dest before source}				SP := SetPointer15(GetMaster(H));				if lookoutfordollo then  {otherwise don't need to do more than contractCHBlock}					DoDolloContract(SP);				HUnlock(dhdl);				CopyHandles(H, dhdl);				oldHp^ := dhdl;			end;		ResetHandle(TaxstsCHUNKs, oldState);		HUnLock(H);		ZapHandle(H);		ReCalcMaxstAndStates(1,numchars);		InvalidateWindow(editorWindow, true);	end;{-----------------------------------------------------------------------------}	procedure ExpandData;		var			H: Handle;			oldHp: HdlPtr;			it: integer;			oldState: SignedByte;	begin		SetCursID(memory32);		H := NewHandle(tcb * ord4(numchars));		LockHandle(TaxstsCHUNKs, oldState);		HLock(H);		for it := 1 to numtaxa do			begin				oldHp := HdlPtr(GetMaster(TaxstsCHUNKs) + HdlSize * (it - 1));				ExpandCHBlock(Pointer(GetMaster(H)), Pointer(GetMaster(oldHp^)), numchars);	{!!! dest before source}				CopyHandles(H, oldHp^);			end;		ResetHandle(TaxstsCHUNKs, oldState);		ExpandCHBlock(Pointer(GetMaster(H)), Pointer(GetMaster(chstatesH)), numchars);	{!!! dest before source}		CopyHandles(H, chstatesH);		HUnlock(H);		ZapHandle(H);	end;{-----------------------------------------------------------------------------}	procedure DeleteNewlyInsertedCharacters;	var ic: integer;	begin		ic := numchars;		while ic>=1 do			begin				if CharIsNewlyInserted(ic) then					DestroyCharacters(ic,ic,true,false,false,false);				ic := ic-1;			end;		InvalidateInfoWindow(charinfo);		InvalidateInfoWindow(taxinfo);	end;{-----------------------------------------------------------------------------}	procedure DeleteNewlyInsertedTaxa;	var it: integer;	begin		it := numtaxa;		while it>=1 do			begin				if TaxonIsNewlyInserted(it) then					DestroyTaxa(it,it,false,false);				it := it-1;			end;		InvalidateInfoWindow(charinfo);		InvalidateInfoWindow(taxinfo);	end;{----------------------------------------------------------------------------}	procedure LoadRowColumn;	begin	end;end.