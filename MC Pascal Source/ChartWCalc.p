unit ChartWCalc;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, BoxUtil, CharUtil, typeutil, ChartWUtil, ChartWWrite, ChartWProbStepsCalc, ProbReconstruct, Thermos, TreeMover, ChartWCST, PolyCalc, Prohibitions, ChartWChangesCalc, SymbolsNames, SetStates, CHUNK, WriteUtil, ReadWriteUtil, ReadUtil, ReadTreeFile, StrUtil, MenuUtil, TreeUtil, Count, RandomTree, TreeCycle, TaxonCHUtil, TraceAllChangesCalc, equivocal;	procedure CalcChartData (isrecalc: boolean);{$SETC COMPAREALL=FALSE}{еееееееееееееееееееееее}implementation {е$S ChartWCalc}	var		prevendtree: longint;		treeRandomSeed: longint;{-----------------------------------------------------------------------------}	function CharLength (ic: integer; weighted: boolean): longint;{note that weighting done everywhere EXCEPT if traced character only}		var			clen: longint;	begin		clen := CharSteps(ic);		if weighted then			clen := clen * CharWeight(ic);		if not ((CIRIData or CWTraced) and (CWChart = CWCSteps)) then{above restriction is to make sure that in positionchart cycling with CWCSteps }{and ci, ri, rc, the charsteps called there don't return unnecessarily inflated charsteps}			if realtypes & not typeisreal(typeofchar(ic)) then {& ((CWChart <> CWCSteps) or ((sequencechart or positionchart) and not CWTraced))}  	{}				clen := clen * typeinflate;		CharLength := clen;	end;{-----------------------------------------------------------------------------}	function GetIndex (ic, toshow: integer): double;		var			charHdl: chHdl;			index: double;	begin		charHdl := getchHdl(ic);		case toshow of			CWStepsCI: 				index := (charHdl^^.ci);			CWStepsRI: 				index := (charHdl^^.ri);			CWStepsRC: 				index := (charHdl^^.ri) * (charHdl^^.ci);			otherwise				;		end;		GetIndex := index;	end;{-----------------------------------------------------------------------------}	function GetStepsCIRIclen (ic: integer; weighted: boolean): longint;		var			clen: longint;	begin		case CWStepsShow of			CWStepsSteps: 				clen := CharLength(ic, weighted);			otherwise				clen := RoundValue(100 * GetIndex(ic, CWStepsShow));		end;		GetStepsCIRIclen := clen;	end;{-----------------------------------------------------------------------------}	function CumulativeCLEN (totSteps, totmin, totmax: longint): longint;{calculates CI,RI,RC over a range of characters; used in SequenceSteps and PositionSteps}		var			clen: longint;	begin		if CWStepsShow = CWStepsCI then			if totSteps = 0 then				clen := 0			else				clen := RoundValue(100.0 * totMin / totSTeps)		else if CWStepsShow = CWStepsRI then			if (totMax - totMin) = 0 then				clen := 0			else				clen := RoundValue(100.0 * ((totMax - totSteps) / (totMax - totMin)))		else if ((totMax - totMin) = 0) or (totSteps = 0) then			clen := 0		else			clen := RoundValue(100.0 * ((totMax - totSteps) / (totMax - totMin)) * totMin / totSTeps);		CumulativeCLEN := clen;	end;{====================================================================}{|||||||||||||||||||||||||||||   Compare ||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}{-----------------------------------------------------------------------------}	procedure Compare2TreeFiles;		label			1;		type			twoints = array[1..2] of integer;		var			j, ic, oldtreechain, ntrees: integer;			dif12, dif21: longint;			H, packH: Handle;			status, querycyclepoly: boolean;			ds: str255;			CLwhichmin, CLwhichmax: twoints;			theDialog: DialogPtr;			tempP: WindowPtr;	begin{v4: what about dealing with stored, but unsaved trees? what about random trees}		if (dirtyfile & EqualFileSpecs(FDI^[dataFileFDI].fs,FDI^[extraTreeFile1FDI].fs)) | (dirtytreefile & treefile & EqualFileSpecs(FDI^[treeFileFDI].fs,FDI^[extraTreeFile1FDI].fs)) then			NewError(354, 0)		else if (dirtyfile & EqualFileSpecs(FDI^[dataFileFDI].fs,FDI^[extraTreeFile2FDI].fs)) | (dirtytreefile & treefile & EqualFileSpecs(FDI^[treeFileFDI].fs,FDI^[extraTreeFile2FDI].fs)) then			NewError(354, 0);		startreadtree := 1;		endreadtree := -1;		CLwhichmin[1] := CLmin1;   {these 4 kinds are used as temporary holders of information}		CLwhichmin[2] := CLmin2;		CLwhichmax[1] := CLmax1;		CLwhichmax[2] := CLmax2;		minChartLinearcat := 1;		maxChartLinearcat := numchars;		for j := 0 to 3 do			begin				AddLinearChart(j, numchars, false, minChartLinearCat);				if ErrorFlag or pleaseNoMoreChart then					begin						pleaseOffChart := errorflag;						Exit(Compare2TreeFiles);					end;			end;		packH := NewHandle(0);		if treeopen then			StoreCurrentTree(H);		blastpolytomies := CWBlastPolyT;		querycyclepoly := true;		for j := 1 to 2 do			if not pleaseOffChart then				begin					ntrees := 0;					DisableWindowUpdates(chartwindow);					DisableWindowUpdates(treewindow);					DisableWindowUpdates(tlegwindow);					DisableWindowUpdates(chlegwindow);					if j = 1 then						StartThermo(theDialog, tempP, 0, mcFileLength, 'Chart: Examining first tree file', 'percent', true)					else						StartThermo(theDialog, tempP, 0, mcFileLength, 'Chart: Examining second tree file', 'percent', true);					if StartFileTrees(j, ds, oldtreechain, packH) then						while not EndOfBlock(ds) and (fpos < mcFileLength) do							begin								if CheckIfAbortedChart then									if checkChartStop(2) then										goto 1;								if GetFileTree(ds, packH, numCWTrees) then									begin										BuildTree(packH, 0, status, querycyclepoly, false, not Anytype([irreversible, fisher, dollo, usedef]), not AnyType([dollo, usedef]));										if treemakingfailed then											begin												Pleaseoffchart := true;												NewError(380, 0);												errorflag := true;												leave;											end;										if status then											begin												ntrees := ntrees + 1;												SetTaxaDnSts(1, numchars);												if not CountTree then													NewError(310, 0);												for ic := 1 to numchars do													if CharIncluded(ic) then														CheckChartMinMax(CLwhichmin[j], CLwhichmax[j], (ic - 1), CharLength(ic, true));											end										else											NewError(35, 0);									end;								UpdateThermo(theDialog, 0, fpos, mcFileLength,true);							end;1:					EndFileTrees(oldtreechain, packH);					EndThermo(theDialog, tempP, true);					if ntrees <= 0 then						Errorflag := true;					if errorflag then						leave;				end;  {for j = 1 to 2}		blastpolytomies := false;		querycyclepoly := false;		if not errorflag then			begin				for j := 1 to 2 do					for ic := 1 to numchars do						if not CharIncluded(ic) then   {initialize excluded characters}							CheckChartMinMax(CLwhichmin[j], CLwhichmax[j], (ic - 1), 0);				for j := 0 to numIntervals[CLmin] - 1 do					begin						dif12 := GetChartLinearData(CLmin1, j) - GetChartLinearData(CLmax2, j);						dif21 := GetChartLinearData(CLmin2, j) - GetChartLinearData(CLmax1, j);						if dif12 > 0 then							SetChartLinearData(CLstandard, j, dif12)						else if dif21 > 0 then							SetChartLinearData(CLstandard, j, -dif21)						else							SetChartLinearData(CLstandard, j, 0);					end			end		else			begin				pleaseOffChart := true;				NewError(349, 0);			end;		if treeopen then			RestoreCurrentTree(H, true);		genericSetPort(ChartWindow);		ZapHandle(packH);	end;{-----------------------------------------------------------------------------}	procedure Calc2TreeCompare;		label			1;		var			H: Handle;			clen: longint;			j, starttree, endtree: longint;			status, querycyclepoly: boolean;	begin		if treeopen then			StoreCurrentTree(H);		querycyclepoly := false;		minChartLinearcat := 1;		maxChartLinearcat := numchars;		AddLinearChart(CLkind, numchars, false, minChartLinearCat);		if ErrorFlag or pleaseNoMoreChart then			begin				pleaseOffChart := ErrorFlag;				Exit(Calc2TreeCompare);			end;		BuildTree(nil, twotrees[0], status, querycyclepoly, false, not Anytype([irreversible, fisher, dollo, usedef]), not AnyType([dollo, usedef]));		if treemakingfailed then			begin				Pleaseoffchart := true;				NewError(380, 0);				errorflag := true;				goto 1;			end;		if status then			begin				SetTaxaDnsts(1, numchars);				if not CountTree then					NewError(310, 0);				for j := 1 to numchars do					if charincluded(j) then						SumChartLinearData(CLkind, (j - 1), CharLength(j, true));			end		else			begin				PleaseOffChart := true;				NewError(35, 0);				goto 1;			end;		BuildTree(nil, twotrees[1], status, querycyclepoly, false, not Anytype([irreversible, fisher, dollo, usedef]), not AnyType([dollo, usedef]));		if treemakingfailed then			begin				Pleaseoffchart := true;				NewError(380, 0);				errorflag := true;				goto 1;			end;		if status then			begin				SetTaxaDnsts(1, numchars);				if not CountTree then					NewError(310, 0);				for j := 1 to numchars do					if charincluded(j) then						SubtractChartLinearData(CLkind, (j - 1), CharLength(j, true));			end		else			begin				NewError(35, 0);				PleaseOffChart := true;			end;1:		if treeopen then			RestoreCurrentTree(H, true);		genericSetPort(ChartWindow);	end;{$IFC COMPAREALL}{-----------------------------------------------------------------------------}	function BinomialProb (r1, r2: integer): double;  {v4: note in RandomTree that I have some combinatorial stuff}{that also calculates probabilities, some I believe are binomial.  Do we save code by condensing??}		var			j, X: integer;			prob, prob2, XF, NXF: extended;			n, r: integer;	begin		n := r1 + r2;		if r1 > r2 then			r := r1		else			r := r2;		prob := 1.0;		for j := 1 to n do			prob := prob * 0.5 * j;		prob2 := 0.0;		for X := r to n do			begin				XF := 1.0;				for j := 1 to x do					XF := XF * j;				nXF := 1.0;				for j := 1 to n - x do					nXF := nXF * j;				prob2 := prob2 + 1 / (XF * nXF);			end;		BinomialProb := prob * prob2;	end;{-----------------------------------------------------------------------------}	procedure CompareFirstTreeToRest;		var			j, k: integer;			posWeighted, positive, negWeighted, negative, theData: longint;			prob: double;			ds: str255;	begin		putToken('tree');  {v4: ChartWrite...}		putTab;		putToken('positive');		putTab;		putToken('negative');		putTab;		putToken('probability');		putTab;		putToken('posWeighted');		putTab;		putToken('negWeighted');		putReturn;		twotrees[0] := StartUserLink(treechain);		for j := StartUserLink(treechain) + 1 to EndUserLink(treechain) do			begin				minChartLinearcat := -1;				maxChartLinearcat := -1;				for k := 0 to numCLkinds do					numIntervals[k] := 0;				ZeroChartData;				twotrees[1] := j;				Calc2TreeCompare;				putSimpleLongint(j);				putTab;				positive := 0;				posWeighted := 0;				negative := 0;				negWeighted := 0;				for k := 0 to numIntervals[CLkind] - 1 do					begin						theData := GetChartLinearData(CLkind, k);						if theData > 0 then							begin								posWeighted := posWeighted + theData;								positive := positive + 1;							end;						if theData < 0 then							begin								negWeighted := negWeighted + theData;								negative := negative + 1;							end;					end;				putSimpleLongint(positive);				putTab;				putSimpleLongint(negative);				putTab;				RealTostring(BinomialProb(positive, negative), ds, 1000000, 2, true);				putLegalToken(ds);				putTab;				putSimpleLongint(posWeighted);				putTab;				putSimpleLongint(negWeighted);				putReturn;			end;	end;{$ENDC}{|||||||||||||||||||||||||||||||||||||   States    ||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	procedure CalcStateFreq (N: Nptr);		type			basefreqtype = array[0..absmaxstate] of longint;		var			TaxonHdl: thdl;			it: integer;			k: longint;			basefreq: basefreqtype;	begin		minChartLinearCat := 0;{v4: this shouldn't be done if file is unchanged since it was last done}		if CWTraced then			CalcStateFrequencies(1, numtaxa, i, i, MOS)  {ok to have MOS as only over observed terminal taxa}		else			CalcStateFrequencies(1, numtaxa, 1, numchars, MOS);		for k := 0 to maxstate do			basefreq[k] := 0;		for it := 1 to numtaxa do			if TaxonInTree(it) then				begin					TaxonHdl := getTaxonHdl(it);					taxonHdl^^.dataPoints := 0;					for k := 0 to MOS do						begin							basefreq[k] := basefreq[k] + taxonHdl^^.tipNumbers[k];							taxonHdl^^.dataPoints := taxonHdl^^.dataPoints + taxonHdl^^.tipNumbers[k];						end;				end;{$IFC FALSE}		if datatype = standard then			begin				for k := MOS downto 0 do					if basefreq[k] > 0 then						leave;				maxChartLinearcat := k;			end		else			maxChartLinearcat := maxstate;{$ENDC}		maxChartLinearcat := numIntervals[CLkind] - 1;		for k := 0 to numIntervals[CLkind] - 1 do			SetChartLinearData(CLkind, k, basefreq[k]);	end;{|||||||||||||||||||||||||||||||||||||   CWCSteps    ||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	procedure StepsInTree;{this does CWSteps w/o sequencechart or positionchart, for only the tree on screen}		var			ic: integer;			theDialog: DialogPtr;			tempP: WindowPtr;			minch, maxch: integer;			charHdl: chHdl;			aborted: boolean;			minminCLC, minmaxCLC, maxminCLC, maxmaxCLC, clen: longint;	begin		case CWStepsShow of			CWStepsSteps: 				for ic := 1 to numchars do					if charincluded(ic) then						begin							AddToChartLinear(CLkind, CharLength(ic, true), minChartLinearCat, maxChartLinearCat);							if ErrorFlag or pleaseNoMoreChart then								Exit(StepsInTree);						end;			CWStepsCI, CWStepsRI, CWStepsRC: 				begin					maxChartLinearcat := 100;					minChartLinearCat := 0;					AddLinearChart(CLkind, 101, false, minChartLinearCat);					if ErrorFlag or pleaseNoMoreChart then						begin							pleaseOffChart := ErrorFlag;							Exit(StepsInTree);						end;					numCWchars := 0;					for ic := 1 to numchars do						if charincluded(ic) & MinMaxLenLegalChar(ic, minlength) & (CharLength(ic, false) <> 0) & ((CWStepsShow = CWStepsCI) | MinMaxLenLegalChar(ic, maxlength)) then							begin								clen := GetStepsCIRIclen(ic, false);  {passed false as irrelevant as no weighting for CI, RI, RC}								SumChartLinearData(CLkind, clen, 1);								numCWchars := numCWchars + 1;							end;				end;			CWStepsChanges: 				begin					maxminCLC := -1;					maxmaxCLC := -1;					minminCLC := -1;					minmaxCLC := -1;					numCWChars := 0;					for ic := 1 to numchars do						if charincluded(ic) then							begin								if CheckIfAbortedChart then									if not CheckIfContinueABit then										leave;								CharHdl := getchhdl(ic);								minch := CharHdl^^.minRestchg;								maxch := CharHdl^^.maxRestchg;								numCWChars := numCWChars + 1;								AddToChartLinear(CLmin, minch, minminCLC, minmaxCLC);								AddToChartLinear(CLmax, maxch, maxminCLC, maxmaxCLC);								if ErrorFlag or pleaseNoMoreChart then									Exit(StepsInTree);							end;					PadMinMaxChart(minminCLC, minmaxCLC, maxminCLC, maxmaxCLC);				end;			otherwise				;		end;	end;{-----------------------------------------------------------------------------}	procedure TracedSteps (var aborted: boolean; var minminCLC, minmaxCLC, maxminCLC, maxmaxCLC: longint);{this does CWSteps w/o sequencechart or positionchart}{this procedure is used for calculations for one of many trees}		var			charHdl: chHdl;			minch, maxch: integer;			clen: longint;			tsts: LargestSetChars;			ir: integer;	begin		aborted := false;		case CWStepsShow of			CWStepsSteps, CWStepsCI, CWStepsRI, CWStepsRC: 				begin					clen := GetStepsCIRIclen(i, false);					if ChartCalcToText then						begin							if CWSTepsShow = CWStepsSteps then								begin									if gettypeHdl(TypeOfChar(i))^^.isreal then										ChartWriteReal(clen / typeinflate, 8, 3)									else										ChartWriteInteger(clen);								end							else								begin									if CWSTepsShow = CWStepsRC then										begin											ChartWriteReal(GetIndex(i, CWStepsCI), 7, 5);											ChartWriteChar(chr(9));											ChartWriteReal(GetIndex(i, CWStepsRI), 7, 5);											ChartWriteChar(chr(9));											ChartWriteReal(GetIndex(i, CWStepsRC), 7, 5);										end									else										ChartWriteReal(GetIndex(i, CWStepsShow), 7, 5);								end;{v4: this is output of root states do this via entirely separate menu item, etc.}{for version 3.1}							if writeRootStates then  {note this is not allowed for char types >= dollo}								if R^.fixanc then									begin										ChartWriteChar(chr(9));										ChartWriteString('(can''t calc.)');									end								else									begin										ChartWriteChar(chr(9));										tsts := getdnstLargest(R, i);										for ir := maxstate downto 0 do											if ir in tsts then												ChartWriteChar(CharOfNum(ir));									end;						end;					AddToChartLinear(CLkind, clen, minChartLinearCat, maxChartLinearCat);					if ErrorFlag or pleaseNoMoreChart then						Exit(TracedSteps);				end;			CWStepsChanges: 				begin					CharHdl := getchhdl(i);					minch := CharHdl^^.minRestchg;					maxch := CharHdl^^.maxRestchg;					AddToChartLinear(CLmin, minch, minminCLC, minmaxCLC);					AddToChartLinear(CLmax, maxch, maxminCLC, maxmaxCLC);					if ErrorFlag or pleaseNoMoreChart then						Exit(TracedSteps);				end;			otherwise				;		end;	end;{-----------------------------------------------------------------------------}	procedure SequenceSteps;{this does CWSteps for sequencechart}		var			charHdl: chHdl;			clen: longint;			oldinterval, theinterval: integer;			minch, maxch: integer;			ic, icw: integer;			aborted: boolean;			theDialog: DialogPtr;			tempP: WindowPtr;			totsteps, totMin, totMax, clentot: longint;	begin		case CWStepsShow of			CWStepsSteps: 				begin					numCWChars := 0;					ic := 0;					repeat						icw := 0;						clentot := 0;						repeat							ic := ic + 1;							icw := icw + 1;							if charincluded(ic) then								begin									if not CharConstant(ic) then										clentot := clentot + GetStepsCIRIclen(ic, true);									numCWchars := numCWchars + 1;								end;						until (ic = numchars) or (icw = catwid);						theinterval := (ic - 1) div catwid;						if ChartCalcToText then							if realwt then								if realtypes then									ChartWriteReal(clentot / typeinflate / wtinflate, 8, 3)								else									ChartWriteReal(clentot / wtinflate, 8, 3)							else if realtypes then								ChartWriteReal(clentot / typeinflate, 8, 3)							else								CheckWriteCalc(clentot);						if CWTrees[CWCSteps] <> CWCurrentTree then							CheckChartMinMax(CLmin, CLmax, theinterval, clentot);						SumChartLinearData(CLStandard, theinterval, clentot);					until ic = numchars;				end;			CWStepsCI, CWStepsRI, CWStepsRC: 				if (catwid = 1) then					begin						numCWChars := 0;						for ic := 1 to numchars do							if charincluded(ic) then								begin									theinterval := (ic - 1) div catwid;									if (MinMaxLenLegalChar(ic, minlength) & (CharLength(ic, true) <> 0) & ((CWSTepsShow = CWSTepsCI) | MinMaxLenLegalChar(ic, maxlength))) then										begin											clen := GetStepsCIRIclen(ic, true);											CheckWriteReal(GetIndex(ic, CWStepsShow),ChartLogSigDigits);											if CWTrees[CWCSteps] <> CWCurrentTree then												CheckChartMinMax(CLmin, CLmax, theinterval, clen);											SumChartLinearData(CLStandard, theinterval, clen);											numCWchars := numCWchars + 1;										end									else			{have to deal with constant and bad CIRIRC characters here}										begin											CheckWriteCalc(0);											if CWTrees[CWCSteps] <> CWCurrentTree then												CheckChartMinMax(CLmin, CLmax, theinterval, 0);											SumChartLinearData(CLStandard, theinterval, 0);										end;								end					end				else {its ci, ri, rc with > 1 catwidth}					begin						numCWchars := 0;						oldinterval := -1;						for ic := 1 to numchars do							begin								theinterval := (ic - 1) div catwid;								if theinterval <> oldinterval then									begin										totSteps := 0;										totMin := 0;										totMax := 0;									end;								if charincluded(ic) then									if (MinMaxLenLegalChar(ic, minlength) & (CharLength(ic, true) <> 0) & ((CWSTepsShow = CWSTepsCI) | MinMaxLenLegalChar(ic, maxlength))) then										begin											charHdl := getchHdl(ic);											totSteps := totSteps + CharLength(ic, true);{$IFC FALSE}											if realtypes and not typeisreal(typeofchar(ic)) then												begin													totMin := totMin + ord4(charHdl^^.minlen) * CharWeight(ic) * typeinflate;													if CWStepsShow in [CWStepsRI, CWStepsRC] then														totMax := totMax + ord4(charHdl^^.maxlen) * CharWeight(ic) * typeinflate;												end											else{$ENDC}												begin													totMin := totMin + ord4(charHdl^^.minlen) * CharWeight(ic);													if CWStepsShow in [CWStepsRI, CWStepsRC] then														totMax := totMax + ord4(charHdl^^.maxlen) * CharWeight(ic);												end;											numCWchars := numCWchars + 1;										end;								oldinterval := theinterval;								if ic div catwid <> oldinterval then									begin										clen := CumulativeCLEN(totSteps, totMin, totMax);										if clen >= 0 then											begin												CheckWriteReal(clen / 100.0,ChartLogSigDigits);												if CWTrees[CWCSteps] <> CWCurrentTree then													CheckChartMinMax(CLmin, CLmax, theinterval, clen);											end;										SumChartLinearData(CLStandard, theinterval, clen);									end;							end;					end;			CWStepsChanges: 				begin					ic := 0;					repeat						icw := 0;						minch := 0;						maxch := 0;						repeat							ic := ic + 1;							icw := icw + 1;							if charincluded(ic) then								begin									if CheckIfAbortedChart then										if not CheckIfContinueABit then											leave;									if not CharConstant(ic) then										begin											CharHdl := getchhdl(ic);											minch := minch + CharHdl^^.minRestchg;											maxch := maxch + CharHdl^^.maxRestchg;										end;									if icw = 0 then										numCWchars := numCWchars + 1;								end;						until (ic = numchars) or (icw = catwid);						theinterval := (ic - 1) div catwid;						CheckWriteCalc(minch);						CheckWriteCalc(maxch);						if CWTrees[CWCSteps] <> CWCurrentTree then							begin								SumChartLinearData(CLminmean, theinterval, minch);								SumChartLinearData(CLmaxmean, theinterval, maxch);								CheckChartMinMax(CLmaxmin, CLmaxmax, theinterval, maxch);								CheckChartMinMax(CLminmin, CLminmax, theinterval, minch);							end						else							begin								SumChartLinearData(CLmin, theinterval, minch);								SumChartLinearData(CLMax, theinterval, maxch);							end;					until ic = numchars;{EndThermo(theDialog, tempP, true);}				end;			otherwise				;		end;	end;{-----------------------------------------------------------------------------}	procedure PositionSteps;{calculates stats for codon positions 0, 1, & 2}		type			codposlongint = array[0..2] of longint;		var			charHdl: chHdl;			j, ic, whichCL, thepos, minch, maxch: integer;			clen: longint;			aborted: boolean;			theDialog: DialogPtr;			tempP: WindowPtr;			codposSteps, codPosMin, codPosMax: codposlongint;	begin		numCWChars := 0;		if CWTrees[CWCSteps] <> CWCurrentTree then			for j := 0 to 2 do				if (CWStepsShow = CWStepsChanges) then					begin						SetChartLinearData(CLextramin, j, 0);						SetChartLinearData(CLextramax, j, 0);					end				else					SetChartLinearData(CLextra, j, 0);		if (CWStepsShow = CWStepsChanges) then			begin			end;		case CWStepsShow of			CWStepsChanges: 				for ic := 1 to numchars do					if CharIncluded(ic) and CodPosSet(ic) and not charconstant(ic) then						begin							numCWChars := numCWChars + 1;							thepos := CharCodPos(ic) - 1;		{Chart linear data is zero based, thus the -1}							if CheckIfAbortedChart then								if not CheckIfContinueABit then									leave;							CharHdl := getchhdl(ic);							minch := CharHdl^^.minRestchg;							maxch := CharHdl^^.maxRestchg;							if CWTrees[CWCSteps] <> CWCurrentTree then								begin									SumChartLinearData(CLextramin, thepos, minch);									SumChartLinearData(CLextramax, thepos, maxch);								end							else								begin									SumChartLinearData(CLmin, thepos, minch);									SumChartLinearData(CLmax, thepos, maxch);								end						end;			CWStepsSteps: 				for ic := 1 to numchars do					if CharIncluded(ic) & not charconstant(ic) & CodPosSet(ic) then						begin							numCWChars := numCWChars + 1;							thepos := CharCodPos(ic) - 1;		{Chart linear data is zero based, thus the -1}							clen := GetStepsCIRIclen(ic, true);							if CWTrees[CWCSteps] <> CWCurrentTree then								SumChartLinearData(CLextra, thepos, clen)							else								SumChartLinearData(CLstandard, thepos, clen);						end;			CWStepsCI, CWStepsRI, CWStepsRC: 				begin					for j := 0 to 2 do						begin							codposSteps[j] := 0;							codposMin[j] := 0;							codposMax[j] := 0;						end;					numCWChars := 0;					for ic := 1 to numchars do						if CharIncluded(ic) & not charconstant(ic) & CodPosSet(ic) then							if (MinMaxLenLegalChar(ic, minlength) & (CharLength(ic, true) <> 0) & ((CWSTepsShow = CWSTepsCI) | MinMaxLenLegalChar(ic, maxlength))) then								begin									charHdl := GetChHdl(ic);									thepos := CharCodPos(ic) - 1;		{Chart linear data is zero based, thus the -1}									codposSteps[thePos] := codposSteps[thePos] + CharLength(ic, true);									codPosMin[thepos] := codPosMin[thepos] + ord4(charHdl^^.minlen) * CharWeight(ic);									if CWStepsShow in [CWStepsRI, CWStepsRC] then										codPosMax[thepos] := codPosMax[thepos] + ord4(charHdl^^.maxlen) * CharWeight(ic);									numCWchars := numCWchars + 1;								end;					for j := 0 to 2 do						begin							clen := CumulativeCLEN(codPosSteps[j], codposMin[j], CodPosMax[j]);							if CWTrees[CWCSteps] <> CWCurrentTree then								SumChartLinearData(CLextra, j, clen)							else								SumChartLinearData(CLstandard, j, clen);						end;				end;			otherwise				;		end;{if (CWStepsShow = CWStepsChanges) then EndThermo(theDialog, tempP, true);}		if CWTrees[CWCSteps] <> CWCurrentTree then			if (CWStepsShow = CWStepsChanges) then				begin					for j := 0 to 2 do						begin							CheckWriteCalc(GetChartLinearData(CLextramin, j));							checkChartMinMax(CLminmin, CLminmax, j, GetChartLinearData(CLextramin, j));							SumChartLinearData(CLminmean, j, GetChartLinearData(CLextramin, j));							CheckWriteCalc(GetChartLinearData(CLextramax, j));							checkChartMinMax(CLmaxmin, CLmaxmax, j, GetChartLinearData(CLextramax, j));							SumChartLinearData(CLmaxmean, j, GetChartLinearData(CLextramax, j));						end;				end			else				for j := 0 to 2 do					begin						CheckWriteCalc(GetChartLinearData(CLextra, j));						checkChartMinMax(CLmin, CLmax, j, GetChartLinearData(CLextra, j));						SumChartLinearData(CLstandard, j, GetChartLinearData(CLextra, j));					end;	end;{|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}{-----------------------------------------------------------------------------}	procedure ChartTreeCycle (whichCycle: integer; isrecalc: boolean; var numTreesProcessed: longint);		label			1, 2, 4;		var			H: Handle;			j, starttree, endtree: longint;			blah : longint;			charHdl: chHdl;			minch, maxch, minRestch, maxRestch: integer;			lastTreeSeed: longint;			theDialog: DialogPtr;			tempP: WindowPtr;			status, OKtoPolytomy, OKtofixanc, querycyclepoly, doSTDN: boolean;			aborted: boolean;			isfrom, isto, numtoadd: longint;			minminCLC, minmaxCLC, maxminCLC, maxmaxCLC: longint;			packH: Handle;			oldtreechain: integer;			ds: str255;			numres: integer;			randommoves: boolean;			oldstate: SignedByte;			pauplog: boolean;{............}		procedure AddStartLinearChart (numtoadd, maxKind: integer);			var				j: integer;		begin			for j := 0 to maxKind do				AddLinearChart(j, numtoadd, false, minChartLinearCat);		end;{............}	begin		grow1 := MaxMem(grow2);		randomMoves := false;		if (CWChart = CWCSteps) & ((CWStepsShow = CWStepsChanges)) & CWTraced & (Typeofchar(i) = fisher) then			begin				NewError(363, 0);				PleaseOffChart := true;				Errorflag := true;				goto 1;			end;		packH := NewHandle(0);{========= starttree, endtree ==========}		if (CWTrees[CWChart] = CWStoredTrees) then			begin				starttree := StartUserLink(treeCHAIN);				endtree := EndUserLink(treeCHAIN);			end		else if (CWTrees[CWChart] = CWTreeFile) then			begin				starttree := 1;				endtree := maxlongint; 				if (dirtyfile & EqualFileSpecs(FDI^[dataFileFDI].fs,FDI^[extraTreeFile1FDI].fs)) | (dirtytreefile & treefile & EqualFileSpecs(FDI^[treeFileFDI].fs,FDI^[extraTreeFile1FDI].fs)) then					NewError(354, 0);{v4: check to see that it is a currently opened treefile, and if so give warning that will use saved version of file}			end		else if not isrecalc then			if RandomTreeDLOG(endtree, false) then				begin					starttree := 1;					prevendtree := endtree;					if SaveRndTreesReport then						InitializeRndTreesReport;				end			else				begin{v4: ideally wouldn't turn off chart if already there!}					PleaseOffChart := true;					Errorflag := true;					goto 1;				end		else if isrecalc then			begin				OurRandSeed := oldTreeSeed;				starttree := 1;				endtree := prevendtree;			end;{$IFC FALSE AND RANDOMMOVE}		randomMoves := OptionDown and ShiftDown and CommandDown;{$ENDC}{=========  ==========}		maxminCLC := -1;		maxmaxCLC := -1;		minminCLC := -1;		minmaxCLC := -1;		if WhichCycle = sequenceCycle then			begin				if numchars mod catwid = 0 then					numtoadd := numchars div catwid				else					numtoadd := numchars div catwid + 1;				if (CWStepsShow = CWStepsChanges) then					AddStartLinearChart(numtoadd, 7)				else					AddStartLinearChart(numtoadd, 2);			end		else if whichcycle = positioncycle then			begin				if (CWStepsShow = CWStepsChanges) then					AddStartLinearChart(3, 7)				else					AddStartLinearChart(3, 3);			end		else if whichcycle = changescycle then			begin				allTreesChangesSelMin := 10000000;				allTreesChangesSelMax := 0;				allTreesChangesSelAvgMin := 10000000.0;				allTreesChangesSelAvgMax := 0.0;				ChangesSelMin := 0;				ChangesSelMax := 0;				ChangesSelAvg := 0.0;				if nucleotides then					begin						allTreesTransRatioMin := 1.0;						allTreesTransRatioMax := 0.0;						allTreesTransversionMin := 10000000;						allTreesTransversionMax := 0;						allTreesTransitionMin := 10000000;						allTreesTransitionMax := 0;						allTreesTransitionAvgMin := 1000000.0;						allTreesTransitionAvgMax := 0.0;						allTreesTransversionAvgMin := 1000000.0;						allTreesTransversionAvgMax := 0.0;						TransversionMin := 0;						TransversionMax := 0;						TransitionMin := 0;						TransitionMax := 0;					end;			end;		if ChartCalcToText then			WriteCalcHeadings(whichCycle);{=========  ==========}		if treeopen then			StoreCurrentTree(H);		numCWTrees := 0;		DisableWindowUpdates(chartwindow);		DisableWindowUpdates(treewindow);		DisableWindowUpdates(tlegwindow);		DisableWindowUpdates(chlegwindow);		if (CWTrees[CWChart] = CWTreeFile) then			begin				if endreadtree < 0 then					StartThermo(theDialog, tempP, 0, mcFileLength, 'Chart: Examining tree file', 'percent', true)				else					StartThermo(theDialog, tempP, startreadtree, endreadtree, 'Chart: Examining tree file', 'trees', false);				if not StartFileTrees(1, ds, oldtreechain, packH) then					goto 2;   {give appropriate warning}			end		else			StartThermo(theDialog, tempP, 0, endtree - starttree + 1, 'Chart: Processing trees', 'trees', false);		OKtoFixanc := not ((CWChart = CWCChanges) & (ChartChangesMode <> unambigmode)); {& (resolveoption = allpossible)}		OKtoFixanc := OKtoFixanc & not ((CWstepsShow = CWstepsChanges) & (CWChart = CWCSteps));		OKtoFixanc := OKtoFixanc & not ((igos * (fullgochartone + fullgochartmult) * gomask <> []) & (typeofchar(i) >= dollo));		OKtoFixanc := OKtoFixanc & not (((fullgochartone + fullgochartmult - igos) * gomask <> []) & (anytype([dollo, usedef])));		OKtoPolytomy := not ((CWChart = CWCChanges) & (ChartChangesMode <> unambigmode)); {& (resolveoption = allpossible)}		OKtoPolytomy := OKtoPolytomy & not ((CWstepsShow = CWstepsChanges) & (CWChart = CWCSteps));		OKtoPolytomy := OKtoPolytomy & not ((igos * (fullgochartone + fullgochartmult) * gomask <> []) & (typeofchar(i) >= irreversible));		OKtoPolytomy := OKtoPolytomy & not (((fullgochartone + fullgochartmult - igos) * gomask <> []) & (anytype([irreversible, fisher, dollo, usedef])));		stopaftertree := false;		querycyclepoly := true;		blastpolytomies := CWBlastPolyT;		if (CWTrees[CWChart] = CWRandomTrees) and (RTKind = RTResolve) then			PrepareToRandomPoly(R);{||||||||||||||||||| TREES LOOP |||||||||||||||||||||}		for j := starttree to endtree do			begin				if (CWChart = CWCSteps) & ((CWStepsShow in [CWStepsCI, CWStepsRI, CWStepsRC]) & ErrorPosted(81)) | ((CWStepsShow in [CWStepsRI, CWStepsRC]) & ErrorPosted(82)) then					goto 4;				if stopaftertree then					begin						NewError(44, 0);						goto 4;					end				else					begin						lastTreeSeed := OurRandSeed;  {store it for later writing}						if CheckIfAbortedChart then							begin								aborted := CheckChartStop(3);								if aborted then									goto 4;							end;{==== getting tree =====}						if (CWTrees[CWChart] = CWRandomTrees) then							begin								if randomMoves then									begin{$IFC RANDOMMOVE}										RandomBranchMove(screenR);{have to store and restore tree here!!!}										status := true;{$ENDC}									end								else if RTkind = RTResolve then									begin										RandomizeAllPolytomies(R);										status := true;									end								else									BuildTree(nil, RTKind, status, querycyclepoly, false, OKtoPolytomy, OKtoFixanc);								if SaveRndTreesReport then									UpdateRndTreesReport;							end						else if CWTrees[CWChart] = CWTreeFile then							begin								if EndOfBlock(ds) or (fpos >= mcFileLength) then									leave;								status := false;								if GetFileTree(ds, packH, numCWTrees) then									BuildTree(packH, 0, status, querycyclepoly, false, OKtoPolytomy, OKtoFixanc);							end						else							BuildTree(nil, j, status, querycyclepoly, false, OKtoPolytomy, OKtoFixanc);						if treemakingfailed then							begin								PleaseOffChart := true;								NewError(380, 0);								Errorflag := true;								goto 4;							end;{===== Tree was acceptable ====}						if status then							begin{=== preparatory calculations ===}								if ChartCalcToText then									begin										if (CWTrees[CWChart] = CWStoredTrees) then											begin												ChartWriteInteger(j - StartUserLink(treeCHAIN) + 1);												ChartWriteChar(chr(9));												LockHandle(treename, oldstate);												ChartWriteString(treename^^);												ResetHandle(treename, oldstate);											end										else											ChartWriteInteger(j);  {write treenumber}										ChartWriteChar(chr(9));										if (CWTrees[CWChart] = CWRandomTrees) and (RTkind <> RTResolve) then{as RTKind <> RTResolve, then can't retrieve random resolution from seed, therefore don't output}											begin												ChartWriteInteger(lastTreeSeed);												ChartWriteChar(chr(9));											end;									end;								doSTDN := (j = starttree) or not ((CWTrees[CWChart] = CWRandomTrees) and (RTKind = RTResolve));								if (whichcycle in [lengthcycle, sequencecycle, positioncycle]) or ((whichcycle = changescycle) and not CWTraced) then									begin {***}										if doSTDN then											SetTaxaDnSts(1, numchars);										if not CountTree then											NewError(310, 0);									end								else if (whichcycle = tracedstepcycle) or ((whichcycle = changescycle) and CWTraced) then									begin {**}										if j > 36000 then											begin												blah := j;											end;																					if doSTDN then											SetTaxaDnSts(i, i);										CountChar(i);									end;								if (whichcycle in [sequencecycle, positioncycle]) and (CWStepsShow in [CWStepsCI, CWStepsRI, CWStepsRC]) then									begin										if doSTDN then											CalcMinMaxTreeLen(minlength);										if CWStepsShow in [CWstepsRC, CWStepsCI] then											CalculateCIAll;										if CWStepsShow in [CWstepsRC, CWStepsRI] then											begin												if doSTDN then													CalcMinMaxTreeLen(maxlength);												CalculateRIAll;											end;									end;								if (whichcycle = tracedstepcycle) and (CWStepsShow in [CWStepsCI, CWStepsRI, CWStepsRC]) then									begin										if doSTDN then											CalcCharMinMaxLen(i, minlength);										if CWStepsShow in [CWstepsRC, CWStepsCI] then											CalculateCIRiChar(i, true);										if CWStepsShow in [CWstepsRC, CWStepsRI] then											begin												if doSTDN then													CalcCharMinMaxLen(i, maxlength);												CalculateCIRiChar(i, false);											end;									end;{==== gathering data about the tree ====}								case WhichCycle of									lengthCycle: 										begin											AddToChartLinear(CLkind, treelength, minChartLinearCat, maxChartLinearCat); {div lengthinflate}											if not (ErrorFlag or pleaseNoMoreChart) then												if ChartCalcToText then													if lengthinflate > 1 then														begin															RealToString(1.0 * treelength / lengthinflate, ds, 10000, 2, writeexpon);															ChartWriteString(ds);														end													else														ChartWriteInteger(treelength);										end;									tracedStepCycle: 										begin											if CWStepsShow = CWStepsChanges then												begin													if (resolveOption <> allpossible) then														NewError(45, 0);													ReconstructChars(i, i, false);													NChangesInCharDual(minch, maxch, minRestch, maxRestch, i, false, aborted);													if aborted then														begin															NewError(72, 0);															PleaseOffChart := true;														end													else														begin															CharHdl := getchhdl(i);															CharHdl^^.minRestchg := minRestch;  {assigning results for latter use}															CharHdl^^.maxRestchg := maxRestch;														end;												end;											TracedSteps(aborted, minminCLC, minmaxCLC, maxminCLC, maxmaxCLC);										end;									sequencecycle: 										begin											if CWStepsShow = CWStepsChanges then												begin													ReconstructChars(1, numchars, true);													CountTotalTreeChanges;												end;											SequenceSteps;										end;									positioncycle: 										begin											if CWStepsShow = CWStepsChanges then												begin													ReconstructChars(1, numchars, true);													CountTotalTreeChanges;												end;											PositionSteps;										end;									changescycle: 										begin											if CWTraced then												begin													ReconstructChars(i, i, false);    {Note: downpass already done under ** above}													if (resolveOption <> allpossible) then														NewError(45, 0);												end											else												ReconstructChars(1, numchars, true); {Note: downpass already done under *** above}											CharChanges;											if (chartchangesmode = unambigmode) then  {for unambigmode, only min variables used}												begin													if allTreesChangesSelMin > ChangesSelMin then														allTreesChangesSelMin := ChangesSelMin;													if allTreesChangesSelMax < ChangesSelMin then														allTreesChangesSelMax := ChangesSelMin;												end											else if (chartchangesmode = minmaxmode) then												begin													if allTreesChangesSelMin > ChangesSelMin then														allTreesChangesSelMin := ChangesSelMin;													if allTreesChangesSelMax < ChangesSelMax then														allTreesChangesSelMax := ChangesSelMax;												end											else												begin													if allTreesChangesSelAvgMin > ChangesSelAvg then														allTreesChangesSelAvgMin := ChangesSelAvg;													if allTreesChangesSelAvgMax < ChangesSelAvg then														allTreesChangesSelAvgMax := ChangesSelAvg;												end;											if nucleotides then												begin													if (chartchangesmode = unambigmode) then  {for unambigmode, only min variables used}														begin															if allTreesTransversionMin > TransversionMin then																allTreesTransversionMin := TransversionMin;															if allTreesTransversionMax < TransversionMin then																allTreesTransversionMax := TransversionMin;															if allTreesTransitionMin > TransitionMin then																allTreesTransitionMin := TransitionMin;															if allTreesTransitionMax < TransitionMin then																allTreesTransitionMax := TransitionMin;														end													else if (chartchangesmode = minmaxmode) then														begin															if allTreesTransversionMin > TransversionMin then																allTreesTransversionMin := TransversionMin;															if allTreesTransversionMax < TransversionMax then																allTreesTransversionMax := TransversionMax;															if allTreesTransitionMin > TransitionMin then																allTreesTransitionMin := TransitionMin;															if allTreesTransitionMax < TransitionMax then																allTreesTransitionMax := TransitionMax;														end													else   {for other modes, max only used}														begin															if allTreesTransversionAvgMin > TransversionAvg then																allTreesTransversionAvgMin := TransversionAvg;															if allTreesTransversionAvgMax < TransversionAvg then																allTreesTransversionAvgMax := TransversionAvg;															if allTreesTransitionAvgMin > TransitionAvg then																allTreesTransitionAvgMin := TransitionAvg;															if allTreesTransitionAvgMax < TransitionAvg then																allTreesTransitionAvgMax := TransitionAvg;														end;													if allTreesTransRatioMin > TransRatio then														allTreesTransRatioMin := TransRatio;													if allTreesTransRatioMax < TransRatio then														allTreesTransRatioMax := TransRatio;												end;										end;									otherwise										;								end;								if PleaseOffchart then									goto 4;								if ErrorFlag or pleaseNoMoreChart then									leave;								numCWTrees := numCWTrees + 1;								if (CWTrees[CWChart] = CWTreeFile) and ((numCWTrees >= endreadtree - startreadtree + 1) and (endreadtree > -1)) then									leave;							end   {status}						else							NewError(35, 0);						if CWTrees[CWChart] = CWTreeFile then							if endreadtree < 0 then								UpdateThermo(theDialog, 0, fpos, mcFileLength,true)							else								UpdateThermo(theDialog, startreadtree, startreadtree + numCWTrees, endreadtree,false)						else							UpdateThermo(theDialog, 0, j - starttree + 1, endtree - starttree + 1,false);						if ChartCalcToText then							ChartWriteChar(chr(13));					end;			end;{|||||||||||||||||||| END TREES LOOP ||||||||||||||||||||}4:		blastpolytomies := false; 		{have to set to false for next MakeTree call}		querycyclepoly := false;		stopaftertree := false;2:		if CWTrees[CWChart] = CWTreeFile then			EndFileTrees(oldtreechain, packH);		EndThermo(theDialog, tempP, true);		{this was where save random trees report was}		numTreesProcessed := j-1;		if treeopen then			RestoreCurrentTree(H, true);{==== tidying up ====}		if not ErrorFlag then			if (whichcycle = tracedstepcycle) and (CWStepsShow = CWStepsChanges) then				PadMinMaxChart(minminCLC, minmaxCLC, maxminCLC, maxmaxCLC);		if not ErrorFlag then			if numcwtrees = 0 then				begin					if not ErrorPosted(72) then						NewError(113, 0);   {if 72 is posted, which reports that charts were aborted, then no point in 113}					PleaseOffChart := true;				end			else				begin					if whichCycle in [positioncycle, sequencecycle] then						for j := 0 to numIntervals[CLstandard] - 1 do							if (CWStepsShow = CWStepsChanges) then								begin									SetChartLinearData(CLminmean, j, RoundValue(MeanInflate * GetChartLinearData(CLminMean, j) / numCWTrees));									SetChartLinearData(CLmaxmean, j, RoundValue(MeanInflate * GetChartLinearData(CLmaxMean, j) / numCWTrees));								end							else								SetChartLinearData(CLstandard, j, RoundValue(MeanInflate * GetChartLinearData(CLstandard, j) / numCWTrees));					if whichCycle = changescycle then						begin							transRatio := transRatioTotal / numCWTrees;							for isto := 0 to maxChangesState do								for isfrom := 0 to maxChangesState do									case chartchangesmode of										minmaxmode: 											begin												ChartMatrixData[CMmaxmean]^[isfrom, isto] := RoundValue(MeanInflate * ChartMatrixData[CMmaxmean]^[isfrom, isto] / numCWTrees);												ChartMatrixData[CMminmean]^[isfrom, isto] := RoundValue(MeanInflate * ChartMatrixData[CMminmean]^[isfrom, isto] / numCWTrees);											end;										meanmode: 											ChartMatrixData[CMstandard]^[isfrom, isto] := RoundValue(MeanInflate * ChartMatrixData[CMstandard]^[isfrom, isto] / numCWTrees);										unambigmode: 											ChartMatrixData[CMstandard]^[isfrom, isto] := RoundValue(MeanInflate * ChartMatrixData[CMstandard]^[isfrom, isto] / numCWTrees);										otherwise											;									end;						end;				end;1:		genericSetPort(ChartWindow);		ZapHandle(packH);	end;{-----------------------------------------------------------------------------}{$IFC FALSE}	procedure CheckExpandCatWid;	begin		catwid := usercatwid;		if not CIRICategory and (CategoryInflation > 1) and (usercatwid < categoryinflation) then			catwid := CategoryInflation;{really, it depends upon the weights - if weights of, say, 99.0 are used, this is not too}{severe; but if wts of 1.1 are used, it is not necessary}	end;{$ENDC}{-----------------------------------------------------------------------------}	function StatesChartIntervals: integer;	begin		if nucleotides then			StatesChartIntervals := maxDNAstate + 1		else if CWTraced then			StatesChartIntervals := CharMaxstOBS(i) + 1		else			StatesChartIntervals := MOS + 1;	end;{-----------------------------------------------------------------------------}	function EnoughChartMemory: boolean;{calculates, roughly, whether there is enough memory to build the chart}		var			setToCalc: set15;			numtoCalc, memoryrequired: longint;			min, max, numints, clen: longint;			ic: integer;			amountneeded: longint;	begin{v4: if not enough memory, automatically set it so that no cumulative views are possible}{this will reduce LDS to 8 bytes}		settocalc := SpotBarSetToCalc;		NumtoCalc := cardP(@settocalc, 15);{memory to be taken by a linear chart:}{	- for each kind, LDS for each interval (note: LDS=8 bytes)}{	- number of kinds = numtocalc + extras}{therefore, each interval takes (numtocalc + extras)*LDS bytes}		case CWChart of {$IFC DRMCST}			CWCcst: 				memoryrequired := 0;{$ENDC}			CWCProbSteps: 				memoryrequired := LDS * numtocalc;			CWCStates: 				memoryrequired := StatesChartIntervals * LDS;			CWCSteps: 				begin					catwid := usercatwid;					if sequencechart then{numtocalc div 3 in next several statements takes care of the CLextra storage}						memoryrequired := longint(numchars) * LDS * (numtocalc + numtocalc div 3)					else if positionchart then						memoryrequired := 3 * LDS * (numtocalc + numtocalc div 3)					else if CIRICategory then						memoryrequired := 101 * LDS * numtocalc					else if CWTrees[CWCSteps] = CWCurrentTree then						if CWStepsShow = CWStepsSteps then							begin								maxChartIntervals := (myFreeMem - memorySlack) div LDS div numtocalc;								if maxChartIntervals > userMaxChartIntervals then									maxChartIntervals := userMaxChartIntervals;								min := ChartInfinity;								max := 0;								for ic := 1 to numchars do									if CharIncluded(ic) then										begin											clen := CharLength(ic, true);											if min > clen then												min := clen;											if max < clen then												max := clen;										end;{===== automatically adjust catwid to so that it can fit into available memory =======}								repeat									numints := (max - min) div catwid;									if numints > maxChartIntervals then										catwid := catwid * 10;								until numints <= maxChartIntervals;								memoryrequired := numints * LDS * numtocalc;							end						else			{it's a stepchanges chart}							memoryrequired := LDS * numtocalc    {v4: this is the lowest possible memory required}					else if CWStepsShow = CWStepsSteps then						begin{CheckExpandCatWid;}							memoryrequired := LDS * numtocalc   {v4: this is the lowest possible memory required}						end					else						memoryrequired := LDS * numtocalc;    {v4: this is the lowest possible memory required}				end;			CWCChanges: 				memoryrequired := 0;  {set to zero as memory has been allocated on startup}									{v4: set global boolean saying whether allocation of memory for changes matrix}									{was successful}			CWCCTAll: 				memoryrequired := LDS * numtocalc;   {v4: this is the lowest possible memory required}			CWCC2T: 				memoryrequired := longint(numchars) * LDS;   {CLStandard}			CWCC2TF: 				memoryrequired := longint(numchars) * LDS * (5);   {CLSTandard + 4 extras}			otherwise				;		end;		if EnoughMemory(memoryrequired, amountneeded) then			EnoughChartMemory := true		else			begin				InstantErrorPlus(346, concat(StringFromNum(amountneeded div 1024), 'K'));				EnoughChartMemory := false;			end;	end;{-----------------------------------------------------------------------------}	procedure CalcChartData (isrecalc: boolean);{if isrecalc is true, then this is a recalculation, not original calculation}		var			oldmode: longint;			j, numtoadd, theKind: integer;			numTreesProcessed: longint;{$IFC CUMUL}			setToShow: set15;{$ENDC}			aborted, oldExists: boolean;			fs: FSSpec;	begin		numTreesProcessed := 0;		allowCursorChange := false;		if ChartCalcToText then			begin				fs := FDI^[chartCalcFileFDI].fs;				if StartSimpleFile(oldExists, fs, chartCalcFileFDI) then   {in here it sets the iofile to be chartCalcFileFDI}					begin						InitChartWriting;						StartWrite;					end				else					ChartCalcToText := false;			end;		SetMaxChangesState;		endreadtree := endreadcharttree;		startreadtree := startreadcharttree;		pleaseNoMoreChart := false;		polytomiesWereBlasted := false;		polytomiesBlasted := false;		DataInflation := InflationOnData;		CategoryInflation := InflationOnCategory(CWChart);		if (defaultcatwid = -1) then   {it is a dirty defaultcatwid}			begin				defaultcatwid := CategoryInflation;				usercatwid := defaultcatwid;			end;		catwid := defaultCatWid;		if not EnoughChartMemory then			begin				PleaseOffChart := true;				ErrorFlag := true;				allowCursorChange := true;				Exit(CalcChartData);			end;		chartbeingcalculated := true;		numCWChars := numcharin;		stopaftertree := false;		chartAlreadyDrawn := false;		aborted := false;		SetCursor(clockCursor);		numCWTrees := 1;		minChartLinearcat := -1;		maxChartLinearcat := -1;		for j := 0 to numCLkinds do			numIntervals[j] := 0;		ZeroChartData;		case CWChart of			CWCcst: 				begin {$IFC DRMCST}					AllCST;{$ENDC}				end;{$IFC PROBSTEPCHART}			CWCProbSteps: 				begin					CalcProbStepsChart;					if ErrorFlag or pleaseNoMoreChart then						begin							pleaseOffChart := true;							allowCursorChange := true;							Exit(CalcChartData);						end;				end; {$ENDC}			CWCStates: 				begin					AddLinearChart(CLkind, StatesChartIntervals, false, minChartLinearCat);					if ErrorFlag or pleaseNoMoreChart then						begin							pleaseOffChart := true;							allowCursorChange := true;							Exit(CalcChartData);						end;					CalcStateFreq(R);{v4: allow ScreenR}				end;			CWCSteps: 				begin{======================}					if CWTraced & (((CWStepsShow in [CWStepsRI, CWStepsRC]) & (TypeofChar(i) > ordered)) | ((CWStepsShow in [CWStepsCI, CWStepsRI, CWStepsRC]) & (TypeofChar(i) > irreversible))) then						begin							PleaseOffChart := true;							NewError(137, 0);						end					else if sequencechart then						begin							minChartLinearcat := 1;							maxChartLinearcat := numchars;							if CWTrees[CWCSteps] <> CWCurrentTree then								ChartTreeCycle(sequencecycle, isrecalc,numTreesProcessed)							else								begin									if numchars mod catwid = 0 then										numtoadd := numchars div catwid									else										numtoadd := numchars div catwid + 1;									if (CWStepsShow = CWStepsChanges) then										begin											AddLinearChart(CLmin, numtoadd, false, minChartLinearCat);											AddLinearChart(CLmax, numtoadd, false, minChartLinearCat);										end									else										AddLinearChart(CLStandard, numtoadd, false, minChartLinearCat);									if ErrorFlag or pleaseNoMoreChart then										begin											pleaseOffChart := true;											allowCursorChange := true;											Exit(CalcChartData);										end;									SequenceSteps;{*****}								end;						end{======================}					else if positionchart then						begin							minChartLinearcat := 1;							maxChartLinearcat := 3;							catwid := 1;							if CWTrees[CWCSteps] = CWCurrentTree then								begin									if (CWStepsShow = CWStepsChanges) then										begin											AddLinearChart(CLmin, 3, false, minChartLinearCat);											AddLinearChart(CLmax, 3, false, minChartLinearCat);										end									else										AddLinearChart(CLkind, 3, false, minChartLinearCat);									if ErrorFlag or pleaseNoMoreChart then										begin											pleaseOffChart := true;											allowCursorChange := true;											Exit(CalcChartData);										end;									PositionSteps;{*****}								end							else								ChartTreeCycle(positioncycle, isrecalc,numTreesProcessed);						end{======================}					else if CWTrees[CWCSteps] = CWCurrentTree then						StepsInTree{*****}					else						ChartTreeCycle(tracedstepcycle, isrecalc,numTreesProcessed);				end;			CWCChanges: 				begin					transRatioMax := 0.0;					transRatioMin := 100000000.0;					transRatioTotal := 0.0;					if CWTRees[CWChart] = CWCurrentTree then						begin							writeEveryCharacter := not CWTraced;							if ChartCalcToText then   {v3.02}								WriteCalcHeadings(changescycle);							ChangesInClade(R, aborted);{*****}						end					else						ChartTreeCycle(changescycle, isrecalc,numTreesProcessed);				end;			CWCCTAll: 				begin{CheckExpandCatWid;}					catwid := usercatwid;					ChartTreeCycle(lengthcycle, isrecalc,numTreesProcessed);				end;			CWCC2T: {$IFC COMPAREALL}				if OptionEvent(Event) then					CompareFirstTreeToRest				else{$ENDC}					Calc2TreeCompare;			CWCC2TF: 				begin					Compare2TreeFiles;					if errorflag then						begin							Beep;							allowCursorChange := true;							Exit(CalcChartData);						end;				end;			otherwise				;		end;		if not PleaseOffChart and not ErrorFlag then			begin{$IFC CUMUL}				setToShow := SpotBarSetToShow;				if CWlinear then					for theKind := 0 to numCLkinds do						if (theKind in setToShow) or (MinMaxOn and (theKind < 6)) then							begin								CumulativeUp(theKind);								CumulativeDown(theKind);							end;{$ENDC}				CalcTotalChart(MaxSpotBarKind);  {has to follow cumulative calcs!}				if polytomiesBlasted then					NewError(96, 0);			end;{=== zeroing chartorigin ====}		chartorigin := 0;		CWTableTop := 0;		if not printon and not savepicton then			SetControlValueLong(CWScroll, 0);		SetCursorToArrow;		ChartJustCalc := true;		chartbeingcalculated := false;		stopaftertree := false;		if chartCalcToText & polytomiesBlasted then			begin				ChartWriteChar(chr(13));				ChartWriteChar(chr(13));				ChartWriteString('Polytomies were arbitrarily resolved in some trees.');			end;		polytomiesWereBlasted := polytomiesBlasted;		polytomiesBlasted := false;		if ChartCalcToText then			begin				EndWrite;				EndSimpleFile(oldExists,chartCalcFileFDI);			end;		if SaveRndTreesReport then			SaveRndTreesReportToFile(numTreesProcessed, rtkind);		allowCursorChange := true;		//InvalidateAllWindowsMarkedUnUpdatable;	end;end.