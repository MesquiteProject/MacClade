unit ReadDataBlock;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface, 		 MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, 		 ReadAssumpBlock, SymbolsNames, InfoWindows, Thermos, CharUtil, TreeUtil, ReadWriteUtil, ReadUtil, 		 CHUNK, SpreadUtil, DrawSpread, StatesWindow, RowColumn, Editcontrol, Windows, ReadMisc;	procedure CheckAdjacenti;	procedure CheckMemoryMade (makeCharMemory: boolean; ntax, nchar: integer);	procedure StringToTaxonName (var ds: str255; it: integer);	procedure ReadDataCharBlockStart (theNexusBlock: NexusBlockPtr; theblock: integer; var successfulread, taxaDefinedInBlock: boolean; var blockdatatype: integer; readcontinuous: boolean; firstCommand: str255);	procedure ReadTaxaBlock(theNexusBlock: NexusBlockPtr; firstCommand: str255);	var		eqH: Handle;		somechars: boolean;		dataFormatRead: boolean;		taxaDefined: boolean;		minMaxContinuous: boolean;		dataBlockNumber, lastDataBlockChecked: integer;{еееееееееееееееееееееее}implementation {е$S ReadDataBlock}{-----------------------------------------------------------------------------}	procedure CheckAdjacenti;	begin		MCFlag := false;		while next = '[' do			begin				SkipComment;				if (fpos < mcFileLength) then					next := nextchar;			end;	end;{-----------------------------------------------------------------------------}	procedure CheckDataType (ds: str255; legalDataTypes: DataTypeSet; blockType,blockDataType: integer; var success, abandonship, dataTypeChecked, formatset: boolean);	begin		success := true;		if not (blockDataType in LegalDataTypes) then			begin				if taxmemorymade then {we already have some characters, so just abandonship}					abandonship := true				else					errorflag := true;				{openasUntitled := true;}				if (lastDataBlockChecked=dataBlockNumber) then					InstantError(463)				else if blockdatatype in [standard..protein, continuous] then					{NewError(138, 0)}					InstantErrorPlus(279, NativeBlockName(blockType))				else					InstantErrorPlus(261, ds);				success := false;			end		else if (blockDataType <> continuous) & not dataFormatRead then   {v4: }			begin{doCodPosQuery := blockDataType in [DNA, RNA];}				SetDataFormat(blockDataType, false);				formatset := true;			end;		dataTypeChecked := true;		lastDataBlockChecked := dataBlockNumber;	end;{-----------------------------------------------------------------------------}	procedure ReadFORMAT (legalDataTypes: DataTypeSet; blockType: integer; var blockDataType: integer; var abandonship: boolean);		label			1, 2, 3, 4;		var			startpos, endpos, hsize: longint;			ist: integer;			ds: str255;			c, oc, prev: char;			badtoken, formatset,interleaveJustRead: boolean;			missingdefined, gapdefined, extended, symbolsread, datatyperead, success, gooditems: boolean;			datatypeChecked: boolean;			oldmissing, oldfillchar, oldgap, oldmatchchar: char;			oldmatchcharon, oldEditorTransposed, oldinterleave, oldsymbolson, oldequateson: boolean;			olddatatype: integer;			oldsymbols: str255;			fileSymbols: str255;	begin		fileSymbols := '';		interleaveJustRead := false;		abandonship := false;		blockDatatype := standard;		oldmissing := missing;		oldfillchar := fillchar;		dataTypeChecked := false;		success := true;		oldgap := gap;		oldmatchcharon := matchcharon;		oldmatchchar := matchchar;		oldEditorTransposed := editorTransposed;		oldinterleave := interleave;		olddatatype := datatype;		oldsymbols := symbols;		oldsymbolson := symbolson;		oldequateson := equateson;		missingdefined := false;		gapdefined := false;		symbolsread := false;		datatyperead := false;		formatset := false;		badtoken := false;		repeat			ds := MakeCaps(GetFileToken(maxtok));			if interleaveJustRead & (ds='=') then  {we've encountered a situation were someone has used "interleave=yes" or interleave = no}				begin					ds := MakeCaps(GetFileToken(maxtok));					if (ds='NO') then						begin 							interleave := false;							ds := MakeCaps(GetFileToken(maxtok));						end					else if (ds='YES') then						begin							interleave := true;							ds := MakeCaps(GetFileToken(maxtok));						end					else if (ds=';') then						goto 1;				end;			interleaveJustRead := false;			if (ds = 'DATATYPE') then				begin					datatyperead := true;					SkipEqual;					ds := MakeCaps(GetFileToken(maxtok));					if (ds = 'DNA') then						blockDatatype := DNA					else if (ds = 'NUCLEOTIDE') then  {v3.05}						blockDatatype := DNA					else if (ds = 'RNA') then						blockDatatype := RNA					else if (ds = 'PROTEIN') then						blockDatatype := protein					else if (ds = 'STANDARD') then						blockDatatype := standard					else if (ds = 'CONTINUOUS') then						blockDatatype := continuous{    else if (ds = 'DISTRIBUTION') then blockDatatype := distribution}{    else if (ds = 'FREQUENCY') then blockDatatype := frequency}{    else if (ds = 'GENOTYPE') then blockDatatype := genotype}					else						blockDatatype := unknownDataType;					CheckDataType(ds, legalDataTypes, blockType,blockDataType, success, abandonship, dataTypeChecked, formatset);					if not success then						goto 3;				end			else				begin					if not dataTypeChecked then						CheckDataType(ds, legalDataTypes, blockType,blockDataType, success, abandonship, dataTypeChecked, formatset);					if not success then						goto 3;					if (ds = 'MISSING') then						begin							SkipEqual;							if not dataFormatRead then     {this prevents secondary characters blocks from altering missing symbol etc.}								begin									missing := GetSingleCharToken;									fillchar := missing;									missingdefined := true;								end							else								c := GetSingleCharToken;   {skip over excess symbol}{    next := nextchar;}						end					else if (ds = 'GAP') then						begin							SkipEqual;							if not dataFormatRead then								begin									gap := GetSingleCharToken;									gapdefined := true;								end							else								c := GetSingleCharToken;   {skip over excess symbol}{    next := nextchar;}						end					else if (ds = 'MATCHCHAR') then						begin							SkipEqual;							if not dataFormatRead then								begin									matchchar := GetSingleCharToken;									matchcharon := true;								end							else								c := GetSingleCharToken;   {skip over excess symbol}{    next := nextchar;}						end					else if (ds = 'TRANSPOSE') & not dataFormatRead then						editorTransposed := true					else if (ds = 'INTERLEAVE') & not dataFormatRead then						begin							interleave := true;							interleaveJustRead := true;						end					else if (ds = 'ITEMS') then						begin							if blockDatatype = continuous then								begin									minMaxContinuous := false;									Skipper(['('], true);									whitespace := whitespace + [','];									ds := MakeCaps(GetFileToken(maxtok));{legal combinations:  MIN    MAX   MIN MAX}									gooditems := false;									if ds = 'MIN' then										begin											ds := MakeCaps(GetFileToken(maxtok));											if ds = 'MAX' then												begin													ds := MakeCaps(GetFileToken(maxtok));													if ds = ')' then														begin															gooditems := true;															minMaxContinuous := true;														end;												end											else if ds = ')' then												gooditems := true;										end									else if ds = 'MAX' then										begin											ds := MakeCaps(GetFileToken(maxtok));											if ds = ')' then												gooditems := true;										end									else   {we've encountered something else}										begin											InstantErrorPlus(461, ds);											errorflag := true;											whitespace := whitespace - [','];											Exit(ReadFormat);										end;									whitespace := whitespace - [','];									if not gooditems then										goto 4;								end							else								goto 4;						end					else if (ds = 'SYMBOLS') then						begin							if dataFormatRead then								begin									repeat										c := nextdarkchar;									until (c = '"')| (fpos >= mcFileLength);									if (fpos >= mcFileLength) then										begin											InstantError(399);											errorflag := true;											badfile := true;											goto 1;										end;									repeat										c := nextdarkchar;									until (c = '"')| (fpos >= mcFileLength);									if (fpos >= mcFileLength) then										begin											InstantError(399);											errorflag := true;											badfile := true;											goto 1;										end;									next := nextdarkchar;								end							else								begin									if datatype = standard then										begin											extended := IsExtended or MCFlag;   {picked up from macClade start block or old system}											symbols := '';										end									else										begin											extended := false;											if molecular then												begin													if datatype = DNA then														symbols := 'ACGT'													else if datatype = RNA then														symbols := 'ACGU';													repeat													until (nextdarkchar = '"')| (fpos >= mcFileLength);													if (fpos >= mcFileLength) then														begin															InstantError(399);															errorflag := true;															badfile := true;															goto 1;														end;													repeat													until (nextdarkchar = '"')| (fpos >= mcFileLength);													if (fpos >= mcFileLength) then														begin															InstantError(399);															errorflag := true;															badfile := true;															goto 1;														end;													next := nextchar;   { note that ignores symbols entirely for molecular data}													goto 2;												end;										end;									repeat										prev := next;										next := nextdarkchar;									until (next = '"')| (fpos >= mcFileLength);									if (fpos >= mcFileLength) then										begin											InstantError(399);											errorflag := true;											badfile := true;											goto 1;										end;									repeat										prev := next;										next := nextdarkchar;										if next = '~' then											begin												next := nextdarkchar;												for oc := succ(prev) to next do													symbols := concat(symbols, oc);											end										else if next <> '"' then											symbols := concat(symbols, next);									until next = '"';									next := nextchar;									symbolson := not StandardSymbols;									fileSymbols := symbols;  {v 3.06}									if extended then										begin											SetDataFormat(standard32, false);											formatset := true;										end;									if (length(symbols) <= 10) then										begin											if not (datatype = standard32) then												begin													SetDataFormat(standard, false);													formatset := true;												end;										end									else if length(symbols) <= 26 then										begin											SetDataFormat(standard32, false);											formatset := true;										end									else										begin											InstantError(262);											errorflag := true;											badfile := true;											goto 1;										end;2:								end;						end					else if (ds = 'EQUATE') then						begin							repeat								c := nextdarkchar;							until (c = '"') | (fpos >= mcFileLength);							if (fpos >= mcFileLength) then								begin									InstantError(399);									errorflag := true;									badfile := true;									goto 1;								end;							startpos := fpos + 1;							repeat								c := nextdarkchar;							until (c = '"') | (fpos >= mcFileLength);							if (fpos >= mcFileLength) then								begin									InstantError(399);									errorflag := true;									badfile := true;									goto 1;								end;							endpos := fpos;							next := nextdarkchar;							if not dataFormatRead then								begin									eqH := NewHandle(2);									equateson := MemoryOK;									if equateson then										FilePieceToH(startpos, endpos, eqH);								end;						end					else if ds = ';' then						goto 1					else if (ds <> ',') then						begin4:							InstantErrorPlus(263, ds);							errorflag := true;							Exit(ReadFormat);						end;				end;		until false;1:		if datatyperead & (blockdatatype in [DNA, RNA]) & symbolsread then			begin				if CWarning('MacClade does not support SYMBOLS with DNA, RNA format - convert to standard format?', 'Continue', 'Cancel') then					begin						DrawDialog(iothermo);						formatset := true;						SetDataFormat(standard, false);						openasUntitled := true;					end				else					begin						errorflag := true;						Exit(ReadFormat);					end;			end;		if (blockdatatype <> continuous) and not dataFormatRead then			begin				if not formatset then					SetDataFormat(standard, false);{==== Checking for Symbols conflict ======}				CheckSymbolsConflictRead(fileSymbols, missingdefined, gapdefined, formatset);			end;3:		if abandonship then			begin				if equateson then					ZapHandle(eqH);				equateson := oldequateson;				missing := oldmissing;				fillchar := oldfillchar;				gap := oldgap;				matchcharon := oldmatchcharon;				matchchar := oldmatchchar;				editorTransposed := oldEditorTransposed;				interleave := oldinterleave;				datatype := olddatatype;				SetDataFormat(datatype, false);				symbols := oldsymbols;				symbolson := oldsymbolson;			end		else {v3.05: removed     if blockdatatype <> continuous then}			dataFormatRead := true;	end;{-----------------------------------------------------------------------------}	procedure ReadOPTIONS;  {reading option for earlier files, in DATA block}		label			1;		var			ds: str255;			c: char;	begin		ignore := notgiven;		repeat			ds := MakeCaps(GetFileToken(maxtok));			if (ds = 'MSTAXA') then				ReadMSTAXA			else if (ds = 'IGNORE') then				ReadIGNORE			else if (ds = 'ZAP') then   {v3.03: added ZAP so skips over equal}				begin					InstantErrorPlus(267, 'ZAP');					SkipOption;					{ds := MakeCaps(GetFileToken(maxtok));}					DrawDialog(iothermo);					openasUntitled := true;				end			else if (ds = 'GAPMODE') then				ReadGAPMODE			else if (ds = 'LINKCHARACTERS') then  {4.08}				begin					InstantErrorPlus(267, ds);					SkipEqual;					ds := GetFileToken(maxtok);				end			else if (ds <> ',') & (ds<>';') then				begin					InstantErrorPlus(267, ds);					DrawDialog(iothermo);					openasUntitled := true;					SkipOption;					{Skipper([';'],true);					goto 1;}				end;		until (fpos >= mcFileLength) | (ds = ';');1:	end;{-----------------------------------------------------------------------------}	procedure StringToTaxonName (var ds: str255; it: integer);		var			TaxonHdl: thdl;	begin		TaxonHdl := GetTaxonHdl(it);		if MCFlag or italicsIsOn or tokenIsItalics then   {v3.05 added italicsIsOn and tokenIsItalics}{if [\i] is turned on, but never turned off, then italicsIsOn will be true until it is explicitly turned off}{however, if [\i] is at start of name, and [\p] at end, then italicsIsOn will be off by the time the token}{is completely read, so that can't be used; but tokenIsItalics will be true}			TaxonHdl^^.isItalic := true;   {this is still needed for old files}		UnderLineToBlanks(ds);		MCFlag := false;		SetTaxonName(it, ds);	end;{----------------------------------------------------------------------------}	procedure ReadTaxLabels;		var			it: integer;			ds: str255;	begin		MCFlag := false;		italicsIsOn := false;		ds := GetFileToken(maxtok);		it := 1;		while (it <= numtaxa) and (ds <> ';') do			begin				StringToTaxonName(ds, it);				ds := GetFileToken(maxtok);				it := it + 1;			end;		if ds <> ';' then			Skipper([';'], false);		if not editorTransposed & DuplicateNames then 			InstantError(423);	end;{----------------------------------------------------------------------------}	procedure ReadCharLabels;		var			ic: integer;			j: integer;			ds: str255;	begin		ds := GetFileToken(maxtok);		ic := 1;		while (ic <= numchars) and (ds <> ';') do			begin				UnderLineToBlanks(ds);				if length(ds)> cnw then					NewError(450,ic);				j := length(ds);				ds := CopyString(ds, 1, cnw);				SetCharName(ic, ds);				ds := GetFileToken(maxtok);				j := length(ds);				ic := ic + 1;			end;		if ds <> ';' then			Skipper([';'], false);	end;{----------------------------------------------------------------------------}	procedure ReadCharStateLabels;		label			2;		var			ic: integer;			ds: str255;			H: Handle;	begin		H := NewHandle(0);		ic := 1;		repeat			ds := GetFileToken(maxtok);			if ds <> ';' then				begin					ic := TokenToInteger(ds, true);					if (ic > 0) and (ic <= numchars) then						begin{next := nextdarkchar; skip over semicolon}{if (next <> ',') and (next <> ';') then begin}							StringToH(' ', H);							ds := GetFileToken(maxtok);							if (ds = ',') or (ds = ';') or (fpos >= mcFileLength) then								goto 2;							if ds <> '/' then {this is the character name}								begin									if not editorTransposed then   {ignore it otherwise}										begin											UnderLineToBlanks(ds);											if length(ds)> cnw then												NewError(450,ic);											ds := CopyString(ds, 1, cnw);											SetCharName(ic, ds);										end;									ds := GetFileToken(maxtok);   {this should be the '/' or ',' or ';'}								end;							if ds = '/' then   {there are state names to follow}								repeat									ds := GetFileToken(maxtok);									if (ds <> ',') and (ds <> ';') then										begin											if ds = '_' then												ds := NoName											else												BlanksToUnderLine(ds);											AppendToHandle(H, ds);											AppendToHandle(H, ' ');										end;								until (ds = ',') or (ds = ';') or (fpos >= mcFileLength);2:							if fpos >= mcFileLength then   {v.302:  }								begin									errorflag := true;									badfile := true;									NewError(399, 0);									Exit(ReadCharStateLabels);								end;							AppendToHandle(H, EndNames);							HandletoCHUNK(H, statenamesCHUNKs, ic);{end;}						end					else						begin							Skipper([';', ','], false);							ds := next;  {v3.05}						end;				end;		until (ds = ';') | (fpos >= mcFileLength) | badfile;  {v3.05: fpos part added}		ZapHandle(H);	end;{----------------------------------------------------------------------------}	procedure ReadStateLabels;		label			2;		var			ic: integer;			ds: str255;			H: Handle;	begin		H := NewHandle(0);		ic := 1;		repeat			ds := GetFileToken(maxtok);			if ds <> ';' then				begin					ic := TokenToInteger(ds, true);					if (ic > 0) and (ic <= numchars) then						begin{next := nextdarkchar; if (next <> ',') and (next <> ';') then begin}							StringToH(' ', H);							repeat								ds := GetFileToken(maxtok);								if (ds <> ',') and (ds <> ';') then									begin										if ds = '_' then											ds := NoName										else											BlanksToUnderLine(ds);										AppendToHandle(H, ds);										AppendToHandle(H, ' ');									end;							until (ds = ',') or (ds = ';') or (fpos >= mcFileLength);2:							if fpos >= mcFileLength then   {v.302:  }								begin									errorflag := true;									badfile := true;									NewError(399, 0);									Exit(ReadStateLabels);								end;							AppendToHandle(H, EndNames);							HandletoCHUNK(H, statenamesCHUNKs, ic);{    end;}						end					else						begin							Skipper(punctuation, false);							ds := next;  {v3.05}						end;				end;		until (ds = ';') | (fpos >= mcFileLength) | badfile;  {v3.05: fpos part added}		ZapHandle(H);	end;{----------------------------------------------------------------------------}	var		taxNumBytes: integer;{----------------------------------------------------------------------------}	procedure CheckMemoryMade (makeCharMemory: boolean; ntax, nchar: integer);{if charmemorymade is true, then all memory, including character memory, has been made}{if taxmemorymade is true, then only taxon memory with 1 empty character has been made}		label			1;		var			amountneeded: longint;			it: integer;			taxstsHdl: Handle;	begin		if not taxmemorymade then			begin				if not EnoughMemory(FullMemoryNeeded(ntax, nchar), amountneeded) then					begin						InstantErrorPlus(268, concat(StringFromNum(amountneeded div 1024), 'K'));						errorflag := true;						goto 1;					end;				numtaxa := ntax;				if makeCharMemory then   {v3.05}					numchars := nchar				else					numChars := 1;				if not CreateTaxonCharMemory then					begin						CleanUpFailedTaxonCharacterMemory;						goto 1;					end;				SetCursID(amoeba);				taxNumBytes := numbytes;				if not makeCharMemory then					charMemoryMade := false;			end;		if taxmemorymade and not charmemorymade and makeCharMemory then			begin				if not EnoughMemory(FullMemoryNeeded(ntax, nchar), amountneeded) then					begin						InstantErrorPlus(268, concat(StringFromNum(amountneeded div 1024), 'K'));						errorflag := true;						goto 1;					end;				if (numbytes = 4) & (taxNumBytes = 2) then  {taxmemory was made with 2 bytes, need to expand to 4}					begin						for it := 1 to numtaxa do							begin								taxstsHdl := gettaxstsHdl(it);								SetHandleSize(taxstsHdl, tcb);							end;						FillTaxSts(1, 1, 1, numtaxa, datatype = protein);					end;				AddNewCharacters(nchar - 1, false);				datachanged := false;   {add this to nullify setting of datachanged in AddNewCharacters}				SetCursID(amoeba);				charmemorymade := not ErrorFlag;			end;1:	end;{----------------------------------------------------------------------------}	procedure ReadDimensions (theNexusBlock: NexusBlockPtr; theblock: integer; var ntax, nchar: integer; var taxaspecified, charspecified, newtaxa: boolean; firstCommand: str255);		var			ds: str255;			ncharL : longint;	begin		SetCursID(amoeba);		nchar := 1;		ntax := 1;		charspecified := false;		taxaspecified := false;		newtaxa := false;		ds := MakeCaps(firstCommand);		if  (ds <> 'DIMENSIONS') & (ds<> 'DIMENSION') & not EndOfBlock(ds) then			repeat				ds := MakeCaps(GetFileToken(maxtok));			until (ds = 'DIMENSIONS') or (ds = 'DIMENSION') or EndOfBlock(ds);		if EndOfBlock(ds) then			begin				if theblock = taxaBlock then					InstantError(269)				else if theblock = charactersBlock then					InstantError(270)				else if theblock = dataBlock then					InstantError(271);				errorflag := true;				badfile := true;				Exit(ReadDimensions);			end;		repeat			ds := MakeCaps(GetFileToken(maxtok));			if (ds = 'NTAX') or (ds = 'NTAXA') then				begin					next := nextdarkchar;		{=}					if next = '=' then						next := nextdarkchar;					ds := GetFileToken(maxtok);					if taxaDefined then   {taxa are already defined}						InstantError(272)					else						begin							ntax := TokenToInteger(ds, true);							if ntax > 0 then								taxaspecified := true;						end;				end			else if (ds = 'NCHAR') or (ds = 'NCHARS') then				begin					next := nextdarkchar;		{=}					if next = '=' then						next := nextdarkchar;					ds := GetFileToken(maxtok);					if theblock = taxaBlock then						begin							InstantError(273);							ncharL := 1;						end					else						ncharL := TokenToLongint(ds, true);					if (ncharL > mnchars) then						begin							InstantError(465);							errorflag := true;							badfile := true;							nchar := 1;						end					else						nchar := ncharL;										if nchar > 0 then						charspecified := true;				end			else if (ds = 'NEWTAX') or (ds = 'NEWTAXA') then				begin					newtaxa := true;				end			else if ds <> ';' then				begin					InstantErrorPlus(387, ds);					errorflag := true;					Exit(ReadDimensions);				end;		until (ds = ';') | errorflag;	end;{----------------------------------------------------------------------------}	procedure ReadDataCharBlockStart (theNexusBlock: NexusBlockPtr; theblock: integer; var successfulread, taxaDefinedInBlock: boolean; var blockdatatype: integer; readcontinuous: boolean; firstCommand: str255);{reads pre-matrix elements of data or character block}		label			1, 2;		var			ds: str255;			command, upperCaseCommand: str255;			db: boolean;			abandonship, oldsomechars, newtaxa: boolean;			ntax, nchar: integer;			formatread: boolean;	begin		formatread := false;  {v3.06}		taxaDefinedInBlock := false;		oldsomechars := somechars;		ReadDimensions(theNexusBlock, theblock, ntax, nchar, db, somechars, newtaxa, firstCommand);		if errorflag then			goto 2;		taxaDefinedInBlock := newTaxa or (theBlock = dataBlock) or (theBlock = taxaBlock);		if taxaDefined & taxaDefinedInBlock then   {taxa are already defined, can't have any more}			begin				successfulread := false;				goto 2;			end;{if not (taxaBlock in blocksread) then}		if taxaDefinedInBlock then   {v3.05: this block creates taxa - need to check if too many}			if ntax > mntaxa then				begin{$IFC DEMO}					InstantInfo(concat('This demonstration version of MacClade cannot open files with more than ', StringFromNum(mntaxa), ' taxa or ', StringFromNum(mnchars), ' characters.'));{$ELSEC}					InstantError(274);{$ENDC}					errorflag := true;				end;		ntscreen := 1;  {not needed; just here for test}		if not charmemorymade & (nchar > mnchars) then   { Davidv4.1: need to do this after find out if continuous or normal}									{also, don't give this if CHARACTERS and not continuous...}									{these warnings are present in the 3.08 code!}			begin{$IFC DEMO}				if not errorflag then					InstantInfo(concat('This demonstration version of MacClade cannot open files with more than ', StringFromNum(mntaxa), ' taxa or ', StringFromNum(mnchars), ' characters.'));{$ELSEC}				InstantError(275);{$ENDC}				errorflag := true;			end;		if errorflag then			goto 2;		blockdatatype := standard;		abandonship := false;				dataBlockNumber := dataBlockNumber+1;		repeat			command := GetFileToken(maxtok);			upperCaseCommand := MakeCaps(command);			if (upperCaseCommand = 'FORMAT') then				begin{$IFC TRUE}{this is the version 3.05 stuff to handle a data block and a continuous block}					if readcontinuous and not contmemorymade then						ReadFORMAT([continuous], theBlock,blockdatatype, abandonship)					else if not contmemorymade and not charmemorymade then  {nothing's made, anything legal}						ReadFORMAT([standard..protein, continuous], theBlock,blockdatatype, abandonship)					else if charmemorymade and not contmemorymade then   {only thing that is legal is continuous}						ReadFORMAT([continuous], theBlock,blockdatatype, abandonship)					else if contmemorymade and not charmemorymade then  {only thing that is legal is standard block}						ReadFORMAT([standard..protein], theBlock,blockdatatype, abandonship)					else						begin							{openasUntitled := true;}							{NewError(138, 0);}							InstantErrorPlus(279, NativeBlockName(theblock));							abandonship := true;						end;{$ELSEC}					if readcontinuous then						ReadFORMAT([continuous], theBlock,blockdatatype, abandonship)					else						ReadFORMAT([standard..protein, continuous], theBlock,blockdatatype, abandonship);{$ENDC}					successfulread := not abandonship;					if abandonship then						begin							goto 2;						end;					if blockdatatype = continuous then						begin							numcontinuous := nchar;							somechars := oldsomechars;						end;					CheckMemoryMade(blockdatatype <> continuous, ntax, nchar);					if errorflag then						goto 2;					formatread := true;  {v3.06}				end			else if (upperCaseCommand = 'OPTIONS') or (upperCaseCommand = 'OPTION') then				if blockdatatype = continuous then					begin						InstantError(276);						DrawDialog(iothermo);						Skipper([';'], true);					end				else					ReadOptions			else if (upperCaseCommand = 'TAXLABELS') then				begin					if theblock = charactersBlock then						begin							InstantError(277);							DrawDialog(iothermo);							Skipper([';'], true);						end					else						begin							CheckMemoryMade(blockdatatype <> continuous, ntax, nchar);							if errorflag then								goto 2;							if editorTransposed then								ReadTaxLabels							else								begin									InstantError(278);									DrawDialog(iothermo);									Skipper([';'], true);								end;						end;				end			else if (upperCaseCommand = 'CHARLABELS') or (upperCaseCommand = 'CHARSTATELABELS') then   {v3.05: added charstatelabels}				begin					if blockdatatype = continuous then						begin							ReadForeignLineIntoNexusBlockPtr(theNexusBlock, command);							{InstantError(284);							openasuntitled := true;							DrawDialog(iothermo);							Skipper([';'], true);}						end					else						begin							CheckMemoryMade(blockdatatype <> continuous, ntax, nchar);							if errorflag then								goto 2;							if upperCaseCommand='CHARSTATELABELS' then								ReadCharStateLabels							else								if not editorTransposed then									ReadCharLabels								else									begin										InstantError(280);										DrawDialog(iothermo);										Skipper([';'], true);									end;						end;				end			else if (upperCaseCommand = 'STATELABELS') then				if blockdatatype = continuous then					begin						ReadForeignLineIntoNexusBlockPtr(theNexusBlock, command);						{InstantError(281);						DrawDialog(iothermo);						openasuntitled := true;						Skipper([';'], true);}					end				else					begin						CheckMemoryMade(blockdatatype <> continuous, ntax, nchar);						if errorflag then							goto 2;						ReadStateLabels					end			else if (upperCaseCommand = 'MATRIX') then				begin					CheckMemoryMade(blockdatatype <> continuous, ntax, nchar);					if errorflag then						goto 2;					if not formatread then   {v3.06}						SetDataFormat(standard, true);					goto 1;   {we have encountered the MATRIX, the last command in the block}				end			else if (upperCaseCommand <> ';') then				begin					ReadForeignLine(theblock, command);{$IFC FALSE}					errorflag := CWarning(concat('MacClade does not support the command ''', command, '''.'), 'Cancel', 'Continue');					if errorflag then						badfile := true;					Skipper([';'], true); {$ENDC}				end;			if errorflag then				goto 2;		until (fpos >= mcFileLength);1:		if blockdatatype <> continuous then			NamesToBackUp(true)		else 			theNexusBlock^.blockType := continuousBlock;2:	end;{----------------------------------------------------------------------------}	procedure ReadTaxaBlock(theNexusBlock: NexusBlockPtr; firstCommand: str255);		label			2;		var			command, upperCaseCommand: str255;			db: boolean;			ntax, nchar: integer;	begin		ReadDimensions(theNexusBlock, taxaBlock, ntax, nchar, db, db, db, firstCommand);		if errorflag then			goto 2;		if ntax > mntaxa then			begin				InstantError(274);				errorflag := true;			end;		if errorflag then			goto 2;		repeat			command := GetFileToken(maxtok);			upperCaseCommand := MakeCaps(command);			if (upperCaseCommand = 'TAXLABELS') then				begin					CheckMemoryMade(false, ntax, nchar);					if errorflag then						goto 2;					ReadTaxLabels;					//db := FindEndOfBlock;  {4.07}					//Skipper([';'], true);					//goto 2;				end			else if (upperCaseCommand <> ';') & not EndOfBlock(upperCaseCommand) then				begin									ReadForeignLine(taxaBlock, command);{$IFC FALSE}					errorflag := CWarning(concat('MacClade does not support ', upperCaseCommand, '.'), 'Cancel', 'Continue');					if errorflag then						badfile := true;					Skipper([';'], true);{$ENDC}				end;			if errorflag then				goto 2;		until EndOfBlock(upperCaseCommand) or (badmemory) or errorflag or (fpos > mcFileLength);2:	end;end.