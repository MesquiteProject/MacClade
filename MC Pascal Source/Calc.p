unit Calc;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, CharUtil, TypeUtil, TreeUtil, Polycalc, CalcUtil, Dollo, UtilLibInterface, SetLibInterface;	procedure DownPass (NP: Nptr; ist, iend: INTEGER);	procedure UpPass (NP: Nptr; ist, iend: integer);	procedure TriplePass (NP: Nptr; ist, iend: integer; whatOnly: integer);	procedure StSetsOpC (numbytes: integer; NdP, NlfdP, NrtdP: Ptr; clP: LIP; ctP: IP; ic: integer);{	procedure StSetsOpASM (numbytes: integer; NdP, NlfdP, NrtdP: Ptr; clP: LIP; ctP: IP; ic: integer);}{еееееееееееееееееееееее}implementation {е$S Calc}	var		NstsP, NancstsP, NdnstP, NlfdnstP, NrtdnstP, NupstP: Ptr;		NlfupstP, NrtupstP, NancUpstP, sidednstP: Ptr;		Nfixanced, SideN: Nptr;		lenpl: longint;{-----------------------------------------------------------------------------}{#######  RECONSTRUCTION & COUNTING OF DISCRETE CHARACTERS  #########}{This unit deals with the reconstructing and counting of non-traced discrete characters.}{Thus this performs the downpass for counting the treelength; it also performs the}{reconstruction of all characters for TraceAllChanges, etc.}{The three main procedures are DownPass, UpPass, and TriplePass.  See the unit}{CalcTraced for similar procedures there designed specifically for the traced character}{These procedures operate on characters ist ("istart") through iend.  It will always be }{assumed that either ist = iend (calculations on one single character)}{OR (ist=1 AND iend=numchars) (calculations on all characters)}{-----------------------------------------------------------------------------}	procedure StSetsOpC (numbytes: integer; NdP, NlfdP, NrtdP: Ptr; clP: LIP; ctP: IP; ic: integer);external;	procedure StSetsOpASM (numbytes: integer; NdP, NlfdP, NrtdP: Ptr; clP: LIP; ctP: IP; ic: integer);{FROZEN 3.0}	begin			{Wayne: v3.5 DELETE}	end;{This assembly procedure cycles through characters, doing the standard state set operations}{to combine two sets (stored at pointers Nlfdp and Nrtdp) into the set at their ancestral node}{(Ndp), used in the DownPass and for branchswapping.}{Operates only on unordered, ordered, irreversible and fisher characters}{Increments length cost for unordered, ordered, irreversible characters.}{==================================================================================}{==================================================================================}	procedure DownPass (NP: Nptr; ist, iend: INTEGER);{FROZEN 3.0}{Down pass for counting & reconstruction of characters ist through iend}{Calculates downstates from nodes above.  Also does counting of steps for}{characters except Fisher, Dollo and User-defined.  Fisher & Dollo counted after full reconstruction}{(see Count unit), and all User-defined type calculations done separately (see Count and}{Genchar units)}		var			chL: longint;			clenP: LIP;			ctypP: ip;			Nfixtaxonsts: largestsetchars;			tempset: largestsetchars;  {.........................................................}		procedure DownPolytomous (N: Nptr); {===  POLYTOMOUS ===}{FROZEN 3.0}	{when N is polytomous, N's downstates for characters ist through iend assigned here}			var				ic: integer;		begin			NdnstP := SetPtrFromHandleLock(N^.dnstH, ist);{get pointer to first downstate location}			ResetCtypPtr(CtypP, ist);{opening pointers to type and lengths of characters}			ResetClenPtr(ClenP, ist);			for ic := ist to iend do				begin		{cycle through characters, performing PolyCalcs on each}					if ctypP^ < irreversible then {excluded ignored since ctyp=excluded}						begin							chL := 0;							tempset := PolyCalcs(N, ic, ctypP^, down, chL, tracedfalse);							TransferStatesFromLargest(NdnstP, tempset); {place resulting set in downstate storage}							ClenP^ := ClenP^ + chL;						end;					NdnstP := Ptr(ord4(NdnstP) + tcb);{increment pointers}					IncrementClenPtr(ClenP);					IncrementCtypPtr(CtypP);				end;  {ist to iend}			HUnLock(N^.dnstH);		end;{.........................................................}		procedure DownFixanced (N: Nptr);  {===  FIXANCED ===}{FROZEN 3.0}	{when N is fixanced, characters ist through iend dealt with here}			var				ic: integer;				fixanceddown, notfixanceddown, Ndown: largestsetchars;		begin			Nfixanced := Termoffixanc(N);  {get taxon fixanced onto N}			NdnstP := SetPtrFromHandleLock(N^.dnstH, ist);			NlfdnstP := SetPtrFromHandleLock(Nfixanced^.dnstH, ist);			NrtdnstP := SetPtrFromHandleLock(Descoffixanc(N)^.dnstH, ist);{ее    Open3SetHandles(N^.dnstH, Nfixanced^.dnstH, Descoffixanc(N)^.dnstH, NdnstP, NlfdnstP, NrtdnstP, ist);}		{Note: when right is fixanced, opening above puts rt^.dnst storage into left as if left fixanced:}		{Fixancd	N^.rt	}		{     \        //		}		{       \    //		}		{          N			}			ResetCtypPtr(CtypP, ist);{opening pointers to type and lengths of characters}			ResetClenPtr(ClenP, ist);			for ic := ist to iend do				begin{cycle through characters, adjusting states of N. Not simply pulling down fixanced node's states}{because if they are missing, node is transparent and other descendant's states come down; }{if they are uncertain, node is translucent, and state is filtered combination of both descendants.}{For more information see CalcTraced unit.}					if ctypP^ < dollo then  {assumes excluded characters have type "excluded"}						begin							Nfixtaxonsts := gettaxonstsLargest(Nfixanced^.name, ic); {get original states of fixanced terminal}							fixanceddown := GetLargestfromPtr(NlfdnstP);  {downstates of fixanced terminal}							notfixanceddown := GetLargestfromPtr(NrtdnstP);  {downstates of other descendant}							chl := 0;							CombineFixancedDown(Ndown, fixanceddown, notfixanceddown, Nfixtaxonsts, chl, ic, N, tracedfalse);							TransferStatesFromlargest(NdnstP, Ndown); {store result in downstate storage}							ClenP^ := ClenP^ + chL; {increment length obtained}						end;  {charincluded}					IncrSetPointer(NdnstP);{increment pointers}					IncrSetPointer(NlfdnstP);					IncrSetPointer(NrtdnstP);					IncrementClenPtr(ClenP);					IncrementCtypPtr(CtypP);				end; {ist to iend}			Unlock3Handles(N^.dnstH, N^.lf^.dnstH, N^.rt^.dnstH);		end;{.........................................................}		procedure DownReviseDollo (N: Nptr); {===Dollo revise}{FROZEN 3.0}{Revises downstates of Dollo (because ASM procedure does not deal with Dollo), }			var				ic: integer;		begin		{obtained pointers to downstate storage of node and its left and right descendants}			NdnstP := SetPtrFromHandleLock(N^.dnstH, ist);	{getting pointers}			NlfdnstP := SetPtrFromHandleLock(N^.lf^.dnstH, ist);			NrtdnstP := SetPtrFromHandleLock(N^.rt^.dnstH, ist);			ResetCtypPtr(CtypP, ist);{opening pointers to type and lengths of characters}			ResetClenPtr(ClenP, ist);			for ic := ist to iend do				begin					if ctypP^ = dollo then  {if Dollo calculate downstates from those of two descendants}						TransferStatesFromlargest(NdnstP, DolloCombineAndPack(GetLargestFromPtr(NlfDnstP), GetLargestFromPtr(NrtDnstP), N = R, ic));					IncrSetPointer(NdnstP);{increment pointers}					IncrSetPointer(NlfdnstP);					IncrSetPointer(NrtdnstP);					IncrementClenPtr(ClenP);					IncrementCtypPtr(CtypP);				end; {ist to iend}			Unlock3Handles(N^.dnstH, N^.lf^.dnstH, N^.rt^.dnstH);		end;{.........................................................}		procedure InDownPass (N: Nptr);  {й=й=й=й=й=й=й=й=й=RECURSION}{FROZEN 3.0}{This is the recursive procedure which controls the DownPass}{Depending upon whether the node is polytomous, fixanced or not, this procedure}{passes control to the calculation procedures above.  The simple case}{is handled by a fast assembly language procedure}		begin			if NodeIsInternal(N) then	{internal node}				begin					InDownPass(N^.lf);					InDownPass(N^.rt);					if not N^.null then						begin							if NodeIsPolytomous(N) then								DownPolytomous(N)							else if N^.fixanc then								DownFixanced(N)							else  {====  SIMPLE ====}								begin				{obtain starting pointers to downstate storage for node and its descendants}									NdnstP := SetPtrFromHandleLock(N^.dnstH, ist);	{getting pointers}									NlfdnstP := SetPtrFromHandleLock(N^.lf^.dnstH, ist);									NrtdnstP := SetPtrFromHandleLock(N^.rt^.dnstH, ist);				{open pointers to type and length storage for characters}									ResetCtypPtr(CtypP, ist);{opening pointers to type and lengths of characters}									ResetClenPtr(ClenP, ist);				{main calculation to combine state sets at descendants is called}				{********************************}									StSetsOpC(tcb, NdnstP, NlfdnstP, NrtdnstP, clenP, ctypP, iend - ist + 1);				{********************************}			{handles are closed}									Unlock3Handles(N^.dnstH, N^.lf^.dnstH, N^.rt^.dnstH);									if Anytype([dollo]) then										DownReviseDollo(N);						{this is called for Dollo because ASM procedure does not deal with Dollo, }						{Not needed for polytomous and fixanced cases because }						{dollo not allowed with polytomous, and fixanced deals with dollo already}								end;  {simple}						end;				end;  {internal node}		end; {й=й=й=й=й=й=й=й=й=й=й=RECURSION}	begin {.............main of downpass......................}		if allowCursorChange then Setcursor(DownPassCurs);		HLock(chtypH);		HLock(chlenH);		InDownPass(NP);		HUnLock(chtypH);		HUnLock(chlenH);	end;{==================================================================================}{==================================================================================}	procedure UpOpC (numbytes: integer; NuP, NancupP, SideNdP: Ptr; ctP: IP; ic: integer);	external;	procedure UpOpASM (numbytes: integer; NuP, NancupP, SideNdP: Ptr; ctP: IP; ic: integer);{FROZEN 3.0}	begin		{Wayne: v3.5 DELETE}	end;{This assembly procedure calculates uppass state sets at Nup using ancestor's upstate at NancupP}{and sister's downstate at sideNdp}{.........................................................}	procedure UpPass (NP: Nptr; ist, iend: integer);{FROZEN 3.0}{UpPass calculates upstates for internal nodes for characters ist through iend}{ for unordered and ordered characters only.}{User-defined types ignored here & done separately}{Dollo and irreversible characters don't have upstates so not done here}{NOTE: upstates at node N indicates preferences of part of tree below N; it is }{calculated from upstate of ancestor, and downstate of sister. }{Sis е     е N	}{      | \  /		}{      |   е Anc	}{      | /		}{      е  		}		var			clenP: Lip;			CtypP: ip;{.........................................................}		procedure UpPolytomous (N: Nptr);{FROZEN 3.0}{when N's ancestor is polytomous, N's upstates for characters ist through iend assigned here}{If Node's ancestor is polytomous, then must use Polycalcs to calculate states coming}{up from below.  This procedure simply cycles through characters, calling Polycalcs}			var				ic: integer;		begin			NupstP := SetPtrFromHandleLock(N^.upstH, ist);{get pointer to first upstate location}			ResetCtypPtr(CtypP, ist);{opening pointer to types of characters}			for ic := ist to iend do				begin					if (ctypP^ <= ordered) then  {note: excluded chars have type=excluded}						begin							lenpl := 0;							TransferStatesFromLargest(NupstP, PolyCalcs(N, ic, ctypP^, up, lenpl, tracedfalse))						end;					IncrSetPointer(NupstP);					IncrementCtypPtr(CtypP);				end;			HUnLock(N^.upstH);		end;{.........................................................}		procedure UpFixanced (N: Nptr);{FROZEN 3.0}{Used for N when N's ancestor is fixanced; therefore its states are automatically the upstates}{of N, unless this fixed terminal has missing or uncertain states, in which case}{it is translucent or transparent to states  coming from below, in which case}{the ancestor's upstates can be filtered by its downstates to give the upstates of N}			var				ic: integer;		begin			NupstP := SetPtrFromHandleLock(N^.upstH, ist);{get pointer to first upstate location}			SideN := Sis(N);			sidednstP := SetPtrFromHandleLock(SideN^.dnstH, ist);{get pointer to first sister downstate location}			ResetCtypPtr(CtypP, ist);{opening pointer to types of characters}			for ic := ist to iend do				begin					if (ctypP^ <= ordered) then  {remember excluded don't enter because ctyp=excluded}						begin				{Getting states from fixed ancestor (recall can't use N^.anc^.dnst because this}				{may have been altered in downpass by filtering from above if uncertain)}				{ don't need to ask if N^.anc=R since already asked in InUpPass}							lenpl := 0; {dummy to absorb length}							if FixancedByMissing(N^.anc, ic) then				{if fixanced by missing node is transparent to upstate from below}								TransferStatesFromLargest(NupstP, getupstlargest(N^.anc, ic))							else if FixancedByUncertain(N^.anc, ic) then								begin {N^.anc^.fixanc and  fixancedbyuncertain; need to filter}									TransferStatesFromLargest(NupstP, closestInAtoB(GetLargestFromPtr(sidednstP), getupstlargest(N^.anc, ic), ctypP^));								end							else  {otherwise put states from fixed ancestor; covers case when fixed terminal  has certain states}								TransferStates(NupstP, sidednstP);						end;					IncrSetPointer(NupstP);					IncrSetpointer(sidednstP);					IncrementCtypPtr(CtypP);				end;			HUnLock(N^.upstH);			HUnLock(SideN^.dnstH);		end;{.........................................................}		procedure InUpPass (N: Nptr);  {й=й=й=й=й=й=й=й=й=RECURSION}{FROZEN 3.0}{This is the recursive procedure which controls the UpPass}{Depending upon whether the node is polytomous, fixanced or not, this procedure}{passes control to the calculation procedures above.  The simple case}{is handled by a fast assembly language procedure}		begin			if (NodeIsInternal(N)) then  {internal node}				begin					if (N <> R) and not N^.null then						begin							if PartOfPolytomy(N) then								UpPolytomous(N)							else if N^.anc = R then  {if just above root, then bring sister's downstates around for upstates}								begin									sideN := Sis(N);									if ist = iend then {only one char done}										SetUpstLargest(N, ist, GetDnstLargest(sideN, ist))									else  {NOTE: this assumes when ist<>iend, that all chars done}										CopyHandles(SideN^.dnstH, N^.upstH)								end							else if N^.anc^.fixanc then								UpFixanced(N)							else								begin   {======  SIMPLE ====}			 	{if not just above root, derive upstates from ancestor's upstates and sister's downstates}									NupstP := SetPtrFromHandleLock(N^.upstH, ist);									NancupstP := SetPtrFromHandleLock(N^.anc^.upstH, ist);									sideN := Sis(N);									SidednstP := SetPtrFromHandleLock(SideN^.dnstH, ist);									ResetCtypPtr(CtypP, ist);{opening pointers to type and lengths of characters}									ResetClenPtr(ClenP, ist);				{********************************}									UpOpC(tcb, NupstP, NancupstP, SidednstP, ctypP, iend - ist + 1);				{********************************}									Unlock3Handles(N^.upstH, N^.anc^.upstH, SideN^.dnstH);								end;    {simple}						end;					InUpPass(N^.lf);					InUpPass(N^.rt);				end;		end; {й=й=й=й=й=й=й=й=й=й=RECURSION}	begin {.............main of uppass......................}		if allowCursorChange then Setcursor(UpPassCurs);{Note that upstates no longer assigned for root}		HLock(ChtypH);		InUpPass(NP);		HUnLock(ChtypH);	end;{==================================================================================}{==================================================================================}	procedure TripleC (NUMbytes: integer; NSP, NlfSP, NrtSP, NupstP: Ptr; chTP: IP; numchars: integer);	external;		procedure TripleASM (NUMbytes: integer; NSP, NlfSP, NrtSP, NupstP: Ptr; chTP: IP; numchars: integer);{FROZEN 3.0}	begin	{Wayne: v3.5 DELETE}	end;{This assembly procedure performs triple node combine for simple cases with unordered and ordered characters}{.........................................................}	procedure TerminalTripleC (Numbytes: integer; NstsP, NancstsP, TstsP, NdnstP: Ptr; CtypP: IP; ichars: integer);	external;	procedure TerminaltripleASM (Numbytes: integer; NstsP, NancstsP, TstsP, NdnstP: Ptr; CtypP: IP; ichars: integer);{FROZEN 3.0}	begin	{Wayne: v3.5 DELETE}	end;{This assembly procedure performs final adjustment of terminal states for simple cases with unordered and ordered characters}{.........................................................}{------------------------------------------}	procedure TriplePass (NP: Nptr; ist, iend: integer; whatOnly: integer);{FROZEN 3.0}{Calculate final states (sts) for chars ist through iend, }{Used only for unord, ord, irrev, fisher, Dollo; }{User-defined types done separately, in unit Genchar.}{if whatonly= everything, then all characters between ist through iend that are}{of a predefined type are dealt with; however,}{if whatonly= dollo, then only the dollo characters are done (this is done when a }{reconstruction is needed only for counting's sake)}{if whatonly= fisher, then only the fisher characters are done (this is done when a }{reconstruction is needed only for counting's sake)}		const			everything = -1;		var			ststemp, belowset: largestsetchars;			ctyp: integer;			ctypP: IP;			TstsP: Ptr;			txhdl: handle;			tempset: largestsetchars;{.........................................................}		procedure TriplePolytomous (N: Nptr);{FROZEN 3.0}{when N is polytomous, N's final for characters ist through iend assigned here}			var				ic: integer;		begin			if ist = iend then				SetStsLargest(N, ist, GetdnstLargest(N, ist))			else				CopyHandles(N^.dnstH, N^.stsH); {default assign downstates as final states (used, e.g., for root)}		{Does not need to ask about whatonly since can't have dollo or fisher with polytomies}			if N <> R then				begin					NdnstP := SetPtrFromHandleLock(N^.dnstH, ist);	{getting pointers}					NstsP := SetPtrFromHandleLock(N^.stsH, ist);					NupstP := SetPtrFromHandleLock(N^.upstH, ist);					ResetCtypPtr(CtypP, ist);{opening pointer to types of characters}					for ic := ist to iend do			{cycle through all characters}						begin							if (ctypP^ <= ordered) then								begin									if not POLYREAL then										begin						{soft polytomy, thus calculate final on internode just below N from up and down}											StSetOpLargest(tempset, GetLargestfromPtr(NdnstP), GetLargestfromPtr(NupstP), ctypP^, lenpl);											TransferstatesFromLargest(NstsP, tempset);										end									else  {hard polytomy, thus calculate final using triple version of Polycalcs}										TransferstatesFromLargest(NstsP, PolyCalcs(N, ic, ctypP^, triple, lenpl, tracedfalse));								end; {charincluded & unord/ord}							IncrSetPointer(NdnstP);{increment pointers}							IncrSetPointer(NstsP);							IncrSetPointer(NupstP);							IncrementCtypPtr(CtypP);						end;					Unlock3Handles(N^.dnstH, N^.stsH, N^.upstH);				end;		end;{.........................................................}		procedure TripleInternalNotSimple (N: Nptr);{FROZEN 3.0}{when internal node is fixanced or there are irreversible or dollo type characters, the simple assembly}{procedures cannot be used and final state calculations are done here.}			var				ic: integer;				NfinalSts, ancpref: largestsetchars;				NNotFixancedP: ptr;		begin		{use downstates as default for final states}			if (ist <> iend) & (whatonly = everything) then  {default is dnst}				CopyHandles(N^.dnstH, N^.stsH);			NdnstP := SetPtrFromHandleLock(N^.dnstH, ist);	{getting pointers}			NlfdnstP := SetPtrFromHandleLock(N^.lf^.dnstH, ist);			NrtdnstP := SetPtrFromHandleLock(N^.rt^.dnstH, ist);			NstsP := SetPtrFromHandleLock(N^.stsH, ist);			NancstsP := SetPtrFromHandleLock(NotNullAnc(N)^.stsH, ist);			NupstP := SetPtrFromHandleLock(N^.upstH, ist);			NlfupstP := SetPtrFromHandleLock(N^.lf^.upstH, ist);			NrtupstP := SetPtrFromHandleLock(N^.rt^.upstH, ist);			if ist = iend then				TransferStates(NstsP, NdnstP);  {default is dnst}			ResetCtypPtr(CtypP, ist);{opening pointer to types of characters}			for ic := ist to iend do				begin					ctyp := ctypP^;					if (ctyp = fisher) & (whatonly = fisher) then {otherwise not transferred}						TransferStates(NstsP, NdnstP);					if (whatonly = everything) | (whatonly = ctyp) then						begin							ancpref := GetLargestFromPtr(NancstsP);							if not N^.fixanc then 				{simple case: node not fixanc}								begin									if ctyp = dollo then				{For dollo use special procedure to calculate final set}										begin {recall dollo prohibits fixanc}											NfinalSts := FinalCombineDollo(GetLargestFromPtr(NlfdnstP), GetLargestFromPtr(NrtdnstP), GetLargestFromPtr(NdnstP), ancpref, N = R, ic);											TransferStatesFromLargest(NstsP, NfinalSts);										end									else if N <> R then				{for other types of characters use triple combining algorithms}										begin											TripleCombineCore(NfinalSts, GetLargestFromPtr(NlfdnstP), GetLargestFromPtr(NrtdnstP), GetLargestFromPtr(NupstP), ancpref, Ctyp);											TransferStatesFromLargest(NstsP, NfinalSts);										end;								end							else  {Fixanced}								begin									Nfixanced := Termoffixanc(N);  {get node above that is fixanced onto N}									if IsTerminalFixanc(N^.lf) then  {get dnstP of descendant of N}										NNotFixancedP := NrtdnstP									else										NNotFixancedP := NlfdnstP;									if (ctyp = fisher) then										begin				{Note: fisher characters treated as fixancedbyuncertain even if fixancedbypoly}				{because need to allow non-minimal values assigned to fixancednode}											if (N = R) then  {if at root, don't need to change unless polymorphic}												begin													if FixancedByPolymorphic(N, ic) then														begin															ancpref := GetLargestFromPtr(NdnstP);															TripleFixancedByUncertain(NfinalSts, GetLargestFromPtr(NNotFixancedP), GetTaxonStsLargest(Nfixanced^.name, ic), ancpref, ctyp);															TransferStatesFromLargest(NstsP, NfinalSts);														end; {otherwise NstsP used from default setting from dnstp}												end											else												begin													if FixancedbyMissing(N, ic) then														TripleFixancedByUncertain(NfinalSts, GetLargestFromPtr(NNotFixancedP), [0..charmaxstDef(ic)], ancpref, ctyp)													else														TripleFixancedByUncertain(NfinalSts, GetLargestFromPtr(NNotFixancedP), GetTaxonStsLargest(Nfixanced^.name, ic), ancpref, ctyp);													TransferStatesFromLargest(NstsP, NfinalSts);												end;										end				{Not fisher: unordered, ordered, and irreversible}									else if N <> R then {if N = R then just use Ndnst as initialized above}										begin											if FixancedbyMissing(N, ic) then					{Note that Fixancedbymissing can fall with triple operators under}					{simple even though there are only two nodes to combine, because missing downstates of fixed}					{terminal will be innocent identity operators}												begin													TripleCombineCore(NfinalSts, GetLargestFromPtr(NlfdnstP), GetLargestFromPtr(NrtdnstP), GetLargestFromPtr(NupstP), ancpref, Ctyp);													TransferStatesFromLargest(NstsP, NfinalSts);												end											else if FixancedByUncertain(N, ic) then												begin													if ctyp = dollo then														Newerror(31, ic) {fixanced and dollo not allowed.  warning here just in case}													else														begin															if (ctyp <= ordered) then																ancpref := GetLargestFromPtr(NupstP);{for irreversible, ancpref is ancsts}															TripleFixancedByUncertain(NfinalSts, GetLargestFromPtr(NNotFixancedP), GetTaxonStsLargest(Nfixanced^.name, ic), ancpref, ctyp);															TransferStatesFromLargest(NstsP, NfinalSts);														end;												end; {if fixancedby polymorphic or monomorphic then states are left as they are from down}										end;								end;						end; {charincluded}					Incr3SetPointers(NdnstP, NlfdnstP, NrtdnstP);					Incr3SetPointers(NstsP, NancstsP, NupstP);					IncrSetPointer(NlfupstP);					IncrSetPointer(NrtupstP);					IncrementCtypPtr(CtypP);				end;			Unlock3Handles(N^.dnstH, N^.lf^.dnstH, N^.rt^.dnstH);			Unlock3Handles(N^.stsH, NotNullAnc(N)^.stsH, N^.upstH);		end;{.........................................................}		procedure TripleTerminalNotSimple (N: Nptr);{Adjusts final states at terminal node N, if any characters are dollo, fisher, or N is part of a polytomy}			var				ic: integer;				Nfinalsts: largestsetchars;		begin			if (ist <> iend) and (whatonly = everything) then {default is dnst}				CopyHandles(N^.dnstH, N^.stsH);			NdnstP := SetPtrFromHandleLock(N^.dnstH, ist);{get pointer to first downstate location}			NstsP := SetPtrFromHandleLock(N^.stsH, ist);			NancstsP := SetPtrFromHandleLock(NotNullAnc(N)^.stsH, ist);			NupstP := SetPtrFromHandleLock(N^.upstH, ist);			if ist = iend then				TransferStates(NstsP, NdnstP);   {default is dnst}			ResetCtypPtr(CtypP, ist);{opening pointer to types of characters}			for ic := ist to iend do				begin					ctyp := ctypP^;					if (ctyp = fisher) & (whatonly = fisher) then {otherwise not transferred above}						TransferStates(NstsP, NdnstP);					if (ctyp <> excluded) & ((whatonly = everything) | (ctyp = whatonly)) then						begin							Nfinalsts := GetLargestfromPtr(NdnstP);							lenpl := 0;  {dummy variable to absorb length increase}							if Qtaxon(N, ic) | (MStaxon(N, ic) and not (ctyp = dollo)) then	{if missing data or multiple states, state assigned}								begin									if PartOfPolytomy(N) and not polyreal then				{if ancestor is soft polytomous, state assigned by uppass preference from below,}				{but since uppass not done previously for terminal nodes, Polycalcs is called right here to get}				{what would have been uppass states}										TerminalFilterCore(Nfinalsts, PolyCalcs(N, ic, ctyp, up, lenpl, tracedfalse) + [FTl], gettaxonstsLargest(N^.name, ic), ctyp)									else {otherwise assign ancestor's state}										TerminalFilterCore(Nfinalsts, GetLargestFromPtr(NancstsP), gettaxonstsLargest(N^.name, ic), ctyp);  {assumes irrev will fall here because no nulls}								end							else if ctyp = dollo then								begin				{need to reassign here because N^.final cannot be left as downstate}				{because the latter is packed in the special dollo format}									ststemp := gettaxonstslargest(N^.name, ic);									if MultipleStatesLg(ststemp) then				{uncertain or polymorphic state; assign state in range of those observed closest to state below}										Nfinalsts := ClosestInAtoB(SpanLg(ststemp), GetLargestFromPtr(NancstsP), dollo)									else										Nfinalsts := ZeroHighBitsLg(ststemp);								end;							TransferStatesFromLargest(NstsP, Nfinalsts);						end; {charincluded}					Incr3SetPointers(NstsP, NancstsP, NupstP);					IncrSetPointer(NdnstP);{increment pointers}					IncrementCtypPtr(CtypP);				end;			Unlock3Handles(N^.stsH, NotNullAnc(N)^.stsH, N^.upstH);		end;{.........................................................}		procedure InTriplePass (N: Nptr); {й=й=й=й=й=й=й=й=RECURSION}		begin			if (NodeIsInternal(N)) then {====== internal}				begin					if not N^.null then						begin							if NodeIsPolytomous(N) then								TriplePolytomous(N)							else if N^.fixanc | Anytype([irreversible, fisher, dollo]) then								TripleInternalNotSimple(N)							else								begin  {===SIMPLE===}									if N <> R then										begin											NdnstP := SetPtrFromHandleLock(N^.dnstH, ist);	{getting pointers}											NlfdnstP := SetPtrFromHandleLock(N^.lf^.dnstH, ist);											NrtdnstP := SetPtrFromHandleLock(N^.rt^.dnstH, ist);											NstsP := SetPtrFromHandleLock(N^.stsH, ist);											NancstsP := SetPtrFromHandleLock(NotNullAnc(N)^.stsH, ist);											NupstP := SetPtrFromHandleLock(N^.upstH, ist);											ResetCtypPtr(CtypP, ist);{opening pointer to types of characters}					{********************************}											TripleC(tcb, NstsP, NlfdnstP, NrtdnstP, NupstP, ctypP, iend - ist + 1);					{********************************}											Unlock3Handles(N^.dnstH, N^.lf^.dnstH, N^.rt^.dnstH);											Unlock3Handles(N^.stsH, NotNullAnc(N)^.stsH, N^.upstH);										end									else if ist <> iend then										CopyHandles(N^.dnstH, N^.stsH)									else										SetStsLargest(N, ist, GetDnstLargest(N, ist));								end;						end; {not null}					InTriplePass(N^.lf);					InTriplePass(N^.rt);				end {Internal node}			else if not N^.fixanc then  {======== terminal}				begin					if not (PartOfPolytomy(N) or Anytype([dollo])) then						begin							HLock(TaxstsChunks);							txhdl := HdlPtr(GetMaster(TaxstsCHUNKs) + HdlSize * ord4(N^.name - 1))^;							NstsP := SetPtrFromHandleLock(N^.stsH, ist);							NancstsP := SetPtrFromHandleLock(NotNullAnc(N)^.stsH, ist);							TstsP := SetPtrFromHandleLock(txhdl, ist);							NdnstP := SetPtrFromHandleLock(N^.dnstH, ist);{get pointer to first downstate location}							ResetCtypPtr(CtypP, ist);{opening pointer to types of characters}			{********************************}							TerminalTripleC(tcb, NstsP, NancstsP, TstsP, NdnstP, CtypP, iend - ist + 1);			{********************************}							Unlock3Handles(N^.stsH, N^.anc^.stsH, txhdl);							HUnLock(TaxstsChunks);							HUnLock(N^.dnstH);						end					else						TripleTerminalNotSimple(N);				end; {terminal node}		end; 					{й=й=й=й=й=й=й=й=й=RECURSION}	begin {.............main of triplepass......................}		if allowCursorChange then Setcursor(TriplePassCurs);		HLock(chtypH);		InTriplePass(NP);		HUnLock(chtypH);		if allowCursorChange then SetCursorToArrow;	end;end.