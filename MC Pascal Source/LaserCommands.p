unit LaserCommands;{еееееееееееееееееееееее}interface	uses		Printing, QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, 		Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, 		EventUtil, GenUtil, TaxonCHUtil, StrUtil, BoxUtil, TraceAllChangesCalc, Coloring, LaserDLOGDraw, 		TreeGet, PrintingUtil, PrintingMisc, LaserTreeUtil, TraceAllChangesOptions;	procedure DoOtherBranchWidth;	procedure MouseInBranchWidth (offset: integer);	procedure FixPrOptionsMenu;	procedure PopUpOptionsMenu (theDialog: DialogPtr);{еееееееееееееееееееееее}implementation {е$S LaserCommands}	const		pageV = 22;		pageH = 16;		maxVpages = 8;		maxHpages = 16;	var		maxpagesB, pagesB: rect;		thePoint: point;{||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	procedure DoOtherBranchWidth;		var			TD: DialogPtr;			tlaserwidth: integer;			tempP: WindowPtr;			ds: str255;			localItemHit: integer;	begin		if PaintedBranches then			tlaserwidth := laser^.tracewidth		else			tlaserwidth := laser^.width;		StartDLOG(348, TD, tempP);		if tlaserwidth = 0 then			SetDLOGText(TD, 3, 'hairline', true)		else			SetDLOGText(TD, 3, StringFromNum(tlaserwidth), true);		myShowDialog(TD);		FrameButton(TD, 1);		repeat			ModalDialog(nil, localItemHit);		until localItemHit in [1, 2];		if localItemHit = 1 then			begin				ds := GetEditText(TD, 3);				if MakeCaps(ds) = 'HAIRLINE' then					tlaserwidth := 0				else					begin						tlaserwidth := EditTextInt(TD, 3,true);						if tlaserwidth = 0 then							tlaserwidth := -1;					end;			end;		EndDLOG(TD, tempP);		if localItemHit = 1 then			begin				if (tlaserwidth < 0) or (tlaserwidth >= laser^.txsp) then					Beep				else					begin						InvalidateWindowRect(myGetWindowPtrForDialog(LaserTreeDialog),drawbox,false);						if PaintedBranches then							laser^.tracewidth := tlaserwidth						else							laser^.width := tlaserwidth;					end;			end;	end;{||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	procedure PagesUser (TD: DialogPtr; itemNo: INTEGER);		var			j: integer;	begin		EraseRect(maxPagesB);		pagesB := maxPagesB;		pagesB.right := pagesB.left + pageH * thePoint.h;		pagesB.bottom := pagesB.top + pageV * thePoint.v;		maxpagesB.bottom := maxpagesB.bottom + 2;		maxpagesB.right := maxpagesB.right + 2;		FrameShadowRect(maxPagesB);		maxpagesB.bottom := maxpagesB.bottom - 2;		maxpagesB.right := maxpagesB.right - 2;		PenPat(QDGray);		for j := 1 to maxHpages - 1 do			begin				moveto(maxPagesB.left + j * pageH, maxpagesB.top);				lineto(maxPagesB.left + j * pageH, maxpagesB.bottom - 2);			end;		for j := 1 to maxVpages - 1 do			begin				moveto(maxpagesB.left, maxPagesB.top + j * pageV);				lineto(maxpagesB.right - 2, maxPagesB.top + j * pageV);			end;		PenPat(QDBlack);		InvertRect(pagesB);	end;{----------------------------------------------------------------------------}	function PagesFilter (TD: DialogPtr; var Event: EventRecord; var localItemHit: INTEGER): BOOLEAN;		var			itemtype: integer;			okrect, box: rect;			oldpagesRgn, pagesRgn: RgnHandle;			tempH: handle;			wh: point;	begin		oldpagesRgn := NewRgn;		pagesRgn := NewRgn;		PagesFilter := FALSE;		GlobalToLocal(Event.where);		if (Event.what = keyDown) and HitReturn(Event) then			begin				localItemHit := PressButton(TD, 1);				PagesFilter := true;			end;		if (Event.what = mouseDown) then			begin				if PtInREct(event.where, maxpagesB) then					begin						repeat							RectRgn(oldpagesRgn, pagesB);							GetMouse(wh);							if PtInRect(wh, maxPagesB) then								begin									thePoint.h := (wh.h - maxpagesB.left) div pageH + 1;									thePoint.v := (wh.v - maxpagesB.top) div pageV + 1;									pagesB := maxPagesB;									pagesB.right := pagesB.left + pageH * thePoint.h;									pagesB.bottom := pagesB.top + pageV * thePoint.v;									RectRgn(pagesRgn, pagesB);									XorRgn(pagesRgn, oldpagesRgn, pagesRgn);									{BitClr(Ptr($938), pHiliteBit);   v4: use constant}									InvertRgn(pagesRgn);								end;						until not stilldown;						PagesFilter := TRUE;						localItemHit := NotInDialog;					end;			end;		LocaltoGlobal(Event.where);		ZapRegion(oldpagesRgn);		ZapRegion(pagesRgn);	end;{-----------------------------------------------------------------------------}	procedure DoPages (var dpt: point; dotreepages: boolean);		var			TD: DialogPtr;			itemtype: integer;			tempP: WindowPtr;			tempH: Handle;			box: rect;			haschanged: boolean;			localItemHit: integer;DLOGFilterUPP: UniversalProcPtr;UserItemUProcP: UniversalProcPtr;	begin		thePoint := dpt;		StartDLOG(347, TD, tempP);UserItemUProcP := MyNewUserItemUPP(@PagesUser);  tempH := Handle(UserItemUProcP);		SetDialogItem(TD, 3, UserItem, tempH, box);		SetRect(maxPagesB, 45, 27, 45 + pageH * maxHpages, 27 + pageV * maxVpages);		if dotreepages then			ParamText('pages for image', '', '', '')		else			ParamText('trees per page', '', '', '');		myShowDialog(TD);		FrameButton(TD, 1);		DLOGFilterUPP := MyNewModalFilterUPP(@PagesFilter);  		repeat			myModalDialog(DLOGFilterUPP, localItemHit);		until localItemHit in [1, 2];		LaserTreeParamText;		MyDisposeUserItemUPP(UserItemUProcP);MyDisposeModalFilterUPP(DLOGFilterUPP);		EndDLOG(TD, tempP);		if localItemHit = 1 then			begin				haschanged := not EqualPt(dpt, thePoint);				if haschanged then					closeupon := false;				if dotreepages then					laser^.treepages := thePoint				else					laser^.treesPerPage := thePoint;				dpt := thePoint;				if haschanged then					SetPreviewRects(true);				InvalidateWindowRect(myGetWindowPtrForDialog(LaserTreeDialog),previewB,false);			end;	end;{----------------------------------------------------------------------------}	procedure PhyloUser (theDialog: DialogPtr; itemNo: INTEGER);	begin		FrameButton(theDialog, 1);		if (branchlistmode <> minmaxmode) or not laser^.printbranchlengths then			begin				DimBox(GetDLOGItemBox(theDialog, 15));				DimBox(GetDLOGItemBox(theDialog, 19));			end;		if not laser^.printbranchlengths then			begin				DimBox(GetDLOGItemBox(theDialog, 14));				DimBox(GetDLOGItemBox(theDialog, 24));   {v3.04}			end;	end;{----------------------------------------------------------------------------}	procedure DoPhylogram;		label			1;		const			cladogramitem = 5;			phylogramitem = 8;			scaleitem = 10;			PixValueItem = 12;			manualPixItem = 11;			mmMinItem = 16;			mmMeanItem = 17;			mmMaxItem = 18;			mmShowBarsItem = 20;			mmShowTicksItem = 21;			mmDontShowItem = 22;			autoheightenItem = 23;			manPixAccessoryItem = 24;		var			theDialog: DialogPtr;			tempP: WindowPtr;			oldLPPCconstant, oldprintbranchlengths, oldscaleon: boolean;			box: rect;			H, LPPCH, tempH: Handle;			tLPPC: longint;			itemtype: integer;			ds: str255;			j: integer;			localItemHit: integer;			oldmmEnd, oldmmShow: SignedByte;UserItemUProcP: UniversalProcPtr;{......}		procedure FixPhylogramControls;		begin			ItemCheckMark(theDialog, CladogramItem, not laser^.printbranchlengths);			ItemCheckMark(theDialog, PhylogramItem, laser^.printbranchlengths);			EnableDisableDLOGItem(theDialog, scaleItem, laser^.printbranchlengths, false);			EnableDisableDLOGItem(theDialog, ManualPixItem, laser^.printbranchlengths, false);			EnableDisableDLOGItem(theDialog, autoheightenItem, not ((branchlistmode = minmaxmode) & (laser^.mmEnd <> mmMax)) & not branchlengthsweighted & laser^.printbranchlengths & laser^.LPPCconstant & (summaryview = asticks), false);  {v3.02}			ItemCheckMark(theDialog, scaleitem, laser^.scaleon);			ItemCheckMark(theDialog, ManualPixItem, laser^.LPPCconstant);			if not laser^.printbranchlengths then				begin					DimBox(GetDLOGItemBox(theDialog, 14));					DimBox(GetDLOGItemBox(theDialog, manPixAccessoryItem));   {v3.04}				end			else				begin					InvalidateWindowRect(myGetWindowPtrForDialog(LaserTreeDialog),GetDLOGItemBox(theDialog, 14),false);					InvalidateWindowRect(myGetWindowPtrForDialog(LaserTreeDialog),GetDLOGItemBox(theDialog, manPixAccessoryItem),false);   {v3.04}				end;			if branchlistmode = minmaxmode then				begin					EnableDisableDLOGItem(theDialog, mmShowBarsItem, laser^.printbranchlengths, false);					EnableDisableDLOGItem(theDialog, mmShowTicksItem, laser^.printbranchlengths, false);					EnableDisableDLOGItem(theDialog, mmDontShowItem, laser^.printbranchlengths, false);					EnableDisableDLOGItem(theDialog, mmMinItem, laser^.printbranchlengths, false);					EnableDisableDLOGItem(theDialog, mmMeanItem, laser^.printbranchlengths, false);					EnableDisableDLOGItem(theDialog, mmMaxItem, laser^.printbranchlengths, false);					ItemCheckMark(theDialog, mmShowBarsItem, laser^.mmShow = mmShowBars);					ItemCheckMark(theDialog, mmShowTicksItem, laser^.mmShow = mmShowTicks);					ItemCheckMark(theDialog, mmDontShowItem, laser^.mmShow = mmDontShow);					ItemCheckMark(theDialog, mmMinItem, laser^.mmEnd = mmMin);					ItemCheckMark(theDialog, mmMeanItem, laser^.mmEnd = mmMean);					ItemCheckMark(theDialog, mmMaxItem, laser^.mmEnd = mmMax);					if laser^.printbranchlengths then						begin							InvalidateWindowRect(myGetWindowPtrForDialog(LaserTreeDialog),GetDLOGItemBox(theDialog, 15),false);							InvalidateWindowRect(myGetWindowPtrForDialog(LaserTreeDialog),GetDLOGItemBox(theDialog, 19),false);						end					else						begin							DimBox(GetDLOGItemBox(theDialog, 15));							DimBox(GetDLOGItemBox(theDialog, 19));						end;				end;		end; {......}	begin		oldprintbranchlengths := laser^.printbranchlengths;		oldmmEnd := laser^.mmEnd;		oldscaleon := laser^.scaleon;		oldmmShow := laser^.mmShow;		oldLPPCconstant := laser^.LPPCconstant;		StartDLOG(402, theDialog, tempP);		if branchlistmode <> minmaxmode then			begin				EnableDisableDLOGItem(theDialog, mmShowBarsItem, false, false);				EnableDisableDLOGItem(theDialog, mmShowTicksItem, false, false);				EnableDisableDLOGItem(theDialog, mmDontShowItem, false, false);				EnableDisableDLOGItem(theDialog, mmMinItem, false, false);				EnableDisableDLOGItem(theDialog, mmMeanItem, false, false);				EnableDisableDLOGItem(theDialog, mmMaxItem, false, false);			end;		if branchlengthsweighted then   {v3.02}			if (realwt or realtypes) then				SetDLOGText(theDialog, manPixAccessoryItem, concat(LengthString(1, true), ' step to:'), false)			else				SetDLOGText(theDialog, manPixAccessoryItem, 'one change to:', false)		else			SetDLOGText(theDialog, manPixAccessoryItem, 'one change to:', false);		SetDLOGText(theDialog, PixValueItem, StringFromNum(laser^.LPPCvalue), true);UserItemUProcP := MyNewUserItemUPP(@PhyloUser);  tempH := Handle(UserItemUProcP);		SetDialogItem(thedialog, 25, UserItem, tempH, box);		FixPhylogramControls;		myShowDialog(theDialog);1:		repeat			ModalDialog(nil, localItemHit);			case localItemHit of				3..5: 					laser^.printbranchlengths := false;				6..12, manPixAccessoryItem: 					begin						laser^.printbranchlengths := true;						if localItemHit = scaleitem then							laser^.scaleon := not laser^.scaleon						else if (localItemHit = ManualPixitem) or (localItemHit = manPixAccessoryItem) then							laser^.LPPCconstant := not laser^.LPPCconstant;					end;				mmMinItem: 					laser^.mmEnd := mmMin;				mmMeanItem: 					laser^.mmEnd := mmMean;				mmMaxItem: 					laser^.mmEnd := mmMax;				mmShowBarsItem: 					laser^.mmShow := mmShowBars;				mmShowTicksItem: 					laser^.mmShow := mmShowTicks;				mmDontShowItem: 					laser^.mmShow := mmDontShow;				autoheightenItem: 					begin						AutoPrintTreeTicksHeighten;						SetDLOGText(theDialog, PixValueItem, StringFromNum(laser^.LPPCvalue), true)					end;				otherwise					;			end;			FixPhylogramControls;		until localItemHit in [1, 2];		tLPPC := EditTextInt(theDialog, PixValueItem,true);		if tLPPC = 0 then			goto 1		else			laser^.LPPCvalue := tLPPC;MyDisposeUserItemUPP(UserItemUProcP);		EndDLOG(theDialog, tempP);		if localItemHit = 2 then			begin				laser^.printbranchlengths := oldprintbranchlengths;				laser^.scaleon := oldscaleon;				laser^.LPPCconstant := oldLPPCconstant;				laser^.mmEnd := oldmmEnd;				laser^.mmShow := oldmmShow;			end		else			begin				InvalidateWindowRect(myGetWindowPtrForDialog(LaserTreeDialog),previewB,false);				for j := 0 to numtreeshapes do					begin						EraseRect(laser^.treeshapeB[j]);						InvalidateWindowRect(myGetWindowPtrForDialog(LaserTreeDialog),laser^.treeshapeB[j],false);					end;				box := branchWidthB;				box.bottom := otherBranchWidthB.bottom;				InsetRect(box, -6, -6);				EraseRect(box);				InvalidateWindowRect(myGetWindowPtrForDialog(LaserTreeDialog),box,false);				if not SummaryViewPrintLegal(summaryview) then					summaryview := asblack;			end;		if not laser^.printbranchlengths then			laser^.scaleon := false;	end;{-----------------------------------------------------------------------------}	procedure LaserBoxesOptions;		type			showarray = array[2..numlaserB] of boolean;		var			TD: DialogPtr;			j: integer;			tempP: WindowPtr;			B: REct;			oldshow: showarray;			oldshowsteps, oldshowtype: boolean;			oldState: SignedByte;			localItemHit: integer;{.........}		function theLB (theItem: integer): integer;		begin			case theItem of				4: 					theLB := treestatsB;				5: 					theLB := treenamB;				6: 					theLB := commentB;				7: 					theLB := legB;				9: 					theLB := treenumB;			end;		end;{.........}	begin		for j := 2 to numlaserB do			oldshow[j] := laser^.showbox[j];		oldshowsteps := laser^.showstepslaser;		oldshowtype := laser^.showtype;		StartDLOG(579, TD, tempP);		LockHandle(LaserCommentSH, oldstate);		SetDLOGText(TD, 8, LaserCommentSH^^, true);		ResetHandle(LaserCommentSH, oldstate);		for j := 4 to 7 do			ItemCheckMark(TD, j, laser^.showbox[theLB(j)]);		ItemCheckMark(TD, 9, laser^.showbox[theLB(9)]);		EnableDisableDLOGItem(TD, 7, PaintedBranches or ((traceshown = traceAllChanges) and not (summaryview = asblack)) or (traceshown = traceProbability), true);		ItemCheckMark(TD, 11, laser^.showstepslaser);		EnableDisableDLOGItem(TD, 11, (traceshown = traceDiscrete) or (traceshown = traceContinuous), true);		ItemCheckMark(TD, 12, laser^.showtype);		EnableDisableDLOGItem(TD, 12, (traceshown = traceDiscrete), true);		myShowDialog(TD);		FrameButton(TD, 1);		repeat			ModalDialog(nil, localItemHit);			if localItemHit in [4..7, 9] then				begin					j := theLB(localItemHit);					laser^.showbox[j] := not laser^.showbox[j];					ItemCheckMark(TD, localItemHit, laser^.showbox[j]);				end			else if localItemHit = 11 then				begin					laser^.showstepslaser := not laser^.showstepslaser;					ItemCheckMark(TD, 11, laser^.showstepslaser);				end			else if localItemHit = 12 then				begin					laser^.showtype := not laser^.showtype;					ItemCheckMark(TD, 12, laser^.showtype);				end;		until localItemHit in [1, 2];		if localItemHit = 1 then			LaserCommentSH^^ := GetEditText(TD, 8);		EndDLOG(TD, tempP);		InvalidateWindowRect(myGetWindowPtrForDialog(LaserTreeDialog),previewB,false);		if localItemHit = 1 then			begin				InvalidateWindowRect(myGetWindowPtrForDialog(LaserTreeDialog),previewB,false);				defLaserShowCHLeg := laser^.showbox[legB];			end		else			begin				for j := 2 to numlaserB do					laser^.showbox[j] := oldshow[j];				laser^.showstepslaser := oldshowsteps;				laser^.showtype := oldshowtype;			end;	end;{----------------------------------------------------------------------------}	procedure DoShadesMenu (ItemNo: integer);		var			box: rect;			spot: point;			menucode: longint;			ds: str255;	begin		if ItemNo > 0 then			begin				case ItemNo of					ForceGraysItem: 						laser^.branchShades[curTrace] := branchGrayScale;					ForcePatternsItem: 						laser^.branchShades[curTrace] := branchPatterns;					ForceColorsItem: 						laser^.branchShades[curTrace] := branchColors;					otherwise						;				end;				if PaintedBranches then					InvalidateWindowRect(myGetWindowPtrForDialog(LaserTreeDialog),previewB,false);			end;		branchShades[curTrace] := laser^.branchShades[curTrace];	end;{----------------------------------------------------------------------------}	procedure FixPrOptionsMenu;	begin		{myCheckMenuItem(PrOptionsMHdl, PrWhichTrees, numtreeschosen > 1);}		myCheckMenuItem(PrOptionsMHdl, PrWhichChars, (traceshown = traceDiscrete) and laser^.multicharacters);		myCheckMenuItem(PrOptionsMHdl, PrEquiv, (traceshown = traceDiscrete) and laser^.printequiv);		myCheckMenuItem(PrOptionsMHdl, PrAngledNames, laser^.postscripton);		myCheckMenuItem(PrOptionsMHdl, PrCondensedTree, laser^.condensedTree);		myCheckMenuItem(ShadesMHdl, ForcePatternsItem, laser^.branchShades[curTrace] = branchPatterns);		myCheckMenuItem(ShadesMHdl, ForceGraysItem, laser^.branchShades[curTrace] = branchGrayScale);		myCheckMenuItem(ShadesMHdl, ForceColorsItem, laser^.branchShades[curTrace] = branchColors);		EnableDisableItem(PrOptionsMHdl, PrCondensedTree, laser^.treeshape[squaretree] | laser^.treeshape[eurotree]);		EnableDisableItem(PrOptionsMHdl, PrTreesPerPage, LaserTreePrint and ((laser^.treepages.v = 1) and (laser^.treepages.h = 1)));		EnableDisableItem(PrOptionsMHdl, PrPages, (laser^.treesPerPage.v = 1) and (laser^.treesPerPage.h = 1));	end;{----------------------------------------------------------------------------}	procedure PopUpOptionsMenu (theDialog: DialogPtr);		var			box: rect;			spot: point;			menucode: longint;			ItemNo, Menu_No, theItem: integer;			ds: str255;			db: boolean;	begin		myValidRect(myGetWindowPtrForDialog(theDialog),WindowPortRect(myGetWindowPtrForDialog(theDialog)));		box := GetDLOGITemBox(theDialog, LOptionsItem);		spot.v := box.bottom + 2;		spot.h := box.left;		LocalToGlobal(spot);		menucode := PopUpMenuSelect(PrOptionsMHdl, spot.v, spot.h, 1);		Menu_No := HighWord(menucode);		ItemNo := LowWord(menucode);		if ItemNo > 0 then			if Menu_No = ShadesMenu then				begin					if colorQDExists then						DoShadesMenu(ItemNo);				end			else				begin					case ItemNo of						{PrWhichTrees: 							if (numtreeschosen >= 1) then								begin									numtreeschosen := 0;									curtreechosen := true;								end							else								begin									ParamText('Select trees to print:', '', '', '');									db := GetTree(GTmultiprint);									if not LaserTreePrint then										ParamText('Graphics File Options', '', '', '')									else										ParamText('Tree Printing Options', '', '', '');								end;}						PrWhichChars: 							if (traceshown = traceDiscrete) then								laser^.multicharacters := not laser^.multicharacters;						PrEquiv: 							laser^.printequiv := not laser^.printequiv;						PrTextBoxes: 							LaserBoxesOptions;						PrCondensedTree:							begin								laser^.condensedTree := not laser^.condensedTree;								InvalidateWindowRect(myGetWindowPtrForDialog(LaserTreeDialog),previewB,false);							end;						PrAngledNames: 							begin								laser^.postscripton := not laser^.postscripton;								if not laser^.postscripton then									begin										laser^.nameAnglePt.h := 0;										laser^.nameAnglePt.v := -40;										SetAngleControlBox;									end;								CleanAngleControl;								InvalidateWindowRect(myGetWindowPtrForDialog(LaserTreeDialog),previewB,false);							end;						PrPageSetUp: 							begin								DoPageSetUp;								SetPreviewRects(true);								InvalidateWindowRect(myGetWindowPtrForDialog(LaserTreeDialog),previewB,false);							end;						PrPages: 							DoPages(laser^.treepages, true);						PrTreesPerPage: 							DoPages(laser^.treesPerPage, false);						PrBranchLengths: 							if laser^.treeshape[squaretree] then								DoPhylogram							else								InstantError(207);						PrTicks: 							if OptionDown & (traceShown=traceAllChanges) then								begin									if not laser^.treeshape[squaretree] then										ChangeToSquareTree;									laser^.printbranchlengths := true;									summaryview := asticks;									laser^.summaryview := asticks;								end							else								begin									if (traceshown = traceAllChanges) & ChangesDisplay(true) then										begin											QueryChangeTreeShapeForTicksPrint;											if not SummaryViewPrintLegal(summaryview) then												summaryview := asblack;											if summaryview = aspattern then												DrawBullets(laser^.tracewidth)											else												DrawBullets(laser^.width);											LegendBoxPosition(true);											InvalidateWindowRect(myGetWindowPtrForDialog(LaserTreeDialog),previewB,false);	{laser^.showbox[legB] := (summaryview <> asblack);}										end									else if not (traceshown = traceAllChanges) then										begin											if (traceshown = traceDiscrete) then												CharTraceLabelDLOG {in Coloring}											else if (traceshown = traceContinuous) then												ContTraceLabelDLOG; {in Coloring}											InvalidateWindowRect(myGetWindowPtrForDialog(LaserTreeDialog),previewB,false);										end;								end;						otherwise							;					end;				end;	end;{----------------------------------------------------------------------------}	procedure MouseInBranchWidth (offset: integer);		var			oldlaserwidth, laserwid: integer;	begin		if PaintedBranches then			oldlaserwidth := laser^.tracewidth		else			oldlaserwidth := laser^.width;		if (offset < 7) then			if PaintedBranches then				begin					laserwid := oldlaserwidth;					Beep;				end			else				laserwid := 0		else if (offset < BWInterval + 7) then			if PaintedBranches then				begin					laserwid := oldlaserwidth;					Beep;				end			else				laserwid := 1		else if (offset < 2 * BWInterval + 6) then			laserwid := 2		else if (offset < 3 * BWInterval + 6) then			laserwid := 3		else if (offset < 4 * BWInterval + 6) then			laserwid := 4		else			laserwid := 5;		DrawBullets(laserwid);		if laserwid <> oldlaserwidth then			begin				InvalidateWindowRect(myGetWindowPtrForDialog(LaserTreeDialog),drawbox,false);				if PaintedBranches then					laser^.tracewidth := laserwid				else					laser^.width := laserwid;			end;	end;end.