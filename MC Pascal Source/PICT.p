unit PICT;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, 		TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap, 		 Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, 		 ErrorUtil, EventUtil, GenUtil, TaxonCHUtil, ReadWriteUtil;	procedure GetPICT (pictFS: FSSpec; var thepictureH: PicHandle);	procedure PutPICTData (dataPtr: Ptr; byteCount: integer);	procedure PutPICT (pictureH: pichandle);	function PictToPict (var frompict, topict: PicHandle): boolean;	procedure myCutCopyPicture(var pictH: PicHandle);	var		pictfilenum: integer;{еееееееееееееееееееееее}implementation {е$S PICT}{-----------------------------------------------------------------------------}	procedure GetPICTData (dataPtr: Ptr; byteCount: integer);		var			err: integer;			longcount: longint;	begin		longcount := bytecount;		err := FSRead(pictfilenum, longcount, dataptr);	end;{-----------------------------------------------------------------------------}	procedure GetPICT (pictFS: FSSpec; var thepictureH: PicHandle);		label			1;		var			err: oserr;			myProcs: QDProcs;			myCprocs: cQDProcs;			longcount: longint;			oldstate: SignedByte;			curFPos: longint;			db: boolean;			box: Rect;    		UPP: QDGetPicUPP;	begin		UPP := QDGetPicUPP(MyNewQDGetPicUPP(@GetPICTData));		//UPP := NewRoutineDescriptor(@GetPICTData, uppQDGetPicProcInfo, GetCurrentISA);  		Err := FSpOpenDF(pictFS,fsCurPerm,pictfilenum);		if err <> noerr then			begin				NewError(344, 0);				goto 1;			end;{$IFC NOT CARBON}		if not colorQDexists then			begin				SetStdProcs(myProcs);				QDThePort^.grafprocs := @myprocs;				myprocs.getpicproc := UPP;  			end		else			begin				SetStdCProcs(mycProcs);				QDThePort^.grafprocs := @mycprocs;{$ENDC}				mycProcs.getpicproc := UPP;  {$IFC NOT CARBON}			end;{$ENDC}		newpicthand := PicHandle(NewHandle(sizeof(picture)));		err := SetFPos(pictfilenum, fsfromstart, 512);{$IFC NOT CARBON}		longcount := sizeof(picture);{$ELSEC}  		err := GetFPos(pictFileNum,curFPos);  // this is new code 12 Nov 2003; in test		err := GetEOF(pictFileNum,longCount);		longCount := longCount-curFPos;{$ENDC}		err := FSREad(pictfilenum, longcount, Ptr(GetMaster(Handle(newpicthand))));		box := newPictHand^^.picFrame;		thepictureH := OpenNewPicture(box);		ClipRect(box);		DrawPicture(newpicthand, box);		ClosePicture;		if IOSuccessful(FSClose(pictfilenum)) then			db := IOSuccessful(FlushVol(nil,pictFS.vRefNum));{$IFC NOT CARBON}		QDThePort^.grafprocs := nil;{$ENDC}1:		MyDisposeQDGetPicUPP(UniversalProcPtr(UPP));	end;{----------------------------------------------------------------------------}	procedure PutPICTData (DataMatrixPtr: Ptr; byteCount: integer);		var			longcount: longint;	begin		longCount := bytecount;		PICTcount := PICTcount + bytecount;		resultcode := FSWrite(pictfilenum, longcount, DataMatrixPtr);		if newpicthand <> nil then			newpicthand^^.picSize := PICTcount;	end;{$IFC FALSE}FUNCTION DoSavePICTAsCmd(picH: PicHandle): OSErr;LABEL 8,9;VARmyReply: StandardFileReply;err, ignore: OSErr;pictFileRefNum: Integer;dataLength, zeroData, count: LongInt;BEGIN {display the default Save dialog box}PutStandardFile('Save picture as:','untitled',myReply);err := noErr; {return noErr if the user cancels}IF myReply.sfGood THENBEGINIF NOT myReply.sfReplacing THEN {create the file if it doesn't exist}err := FSpCreate(myReply.sfFile,'WAVE','PICT',smSystemScript);IF err <> noErr THEN GOTO 9;err := FSpOpenDF(myReply.sfFile,fsRdWrPerm,pictFileRefNum); {open file}IF err <> noErr THEN GOTO 8;zeroData := 0;dataLength := 4;FOR count := 1 TO 512 DIV dataLength DO {write the PICT file header}err := FSWrite(pictFileRefNum,dataLength,@zeroData); {for this app, put 0's in header}IF err <> noErr THEN GOTO 8;dataLength := GetHandleSize(Handle(picH));HLock(Handle(picH)); {lock picture handle before writing data}err := FSWrite(pictFileRefNum,dataLength,Ptr(picH^)); {write picture }{ data to file}HUnlock(Handle(picH)); {unlock picture handle after writing data}END;8:ignore := FSClose(pictFileRefNum); {close the file}9:DoSavePICTAsCmd := err;END;FUNCTION MyReplacePutPic: QDProcsPtr;VARcurrPort: GrafPtr;customProcs: QDProcs;customCProcs: CQDProcs;savedProcs: QDProcsPtr;BEGINgenericGetPort(currPort);savedProcs := currPort^.grafProcs; {save QDProcs or CQDProcs record }{ for current graphics port}IF MyIsColorPort(currPort) THEN {see Listing 7-4 on page 7-16}BEGINSetStdCProcs(customCProcs); {create new CQDProcs record containing }{ standard Color QuickDraw low-level }{ routines}customCProcs.putPicProc := @MyFilePutPic; {replace StdPutPic with }{ address of custom }{ low-level routine }{ shown in Listing 7-11}currPort^.grafProcs := @customCProcs; {replace current CQDProcs}ENDELSEBEGIN {perform similar work for a basic graphics port}SetStdProcs(customProcs);customProcs.putPicProc := @MyFilePutPic;currPort^.grafProcs := @customProcs;END;gPictureSize := 0; {track the picture size}gSpoolPicture := PicHandle(NewHandle(0));MyReplacePutPic := savedProcs; {return saved CQDProcs or QDProcs }{ record for restoring at a later time}END;{$ENDC}{----------------------------------------------------------------------------}	procedure PutPICT (pictureH: pichandle);		var			j: integer;			tempP: WindowPtr;			longCount, longZero: longint;			err: oserr;			db: boolean;			reply: StandardFileReply;			myProcs: QDProcs;			myCprocs: cQDProcs;			savedProcs: QDProcsPtr;    			UPP: UniversalProcPtr;			box: rect;			currPort: WindowPtr;	begin		genericGetPort(tempP);		PutStandardFile('Save PICT file as:', 'Untitled', reply);		ShowCursor;		genericSetPort(tempP);		if reply.sfgood then			begin				UPP := MyNewQDPutPicUPP(@putPICTdata);  				err := FSpCreate(reply.sfFile, pictCreator, 'PICT',scriptTag);				if (err = noerr) or (err = dupfnerr) then					begin						if err = dupfnerr then							FSpSetFileCreatorType(reply.sfFile, pictCreator, 'PICT');						if FSpOpenDF(reply.sfFile,fsCurPerm, pictfilenum) = noErr then							begin								genericGetPort(currPort);{$IFC NOT CARBON}								savedProcs := currPort^.grafProcs; {save QDProcs or CQDProcs record }								if colorQDexists then									begin										SetStdCProcs(mycProcs);										currPort^.grafprocs := @mycprocs;{$ENDC}										mycProcs.putPicProc := QDPutPicUPP(UPP);  {$IFC NOT CARBON}									end								else									begin										SetStdProcs(myProcs);										myProcs.putPicProc := UPP;  										currPort^.grafprocs := @myprocs;									end;{$ENDC}								longzero := 0;								longCount := 4;								PICTcount := sizeof(Picture);								for j := 1 to 512 div 4 + Sizeof(picture) do									resultcode := FSWrite(pictfilenum, longcount, @longzero);								box := pictureH^^.picFrame;								ClipRect(box);								newpicthand := nil;								newpicthand := OpenNewPicture(box);								DrawPicture(pictureH, box);								ClosePicture;								resultcode := SetFpos(pictfilenum, fsFromStart, 512);								longCount := GetHandleSize(Handle(newPictHand));								HLock(Handle(newpicthand));								resultcode := FSWrite(pictfilenum, longcount, Ptr(GetMaster(Handle(newpicthand))));								HUnLock(Handle(newpicthand));								if IOSuccessFul(FSClose(pictfilenum)) then									db := IOSuccessful(FlushVol(nil,reply.sfFile.vRefNum));							end;{$IFC NOT CARBON}						QDThePort^.grafprocs := nil;{$ENDC}						KillPicture(newpicthand);						newpicthand := nil;					end;				MyDisposeQDPutPicUPP(UPP);			end;	end;{----------------------------------------------------------------------------}	procedure PutPICT2 (pictureH: pichandle);		var			j: integer;			tempP: WindowPtr;			longCount, longZero: longint;			err: oserr;			db: boolean;			reply: StandardFileReply;			myProcs: QDProcs;			myCprocs: cQDProcs;			savedProcs: QDProcsPtr;    			UPP: UniversalProcPtr;			box: rect;			currPort: WindowPtr;	begin		genericGetPort(tempP);		PutStandardFile('Save PICT file as:', 'Untitled', reply);		ShowCursor;		genericSetPort(tempP);		if reply.sfgood then			begin				UPP := MyNewQDPutPicUPP(@putPICTdata);  				err := FSpCreate(reply.sfFile, pictCreator, 'PICT',scriptTag);				if (err = noerr) or (err = dupfnerr) then					begin						if err = dupfnerr then							FSpSetFileCreatorType(reply.sfFile, pictCreator, 'PICT');						if FSpOpenDF(reply.sfFile,fsCurPerm, pictfilenum) = noErr then							begin								genericGetPort(currPort);{$IFC NOT CARBON}								savedProcs := currPort^.grafProcs; {save QDProcs or CQDProcs record }								if colorQDexists then									begin										SetStdCProcs(mycProcs);										currPort^.grafprocs := @mycprocs;{$ENDC}										mycProcs.putPicProc := QDPutPicUPP(UPP);  {$IFC NOT CARBON}									end								else									begin										SetStdProcs(myProcs);										myProcs.putPicProc := UPP;  										currPort^.grafprocs := @myprocs;									end;{$ENDC}								longzero := 0;								longCount := 4;								PICTcount := sizeof(Picture);								for j := 1 to 512 div 4 + Sizeof(picture) do									resultcode := FSWrite(pictfilenum, longcount, @longzero);								box := pictureH^^.picFrame;								ClipRect(box);								newpicthand := nil;								newpicthand := OpenNewPicture(box);								DrawPicture(pictureH, box);								ClosePicture;								resultcode := SetFpos(pictfilenum, fsFromStart, 512);								longCount := sizeof(Picture);								HLock(Handle(newpicthand));								resultcode := FSWrite(pictfilenum, longcount, Ptr(GetMaster(Handle(newpicthand))));								HUnLock(Handle(newpicthand));								if IOSuccessFul(FSClose(pictfilenum)) then									db := IOSuccessful(FlushVol(nil,reply.sfFile.vRefNum));							end;{$IFC NOT CARBON}						QDThePort^.grafprocs := nil;{$ENDC}						KillPicture(newpicthand);						newpicthand := nil;					end;				MyDisposeQDPutPicUPP(UPP);			end;	end;{-----------------------------------------------------------------------------}	function PictToPict (var frompict, topict: PicHandle): boolean;		var			db: boolean;			dL: longint;	begin		if topict <> nil then			KillPicture(topict);		topict := frompict;		currentIOPosition := 67;   {v3.05}		dL:= GetHandleSize(Handle(fromPict));		PictToPict := OSSuccessful(HandToHand(Handle(frompict)));	end;{-----------------------------------------------------------------------------}	procedure myCutCopyPicture(var pictH: PicHandle);	var os: OSErr;		scrapReference: ScrapRef;		dataSize: Size;		oldState: SignedByte;		db: boolean;	begin{$IFC CARBON}		if (ClearCurrentScrap =  noErr) then			begin				os := GetCurrentScrap(scrapReference);				dataSize := GetHandleSize(Handle(pictH));				LockHandle(pictH,oldState);				os := PutScrapFlavor(scrapReference,kScrapFlavorTypePicture,kScrapFlavorMaskNone,dataSize,Ptr(GetMaster(Handle(pictH))));{$ELSEC}				db := PictToPict(pictH, clippicture);{$ENDC}				scrapispict := true;				scrappictdirty := true;{$IFC CARBON}				ResetHandle(pictH, oldState);			end;{$ENDC}	end;{-----------------------------------------------------------------------------}	procedure DrawResourcePicture (id, left, top: integer);		var			currentResFile: integer;			picH: PicHandle;			box: rect;			width, height: integer;	begin		currentResFile := CurResFile;		UseResFile(FDI^[maccladeFDI].rfFileNum);		picH := GetPicture(id);		if picH <> nil then			begin				width := picH^^.picFrame.right - picH^^.picFrame.left;				height := picH^^.picFrame.bottom - picH^^.picFrame.top;				SetRect(box, left, top, left + width, top + height);				DrawPicture(picH, box);				ReleaseResource(Handle(picH));			end;		UseResFile(currentResFile);	end;end.