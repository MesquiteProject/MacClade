unit LaserTreeUtil;{еееееееееееееееееееееее}interface	uses		Printing, QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, 		TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, 		UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, TaxonCHUtil, 		StrUtil, BoxUtil, TreeUtil, CharUtil, PrintingUtil, PrintingMisc, Legends, TreeGet;	const		{PrWhichTrees = 1;}		PrWhichChars = 1;		PrEquiv = 2;		PrTextBoxes = 4;		PrAngledNames = 5;		PrPageSetUp =6;		PrPages = 7;		PrTreesPerPage = 8;		PrBranchLengths = 9;		PrCondensedTree=10;		PrTicks = 11;		PrBranchShading = 12;		slantBleft = 16;		LPrintItem = 1;		LCancelItem = 2;		LPICTItem = 3;		LSlantItem = 5;		LSquareItem = 6;		LEuroItem = 7;		LCircleItem = 8;		LClipItem = 9;		LSetItem = 10;		LDataBoxesItem = 11;		LOptionsItem = 12;		LMakeDefaultItem = 13;		LBranchWidthItem = 14;		LOtherBranchWidthItem = 15;		LUserItem = 16;		LMatchTreeItem = 17;		ForcePatternsItem = 1;		ForceColorsItem = 2;		ForceGraysItem = 3;		laserarrow = 1;		laserFonts = 2;		lasermag = 3;		laserruler = 4;		numlaserCursors = 4;	type		lasercursrtype = array[1..numlaserCursors] of Rect;	var		LaserTreeDialog: DialogPtr;		LaserCursorR: laserCursRtype;		BranchWidthB: RECT;				{rectangle enclosing branch width controls}		otherBranchWidthB: RECT;			{rectangle enclosing line for other branch widths DLOG}		angleB: RECT;							{box enclosing angle of taxon names control}		LaserCommandsBox: RECT;			{rectangle enclosing all 9 lasercommand buttons at upper right}		treesizeB: RECT;						{tree resizing rectangle at lower right of laserBoxes^[treeB].R}		previewB: RECT;						{full preview rectangle, including QDGray border}		pictB: RECT;							{rectangle in  DLOG coordinates representing the space occupied by one illustration}		drawbox: RECT;						{similar to pictB, but = previewB if closeupon}		fullTreeFrame: RECT;				{}		oldBranchShades: tracetype;					{}		imageBottom: integer;		closeupon: BOOLEAN;		shrink: double;							{a value between 0 and 1, indicating the ratio of the size of the image}											{on the dialog box to the size of the actual picture}		pleaseWriteBottom: boolean;		anglehor, angleVer: integer;		closeuppt: point;		changesheight: longint;		tLaserBoxes: LaserBoxesArrayPtr;		tlaser: LaserPtr;		LaserTreePrint: boolean;			{true iff LaserTree dlog is called up to print, as opposed to Save Graphics File}		LaserCommentSH: StringHandle;		LaserCursor: integer;				{integer saying which cursor is current}		TextMHdl: MenuHandle;		ShadesMHdl: MenuHandle;		PrOptionsMHdl: MenuHandle;	function ReallyShowLegend (thebox: integer): boolean;	procedure GetTreeNumber;	procedure SetTreeSizeB (dodraw: boolean);	procedure CleanAngleControl;	procedure SetAngleControlBox;	procedure SetAngleControlStarts;	procedure FixLaserTreeB;	procedure MakeSpacingsEven;	procedure CalcLaserBoxes;	procedure LegendBoxPosition (moveintoview: boolean);	function MaxNameHeight: integer;	function CalcNodesH: integer;	procedure SetPreviewRects (redospacing: boolean);	procedure SetTreeShape (theshape: integer);	procedure ChangeToSquareTree;	procedure LaserTreeParamText;	procedure AutoPrintTreeTicksHeighten;   {v3.02: }	procedure QueryChangeTreeShapeForTicksPrint;{еееееееееееееееееееееее}implementation {е$S LaserTreeUtil}	const		txspleft = 360;		txsptop = 50;{-----------------------------------------------------------------------------}	function ReallyShowLegend (thebox: integer): boolean;	begin		ReallyShowLegend := ((thebox <> legB) & (laser^.showbox[theBox])) | ((theBox = legB) & (laser^.showbox[legb] & not ((traceshown = traceAllChanges) & (summaryview = asblack) & not laser^.printbranchlengths)));	end;{-----------------------------------------------------------------------------}	procedure SetAngleControlBox;	begin		if laser^.treeshape[circletree] then			SetRect(angleB, anglehor - laser^.circleAnglePt.h - 5, anglever - laser^.circleAnglePt.v - 5, anglehor - laser^.circleAnglePt.h + 5, anglever - laser^.circleAnglePt.v + 5)		else			SetRect(angleB, anglehor + laser^.nameAnglePt.h - 5, anglever + laser^.nameAnglePt.v - 5, anglehor + laser^.nameAnglePt.h + 5, anglever + laser^.nameAnglePt.v + 5);	end;{-----------------------------------------------------------------------------}	procedure CleanAngleControl;		var			B: rect;	begin		SetRect(B, 0, 0, previewB.left - 8, 74);		EraseRect(B);		InvalidateWindowRect(myGetWindowPtrForDialog(LaserTreeDialog),B,false);	end;{-----------------------------------------------------------------------------}	procedure SetAngleControlStarts;	begin		if laser^.treeshape[circletree] then			begin				anglehor := 50;				anglever := 12;			end		else			begin				anglehor := 16;				anglever := 52;			end;	end;{-----------------------------------------------------------------------------}	procedure GetTreeNumber;{returns treenumber of tree to be printed}	begin		if dirtytree then			printtreenumber := 0		else			printtreenumber := linknumber[treechain] - StartUserLink(treeChain) + 2;	end;{-----------------------------------------------------------------------------}	procedure SetTreeSizeB (dodraw: boolean);	begin		with LaserBoxes^[treeB].R do			SetRect(treeSizeB, right - 5, bottom - 5, right - 1, bottom - 1);		if dodraw then {v3.04: removed: and not (laser^.printbranchlengths and (traceshown = traceAllChanges) and laser^.LPPCconstant)}			begin				PenPat(QDGray);				PenMode(patxor);				PaintRect(treeSizeB);				PenNormal;			end;	end;{-----------------------------------------------------------------------------}	procedure ShrinkRect (var box: rect);{takes a rect in "real" coordinates and shrinks it down to dialog coordinates}	begin		with box do			if not closeupon then				begin					left := pictB.left + TruncateValue(shrink * left);					top := pictB.top + TruncateValue(shrink * top);					right := pictB.left + TruncateValue(shrink * right);					bottom := pictB.top + TruncateValue(shrink * bottom);				end;	end;{-----------------------------------------------------------------------------}	function CalcLegendBox: rect;{returns size of chlegend box}		var			legH, boxestoshow: integer;			box: rect;	begin		SetBoxFont(legB);		laserLegLineW := FontHeight;		laserLegBoxW := laserLegLineW + 4;		if (traceshown = traceDiscrete) then			begin				CheckPolyUncert;				legendstates := CalcLegendStates(i);				CalcNumChLegBoxes(boxestoshow, cardLg(legendstates));				legH := laserLegBoxW * (boxestoshow + 1);				if laser^.printequiv then					legH := legH + laserLegLineW;				if laser^.showstepslaser then					legH := legH + laserLegLineW;				if laser^.showtype then					legH := legH + laserLegLineW;			end		else if (traceshown = traceAllChanges) then			begin				if summaryview = aspattern then					begin						legH := (maxchg + 1) * laserLegBoxW + 2 * laserLegLineW;						if AnyNulls(screenR) and not polyreal then							legH := legH + laserLegBoxW;					end				else 					begin						if laser^.printBranchLengths then							legH := 3 * laserLegLineW						else							legH := 2 * laserLegLineW;						if (summaryview = asticks) & ticksAreColored then							begin 								case colorTicksClass of									colorTicksIndex:										begin											if ColorPort then												legH := legH + (ticksIndexColorLevels+1)*laserLegBoxW											else												legH := legH + (TicksIndexPatLevels+1)*laserLegBoxW;											legH := legH + laserLegBoxW;											if AnyType([usedef, dollo, fisher]) or (Anytype([irreversible]) & (colorTicksIndexClass in [colorTicksRI, colorTicksRC])) then												legH := legH + laserLegBoxW;				{for uncalculable index box}										end;									colorTicksCodPos:										begin											legH := legH + 5*laserLegBoxW;										end;									colorTicksTiTv:										begin											legH := legH + 3*laserLegBoxW;										end;									otherwise										;								end;							end;						if (summaryview = asticks) & showTickClass then							begin 								legH := legH + 8*laserLegBoxW;							end;					end;			end		else if (traceshown = traceContinuous) then			legH := 11 * laserLegBoxW + 2 * laserLegLineW + 4		else if (traceshown = traceProbability) then			legH := 10 * laserLegLineW;		SetRect(box, 0, 0, 100, legH);  {v4: width should be geared toward real width}		RestoreSystemFonts;		CalcLegendBox := box;	end;{-----------------------------------------------------------------------------}	function numLasertlegLines: integer;{returns number of statistic lines included in tlegend}		var			numtleglines, j: integer;	begin		numtleglines := 0;		for j := tlegTreeLength to tlegChg do			if tlegStats[j].show then				numtleglines := numtleglines + tlegStats[j].lines;		numLasertlegLines := numtleglines;	end;{-----------------------------------------------------------------------------}	procedure SetLaserBox (theLaserBox: integer; maxStr: str255; height: integer);	begin		SetBoxFont(theLaserBox);		with laser^.starts[theLaserBox] do			SetRect(LaserBoxes^[theLaserBox].R, h, v, h + StringWidth(maxStr) + 20, v + height);		ShrinkRect(LaserBoxes^[theLaserBox].R);		RestoreSystemFonts;	end;{-----------------------------------------------------------------------------}	procedure LegendBoxPosition (moveintoview: boolean);	begin		if PaintedBranches or (traceshown = traceAllChanges) or (traceshown = traceProbability) then			begin{first calculate the chLeg rectangle in page coordinates}				LaserBoxes^[legB].R := CalcLegendBox;				with laser^.starts[legB] do					OffSetRect(laserBoxes^[legB].R, h, v);				if moveintoview then   {see if box.bottom too low and if so adjust upwards}					if LaserBoxes^[legB].R.bottom > printPageR.bottom then						begin							laser^.starts[legB].v := laser^.starts[legB].v + printPageR.bottom - LaserBoxes^[legB].R.bottom - 2;							OffSetRect(LaserBoxes^[legB].R, 0, printPageR.bottom - LaserBoxes^[legB].R.bottom - 2);						end;{now set these in to DLOG coordinates}				ShrinkRect(LaserBoxes^[legB].R);			end;	end;{-----------------------------------------------------------------------------}	procedure CalcLaserBoxes;{calcs rectangle for laserboxes other than treeB and taxanameB}	begin		LegendBoxPosition(false);		SetLaserBox(treestatsB, 'Treelength:  0000', numLasertlegLines * FontHeight + 4);		SetLaserBox(treenamB, treename^^, FontHeight + 4);		SetLaserBox(treenumB, '000', FontHeight + 4);		SetLaserBox(commentB, LaserCommentSH^^, FontHeight + 4);		RestoreSystemFonts;	end;{-----------------------------------------------------------------------------}	procedure FixLaserTreeB;{fixes right and left of TreeB  - note does not actually fix top and bottom}	begin		with LaserBoxes^[treeB].R do			if not closeupon then				begin					left := pictB.left + TruncateValue(shrink * (firsttx - 4));					top := pictB.top + TruncateValue(shrink * (topmargin - 4 + phylogap));					right := pictB.left + TruncateValue(shrink * (firsttx + (ntscreen - 1) * laser^.txsp)) + 4;				end			else				begin					left := (firsttx - 4);					top := (topmargin - 4 + phylogap);					right := firsttx + (ntscreen - 1) * laser^.txsp + 4;				end;	end;{-----------------------------------------------------------------------------}	procedure MakeSpacingsEven;	begin		if Odd(laser^.txsp) then			if laser^.txsp < 2 then				laser^.txsp := 2			else				laser^.txsp := laser^.txsp - 1;		if Odd(laser^.versp) then			if laser^.versp < 2 then				laser^.versp := 2			else				laser^.versp := laser^.versp - 1	end;{-----------------------------------------------------------------------------}	function MaxNameHeight: integer;{returns the height in pixels of the longest taxon name, }{considering angle of names, if appropriate}		var			ang, maxname, it: integer;	begin		with laser^ do			SetBoxFont(taxanameB);		maxname := 0;		for it := 1 to numtaxa do			if TaxoninTree(it) then				maxname := IntegerMax(maxname, StringWidth(TaxonName(it)));		if laser^.postscripton and not laser^.treeshape[circletree] then				begin					ang := CalcAngle(laser^.nameanglept);					if not closeupon then						maxname := TruncateValue(shrink * maxname * sin(pi / 2 - ang * pi / 180.0))					else						maxname := TruncateValue(maxname * sin(pi / 2 - ang * pi / 180.0));				end			else if not closeupon then				maxname := TruncateValue(maxname * shrink);		RestoreSystemFonts;		MaxNameHeight := maxname;	end;{-----------------------------------------------------------------------------}	function CalcNodesH: integer;{returns height of tree from topmargin to the root}		var			taxaH, oldlasttx: integer;{...................}		procedure CalcVLocs (N: Nptr);		begin			if NodeIsTerminal(N) then				begin					N^.loc.h := lasttx;					lasttx := laser^.txsp + lasttx;					N^.loc.v := topmargin;				end			else				begin					CalcVLocs(N^.lf);					CalcVLocs(N^.rt);					if not laser^.square then						begin							N^.loc.h := (N^.lf^.loc.h + N^.rt^.loc.h - N^.lf^.loc.v + N^.rt^.loc.v) div 2;							N^.loc.v := (-N^.lf^.loc.h + N^.rt^.loc.h + N^.lf^.loc.v + N^.rt^.loc.v) div 2;						end					else						begin							N^.loc.h := (N^.lf^.loc.h + N^.rt^.loc.h) div 2;							if N^.lf^.loc.v > N^.rt^.loc.v then								N^.loc.v := N^.lf^.loc.v + laser^.versp							else								N^.loc.v := N^.rt^.loc.v + laser^.versp;						end;				end;		end;{................}	begin		lasttx := firsttx;		CalcVLocs(screenR);		calcnodesH := screenR^.loc.v - topmargin;	end;{-----------------------------------------------------------------------------}	procedure LaserTreeParamText;	begin		if not LaserTreePrint then			ParamText('Graphics File Options', '', '', '')		else if numTreesChosen=0 then			ParamText('Print Current Tree', '', '', '')		else if numTreesChosen=1 then			ParamText('Print Selected Tree', '', '', '')		else			ParamText('Print Selected Trees', '', '', '');	end;{-----------------------------------------------------------------------------}	procedure SetPreviewRects (redospacing: boolean);		var			fullW, fullH, pictW, pictH, prevW, prevH, treeW, treeH, taxaH: integer;			oldlaserversp, currentH, naturalH, fullpagewidth, fullpageheight, panelH, panelW: integer;			dL: Longint;			box: rect;	begin		with printPageR do			begin				fulltreeframe.left := RoundValue((left / pgHres) * 72);				fulltreeframe.right := RoundValue((right / pgHres) * 72);				fulltreeframe.top := RoundValue((top / pgVres) * 72);				fulltreeframe.bottom := RoundValue((bottom / pgVres) * 72);				fullpageWidth := (fulltreeframe.right - fulltreeframe.left);				fullpageHeight := (fulltreeframe.bottom - fulltreeframe.top);				pgwidth := fullpageWidth div laser^.treesPerPage.h;				pgheight := fullpageHeight div laser^.treesPerPage.v;			end;		fullH := fullpageheight * laser^.treepages.v;		fullW := fullpagewidth * laser^.treepages.h;		panelH := pgheight * laser^.treepages.v;		panelW := pgwidth * laser^.treepages.h;		fulltreeframe.right := fulltreeframe.left + fullW;		fulltreeframe.bottom := fulltreeframe.top + fullH;		prevH := previewB.bottom - previewB.top;		prevW := previewB.right - previewB.left;		pictB := previewB;		if (fullH / prevH) > (fullW / prevW) then	{have to shrink it down; height's relatively the biggest}			begin				shrink := prevH / fullH;				pictW := TruncateValue(shrink * fullW);				pictB.left := pictB.left + (prevW - pictW) div 2;				pictB.right := pictB.left + pictW;			end		else			begin				shrink := prevW / fullW;				pictH := TruncateValue(shrink * fullH);				pictB.top := pictB.top + (prevH - pictH) div 2;				pictB.bottom := pictB.top + pictH;			end;		drawbox := pictb;		if redospacing then			begin				laser^.txsp := (panelW - 56) div ntscreen;				laser^.versp := laser^.txsp;				MakeSpacingsEven;			end;		treeW := laser^.txsp * (ntscreen - 1) + laser^.width;{verinc := laser^.txsp * sin(pi / 2 - Angle * pi / 180.0);}		phylogap := 0;{====== calculating height of tree + taxon names ========}		taxaH := MaxNameHeight;		currentH := CalcNodesH;		phylogap := 0;		TreeH := currentH + taxaH + 10;		if panelH < treeH then			begin				oldlaserversp := laser^.versp;				dL := (panelH - taxaH);				dL := laser^.versp * dL;				laser^.versp := dL div (treeH - taxaH);				laser^.txsp := laser^.versp;				MakeSpacingsEven;				treeW := laser^.txsp * (ntscreen - 1) + laser^.width;				dL := treeH;				dL := dL * laser^.versp;				treeH := dL div oldlaserversp;			end;		firsttx := (panelW - treeW) div 2;		topmargin := (panelH - treeH - phylogap) div 2;		TSP.v := topmargin;		TSP.h := firsttx;{===== calculating positions of various text boxes on screen========}		box := CalcLegendBox;		laser^.starts[legB].h := panelW - box.right - 20;		laser^.starts[legB].v := panelH - box.bottom - 20;		SetBoxFont(treenamB);		laser^.starts[treenamB].h := 35;		laser^.starts[treenamB].v := panelH - FontHeight - 30;		SetBoxFont(treenumB);		laser^.starts[treenumB].h := 35;		laser^.starts[treenumB].v := 2 * FontHeight;		SetBoxFont(treestatsB);		laser^.starts[treestatsB].h := 35;		laser^.starts[treestatsB].v := laser^.starts[treenamB].v - numLasertlegLines * FontHeight - 30;		SetBoxFont(commentB);		laser^.starts[commentB].h := (panelW - StringWidth(LaserCommentSH^^)) div 2;		laser^.starts[commentB].v := panelH - FontHeight - 30;		CalcLaserBoxes;		RestoreSystemFonts;	end;{----------------------------------------------------------------------------}	procedure SetTreeShape (theshape: integer);		var			j: integer;			changeControls: boolean;	begin		changecontrols := laser^.treeshape[circletree] = (theshape <> circletree);		for j := 0 to numtreeshapes do			if laser^.treeshape[j] then				InvertRect(laser^.treeshapeB[j]);		for j := 0 to numtreeshapes do			laser^.treeshape[j] := false;		laser^.treeshape[theshape] := true;		InvertRect(laser^.treeshapeB[theshape]);		SetAngleControlStarts;		if theshape = circletree then			begin				laser^.numbernodes := false;				laser^.showEvolveSegments := false;				laser^.showEvolveRealLengths := false;			end;		if changeControls then			begin				CleanAngleControl;				SetAngleControlBox;			end;	end;{-----------------------------------------------------------------------------}	procedure ChangeToSquareTree;		var			nodesH: integer;	begin		SetTreeshape(squaretree);		laser^.square := true;		nodesH := CalcNodesH;		if (topmargin + nodesH > (fulltreeframe.bottom - 50)) then			begin				laser^.versp := (laser^.versp * (fulltreeframe.bottom - topmargin - 50)) div nodesH;				MakeSpacingsEven;			end;		InvalidateWindowRect(myGetWindowPtrForDialog(LaserTreeDialog),previewB,false);	end;{----------------------------------------------------------------------------}	procedure AutoPrintTreeTicksHeighten;   {v3.02: }		var			fH: integer;	begin		SetBoxFont(treeB);		fH := FontHeight;		if ticksNoNames then			laser^.LPPCvalue := 4		else			laser^.LPPCvalue := (fH + 3);		CalcBranchLengthSpacing(laser^.LPPCvalue);				laser^.LPPCvalue := branchLengthSpacing;		{    laser^.LPPCvalue := 3 * (fH + 2) div 2;}{if branch has 2 chg, then it will be of length 2*LPPCvalue,}{but it will be divided up into 3 pieces, so that each piece will be of length 2/3*LPPCvalue;}{thus, need to have 2/3*LPPCvalue = fH+2}		TextFace([]);		TextFont(systemfont);		TextSize(0);	end;{-----------------------------------------------------------------------------}	procedure QueryChangeTreeShapeForTicksPrint;	begin		if (summaryView=asTicks) & (not laser^.treeshape[squaretree] | not laser^.printbranchlengths) & CWarning('Do you want to set the tree shape so that the bars are more easily visible?','Yes', 'No') then			begin				if not laser^.treeshape[squaretree] then					ChangeToSquareTree;				laser^.printbranchlengths := true;				AutoPrintTreeTicksHeighten;				laser^.LPPCconstant := true;			end;	end;{-----------------------------------------------------------------------------}end.