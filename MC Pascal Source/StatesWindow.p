unit StatesWindow;{ееееееееееееееееееееее}interface	uses		QuickDraw, 		Types, Events, QuickDrawText, Controls, Menus, OSUtils, TextUtils, Windows, Sound, Dialogs, 		TextEdit, Lists, ToolUtils, Memory, Fonts, Resources, Scrap, 		Globals, MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, 		BoxUtil, TaxonCHUtil, CharUtil, SymbolsNames, InfoWindows, WriteUtil, TreeUtil, CHUNK, 		SpreadUtil, DrawSpread, TrackThumb, StatesWindowUtil;	procedure DrawStatesChangedReDrawEditor;  {v3.05}	procedure CheckStateNamesSymbolsDanger (drawstatesOverrides: boolean; var redrewEditor: boolean);   {v3.05}	procedure NamesToBackup (backup: boolean);	{procedure EdStatesDLOG;}	procedure CopyStatesToClipBoard(ic: integer);	procedure ClearStatesInWindow(ic: integer);	procedure PasteStatesFromClipBoard(ic: integer);	procedure DrawStatesTitle (titleTop,titleHeight: integer);	procedure DrawStatesLine (rowNumber, bottomHeight: integer; drawSymbols: boolean);	procedure DrawStatesWindow (drawSymbols: boolean);		procedure ScrollStatesUpDown (whichControl: ControlRef; theCode: INTEGER);	procedure ScrollStatesWindow;	procedure DoStatesScroll (wh: point);	procedure DeSelectAllStatesWindow;	procedure TurnOffSymbolsEditing;	procedure TurnOffStatesEditing;	procedure SelectAllStatesWindow(selectAll: boolean);	procedure ClickInStatesWindow (theEvent: EventRecord);	procedure KeyInStatesWindow (theChar: char;theEvent: EventRecord);{ееееееееееееееееееееее}implementation {е$S StatesWindow}{----------------------------------------------------------------------------}	procedure PostStateNameChanged(ic: integer;theState: integer);	begin		if treeopen & ((traceShown = traceDiscrete) | (traceShown = traceallchanges)) then			godraw := true;		if editorShowFullStateNames then			InvalidateCellBlock(1,numtaxa,ic,ic,true);		if (theState=kCharNameRow) then			InvalidateEditorNames(false);		if not foottexton then DrawFootText(false, false); {redraw footstates}		InvalidateWindow(chlegwindow, false);		dirtyfile := true;	end;{-----------------------------------------------------------------------------}	procedure DrawStatesChangedReDrawEditor;  {v3.05}	var oldClip: RgnHandle;	begin		if editorOpen then			begin				genericSetPort(editorWindow);				myCheckMenuItem(ShowMHdl, EWStateNamesItem, editorShowFullStateNames);				myCheckMenuItem(ShowMHdl, EWUseIUPACItem, editorShowIUPACSymbols);				oldClip := NewRgn;				GetClip(oldClip);				SetEWClip(justDataAndConsenses);				SetClip(EWClip);				EraseREct(editorBoundaryRect);				if editorSelected and SingleCell then					FillsTE(editorCellTE, CellString);				DrawCells(true, true,true);				SetClip(oldClip);				ZapRegion(oldClip);			end;	end;{-----------------------------------------------------------------------------}	procedure CheckStateNamesSymbolsDanger (drawstatesOverrides: boolean; var redrewEditor: boolean);   {v3.05}	begin		redrewEditor := false;		CheckStateNamesAreSymbols;		if StateNamesAreSymbols then			begin				if interpretStateNames <> editorShowFullStateNames then					begin						NewError(409, CharWithStateNamesAsSymbols);						if drawStatesOverrides then							interpretStateNames := editorShowFullStateNames						else							begin								editorShowFullStateNames := interpretStateNames;								DrawStatesChangedReDrawEditor;								redrewEditor := true;							end;					end;			end;	end;{----------------------------------------------------------------------------}	procedure CopyStatesToClipBoard(ic: integer);	var oldstate: SignedByte;		H: Handle;	begin		LockHandle(stateNamesCHUNKs,oldstate);		H := getCHUNKHdl(statenamesCHUNKs, ic);		CopyHandles (H, statesClipboardH);		ResetHandle(stateNamesCHUNKs,oldstate);		{if (ic=statesWindowCharacter) & statesWindowOpen then			InvalidateWindow(StatesWindow,false);}	end;	{----------------------------------------------------------------------------}	procedure ClearStatesInWindow(ic: integer);	begin		InitStateNamesOfCharacter(ic, false);		if (ic=statesWindowCharacter) & statesWindowOpen then			InvalidateWindow(StatesWindow,false);		PostStateNameChanged(ic,0);	end;{----------------------------------------------------------------------------}	procedure PasteStatesFromClipBoard(ic: integer);	var oldstate: SignedByte;		H: Handle;	begin		LockHandle(stateNamesCHUNKs,oldstate);		H := getCHUNKHdl(statenamesCHUNKs, ic);		CopyHandles (statesClipboardH, H);		HdlPtr(GetMaster(statenamesCHUNKs) + HdlSize * longint(ic - 1))^ := H;		ResetHandle(stateNamesCHUNKs,oldstate);		if (ic=statesWindowCharacter) & statesWindowOpen then			InvalidateWindow(StatesWindow,false);		PostStateNameChanged(ic,0);	end;{----------------------------------------------------------------------------}	procedure NamesToBackup (backup: boolean);{moves state names to and from backup state names}		var			charHdl: chHdl;			ic: integer;	begin		if backup then			begin				copyCHUNKs(statenamesCHUNKs, statenamesCHUNKsBU, 1, numchars);				for ic := 1 to numchars do					begin						charHdl := getchHdl(ic);						charHdl^^.namebackup := charHdl^^.name;					end;			end		else			begin				copyCHUNKs(statenamesCHUNKsBU, statenamesCHUNKs, 1, numchars);				for ic := 1 to numchars do					begin						charHdl := getchHdl(ic);						charHdl^^.name := charHdl^^.namebackup;					end;			end;	end;{$IFC FALSE}{-----------------------------------------------------------------------------}	procedure CheckDupStateNames (ic: integer);{checks for states names that are a subset of other state names for character ic}		var			state, compstate: integer;			ds, ds2: str255;	begin		for state := 0 to maxstbit do			begin				ds := CharStateName(ic, state);				if length(ds) > 0 then					for compstate := state + 1 to maxstbit do						begin							ds2 := CharStateName(ic, compstate);							if (length(ds2) > 0) & ((pos(ds2, ds) > 0) | (pos(ds, ds2) > 0)) then								begin									NewError(351, ic);									Exit(CheckDupStateNames);								end;						end;			end;	end;{$ENDC}{-----------------------------------------------------------------------------}	procedure DrawStateSymbol (rowNumber, height: integer);		var			box: rect;			oldBack: RGBColor;	begin		SetRect(box, statesSymbolWidth, StatesRowHeightTopFromBottom(height), statesNameStart, height);		InsetRect(box, -1, -1);		GetRGBSetTingeBackground(oldBack, blueTinge);		Eraserect(box);		moveto(box.left + ((box.right - box.left) - (StringWidth(symbols[rowNumber]))) div 2, box.bottom - 3);		DrawString(symbols[rowNumber]);		SetRGBBackground(oldBack);		InnerShadowedBox(box);		if statesSymbolisSelected and (statesSymbolSelected = (rowNumber - 1)) then			begin				InsetRect(box, 1, 1);				InvertRect(box);			end;	end;{-----------------------------------------------------------------------------}	procedure DrawStatesLine (rowNumber, bottomHeight: integer; drawSymbols: boolean);	{bottomHeight:  bottom of line}		var			ici, ir: integer;			box: rect;			clenp: LIP;			cstatesP: Ptr;			prevClip: RgnHandle;			oldBack: RGBColor;	begin{note: don't get and set ports, as this messes up textfile output and printing}		TextFont(statesFont);		TextSize(statesFontSize);{============ state Number ===========}		if drawSymbols then			if not DrawToFile then				begin					TextFace([bold]);					SetRect(box, 0, StatesRowHeightTopFromBottom(bottomHeight), statesSymbolWidth, bottomHeight);					InsetRect(box, -1, -1);					SetGrayBackground(oldBack,grayPlain);					Eraserect(box);					moveto(box.left + ((box.right - box.left) - (StringWidth(StringFromNum(rowNumber - 1)))) div 2, box.bottom - 3);					DrawString(StringFromNum(rowNumber - 1));					TextFace([]);					SetRGBBackground(oldBack);					InnerShadowedBox(box);				end;{============ state Symbol ===========}		if drawSymbols then			if not DrawToFile then				DrawStateSymbol(rowNumber, bottomHeight);		if not DrawToFile then			begin				prevClip := NewRgn;				GetClip(prevClip);				SetRect(box, statesnameStart + 1, StatesRowHeightTopFromBottom(bottomHeight), WindowPortRect(stateswindow).right - scrollwidth - 1, bottomHeight);				ClipRect(box);				if not printon then					begin						Eraserect(box);						if statesSelected then							ShadeSelectedRectangle(box);					end;				moveto(box.left + 6, bottomHeight - statesFontDescent);				drawstring(CharStateName(statesWindowCharacter, rowNumber - 1));				if not printon & statesEditing & (stateBeingEdited = rowNumber - 1) then					TEUpdate(box, statesTE);				SetClip(prevClip);				ZapRegion(prevClip);			end;{=======================}		if not DrawToFile then			begin				if rowNumber <> maxStateRows then					penpat(QDltGray);				moveto(statesNameStart+1, bottomHeight);				ClipRect(WindowPortRect(myGetWindowFromPort(QDThePort)));				GridLineTo(WindowPortRect(stateswindow).right - scrollwidth - 2, bottomHeight, false);				penpat(QDBlack);{    if frontwindow = statesWindow then if InfoRowSelected(whichinfo, rowNumber) then InvertHiliteRect(InfoRowBox(whichinfo, bottomHeight));}			end		else			putreturn;		PenNormal;{    textfont(TWFont);}	end;{-----------------------------------------------------------------------------}	procedure DrawStatesTitle (titleTop, titleHeight: integer);		var			j: integer;			box: rect;			oldBack: RGBColor;			title: str255;			oldClip: RgnHandle;	begin		textface([bold]);		textfont(statesFont);		if DrawToFile then			begin				title := concat(StringFromNum(statesWindowCharacter), '.  ', CharName(statesWindowCharacter));				puttoken(title);				puttab;				putreturn;			end		else			begin				if not printon then					begin						SetGrayBackground(oldBack,grayPlain);						SetRect(box, 0, titleHeight - statesWindowTitleWidth, charNameBoxStart-1, titleHeight);						EraseRect(box);						SetRect(box, WindowPortRect(stateswindow).right-scrollwidth, titleHeight - statesWindowTitleWidth, WindowPortRect(stateswindow).right, titleHeight);						EraseRect(box);						moveto(statesSymbolWidth + statesSymbolWidth div 2 - 3, 0);						DrawSmallTriangleAtPen(statesWindowTitleWidth);						PenNormal;					end;				moveto(statesSymbolWidth*2, titleTop);				LineTo(statesSymbolWidth*2, titleHeight);				moveto(0, titleHeight);				LineTo(WindowPortRect(stateswindow).right - scrollwidth - 2, titleHeight);				if not printon then					begin						MoveTo(WindowPortRect(stateswindow).right - scrollwidth - 1, titleTop);						Line(0, WindowPortRect(stateswindow).bottom);					end;								{moveto(statesNameStart + ((WindowPortRect(stateswindow).right - statesNameStart) - StringWidth(title)) div 2, titleHeight);}												if not printon then					begin						OldClip :=NewRgn;						GetClip(oldClip);						SetRect(box, statesNameStart, titleHeight - statesWindowTitleWidth, WindowPortRect(stateswindow).right-scrollwidth-1, titleHeight);						ClipRect(box);					end;				moveto(statesNameStart + 8, titleHeight-statesFontDescent);				DrawString(StringFromNum(statesWindowCharacter));				DrawString('. ');				if not printon then					SetRGBBackground(oldBack);				moveto(charNameBoxStart, titleTop);				lineto(charNameBoxStart, titleHeight);				TextFace([]);				if not printon then					begin						SetRect(box, charNameBoxStart, titleHeight - statesWindowTitleWidth, WindowPortRect(stateswindow).right-scrollwidth-1, titleHeight);						EraseRect(box);					end;								moveto(charNameBoxStart+4, titleHeight-statesFontDescent);				DrawString(CharName(statesWindowCharacter));				if not printon then					begin						SetClip(oldClip);					end;			end;		textface([]);{textfont(genevafont);}	end;{-----------------------------------------------------------------------------}	procedure DrawStatesWindow (drawSymbols: boolean);		var			ir, rowNumber: INTEGER;			tport: WindowPtr;	begin		if statesWindowCharacter < 1 then StatesWindowCharacter := 1;		maxStateRows := maxstate + 1;		SetCursor(clockCursor);		genericGetPort(tport);		genericSetPort(statesWindow);		ClipRect(WindowPortRect(stateswindow));		DrawStatesTitle(0,statesWindowTitleWidth);		if not printon then			begin				moveTo(WindowPortRect(stateswindow).right - scrollwidth, statesWindowTitleWidth);				LineTo(WindowPortRect(stateswindow).right - scrollwidth, WindowPortRect(stateswindow).bottom);			end;		textfont(statesFont);		ir := 1;		if statesWindowTop > maxStateRows then			statesWindowTop := 1;		rowNumber := statesWindowTop;		if (ir <= statesWindowRows) or (rowNumber <= maxStateRows) then			repeat				DrawStatesLine(rowNumber, StatesRowHeightBottom(rowNumber), drawSymbols);				ir := ir + 1;				rowNumber := rowNumber + 1;			until (ir > statesWindowRows) or (rowNumber > maxStateRows);{    textfont(genevafont);}		DrawGrowBox(statesWindow);		myValidRect(statesWindow,WindowPortRect(stateswindow));		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	procedure ScrollStatesWindow;		var			dv, dh: integer;			tport: WindowPtr;			oldInfotop, oldStatesWindowCharacter, ic: integer;			oldClip: RgnHandle;			box: rect;	begin		genericGetPort(tport);		genericSetPort(statesWindow);		oldClip := NewRgn;		GetClip(oldClip);		ClipRect(WindowPortRect(stateswindow));		oldStatesWindowCharacter := statesWindowCharacter;		oldInfotop := statesWindowTop;		statesWindowTop := GetControlValueLong(statesWindowVScroll);		dv := (oldInfotop - statesWindowTop) * statesWindowLineWidth;		stateswindowCharacter := GetControlValueLong(statesWindowHScroll);		if statesWindowCharacter > numchars then			statesWindowCharacter := numchars		else if statesWindowCharacter < 1 then			statesWindowCharacter := 1;		dh := oldStateswindowCharacter - statesWindowCharacter;		if dv <> 0 then			begin				if statesEditing then					MoveStatesTE(stateBeingEdited);				with WindowPortRect(stateswindow) do					SetRect(box, left, statesWindowTitleWidth+1, right - scrollwidth - 1, bottom - scrollwidth);				ScrollRect(box, 0, dv, updateRgn);				SetClip(updateRgn);			end		else if dh <> 0 then			begin				with WindowPortRect(stateswindow) do					SetRect(box, statesNameStart+1, statesWindowTitleWidth, right - scrollwidth - 1, bottom - scrollwidth - 1);				ClipRect(box);			end;		if dv = statesWindowLineWidth then   {scrolling down, therefore adding rows to top}			begin				if statesEditing then					if (stateBeingEdited = statesWindowRows + statesWindowTop - 1) then  {edit box disappearing}						TEDeActivate(statesTE)					else if (stateBeingEdited = statesWindowTop - 1) then  {edit box disappearing}						TEActivate(statesTE);				DrawStatesLine(statesWindowTop, StatesRowHeightBottom(statesWindowTop), true);			end		else if (dv = -statesWindowLineWidth) & WindowBotRightOnScreen(statesWindow, true, WindowPortRect(stateswindow).bottom) then			begin				ic := statesWindowTop + statesWindowRows - 1;				if statesEditing then					if (stateBeingEdited = statesWindowRows + statesWindowTop) then  {edit box to appear}						TEActivate(statesTE)					else if (stateBeingEdited = statesWindowTop - 1) then  {edit box disappearing}						TEDeActivate(statesTE);				if ic <= maxStateRows then					DrawStatesLine(ic, StatesRowHeightBottom(ic), true);			end		else if dv <> 0 then			DrawStatesWindow(true);		if dh <> 0 then			DrawStatesWindow(false);		SetClip(OldClip);		ZapRegion(oldClip);		genericSetPort(tport);	end;{----------------------------------------------------------------------------}	procedure ScrollStatesUpDown (whichControl: ControlRef; theCode: INTEGER);	begin		if scrollup then			begin				if theCode = kControlUpButtonPart then					begin						SetControlValueLong(whichControl, GetControlValueLong(whichControl) - 1);						ScrollStatesWindow					end			end		else if theCode = kControlDownButtonPart then			begin				SetControlValueLong(whichControl, GetControlValueLong(whichControl) + 1);				ScrollStatesWindow			end	end;{-----------------------------------------------------------------------------}	procedure DoStatesScroll (wh: point); 		var			MyControl, t: integer;			mypt: point;	begin		MyControl := FindControl(wh, statesWindow, whichControl);		if whichControl= nil then Exit(DoStatesScroll);		case MyControl of			kControlUpButtonPart: 				begin					scrollup := true;					t := myTrackControl(whichControl, wh, ScrollStatesUpDownUPP);				end;			kControlDownButtonPart: 				begin					scrollup := false;					t := myTrackControl(whichControl, wh, ScrollStatesUpDownUPP);				end;			kControlPageUpPart: 				repeat					GetMouse(myPt);					if TestControl(whichControl, myPt) = mycontrol then						begin							if whichControl = statesWindowVScroll then								SetControlValueLong(whichControl, GetControlValueLong(whichControl) - statesWindowRows)							else								begin									SetControlValueLong(whichControl, GetControlValueLong(whichControl) - 5);								end;							ScrollStatesWindow						end				until not StillDown;			kControlPageDownPart: 				repeat					GetMouse(myPt);					if TestControl(whichControl, myPt) = mycontrol then						begin							if whichControl = statesWindowVScroll then								SetControlValueLong(whichControl, GetControlValueLong(whichControl) + statesWindowRows)							else								begin									SetControlValueLong(whichControl, GetControlValueLong(whichControl) + 5);								end;							ScrollStatesWindow						end				until not StillDown;			kControlIndicatorPart: 				begin					if whichControl = statesWindowVScroll then						TrackFeedbackThumb(whichControl,wh, statesWindow)					else						t := myTrackControl(whichControl, wh, nil);					ScrollStatesWindow;				end;			otherwise				;		end;	end;{----------------------------------------------------------------------------}	procedure DeSelectAllStates;	begin	end;{----------------------------------------------------------------------------}{----------------------------------------------------------------------------}	procedure TurnOnStatesEditing (theState: integer);		var			oldstate: SignedByte;			ds: str255;	begin		DeSelectAllStates;		LockHandle(statesTE, oldstate);		if theState=kCharNameRow then			ds := CharName(statesWindowCharacter)		else			ds := CharStateName(statesWindowCharacter, theState);		TESetText(Pointer(ORD4(@ds) + 1), ORD4(length(ds)), statesTE);		MoveStatesTE(theState);		statesTE^^.txFont := statesFont;		statesTE^^.txSize := statesFontSize;		EndSetUpEdit(statesTE);		ResetHandle(statesTE, oldstate);{$IFC NOT ALWAYSENABLED}		myDisableItem(EditMHdl, UndoItem); {$ENDC}		statesEditing := true;		stateBeingEdited := theState;		if statesSelected then			begin				InvalidateWindow(statesWindow,false);				statesSelected:= false;			end;	end;{----------------------------------------------------------------------------}	procedure TurnOffStatesEditing;		var			oldState: SignedByte;			ds, oldStateName: str255;			linkH: Handle;			theState: integer;	begin		if statesEditing then			begin				theState := stateBeingEdited;				if theState = kCharNameRow then					oldStateName := CharName(statesWindowCharacter)				else					oldStateName := CharStateName(statesWindowCharacter, theState);				LockHandle(statesTE, oldstate);				GetDialogItemText(statesTE^^.hText, ds);				ResetHandle(statesTE, oldstate);				if ds <> oldstateName then					begin						if theState = kCharNameRow then							begin								SetCharName(statesWindowCharacter,ds);								if editorSelected & OnlySingleNameSelected & (CharOfCell(editorSelectionTopLeft) = statesWindowCharacter) then									FillsTE(editorCellTE,CellString);								infoDirtyNames[charinfo] := true;								SizeInfoWindow(charinfo, true, true);							end						else							begin								AddDotsToStateNames(statesWindowCharacter);								SetCharStateName(statesWindowCharacter, theState, ds);								if editorSelected & SingleCell & not OnlySingleNameSelected & (CharOfCell(editorSelectionTopLeft) = statesWindowCharacter) then									FillsTE(editorCellTE,CellString);							end;						PostStateNameChanged(statesWindowCharacter,theState);					end;				TEDeactivate(statesTE);				statesEditing := false;				dirtyfile := true;			end;	end;{-----------------------------------------------------------------------------}	procedure UpdateSymbolsChanged;	begin		InvalidateWindow(editorWindow, true);		if treeopen & ((traceShown = traceDiscrete) | (traceShown = traceallchanges)) then			godraw := true;		if charton & ( (CWChart = CWCStates)| (CWChart = CWCChanges))then			InvalidateWindow(chartWindow, true);		if editorSelected and SingleCell then			FillsTE(editorCellTE, CellString);		dirtyfile := true;	end;{----------------------------------------------------------------------------}	procedure PopUpSymbolsMenu (theSpot: point);		var			menucode: longint;			ItemNo, currentsel: integer;			TempMHdl: MenuHandle;			box: rect;	begin		TempMHdl := nil;		TempMHdl := NewMenu(TemporaryMenu, 'Temp');		if TempMHdl= nil then			begin				InstantInfo('Problems creating pop-up menu');				 Exit(PopUpSymbolsMenu);			end;		AppendMenu(TempMHdl, 'Standard Symbols');		AppendMenu(TempMHdl, 'Upper Case Letters');		AppendMenu(TempMHdl, 'Lower Case Letters');		InsertMenu(TempMHdl, -1);		LocalToGlobal(thespot);		currentsel := 1;		menucode := PopUpMenuSelect(TempMHdl, thespot.v + 5, thespot.h, currentsel);		ItemNo := LowWord(menucode);		if ItemNo > 0 then			begin				case ItemNo of					1: 						symbols := defSymbols;					2: 						begin							symbols := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';						end;					3: 						begin							symbols := 'abcdefghijklmnopqrstuvwxyz';						end;					otherwise						;				end;				symbols := Copystring(symbols, 1, maxstate + 1);				SetRect(box, statesSymbolWidth, statesWindowTitleWidth, statesNameStart, WindowPortRect(stateswindow).bottom - scrollwidth);				InvalidateWindowRect(statesWindow,box,false);				UpdateSymbolsChanged;			end;		DeleteMenu(TemporaryMenu);		DisposeMenu(TempMHdl);	end;{-----------------------------------------------------------------------------}	procedure ExtendSelectStatesInStatesWindow (oldTop, oldBottom, newState: integer);	begin	end; {-----------------------------------------------------------------------------}	function SymbolAcceptable (theState: integer; c: char): boolean; {check legality of newly typed symbol}		var			bad: boolean;			otherCase: char;	begin		bad := c in (illegalSymbols + extraIllegalStateSymbols + [' '] + [missing,gap,orsep,andsep]);		if not bad then			bad := (pos(c, symbols) > 0) & (pos(c, symbols) <> theState + 1);  {c is in symbols list and is not the same}		if not bad then			begin				otherCase := c;				SwitchCase(otherCase);				bad := (pos(otherCase, symbols) > 0) & (pos(otherCase, symbols) <> theState + 1);  {c is in symbols list and is not the same}			end;		if bad then			NewError(432,0);		SymbolAcceptable := not bad;	end;{-----------------------------------------------------------------------------}	procedure SetStateSymbol (stateNumber: integer; theChar: char);	begin		if SymbolAcceptable(stateNumber, theChar) then			begin				if symbols[stateNumber + 1] <> theChar then					UpdateSymbolsChanged;				symbols[stateNumber + 1] := theChar;				DrawStateSymbol(stateNumber + 1, StatesRowHeightBottom(stateNumber + 1));			end		else			Beep;		symbolson := not StandardSymbols;	end;{-----------------------------------------------------------------------------}	procedure TurnOnSymbolsEditing (theState: integer);		var			box: rect;	begin		statesSymbolIsSelected := true;		statesSymbolSelected := theState;		SetRect(box, statesSymbolWidth, StatesRowHeightTop(theState + 1), statesNameStart, StatesRowHeightBottom(theState + 1));		InvertRect(box);		if statesSelected then			begin				InvalidateWindow(statesWindow,false);				statesSelected:= false;			end;	end;{-----------------------------------------------------------------------------}	procedure TurnOffSymbolsEditing;		var			box: rect;	begin		if statesSymbolIsSelected then			begin				SetRect(box, statesSymbolWidth, StatesRowHeightTop(statesSymbolSelected + 1), statesNameStart, StatesRowHeightBottom(statesSymbolSelected + 1));				InvertRect(box);				statesSymbolIsSelected := false;				dirtyfile := true;			end;	end;{-----------------------------------------------------------------------------}	procedure SelectAllStatesWindow(selectAll: boolean);	begin		if statesEditing then			TurnOffStatesEditing		else if statesSymbolIsSelected then			TurnOffSymbolsEditing;		statesSelected := selectAll;		InvalidateWindow(StatesWindow,false);		FixCopyPasteMenuItems;	end;{-----------------------------------------------------------------------------}	procedure ClickInStatesWindow (theEvent: EventRecord);		var			tport: WindowPtr;			wh: point;			rowNumber, theState: integer;			turnOffAll: boolean;	begin		genericGetPort(tport);		genericSetPort(statesWindow);		wh := Event.where;		GlobalToLocal(wh);		turnOffAll := false;		if wh.v < statesWindowTitleWidth then			begin				theState := kCharNameRow;				rowNumber := 1;			end		else			begin				rowNumber := (wh.v - statesWindowTitleWidth) div statesWindowLineWidth + statesWindowTop;				theState := rowNumber - 1;			end;		if ptinrect(wh, myGetControlRect(statesWindowVScroll)) then			begin				DoStatesScroll(wh);			end		else if ptinrect(wh, myGetControlRect(statesWindowHScroll)) then			begin				if statesEditing then					TurnOffStatesEditing;				DoStatesScroll(wh);			end		else if wh.h > myGetControlRect(statesWindowVScroll).left then			turnoffAll := true		else if not Locked(lockData) then			if wh.h > statesNameStart then   {in character & state names}				begin					{if wh.v <= stateWindowTitleWidth then						turnOffAll:= true					else if wh.v > statesWindowTitleWidth then						}if (wh.v < WindowPortRect(stateswindow).bottom-scrollwidth) &(rowNumber > 0) & (rowNumber <= maxStateRows) then							if ShiftEvent(Event) & statesEditing & (stateBeingEdited <> theState) then								SelectAllStatesWindow(true)							else								begin									TurnOffSymbolsEditing;									if statesEditing & (stateBeingEdited <> theState) then										begin											TurnOffStatesEditing;											TurnOnStatesEditing(theState);										end									else if not statesEditing then										TurnOnStatesEditing(theState)									else   {it is the same one we are already editorOpen}										TEClick(wh, ShiftEvent(Event), statesTE);								end						else							turnOffAll := true;				end			else if (wh.h < statesNameStart) then				begin					if wh.v < statesWindowTitleWidth then						begin							if wh.h > statesSymbolWidth then								PopUpSymbolsMenu(wh)							else								turnOffAll := true;						end					else if (wh.v < WindowPortRect(stateswindow).bottom-scrollwidth) & (rowNumber > 0) & (rowNumber <= maxStateRows) then						if wh.h > statesSymbolWidth then							begin								TurnOffStatesEditing;								if statesSymbolisSelected & (theState <> statesSymbolSelected) then									begin										TurnOffSymbolsEditing;										TurnOnSymbolsEditing(theState);									end								else if not statesSymbolisSelected then									TurnOnSymbolsEditing(theState);							end						else							turnOffAll := true					else 						turnOffAll := true;				end;		if turnOffAll then			begin				if statesEditing then					TurnOffStatesEditing;				if statesSymbolisSelected then					TurnOffSymbolsEditing;			end;		genericSetPort(tport);		FixCopyPasteMenuItems;	end;{-----------------------------------------------------------------------------}	procedure KeyInStatesWindow (theChar: char;theEvent: EventRecord);		var			charcode: integer;			ic: integer;	begin		charcode := ord(theChar);		if statesEditing then			begin				if charcode = 3 then					TurnOffStatesEditing				else if charcode = 13 then  {return}					begin						ic := stateBeingEdited;						if ShiftEvent(Event) then							ic := ic -1						else 							ic := ic+1;						if (ic < 0) | (ic>maxstate) then							Beep						else							begin								TurnOffStatesEditing;								if ic < statesWindowTop-1 then									begin										SetControlValueLong(statesWindowVScroll, GetControlValueLong(statesWindowVScroll) - 1);										ScrollStatesWindow;									end								else if ic > statesWindowTop + statesWindowRows -2 then  {statesWindowTop is 1 based}									begin										SetControlValueLong(statesWindowVScroll, GetControlValueLong(statesWindowVScroll) + 1);										ScrollStatesWindow;									end;								{if icif ShiftEvent(Event) then									SetControlValueLong(statesWindowHScroll, GetControlValueLong(statesWindowVScroll) - 1)								else									SetControlValueLong(statesWindowHScroll, GetControlValueLong(statesWindowVScroll) + 1);								if GetControlValueLong(statesWindowVScroll)								ScrollStatesWindow;}								TurnOnStatesEditing(ic);							end;					end				else if charcode = 9 then  {tab}					begin						TurnOffStatesEditing;						if ShiftEvent(Event) then							SetControlValueLong(statesWindowHScroll, GetControlValueLong(statesWindowHScroll) - 1)						else							SetControlValueLong(statesWindowHScroll, GetControlValueLong(statesWindowHScroll) + 1);						ScrollStatesWindow;					end				else					TEKey(theChar, statesTE);			end		else if statesSymbolIsSelected then			if charcode = 3 then				TurnOffSymbolsEditing			else if charcode = 13 then  {return}				begin					if statesSymbolSelected = maxstate then						Beep					else						begin							TurnOffSymbolsEditing;							TurnOnSymbolsEditing(statesSymbolSelected + 1);						end;				end			else if charcode = 9 then				Beep			else				SetStateSymbol(statesSymbolSelected, theChar)		else if charcode = 9 then  {tab}			begin				if ShiftEvent(Event) then					SetControlValueLong(statesWindowHScroll, GetControlValueLong(statesWindowHScroll) - 1)				else					SetControlValueLong(statesWindowHScroll, GetControlValueLong(statesWindowHScroll) + 1);				ScrollStatesWindow;			end	end;{-----------------------------------------------------------------------------}end.