unit ToolOnBranch;{еееееееееееееееееееееее}interface	uses		QuickDraw, Printing,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, 		TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, 		GenUtil, StrUtil, BoxUtil, MenuUtil, SymbolsNames, IncExcTaxa, Thermos, SpreadUtil, TaxonCHUtil, 		ChartWindow, TypeUtil, CharUtil, SetStates, TreeUtil, InfoWindows, LinkUtil, treemakerutil, Legends, 		Count, Coloring, TraceControl, TreeDrawer, TreeMover, Swap, MCWindows, ClickInInfoWindow, 		BranchListWindow, Prohibitions, CharCorrelation, AncestorSearch;	procedure TraceTickOnBranch(ic:integer);	procedure ShowBranchListWindow(N: NPtr);	function TickCharacterBox(N: Nptr; tickCharacter: integer): rect;	function FoundTickBoxNearBranch(var N:Nptr; wh: point; var foundChar: integer): boolean;	function FoundTickNearBranch(var N:Nptr; wh: point; var foundChar: integer): boolean;	function BranchTickCharacter(N:Nptr; wh: point; var foundChar: integer): boolean;	procedure FindTickCharacter(N: Nptr; wh: point; var foundChar: integer);	procedure ToolOnAllOfClass(tickClass: integer);	procedure ReportOnBranch(N:Nptr; wh: point);	procedure ToolOnBranchTick(whichTool: integer; N:Nptr; wh: point);	procedure ToolOnBranch (toolT: Integer; N: Nptr);{еееееееееееееееееееееее}implementation {е$S ToolOnBranch}{$IFC SETBRANCHLENGTHS}{----------------------------------------------------------------------------}	procedure SetBranchLength (N: Nptr; theSpot: point);		var			menucode: longint;			ItemNo, currentsel, j: integer;			lengthMHdl: MenuHandle;			success: boolean;	begin		lengthMHdl := nil;		lengthMHdl := GetMenu(31);		InsertMenu(lengthMHdl, -1);		LocalToGlobal(thespot);		currentsel := 1;		menucode := PopUpMenuSelect(lengthMHdl, thespot.v + 5, thespot.h, currentsel);		ItemNo := LowWord(menucode);		if ItemNo > 0 then			begin				if ItemNo = 11 then					begin						j := GetLongint('Number of segments:', 1, 0, maxBranchSegments, success);						if success then							N^.setLength := j;					end				else					N^.setLength := ItemNo - 1;				if contweighted then					golist := golist + [GOcontinuous];				if (seglistenProb) then					begin{$IFC PROBRECONSTRUCT}						if traceshown = traceprobability then							golist := golist + [GOProbability];{$ENDC}{$IFC PROBSTEPCHART}						if charton and (CWChart = CWCProbSteps) then							golist := golist + [goProbStepsChart];{$ENDC}					end;				dirtyfile := true;			end;		DeleteMenu(31);	end;{-----------------------------------------------------------------------------}{$ENDC}{-----------------------------------------------------------------------------}	function TickCharacterBox(N: Nptr; tickCharacter: integer): rect;	var 	afN: Nptr;		vpos: longint;		v, right, h: longint;		vinc, curTick, numTicks, ic,top,bottom,left: integer;		box: rect;	begin		TextFont(maccladesmall);		TextFace([]);		TextSize(9);		SetRect(box,0,0,0,0);		CalcVertTickSpacings (N,vinc,vpos);		{Drawstring(LengthString(N^.length1, branchlengthsWeighted));}		afN := NotNullAnc(N);		numTicks:= 0;		for ic := 1 to tickCharacter do			if CharIncluded(ic) & (typeofchar(ic) <> fisher) & changetoshow(N, afN, ic, branchlistmode, false) then				numTicks := numTicks+1			else if ic=tickCharacter then				numTicks := 0;		{now we know that it is tick down}		if numTicks > 0 then			begin				CalcTickBoundaries(N,vpos+vinc*(numTicks-1),h,right);				v := N^.loc.v + vpos+vinc*(numTicks-1);				SetRect(box, right, v - FontHeight div 2, right+StringWidth(StringFromNum(numchars))+4, v + FontHeight div 2);			end;		TextFont(kFontIDGeneva);		TextFace(treetaxastyle);		TextSize(treetaxafontsize);		TickCharacterBox := box;	end;{-----------------------------------------------------------------------------}	procedure FindTickCharacter(N: Nptr; wh: point; var foundChar: integer);	var 	afN: Nptr;		vpos: longint;		vinc, curTick, tick, ic,ir, tickClass, tickBelow, tickAbove: integer;	begin		CalcVertTickSpacings (N,vinc,vpos);		{Drawstring(LengthString(N^.length1, branchlengthsWeighted));}		afN := NotNullAnc(N);{$IFC FALSE}		if treeflipped then 			curTick := RoundValue(1.0* (wh.h-(N^.loc.h + vpos)) / vinc)+1		else			curTick := RoundValue(1.0* (wh.v-(N^.loc.v + vpos)) / vinc)+1;{$ELSEC}		curTick := RoundValue(1.0* (wh.v-(N^.loc.v + vpos)) / vinc)+1;{$ENDC}		tick:= 0;		foundChar  := 0;		for ic := 1 to numchars do			if CharIncluded(ic) & (typeofchar(ic) <> fisher) then				if changetoshow(N, afN, ic, branchlistmode, false) then					begin						tick := tick+1;						if tick=curTick then							begin								foundChar := ic;								leave;							end;					end;	end;{-----------------------------------------------------------------------------}	procedure TraceTickOnBranch(ic:integer);	var 	oldi: integer;	begin		if traceTickToolTemporary then			begin				oldi := i;				i := ic;				ReconstructTraced;				SetCursH(tool^[treeTools,currentTool[treeTools]].curs);				TurnOffTickFlash;				TemporaryColorCharacter(true);				i := oldi;			end		else			TurnOnTrace(i, ic);	end;{-----------------------------------------------------------------------------}	procedure ReportOnBranch(N:Nptr; wh: point);	var 	ds, ds2: str255;		index: double;		afN: Nptr;		ambigTick, firstThrough: boolean;		ir, tickClass, tickBelow, tickAbove, foundchar,ic, oldi, changeClass: integer;		MaxNumStates, NumStates: numstatearray;		H: Handle;	begin		afN:= NotNullAnc(N);		H := NewHandle(0);		if BranchExists(N) then			if  (traceshown = traceAllChanges) then				if (summaryview=asticks) then					begin						if (PartofPolytomy(N) and not polyreal) then							AppendToHandle(H,'Not Calculated')						else if N = R then							AppendToHandle(H,'Root: no changes')						else							begin								FindTickCharacter(N,DisOrientPoint(wh),foundChar);								ic := foundChar;								if foundChar > 0 then									begin										ds := GetCharAndStates(N, getstslargest(afN, ic), getstslargest(N, ic), false, ic, true);										PrepareCharAndStates(ds);										AppendToHandle(H,ds);										AppendChangeReporttoHandle(H,N,ic);									end								else									begin										ZapHandle(H);										Exit(ReportOnBranch);									end;							end;						wh.h := wh.h+16;						if GetHandleSize(H) > 0 then							PlaceTextHandleWhileButtonDown(H,wh);						{PlaceTextWhileButtonDown (ds,wh);}					end				else  {trace all changes, but not summaryview=asticks}					begin						firstThrough := true;						for ic := 1 to numchars do							if CharIncluded(ic) & (typeofchar(ic) <> fisher) & changetoshow(N, afN, ic, branchlistmode, false) then								begin									DetermineTickClass(N,ic,tickClass, tickBelow, tickAbove, changeClass);									ambigTick := ambigDistinguish & (tickClass = tickAmbiguous);									if  not ambigTick  then										begin											if firstThrough then												begin													AppendToHandle(H,'Unambiguous changes:');													AppendToHandle(H,chr(13));													firstThrough := false;												end;											ds := GetCharAndStates(N, getstslargest(afN, ic), getstslargest(N, ic), false, ic, true);											PrepareCharAndStates(ds);											AppendToHandle(H,ds);											AppendToHandle(H,chr(13));										end;								end;						firstThrough := true;						if branchlistmode<> unambigmode then							for ic := 1 to numchars do								if CharIncluded(ic) & (typeofchar(ic) <> fisher) & changetoshow(N, afN, ic, branchlistmode, false) then									begin										DetermineTickClass(N,ic,tickClass, tickBelow, tickAbove, changeClass);										ambigTick := ambigDistinguish & (tickClass = tickAmbiguous);										if ambigTick then											begin												if firstThrough then													begin														AppendToHandle(H,chr(13));														AppendToHandle(H,'Ambiguous changes:');														AppendToHandle(H,chr(13));														firstThrough := false;													end;												ds := GetCharAndStates(N, getstslargest(afN, ic), getstslargest(N, ic), false, ic, true);												PrepareCharAndStates(ds);												AppendToHandle(H,ds);												AppendToHandle(H,chr(13));											end;									end;						wh.h := wh.h+16;						if GetHandleSize(H) > 0 then							PlaceTextHandleWhileButtonDown(H,wh);					end			else				begin						CalcNumStateFrequency(N,numStates, maxNumStates);						ds := '';						for ir := 0 to maxstate do							begin								if NumStates[ir] <> MaxNumStates[ir] then									ds := concat(ds,CharOfNum(ir), ':  ', StringFromNum(NumStates[ir]), '-', StringFromNum(MaxNumStates[ir]),chr(13))								else									ds := concat(ds,CharOfNum(ir), ':  ', StringFromNum(NumStates[ir]),chr(13));							end;						wh.h := wh.h+16;						PlaceTextWhileButtonDown (ds,wh, false);				end;		ZapHandle(H);	end;{-----------------------------------------------------------------------------}	function FoundTickBoxNearBranch(var N:Nptr; wh: point; var foundChar: integer): boolean;	label 1;	var	afN: NPtr;	{.............}		procedure FoundTickBoxRec(tN: Nptr);		var ic: integer;		begin			if BranchExists(tN) & (tN<> screenR) then				begin					afN:= NotNullAnc(tN);					for ic := 1 to numchars do						if CharIncluded(ic) & (typeofchar(ic) <> fisher) & changetoshow(tN, afN, ic, branchlistmode, false) then							if PtInRect(wh,TickCharacterBox(tN,ic)) then								begin									foundChar := ic;									N := tN;									goto 1;								end;				end;			if NodeIsInternal(tN) then				begin						FoundTickBoxRec(tN^.lf);					FoundTickBoxRec(tN^.rt);				end;		end;	{.............}	begin		FoundTickBoxNearBranch := false;		foundChar := 0;		N := nil;		FoundTickBoxRec(ScreenR);1:					FoundTickBoxNearBranch := (N<>nil);	end;{-----------------------------------------------------------------------------}	function FoundTickNearBranch(var N:Nptr; wh: point; var foundChar: integer): boolean;	var	afN: NPtr;	begin		FoundTickNearBranch := false;		foundChar := 0;		if squareBranches then			begin				if  FindJustRightOfBranch(wh, ScreenR, N) then					FoundTickNearBranch := BranchTickCharacter(N,wh,foundChar);			end		else			FoundTickNearBranch := FoundTickBoxNearBranch(N,wh,foundChar);	end;{-----------------------------------------------------------------------------}	function BranchTickCharacter(N:Nptr; wh: point; var foundChar: integer): boolean;	begin		BranchTickCharacter := false;		if BranchExists(N) &  (traceshown = traceAllChanges) & (summaryview=asticks) & not ticksNoNames then			if not (PartofPolytomy(N) & not polyreal) & (N<>R) then				begin					FindTickCharacter(N,DisOrientPoint(wh),foundChar);					BranchTickCharacter := foundChar > 0;				end;	end;{-----------------------------------------------------------------------------}	procedure ShowBranchListWindow(N: NPtr);	var		d1, d2: longint;	begin		BranchListN := N;		if not BranchListon then			OpenBranchListWindow;		MakeBranchList(BranchListN, d1, d2, 0, 0, listToWindow);		DrawBranchListWindow;	end;{-----------------------------------------------------------------------------}	procedure SelectAllTicksOnBranch(N: Nptr);	var ic: integer;		afN: NPtr;	begin		afN:= NotNullAnc(N);		for ic := 1 to numchars do			SelectInfoCell(charinfo,ic,CharIncluded(ic) & (typeofchar(ic) <> fisher) & changetoshow(N, afN, ic, branchlistmode, false), false);		ChangeInfoSelectMenuFix(charinfo);		OpenOrSelectInfoWindow(charinfo);		ScrollInfoWindowToSelectedRow(charinfo);	end;{-----------------------------------------------------------------------------}	procedure ToolOnAllOfClassOnBranch(tickClass: integer; N: Nptr);	var ic: integer;		afN: NPtr;		theClass,tickBelow, tickAbove, changeClass: integer;		polyoranc, didChange: boolean;	begin		afN:= NotNullAnc(N);		didChange := false;		polyoranc := nullson or ancon;		for ic := 1 to numchars do			if CharIncluded(ic) & (typeofchar(ic) <> fisher) & changetoshow(N, afN, ic, branchlistmode, false) then				begin					DetermineTickClass(N,ic,theClass, tickBelow, tickAbove, changeClass);					if theClass=tickClass then 						case currentTool[treeTools] of							treeWandT: 								SelectInfoCell(charinfo,ic,true,false);							scissorsT:								if ChangeIncExc(ic, ExcludeItem, polyoranc) then									didChange := true;																otherwise;						end;				end;		ChangeInfoSelectMenuFix(charinfo);		if didChange then			PostIncExcCharactersChange;	end;{-----------------------------------------------------------------------------}	procedure SelectAllOfClass(tickClass: integer);	var ic: integer;		procedure SelectAllOfClassRec(N: Nptr);		begin			if BranchExists(N) & (N<> screenR) then				ToolOnAllOfClassOnBranch(tickClass,N);			if NodeIsInternal(N) then				begin						SelectAllOfClassRec(N^.lf);					SelectAllOfClassRec(N^.rt);				end;		end;	begin		for ic := 1 to numchars do			SelectInfoCell(charinfo,ic,false,false);		ChangeInfoSelectMenuFix(charinfo);		SelectAllOfClassRec(screenR);		OpenOrSelectInfoWindow(charinfo);		ScrollInfoWindowToSelectedRow(charinfo);	end;{-----------------------------------------------------------------------------}	procedure ExcludeAllOfClass(tickClass: integer);		procedure ExcludeAllOfClassRec(N: Nptr);		begin			if BranchExists(N) & (N<> screenR) then				ToolOnAllOfClassOnBranch(tickClass,N);			if NodeIsInternal(N) then				begin						ExcludeAllOfClassRec(N^.lf);					ExcludeAllOfClassRec(N^.rt);				end;		end;	begin		ExcludeAllOfClassRec(screenR);	end;{-----------------------------------------------------------------------------}	procedure ToolOnAllOfClass(tickClass: integer);	begin		case currentTool[treeTools] of			treeWandT: 				SelectAllOfClass(tickClass);			scissorsT:				ExcludeAllOfClass(tickClass);			otherwise;		end;	end;{-----------------------------------------------------------------------------}	function TaxonInClade(ancN: Nptr; it: integer): boolean;	begin		TaxonInClade := TaxonInTree(it) & IsAnc(ancN, GetTaxonHdl(it)^^.N);	end;{-----------------------------------------------------------------------------}	procedure SelectAllInClade(N: Nptr);	var it: integer;	begin		for it := 1 to numTaxa do			SelectInfoCell(taxinfo,it,TaxonInClade(N,it),false);		ChangeInfoSelectMenuFix(taxinfo);		OpenOrSelectInfoWindow(taxinfo);		ScrollInfoWindowToSelectedRow(taxinfo);	end;{-----------------------------------------------------------------------------}	procedure ToolOnBranchTick(whichTool: integer; N:Nptr; wh: point);	var 	foundchar: integer;		polyOrAnc: boolean;	begin		if BranchTickCharacter (N,wh,foundChar) then			begin				case whichTool of					scissorsT:						begin							polyoranc := nullson or ancon;							if ChangeIncExc(foundChar, ExcludeItem, polyoranc) then								PostIncExcCharactersChange;						end;					treeWandT:						SelectAllTicksOnBranch(N);					traceTickT:						TraceTickOnBranch(foundChar);					otherwise;				end;				TurnOffTickFlash;			end;			end;{-----------------------------------------------------------------------------}	procedure AncestorToolOnBranch (N: Nptr);	var		goahead: boolean;	begin		if (ancestorToolMode=ancestorToolNormalMode) | NodeIsTerminal(N) then				begin					if N^.fixanc then						begin							fullundo := true;							justundid := false;							undotype := justmove;							noundo := false;							StoreOldTreeForUndo;							if NodeIsInternal(N) then								if isTerminalFixanc(N^.lf) then									N^.lf^.fixanc := false								else									N^.rt^.fixanc := false							else								N^.anc^.fixanc := false;							N^.fixanc := false;							SetDirtyTree;							dirtyfile := true;							SetAncOn;							godraw := true;							RearrangeTreeGoList;  {change fixanc; redo golist }							InvalidateWindow(tlegwindow, false);							justchanc := true;							FixTreeShadingMenus;							myEnableItem(EditMHdl, UndoItem);						end					else if fixancLegal(N, true) then						begin							goahead := true;							if N^.fix then								goahead := CWarning('State of taxon will be unfixed before made ancestor. ', 'OK', 'Cancel');							if goahead & (not allSetLengths1) then								begin									goahead := CWarning('Evolve segments will all be set to 1. ', 'OK', 'Cancel');									if goahead then										SetLengths(R, evolveSegmentsAllOneMode);								end;							if goahead then								begin									fullundo := true;									justundid := false;									undotype := justmove;									noundo := false;									StoreOldTreeForUndo;									ancon := true;									SetDirtyTree;									dirtyfile := true;									N^.fixanc := true;									N^.anc^.fixanc := true;									myEnableItem(TreeMHdl, AllTermItem);									myEnableItem(EditMHdl, UndoItem);									if N^.anc^.fix then										dirtyfix := true;									N^.anc^.fix := false;									if TaxonPolyFixancBeware(N^.name) then										NewError(90, 0);									polyon := false;									if N^.fix then										dirtyfix := true;									N^.fix := false;									SetFixon;									Setancon;									godraw := true;									RearrangeTreeGoList;  {change fixan; do golist }									InvalidateWindow(tlegwindow, false);									justchanc := true;									FixTreeShadingMenus;								end;						end;				end			else				begin					goahead := true;					if (not allSetLengths1) then						begin							goahead := CWarning('Evolve segments will all be set to 1. ', 'OK', 'Cancel');							if goahead then								SetLengths(R, evolveSegmentsAllOneMode);						end;					if goahead then						begin							OptimalAncestorSearch(N,true,false);						end;				end;	end;{-----------------------------------------------------------------------------}	procedure ToolOnBranch (toolT: Integer; N: Nptr); {command processed on branch}		label			1;		var			oldCollapsetreeTE: TEHandle;			dummyR: rect;			ds, tds: str255;			sisN, tN: NPtr;			tport: windowptr;			useset: largestsetchars;			wh: point;			whLong: LongPoint;			timesThrough: integer;	begin		genericGetPort(tport);		case toolT of			rerootT: 				if (N <> ScreenR) and ((N^.anc <> ScreenR) or NodeIsPolytomous(ScreenR)) and BranchExists(N) then					begin						setcursor(clockCursor);						Reroot(N, screenR);						godraw := true;						InvalidateWindow(tlegwindow, false);					end;								treeWandT:				if BranchExists(N) then					SelectAllInClade(N);			scissorsT: 				if (N <> screenR) and BranchExists(N) then					begin						if UseOptionTool(treeTools,scissorsT,OptionEvent(Event)) then							while button do								SetCursor(closeddownScissors)						else							while button do								SetCursor(closedScissors);						if (UseOptionTool(treeTools,scissorsT,OptionEvent(Event)) and (numtaxain - (SizeOfClade(screenR, true) - SizeOfClade(N, true)) < minTaxaIn)) or (not UseOptionTool(treeTools,scissorsT,OptionEvent(Event)) and (numtaxain - SizeofClade(N, true) < minTaxaIn)) then							InstantError(291)    {Only allow if at least three remain}						else							begin								StoreOldTreeForUndo;								if UseOptionTool(treeTools,scissorsT,OptionEvent(Event)) then		{delete below branch}									begin										ntscreen := SizeOfClade(N, true);										if (N <> screenR^.lf) and (N <> screenR^.rt) then											Reroot(N, screenR);										if NodeSlantsRight(N) then											DeleteClade(screenR^.lf)										else											DeleteClade(screenR^.rt);									end								else									begin										ntscreen := ntscreen - SizeOfClade(N, true);										if N^.anc^.fix then											NewError(334, 0); {Warning that fix state undone}										DeleteClade(N);										if ntscreen <= 1 then											ShrinkTree;									end;								IncExcChangePosting(false);							end;					end				else					Beep;			paintT: 				if (traceshown = traceDiscrete) and not N^.fixanc then					begin						if typeofchar(i) = fisher then							NewError(373, 0)						else if UseOptionTool(treeTools,paintT,OptionEvent(Event)) then							begin								TryAllFixes(N);							end						else if (brushset <> []) then							begin								setcursor(clockCursor);								N^.fix := TRUE;								dirtyfix := true;								fixon := TRUE;								myEnableItem(TraceMHdl, UnfixAllItem);								N^.fixsts := brushset;								FixStateGoList;								InvalidateWindow(twmesswindow, false);							end;					end				else if N^.fixanc then					NewError(353, 0)				else if tool^[treeTools,paintT].enabled and (brushset = []) then					begin						Beep;						EraseAsterisksEtc;					end;			turpentineT: 				if (traceshown = traceDiscrete) and N^.fix and BranchExists(N) then					begin						setcursor(clockCursor);						N^.fix := FALSE;						dirtyfix := true;						SetFixon;						if not fixon then							begin								SetTool(treeTools,arrowT);								godraw := true;							end;						FixStateGoList;						InvalidateWindow(twmesswindow, false);					end;			arrowT: 				if (storedN = subR) and BranchExists(N) then					begin						tool^[treeTools,arrowT].curs := diamond;						setcursH(diamond);						storedN := N;						writePalmessageB(treeTools,'Branch stored')					end;			ancT: 				AncestorToolOnBranch(N);			collapseallT: 				if NodeIsInternal(N) & not collapseProhibited(N, true) then					begin						StoreOldTreeForUndo;						if UseOptionTool(treeTools,collapseAllT,OptionEvent(Event)) then  {collapse below}							begin								if N <> screenR then									begin										if (N <> screenR^.lf) and (N <> screenR^.rt) then											Reroot(N, screenR);										if NodeSlantsRight(N) then											begin												if NodeIsInternal(ScreenR^.lf) then													begin														CollapseClade(ScreenR^.lf^.lf);														CollapseClade(ScreenR^.lf^.rt);														ScreenR^.lf^.null := true;														if ScreenR^.lf^.setLength <> 1 then															begin																ScreenR^.lf^.setLength := 1;																NewError(390, 0);															end;													end;											end										else if NodeIsInternal(N^.anc^.rt) then											begin												CollapseClade(ScreenR^.rt^.lf);												CollapseClade(ScreenR^.rt^.rt);												ScreenR^.rt^.null := true;												if ScreenR^.rt^.setLength <> 1 then													begin														ScreenR^.rt^.setLength := 1;														NewError(390, 0);													end;											end;									end							end						else							begin								CollapseClade(N^.lf);								CollapseClade(N^.rt);								DrawR := N;							end;						undotype := justCollapseAll;						justundid := false;						myEnableItem(EditMHdl, UndoItem);						DrawRloc := DrawR^.loc;						noundo := false;						godraw := true;						RearrangeTreeGoList;  {change collapse; redo golist }						InvalidateWindow(tlegwindow, false);						dirtyfile := true;						SetDirtyTree;						setnullson;						myEnableItem(EditMHdl, UndoItem);						FixTreeShadingMenus;					end;			collapseT: 				if (N <> ScreenR) & (NodeIsInternal(N)) & not collapseProhibited(N, false) then					begin						if N^.setlength <> 1 then							begin								N^.setlength := 1;								NewError(390, 0);							end;						fullundo := false;						nomove := true;{treechanged := true;}						if N^.fix then							begin								InstantError(224);								dirtyfix := true;							end;						N^.fix := false;						SetFixon;						N^.null := true;						myEnableItem(EditMHdl, UndoItem);						undotoN := N;						undotoNull := 0;						undotype := justmove;						justundid := false;						FixLostByUndo := false;						noundo := false;						DrawR := NotNullAnc(N);						DrawRloc := DrawR^.loc;						godraw := true;						RearrangeTreeGoList;  {change collapse; redo golist }						InvalidateWindow(tlegwindow, false);						dirtyfile := true;						SetDirtyTree;						setnullson;						FixTreeShadingMenus;					end;			expandT: 				if (NodeIsInternal(N)) and (N <> ScreenR) then					begin						ScreenR := N;						DrawR := N;						ntscreen := SizeofClade(N, true);						godraw := true;						myEnableItem(ShowMHdl, ShrinkItem);						expd := TRUE;						TWOrigin.h := 0;						TWOrigin.v := 0;						SetDrawTWRControls;						EnableDisableItem(TraceMHdl, EquivCycleItem, (traceshown = traceDiscrete) & (resolveoption = allpossible) & EquivocalLegal(screenR));						EnableDisableItem(TraceMHdl, NumberMPRsItem, (traceshown = traceDiscrete) & (resolveoption = allpossible) & EquivocalLegal(screenR));					end				else if (N = ScreenR) and (N <> R) then					begin						godraw := true;						if OptionEvent(Event) and (NotNullAnc(N) <> R) then							begin	{partial shrink}								ntscreen := SizeofClade(NotNullAnc(N), false);								ScreenR := NotNullAnc(N);								DrawR := NotNullAnc(N);								goTWHome := true;							end						else							ShrinkTree;						EnableDisableItem(TraceMHdl, EquivCycleItem, (traceshown = traceDiscrete) & (resolveoption = allpossible) & EquivocalLegal(screenR));						EnableDisableItem(TraceMHdl, NumberMPRsItem, (traceshown = traceDiscrete) & (resolveoption = allpossible) & EquivocalLegal(screenR));					end;			swapT: 					begin						oneswap := not multipleSwaps;						if not UseOptionTool(treeTools,toolT,OptionEvent(Event))  then {Swap Above}							begin								if (NodeIsInternal(N))  & (NodeIsInternal(N^.lf) | NodeIsInternal(N^.rt)) then									BranchSwap(N, true);							end						else if (N <> R) and (N^.anc <> R) then  {Swap Below}							BranchSwap(N, false);					end;			evolveSegmentsT:					begin						if ancon then							NewError(391, 0)						else							case evolveSegmentsToolMode of								evolveSegmentsNormalMode:									begin										wh := Event.where;										genericSetPort(treewindow);										GlobalToLocal(wh);										SetBranchLength(N, wh);										godraw := true;									end;								evolveSegmentsAllOneMode:									SetLengths(N,evolveSegmentsAllOneMode);								evolveSegmentsRandomMode:									SetLengths(N,evolveSegmentsRandomMode);								{evolveSegmentsUltraMetricMode:									SetLengths(N,evolveSegmentsUltraMetricMode);}								otherwise ;							end;					end;						rotateT: 				if (NodeIsInternal(N)) then					begin						setcursor(clockCursor);						FlipNode(N);					end;			queryT: 				if (traceshown = traceDiscrete) and BranchExists(N) then					begin						if OptionEvent(Event) then							begin								ds := concat('Final: ', StsToString(N^.final, i, tracelabelsbyname,false));								if TypeOfChar(i) <= fisher then									begin										ds := concat(ds, chr(13), 'Down: ', StsToString(N^.down, i, tracelabelsbyname,false));										if (NodeIsInternal(N)) & (N <> R) & (typeofchar(i) <= ordered) then											ds := concat(ds, chr(13), 'Up: ', StsToString(N^.up, i, tracelabelsbyname,false));									end;							end						else							ds := concat('State(s): ', StsToString(N^.final, i, tracelabelsbyname,false));						while (pos(andsep, ds) > 0) do							ds[pos(andsep, ds)] := ',';						wh.v := N^.loc.v;						wh.h := N^.loc.h;						wh.v := wh.v + 20;						timesThrough := 0;1:						if not PtInRect(wh, treerect) then   {not in treerect, either hidden by databoxes or off window}							begin								if wh.h > treerect.right then  {a right leaning branch going off right side}									begin										if not squarebranches then											wh.v := wh.v + (wh.h - treerect.right);										wh.h := treerect.right - 2;									end								else if wh.h < treerect.left then  {a left leaning branch going off left side}									begin										if not squarebranches then											wh.v := wh.v + (treerect.left - wh.h);										wh.h := treerect.left + 2;									end								else {must be off top}									begin										if not squarebranches then											if NodeSlantsRight(N) then												wh.h := wh.h - (treerect.top - wh.v)											else												wh.h := wh.h + (treerect.top - wh.v);										wh.v := treerect.top + 10;									end;								timesThrough := timesThrough + 1;								if timesThrough = 1 then									goto 1;   {go back and try again just in case not go it right the first time}							end;						PopUpStringMenu(wh, ds);					end				else if ((traceshown = traceAllChanges) or (traceshown = traceAllStates)) and BranchExists(N) then					begin						if queryToolsPopUp then							begin								wh := Event.where;								genericSetPort(treewindow);								GlobalToLocal(wh);								ReportOnBranch(N,wh);							end						else							ShowBranchListWindow(N);					end;			ladderT: 				if (NodeIsInternal(N)) then					begin						setcursor(clockCursor);						if UseOptionTool(treeTools,toolT,OptionEvent(Event)) then							ladderDir := -1						else							ladderDir := 1;						Ladderize(N);						godraw := true;						DrawR := N;						DrawRloc := N^.loc;					end;			statsTestT: 				begin					cladeN := N;					if (NodeIsInternal(N)) then						DoCharCorrel(N);				end;			otherwise				;		end;		genericSetPort(tport);	end;end.