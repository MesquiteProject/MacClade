unit ProbReconstruct;{еееееееееееееееееееееее}interface{Wayne: save with SFPutfile}{Wayne: when don't add up to one do more gracefully} {Wayne: double check probchange declaration in TreeRandomData}{Wayne: check for branch move screwing up segments & give warning}{Wayne: GLOBAL: change name of probtreeitem, probrecitem}	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  UtilLibInterface, SetLibInterface,   MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, CharUtil, TreeUtil, MenuUtil, Prohibitions, Legends, Thermos, TypeUtil, TraceControl;{$IFC PROBSTEPCHART or PROBRECONSTRUCT}	procedure CalculateSegmentProbs;	procedure Autothermocursor (var kurrent: integer; low, high: integer);	function ProbChangeBranch (N: Nptr; ancstate, state: integer): double;	procedure DoProbReconstruct (istrace: boolean);	procedure CalcProbReconstruct;	const		TrueRootState = 0;		maxtaxasteps = 50;	type		stepsarray = array[0..maxtaxasteps, 0..2, 0..1] of double; {for steps counting, at each node еее trees of 40 taxa only!!!}		stepsptr = ^stepsarray;		ssprobarray = array[0..2, 0..1] of double;		change = (gain, loss);		probptr = ^prec;		prec = record				downgiven, upand, finalgiven: ssprobarray;				changegiven: array[gain..loss, 0..1, 0..1] of double;				minprchange, maxprchange: double;				true: array[0..1] of double;			end;		chsegptr = ^segar;		segar = array[0..1, 0..1, 1..1000] of double;	var		probchgsegs: chsegptr; {prob change on branch of certain number of segments}		nnum: integer;		probstepsvalues: array[0..maxtaxasteps] of double;		mean: double;{$ENDC}{еееееееееее}implementation{$IFC PROBSTEPCHART or PROBRECONSTRUCT}{ ProbModelItem;  probTreeitem}{numsteps, allstates }{====================================================================}	procedure CalculateSegmentProbs;		var			ta, tn, iseg: integer;	begin		for ta := 0 to 1 do			for tn := 0 to 1 do				probchgsegs^[ta, tn, 1] := probchangeRec[ta, tn];		for iseg := 2 to 1000 do			begin				for ta := 0 to 1 do					for tn := 0 to 1 do {2 possibilities; previous seg ended at 0 or at 1}						probchgsegs^[ta, tn, iseg] := probchgsegs^[ta, 0, iseg - 1] * probchangeRec[0, tn] + probchgsegs^[ta, 1, iseg - 1] * probchangeRec[1, tn];			end;	end;{-----------------------------------------------------------------------------}	procedure Autothermocursor (var kurrent: integer; low, high: integer);{157 to 183}	begin		if kurrent < low then			kurrent := low		else if kurrent > high then			kurrent := high;		SetCursID(157 + ((kurrent - low) * 26) div (high - low));		kurrent := kurrent + 1;	end;{-----------------------------------------------------------------------------}	function ProbChangeBranch (N: Nptr; ancstate, state: integer): double;	begin		if seglistenProb then			ProbChangeBranch := probchgsegs^[ancstate, state, N^.setlength]		else			ProbChangeBranch := probchangeRec[ancstate, state];	end;{-----------------------------------------------------------------------------}	function DownGivenAnc (N: Nptr; downset, ancstate: integer): double;	begin		DownGivenAnc := probptr(N^.bset1)^.downgiven[downset, 0] * ProbChangeBranch(N, ancstate, 0) + probptr(N^.bset1)^.downgiven[downset, 1] * ProbChangeBranch(N, ancstate, 1);	end;{-----------------------------------------------------------------------------} {Calculates probability of downset given true state for all nodes}	procedure DownCalcProbs (N: Nptr);		var			a, b: integer;			P: probptr;	begin		N^.bset1 := NewPtr(SizeOf(prec));		P := probptr(N^.bset1);		if NodeIsTerminal(N) then			begin {initialize for terminals}				for a := 0 to 2 do					for b := 0 to 1 do						P^.downgiven[a, b] := 0;				P^.downgiven[0, 0] := 1;  {prob downset is [0] is 1 only if true state is 0}				P^.downgiven[1, 1] := 1;  {prob downset is [1] is 1 only if true state is 1}			end		else			begin				DownCalcProbs(N^.lf);				DownCalcProbs(N^.rt);{N's state reconstructed [0] or [1]}				for a := 0 to 1 do  {a = [0] or [1] downstate at N}					for b := 0 to 1 do  {b = 0 or 1 true states at N}						begin							P^.downgiven[a, b] := 0; {initialize to 0}{There are three cases in which N's downstate set could be reconstructed as a = [0] or [1]}{ case 1: [a] at left and [a] at right}							P^.downgiven[a, b] := P^.downgiven[a, b] + (DownGivenAnc(N^.lf, a, b) * DownGivenAnc(N^.rt, a, b));{ case 2: [01] at left and [a] at right}							P^.downgiven[a, b] := P^.downgiven[a, b] + (DownGivenAnc(N^.lf, 2, b) * DownGivenAnc(N^.rt, a, b));{ case 3: [a] at left and [01] at right}							P^.downgiven[a, b] := P^.downgiven[a, b] + (DownGivenAnc(N^.lf, a, b) * DownGivenAnc(N^.rt, 2, b));						end;{N's state reconstructed [01]; i.e. a=2}				for b := 0 to 1 do {b = 0 or 1 true states at N}					begin						P^.downgiven[2, b] := 0; {initialize to 0}{There are three cases in which N's state could be reconstructed as 2 = [01]}{ case 1: [01] at both left and right}						P^.downgiven[2, b] := P^.downgiven[2, b] + (DownGivenAnc(N^.lf, 2, b) * DownGivenAnc(N^.rt, 2, b));{ case 2: [a] at left and [a] at right}						P^.downgiven[2, b] := P^.downgiven[2, b] + (DownGivenAnc(N^.lf, 0, b) * DownGivenAnc(N^.rt, 1, b));{ case 3: [a] at left and [a] at right}						P^.downgiven[2, b] := P^.downgiven[2, b] + (DownGivenAnc(N^.lf, 1, b) * DownGivenAnc(N^.rt, 0, b));					end;			end;		AutoThermocursor(nnum, 0, numtaxain * 6 - 2);	end;{-----------------------------------------------------------------------------} {Calculates probability of upset *and* true state for all nodes}{terminal nodes calculated for use in change probability calculations}	procedure UpCalcProbs (N: Nptr);		var			a, b, c: integer;			puptemp: double;	begin		if N = R then			begin				probptr(N^.bset1)^.true[TrueRootState] := 1;				probptr(N^.bset1)^.true[abs(TrueRootState - 1)] := 0;			end		else if N^.anc = R then			begin				for b := 0 to 1 do					probptr(N^.bset1)^.true[b] := probptr(N^.anc^.bset1)^.true[0] * ProbChangeBranch(N, 0, b) + probptr(N^.anc^.bset1)^.true[1] * ProbChangeBranch(N, 1, b);				for a := 0 to 2 do  {upstate reconstructed: [0] or [1] at N}					for b := 0 to 1 do  {0 or 1 true states at N}						probptr(N^.bset1)^.upand[a, b] := DowngivenAnc(Sis(N), a, TrueRootState) * ProbChangeBranch(N, TrueRootState, b);			end		else			begin				for b := 0 to 1 do					probptr(N^.bset1)^.true[b] := probptr(N^.anc^.bset1)^.true[0] * ProbChangeBranch(N, 0, b) + probptr(N^.anc^.bset1)^.true[1] * ProbChangeBranch(N, 1, b);{N's state reconstructed [0] or [1]}				for a := 0 to 1 do  {upstate reconstructed: [0] or [1] at N}					for b := 0 to 1 do  {0 or 1 true states at N}						begin							probptr(N^.bset1)^.upand[a, b] := 0; {initialize to 0}							for c := 0 to 1 do {true state given at ancestor of N}								begin{To calculate the upstates at N, we need to look to sister and ancestor.  The probability that N has}{truly state b and is reconstructed as state a is obtained by summing probabilities arising under}{the two mutually-exclusive cases that the true state of the ancestor of N is c = 0 or 1.  Given the true}{state of the ancestor is c, then the desired situation of a and b at N can be obtained when the sister}{and ancestor have state sets that combine to yield a and when a c to b change occurs along N's }{branch.  Thus we multiply the probability for the latter (probchangeRec[c,b]) by the sum of all probabilities ***}{for ways of getting correct state set at N.  If a is  0 or 1, then the correct state set will be obtained }{if sister and ancestor have [a] and [a] or [a] and [01] or [01] and [a]; the probability of this }{any one of these occurring is the sum of probabilities of ways the sister could have the state set given}{ancestor has true state c times the probability the ancestor has the right state set given its true state set}{}{first, put in puptemp the sum of probabilities *** (note, in each the last terms represent Panc upstates given true state}{is c, but since stored as ands not givens, need to divide by prob of true state to yield conditional}{ case 1: [a] at sister and [a] at anc}									puptemp := (DownGivenAnc(Sis(N), a, c) * probptr(N^.anc^.bset1)^.upand[a, c]); {/ anc^.P^.true[c]}{ case 2: [01] at sister and [a] at anc}									puptemp := puptemp + (DownGivenAnc(Sis(N), 2, c) * probptr(N^.anc^.bset1)^.upand[a, c]); {/ anc^.P^.true[c]}{ case 3: [a] at sister and [01] at anc}									puptemp := puptemp + (DownGivenAnc(Sis(N), a, c) * probptr(N^.anc^.bset1)^.upand[2, c]); {/ anc^.P^.true[c]}{now, add probabilities for this case of c to N's up probabilites; need to multiply probability *** by prob of change from c to b; note other probs cancel out!}									probptr(N^.bset1)^.upand[a, b] := probptr(N^.bset1)^.upand[a, b] + puptemp * ProbChangeBranch(N, c, b); {* anc^.P^.true[c]}{}								end;						end;{now, for case in which N's state reconstructed [01]; i.e. a=2}				for b := 0 to 1 do  {0 or 1 true states at N}					begin						probptr(N^.bset1)^.upand[2, b] := 0; {initialize to 0}						for c := 0 to 1 do {true state given at ancestor of N}							begin{ case 1: [0] at sister and [1] at anc}								puptemp := (DownGivenAnc(Sis(N), 0, c) * probptr(N^.anc^.bset1)^.upand[1, c]); {/ anc^.P^.true[c]}{ case 2: [1] at sister and [0] at anc}								puptemp := puptemp + (DownGivenAnc(Sis(N), 1, c) * probptr(N^.anc^.bset1)^.upand[0, c]); {/ anc^.P^.true[c]}{ case 3: [01] at sister and [01] at anc}								puptemp := puptemp + (DownGivenAnc(Sis(N), 2, c) * probptr(N^.anc^.bset1)^.upand[2, c]); {/ anc^.P^.true[c]}								probptr(N^.bset1)^.upand[2, b] := probptr(N^.bset1)^.upand[2, b] + puptemp * ProbChangeBranch(N, c, b); {* anc^.P^.true[c] }							end;					end;			end;		if not NodeIsTerminal(N) then			begin				UpCalcProbs(N^.lf);				UpCalcProbs(N^.rt);			end;		AutoThermocursor(nnum, 0, numtaxain * 6 - 2);	end;{-----------------------------------------------------------------------------}	procedure FinalCalcProbs (N: Nptr);		var			a, b: integer;		function P3 (x, y, z, q: integer): double;			var				t, ts: double;				c: integer;		begin			t := DownGivenAnc(N^.lf, x, q) * DownGivenAnc(N^.rt, y, q) * (probptr(N^.bset1)^.upand[z, q] / probptr(N^.bset1)^.true[q]);			P3 := t;		end;	begin		if not NodeIsTerminal(N) then			begin				FinalCalcProbs(N^.lf);				FinalCalcProbs(N^.rt);				if N = R then					begin						probptr(N^.bset1)^.finalgiven := probptr(N^.bset1)^.downgiven;					end				else					begin{now we need to calculate probability final, which is probability of reconstructing a at N given b is at N}{This can be found by adding up probabilities of all possible cases contributing to a being reconstructed at N.}{N's state reconstructed [0] or [1]}						for a := 0 to 1 do  {[0] or [1] at N}							for b := 0 to 1 do  {0 or 1 true states at N}								begin{if a is [0] or [1], this can arise is descendants and ancestor are a,a,a or a,a,01 or a,a,~a or a,01,01}{funciton P3(x,y,z,b) is probability of left and right and ancestor having state sets given b is true state}									probptr(N^.bset1)^.finalgiven[a, b] := P3(a, a, a, b) + P3(a, a, 2, b) + P3(a, 2, a, b) + P3(2, a, a, b);									probptr(N^.bset1)^.finalgiven[a, b] := probptr(N^.bset1)^.finalgiven[a, b] + P3(a, 2, 2, b) + P3(2, a, 2, b) + P3(2, 2, a, b);									probptr(N^.bset1)^.finalgiven[a, b] := probptr(N^.bset1)^.finalgiven[a, b] + P3(a, a, abs(a - 1), b) + P3(a, abs(a - 1), a, b) + P3(abs(a - 1), a, a, b);								end;{N's state reconstructed [01]; i.e. a=2}						for b := 0 to 1 do  {0 or 1 true states at N}							begin{if a is [01], this can arise is descendants and ancestor are 01,01,01 or a,~a,01}{funciton P3(x,y,z,b) is probability of left and right and ancestor having state sets given b is true state}								probptr(N^.bset1)^.finalgiven[2, b] := P3(2, 2, 2, b) + P3(0, 1, 2, b) + P3(0, 2, 1, b) + P3(1, 0, 2, b);								probptr(N^.bset1)^.finalgiven[2, b] := probptr(N^.bset1)^.finalgiven[2, b] + P3(1, 2, 0, b) + P3(2, 0, 1, b) + P3(2, 1, 0, b);							end;					end;			end;		AutoThermocursor(nnum, 0, numtaxain * 6 - 2);	end;{-----------------------------------------------------------------------------}{calculates probability of reconstructing an unambiguous 0 to 1 (gain) or 1 to 0 (loss) change}{on a branch given various true states at N and its ancestor}	procedure CalcProbParticularChange (N: Nptr);		var			rchange: change;			tA, tN, rA, rN: integer;	begin		if not NodeIsTerminal(N) then			begin				if (N = R) | (N^.anc = R) then					begin						for rchange := gain to loss do							for tA := 0 to 1 do								for tN := 0 to 1 do									probptr(N^.bset1)^.changegiven[rchange, tA, tN] := 0;					end				else					begin						for rchange := gain to loss do							begin								if rchange = gain then									begin										rA := 0;										rN := 1;									end								else									begin										rA := 1;										rN := 0;									end;								for tA := 0 to 1 do									for tN := 0 to 1 do										if probptr(N^.anc^.bset1)^.true[tA] <> 0.0 then											begin												probptr(N^.bset1)^.changegiven[rchange, tA, tN] := DownGivenAnc(N^.lf, rN, tN) * DownGivenAnc(N^.rt, rN, tN) * DownGivenAnc(Sis(N), rA, tA);												probptr(N^.bset1)^.changegiven[rchange, tA, tN] := probptr(N^.bset1)^.changegiven[rchange, tA, tN] * (probptr(N^.anc^.bset1)^.upand[rA, tA]) / probptr(N^.anc^.bset1)^.true[tA];											end;							end;					end;				CalcProbParticularChange(N^.lf);				CalcProbParticularChange(N^.rt);			end		else {terminal}			if (N^.anc = R) then				begin					for rchange := gain to loss do						for tA := 0 to 1 do							for tN := 0 to 1 do								probptr(N^.bset1)^.changegiven[rchange, tA, tN] := 0;				end			else				begin { calculate as probability that N's ancestor will be reconstructed as of different state}					for tA := 0 to 1 do						if probptr(N^.anc^.bset1)^.true[tA] <> 0.0 then							begin								probptr(N^.bset1)^.changegiven[loss, tA, 1] := 0;{given tA is tA and tN=1, probability 0 will get reconstructed at A (yielding a reconstr gain)}{is probability of the one way can get reconstructed 0, namely N's sister and Ancestor have to both be 0 }								probptr(N^.bset1)^.changegiven[gain, tA, 1] := DownGivenAnc(Sis(N), 0, tA) * (probptr(N^.anc^.bset1)^.upand[0, tA]) / probptr(N^.anc^.bset1)^.true[tA];								probptr(N^.bset1)^.changegiven[gain, tA, 0] := 0;								probptr(N^.bset1)^.changegiven[loss, tA, 0] := DownGivenAnc(Sis(N), 1, tA) * (probptr(N^.anc^.bset1)^.upand[1, tA]) / probptr(N^.anc^.bset1)^.true[tA];							end;				end;	end;{-----------------------------------------------------------------------------}{calculates probability of reconstructing an unambiguous or allowed change}{on a branch}	procedure CalcProbMinMaxChange (N: Nptr);		var			rchange: change;			tA, tN, rA, rN: integer;	begin		if not NodeIsTerminal(N) then			begin				if (N = R) then					begin						probptr(N^.bset1)^.minPRchange := 0;  {no changes on root}						probptr(N^.bset1)^.maxPRchange := 0;					end				else if (N^.anc = R) then					begin						probptr(N^.bset1)^.minPRchange := 0;  {no unambiguous changes on branch descended from root}{prob allowed change is prob N and its sister's downpass sets don't overlab}						probptr(N^.bset1)^.maxPRchange := DownGivenAnc(Sis(N), 0, TrueRootState) * DowngivenAnc(N, 1, TrueRootState);						probptr(N^.bset1)^.maxPRchange := probptr(N^.bset1)^.maxPRchange + DownGivenAnc(Sis(N), 1, TrueRootState) * DowngivenAnc(N, 0, TrueRootState);					end				else					begin{on branch, probability of unambiguous change is sum of probabilities of cases with unambiguous change - those from}{0 to 1 and 1 to 0, and with all possible true states at N and A}						probptr(N^.bset1)^.minPRchange := 0;						for tA := 0 to 1 do							for tN := 0 to 1 do								for rchange := gain to loss do									probptr(N^.bset1)^.minPRchange := probptr(N^.bset1)^.minPRchange + probptr(N^.bset1)^.changegiven[rchange, ta, tN] * probptr(N^.anc^.bset1)^.true[ta] * ProbChangeBranch(N, ta, tn);{on branch, probability of allowed change is probability downpass and uppass sets of N will not overlap}{first, with true at N being 0}						probptr(N^.bset1)^.maxPRchange := ((probptr(N^.bset1)^.downgiven[0, 0]) * (probptr(N^.bset1)^.upand[1, 0] / probptr(N^.bset1)^.true[0]) + (probptr(N^.bset1)^.downgiven[1, 0]) * (probptr(N^.bset1)^.upand[0, 0] / probptr(N^.bset1)^.true[0])) * probptr(N^.bset1)^.true[0];{now, with true at N being 1}						probptr(N^.bset1)^.maxPRchange := probptr(N^.bset1)^.maxPRchange + ((probptr(N^.bset1)^.downgiven[0, 1]) * (probptr(N^.bset1)^.upand[1, 1] / probptr(N^.bset1)^.true[1]) + (probptr(N^.bset1)^.downgiven[1, 1]) * (probptr(N^.bset1)^.upand[0, 1] / probptr(N^.bset1)^.true[1])) * probptr(N^.bset1)^.true[1];					end;				CalcProbMinMaxChange(N^.lf);				CalcProbMinMaxChange(N^.rt);			end		else {terminal}			begin				probptr(N^.bset1)^.minPRchange := 0;				if N^.anc <> R then					for tA := 0 to 1 do						for tN := 0 to 1 do							for rchange := gain to loss do								probptr(N^.bset1)^.minPRchange := probptr(N^.bset1)^.minPRchange + probptr(N^.bset1)^.changegiven[rchange, ta, tN] * probptr(N^.anc^.bset1)^.true[ta] * ProbChangeBranch(N, ta, tn);{on branch, probability of allowed change is probability observed and uppass sets of N will not overlap}				probptr(N^.bset1)^.maxPRchange := (probptr(N^.bset1)^.true[0]) * (probptr(N^.bset1)^.upand[1, 0] + probptr(N^.bset1)^.upand[1, 1]) + (probptr(N^.bset1)^.true[1]) * (probptr(N^.bset1)^.upand[0, 0] + probptr(N^.bset1)^.upand[0, 1]);{true is 0 and up is 1 given true is 0 or true is 1 and up is 0 given true is 1}				probptr(N^.bset1)^.maxPRchange := (probptr(N^.bset1)^.upand[1, 0]) + (probptr(N^.bset1)^.upand[0, 1]);			end;	end;{-----------------------------------------------------------------------------}	procedure CleanMemory1 (N: Nptr);	begin		DisposePtr(N^.bset1);		if not NodeIsTerminal(N) then			begin				CleanMemory1(N^.lf);				CleanMemory1(N^.rt);			end;	end;	procedure CalcProbsNodes (baseN: Nptr);		var			total, subtotal: double;			pp: integer;{........}		procedure WriteProbs (N: Nptr; left: boolean);		begin			begin				if not NodeIsTerminal(N) then					begin{reconstructed state exactly correct}						if stateexact = probRecitem then							N^.finalC := probptr(N^.bset1)^.finalgiven[0, 0] * probptr(N^.bset1)^.true[0] + probptr(N^.bset1)^.finalgiven[1, 1] * probptr(N^.bset1)^.true[1];{reconstructed state not wrong}						if statenotwrong = probRecitem then							N^.finalC := (probptr(N^.bset1)^.finalgiven[0, 0] + probptr(N^.bset1)^.finalgiven[2, 0]) * probptr(N^.bset1)^.true[0] + (probptr(N^.bset1)^.finalgiven[1, 1] + probptr(N^.bset1)^.finalgiven[2, 1]) * probptr(N^.bset1)^.true[1];{reconstructed state equivocal}{Write(outfile, chr(9), (probptr(N^.bset1)^.finalgiven[2, 0]) * probptr(N^.bset1)^.true[0] + (probptr(N^.bset1)^.finalgiven[2, 1]) * probptr(N^.bset1)^.true[1] : 7 : 5);}					end;				if N <> R then					begin{change reconstructed correctly given change}						if changecorrect = probRecitem then							N^.finalC := (probptr(N^.bset1)^.changegiven[gain, 0, 1] * ProbChangeBranch(N, 0, 1) * probptr(N^.anc^.bset1)^.true[0] + probptr(N^.bset1)^.changegiven[loss, 1, 0] * ProbChangeBranch(N, 1, 0) * probptr(N^.anc^.bset1)^.true[1]) / (ProbChangeBranch(N, 0, 1) * probptr(N^.anc^.bset1)^.true[0] + ProbChangeBranch(N, 1, 0) * probptr(N^.anc^.bset1)^.true[1]);{unambiguous change}						if numchangeUnamb = probRecitem then							N^.finalC := probptr(N^.bset1)^.minPRchange;{allowed change}						if numchangeAllowed = probRecitem then							N^.finalC := probptr(N^.bset1)^.maxPRchange;					end;			end;			if not NodeIsTerminal(N) then				begin					WriteProbs(N^.lf, true);					WriteProbs(N^.rt, false);				end;		end;{........}{........}	begin		if seglistenProb then			CalculateSegmentProbs;		DownCalcProbs(baseN);		UpcalcProbs(baseN);		FinalCalcProbs(baseN);		if probRecitem in [changecorrect, numchangeunamb, numchangeAllowed] then			CalcProbParticularChange(baseN);		if probRecitem in [numchangeunamb, numchangeAllowed] then			CalcProbMinMaxChange(baseN);		WriteProbs(baseN, true);		CleanMemory1(baseN);	end;{====================================================================}	procedure SaveProbsSteps;		var			maxs, ss, aa, pp: integer;			outfile: text;	begin		SetCursor(clockCursor);		maxs := numtaxain div 2;		open(outfile, 'Prob.Results');		Writeln(outfile, MacCladeStamp);		Writeln(outfile, UserStamp(true, true, false));		Writeln(outfile, TimeStamp);		Writeln(outfile, DataFileStamp);		Writeln(outfile, CurrentTreeStamp);		writeln(outfile);		writeln(outfile);		Writeln(outfile, 'Probabilities for various number of steps given any reconstruction at base');		writeln(outfile);		Writeln(outfile);		writeln(outfile, 'Model of evolution:  ');		writeln(outfile, 'Probability of change per');		if seglistenprob then			writeln(outfile, 'segment: ')		else			writeln(outfile, 'branch: ');		writeln(outfile, '0->0', probchangeRec[0, 0] : 7 : 4);		writeln(outfile, '0->1', probchangeRec[0, 1] : 7 : 4);		writeln(outfile, '1->0', probchangeRec[1, 0] : 7 : 4);		writeln(outfile, '1->1', probchangeRec[1, 1] : 7 : 4);		Writeln(outfile);		Writeln(outfile);		Writeln(outfile, 'Results');		Writeln(outfile);		Writeln(outfile, 'Steps', chr(9), 'Probability');		for ss := 0 to maxs do			begin				writeln(outfile, ss : 4, chr(9), probstepsvalues[ss] : 9 : 6);			end;		Writeln(outfile);		Write(outfile, 'Mean for above:  ', mean : 9 : 6);		close(outfile);		SetCursorToArrow;	end;{====================================================================}	procedure CalcProbsSteps (var donecalc: boolean);		var			maxs, ss, aa, pp: integer;			subtotal: double;			nnum: integer;			ds: str255;{  stepsarray = array[0..100, 0..2, 0..1] of real; }{}		procedure InCalcProbsSteps (N: Nptr);			var				s, a, b, rs: integer;				P, lfP, rtP: stepsptr;		begin			N^.bset2 := NewPtr(SizeOf(stepsarray));			P := stepsptr(N^.bset2);			if NodeIsTerminal(N) then				begin {initialize for terminals}					for s := 0 to maxs do						for a := 0 to 2 do							for b := 0 to 1 do								P^[s, a, b] := 0;					P^[0, 0, 0] := 1;					P^[0, 1, 1] := 1;				end			else				begin					InCalcProbsSteps(N^.lf);					InCalcProbsSteps(N^.rt);					lfP := stepsptr(N^.lf^.bset2);					rtP := stepsptr(N^.rt^.bset2);					for s := 0 to maxs do						begin{N's state reconstructed [0] or [1]}							for a := 0 to 1 do  {[0] or [1] at N}								for b := 0 to 1 do  {0 or 1 true states at N}									begin										P^[s, a, b] := 0; {initialize to 0}										for rs := 0 to s do  {distributions of s steps on left and right}											begin							{ case 1: [a] at both left and right}												P^[s, a, b] := P^[s, a, b] + ((lfP^[rs, a, 0] * ProbChangeBranch(N^.lf, b, 0) + lfP^[rs, a, 1] * ProbChangeBranch(N^.lf, b, 1)) * (rtP^[s - rs, a, 0] * ProbChangeBranch(N^.rt, b, 0) + rtP^[s - rs, a, 1] * ProbChangeBranch(N^.rt, b, 1)));							{ case 2: [01] at left and [a] at right}												P^[s, a, b] := P^[s, a, b] + ((lfP^[rs, 2, 0] * ProbChangeBranch(N^.lf, b, 0) + lfP^[rs, 2, 1] * ProbChangeBranch(N^.lf, b, 1)) * (rtP^[s - rs, a, 0] * ProbChangeBranch(N^.rt, b, 0) + rtP^[s - rs, a, 1] * ProbChangeBranch(N^.rt, b, 1)));							{ case 3: [a] at left and [01] at right}												P^[s, a, b] := P^[s, a, b] + ((lfP^[rs, a, 0] * ProbChangeBranch(N^.lf, b, 0) + lfP^[rs, a, 1] * ProbChangeBranch(N^.lf, b, 1)) * (rtP^[s - rs, 2, 0] * ProbChangeBranch(N^.rt, b, 0) + rtP^[s - rs, 2, 1] * ProbChangeBranch(N^.rt, b, 1)));											end;									end;{N's state reconstructed [01]; i.e. a=2}							for b := 0 to 1 do								begin									P^[s, 2, b] := 0;									for rs := 0 to s do  { case 1: [01] at both left and right}										P^[s, 2, b] := P^[s, 2, b] + ((lfP^[rs, 2, 0] * ProbChangeBranch(N^.lf, b, 0) + lfP^[rs, 2, 1] * ProbChangeBranch(N^.lf, b, 1)) * (rtP^[s - rs, 2, 0] * ProbChangeBranch(N^.rt, b, 0) + rtP^[s - rs, 2, 1] * ProbChangeBranch(N^.rt, b, 1)));									for rs := 0 to s - 1 do										begin											P^[s, 2, b] := P^[s, 2, b] + ((lfP^[rs, 0, 0] * ProbChangeBranch(N^.lf, b, 0) + lfP^[rs, 0, 1] * ProbChangeBranch(N^.lf, b, 1)) * (rtP^[s - rs - 1, 1, 0] * ProbChangeBranch(N^.rt, b, 0) + rtP^[s - rs - 1, 1, 1] * ProbChangeBranch(N^.rt, b, 1)));											P^[s, 2, b] := P^[s, 2, b] + ((lfP^[rs, 1, 0] * ProbChangeBranch(N^.lf, b, 0) + lfP^[rs, 1, 1] * ProbChangeBranch(N^.lf, b, 1)) * (rtP^[s - rs - 1, 0, 0] * ProbChangeBranch(N^.rt, b, 0) + rtP^[s - rs - 1, 0, 1] * ProbChangeBranch(N^.rt, b, 1)));										end;								end;						end;				end;			AutoThermocursor(nnum, 0, numtaxain * 2 - 1);		end;		procedure CleanMemory2 (N: Nptr);		begin			DisposePtr(N^.bset2);			if not NodeIsTerminal(N) then				begin					CleanMemory2(N^.lf);					CleanMemory2(N^.rt);				end;		end;		procedure DrawProbStepsChart;			const				lll = 15;				rrr = 357;				ttt = 165;				bbb = 275;			var				ss, aa: integer;				min1, max1, min2, max2: single;				box: rect; {left, top, right, bottom = 11, 152, 370, 281}			function LocateC1 (c1: single): integer;			begin				if max1 = min1 then					LocateC1 := lll				else					LocateC1 := RoundValue(lll + (rrr - lll) * ((c1 - min1) / (max1 - min1)));			end;			function LocateC2 (c2: single): integer;			begin				if max2 = min2 then					LocateC2 := bbb				else					LocateC2 := RoundValue(bbb - (bbb - ttt) * ((c2 - min2) / (max2 - min2)));			end;		begin			setrect(box, lll - 20, ttt - 2, rrr + 13, bbb + 20);			EraseRect(box);			min1 := 0;			max1 := -100000;			min2 := 0;			max2 := -100000;			for ss := 0 to maxs do				if probstepsvalues[ss] > 0 then					begin						max1 := ss;						if probstepsvalues[ss] > max2 then							max2 := probstepsvalues[ss];					end;			if max2 < 0 then				max2 := 0;			if max1 < 0 then				max1 := 0;			moveTo(LocateC1(0), LocateC2(0));  {Drawing axes}			LineTo(LocateC1(0), LocateC2(max2));			moveTo(LocateC1(0), LocateC2(0));			LineTo(LocateC1(max1), LocateC2(0));			for ss := 0 to 10 do				if max2 > 0.1 * ss then					begin						moveTo(lll - 15, LocateC2(0.1 * ss));						RealToString(0.1 * ss, ds, 10, 1, false);						Textfont(1);						textsize(9);						DrawString(ds);						Textfont(0);						textsize(12);						moveTo(lll - 2, LocateC2(0.1 * ss));						lineTo(lll + 2, LocateC2(0.1 * ss));					end;			for ss := 0 to maxs do				begin					moveTo(LocateC1(ss), bbb + 10);					Textfont(1);					textsize(9);					DrawString(StringFromNum(ss));					Textfont(0);					textsize(12);					moveTo(LocateC1(ss), bbb - 1);					lineTo(LocateC1(ss), bbb + 2);				end;			for ss := 0 to maxs do				begin					PenSize(4, 1);					MoveTo(LocateC1(ss), LocateC2(0));					LineTo(LocateC1(ss), LocateC2(probstepsvalues[ss]));					PenNormal;				end;			MoveTo(LocateC1(mean), bbb);			Pensize(1, 1);			LineTo(LocateC1(mean), bbb + 2);			Pensize(2, 1);			LineTo(LocateC1(mean), bbb + 4);			Pensize(3, 1);			LineTo(LocateC1(mean), bbb + 6);			Pensize(4, 1);			LineTo(LocateC1(mean), bbb + 8);		end;{............................................................................}	begin		maxs := Numtaxain div 2;		if nullson or ancon then			begin				InstantInfo('Can''t calculate probability distribution for steps if tree has polytomies or some observed taxa are fixed as ancestors');			end		else if maxs > maxtaxasteps then			begin				numtostring(maxtaxasteps * 2, ds);				InstantInfo(concat('Can''t calculate probability distribution for steps since more than ', ds, ' taxa in tree'))			end		else			begin				donecalc := true;				SetCursor(clockCursor);				if seglistenProb then					New(probchgsegs);				if seglistenProb then					CalculateSegmentProbs;				nnum := 0;				InCalcProbsSteps(R);				mean := 0;				for ss := 0 to maxs do					begin						subtotal := 0;						for aa := 0 to 2 do							subtotal := subtotal + stepsptr(R^.bset2)^[ss, aa, 0];						probstepsvalues[ss] := subtotal;						mean := mean + ss * subtotal;					end;				CleanMemory2(R);				DrawProbStepsChart;				SetCursorToArrow;				if seglistenProb then					Dispose(probchgsegs);			end;	end;{=============================================================}	procedure CalcProbReconstruct;	begin		SetCursor(clockCursor);		if seglistenProb then			New(probchgsegs);		nnum := 0;		CalcProbsNodes(R);		if seglistenProb then			Dispose(probchgsegs);	end;{=============================================================}	procedure TurnOnProbReconstruct;	begin		SetCursor(clockCursor);		if (traceshown = traceDiscrete) then			TurnoffTrace(i, true, false, true);		if (traceshown = traceAllChanges) then			TurnOffShowChg(true);		if (traceshown = traceAllStates) then			TurnOffAllStates		else if (traceshown = traceContinuous) then			TurnOffContinuous(true);		traceshown := traceProbability;		curTrace := tracenothing;		ShowCHLegIfHidden;{FROZEN 3.0}		gomask := gomask + [goProbability];		golist := golist + [goProbability];		DefineTWClip;		FixTreeShadingMenus;		CheckPixelDepth(treewindow);	end;{-----------------------------------------------------------------------------}{10, 11, 12, 13 : probs of change 00, 01, 10, 11}{14 segments}{15 state exact}{16 state not wrong}{17 change correct}{18 num change unamb}{19 num change allowed}{20 num steps}{21all states}{    seglisten = 0;}{    stateexact = 1;}{    statenotwrong = 2;}{    changecorrect = 3;}{    numchangeUnamb = 4;}{    numchangeAllowed = 5;}{    numsteps = 6;}{    allstates = 7;}{====================================================================}	procedure DoProbReconstruct (istrace: boolean);		label			1;		var			theDialog: DialogPtr;			tempP: WindowPtr;			tempH: Handle;			ds, rs: str255;			ic: integer;			localItemHit: integer;			oldprobitem: integer;			oldseglisten: boolean;			oldprobchange: array[0..3, 0..3] of double;			maxitems: integer;			hasdonecalc: boolean;{.......}		procedure AdjustChecks (IH: integer);			var				iii: integer;		begin			for iii := 15 to maxitems do				ItemCheckMark(theDialog, iii, false);			if istrace then				probRecitem := ih - 14			else				probTreeitem := ih - 14;			ItemCheckMark(theDialog, IH, true);		end;{.......}		procedure WriteProbability (iffrom, itto, iitem: integer);		begin			RealToString(probchangeRec[iffrom, itto], ds, 10, 4, false);			SetDLOGText(theDialog, iitem, ds, false);		end;{.......}		function GetProbability (iitem: integer): double;     {getting the probability values from the edit text items}			var				intvalue: longint;				realvalue: double;				isreal: boolean;		begin			EditTextNum(theDialog, iitem, realvalue, intvalue, isreal);			if not isreal then				if intvalue = 1 then					realvalue := 1.0				else					begin						if intvalue <> 0 then							begin								InstantError(189);								SelectDialogItemText(theDialog, iitem, 0, 32767);							end;						realvalue := 0.0					end			else if (realvalue < 0.0) or (realvalue > 1.0) then 			 {it's a real value}				begin					realvalue := 0.0;					InstantError(189);					SelectDialogItemText(theDialog, iitem, 0, 32767);				end;			GetProbability := realvalue;		end;{.......}	begin		hasdonecalc := false;		if istrace then			begin				StartDLOG(147, theDialog, tempP);				maxitems := 19;				for ic := 15 to maxitems do					ItemCheckMark(theDialog, ic, (ic - 14) = probrecitem);			end		else			begin				StartDLOG(148, theDialog, tempP);				maxitems := 14;{for ic := 15 to maxitems do ItemCheckMark(theDialog, ic, (ic - 14) = probTreeitem);}				EnableDisableDLOGItem(theDialog, 22, false, false);			end;		oldprobitem := probrecitem;		oldseglisten := seglistenProb;		oldprobchange[0, 0] := probchangeRec[0, 0];		oldprobchange[0, 1] := probchangeRec[0, 1];		oldprobchange[1, 0] := probchangeRec[1, 0];		oldprobchange[1, 1] := probchangeRec[1, 1];		WriteProbability(0, 0, 10);		WriteProbability(0, 1, 11);		WriteProbability(1, 0, 12);		WriteProbability(1, 1, 13);		ItemCheckMark(theDialog, 14, seglistenProb);		myShowDialog(theDialog);1:		repeat			ModalDialog(nil, localItemHit);			case localItemHit of				1: 					begin{istrace: 1, trace; 2, cancel; 21: don't trace}{issteps: 1, calculate; 2, cancel/done; 22: save}						if (abs(probchangeRec[0, 0] + probchangeRec[0, 1] - 1.0) > 0.001) or (abs(probchangeRec[1, 0] + probchangeRec[1, 1] - 1.0) > 0.001) then							begin								InstantInfo('Probabilities don'' t add up to 1 ');								probchangeRec[0, 0] := oldprobchange[0, 0];								probchangeRec[0, 1] := oldprobchange[0, 1];								probchangeRec[1, 0] := oldprobchange[1, 0];								probchangeRec[1, 1] := oldprobchange[1, 1];								if (traceshown = traceProbability) then									TurnOffProbReconstruct;								SetCursorToArrow;							end						else if not istrace then							begin								CalcProbsSteps(hasdonecalc);								if hasdonecalc then									begin										SetButtonTitle(theDialog, 2, 'Done');										EnableDisableDLOGItem(theDialog, 22, true, false);									end;							end						else if (traceshown = traceProbability) then							begin								golist := golist + [goProbability];								godraw := true;							end						else							TurnOnProbReconstruct;					end;				2: 					if istrace or not hasdonecalc then						begin							probrecitem := oldprobitem;							probchangeRec[0, 0] := oldprobchange[0, 0];							probchangeRec[0, 1] := oldprobchange[0, 1];							probchangeRec[1, 0] := oldprobchange[1, 0];							probchangeRec[1, 1] := oldprobchange[1, 1];							seglistenProb := oldseglisten;						end;				10: 					probchangeRec[0, 0] := GetProbability(10); {0 to 0}				11: 					probchangeRec[0, 1] := GetProbability(11); {0 to 1}				12: 					probchangeRec[1, 0] := GetProbability(12); {1 to 0}				13: 					probchangeRec[1, 1] := GetProbability(13); {1 to 1}				14: 					begin						seglistenProb := not seglistenProb;						ItemCheckMark(theDialog, 14, seglistenProb);					end;				15, 16, 17, 18, 19: 					AdjustChecks(localItemHit);				21: 					begin						if (traceshown = traceProbability) then							TurnOffProbReconstruct;					end;				22: 					begin						SaveProbsSteps;					end;				otherwise					;			end;		until (localItemHit in [2, 21]) or ((localItemHit = 1) and istrace);		EndDLOG(theDialog, tempP);		if seglistenProb <> oldseglisten or (probchangeRec[0, 0] <> oldprobchange[0, 0]) or (probchangeRec[0, 1] <> oldprobchange[0, 1]) or (probchangeRec[1, 0] <> oldprobchange[1, 0]) or (probchangeRec[1, 1] <> oldprobchange[1, 1]) then			begin				golist := golist + [goProbability];				godraw := true;			end;	end;{$ENDC}end.