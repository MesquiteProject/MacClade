unit ProcessMenu;{еееееееееееееееееееееее}interface	uses		Printing, QuickDraw,  Types, Events, QuickDrawText, Devices, OSUtils, TextUtils, 		menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, 		Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  Traps, 		Balloons, MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, 		AppleTalk, PPCToolBox, Processes, FileMenu, Notification, EPPC, AppleEvents, 		TaxonCHUtil, BranchListWindow, ChartWWrite, StrUtil, TreeUtil, 		ImpForeignFiles, TypeUtil, WriteDataUtil, CharUtil, LaserTree, EditUtilMenu, 		WriteUtil, PICT, ClickInInfoWindow, SpreadUtil, LinkUtil, Export, ChartMenu, 		ChartWindow, StatsMenu, TreeMaker, MCWindows, Fonts, PrintingUtil, PrintingMisc, DoPrint, 		WriteData, GenCloseFile, GenOpenFile, TreeMenu, TraceMenu, EditMenu, 		DisplayMenu, Settings, BoxUtil, About, Equivocal, CharactersMenu, TaxaMenu,		ChartWWrite, StatusNotes, InfoWindows, ChartWText, ChangeAssumptions, SaveOtherMenu;	procedure ScrollHome;	procedure ProcessMenu (CodeWord: longint);{$SETC HELPMENU=FALSE}{$IFC HELPMENU}	var		hHelpMHdl: MenuHandle;		myHelpMenuItem: integer;{$ENDC}{еееееееееееееееееееееее}implementation {е$S ProcessMenu} {-----------------------------------------------------------------------------}	procedure GoToCellQuery;		var			theDialog: DialogPtr;			tempP: windowptr;			taxonGoTo, characterGoTo: integer;			localItemHit: integer;	begin		StartDLOG(148, theDialog, tempP);		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);		until (localItemHit in [1, 2]);		if localItemHit = 1 then			begin				taxonGoTo := EditTextInt(TheDialog, 3,false);				if taxonGoTo <1 then taxonGoTo := -2;				if taxonGoTo > numtaxa then taxonGoTo := numtaxa;				characterGoTo := EditTextInt(TheDialog, 4,false);				if characterGoTo <1 then characterGoTo := -2;				if characterGoTo > numchars then characterGoTo := numchars;			end;		EndDLOG(thedialog, tempP);		if localItemHit = 1 then			begin				if (taxonGoTo > 0)|(characterGoTo > 0) then					if editorTransposed then						ScrolltoRectangle(characterGoTo,characterGoTo,taxonGoTo,taxonGoTo,true,true)					else						ScrollToRectangle(taxonGoTo,taxonGoTo,characterGoTo,characterGoTo,true,true);			end;	end;{-----------------------------------------------------------------------------}	procedure GoToObject(secondaryObject: boolean);	var whichinfo,whichText: integer;		j: integer;		scrollMax: longint;		success: boolean;		ds: str255;	begin		if IsInfoWindow(frontWindow) then			begin				whichInfo:= WhichInfoWindow(frontWindow);				j := GetLongint(concat(InfoObjectName[whichinfo], ': Go to number'), 1, 1, MaximumInfoRows(whichinfo), success);  				if success then					begin						scrollMax := GetControlMaximumLong(infoScroll[whichinfo]);						if j > scrollMax then							j := scrollMax;						SetControlValueLong(infoScroll[whichinfo], j);						ScrollInfoWindow(whichinfo, true);					end;			end		else if IsTreeWindow(frontWindow) then			begin				SetCursorToArrow;				if not secondaryObject then					j := GetLongint('Go to tree number:', 1, 1 - PreDefLinks[treechain], EndUserLink(treeChain), success)				else if (traceshown = traceDiscrete) then					j := GetLongint('Go to character number', 1, 1, numchars, success)				else					success := false;				if success then					if not secondaryObject then						begin							setcursor(clockCursor);							success := GoToTree(j + PreDefLinks[treechain] - 1);						end					else if  (traceshown = traceDiscrete) & CharIncluded(j) then						TurnOnTrace(i, j)					else						Beep;			end		else if IsEditorWindow(frontWindow) then			GoToCellQuery		else if frontwindow = stateswindow then			begin				j := GetLongint(concat('Go to character number:'), 1, 1, numchars, success);  				SetControlValueLong(statesWindowHScroll, j);				ScrollStatesWindow;			end	end;{-----------------------------------------------------------------------------}	procedure ScrollHome;	var whichinfo,whichText: integer;	begin		if IsEditorWindow(frontwindow) then			ScrollEditHome		else if IsTreeWindow(frontwindow) then			begin				genericSetPort(treeWindow);				ScrollTreeHome			end		else if IsInfoWindow(frontwindow) then			begin				whichInfo := WhichInfoWindow(frontwindow);				SetControlValueLong(infoScroll[whichInfo], GetControlMinimumLong(infoScroll[whichInfo]));				SetControlValueLong(infoScroll[whichInfo], GetControlMinimumLong(infoHScroll[whichInfo]));				ScrollInfoWindow(whichInfo, true);				ScrollInfoWindow(whichInfo, false);			end		else if frontwindow = stateswindow then			begin				SetControlValueLong(statesWindowVScroll, GetControlMinimumLong(statesWindowVScroll));				SetControlValueLong(statesWindowHScroll, GetControlMinimumLong(statesWindowHScroll));				ScrollStatesWindow			end		else if IsTextWindow(frontwindow) then			begin				whichText := WhichTextWindow(frontwindow);				SetControlValueLong(textWindowInfo[whichText]^.scroll, GetControlMinimumLong(textWindowInfo[whichText]^.scroll));				ScrollTextWindow(whichText);			end		else if frontwindow = branchlistwindow then			begin				genericSetPort(branchlistwindow);				LScroll(0, -32000, BranchList);			end		else if frontwindow = chartwindow then			begin				if (CWView = tableview) or ((CWView = histoview) and biggraph) then					begin						genericSetPort(chartwindow);						SetControlValueLong(CWScroll, GetControlMinimumLong(CWScroll));						ScrollCW;					end;			end;	end;{-----------------------------------------------------------------------------}	procedure ScrollWindowToSelection;	var whichinfo,whichText: integer;	begin		if IsEditorWindow(frontwindow) then			ScrollToSelection(false,true)		else if IsInfoWindow(frontwindow) then			begin				whichInfo := WhichInfoWindow(frontwindow);				ScrollInfoWindowToSelectedRow(whichinfo);			end;	end;{----------------------------------------------------------------------------} 	procedure DoGoToMenu(ItemNo: integer); 	begin 		case itemNo of 			GoToSelection: 				ScrollWindowToSelection; 			GoToHomeItem: 				ScrollHome; 			GoToObjectItem: 				GoToObject(false); 			GoToTraceCharacterItem: 				GoToObject(true); 			otherwise; 		end; 	end;{----------------------------------------------------------------------------} 	procedure DoExportMenu(ItemNo: integer); 	begin{$IFC DEMO}		InstantInfo('You cannot save files with this demonstration version of MacClade.');{$ELSEC}		if fileopen then			case ItemNo of				NBRFFileItem: 					WriteExportData(NBRF);				NBRFNoGapsFileItem: 					WriteExportData(NBRFnogaps);				FASTAItem: 					WriteExportData(FASTA);				PHYLIPFileItem: 					begin						phylipversion := 33;						WriteExportData(phylip);					end;				PHYLIP34FileItem: 					begin						phylipversion := 34;						WriteExportData(phylip);					end;				PHYLIP36FileItem:					begin						phylipversion := 36;						WriteExportData(phylip);					end;				TEXTFileItem: 					WriteExportData(simpletext);				DescFileItem: 					WriteExportData(descriptions);				HTMLFileItem: 					WriteExportData(htmlMatrix);				HennigFileItem: 					WriteExportData(hennig);				NonaFileItem:					WriteExportData(nona);{$IFC MEGA}				MegaItem: 					WriteExportData(mega);{$ENDC}				MalignItem:					WriteExportData(malign);				otherwise					;			end;{$ENDC}	end;{----------------------------------------------------------------------------}	procedure ProcessMenu; {CodeWord : longint}		var			Menu_No, ItemNo: integer;			ds: Str255;			DeskAcc: integer;			tempP: WindowPtr;	begin		if CodeWord <> 0 then			begin				Menu_No := HighWord(CodeWord);				ItemNo := LowWord(CodeWord);				if editorOpen & editorSelected & SingleCell then					begin						{if (TaxonOfCell(editorSelectionTopLeft) > 0) and (CharOfCell(editorSelectionTopLeft) > 0) then							undoCellStates := gettaxonstsLargest(TaxonOfCell(editorSelectionTopLeft), CharOfCell(editorSelectionTopLeft));}						ReturnValue(editorSelectionTopLeft,false);					end;				case Menu_No of					AppleMenu: 						begin							case ItemNo of								AboutMCItem: 										DoAbout;{HelpItem:  ShowHelp(1);}								otherwise									begin{$IFC NOT CARBON}										GetMenuItemText(AppleMHdl, ItemNo, ds);										genericGetPort(tempP);										DeskAcc := OpenDeskAcc(ds);										genericSetPort(tempP);{$ENDC}									end;							end;						end;					FileMenu: 						DoFileMenu(ItemNo);					EditMenu: {$IFC NOT CARBON}						if not SystemEdit(ItemNo - 1) then{$ENDC}							DoEditMenu(ItemNo);												CopySpecialMenu:						DoCopySpecialMenu(ItemNo);					EdUtilitiesMenu: 						DoEdUtilitiesMenu(ItemNo);					SaveOptionsMenu: 						DoSaveOptionsMenu(ItemNo);					TreeMenu: 						DoTreeMenu(ItemNo);					xxCreateTreesMenu: 						DoCreateTreeMenu(ItemNo);					TraceMenu: 						DoTraceMenu(ItemNo);											ReplaceAllMenu:						DoReplaceAllMenu(Event,ItemNo);											xxCharacterSetsMenu:						DoCharacterSetsMenu(ItemNo);											xxDataFormatMenu:						DoDataFormatMenu(ItemNo);										xxImportTaxaMenu:						DoImportTaxaMenu(ItemNo);					xxTaxonSetsMenu:						DoTaxonSetsMenu(ItemNo);					TaxaMenu :						DoTaxaMenu(ItemNo);											xxTypeSetsMenu:						DoTypeSetMenu(ItemNo);					xxWeightSetsMenu:						DoWeightSetMenu(ItemNo);					xxInclusionSetsMenu:						DoInclusionSetMenu(ItemNo);					CharactersMenu:						DoCharactersMenu(ItemNo);											ConsensusTaxSetMenu:						DoConsensusTaxSetMenu(ItemNo);					{AssumpMenu: 						DoAssumpMenu(ItemNo);}					GDisplayMenu: 						DoDisplayMenu(ItemNo);					TWDisplayMenu: 						DoDisplayMenu(ItemNo);					EWDisplayMenu: 						DoDisplayMenu(ItemNo);					ChartDisplayMenu:						DoChartDisplayMenu (ItemNo);											ChartViewsMenu:						DoChartViewsMenu(ItemNo);				{	ToolMenu: 						if ItemNo > 0 then							SetTool(treeTools,ItemNo - 1);}					EquivMenu: 						DoEquivMenu(ItemNo);					PrintOtherMenu: {$IFC DEMO}						InstantInfo('You cannot print with this demonstration version of MacClade.');{$ELSEC}					begin						DoPrintOtherMenu(ItemNo);					end;{$ENDC}					SaveOtherMenu: {$IFC DEMO}						InstantInfo('You cannot save files with this demonstration version of MacClade.');{$ELSEC}					DoSaveOtherMenu(ItemNo);{$ENDC}					ExpFileMenu: 						DoExportMenu(ItemNo);					ExpTreeMenu: {$IFC DEMO}						InstantInfo('You cannot save files with this demonstration version of MacClade.');{$ELSEC}					DoExpTreeMenu(ItemNo);{$ENDC}					WindowsMenu: 						DoWindowsMenu(ItemNo);											ShowMenu:						DoShowMenu(ItemNo);											ColorCellsMenu:						DoColorCellsMenu (ItemNo);					AATranslateMenu:						DoAATranslateMenu (ItemNo);											NexusBlocksMenu:						DoNexusBlocksMenu(ItemNo);					DataMatrixStyleMenu:						DoDataMatrixStyleMenu(ItemNo);					FontMenu: 						if (IsEditorWindow(frontwindow)) then  		{if editorOpen but not front, menu should be disabled}							DoFontMenu(FontMHdl, ItemNo, editorFont)						else if IsInfoWindow(frontwindow) then							DoFontMenu(FontMHdl, ItemNo, infoFont[WhichInfoWindow(frontwindow)])						else if (frontwindow = stateswindow) then							DoFontMenu(FontMHdl, ItemNo, statesFont)						else if (frontwindow=chartwindow) then							DoFontMenu(FontMHdl, ItemNo,CWFont)						else if IsTreeWindow(frontWindow) then							begin								DoFontMenu(FontMHdl, ItemNo,treetaxafont);								InvalTaxonNames;								SetDrawTWRControls;								godraw := true;							end						else if IsTextWindow(frontWindow) then							begin								DoFontMenu(FontMHdl, ItemNo,textWindowInfo[WhichTextWindow(frontWindow)]^.font);							end;					SizeMenu: 						if (IsEditorWindow(frontwindow)) then  		{if editorOpen but not front, menu should be disabled}							DoSizeMenu(SizeMHdl, ItemNo, editorFontSize)						else if IsInfoWindow(frontwindow) then							DoSizeMenu(SizeMHdl, ItemNo, infoFontSize[WhichInfoWindow(frontwindow)])						else if (frontwindow = stateswindow) then							DoSizeMenu(SizeMHdl, ItemNo, statesFontSize)						else if (frontwindow=chartwindow) then							DoSizeMenu(SizeMHdl, ItemNo,CWfontsize)						else if IsTreeWindow(frontWindow) then							begin								DoSizeMenu(SizeMHdl, ItemNo,treetaxafontsize);								InvalTaxonNames;								SetDrawTWRControls;								godraw := true;							end						else if IsTextWindow(frontWindow) then							begin								DoSizeMenu(SizeMHdl, ItemNo,textWindowInfo[WhichTextWindow(frontWindow)]^.size);							end;					StyleMenu: 						{if (IsEditorWindow(frontwindow)) then  									DoSizeMenu(ItemNo, editorFontSize)						else if IsInfoWindow(frontwindow) then							DoSizeMenu(ItemNo, infoFontSize[WhichInfoWindow(frontwindow)])						else if (frontwindow = stateswindow) then							DoSizeMenu(ItemNo, statesFontSize)						else} if IsTreeWindow(frontWindow) then							begin								DoStyleMenu(StyleMHdl, ItemNo,treetaxastyle);								InvalTaxonNames;								SetDrawTWRControls;								godraw := true;							end						else if (frontwindow=chartwindow) then							begin								DoStyleMenu(StyleMHdl, ItemNo,CWStyle);								UpdateWindowsAfterFontChange;							end;											{DataFormMenu: 						DoDataFormMenu(ItemNo);}					CalcMenu: 						DoCalcMenu(ItemNo);					NewChartMenu: 						if ItemNo <= maxChartItem then							DoChartMenu(ItemNo)						else							DoBottomChartMenu(ItemNo);					IncExcMenu: 						DoIncExcCharactersMenu(ItemNo);											IncExcTaxaMenu:						DoIncExcTaxaMenu(ItemNo);											FindMenu:						DoFindMenu(ItemNo);																	TaxonListOptionsMenu:						DoTaxaListOptionsMenu(ItemNo);											CharListOptionsMenu:						DoCharListOptionsMenu(ItemNo);											GoToMenu:						DoGoToMenu(ItemNo);											ColumnWidthMenu:						DoColumnWidthMenu(ItemNo);					SimpleSelectMenu: 						 if IsEditorWindow(frontWindow) or IsEditableTextWindow(frontWindow) or (statesWindow=frontWindow) then							DoNonInfoSelectMenu(ItemNo);												ShadeCharSetMenu:						DoShadeCharSetMenu(ItemNo);											MismatchMenu:						DoMismatchMenu(ItemNo);											ColorCodPosMenu:						DoColorCodPosMenu(ItemNo);					ColorCharPartitionMenu:						DoColorPartitionsMenu(ItemNo);											InfoSelectMenu: 						if IsInfoWIndow(frontWindow) then							DoInfoWindowSelectMenu(WhichInfoWindow(frontwindow), ItemNo);					WeightMenu: 						DoWeightMenu(ItemNo);											CharPartMenu:						DoCharPartMenu(ItemNo);											CharPartListMenu:						DoCharPartListMenu(ItemNo);					CodingMenu: 						DoCodingMenu(ItemNo);					TypeMenu: 						DoTypeMenu(ItemNo);{$IFC HELPMENU}					kHMHelpMenuID: 						if (ItemNo = myHelpMenuItem) then							begin								ShowHelp(1);							end;{$ENDC}					otherwise						;				end;				comingback := true;				HiliteMenu(0);			end;	end;end.