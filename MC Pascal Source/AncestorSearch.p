unit AncestorSearch;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, 		TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, 		ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, TypeUtil, MenuUtil, 		CharUtil, Prohibitions, SetStates, TreeUtil, LinkUtil, CalcUtil, Calc, Genchar, 		InfoWindows, Legends, Count, Swap;	procedure SearchAncestorOptions;	procedure OptimalAncestorSearch (N: Nptr; swapisabove, tryAll: boolean);{еееееееееееееееееееееее}implementation {е$S AncestorSearch}{-----------------------------------------------------------------------------}	procedure SearchAncestorOptions;		label			1;		var			theDialog: DialogPtr;			tempP: WindowPtr;			ds: str255;			LI: longint;			localItemHit: integer;			showReps: boolean;			oldsearchAncestorStartWithAncestors: boolean;			{...............}	procedure CheckSearchAncestorOptions;	begin		ItemCheckMark(theDialog, 9, showReps);		ItemCheckMark(theDialog, 6, searchAncestorStartWithAncestors);		ItemCheckMark(theDialog, 11, not searchAncestorStartWithAncestors);		EnableDisableDLOGItem (theDialog,4,searchAncestorStartWithAncestors,false);	end;{...............}	procedure GetEditSearchAncestorOptions(itemNumber: integer; var value: integer);	begin		ds := GetEditText(theDialog, itemNumber);		if StringIsLongint(ds) then			begin				StringToNum(ds, LI);				value := LI;			end		else			begin				Beep;				goto 1;			end;	end;{...............}	begin		NewRandomSeed;		StartDLOG(174, theDialog, tempP);		oldsearchAncestorStartWithAncestors := searchAncestorStartWithAncestors;		SetDLOGText(theDialog,3, StringFromNum(searchAncestorReps), true);		SetDLOGText(theDialog,4, StringFromNum(searchAncestorRandomNumber), false);		showReps := searchAncestorReportReps;		CheckSearchAncestorOptions;		myShowDialog(theDialog);		FrameButton(theDialog, 1);1:		repeat			ModalDialog(nil, localItemHit);			case localitemhit of				9:	showReps := not showReps;				10: 	GetRandomSeed;				6:   	searchAncestorStartWithAncestors := true;				11:  	searchAncestorStartWithAncestors := false;				otherwise;			end;			CheckSearchAncestorOptions;		until localItemHit in [1, 2];		if localItemHit = 1 then			begin				GetEditSearchAncestorOptions(3, searchAncestorReps);				GetEditSearchAncestorOptions(4,searchAncestorRandomNumber);				oldRandSeed := OurRandSeed;				searchAncestorReportReps := showReps;			end		else			searchAncestorStartWithAncestors := oldsearchAncestorStartWithAncestors;		EndDLOG(theDialog, tempP);	end;{-----------------------------------------------------------------------------}	procedure ImproveAncestors (theDialog: DialogPtr;N: Nptr;swapIsAbove:boolean; var swapFoundThisPass: boolean; var newTreeLength: longint);	label 1;	var it: integer;		testN: NPtr;		currentLength, bestFoundThisPass: longint;		taxonHdl: THdl;		numTaxaLeft,taxonToFind,numTaxon: integer;		numNodesTested: integer;	begin		currentLength := newTreeLength;		numNodesTested := 0;		bestFoundThisPass:= -1;		numTaxaLeft := numtaxa;		for it := 1 to numTaxa do			begin				taxonHdl:= getTaxonHdl(it);				taxonHdl^^.unused1 := false;			end;		repeat			taxonToFind := RandomBetween(1, numTaxaLeft);			numTaxon:= 1;			for it := 1 to numTaxa do				begin					taxonHdl:= getTaxonHdl(it);					if not taxonHdl^^.unused1 then						if numTaxon=taxonToFind then  {then this is the one to use}							begin 								taxonHdl^^.unused1 := true;								if TaxonInTree(it) then									begin										NPtrOfTaxon(it,testN);										if (testN^.fixanc | fixancLegal(testN, false)) & (swapIsAbove = IsAnc(N,testN)) then											begin												testN^.fixanc := not testN^.fixanc;												testN^.anc^.fixanc := testN^.fixanc;												numNodesTested := numNodesTested + 1;												setAncOn;												SetTaxaDnsts(1, numchars);												if not CountTree then													NewError(308, 0); {First rearrangement - nativelength}												if bestFoundThisPass = -1 then													bestFoundThisPass := treeLength												else if treeLength < bestFoundThisPass then													bestFoundThisPass := treeLength;												if currentLength > treeLength then  {this tree is better than all previous, reset treelength}													begin														currentLength := treeLength;														newTreeLength := treeLength;														swapFoundThisPass := true;													end												else													begin														testN^.fixanc := not testN^.fixanc;														testN^.anc^.fixanc := testN^.fixanc;														setAncOn;														SetTaxaDnsts(1, numchars);													end;											end;									end;								goto 1;							end						else							numTaxon := numTaxon+1;				end;			1:			numTaxaLeft := numTaxaLeft-1;		until (numTaxaLeft <= 0);			end;{-----------------------------------------------------------------------------}	procedure StoreAncestors;	var it: integer;		taxonHdl: THdl;		N: Nptr;	begin		for it := 1 to numTaxa do			begin				taxonHdl:= getTaxonHdl(it);				taxonHdl^^.unused2 := false;			end;		for it := 1 to numTaxa do			if TaxonInTree(it) then				begin					NPtrOfTaxon(it,N);					taxonHdl:= getTaxonHdl(it);					taxonHdl^^.unused2 := N^.fixanc;				end;	end;{-----------------------------------------------------------------------------}	procedure ReStoreAncestors;	var it: integer;		taxonHdl: THdl;		N: Nptr;	begin		for it := 1 to numTaxa do			if TaxonInTree(it) then				begin					NPtrOfTaxon(it,N);					taxonHdl:= getTaxonHdl(it);					N^.fixanc := false;					N^.anc^.fixanc := false;				end;		for it := 1 to numTaxa do			if TaxonInTree(it) then				begin					NPtrOfTaxon(it,N);					taxonHdl:= getTaxonHdl(it);					N^.fixanc := taxonHdl^^.unused2;					if taxonHdl^^.unused2 then						N^.anc^.fixanc := true;				end;		setAncOn;		SetTaxaDnsts(1, numchars);		if not CountTree then			NewError(308, 0); {First rearrangement - nativelength}	end;{-----------------------------------------------------------------------------}	procedure RandomAncestors;	var it: integer;		taxonHdl: THdl;		N: Nptr;	begin		for it := 1 to numTaxa do			if TaxonInTree(it) then				begin					NPtrOfTaxon(it,N);					N^.fixanc := false;					N^.anc^.fixanc := N^.fixanc;				end;{$IFC TRUE}		if searchAncestorStartWithAncestors then			for it := 1 to numTaxa do				if TaxonInTree(it) then					begin						NPtrOfTaxon(it,N);						if not N^.anc^.fixanc then  {sister is not already fixed}							begin								N^.fixanc := RandomBetween(1,searchAncestorRandomNumber) = 1;								N^.anc^.fixanc := N^.fixanc;							end;					end;{$ENDC}		setAncOn;		SetTaxaDnsts(1, numchars);		if not CountTree then			NewError(308, 0); {First rearrangement - nativelength}	end;{-----------------------------------------------------------------------------}	procedure OptimalAncestorSearch (N: Nptr; swapisabove, tryAll: boolean);		var			newTreeLength, bestOverallTreeLength: longint;			easterEgg: boolean;			lastRepWithImprovement, currentRep: longint;			tempP: WindowPtr;			wascount, wasnullson: boolean;			tpMain: WindowPtr;			ir: INTEGER;			swapFoundThisPass, atLeastOneSwapFound,swapfoundThisRep: BOOLEAN;			nativeLength: longint;			j: integer;			ds: str255;			multiAncSearch: boolean;			totalReps, numTimesFound: longint;			theDialog: DialogPtr;	begin		allowCursorChange := false;		multiAncSearch := true;		if allexcluded then			InstantError(121) {can't swap if no included characters}		else			begin								genericGetPort(tpmain);				genericSetPort(treewindow);				ShrinkTree;				StoreOldTreeForUndo;				noundo := true;				wasnullson := nullson;				if nullson then					begin{v4: if swap above, why not randomize polytomies just above swap node???}						if Cwarning('Polytomies not allowed with searching.  Do you want to resolve them randomly before swapping?', 'Resolve', 'Cancel') then							begin								PrepareToRandomPoly(R);								RandomizeAllPolytomies(R);								nullson := false;								drawR := screenR;								undotype := justswap;								justundid := false;								noundo := false;								SetDirtyTree;							end						else							noundo := true;					end;				if fixon then					begin						if Cwarning('Searching will unfix all states fixed in traced character.  Do you want to proceed?', 'Continue', 'Cancel') then							begin								Offfix(true);							end;					end;				if not nullson and not fixon then					begin						swapdone := false;						swapabort := false; { USER requested abort}						ir := i; {saving character traced just in case}						setcursor(clockCursor);						wascount := count;						if not count then {must turn on count if not already counted}							begin								SetOnOffCount(true);								if not CountTree then									NewError(110, 0);							end;						searchCursorNumber[searchAncestor] := -1;						LoadSearchCursors(searchAncestor);						Cliprect(treerect);   {primarily for nex7on}						SetUpdatesAllowed(treewindow,false);						nativelength := treelength;						bestOverallTreeLength := treeLength;						currentRep := 0;												if tryAll then							begin								totalReps := 2**numtaxain;								StoreAncestors;								StartThermo (theDialog,tempP,0,totalReps,'Searching...','',true);																repeat									UpdateThermo (theDialog,0,currentRep,totalReps,true);									if abortedThermo then swapAbort := true;									currentRep := currentRep + 1;								until (currentRep >= totalReps) | swapAbort;																EndThermo(theDialog,tempP,false);							end						else							begin								{StartSearchThermo (searchThermo, tempP,treelength);}								numTimesFound := 0;								StartThermo (theDialog,tempP,0,searchAncestorReps,'# Reps with Best Score','replicates',false);																lastRepWithImprovement := 0;								if multiAncSearch then									StoreAncestors;								repeat									atLeastOneSwapFound := false;									swapfoundThisRep := false;									newTreeLength := treelength;																	repeat 										swapfoundThisPass := false;										maxswap := 0;										{UpdateSearchThermo (searchThermo,bestOverallTreeLength);}										UpdateThermo (theDialog,0,numTimesFound,searchAncestorReps,false);										if abortedThermo then swapAbort := true;										ImproveAncestors (searchThermo,N,swapIsAbove,swapFoundThisPass, newTreeLength);										if not swapFoundThisPass then 											swapdone := true										else 											begin												atLeastOneSwapFound := true;												swapfoundThisRep := true;											end;									until swapdone or swapAbort; 																		NextSearchCursor(searchAncestor);									currentRep := currentRep + 1;									if not SwapAbort & multiAncSearch then										begin											if swapfoundThisRep then												if (newTreelength<bestOverallTreeLength) then													begin														bestOverallTreeLength := newTreeLength;														numTimesFound := 1;														treelength := bestOverallTreeLength;														DrawTreeLeg; 														StoreAncestors;														lastRepWithImprovement := currentRep;														ResetThermoWindowBars(theDialog);														ZeroStandardThermoBar(theDialog);														DrawStandardThermo(theDialog,1);													end												else if newTreeLength = bestOverallTreeLength then													numTimesFound := numTimesFound + 1;											{if currentRep - lastRepWithImprovement < searchAncestorReps then}											if numTimesFound < searchAncestorReps then												begin													swapDone := false;													RandomAncestors;  {new treelength calculated in here}												end											else																						end;								until swapdone or swapAbort;																if multiAncSearch then									ReStoreAncestors;																								EndThermo(theDialog,tempP,false);								if SearchAncestorReportReps then									InstantInfo(concat('Total number of search replicates conducted: ', StringFromNum(currentRep)));								{EndSearchThermo (searchThermo,tempP,true);}							end;													SetUpdatesAllowed(treewindow,true);						i := ir;						if atLeastOneSwapFound then							begin								undotype := justswap;								justundid := false;								godraw := true;								dontcancelUpdate := false;								noundo := false;								SetDirtyTree;								if not swapisabove then									ShrinkTree								else									drawR := screenR;								ds := concat(LengthString(bestOverallTreeLength-treeLength, true), ' steps decrease');							end						else							begin								{SwapReport('Completed', 'no trees found');}								noundo := not wasnullson;								justundid := false;								FixLostByUndo := false;								godraw := true;								InvalidateWindow(treewindow, false);								if not swapisabove then									ShrinkTree								else									drawR := screenR;							end;						TWMessage := ' ';						WriteTWMessageB;						FlushEvents(mdownmask, 0);						SetCursorToArrow;						count := true;						RearrangeTreeGoList;  {branch swapping may have rearranged tree; call for calculations}						ReleaseSearchCursors(searchAncestor);						FixTreeShadingMenus;						if not wascount and count then							begin								ResetInfoWindow(charinfo);								InvalidateWindow(tlegwindow, false);							end;					end; {not nullson}				genericSetPort(tpmain);			end;{not ancon}		allowCursorChange := true;	end;{-----------------------------------------------------------------------------}end.