unit TreeRandomData;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{ееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, BoxUtil, Thermos, StrUtil, TaxonCHUtil, SymbolsNames, InfoWindows, Legends, CharUtil, SetStates, MenuUtil, TypeUtil, WriteUtil, RowColumn, Count, TreeCycle, Fill, TreeUtil;	procedure InitProbChange;	procedure TreeRandomData;{ееееееееееееееееееееее}implementation {е$S TreeRandomData}{$SETC EVOLVEPAIRS=FALSE}	const		maxrandstate = 3;	type		boundarytype = array[0..maxrandstate] of integer;	var		constantlock: boolean;		ActualAncestors: array[0..maxrandstate] of longint;		lockbox: rect;		probchange: array[0..maxrandstate, 0..maxrandstate] of double; {Wayne: double check this}{v4: have Make Default button here too}{-----------------------------------------------------------------------------}	procedure InitProbChange;		var			j: integer;	begin		for j := 3 to 18 do			begin				if ((j - 3) mod 4 = (j - 3) div 4) then					probchange[(j - 3) mod 4][(j - 3) div 4] := 1.0				else					probchange[(j - 3) mod 4][(j - 3) div 4] := 0.0;			end;		probchange[0][0] := 0.9;		probchange[0][1] := 0.1;		probchange[1][1] := 0.9;		probchange[1][0] := 0.1;	end;{-----------------------------------------------------------------------------}	procedure TreeRandomUser (theDialog: DialogPtr; itemNo: Integer);		var			j: integer;			pictbox, box: rect;			pH: picHandle;			tPort: WindowPtr;	begin		FrameButton(theDialog, 1);		box := GetDLOGItemBox(theDialog,3);		genericGetPort(tPort);		genericSetPort(myGetWindowPtrForDialog(theDialog));{vertical string}		for j := 0 to maxrandstate do			begin				moveTo(box.left-20, box.top + j * 32+14);				DrawString(CharofNum(j));			end;{horizontal string}		for j := 0 to maxrandstate do			begin				moveTo(box.left + j * 65+6, box.top-8);				DrawString(CharofNum(j));			end;{====== lock ======}		PenSize(2, 2);		if constantlock then			begin				DropCursorID(5730, lockbox.left, lockbox.top, srccopy);				pH := GetPicture(21832);				pictbox := pH^^.picframe;				OffSetRect(pictbox, box.left-11, box.top-11);				DrawPicture(pH, pictBox);			end		else			begin				DropCursorID(32002, lockbox.left, lockbox.top, srccopy);			end;		genericSetPort(tPort);	end;{-----------------------------------------------------------------------------}	function NextRandomState: integer;		var			tot, j: integer;			boundaries: boundarytype;			randfill: longint;	begin		tot := 0;		for j := 0 to RandomMax do			tot := tot + RandomStatesH^^[j];		boundaries[0] := RandomStatesH^^[0];		for j := 1 to highstate do			boundaries[j] := boundaries[j - 1] + RandomStatesH^^[j];		randfill := randombetween(1, tot);		for j := 0 to RandomMax do			if randfill <= boundaries[j] then				leave;		{j is the state choosen}		ActualAncestors[j] := ActualAncestors[j] + 1;		NextRandomState := j;	end;{-----------------------------------------------------------------------------}{-----------------------------------------------------------------------------}	type		changearray = array[0..maxrandstate, 0..maxrandstate] of longint;	var		changeboundaries: array[0..maxrandstate, 0..maxrandstate] of integer;		RealChanges, RealChangesChar: changearray;		charDidChange: boolean;{-----------------------------------------------------------------------------}	procedure EvolveBranch (startState, numUnits: integer; var endstate: integer);{procedure that actually invokes the model, evolving characters along a branch}		var			lastState, randfill, j, k: integer;	begin		lastState := startState;		for k := 1 to numUnits do			begin				randfill := randombetween(0, 32000);				for j := 3 downto 0 do					if randfill > changeboundaries[lastState][j] then						begin							if EvolveSaveOnlyChanged & not charDidChange then								charDidChange := (lastState <> j);							RealChangesChar[lastState][j] := RealChangesChar[lastState][j] + 1;							lastState := j;							leave;						end;			end;		endState := lastState;	end;{-----------------------------------------------------------------------------}	procedure EvolveCharacter (ic: integer; N: Nptr);{procedure that recurses up tree invoking model by calling EvolveBranch}	begin		if NodeIsTerminal(N) then			settaxonstsLargest(N^.name, ic, [N^.int1])		else			begin				if randEvolveUseLengths then					begin						if not N^.lf^.null then							EvolveBranch(N^.int1, N^.lf^.setLength, N^.lf^.int1);						if not N^.rt^.null then							EvolveBranch(N^.int1, N^.rt^.setLength, N^.rt^.int1);					end				else					begin						if not N^.lf^.null then							EvolveBranch(N^.int1, 1, N^.lf^.int1);						if not N^.rt^.null then							EvolveBranch(N^.int1, 1, N^.rt^.int1);					end;				EvolveCharacter(ic, N^.lf);				EvolveCharacter(ic, N^.rt);			end;	end;{$IFC EVOLVEPAIRS}{-----------------------------------------------------------------------------}	type		pairArray = array[0..maxRandState, 0..maxRandState, 0..maxRandState, 0..maxRandState] of longint;	var		oldPairEvents, pairEvents: pairArray;		pairReps: longint;		totPairEvents, oldtotPairEvents: longint;		sigPairDigits: integer;		sigPair: single;{-----------------------------------------------------------------------------}	procedure EvolvePair (ic1, ic2: integer; N: Nptr);		var			branchSegs: integer;{procedure that recurses up tree invoking model by calling EvolveBranch}	begin		if NodeIsTerminal(N) then			begin				settaxonstsLargest(N^.name, ic1, [N^.int1]);				settaxonstsLargest(N^.name, ic2, [N^.int2]);			end		else			begin				if not N^.lf^.null then					begin						if randEvolveUseLengths then							branchSegs := N^.lf^.setlength						else							branchSegs := 1;						EvolveBranch(N^.int1, branchSegs, N^.lf^.int1);						EvolveBranch(N^.int2, branchSegs, N^.lf^.int2);						if (N^.int1 <> N^.lf^.int1) or (N^.int2 <> N^.lf^.int2) then							begin								pairEvents[N^.int1, N^.lf^.int1, N^.int2, N^.lf^.int2] := pairEvents[N^.int1, N^.lf^.int1, N^.int2, N^.lf^.int2] + 1;								totPairEvents := totPairEvents + 1;							end;					end;				if not N^.rt^.null then					begin						if randEvolveUseLengths then							branchSegs := N^.rt^.setlength						else							branchSegs := 1;						EvolveBranch(N^.int1, branchSegs, N^.rt^.int1);						EvolveBranch(N^.int2, branchSegs, N^.rt^.int2);						if (N^.int1 <> N^.rt^.int1) or (N^.int2 <> N^.rt^.int2) then							begin								pairEvents[N^.int1, N^.rt^.int1, N^.int2, N^.rt^.int2] := pairEvents[N^.int1, N^.rt^.int1, N^.int2, N^.rt^.int2] + 1;								totPairEvents := totPairEvents + 1;							end;					end;				EvolvePair(ic1, ic2, N^.lf);				EvolvePair(ic1, ic2, N^.rt);			end;	end;{-----------------------------------------------------------------------------}	procedure ZeroPairEvents;		var			i1, i2, i3, i4: integer;	begin		for i1 := 0 to maxRandState do			for i2 := 0 to maxRandState do				for i3 := 0 to maxRandState do					for i4 := 0 to maxRandState do						pairEvents[i1, i2, i3, i4] := 0;		oldPairEvents := pairEvents;		oldtotPairEvents := 0;		pairReps := 0;		totPairEvents := 0;	end;{-----------------------------------------------------------------------------}	function CheckPairEventStability: boolean;		label			1;		var			i1, i2, i3, i4: integer;			stable: boolean;	begin		stable := true;		if oldtotPairEvents = 0 then			stable := false		else			for i1 := 0 to maxRandState do				for i2 := 0 to maxRandState do					for i3 := 0 to maxRandState do						for i4 := 0 to maxRandState do							if abs(pairEvents[i1, i2, i3, i4] / totPairEvents - oldPairEvents[i1, i2, i3, i4] / oldtotPairEvents) > sigPair then								begin									stable := false;									goto 1;								end;1:		oldPairEvents := pairEvents;		oldtotPairEvents := totPairEvents;		CheckPairEventStability := stable;	end;{-----------------------------------------------------------------------------}	procedure WritePairedChanges;		label			3;		var			theInfo: FInfo;			thefile, j, k: integer;			totchanges: longint;			totconstant: longint;			oldexists, db: BOOLEAN;			ds, writename: str255;			Freply: SFReply;			i1, i2, i3, i4: integer;	begin		oldexists := false;		SFPutFile(sfputwhere, 'Save report as', 'Evolve Characters Report', nil, Freply);		ShowCursor;		if Freply.good then			CreateSaveFile(Freply.fName, Freply.vrefnum, writename, theInfo, oldexists, 'ttxt', 'TEXT')		else			Errorflag := true;		if errorflag then			goto 3;{||||||||||||||||||||||||||||||||||||||}		StartWrite;		PutTokenReturn('Paired Changes Random Tree Generation');		PutTokenReturn(Maccladestamp);		PutTokenReturn(UserStamp(true, true, false));		PutTokenReturn(TimeStamp);		Putreturn;		puttokenReturn(DataFileStamp);		if treefile then			begin				puttoken('Tree File name: ');				putTokenReturn(treefilename^^);			end;		puttokenReturn(CurrentTreeStamp);		puttoken('Number of branches on tree, not counting root: ');		putTokenReturn(StringFromNum(2 * numtaxain - 2));		putreturn;		puttoken('Total Number of Pairs Created: ');		putTokenReturn(StringFromNum(pairReps));		puttoken('Total Number of Events: ');		putTokenReturn(StringFromNum(totPairEvents));		putTokenReturn('prob matrix');		for j := 0 to maxrandstate do			begin				for k := 0 to maxrandstate do					begin						RealToString(probchange[j][k], ds, 10, 4, writeexpon);						puttoken(ds);						puttab;					end;				Putreturn;			end;		putreturn;		PutToken('significant digits: ');		putTokenReturn(StringFromNum(sigPairDigits));		putReturn;		for i1 := 0 to maxRandState do			for i2 := 0 to maxRandState do				for i3 := 0 to maxRandState do					for i4 := 0 to maxRandState do						begin							putSingleChar(CharOfNum(i1));							putSingleChar(CharOfNum(i2));							putSingleChar(CharOfNum(i3));							putSingleChar(CharOfNum(i4));							putTab;							RealToString(pairEvents[i1, i2, i3, i4] / totPairEvents, ds, 100, sigPairDigits + 2, writeexpon);							putToken(ds);							putReturn;						end;		EndWrite;{||||||||||||||||||||||||||||||||||||||}		if errorflag then			goto 3;		if oldexists then			EraseOldFile(Freply.fName, writename, Freply.vrefnum, theInfo);3:		errorFlag := false;   {need this as if we leave it true will screw things up later on if charton}	end;{-----------------------------------------------------------------------------}{$ENDC}{-----------------------------------------------------------------------------}	procedure WriteRealChanges (totevolved: longint);		label			3;		var			theInfo: FInfo;			thefile, j, k: integer;			totchanges: longint;			totconstant: longint;			oldexists, db: BOOLEAN;			ds, writename: str255;			Freply: standardFileReply;			oldstate: SignedByte;			numAncestors: longint;	begin		oldexists := false;		PutStandardFile('Save report as', 'Evolve Characters Report', Freply);		ShowCursor;		if Freply.sfgood then			FSpCreateSaveFile(Freply.sfFile, oldexists, 'ttxt', 'TEXT')		else			Errorflag := true;		if errorflag then			goto 3;{||||||||||||||||||||||||||||||||||||||}		totchanges := 0;		totconstant := 0;		for j := 0 to maxrandstate do			for k := 0 to maxrandstate do				if j <> k then					totchanges := totchanges + RealChanges[j][k]				else					totconstant := totconstant + RealChanges[j][j];		StartWrite;		PutTokenReturn('Report from random character generation on tree');		PutTokenReturn(Maccladestamp);		PutTokenReturn(UserStamp(true, true, false));		PutTokenReturn(TimeStamp);		Putreturn;		putTokenReturn(DataFileStamp);		if treefile then			begin				puttoken('Tree File name: ');				putTokenReturn(treefilename^^);			end;		putTokenReturn(CurrentTreeStamp);		puttoken('Number of branches on tree, not counting root: ');		putTokenReturn(StringFromNum(2 * numtaxain - 2));		putreturn;		puttoken('Total Number of Characters Created: ');		putTokenReturn(StringFromNum(totevolved));		if EvolveSaveOnlyChanged then			begin				puttoken('(of which ');				puttoken(StringFromNum(totevolved - EvolveNumChars));				putTokenReturn(' were discarded as they involved no change on any branch).');			end;		if EvolveNumChars > 1 then			begin				puttoken('Saved as characters ');				puttoken(StringFromNum(numchars - EvolveNumChars + 1));				puttoken(' - ');			end		else			puttoken('Saved as character ');		puttoken(StringFromNum(numchars));		putreturn;		putreturn;		if EvolveAncConstant then			begin				puttoken('Ancestral state: ');				putSingleChar(CharOfNum(EvolveAncState));			end		else			begin				puttoken('Requested ancestral state frequencies: ');				putreturn;				for j := 0 to RandomMax do					begin						putSingleChar(charOfNum(j));						puttoken(': ');						if RandomStatesH^^[j] = 100 then							puttoken('1.00')						else							begin								if RandomStatesH^^[j] < 10 then									puttoken('0.0')								else									puttoken('0.');								LockHandle(RandomStatesH, oldstate);								puttoken(StringFromNum(RandomStatesH^^[j]));								ResetHandle(RandomStatesH, oldstate);							end;						putreturn;					end;				putreturn;				putreturn;				puttoken('Actual ancestral state frequencies: ');				putreturn;				numAncestors := 0;				for j := 0 to RandomMax do					numAncestors := numAncestors + ActualAncestors[j];				for j := 0 to RandomMax do					begin						putSingleChar(charOfNum(j));						puttoken(': ');						RealToString(ActualAncestors[j] / numancestors, ds, 10, 4, writeexpon);						puttoken(ds);						putreturn;					end;			end;		putreturn;		putreturn;		putTokenReturn('Requested probability of changes');		for j := 0 to maxrandstate do			begin				for k := 0 to maxrandstate do					begin						RealToString(probchange[j][k], ds, 10, 4, writeexpon);						puttoken(ds);						puttab;					end;				Putreturn;			end;		putreturn;		if EvolveSaveOnlyChanged then			putTokenReturn('Note: only characters with changes saved; thus, change frequencies over saved characters greater than requested');		putTokenReturn('Actual changes');		for j := 0 to maxrandstate do			begin				for k := 0 to maxrandstate do					begin						puttoken(StringFromNum(RealChanges[j][k]));						puttab;					end;				Putreturn;			end;		putreturn;		puttoken('Sum, over all characters, of branches with changes: ');		putTokenReturn(StringFromNum(totchanges));		puttoken('Sum, over all characters, of branches without changes: ');		putTokenReturn(StringFromNum(totconstant));		putreturn;		putTokenReturn('Actual frequencies, rows normed');		for j := 0 to maxrandstate do			begin				totchanges := 0;				for k := 0 to maxrandstate do					totchanges := totchanges + RealChanges[j][k];				for k := 0 to maxrandstate do					begin						if totchanges > 0 then							begin								RealToString(1.0 * RealChanges[j][k] / totchanges, ds, 10, 4, WriteExpon);								puttoken(ds);							end						else							puttoken('0.0');						puttab;					end;				Putreturn;			end;		EndWrite;{||||||||||||||||||||||||||||||||||||||}		if errorflag then			goto 3;		if oldexists then			FSpExchangeFilesDeleteTemp(Freply.sfFile);3:		errorFlag := false;   {need this as if we leave it true will screw things up later on if charton}	end;{-----------------------------------------------------------------------------}	procedure ExpandNodes (N: Nptr);{expands node memory to accommodate the new characters added}	begin		HUnLock(N^.dnstH);		HUnLock(N^.upstH);		HUnLock(N^.stsH);		SetHandleSize(N^.dnstH, tcb * ord4(numchars));		SetHandleSize(N^.upstH, tcb * ord4(numchars));		SetHandleSize(N^.stsH, tcb * ord4(numchars));		if NodeIsInternal(N) then			begin				ExpandNodes(N^.lf);				ExpandNodes(N^.rt);			end;	end;{-----------------------------------------------------------------------------}	procedure CheckTreeRandomData(theDialog: DialogPtr; allSetLengthsEqual,saveReport: boolean);	begin		ItemCheckMark(theDialog, 31, EvolveSaveOnlyChanged);		ItemCheckMark(theDialog, 33, not EvolveAncConstant);		ItemCheckMark(theDialog, 34, EvolveAncConstant);		if not allSetLengthsEqual then			ItemCheckMark(theDialog, 36, randEvolveUseLengths);		if randEvolveUseLengths & not allSetLengthsEqual then			SetDLOGText(theDialog, 27, 'each branch segment:', false)		else			SetDLOGText(theDialog, 27, 'each branch:', false);		ItemCheckMark(theDialog, 37, saveReport);	end;{-----------------------------------------------------------------------------}		procedure SetProbabilities(theDialog:DialogPtr);{setting the probabilities into the edit text items}			var				j: integer;				ds: str255;		begin			for j := 3 to 18 do				begin					if probchange[(j - 3) mod 4][(j - 3) div 4] < 0.0 then						probchange[(j - 3) mod 4][(j - 3) div 4] := 0.0;					RealToString(probchange[(j - 3) mod 4][(j - 3) div 4], ds, 10, 4, false);					SetDLOGText(theDialog, j, ds, false);				end;		end;{-----------------------------------------------------------------------------}		procedure GetProbabilities(theDialog: DialogPtr; var badvalue: boolean);{getting the probability values from the edit text items}			var				j: integer;				intvalue: longint;				realvalue: double;				isreal: boolean;		begin			badvalue := false;			for j := 3 to 18 do				begin					EditTextNum(theDialog, j, realvalue, intvalue, isreal);					if not isreal then						if intvalue = 1 then							realvalue := 1.0						else							begin								if intvalue <> 0 then									begin										badvalue := true;										InstantError(189);										SelectDialogItemText(theDialog, j, 0, 32767);									end;								realvalue := 0.0							end					else if (realvalue < 0.0) or (realvalue > 1.0) then 			 {it's a real value}						begin							realvalue := 0.0;							badvalue := true;							InstantError(189);							SelectDialogItemText(theDialog, j, 0, 32767);						end;					probchange[(j - 3) mod 4][(j - 3) div 4] := realvalue;				end;		end;{-----------------------------------------------------------------------------}	procedure TreeRandomData;	{item numbers:		probabilities:  3-18		number of characters: 19		ancestral state: 20}		label			1, 2, 22;		var			theDialog, TD: DialogPtr;			tempP, tport: WindowPtr;			allSetLengthsEqual: boolean;			j, k, numnonzero, ic, it, icstart: integer;			totevolved: longint;			tempH: Handle;			box, box2: rect;			ds: str255;			tot, resttot, maxresttot: double;			success: boolean;			redo, notnormed: boolean;			badvalue: boolean;			localItemHit: integer;			numEv: longint;			saveReport: boolean;UserItemUProcP: UniversalProcPtr;{..........................................................................................}{$SETC MARKOV = FALSE}{$IFC MARKOV}		procedure Markov;			var				isfrom, isto, k, generations: integer;				newprobchange: array[0..3, 0..3] of double;		begin			SetCursor(clockCursor);			for generations := 1 to 20 do				begin					for isfrom := 0 to 3 do						for isto := 0 to 3 do							begin								newprobchange[isfrom][isto] := 0;								for k := 0 to 3 do									newprobchange[isfrom][isto] := newprobchange[isfrom, isto] + probchange[isfrom, k] * probchange[k, isto];							end;					for isfrom := 0 to 3 do						for isto := 0 to 3 do							probchange[isfrom][isto] := newprobchange[isfrom][isto];					SetProbabilities(theDialog);				end;			SetCursorToArrow;		end; {$ENDC}{..........................................................................................}	begin		if Locked(lockData) then			Exit(TreeRandomData);		constantlock := false;		saveReport := false;		allSetLengthsEqual := allSetLengths1;		StartDLOG(549, theDialog, tempP);		for j := 0 to maxrandstate do			for k := 0 to maxrandstate do				RealChanges[j][k] := 0;		for j := 0 to maxrandstate do			ActualAncestors[j] := 0;		SetProbabilities(theDialog);		SetDLOGText(theDialog, 19, StringFromNum(EvolveNumChars), false);		SetDLOGText(theDialog, 20, CharOfNum(EvolveAncState), false);		if allSetLengthsEqual then			HideButton(theDialog, 36);		lockbox := GetDLOGItemBox(theDialog, 24);UserItemUProcP := MyNewUserItemUPP(@treerandomuser);  tempH := Handle(UserItemUProcP);		SetDialogItem(theDialog, 24, UserItem, tempH, lockbox);		SelectDialogItemText(theDialog, 19, 0, 32767);		{select number of random characters edit text item}		CheckTreeRandomData(theDialog,allSetLengthsEqual,saveReport);		RandomStatesH := RandomAncH;		RandomMax := RandomAncMax;		myShowDialog(theDialog);		NewRandomSeed;2:		repeat			ModalDialog(nil, localItemHit);			case localItemHit of				21: 	{equal norm}					begin						FlashBox(GetDLOGItemBox(theDialog, 21));						GetProbabilities(theDialog,badvalue);						if not badvalue then							begin								if constantlock then									numnonzero := 3								else									numnonzero := 4;								for k := 0 to maxrandstate do									begin										if constantlock then											maxresttot := 1.0 - probchange[k][k]										else											maxresttot := 1.0;										for j := 0 to maxrandstate do											if not constantlock or (k <> j) then												probchange[k][j] := maxresttot / numnonzero;									end;								SetProbabilities(theDialog);							end;					end;				22: 	{+- norm}					begin						FlashBox(GetDLOGItemBox(theDialog, 22));						GetProbabilities(theDialog,badvalue);						if not badvalue then							begin								for k := 0 to maxrandstate do									begin22:										redo := false;										if constantlock then											maxresttot := 1.0 - probchange[k][k]										else											maxresttot := 1.0;										tot := 0.0;										for j := 0 to maxrandstate do											tot := tot + probchange[k][j];										resttot := 0.0;										for j := 0 to maxrandstate do											if not constantlock or (k <> j) then												resttot := resttot + probchange[k][j];										if tot > 1.0 then											begin												numnonzero := 0;												for j := 0 to maxrandstate do													if not constantlock or (k <> j) then														if probchange[k][j] > 0.0 then															numnonzero := numnonzero + 1;											end										else if constantlock then											numnonzero := 3										else											numnonzero := 4;										if constantlock then											tot := resttot + probchange[k][k]										else											tot := resttot;										if (abs(tot - 1.0) > 0.0001 * numnonzero) then  {v3.02: 0.0001 was 0.01}											for j := 0 to maxrandstate do												if not constantlock or (k <> j) then{if probchange[k][j] > 0.0 then}													begin														probchange[k][j] := probchange[k][j] + (maxresttot - resttot) / numnonzero;														if probchange[k][j] < -0.00000001 then															begin																redo := true;																probchange[k][j] := 0.0;															end;													end;										if redo then											goto 22;									end;								SetProbabilities(theDialog);							end;					end;				23: 	{ratio norm}					begin						FlashBox(GetDLOGItemBox(theDialog, 23));						GetProbabilities(theDialog,badvalue);						if not badvalue then							begin								for k := 0 to maxrandstate do									begin										if constantlock then											maxresttot := 1.0 - probchange[k][k]										else											maxresttot := 1.0;{maxresttot is the final sum of the probabilities to be adjusted}										tot := 0;										for j := 0 to maxrandstate do											tot := tot + probchange[k][j];										if constantlock then											resttot := tot - probchange[k][k]										else											resttot := tot;										if (abs(tot - 1.0) > 0.0001) and (resttot <> 0) then  {v3.02: 0.0001 was 0.05}											for j := 0 to maxrandstate do												if not constantlock or (k <> j) then													probchange[k][j] := probchange[k][j] * (maxresttot / resttot);									end;								SetProbabilities(theDialog);							end;					end;				24:     {the lock}					begin						constantlock := not constantlock;						Flashbox(lockbox);						EraseRect(lockbox);						InvalidateWindowRect(myGetWindowPtrForDialog(theDialog),lockbox,false);						box2 := GetDLOGItemBox(theDialog, 3);						box := GetDLOGItemBox(theDialog, 18);						box2.right := box.right;						box2.bottom := box.bottom;						InsetRect(box2, -12, -12);						EraseRect(box2);						InvalidateWindowRect(myGetWindowPtrForDialog(theDialog),box2,false);					end;				31:    {save only characters with at least one change}{$IFC NOT MARKOV}					EvolveSaveOnlyChanged := not EvolveSaveOnlyChanged; {$ELSEC}				Markov;{$ENDC}				32:    {seed button}					GetRandomSeed;				33:    {random ancestral state }					begin						highstate := maxrandstate;						ParamText('Random ancestral states with following probabilities:', '', '', '');						if RandomStateDLOG(false) then							begin								EvolveAncConstant := false;							end;					end;				20, 34:    {constant ancester button}					EvolveAncConstant := true;				35: 					begin						InitProbChange;						SetProbabilities(theDialog);					end;				36: 					randEvolveUseLengths := not randEvolveUseLengths;				37: 					saveReport := not saveReport;				otherwise					;			end;			if localItemHit = 1 then   {better check to see if eveything normed ok}				begin					oldRandSeed := OurRandSeed;					GetProbabilities(theDialog,badvalue);					if not badvalue then						begin							notnormed := false;							for k := 0 to maxrandstate do								begin									tot := 0;									for j := 0 to maxrandstate do										tot := tot + probchange[k][j];									if (abs(tot - 1.0) > 0.005) then  {v3.02: 0.005 was 0.05}										begin											notnormed := true;											leave;										end;								end;							if notnormed then								begin									InstantError(145);									localItemHit := NotInDialog;								end;						end;				end;			CheckTreeRandomData(theDialog,allSetLengthsEqual,saveReport);		until localItemHit in [1, 2];		if localItemHit = 1 then			begin				GetProbabilities(theDialog,badvalue);				if badvalue then					goto 1;				EvolveNumChars := EditTextInt(theDialog, 19,true);				if EvolveNumChars < 1 then					goto 1				else if EvolveNumChars + numchars > mnchars then {v3.05}					begin						EvolveNumChars := mnchars - numchars - 1;						NewError(398, 0);					end;				if EvolveAncConstant then					begin						ds := GetEditText(theDialog, 20);						if length(ds) > 0 then							begin								EvolveAncState := NumOfChar(ds[1], 0, 0);								if EvolveAncState = MSl then									begin										ShowErrors('');										goto 2;									end;							end						else							EvolveAncState := 0;					end;MyDisposeUserItemUPP(UserItemUProcP);				EndDLOG(theDialog, tempP);				SetCursor(clockCursor);   {v3.01}				for j := 0 to maxrandstate do					begin						changeboundaries[j][0] := 0;						for k := 1 to maxrandstate do							changeboundaries[j][k] := changeboundaries[j][k - 1] + RoundValue(probchange[j][k - 1] * 32000)					end;{$IFC EVOLVEPAIRS}				if OptionDown then					begin						sigPairDigits := GetLongint('significant digits', 1, 1, 10, success);						if not success then							Exit(TreeRandomData);						sigPair := 0.5;						for j := 1 to sigPairDigits do							sigPair := sigPair / 10.0;						SetCursor(clockCursor);						ZeroPairEvents;						repeat							numEv := 0;							repeat								numEv := numEv + 1;								if EvolveAncConstant then									begin										R^.int1 := EvolveAncState;										R^.int2 := EvolveAncState;									end								else									begin										R^.int1 := NextRandomState;										R^.int2 := NextRandomState;									end;								EvolvePair(1, 2, R);							until numEv = 100;							pairReps := pairReps + 100;						until CheckPairEventStability;						WritePairedChanges;					end				else					begin						AddNewCharacters(EvolveNumChars, false);						if badmemory then							Exit(TreeRandomData);						SetCursor(clockCursor);						genericGetPort(tport);						DisableWindowUpdates(infowindow[charinfo]);						StartThermo(TD, tport, 0, EvolveNumChars, 'Creating characters', 'characters', false);						icstart := numchars - EvolveNumChars + 1;						ic := icstart;						totevolved := 0;						repeat							totevolved := totevolved + 1;							ds := concat('Rand.', StringFromNum(totevolved));							SetCharName(ic, ds);							if EvolveAncConstant then								R^.int1 := EvolveAncState							else								R^.int1 := NextRandomState;							charDidChange := false;							for j := 0 to maxrandstate do								for k := 0 to maxrandstate do									RealChangesChar[j][k] := 0;							EvolveCharacter(ic, R);							if not EvolveSaveOnlyChanged or charDidChange then								for j := 0 to maxrandstate do									for k := 0 to maxrandstate do										RealChanges[j][k] := RealChanges[j][k] + RealChangesChar[j][k];							UpdateThermo(TD, 0, EvolveNumChars - (numchars - ic), EvolveNumChars,false);							if abortedthermo then								begin									if ic < numchars then										DestroyCharacters(ic + 1, numchars, true, false,true,true);   {munch typesets, etc., and don't destroy feet}									leave;								end;							if not EvolveSaveOnlyChanged or charDidChange then								ic := ic + 1;						until ic > numchars;						EndThermo(TD, tport, true);						HUnLock(subR^.dnstH);						HUnLock(subR^.upstH);						HUnLock(subR^.stsH);						HUnLock(subsubR^.stsH);						SetHandleSize(subR^.dnstH, tcb * ord4(numchars));						SetHandleSize(subR^.upstH, tcb * ord4(numchars));						SetHandleSize(subR^.stsH, tcb * ord4(numchars));						SetHandleSize(subsubR^.stsH, tcb * ord4(numchars));						ExpandNodes(R);						if saveReport then   {v3.03}							WriteRealChanges(totevolved);						CheckCurrentTypes;  {v4: don't need to do whole thing}						goNex7on := nex7on & treeopen;						ResetTreeStatesH;			{use treebased states calc}						MaxstCalc(icstart, numchars);						CheckConstantCharacters(icstart,numchars);						dirtycharnames := true;						SizeInfoWindow(charinfo,false, false);{FROZEN 3.0}						golist := golist + ((fullgotree + fullgochartone + fullgochartmult) - igos - [gocontinuous]);					{characters added; redo all calculations except for those concerning i}					end;{$ELSEC}				AddNewCharacters(EvolveNumChars, false);				if badmemory then					Exit(TreeRandomData);				SetCursor(clockCursor);				genericGetPort(tport);				DisableWindowUpdates(infowindow[charinfo]);				StartThermo(TD, tport, 0, EvolveNumChars, 'Creating characters', 'characters', false);				icstart := numchars - EvolveNumChars + 1;				ic := icstart;				totevolved := 0;				repeat					totevolved := totevolved + 1;					ds := concat('Rand.', StringFromNum(totevolved));					SetCharName(ic, ds);					if EvolveAncConstant then						R^.int1 := EvolveAncState					else						R^.int1 := NextRandomState;					charDidChange := false;					for j := 0 to maxrandstate do						for k := 0 to maxrandstate do							RealChangesChar[j][k] := 0;					EvolveCharacter(ic, R);					if not EvolveSaveOnlyChanged or charDidChange then						for j := 0 to maxrandstate do							for k := 0 to maxrandstate do								RealChanges[j][k] := RealChanges[j][k] + RealChangesChar[j][k];					UpdateThermo(TD, 0, EvolveNumChars - (numchars - ic), EvolveNumChars,false);					if abortedthermo then						begin							if ic < numchars then								DestroyCharacters(ic + 1, numchars, true, false,true,true);   {munch typesets, etc., and don't destroy feet}							leave;						end;					if not EvolveSaveOnlyChanged or charDidChange then						ic := ic + 1;				until ic > numchars;				EndThermo(TD, tport, true);				HUnLock(subR^.dnstH);				HUnLock(subR^.upstH);				HUnLock(subR^.stsH);				HUnLock(subsubR^.stsH);				SetHandleSize(subR^.dnstH, tcb * ord4(numchars));				SetHandleSize(subR^.upstH, tcb * ord4(numchars));				SetHandleSize(subR^.stsH, tcb * ord4(numchars));				SetHandleSize(subsubR^.stsH, tcb * ord4(numchars));				ExpandNodes(R);				if saveReport then {v3.03}					WriteRealChanges(totevolved);				CheckCurrentTypes;  {v4: don't need to do whole thing}				goNex7on := nex7on & treeopen;				ResetTreeStatesH;			{use treebased states calc}				MaxstCalc(1, numchars);   {v3.02: have to do all characters as otherwise will not consider previous characters}				CheckConstantCharacters(1,numchars);				dirtycharnames := true;				SizeInfoWindow(charinfo,false, false);{FROZEN 3.0}				golist := golist + ((fullgotree + fullgochartone + fullgochartmult) - igos - [gocontinuous]);					{characters added; redo all calculations except for those concerning i}{$ENDC}			end		else1:			beginMyDisposeUserItemUPP(UserItemUProcP);				EndDLOG(theDialog, tempP);			end;	end;{-----------------------------------------------------------------------------}end.