unit GenCloseFile;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Devices, 		Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, 		EventUtil, GenUtil, StrUtil, CharUtil, Prohibitions, SetStates, ReadWriteUtil, ReadUtil, 		FootNote, TaxonCHUtil, MenuUtil, WriteTreeFile, TreeUtil, WriteUtil, CHUNK, SpreadUtil, 		TreeMaker, MCWindows, WriteData, StatesWindow;	procedure CloseFile;	function QuerySaveFiles (whichclose: str255): boolean;	procedure CloseUp;{еееееееееееееееееееееее}implementation {е$S GenCloseFile}{----------------------------------------------------------------------------}{----------------------------------------------------------------------------}	procedure CloseFile;		var			j, ignore, it: integer;			c: char;			dL: longint;			db: boolean;			oldState, oldState1: SignedByte;	begin		WriteDeskScrap;   {v3.05}		if fileopen then			begin				ZapHandle(chtypH);				ZapHandle(chwtH);				ZapHandle(chPartitionH);				ZapHandle(chStorePartitionH);				ZapHandle(chstoretypH);				ZapHandle(chstorewtH);				ZapHandle(chLenH);				ZapHandle(chpLH);				ZapHandle(chstatesH);				for j := 0 to stringchains do					DeleteCHUNKs(strCHUNKs[j], StartUserLink(j) + 1, UserLinks[j]);				{fff  DeleteCHUNKs(foreignCHUNKs, 1, GetHandleSize(foreignCHUNKs) div HdlSize);}				DeleteCHUNKs(typeCHUNKs, usedef, numtypes - usedef + 1);				EmptyCellBlock(EWFindSequenceBlockP);				EmptyNexusBlocks;				EmptyFootPicts;				EmptyCharPartNames;				numtypes := usedef - 1;{    ZapHandle(treedataH);}{    treedataH := NewHandle(0);}				SetHandleSize(treedataH, 0);				SetHandleSize(oldtreeH, 0);				for j := 0 to maxchain do					curLinkNames[j]^^ := '';				for j := 1 to numTextWindows do					begin						SetHandleSize(textWindowInfo[j]^.H, 0);						LockHandle(textWindowInfo[j]^.H,oldState1);						TESetText(textWindowInfo[j]^.H^, 0, textWindowInfo[j]^.TE);						ResetHandle(textWindowInfo[j]^.H,oldState1);						TECalText(textWindowInfo[j]^.TE);					end;				for j := 0 to maxFootType do					SetHandleSize(footH[j], 0);				EmptyAssociatedTreeHandles;			{fff 	SetHandleSize(foreignCHUNKs, 2);}			{fff	for j := 1 to numblocks do					EmptyForeignBlockText(j);}				treeinmemory := false;				fileopen := false;				ClosedFileMenus;{    if theWindow = commWindow then HideWindow(commWindow);}				{if (traceshown = traceAllChanges) then					myCheckMenuItem(TraceMHdl, TraceAllChangesItem, false)				else if (traceshown = traceAllStates) then					myCheckMenuItem(TraceMHdl, TraceAllStatesItem, false);}														EmptyTaxonCharacterMemory;			end;	end;{----------------------------------------------------------------------------}{$IFC NOT CARBON}	procedure CloseDesks;		var			accNumber: INTEGER;			FW: WindowPtr;	begin		if (FrontWindow <> nil) then			begin				accNumber :=myGetWindowKind(frontwindow);				if accNumber < 0 then					CloseDeskAcc(accNumber);			end;		if (frontwindow <> nil) and not MacCladeWindow(Frontwindow) then			CloseDesks;	end;{$ENDC}{----------------------------------------------------------------------------}	function QuerySaveFiles (whichclose: str255): boolean;{returns true if cancel is NOT hit}		var			db: boolean;			doCancel: boolean;			localItemHit: integer;{............}		procedure CheckCells;		begin			ReturnValue(editorSelectionTopLeft,false);			if badcellentry then				if BadCellEntryQuery then					DiscardCellChanges				else					begin						QuerySaveFiles := false;						Exit(QuerySaveFiles)					end;		end;{............}	begin{$IFC NOT DEMO}		QuerySaveFiles := true;		doCancel := false;		CheckDirty;		if dirtyfile then			begin				if newfile then					ParamText(concat('Save file before ', whichclose), '', '', '')				else					ParamText(concat('Save changes to file before ', whichclose), '', '', '');				localItemHit := DoAlert(SaveChangeID, CautionA);				if localItemHit = 1 then					begin						if statesWindowOpen then							begin								TurnOffSymbolsEditing;								TurnOffStatesEditing;							end;						ReturnAllInfoValues;						if editorSelected and editorOpen and SingleCell then							CheckCells;						if not doCancel then							if newfile | Locked(lockSaving) then								SaveAsFile							else								SaveFile;						if errorflag then							doCancel := true;					end				else if localItemHit = 3 then  {Cancel was hit}					doCancel := true;			end;		if doCancel then			QuerySaveFiles := false		else			QuerySaveFiles := QuerySaveTreeFile(whichclose);{$ELSEC}		QuerySaveFiles := true;{$ENDC}	end;{----------------------------------------------------------------------------}	procedure CloseUp;	begin{v4: make sure all windows are dealt with specifically here!}{in fact, it would be good to have a "CloseMacCladeWindow" procedure, to which one passes the windowPtr}{==== close any visible desk accessories ====}{$IFC NOT CARBON}		while (frontwindow <> nil) & (myGetWindowKind(frontwindow) < 0) do			CloseDeskAcc(myGetWindowKind(frontwindow));{$ENDC}{==== close next MacClade window ====}		if (frontWindow <> nil) & MacCladeWindow(frontwindow) then			begin				if frontWindow = pictwindow then					ClosePictWindow				else if frontWindow = chartwindow then					CloseChartWindow				else if IsEditorWindow(frontWindow) then					CloseEdit(false)				else if (frontWindow = statesWindow) then					CloseStatesWindow				else if IsTextWindow(frontWindow) then					CloseTextWindow(WhichTextWindow(frontWindow),true)				else if IsInfoWindow(frontwindow) then					CloseInfoWindow(WhichInfoWindow(frontwindow))				else if GetWindowType(frontwindow) <= 2 then					begin						genericSetPort(TreeWindow);						CloseTreeWindow(false);					end;			end;{==== close any visible desk accessories ====}{$IFC NOT CARBON}		while (frontwindow <> nil) & (myGetWindowKind(frontwindow) < 0) do			CloseDeskAcc(myGetWindowKind(frontwindow));{$ENDC}{==== if fileopen, but all MacClade windows closed, then closefile ====}		if fileopen & ((frontwindow = nil) | not MacCladeWindow(frontwindow)) then			CloseFile		else{==== if file not yet closed, and MacClade windows still visible, then closeup some more ====}			if (frontwindow <> nil) then				Closeup;	end;end.