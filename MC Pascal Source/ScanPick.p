unit ScanPick;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, 		TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, 		EventUtil, GenUtil, Coloring, Count, TreeCycle, SpreadUtil, TraceControl, BoxUtil, MenuUtil, 		StrUtil, TaxonCHUtil, CharUtil, TreeUtil, TypeUtil, SetStates, ToolOnBranch, Legends, 		InfoWindows, TreeDrawer, TreeMover, Swap, Prohibitions, ScrollTree;	procedure ScanPick;{еееееееееееееееееееееее}implementation {е$S ScanPick}{-----------------------------------------------------------------------------}	procedure AutoTreeScroll (dh, dv: integer; var m1, m2, wh: point);	begin		PENMODE(patCopy);		SetControlValueLong(vTWScroll, GetControlValueLong(vTWScroll) + dv);		SetControlValueLong(hTWScroll, GetControlValueLong(hTWScroll) + dh);		ScrollTreeWindow;		m1.v := m1.v - dv;		m1.h := m1.h - dh;		m2.v := m2.v - dv;		m2.h := m2.h - dh;		wh.v := wh.v - dv;		wh.h := wh.h - dh;		PENMODE(patXOR);	end;{-----------------------------------------------------------------------------}	procedure FlashTaxSetInfo;	var tport: WindowPtr;		box: rect;	begin		genericGetPort(tport);		genericSetPort(infoWindow[taxsetinfo] );		box := WindowPortRect(infoWindow[taxSetInfo]);		box.top := InfoHeight(taxsetinfo,infoTop[taxsetinfo]-1);		box.bottom := InfoHeight(taxsetinfo,infoBottom[taxsetinfo]);		box.right := infoDrawRect[taxsetinfo].right - scrollwidth - 1;		InvertRect(box);		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	procedure ScanPickScreen (N: Nptr; var m2: point);		var			ir, windowloc, top: integer;			codeword: longint;			box: rect;			useset: largestsetchars;			sN, afn: Nptr;			dss, ds: str255;			c: char;			crect, ActiveMessageB: Rect;			activeMessage, j: integer;			tport: WindowPtr;			p1, p2, c1, c2: point;			doflash: boolean;			oldClip: RgnHandle;			inInfoWindow: boolean;	begin		doflash := true;		SetRect(ActiveMessageB, 0, 0, 0, 0);		p2 := m2;		c2 := m2;		genericSetPort(toolPaletteWindow[treeTools]);		GlobalToLocal(p2);		genericSetPort(chlegwindow);		GlobalToLocal(c2);		genericSetPort(TreeWindow);		if (traceshown = traceDiscrete) and not isterminalfixanc(N) then			begin				if N^.fix then					c := fixedFlag				else					begin						if TreatAsUncertainty(N^.final, N, i) then							c := '?'						else							c := '*';					end;{$IFC DEBUG}				if (N^.final - [0..charmaxstDEF(i)] - [ucl]) <> [] then					InstantInfo(concat('Calculation Error: state set is', SetToString(N^.final)));				if N^.final = [] then					InstantInfo('Calculation Error; state set empty');{$ENDC}				genericSetPort(chlegwindow);				if not isterminalfixanc(N) then					DrawAsterisksEtc(N^.final, i, c);				genericSetPort(TreeWindow);			end;		PENMODE(patXOR);		Penpat(dashpat);		FlashBranch(N);		inInfoWindow := false;		Penpat(QDBlack); {draw line from selected edge:}		MoveTo(wh.h, wh.v);		BeginDragSound;		repeat			CallWaitNextEventForDrawing;			repeat				GETMOUSE(m1);			until (m2.h <> m1.h) or (m2.v <> m1.v) or not BUTTON;			LocalToGlobal(m1);			windowloc := FindWindow(m1, whichwindow);			p1 := m1;			c1 := m1;			genericSetPort(toolPaletteWindow[treeTools]);			GlobalToLocal(p1);			genericSetPort(chlegwindow);			GlobalToLocal(c1);			genericSetPort(TreeWindow);			GlobalToLocal(m1);			FlashBranch(N);			FlashBranch(N);			genericGetPort(tport);			genericSetPort(toolPaletteWindow[treeTools]);			if (PTINRECT(p2, ActiveMessageB)) and not (PTINRECT(p1, ActiveMessageB)) then				begin					InvertRect(ActiveMessageB);					SetRect(ActiveMessageB, 0, 0, 0, 0);					writePalmessageB(treeTools,' ');				end;			genericSetPort(tport);			if whichwindow = infoWindow[taxsetinfo] then				begin					if not inInfoWindow then						FlashTaxSetInfo;					inInfoWindow := true;				end			else 				begin					if inInfoWindow then						begin							FlashTaxSetInfo;							inInfoWindow := false;						end;					if whichwindow = toolPaletteWindow[treeTools] then						begin							genericGetPort(tport);							genericSetPort(toolPaletteWindow[treeTools]);							if not PTINRECT(p1, ActiveMessageB) then								for j := 0 to numTools[treeTools] do									if PtInRect(p1, tool^[treeTools,j].R) & tool^[treeTools,j].enabled then										begin											writePalMessageB(treeTools,PaletteString(treeTools,j, N));											ActiveMessageB := tool^[treeTools,j].R;											InvertRect(ActiveMessageB);											leave;										end;							genericSetPort(tport);						end					else if flashbranchon then						begin							FindBranch(m1, ScreenR,false);							if (currentTool[treeTools] = polyflipT) & not PartOfSamePolytomy(fN, N) then								fn := subR;							if (fn <> lastselN) then								begin									oldClip := NewRgn;									GetClip(oldClip);									SetDataBoxesClip;									Penpat(dashpat);									PENMODE(patXOR);									if lastselN <> subR then   {turn off last}										OutlinePoly(lastselN);									Penpat(dashpat);									if fn <> subR then    {turn on new}										OutlinePoly(fN);									lastselN := fn;									Penpat(QDBlack);									SetClip(oldClip);									ZapRegion(oldClip);								end;						end;				end;			MoveTo(m2.h, m2.v);			LineTo(wh.h, wh.v);{==== autoscroll section ====}			if nex7on then				top := databoxB.bottom  {orient: need to ask following questions with oriented M1.v,m1.h}			else				top := visTWR.top;  {orient: here need to use visTWR.right if treeflipped}			box := WindowPortRect(treeWindow);			box.left := box.left-4;			box.top := box.top-4;			if PtInRect(m1,box) then				if (m1.v < top + 4) and (GetControlValueLong(vTWScroll) > GetControlMinimumLong(vTWScroll)) then					AutoTreeScroll(0, -20, m1, m2, wh)				else if (m1.v > visTWR.bottom - 2) and (GetControlValueLong(vTWScroll) < GetControlMaximumLong(vTWScroll)) then					AutoTreeScroll(0, 20, m1, m2, wh)				else if (m1.h < visTWR.left + 4) and (GetControlValueLong(hTWScroll) > GetControlMinimumLong(hTWScroll)) then					AutoTreeScroll(-20, 0, m1, m2, wh)				else if (m1.h > visTWR.right - 2) and (GetControlValueLong(hTWScroll) < GetControlMaximumLong(hTWScroll)) then					AutoTreeScroll(20, 0, m1, m2, wh);			MoveTo(wh.h, wh.v);			LineTo(m1.h, m1.v);			LocalToGlobal(m1);			m2 := m1;			p2 := m2;			c2 := m2;			genericSetPort(toolPaletteWindow[treeTools]);			GlobalToLocal(p2);			genericSetPort(chlegwindow);			GlobalToLocal(c2);			genericSetPort(TreeWindow);			GlobalToLocal(m2);		until not BUTTON;		EndDragSound;		GlobalToLocal(m1);		if (lastselN <> subR) then   {turn off last}			begin				Penpat(dashpat);				OutlinePoly(lastselN);				Penpat(QDBlack);				lastselN := subR;			end;		genericSetPort(treewindow);		TWmessage := ' ';		writeTWmessageB;		MoveTo(m2.h, m2.v);		LineTo(wh.h, wh.v);		LineTo(wh.h, wh.v);		Penpat(dashpat);		if doflash then			FlashBranch(N);		Penpat(QDBlack);		PENMODE(patCopy);		SETCURSOR(clockCursor);		genericSetPort(chlegwindow);		if (traceshown = traceDiscrete) and not isterminalfixanc(N) then			EraseAsterisksEtc;		genericSetPort(treewindow);	end;{-----------------------------------------------------------------------------}	procedure MarkTaxaInCladeAsOtherSelected(N: Nptr);	begin		if NodeIsInternal(N) then			begin				MarkTaxaInCladeAsOtherSelected(N^.lf);				MarkTaxaInCladeAsOtherSelected(N^.rt);			end		else			SetOtherSelected(taxSetChain,N^.name,true);	end;{-----------------------------------------------------------------------------}	procedure SaveCladeAsTaxSet(N: Nptr);	var tport: WindowPtr;	begin		InitOtherSelected(taxSetChain);		MarkTaxaInCladeAsOtherSelected(N);		FlashTaxSetInfo;		MakeNewObject(taxsetinfo,'untitled clade',true,true,true);	end;{-----------------------------------------------------------------------------}	procedure ScanPick;  {scans to see if branch clicked on}		label			1;		var		{& where it is dropped}			m2: POINT;			N, tN: Nptr;			goahead, moved, restoretool: boolean;			oldCollapsetreeTE: TEHandle;			dummyR: rect;			ir, it, intaxon, windowloc, oldtool, tslant, oldi,oldedw, foundChar: integer;			j, ScanTool: Integer;			ds, tds, dds: str255;			tport, Whichwindow: windowptr;			irn, ixp: longint;			trn, rn: double;			oldClip: RgnHandle;{.................}	begin		oldtool := currentTool[treeTools];		if CommandEvent(Event) and not ShiftEvent(Event) and not OptionEvent(Event) then			begin				SetTool(treeTools,arrowT);				restoretool := true;			end		else			restoretool := false;		FindBranch(wh, ScreenR, ((currentTool[treeTools]=queryT)& TicksVisible) & ticksNoNames);  		if fN=subR then {didn't find a branch, find near branch}			begin				if  TickNamesVisible & tool^[treeTools,currentTool[treeTools]].worksOnTicks then					if (squareBranches & FindJustRightOfBranch(wh, ScreenR, fN)) | (not squareBranches & FoundTickBoxNearBranch(fN,wh,foundChar)) then						if currentTool[treeTools]=queryT then							begin								if queryToolsPopUp then									ReportOnBranch(fN,wh)								else									ShowBranchListWindow(fN);							end						else							ToolOnBranchTick(currentTool[treeTools],fN,wh);			end		else  {did find a branch}			begin				if (storedN <> subR) and (currentTool[treeTools] <> expandT) then   {stored node in diamond tool}					begin						fromN := storedN;						if MoveNodeToFrom(fN) then							begin								lastselN := subR;								if expd then									begin										ShrinkTree;										FixTreeShadingMenus;									end;							end;						tool^[treeTools,arrowT].curs := arrowcurs;						DropTool(treeTools,arrowT);						storedN := subr;					end				else					begin						if flashbranchon then							if lastselN <> subR then   {turn off flashbranch}								begin									oldClip := NewRgn;									GetClip(oldClip);									SetDataBoxesClip;									PENMODE(patXOR);									Penpat(dashpat);									OutlinePoly(lastselN);									Penpat(QDBlack);									PENMODE(patCopy);									lastselN := subR;									SetClip(oldClip);									ZapRegion(oldClip);								end;						if not ((currentTool[treeTools] = arrowT) or (currentTool[treeTools] = polyflipT) or ((currentTool[treeTools] = rerootT) and UseOptionTool(treeTools,rerootT,OptionEvent(Event)))) then							ToolOnBranch(currentTool[treeTools], fN)						else							begin								if dblclick and (currentTool[treeTools] = arrowT) then									ToolOnBranch(expandT, fN){$IFC RANDOMMOVE}								else if (currentTool[treeTools] = arrowT) & OptionEvent(Event) & ShiftEvent(Event) & not CommandEvent(Event) then									RandomBranchMove(fN){$ENDC}								else if (currentTool[treeTools] = arrowT) | ((currentTool[treeTools] = polyflipT) & PartofPolytomy(fN)) | ((currentTool[treeTools] = rerootT) & UseOptionTool(treeTools,rerootT,OptionEvent(Event))) then									begin										N := fN;										fromN := N;										if (currentTool[treeTools] = arrowT) then											begin												tool^[treeTools,arrowT].curs := diamond;												DropTool(treeTools,arrowT);												BrSelectLegs(N);											end;										SetCursH(diamond);										m2 := wh;										ScanPickScreen(N, m2);										tool^[treeTools,arrowT].curs := arrowcurs;{for j := 0 to numTools[treeTools] do DropTool(treeTools,j);}										LocalToGlobal(m2);										windowloc := FindWindow(m2, whichwindow);{==== dropped in tool^ palette window ====}										if currentTool[treeTools] = arrowT then    {only do this if arrowT}											if whichwindow=infoWindow[taxsetinfo] then												begin													genericSetPort(infoWindow[taxsetinfo]);													SaveCladeAsTaxSet(N);												end											else if whichwindow = toolPaletteWindow[treeTools] then												begin													genericSetPort(toolPaletteWindow[treeTools]);													GlobalToLocal(m2);													if PTINRECT(m2, tool^[treeTools,arrowT].R) then														begin															invertrect(tool^[treeTools,arrowT].R);															ToolOnBranch(arrowT, N);															goto 1;														end													else														for j := 0 to numTools[treeTools] do															if PTINRECT(m2, tool^[treeTools,j].R) then																begin																	invertrect(tool^[treeTools,j].R);																	ToolOnBranch(j, N);																	goto 1;																end;													LocalToGlobal(m2);												end{==== dropped in chlegwindow ====}											else if (whichwindow = chlegwindow) and (traceshown = traceDiscrete) and not N^.fixanc then												begin													genericSetPort(chlegwindow);													GlobalToLocal(m2);													for ir := 1 to CharMaxstDISPLAY(i) + 1 do														if PTINRECT(m2, strect[ir]) and ((ir - 1) in legendstates) then															begin																if ir > charmaxstDEF(i) + 1 then																	NewError(341, 0)																else																	begin																		invertrect(strect[ir]);																		setcursor(clockCursor);																		N^.fix := TRUE;																		dirtyfix := true;																		fixon := TRUE;																		myEnableItem(TraceMHdl, UnfixAllItem);																		invertrect(strect[ir]);																		N^.fixsts := [ir - 1];																		FixStateGoList;																		InvalidateWindow(twmesswindow, false);																		leave;																	end;															end;													LocalToGlobal(m2);												end;										genericSetPort(TreeWindow);										GlobalToLocal(m2);										if (N <> R) and not (IsTerminalFixanc(N)) then{===== ScanDrop =====}											begin												FindBranch(m1, ScreenR,false);												if fN <> subR then{fN is global Nptr which stores tresults of FindBranch (probably a remnant of good old }{days of globals).  Early in ScanPick the first fN, the result of the first touch on a branch,}{is stored in N.  This fN just above is the second fN, the branch on which the first may}{have been dropped}													begin														if (currentTool[treeTools] = arrowT) then															begin																fromN := N;																moved := MoveNodeToFrom(fN);															end														else if (currentTool[treeTools] = polyflipT) & PartofSamePolytomy(N, fN) and (N <> fN) then															begin																if N^.anc = fN^.anc then																	begin																		if (N = N^.anc^.rt) then																			begin																				N^.anc^.rt := fN;																				N^.anc^.lf := N;																			end																		else																			begin																				N^.anc^.rt := N;																				N^.anc^.lf := fN;																			end;																	end																else																	begin																		if (N = N^.anc^.rt) then																			N^.anc^.rt := fN																		else																			N^.anc^.lf := fN;																		if (fN = fN^.anc^.rt) then																			fN^.anc^.rt := N																		else																			fN^.anc^.lf := N;																	end;																tN := N^.anc;																N^.anc := fN^.anc;																fN^.anc := tN;																tslant := N^.slant;																N^.slant := fN^.slant;																fN^.slant := tslant;																DrawR := NotNullAnc(N);																DrawRloc := DrawR^.loc;																godraw := true;																myDisableItem(editMHdl, UndoItem);																noundo := true;																fixlostbyundo := false;																justundid := false;																dirtyfile := true;																SetDirtyTree;																nomove := true;															end														else if ((currentTool[treeTools] = rerootT) & UseOptionTool(treeTools,rerootT,OptionEvent(Event))) then{reroot clade fN so that N is the new root}															begin																if (fN <> N) then {v3.02:}																	if (IsAnc(fN, N)) & ((N^.anc <> fN) | NodeIsPolytomous(fN)) & not (IsTerminalFixanc(N)) then																		begin																			setcursor(clockCursor);																			Reroot(N, fN);																			dontCancelUpdate := godraw;   {will be true if fixanc turned off in reroot}																			if (traceshown = traceDiscrete) or (traceshown = traceContinuous) or (traceshown = traceProbability) then																				godraw := true   {force godraw, as otherwise FillBranches down before tree branches repositions}																			else																				InvalidateWindow(treewindow, false);																			InvalidateWindow(tlegwindow, false);																		end;															end;													end;											end;1:									end;							end;						if (storedN = subR) and restoretool and not ((oldtool = turpentineT) and not fixon) then  {there is no stored branch}							currentTool[treeTools] := oldtool;						DrawPalette(treeTools);					end;				FixTreeShadingmenus;			end;		if (storedN = subR) and restoretool and not ((oldtool = turpentineT) and not fixon) then  {there is no stored branch}			currentTool[treeTools] := oldtool;	end;end.