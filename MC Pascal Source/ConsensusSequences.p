unit ConsensusSequences;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{ееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, 		TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  UtilLibInterface, MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, 		ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, TypeUtil, CharUtil, TreeUtil, 		MenuUtil, SymbolsNames, FootNote, SpreadUtil,LinkUtil;		procedure AddNewConsensus;	procedure InitConsensusPtr(theConsensus: ConsensusPtr);	procedure InitConsensus(consensusNumber: integer);	procedure DestroyConsensus(consensusNumber: integer);	procedure EmptyConsenses;		procedure SelectConsensus(consensusNumber: integer; on: boolean);	function SomeConsensusSelected(var consensusNumber: integer): boolean;	function ConsensusSelected(consensusNumber: integer): boolean;		procedure CheckConsensusSequences;	procedure CalcFullConsensusInfo(consensusNumber, ic: integer; default: LargestSetChars; var allTies: LargestSetChars; var areTies: boolean; var maxFreq,numValues: integer);	function GetConsensusSet(consensusNumber, ic: integer; reCalculate,skipFirst: boolean; var trueMajority: boolean; default: LargestSetChars; var dataFraction: double): LargestSetChars;	function GetConsensusName(consensusNumber: integer): str255;	function ConsensusDialog(consensusNumber: integer): boolean;{ееееееееееееееееееееее}implementation {е$S SpreadUtil}{-----------------------------------------------------------------------------}	procedure InitConsensusPtr(theConsensus: ConsensusPtr);	begin		if theConsensus <> nil then			with theConsensus^ do				begin					prev:= nil;					next := nil;					majorityPercent:=0;					majorityFraction := 0.0;					modalFullFreq := 0;					showModalFreqOnMove := false;					taxSet := defaultTaxSetForConsensus;					modalFreq := 0;					exactMatch:= true;					show:=true;					dimProportionalToNonGaps:= false;					dimProportionalToFreq := true;					showOnlyFullMajority:= false;					selected:= false;					dontshowties := false;				end;	end;{-----------------------------------------------------------------------------}	procedure InitConsensus(consensusNumber: integer);	var theConsensus: ConsensusPtr;	begin		theConsensus := Consensus(consensusNumber);		InitConsensusPtr(theConsensus);	end;{-----------------------------------------------------------------------------}	procedure AddNewConsensus;	var theConsensus: ConsensusPtr;	begin		theConsensus := editorConsensus;		if theConsensus <> nil then			while theConsensus^.next <> nil do				begin					theConsensus := theConsensus^.next;				end;		theConsensus^.next := ConsensusPtr(NewPtrClear(SizeOf(consensusRecord)));		InitConsensusPtr(theConsensus^.next);		theConsensus^.next^.prev := theConsensus;		editorNumConsensusSequences:= editorNumConsensusSequences+1;	end;{-----------------------------------------------------------------------------}	procedure DestroyConsensus(consensusNumber: integer);	var theConsensus: ConsensusPtr;	begin		theConsensus := Consensus(consensusNumber);		if (theConsensus = editorConsensus) then			begin				if  (editorNumConsensusSequences>1) then					begin						editorConsensus := theConsensus^.next;						editorConsensus^.prev := nil;						editorNumConsensusSequences:= editorNumConsensusSequences-1;						ZapPointer(theConsensus);					end				else					begin						InitConsensusPtr(theConsensus);						editorShowConsensusSequences := false;					end;			end		else if theConsensus <> nil then			begin				if theConsensus^.next <> nil then					theConsensus^.next^.prev := theConsensus^.prev;				if theConsensus^.prev <> nil then					theConsensus^.prev^.next := theConsensus^.next;				editorNumConsensusSequences:= editorNumConsensusSequences-1;				ZapPointer(theConsensus);			end;	end;{-----------------------------------------------------------------------------}	procedure EmptyConsenses;	var theConsensus: ConsensusPtr;	begin		if editorConsensus <> nil then			while editorConsensus^.next <> nil do				DestroyConsensus(2);		InitConsensusPtr(editorConsensus);		editorShowConsensusSequences := false;	end;{-----------------------------------------------------------------------------}	procedure SelectConsensus(consensusNumber: integer; on: boolean);	var theConsensus: ConsensusPtr;		j: integer;	begin		for j := 1 to editorNumConsensusSequences do			begin				theConsensus:= Consensus(j);				if (theConsensus<> nil) then					begin						if j= consensusNumber then							theConsensus^.selected :=  on						else							theConsensus^.selected :=  false;					end;			end;	end;{-----------------------------------------------------------------------------}	function SomeConsensusSelected(var consensusNumber: integer): boolean;	var theConsensus: ConsensusPtr;		j: integer;	begin		SomeConsensusSelected:= false;		for j := 1 to editorNumConsensusSequences do			begin				theConsensus:= Consensus(j);				if (theConsensus<> nil) & theConsensus^.selected then					begin						SomeConsensusSelected := true;						consensusNumber := j;						leave;					end;			end;	end;{-----------------------------------------------------------------------------}	function ConsensusSelected(consensusNumber: integer): boolean;	var theConsensus: ConsensusPtr;	begin		theConsensus:= Consensus(consensusNumber);		ConsensusSelected := (theConsensus<> nil) & theConsensus^.selected;	end;{-----------------------------------------------------------------------------}	procedure CheckConsensusSequences;	var j: integer;	begin		editorFirstRow := 1;		editorFirstColumn := 1;		If editorShowConsensusSequences then			if  not editorTransposed  then				editorFirstRow := editorNumConsensusSequences+1			else				editorFirstColumn := editorNumConsensusSequences+1;		{FixTotNums;}	end;{-----------------------------------------------------------------------------}	procedure CalcFullConsensusInfo(consensusNumber, ic: integer; default: LargestSetChars; var allTies: LargestSetChars; var areTies: boolean; var maxFreq,numValues: integer);	type		statefreqT = array[0..absmaxstate] of integer;  	var		 it, k: integer;		statefreq: statefreqT;		maxfreqstate, itblockStart,itBlockEnd, icBlock: integer;		tsts: LargestSetChars;		someDataFromCellBlock,smallSymbol: boolean;		charH: chHdl;	begin		maxfreq := -1;		charH := getchHdl(ic);		areTies := false;		allTies := [];		numValues:= 0;		someDataFromCellBlock :=  (EWCurrentDrawBlockP <> nil) & (ic >= EWCurrentDrawBlockP^.currentstartchars) & (ic <= EWCurrentDrawBlockP^.currentendchars);		if someDataFromCellBlock then			begin				itBlockStart := EWCurrentDrawBlockP^.currentstarttaxa;				itBlockEnd := EWCurrentDrawBlockP^.currentendtaxa;				icBlock := ic-EWCurrentDrawBlockP^.currentstartchars+1;			end		else			begin				itBlockStart := 0;				itBlockEnd:= 0;				icBlock := ic;			end;		for k := 0 to maxstate do			statefreq[k] := 0;		for it := 1 to numtaxa do			if (editorConsensusTaxSet=AllTaxSet)|(InTaxSetLink(editorConsensusTaxSet,it)) then				begin					if someDataFromCellBlock & (it >= itBlockStart) & (it <= itBlockEnd) then						tsts := CellBlockStates(EWCurrentDrawBlockP,it-itBlockStart+1,icBlock,ic, smallSymbol)					else						tsts := gettaxonstsLargest(it, ic);					if not (MSl in tsts) then						numValues := numValues+1;					for k := 0 to maxstate do						if k in tsts then							statefreq[k] := statefreq[k] + 1;				end;		for k := 0 to maxstate do			if statefreq[k] > maxfreq then				begin					maxfreq := statefreq[k];					maxfreqstate := k;					allTies := [k];				end			else if statefreq[k] = maxfreq then				allTies := allTies + [k];				areTies := CardLg(allTies) > 1;		if areTies then			allTies := allTies+[UCl];		charH^^.consensusAreTies := areTies;		charH^^.consensusAllTies := allTies;		charH^^.consensusNumValues := numValues;		charH^^.consensusMaxFreq := maxFreq;	end;{-----------------------------------------------------------------------------}	procedure CalcConsensusInfo(ic: integer;skipFirst: boolean);	type		statefreqT = array[0..absmaxstate] of integer;  	var		 it, k: integer;		statefreq: statefreqT;		maxfreqstate, itblockStart,itBlockEnd, icBlock: integer;		tsts: LargestSetChars;		someDataFromCellBlock,smallSymbol: boolean;		charH: chHdl;		allTies: LargestSetChars; 		areTies: boolean; 		maxFreq,numValues, theState: integer;		firstTaxon: integer;	begin		maxfreq := -1;		areTies := false;		allTies := [];		numValues:= 0;		someDataFromCellBlock :=  (EWCurrentDrawBlockP <> nil) & (ic >= EWCurrentDrawBlockP^.currentstartchars) & (ic <= EWCurrentDrawBlockP^.currentendchars);		if someDataFromCellBlock then			begin				itBlockStart := EWCurrentDrawBlockP^.currentstarttaxa;				itBlockEnd := EWCurrentDrawBlockP^.currentendtaxa;				icBlock := ic-EWCurrentDrawBlockP^.currentstartchars+1;			end		else			begin				itBlockStart := 0;				itBlockEnd:= 0;				icBlock := ic;			end;		for k := 0 to maxstate do			statefreq[k] := 0;		if skipFirst then firstTaxon := 2		else firstTaxon := 1;		for it := firstTaxon to numtaxa do			if (editorConsensusTaxSet=AllTaxSet)|(InTaxSetLink(LinkNumOfUser(taxsetchain,editorConsensusTaxSet),it)) then				begin					if someDataFromCellBlock & (it >= itBlockStart) & (it <= itBlockEnd) then						tsts := CellBlockStates(EWCurrentDrawBlockP,it-itBlockStart+1,icBlock,ic, smallSymbol)					else						tsts := gettaxonstsLargest(it, ic);					if not (MSl in tsts) then						begin							numValues := numValues+1;							{theState := MinLg(tsts);							statefreq[theState] := statefreq[theState] + 1;}							{if tsts <> [theState] then}								for k := 0 to maxstate do									if k in tsts then										begin											statefreq[k] := statefreq[k] + 1;										end;						end;				end;		for k := 0 to maxstate do			if statefreq[k] > maxfreq then				begin					maxfreq := statefreq[k];					maxfreqstate := k;					allTies := [k];				end			else if statefreq[k] = maxfreq then				allTies := allTies + [k];				areTies := CardLg(allTies) > 1;		if areTies then			allTies := allTies+[UCl];		charH := getchHdl(ic);		charH^^.consensusAreTies := areTies;		charH^^.consensusAllTies := allTies;		charH^^.consensusNumValues := numValues;		charH^^.consensusMaxFreq := maxFreq;	end;{-----------------------------------------------------------------------------}	function GetConsensusSet(consensusNumber, ic: integer; recalculate,skipFirst: boolean; var trueMajority: boolean; default: LargestSetChars; var dataFraction: double): LargestSetChars;	var		tsts: LargestSetChars;		theConsensus: ConsensusPtr;		partialMajority: boolean;		charH: chHdl;		numTaxaActive : integer;		oldState: SignedByte;		freq: double;	begin		if reCalculate  then			CalcConsensusInfo(ic,skipFirst);		dataFraction := 1.0;		theConsensus:= Consensus(consensusNumber);		if theConsensus= nil then			begin				GetConsensusSet:= default;				trueMajority := false;				Exit(GetConsensusSet);			end;		charH := getchHdl(ic);				LockHandle(charH,oldstate);		with charH^^ do			begin				if (editorConsensusTaxSet=AllTaxSet) then					if skipFirst then						numTaxaActive := numtaxa -1					else						numTaxaActive := numtaxa 				else					numTaxaActive := GetNumberElementsInLink(taxsetchain,LinkNumOfUser(taxsetchain,editorConsensusTaxSet),nil);				freq := consensusMaxFreq/consensusNumValues;				if theConsensus^.dimProportionalToFreq then					dataFraction := dataFraction*(freq);				if theConsensus^.dimProportionalToNonGaps then					dataFraction := dataFraction*(consensusNumValues/numTaxaActive);								trueMajority := (consensusMaxFreq/numTaxaActive >= theConsensus^.majorityFraction);				partialMajority :=  (freq >= theConsensus^.majorityFraction);				if  (consensusMaxFreq>0)&(trueMajority| (not theConsensus^. showOnlyFullMajority & partialMajority))  then					begin						if consensusAreTies & theConsensus^.dontShowTies then							GetConsensusSet:= default						else							GetConsensusSet:= consensusAllTies;					end				else					GetConsensusSet := default;			end;		ResetHandle(charH,oldstate);		{GetConsensusSet := [MSl];}	end;{-----------------------------------------------------------------------------}	function GetConsensusName(consensusNumber: integer): str255;	var ds: str255;		theConsensus: ConsensusPtr;	begin		ds := 'Modal';		theConsensus := Consensus(consensusNumber);		if theConsensus <> nil then			begin				if theConsensus^.majorityPercent>0 then					ds :=concat(ds,', │',StringFromNum(theConsensus^.majorityPercent),'%');				if theConsensus^.showOnlyFullMajority then					ds :=concat(ds,', full maj.');				if theConsensus^.dontshowties then					ds :=concat(ds,', ties omitted');				if blockMoveOn & theConsensus^.showModalFreqOnMove then					ds := concat (StringFromNum(theConsensus^.modalFreq),'/',StringFromNum(theConsensus^.modalFullFreq));							end;		GetConsensusName := ds;	end; {-----------------------------------------------------------------------------}	function ConsensusDialog(consensusNumber: integer): boolean;	{if consensusNumber=0 then should create new one}		var			theDialog: DialogPtr;			theConsensus: ConsensusPtr;			tempP: WindowPtr;			tmatchcharon: boolean;			majorityPercent: integer;			exactMatch,dimProportionalToNonGaps,showModalFreqOnMove: boolean;			dimProportionalToFreq: boolean;			showOnlyFullMajority, dontshowties: boolean;			ds: str255;			localItemHit: integer;			 newMajorityPercent: longint;			 firstParamText, secondParamText: str255; {........}		procedure AdjustParamText;		begin			if showOnlyFullMajority then				ParamText(firstParamText,secondParamText, concat('all ',firstParamText,' ',secondParamText),'')			else 				ParamText(firstParamText,secondParamText, concat(firstParamText,' without gaps ',secondParamText),'');		end; {........}		procedure CheckConsensusDLOG;		begin			ItemCheckMark(theDialog, 5, dimProportionalToFreq);			ItemCheckMark(theDialog, 15, dimProportionalToNonGaps);			ItemCheckMark(theDialog, 6, showOnlyFullMajority);			ItemCheckMark(theDialog, 11, dontshowties);			ItemCheckMark(theDialog, 14, showModalFreqOnMove);		end; {........}		procedure CheckPercentItem;		begin			ds := GetEditText(theDialog, 3);			newMajorityPercent := -1;			if StringIsLongint(ds) then				begin					StringToNum(ds,newMajorityPercent);					if (newMajorityPercent<0) | (newMajorityPercent>100) then						newMajorityPercent := -1;				end;			if newMajorityPercent=-1 then				begin					SetDLOGText(theDialog,3, StringFromNum(majorityPercent),true);					Beep;				end			else				majorityPercent := newMajorityPercent;		end;	begin		ConsensusDialog:= false;		StartDLOG(164, theDialog, tempP);		theConsensus := nil;		majorityPercent := 0;		dimProportionalToNonGaps:= false;		showOnlyFullMajority := false;		showModalFreqOnMove := false;		dimProportionalToFreq := true;		dontshowties := false;		if consensusNumber=0 then			begin				SetDLOGText(theDialog, 3, '0', true);				EnableDisableDLOGItem (theDialog,9,false,false);			end		else			begin				theConsensus:= Consensus(consensusNumber);				if theConsensus <> nil then					begin						majorityPercent:= theConsensus^.majorityPercent;						dimProportionalToNonGaps:= theConsensus^.dimProportionalToNonGaps;						dimProportionalToFreq := theConsensus^.dimProportionalToFreq;						showOnlyFullMajority := theConsensus^.showOnlyFullMajority;						showModalFreqOnMove := theConsensus^.showModalFreqOnMove;						dontshowties := theConsensus^.dontshowties;						SetDLOGText(theDialog,3, StringFromNum(majorityPercent),true);					end;			end;		if molecular then 			begin				firstParamText := 'sequences';				secondParamText := 'at that site';			end		else			begin				firstParamText := 'taxa';				secondParamText := 'in that character';			end;		AdjustParamText;		CheckConsensusDLOG;		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			case localitemhit of				3: checkPercentItem;				5:					begin						dimProportionalToFreq:= not dimProportionalToFreq;						CheckConsensusDLOG;					end						15,16:						begin						dimProportionalToNonGaps:= not dimProportionalToNonGaps;						CheckConsensusDLOG;					end						6,10:						begin						showOnlyFullMajority:= not showOnlyFullMajority;						CheckConsensusDLOG;						AdjustParamText;						DrawDialog(theDialog);					end											11: 					begin						dontshowties:= not dontshowties;						CheckConsensusDLOG;					end;				14: 					begin						showModalFreqOnMove:= not showModalFreqOnMove;						CheckConsensusDLOG;					end;									9: {apply}				;				otherwise;			end;		until localItemHit in [1, 2, 9];		EndDLOG(theDialog, tempP);		if localItemHit = 2 then			begin							end		else 			begin				if (theConsensus=nil) | (localitemhit=1) then					begin						if not editorShowConsensusSequences then							begin								editorShowConsensusSequences := true;								theConsensus := editorConsensus;							end						else							begin								AddNewConsensus;								theConsensus := Consensus(editorNumConsensusSequences);							end;					end;				if theConsensus <> nil then					begin						theConsensus^. majorityPercent := majorityPercent;						theConsensus^.majorityFraction := majorityPercent/100.00;						theConsensus^. dimProportionalToFreq := dimProportionalToFreq;						theConsensus^. dimProportionalToNonGaps := dimProportionalToNonGaps;						theConsensus^. showOnlyFullMajority := showOnlyFullMajority;						theConsensus^. dontshowties := dontshowties;						theConsensus^.showModalFreqOnMove := showModalFreqOnMove;					end;				ConsensusDialog := true;				dirtyfile := true;			end;	end;end.