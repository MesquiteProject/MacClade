unit Footnote;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{ееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, 		EventUtil, GenUtil, StrUtil, BoxUtil, Sound, WriteUtil, TaxonCHUtil, SymbolsNames, CharUtil, 		TreeUtil, PICT, MenuUtil, NexusBlocks,ToolPalette;	procedure GetFootTaxChar (var it, ic: integer; startFootP, curPos: longint);	function GetFootString (theFoot, it, ic: integer; var ds: str255): boolean;	function GetFootLongint (theFoot, it, ic: integer; var dL: longint): boolean;	procedure SetFootString (theFoot, it, ic: integer; ds: str255);	procedure SetFootLongint (theFoot, it, ic: integer; dL: longint);	procedure ShiftFeet (theFoot, theStart1, theEnd1, shift1, theStart2, theEnd2, shift2: integer; docharacters: boolean);	procedure AddFootText (Cell: point);	procedure AttachPicHandleToFoot (theFoot: Integer; Cell: point; H: univ Handle);	procedure LoadAndAttachPicResourceToFoot (theFoot: Integer; it,ic,resID: integer);	procedure AddFootPictFromFile (pictFS: FSSpec; Cell: point);	procedure DestroyFoot (theFoot, it, ic: integer);	procedure DestroyFeet (theFoot, theStart, theEnd: integer; docharacters: boolean);	procedure RemoveFeetSelected (theFoot: integer);{$IFC FOOTSOUNDS}	procedure PlayFootSound (it, ic: integer);{$ENDC}	function PICTbox: rect;	function FootCellTitle (it, ic: integer): str255;	procedure FillnoteTE;	procedure ShrinkWrapPICT;		function GetFootPict (it, ic: integer): boolean;	procedure ShowFootPict (it, ic, left, top: integer);	procedure DrawFootText (hidePICT, showPICTifPresent: boolean);	procedure HiliteFootNote (turnOn: boolean);	procedure ClosePictWindow;	procedure InitFootPicturesPtr(theFootPicture: FootPicturesPtr);	procedure WriteFootResource (theFoot: Integer; localID: integer; var resID: integer);	procedure EmptyFootPicts;	procedure DestroyFootPicts;{ееееееееееееееееееееее}implementation {е$S Footnote}{Footnote storage.  Footnote information is stored in two places.}{  1. in footH Handles}{  2. bits in taxon and characters storages indicating just whether or not cells have footnotes}{footH Handle structure.  all foot handles consist of a linear chain of footnotes.  }{Each element in the chain consists of 4 leading bytes, followed by the footnote itself.}{Of the leading 4 bytes, the first two are the taxon number, the next two are the character}{number.  }{The footnote itself consists of footBytes[theFoot] bytes.  for Sound and Pict feet, this equals}{4, and is a longint whose value is that of the resource id.  }{for text feet, this equals variableFeet, indicating that the footnote is of variable length.  in}{this case, the actual length of the footnote is given in the first two bytes (this length does}{not include the two bytes themselves).  Therefore the total space occupied by 1 element  in footH}{is 8 for footPict and footSound and 6+footlength (+padding) for footText}{}{one element for FootSound and FootPict has the following structure:}{-- -- ----}{}{one element for FootText has the following structure:}{-- -- -- ----------}{}{all position references in footH are 0-based.  Thus curpos = 6 is the 7th byte}{Note For notes with variable length, each note is padded so that it always consists of an }{even number of bytes}{-----------------------------------------------------------------------------}	function GetFootPicturesPtrFromID(id: integer): FootPicturesPtr;	var theFootPicture: FootPicturesPtr;		j : integer;	begin		GetFootPicturesPtrFromID := nil;		theFootPicture := footPictures;		while theFootPicture<> nil do			begin				if theFootPicture^.id= id then					begin						GetFootPicturesPtrFromID := theFootPicture;						leave;					end				else					theFootPicture:= theFootPicture^.next;			end;	end;{-----------------------------------------------------------------------------}	function GetFootPicturesPtr(footPictNumber: integer): FootPicturesPtr;	var theFootPicture: FootPicturesPtr;		j : integer;	begin		if footPictNumber<=0 then			theFootPicture :=nil		else			begin				theFootPicture := footPictures;				if footPictNumber>1 then					for j := 1 to footPictNumber-1 do						if theFootPicture <> nil then							theFootPicture := theFootPicture^.next;			end;		GetFootPicturesPtr := theFootPicture;	end;{-----------------------------------------------------------------------------}	procedure InitFootPicturesPtr(theFootPicture: FootPicturesPtr);	begin		if theFootPicture <> nil then			with theFootPicture^ do				begin					prev:= nil;					next := nil;					id := 0;					picH := nil;				end;	end;{-----------------------------------------------------------------------------}	function IDAlreadyPresentinFootPicts(id: integer): boolean;	var theFootPicture: FootPicturesPtr;	begin		IDAlreadyPresentinFootPicts:= false;		theFootPicture := FootPictures;		while theFootPicture <> nil do			begin				if theFootPicture^.id=id then					begin						IDAlreadyPresentinFootPicts:= true;						leave;					end;				theFootPicture := theFootPicture^.next;			end;	end;{-----------------------------------------------------------------------------}	procedure AddNewFootPicture(var id: integer; H: univ Handle);	var theFootPicture: FootPicturesPtr;	begin		theFootPicture := FootPictures;		if theFootPicture <> nil then			while theFootPicture^.next <> nil do				begin					theFootPicture := theFootPicture^.next;				end;		theFootPicture^.next := FootPicturesPtr(NewPtrClear(SizeOf(FootPicturesRecord)));		InitFootPicturesPtr(theFootPicture^.next);				id := 1;		while IDAlreadyPresentinFootPicts(id) do			id := id+1;		theFootPicture^.next^.id := id;		theFootPicture^.next^.picH := PicHandle(NewHandle(0));			CopyHandles(H, Handle(theFootPicture^.next^.picH));					theFootPicture^.next^.prev := theFootPicture;		numFootPicts:= numFootPicts+1;		InvalidateTool (editorTools, showPictureT);		InvalidateTool (treeTools, treePictureT);	end;{-----------------------------------------------------------------------------}	procedure DestroyFootPicturesPtr(theFootPicture: FootPicturesPtr);	begin		if (theFootPicture = footPictures) then			begin				if  (numFootPicts>1) then					begin						footPictures := theFootPicture^.next;						footPictures^.prev := nil;						numFootPicts:= numFootPicts-1;						ZapHandle(theFootPicture^.picH);						ZapPointer(theFootPicture);					end				else					begin						InitFootPicturesPtr(theFootPicture);					end;			end		else if theFootPicture <> nil then			begin				if theFootPicture^.next <> nil then					theFootPicture^.next^.prev := theFootPicture^.prev;				if theFootPicture^.prev <> nil then					theFootPicture^.prev^.next := theFootPicture^.next;				numFootPicts:= numFootPicts-1;				ZapHandle(theFootPicture^.picH);				ZapPointer(theFootPicture);			end;		InvalidateTool (editorTools, showPictureT);		InvalidateTool (treeTools, treePictureT);	end;{-----------------------------------------------------------------------------}	procedure DestroyFootPicture(footPictNumber: integer);	var theFootPicture: FootPicturesPtr;	begin		theFootPicture := GetFootPicturesPtr(footPictNumber);		DestroyFootPicturesPtr(theFootPicture);	end;{|||||||||||||||||||||||||||||||||||||  Getting Feet  |||||||||||||||||||||||||||||||||||||||}{----------------------------------------------------------------------------}	procedure GetFootTaxChar (var it, ic: integer; startFootP, curPos: longint);{for handle footH, whose master pointer is startfootP, this returns the number of taxa and characters}{at memory location curpos}	begin		it := IP(startFootP + curPos)^;		ic := IP(startfootP + curPos + 2)^;	end;{----------------------------------------------------------------------------}	function GetFootPosition (theFoot, it, ic: integer; var startpos, endpos: longint; var padded: boolean): boolean;{returns the starting and ending positions of the foot for it,ic in foothandle footH[theFoot]}{note that endpos is the end of the string or longint, and does not take any padding into account}{if padding is present then returns true in padded}{function returns true iff foot it,ic, is found}		var			ft, startfootP, curPos: longint;			oldstate: SignedByte;			footP: IP;			footlength: integer;			curit, curic: integer;	begin		GetFootPosition := false;		if AnyFeet(theFoot) then			begin				LockHandle(footH[theFoot], oldState);				startfootP := GetMaster(footH[theFoot]);				curPos := 0;				padded := false;				for ft := 1 to numfeet[theFoot] do					begin						if footBytes[theFoot] = variableFeet then							footlength := IP(startfootP + curPos + 4)^ + 2   {+2 for the 2 length bytes themselves}						else							footlength := footBytes[theFoot];						GetFootTaxChar(curit, curic, startfootP, curPos);						if (curit = it) & (curic = ic) then  {we have found it}							begin								padded := odd(footlength);								startpos := curpos;								endpos := curpos + 4 + footlength;								GetFootPosition := true;								leave;							end						else							begin								curPos := curpos + 4 + footlength;								if odd(footlength) then									curPos := curPos + 1;							end;					end;				ResetHandle(footH[theFoot], oldState);			end;	end;{----------------------------------------------------------------------------}	function GetFootString (theFoot, it, ic: integer; var ds: str255): boolean;{returns true if finds foot it,ic}{returns in ds the string associated with foot it,ic}		var			padded: boolean;			startpos, endpos: longint;	begin		if GetFootPosition(theFoot, it, ic, startpos, endpos, padded) then			begin				if endpos - startpos > 260 then   {255 + 6-1 for safety}					endpos := startpos + 260;				ds := StringFromHandle(footH[theFoot], startpos + 6, endpos);  {6 as need to avoid starting bytes of element}				GetFootString := true;			end		else			begin				ds := '';				GetFootString := false;			end;	end;{----------------------------------------------------------------------------}	function GetFootLongint (theFoot, it, ic: integer; var dL: longint): boolean;{returns true if finds foot it,ic}{returns in dL longint associated with foot it,ic  - for picts and sounds, = resource id}		var			padded: boolean;			startpos, endpos: longint;	begin		if GetFootPosition(theFoot, it, ic, startpos, endpos, padded) then			begin				dL := LIP(GetMaster(footH[theFoot]) + startpos + 4)^;				GetFootLongint := true;			end		else			begin				dL := 0;				GetFootLongint := false;			end;	end;{|||||||||||||||||||||||||||||||||||||  Setting Feet  |||||||||||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	procedure AdjustNoteBlockWillWrites;	var theNexusBlock: NexusBlockPtr;	begin		theNexusBlock := NexusBlockFromBlockType(notesBlock);		if theNexusBlock <> nil then			theNexusBlock^.willWriteBlock := ShouldWriteNexusBlock(notesBlock);		if infoOpen[nexusblockinfo] then			invalidateWindow(infoWindow[nexusblockinfo], true);	end;{----------------------------------------------------------------------------}	procedure SetFootTaxChar (theFoot, it, ic: integer; startPos: longint);{sets the taxon number and character number bytes for footH theFoot, at position startPos}{startPos 0-based}		var			oldState: SignedByte;			footP: IP;	begin		LockHandle(footH[theFoot], oldState);		footP := IP(GetMaster(footH[theFoot]) + startPos);		footP^ := it;		footP := IP(ord4(footP) + 2);		footP^ := ic;		ResetHandle(footH[theFoot], oldState);	end;{----------------------------------------------------------------------------}	procedure SetFootString (theFoot, it, ic: integer; ds: str255);		var			padded: boolean;			startpos, endpos: longint;			stringlength, dL: longint;			oldState: SignedByte;			oddString: boolean;			footP: IP;	begin		if (ds = '') and AnyFeet(theFoot) then			DestroyFoot(theFoot, it, ic)		else			begin				UnlockHandle(footH[theFoot], oldState);				stringlength := length(ds);				oddString := odd(stringlength);				if oddString then					stringlength := stringlength + 1;				if GetFootPosition(theFoot, it, ic, startpos, endpos, padded) then  {already there}					begin						if padded then							endpos := endpos + 1;						dL := Munger(footH[theFoot], startpos + 6, nil, endpos - startpos - 6, Ptr(ord4(@ds) + 1), stringlength);					end				else					begin						if not AnyFeet(theFoot) then							startpos := 0						else							startpos := GetHandleSize(footH[theFoot]);						SetHandleSize(footH[theFoot], startpos + 6);						AppendToHandle(footH[theFoot], ds);						if odd(GetHandleSize(footH[theFoot])) then							AppendToHandle(footH[theFoot], ' ');  {pad it}						numfeet[theFoot] := numfeet[theFoot] + 1;					end;				SetFootTaxChar(theFoot, it, ic, startPos);				footP := IP(GetMaster(footH[theFoot]) + startPos + 4);				footP^ := length(ds);				SetFootBits(theFoot, it, ic, true);				dirtyfile := true;				ResetHandle(footH[theFoot], oldState);			end;		AdjustNoteBlockWillWrites;	end;{----------------------------------------------------------------------------}	procedure SetFootLongint (theFoot, it, ic: integer; dL: longint);		var			padded: boolean;			startpos, endpos: longint;			oldState: SignedByte;			footLP: LIP;	begin		if (dL = 0) and AnyFeet(theFoot) then			DestroyFoot(theFoot, it, ic)		else			begin				UnlockHandle(footH[theFoot], oldState);				if not GetFootPosition(theFoot, it, ic, startpos, endpos, padded) then  {its not already there}					begin						if AnyFeet(theFoot) then							startpos := GetHandleSize(footH[theFoot])						else							startpos := 0;						SetHandleSize(footH[theFoot], startpos + 8);						numfeet[theFoot] := numfeet[theFoot] + 1;					end;				footLP := LIP(GetMaster(footH[theFoot]) + startPos + 4);				footLP^ := dL;				SetFootTaxChar(theFoot, it, ic, startPos);				SetFootBits(theFoot, it, ic, true);				dirtyfile := true;				ResetHandle(footH[theFoot], oldState);			end;		AdjustNoteBlockWillWrites;	end;{----------------------------------------------------------------------------}	procedure AddFootText (Cell: point);{store the contents of noteTE as a FootText for Cell}		var			note, oldnote: str255;			it, ic: integer;			wasnote: boolean;	begin		it := TaxonofCell(Cell);		ic := CharOfCell(Cell);		GetDialogItemText(noteTE^^.hText, note);		Stripblanks(note);		if note = ' ' then			note := '';		wasnote := GetFootString(footText, it, ic, oldnote);		if (oldnote <> note) then			SetFootString(footText, it, ic, note);	end;{----------------------------------------------------------------------------}	function ResExists (theType: restype; ID: integer): boolean;	begin		SetResLoad(FALSE);		ResExists := (GetResource(theType, ID) <> nil) & (ResError = noErr);		SetResLoad(TRUE);	end;{----------------------------------------------------------------------------}	function NewResID (theType: restype): integer;		var			ID: integer;	begin		ID := 127;		repeat			ID := ID + 1;		until not ResExists(theType, ID);		NewResID := ID;	end;{----------------------------------------------------------------------------}	procedure WriteFootResource (theFoot: Integer; localID: integer; var resID: integer);		var			resH: Handle;			theFootPicture: FootPicturesPtr;			H: Handle;			resFileNum: integer;			db: boolean;	begin		theFootPicture := GetFootPicturesPtrFromID(localID);		if theFootPicture= nil then Exit(WriteFootResource);		H := Handle(theFootPicture^.picH);				currentioposition := 92;		if errorFlag then			Exit(WriteFootResource);		if FSpCreateResourceFork(FDI^[writeFileFDI].fs,'CLAD','TEXT') then			begin				resFileNum := FSpOpenResFile(FDI^[writeFileFDI].fs, fsRdWrPerm);				if (resFileNum = -1) | not OSSuccessful(ResError) then					NewError(104, 0)				else					begin						resID := NewResID(footResType[theFoot]);						resH := NewHandle(0);						CopyHandles(H, resH);						AddResource(resH, footResType[theFoot], resID, '');						if (ResError = NoErr) then							begin								ChangedResource(resH);								UpdateResFile(resFileNum);								ReleaseResource(resH);							end						else							begin								errorFlag := true;								ZapHandle(resH);    {ok to use this as resH never added to resource map}								NewError(104, 0);							end;						CloseResFile(resFileNum);						if OSSuccessful(ResError) then							db := IOSuccessful(FlushVol(nil,FDI^[writeFileFDI].fs.vRefNum));					end;			end;		currentioposition := 112;	end;{----------------------------------------------------------------------------}	procedure AttachPicHandleToTaxonCharacter (theFoot, it,ic: Integer;  H: univ Handle);		var			resH: Handle;			localID: integer;	begin		AddNewFootPicture(localID,H);		SetFootLongint(theFoot, it, ic, localID);		currentioposition := 112;	end;{----------------------------------------------------------------------------}	procedure AttachPicHandleToFoot (theFoot: Integer; Cell: point; H: univ Handle);		var			it, ic: integer;	begin		it := TaxonofCell(Cell);		ic := CharOfCell(Cell);		if (it <= numtaxa) and (ic <= numchars) then			AttachPicHandleToTaxonCharacter(theFoot,it,ic,H);		if editorOpen then CheckToolKit(editorTools, showPictureT);	end;{-----------------------------------------------------------------------------}	procedure LoadAndAttachPicResourceToFoot (theFoot: Integer; it,ic,resID: integer);	var 	H: Handle;		oldRefNum, theResult: integer;		resFileNum: integer;		db: boolean;	begin		oldRefNum := CurResFile;		resFileNum := FSpOpenResFile(FDI^[readFileFDI].fs, fsRdWrPerm);		if  (ResError=noErr) & (resFileNum<> -1) then   			begin				UseResFile(resFileNum);				if ResError=noErr then					begin						H := Get1Resource('PICT', resID);						if (ResError = noErr) and (H <> nil) then							begin								AttachPicHandleToTaxonCharacter(theFoot,it,ic,H);								DetachResource(H);  							end;					end;				CloseResFile(resFileNum);				if OSSuccessful(ResError) then					db := IOSuccessful(FlushVol(nil,FDI^[readFileFDI].fs.vRefNum));			end;		UseResFile(oldRefNum);	end;{-----------------------------------------------------------------------------}	procedure DisplayPict (it, ic: integer; makefront: boolean);{displays the pict by setting up the window and invalidating it}		var			tempP: windowPtr;	begin		genericGetPort(tempP);		SetWTitle(pictWindow, FootCellTitle(it, ic));		ShrinkWrapPict;		picton := true;		ShowWindow(pictWindow);		InvalidateWindow(pictwindow, true);		if makefront then			SelectWindow(pictWindow);		genericSetPort(tempP);	end;{----------------------------------------------------------------------------}	procedure AddFootPictFromFile (pictFS: FSSpec; Cell: point);{read in and attach PICT from PICT file}		var			it, ic: integer;	begin		it := TaxonofCell(Cell);		ic := CharOfCell(Cell);		if (it <= numtaxa) and (ic <= numchars) then			begin				if grabpicture <> nil then					KillPicture(grabpicture);				grabpicture := nil;				GetPICT(pictFS, grabpicture);				DisplayPICT(it, ic, true);				AttachPicHandleToFoot(footPict, cell, grabpicture);			end;	end;{|||||||||||||||||||||||||||||||||||||  Removing Feet  |||||||||||||||||||||||||||||||||||||||}{----------------------------------------------------------------------------}	procedure RemoveFootPicture (theFoot, localID: integer);	var theFootPicture: FootPicturesPtr;{does NOT set any of the foot bits or remove the footH[thefoot] element}	begin		theFootPicture := GetFootPicturesPtrFromID(localID);		if theFootPicture <> nil  then			DestroyFootPicturesPtr(theFootPicture);		currentioposition := 113;	end;{----------------------------------------------------------------------------}	procedure DestroyFoot (theFoot, it, ic: integer);		var			padded: boolean;			startpos, endpos, dL: longint;			oldState: SignedByte;	begin		if GetFootPosition(theFoot, it, ic, startpos, endpos, padded) then  {its  already there}			begin				UnlockHandle(footH[theFoot], oldState);				if padded then					endpos := endpos + 1;				if footResource[theFoot] then  {is resource}					RemoveFootPicture(theFoot, LIP(startpos + 4)^);				DeletePieceOfHandle(footH[theFoot], startpos, endpos - startpos);				ResetHandle(footH[theFoot], oldState);				numfeet[theFoot] := numfeet[theFoot] - 1;				if editorOpen & (theFoot=footPict) then CheckToolKit(editorTools, showPictureT);			end;		SetFootBits(theFoot, it, ic, false);		AdjustNoteBlockWillWrites;		dirtyfile := true;		FixPrintOtherMenu;	end;{----------------------------------------------------------------------------}	procedure DestroyFeet (theFoot, theStart, theEnd: integer; docharacters: boolean);{if docharacters, then destroy feet for all characters TheStart to TheEnd inclusive,}{if not docharacters, then destroy feet for all taxa TheStart to TheEnd inclusive}{this destroys the feet in the the handle footH, as well as the resources}{for footpicts and footsounds. Note, however, that it does NOT clear the foot booleans in charHdl and taxonHdl and}{in the taxstsHdls. DestroyFeet is to be used when the characters (and thus their SetChars}{and charHdl) are begin destroyed anyway}		var			nextPos: longint;			dL, ft, startfootP, curPos: longint;			oldstate: SignedByte;			curit, curic: integer;			footP: IP;			footlength, theMatch: integer;	begin		if AnyFeet(theFoot) then			begin				LockHandle(footH[theFoot], oldState);				startfootP := GetMaster(footH[theFoot]);				curPos := 0;				for ft := 1 to numfeet[theFoot] do					begin						if footBytes[theFoot] = variableFeet then							footlength := IP(startfootP + curPos + 4)^ + 2   {2 for the 2 length bytes}						else							footlength := footBytes[theFoot];						if odd(footlength) then							footlength := footlength + 1;						nextPos := curpos + 4 + footlength;						GetFootTaxChar(curit, curic, startfootP, curPos);						if docharacters then							theMatch := curic						else							theMatch := curit;						if (theMatch >= theStart) & (theMatch <= theEnd) then  {destroy it; note: don't use Destroy Foot as too slow}							begin								HUnLock(footH[theFoot]);								if footResource[theFoot] then  {is resource}									RemoveFootPicture(theFoot, LIP(curpos + 4)^);								DeletePieceOfHandle(footH[theFoot], curpos, nextPos - curpos);								numfeet[theFoot] := numfeet[theFoot] - 1;							end						else							curPos := nextPos;					end;				ResetHandle(footH[theFoot], oldState);			end;		FixPrintOtherMenu;	end;{----------------------------------------------------------------------------}	procedure ShiftFeet (theFoot, theStart1, theEnd1, shift1, theStart2, theEnd2, shift2: integer; docharacters: boolean);{moves feet theStart to TheEnd up or down shift}{note that one when one is moving a block of characters or taxa, then one has to do two sets of shifts:}{one to shift the block of characters moved, and another to shift the footnotes in the characters}{displaced by the move.  .}		var			ft, startfootP, nextpos, curPos: longint;			oldstate: SignedByte;			footP: IP;			curic, curit: integer;			theShift, footlength, curValue: integer;	begin		if AnyFeet(theFoot) then			begin				LockHandle(footH[theFoot], oldState);				startfootP := GetMaster(footH[theFoot]);				curPos := 0;				for ft := 1 to numfeet[theFoot] do					begin						if footBytes[theFoot] = variableFeet then							footlength := IP(startfootP + curPos + 4)^ + 2   {2 for the 2 length bytes}						else							footlength := footBytes[theFoot];						if odd(footlength) then							footlength := footlength + 1;						nextPos := curpos + 4 + footlength;						GetFootTaxChar(curit, curic, startfootP, curPos);						if docharacters then							curValue := curic						else							curValue := curit;						if (curValue >= theStart1) & (curValue <= theEnd1) then							theShift := shift1						else if (curValue >= theStart2) & (curValue <= theEnd2) then							theShift := shift2						else							theShift := 0;						if theShift <> 0 then							begin								HUnLock(footH[theFoot]);								if docharacters then									SetFootTaxChar(theFoot, curit, curValue + theShift, curpos)								else									SetFootTaxChar(theFoot, curValue + theShift, curic, curpos);							end;						curPos := nextPos;					end;				ResetHandle(footH[theFoot], oldState);			end;		FixPrintOtherMenu;	end;{----------------------------------------------------------------------------}	procedure RemoveFeetBlock (theFoot, itstart, itend, icstart, icend: integer);		var			it, ic: integer;	begin		for it := itstart to itend do			for ic := icstart to icend do				if AnyFeet(theFoot) then					DestroyFoot(theFoot, it, ic)				else					Exit(RemoveFeetBlock);	end;{----------------------------------------------------------------------------}	procedure RemoveFeetSelected (theFoot: Integer);		var			tport: WindowPtr;	begin		RemoveFeetBlock(theFoot, TaxonofCell(editorSelectionTopLeft), TaxonofCell(editorSelectionBotRight), CharOfCell(editorSelectionTopLeft), CharOfCell(editorSelectionBotRight));		if editorOpen then			begin				genericGetPort(tport);				genericSetPort(editorWindow);				EraseRect(editorSelectionRect);				InvalidateWindowRect(editorWindow,editorSelectionRect,false);				genericSetPort(tport);			end;	end;{|||||||||||||||||||||||||||||||||||||  Displaying Feet  |||||||||||||||||||||||||||||||||||||||}{$IFC FOOTSOUNDS}{----------------------------------------------------------------------------}	procedure PlayFootSound (it, ic: integer);		const			kAsync = TRUE;		var			sndH: Handle;			os: OSErr;			id: integer;			 refnum: integer;	begin		if hasSndPlay then			begin				currentioposition := 94;				if GetFootLongint(footSoundH, it, ic, id) then  {temporary file failed - let's try in original file}					begin						sndH := GetResource('snd ', id);						if sndH <> nil then							os := SndPlay(nil, sndH, kAsync);						if ResError = noErr then							begin								ReleaseResource(sndH);								if not PictResFileExists then   {we just want to close data file right away}									begin										// CloseResFile(refnum);									end;							end;					end;			end;	end;{$ENDC}{----------------------------------------------------------------------------}	procedure FillnoteTE;{fills noteTE with the FootText for the selected cell}		var			it, ic: integer;			ds: str255;	begin		it := TaxonofCell(editorSelectionTopLeft);		ic := CharOfCell(editorSelectionTopLeft);		if not (SingleCell & editorSelected & footpresent(it, ic) & GetFootString(footText, it, ic, ds)) then			ds := '';		TESetText(Pointer(ORD4(@ds) + 1), ORD4(length(ds)), noteTE);		TESetAlignment(teJustLeft, noteTE);	end;{|||||||||||||||||||||||||||||||||||||  Drawing footpicts  |||||||||||||||||||||||||||||||||||||||}{----------------------------------------------------------------------------}	function PICTbox;{returns the size of the rectangle into which the pict will be drawn}		var			box: rect;			W, H, boxW, boxH: integer;	begin		box := grabpicture^^.picframe;		Offsetrect(box, -box.left, -box.top);		box.right := box.right + scrollwidth;		box.bottom := box.bottom + scrollwidth;		W := (ScreenRectangle.right - ScreenRectangle.left - 10);		boxW := box.right - box.left;		boxW := IntegerMin(boxW, W);		boxW := IntegerMax(boxW, 60);		box.right := box.left + boxW;		H := (ScreenRectangle.bottom - ScreenRectangle.top - 44);		boxH := box.bottom - box.top;		boxH := IntegerMin(boxH, H);		boxH := IntegerMax(boxH, 60);		box.bottom := box.top + boxH;		PICTbox := box;	end;{----------------------------------------------------------------------------}	procedure ShrinkWrapPICT;{sizes pictwindow to shrinkwrap around picture rectangle}	begin		with PICTbox do			SizeWindow(pictWindow, right - left, bottom - top, TRUE);	end;{-----------------------------------------------------------------------------}	function FootCellTitle (it, ic: integer): str255;{returns a string for the cell it,ic, for use in labelling feet}	begin		if (it > 0) and (ic > 0) then			FootCellTitle := concat(AvailTaxonName(it), ', ', AvailCharName(ic))  {v3.01: colon changed to comma}		else if (it = 0) then			FootCellTitle := AvailCharName(ic)		else if (ic = 0) then			FootCellTitle := AvailTaxonName(it);	end;{-----------------------------------------------------------------------------}	procedure BlankFootPICT;		var			box: rect;	begin		if grabpicture <> nil then			KillPicture(grabpicture);		grabpicture := nil;		SetRect(box, 0, 0, 150, 150);		grabpicture := OpenNewPicture(box);		InsetRect(box, 10, 10);		FrameRect(box);		MoveTo(30, 78);		DrawString('Sorry, picture');		MoveTo(30, 90);		DrawString('unavailable.');		ClosePicture;	end;{-----------------------------------------------------------------------------}	function GetFootPict (it, ic: integer): boolean;		var			theResult: integer;			tempP: WindowPtr;			refnum,oldRefNum: integer;			theID: longint;			oldstate: SignedByte;			theFootPicture: FootPicturesPtr;	begin		GetFootPict := false;		if GetFootLongint(footPict, it, ic, theID) then  {there exists a footpict for that cell}			begin				theResult := 0;				if grabpicture <> nil then					KillPicture(grabpicture);				grabpicture := nil;				currentioposition := 95;				if errorflag then					Exit(GetFootPict);				theFootPicture := GetFootPicturesPtrFromID(theID);											if (theFootPicture <> nil) & (theFootPicture^.picH <> nil) then					begin						grabpicture := PicHandle(NewHandle(0));						CopyHandles(Handle(theFootPicture^.picH),Handle(grabpicture));						GetFootPict := grabpicture <> nil;					end;			end;	end;{-----------------------------------------------------------------------------}	procedure ShowFootPict (it, ic, left, top: integer);{this procedure gets the PICT resource for the it taxon and ic character,}{and either draws it for printing or draws it into the pictwindow, selecting the pictwindow}{if necessary}{left and top are only used if printing}	var		oldstate: SignedByte;		box: rect;	begin		if GetFootPict(it, ic) then  {there exists a footpict for that cell}			begin				if grabpicture <> nil then					if printon then						begin							LockHandle(grabPicture, oldstate);							box := grabpicture^^.picframe;							OffSetRect(box, left-box.left,top-box.top);							DrawPicture(grabpicture, box);							ResetHandle(grabPicture, oldstate);						end					else						DisplayPict(it, ic, not WindowinView(pictwindow));				{UseResFile(oldRefNum);}				currentioposition := 115;			end		else			ClosePictWindow;	end;{----------------------------------------------------------------------------}	procedure mySetHiliteMode;	begin{$IFC CARBON}			LMSetHiliteMode(hiliteBit);{$ELSEC}			BitClr(Ptr($938), pHiliteBit);{$ENDC}	end;{----------------------------------------------------------------------------}	procedure HiliteFootNote (turnOn: boolean);		var			notePoly: PolyHandle;			box: rect;			oldRgn: RgnHandle;	begin		oldRgn := NewRgn;		GetClip(oldRgn);		box := editorFootNoteRect;		InsetRect(box, -1, 0);		ClipRect(box);		PenSize(1, 1);		if turnon then			begin				mySetHiliteMode;  {v4: use HiliteMode constant}				PenMode(srcXor);			end		else			begin{Forecolor(whitecolor);}				PenMode(SrcBic);{not}			end;		MoveTo(editorFootNoteRect.left, editorFootNoteRect.top + 5);		Line(5, 0);		Move(0, -1);		if turnon then			mySetHiliteMode;		Line(0, -4);		Move(1, 0);		if turnon then			mySetHiliteMode;		LineTo(editorFootNoteRect.right, editorFootNoteRect.top);		Move(0, 1);		if turnon then			mySetHiliteMode;		LineTo(editorFootNoteRect.right, editorFootNoteRect.bottom - 1);		Move(-1, 0);		if turnon then			mySetHiliteMode;		LineTo(editorFootNoteRect.left - 1, editorFootNoteRect.bottom - 1);		Move(0, -1);		if turnon then			mySetHiliteMode;		LineTo(editorFootNoteRect.left - 1, editorFootNoteRect.top + 5);		PenNormal;		Forecolor(blackColor);		SetClip(oldRgn);		ZapRegion(oldRgn);	end;{----------------------------------------------------------------------------}	procedure FrameFootNote;		var			cornerPoly: PolyHandle;	begin		PenSize(1, 1);{==== Drawing Corner =====}		cornerPoly := OpenPoly;		MoveTo(editorFootNoteRect.left - 1, editorFootNoteRect.top + 4);		LineTo(editorFootNoteRect.left + 4, editorFootNoteRect.top - 1);		Line(0, 5);		Line(-5, 0);		ClosePoly;		FramePoly(cornerPoly);		KillPoly(cornerPoly);		MoveTo(editorFootNoteRect.left + 4, editorFootNoteRect.top - 1);		LineTo(editorFootNoteRect.right, editorFootNoteRect.top - 1);		HiliteFootNote(false);		if footediting then			HiliteFootNote(true);	end;{----------------------------------------------------------------------------}	procedure DrawFootText (hidePICT, showPICTifPresent: boolean);{draws the footnote}		var			ic, ir: integer;			ds: str255;			H: Handle;			box, trect: rect;			oldClip: RgnHandle;			tport: WindowPtr;	begin		oldClip := NewRgn;		genericGetPort(tport);		genericSetPort(editorWindow);		GetClip(OldClip);		ClipRect(WindowPortRect(editorWindow));		FrameFootNote;		if hidepict then			ClosePictWindow;{===== FOOTNOTES =====}		if SingleCell & editorSelected & foottexton then {& DataCellVisible(currentDataP,editorSelectionTopLeft, editorSelectionBotRight)}			begin				trect := noteTE^^.destrect;				Eraserect(trect);				TEUpdate(trect, noteTE);			end{===== FOOTSTATES =====}		else if (not foottexton) & editorSelected & (CharOfCell(editorSelectionTopLeft) > 0) & ((not editorTransposed & (editorSelectionTopLeft.h = editorSelectionBotRight.h)) | (editorTransposed & (editorSelectionTopLeft.v = editorSelectionBotRight.v))) then {DataCellVisible(currentDataP,editorSelectionTopLeft, editorSelectionBotRight) &}			begin				if nucleotides then					begin						ds := 'B: C/G/T  D: A/G/T  H:A/C/T  K:G/T  M:A/C  N:?  R:A/G  S:C/G  V:A/C/G  W:A/T  X:?  Y:C/T';						if orsep <> '/' then  {switch it so string displays custom OR separator}							begin								if orsep = ':' then   {just in case orsep is colon, replace colons with periods}									for ir := 1 to length(ds) do										if ds[ir] = ':' then											ds[ir] := '.';								for ir := 1 to length(ds) do  {now adjust OR separators}									if ds[ir] = '/' then										ds[ir] := orsep;							end;						trect := noteTE^^.destrect;						ClipRect(trect);						Eraserect(trect);						TETextBox(Pointer(ord4(@ds) + 1), length(ds), trect, teJustleft);					end				else					begin						H := NewHandle(0);						ic := CharOfCell(editorSelectionTopLeft);						CHUNKpos := 0;						ds := getnextstateName(ic);						ir := 0;						while (ds <> EndNames) & (ir<=absmaxstate) do							begin								if ds <> NoName then									begin										UnderLinetoBlanks(ds);										AppendToHandle(H, concat(' ', CharOfNum(ir), ': ', ds, '  '));									end;								ds := getnextstateName(ic);								ir := ir + 1;							end;						trect := noteTE^^.destrect;						ClipRect(trect);						Eraserect(trect);						HLock(H);						TETextBox(Pointer(GetMaster(H)), GetHandleSize(H), trect, teJustleft);						HUnlock(H);						ZapHandle(H);					end			end		else			begin				trect := noteTE^^.destrect;				Eraserect(trect);			end;		SetClip(OldClip);		ZapRegion(oldClip);		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	procedure ClosePictWindow;	begin		if WindowVisible(pictWindow) then			begin				HideWindow(pictwindow);				picton := false;				if grabpicture <> nil then					KillPicture(grabpicture);				grabpicture := nil;			end;	end;{-----------------------------------------------------------------------------}	procedure EmptyFootPicts;	var theFootPicture, nextFootPicture: FootPicturesPtr;	begin		theFootPicture := footPictures;		if theFootPicture <> nil then			begin				theFootPicture := theFootPicture^.next;				while theFootPicture<> nil do					begin						nextFootPicture := theFootPicture^.next;						DestroyFootPicturesPtr(theFootPicture);						theFootPicture:= nextFootPicture;					end;			end;	end;{-----------------------------------------------------------------------------}	procedure DestroyFootPicts;	begin		EmptyFootPicts;		{ZapHandle(footPictures^.picH);}		ZapPointer(FootPictures);  	end;{-----------------------------------------------------------------------------}end.