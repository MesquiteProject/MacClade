unit MenuUtil;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, 		Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, 		ErrorUtil, EventUtil, GenUtil, StrUtil, TaxonCHUtil, Prohibitions,ChartWUtil;		procedure ReplaceDisplayMenu(var newMHdl: MenuHandle; newMenu: integer);	procedure ReturnComplexDisplayMenu;	procedure ReturnGDisplayMenu;	procedure InsertSubMenus(theMBar: Handle);	procedure AppendLiteralMenuItem(theMenuHdl: MenuHandle; ds: str255);    	procedure DisableSubMenuIfEmpty(theMenuHandle,theSubMenuHandle: MenuHandle; theMenuItem: integer);	procedure EnableDisableSubmenus(theMHdl: MenuHandle);    	procedure EnableDisableAllSubmenus;   	procedure AddSubmenu(theMenuHandle,theSubMenuHandle: MenuHandle; theMenuItem, theSubMenuID: integer);   	procedure SwitchSubmenus(theMenuHandle: MenuHandle; theMenuItem, theSubMenuID: integer);	procedure CheckFlashMenu;	procedure CheckColorCellsMenu;	procedure RebuildWindowsMenu;	procedure CheckSelectMode;	procedure CheckShowMenu (theWindow: WindowPtr);	procedure RebuildShowMenu (theWindow: WindowPtr);	procedure CheckColumnWidthMenu;		procedure SetPrintExtraItem(theWindow: WindowPtr);	procedure FixGoToMenu;	procedure FixTextMenus;	procedure FixTreeShadingMenus;		procedure FixChangeAllSubmenuName(showSelected: boolean);	procedure FixCopyPasteMenuItems;	procedure FixEditMenu;	procedure FixSizeMenu (theSizeMHdl: MenuHandle; thesize: integer);	procedure FixStyleMenu (theStyleMHdl: MenuHandle; thestyle: Style);	procedure FixFontMenu (theFontMHdl: MenuHandle; thefont: integer; namecheck: boolean);	procedure FixPrintOtherMenu;	procedure FixTreeUndoItem;	procedure CheckCalcMenu;	procedure FixSelectMenu (whichinfo: integer);	procedure RebuildSelectMenu (whichObject: integer);	procedure ConvertToInfoSelectSubMenu (whichObject: integer);	procedure ConvertToSimpleSelectSubMenu;	procedure FixChartDisplayMenu;	procedure CheckChartViewsMenu;	procedure CheckConsensusTaxSetMenu;	procedure RebuildConsensusTaxSetMenu;	procedure TypesInUseMenu;	procedure FixAssumpMenu;	procedure ReBuildAssumpMenu;	procedure SetStateNamesItem;	procedure OpenFileMenus;	procedure ClosedEditMenus;	procedure OpenTraceMenus;	procedure CloseTraceMenus;	procedure OpenTreeMenus;	procedure ClosedFileMenus;	procedure EnableDisableMenu (theMenu: integer);	procedure EnableDisableAllMenus;	procedure RebuildShadeCharSetMenu;	procedure CheckShadeCharSetMenu;	procedure RebuildColorCodPosMenu;	procedure CheckColorCodPosMenu;	procedure CheckColorCharPartitionMenu;	procedure CheckMismatchMenu;	procedure EnableDisablePrimaryMenus(on: boolean);	procedure SetTWMBar;	procedure SetEWMBar;	procedure SetNoWMBar;	procedure SetCloseFileMBar;	procedure SetChartMBar;	procedure SetEquivMBar;	procedure GetFreshMenuHandles;{еееееееееееееееееееееее}implementation {е$S MenuUtil}{-----------------------------------------------------------------------------}	procedure ReplaceDisplayMenu(var newMHdl: MenuHandle; newMenu: integer);	begin		//newMHdl := GetMenuHandle(newMenu);{		EWDisplayMenu = 262;		GDisplayMenu = 263;		TWDisplayMenu = 264;}		if MenuAvailable(EWDisplayMenu) then			ZapMenu(EWDisplayMenu, newMHdl)		else if MenuAvailable(GDisplayMenu) then			ZapMenu(GDisplayMenu, newMHdl)		else if MenuAvailable(TWDisplayMenu) then			ZapMenu(TWDisplayMenu, newMHdl);		newMHdl := GetMenu(newMenu);		InsertMenu(newMHdl,WindowsMenu);		InsertMenu(ShowMHdl, -1);		InsertMenu(ShowMHdl, -1);	end;{-----------------------------------------------------------------------------}	procedure ReturnComplexDisplayMenu;	begin		if editorOpen then			begin				ReplaceDisplayMenu(EWDisplayMHdl, EWDisplayMenu);				InsertMenu(ConsensusTaxSetMHdl,-1);				RebuildShowMenu(editorWindow);			end		else if treeopen then			if chartwindow=frontWindow then				begin					ReplaceDisplayMenu(ChartDisplayMHdl,ChartDisplayMenu);					RebuildShowMenu(chartWindow);				end			else				begin					ReplaceDisplayMenu(TWDisplayMHdl, TWDisplayMenu);					RebuildShowMenu(treeWindow);				end;	end;{-----------------------------------------------------------------------------}	procedure ReturnGDisplayMenu;	begin{$IFC CARBON}		if editorOpen then			ReplaceDisplayMenu(EWDisplayMHdl, GDisplayMenu)		else if treeopen then			if chartwindow=frontWindow then				ReplaceDisplayMenu(ChartDisplayMHdl,GDisplayMenu)			else				ReplaceDisplayMenu(TWDisplayMHdl, GDisplayMenu);{$ELSEC}		ReplaceDisplayMenu(GDisplayMHdl, GDisplayMenu){$ENDC}	end;{-----------------------------------------------------------------------------}	procedure InsertSubMenus(theMBar: Handle);	begin		if theMBar = EquivMBar then			begin				SetEquivMBar;				InsertMenu(ExpFileMHdl, -1);				InsertMenu(SaveOtherMHdl, -1);				InsertMenu(SaveOptionsMHdl, -1);				InsertMenu(SizeMHdl, -1);				InsertMenu(FontMHdl, -1);				InsertMenu(StyleMHdl, -1);				InsertMenu(dlogSizeMHdl, -1);				InsertMenu(dlogFontMHdl, -1);				InsertMenu(dlogStyleMHdl, -1);				InsertMenu(dlogImportTaxaMHdl, -1);				EquivMBar := GetMenuBar;			end		else if theMBar = NoWMBar then			begin				SetNoWMBar;				InsertMenu(ExpFileMHdl, -1);				InsertMenu(SaveOtherMHdl, -1);				InsertMenu(SaveOptionsMHdl, -1);				InsertMenu(PrintOtherMHdl, -1);				InsertMenu(IncExcMHdl, -1);				InsertMenu(IncExcTaxaMHdl, -1);				InsertMenu(WeightMHdl, -1);				InsertMenu(CharPartMHdl, -1);				InsertMenu(CharPartListMHdl, -1);				InsertMenu(CodingMHdl, -1);				InsertMenu(ShowMHdl, -1);				InsertMenu(FontMHdl, -1);				InsertMenu(SizeMHdl, -1);				InsertMenu(StyleMHdl, -1);				InsertMenu(TaxonListOptionsMHdl,-1);				InsertMenu(CharListOptionsMHdl,-1);				NoWMBar := GetMenuBar;			end		else if theMBar = EWMBar then			begin				SetEWMBar;				InsertMenu(ExpFileMHdl, -1);				InsertMenu(ShadeCharSetMHdl,-1);				InsertMenu(FindMHdl, -1);				InsertMenu(ColumnWidthMHdl, -1);				InsertMenu(SaveOtherMHdl, -1);				InsertMenu(SaveOptionsMHdl, -1);				InsertMenu(PrintOtherMHdl, -1);				InsertMenu(FontMHdl, -1);				InsertMenu(SizeMHdl, -1);				InsertMenu(StyleMHdl, -1);				InsertMenu(CopySpecialMHdl, -1);				InsertMenu(SimpleSelectMHdl, -1);				InsertMenu(IncExcMHdl, -1);				InsertMenu(IncExcTaxaMHdl, -1);				InsertMenu(WeightMHdl, -1);				InsertMenu(CharPartMHdl, -1);				InsertMenu(CharPartListMHdl, -1);				InsertMenu(CodingMHdl, -1);				InsertMenu(ShowMHdl, -1);				InsertMenu(ColorCellsMHdl,-1);				InsertMenu(xxDataFormatMHdl,-1);				InsertMenu(xxCreateCharactersMHdl,-1);				InsertMenu(xxCharacterSetsMHdl,-1);				InsertMenu(xxCreateTaxaMHdl,-1);				InsertMenu(xxImportTaxaMHdl,-1);				InsertMenu(xxTaxonSetsMHdl,-1);				InsertMenu(xxCreateTreesMHdl,-1);				InsertMenu(xxTypeSetsMHdl,-1);				InsertMenu(xxWeightSetsMHdl,-1);				InsertMenu(xxInclusionSetsMHdl,-1);				InsertMenu(NexusBlocksMHdl,-1);				InsertMenu(DataMatrixStyleMHdl,-1);				InsertMenu(ConsensusTaxSetMHdl,-1);				InsertMenu(AATranslateMHdl,-1);				InsertMenu(ReplaceAllMHdl,-1);				InsertMenu(ColorCodPosMHdl,-1);				InsertMenu(ColorCharPartitionMHdl,-1);				InsertMenu(MismatchMHdl,-1);				InsertMenu(TypeMHdl, -1);				InsertMenu(TaxonListOptionsMHdl,-1);				InsertMenu(CharListOptionsMHdl,-1);				InsertMenu(dlogImportTaxaMHdl, -1);				InsertMenu(GoToMHdl,-1);				EWMBar := GetMenuBar;			end		else if theMBar = ChartMBar then			begin				SetChartMBar;				InsertMenu(ExpFileMHdl, -1);				InsertMenu(SizeMHdl, -1);				InsertMenu(FontMHdl, -1);				InsertMenu(NexusBlocksMHdl,-1);				InsertMenu(StyleMHdl, -1);				InsertMenu(SaveOtherMHdl, -1);				InsertMenu(SaveOptionsMHdl, -1);				InsertMenu(PrintOtherMHdl, -1);				InsertMenu(ExpTreeMHdl, -1);				InsertMenu(IncExcMHdl, -1);				InsertMenu(IncExcTaxaMHdl, -1);				InsertMenu(WeightMHdl, -1);				InsertMenu(CharPartMHdl, -1);				InsertMenu(CharPartListMHdl, -1);				InsertMenu(SimpleSelectMHdl, -1);				InsertMenu(CopySpecialMHdl, -1);				InsertMenu(CodingMHdl, -1);				InsertMenu(ShowMHdl, -1);				InsertMenu(ChartViewsMHdl, -1);				InsertMenu(xxCreateCharactersMHdl,-1);				InsertMenu(xxCharacterSetsMHdl,-1);				InsertMenu(xxCreateTaxaMHdl,-1);				InsertMenu(xxImportTaxaMHdl,-1);				InsertMenu(xxTaxonSetsMHdl,-1);				InsertMenu(xxCreateTreesMHdl,-1);				InsertMenu(xxTypeSetsMHdl,-1);				InsertMenu(xxWeightSetsMHdl,-1);				InsertMenu(xxInclusionSetsMHdl,-1);				InsertMenu(TypeMHdl, -1);				InsertMenu(TaxonListOptionsMHdl,-1);				InsertMenu(CharListOptionsMHdl,-1);				InsertMenu(GoToMHdl,-1);				ChartMBar := GetMenuBar;			end		else if theMBar = TWMBar then			begin				SetTWMBar;				InsertMenu(ExpFileMHdl, -1);				InsertMenu(SizeMHdl, -1);				InsertMenu(FontMHdl, -1);				InsertMenu(NexusBlocksMHdl,-1);				InsertMenu(StyleMHdl, -1);				InsertMenu(SaveOtherMHdl, -1);				InsertMenu(SaveOptionsMHdl, -1);				InsertMenu(PrintOtherMHdl, -1);				InsertMenu(ExpTreeMHdl, -1);				InsertMenu(IncExcMHdl, -1);				InsertMenu(IncExcTaxaMHdl, -1);				InsertMenu(WeightMHdl, -1);				InsertMenu(CharPartMHdl, -1);				InsertMenu(CharPartListMHdl, -1);				InsertMenu(SimpleSelectMHdl, -1);				InsertMenu(CopySpecialMHdl, -1);				InsertMenu(CodingMHdl, -1);				InsertMenu(ShowMHdl, -1);				InsertMenu(xxCreateCharactersMHdl,-1);				InsertMenu(xxCharacterSetsMHdl,-1);				InsertMenu(xxCreateTaxaMHdl,-1);				InsertMenu(xxImportTaxaMHdl,-1);				InsertMenu(xxTaxonSetsMHdl,-1);				InsertMenu(xxCreateTreesMHdl,-1);				InsertMenu(xxTypeSetsMHdl,-1);				InsertMenu(xxWeightSetsMHdl,-1);				InsertMenu(xxInclusionSetsMHdl,-1);				InsertMenu(TypeMHdl, -1);				InsertMenu(TaxonListOptionsMHdl,-1);				InsertMenu(CharListOptionsMHdl,-1);				InsertMenu(dlogSizeMHdl, -1);				InsertMenu(dlogFontMHdl, -1);				InsertMenu(dlogStyleMHdl, -1);				InsertMenu(dlogImportTaxaMHdl, -1);				InsertMenu(GoToMHdl,-1);				TWMBar := GetMenuBar;			end;	end;{-----------------------------------------------------------------------------}   	procedure SwitchSubmenus(theMenuHandle: MenuHandle; theMenuItem, theSubMenuID: integer);	begin		SetItemMark(theMenuHandle, theMenuItem, char(theSubMenuID));	end;{----------------------------------------------------------------------------}	procedure AppendLiteralMenuItem(theMenuHdl: MenuHandle; ds: str255);	begin		if ds = '-' then			AppendMenu(theMenuHdl, ' - ')		else			begin				AppendMenu(theMenuHdl, ' ');				SetMenuItemText(theMenuHdl, myCountMenuItems(theMenuHdl), ds);			end;	end;{-----------------------------------------------------------------------------}    procedure DisableSubMenuIfEmpty(theMenuHandle,theSubMenuHandle: MenuHandle; theMenuItem: integer);    begin      if myCountMenuItems(theSubmenuHandle)=0 then      	begin      		if theMenuItem > 0 then myDisableItem(theMenuHandle, theMenuItem);      		myDisableItem(theSubMenuHandle, 0);      	end;	    end;{-----------------------------------------------------------------------------}	procedure EnableDisableSubmenus(theMHdl: MenuHandle);		var j : integer;			cmdChar: char;			menuID: char;			subMHdl: MenuHandle;	begin		for j := 1 to myCountMenuItems(theMHdl) do			begin				GetItemCmd(theMHdl,j,cmdChar);				if (cmdChar = char(27)) then					begin 						GetItemMark(theMHdl,j,menuID);						subMHdl:= GetMenuHandle(ord(menuID));						EnableDisableItem(theMHdl,j, (subMHdl <> nil) & (myCountMenuItems(subMHdl)>0));					end;			end;	end;{-----------------------------------------------------------------------------}	procedure EnableDisableAllSubmenus;	begin		{EnableDisableSubmenus(nxxAnalysisMHdl);}	end;{-----------------------------------------------------------------------------}    procedure AddSubmenu(theMenuHandle,theSubMenuHandle: MenuHandle; theMenuItem, theSubMenuID: integer);    {this adds a submenu to a menu}    begin		{SetItemCmd(theMenuHandle, theMenuItem, char(27));}		SetItemMark(theMenuHandle, theMenuItem, char(theSubMenuID));		{InsertMenu(theSubMenuHandle, -1);		myEnableItem(theSubMenuHandle, 0);}    end;{-----------------------------------------------------------------------------}	procedure FixGoToMenu;	var whichinfo: integer;	begin		EnableDisableItem(GoToMHdl, GoToObjectItem,fileopen);		if fileopen then			if IsInfoWindow(frontWindow) then				begin					whichInfo:= WhichInfoWindow(frontWindow);					SetMenuItemText(GoToMHdl, GoToObjectItem, concat(InfoObjectName[whichinfo],'...'));				end			else if IsTreeWindow(frontWindow) then				SetMenuItemText(GoToMHdl, GoToObjectItem, 'Tree...')			else if IsEditorWindow(frontWindow) then				SetMenuItemText(GoToMHdl, GoToObjectItem, 'Taxon & Character...')			else if frontwindow = stateswindow then				SetMenuItemText(GoToMHdl, GoToObjectItem,'Character...')			else				begin					myDisableItem(GoToMHdl, GoToObjectItem);					SetMenuItemText(GoToMHdl, GoToObjectItem,'Object...');				end;		EnableDisableItem(GoToMHdl, GoToTraceCharacterItem, fileopen & IsTreeWindow(frontwindow) &(traceshown = traceDiscrete));		EnableDisableItem(GoToMHdl, GoToSelection, fileopen & ((IsEditorWindow(frontwindow) & editorselected) | (IsInfoWindow(frontWindow)&infoSomeSelected[WhichInfoWindow(frontWindow)])));	end;{-----------------------------------------------------------------------------}	procedure FixTextMenus;{fixes font menus}	begin		if editorOpen then			begin				EnableDisableITem(EWDisplayMHdl, EWFontItem, IsEditorWindow(frontwindow) or IsInfoWindow(frontwindow) or (frontwindow = stateswindow)or IsTextWindow(frontwindow));				EnableDisableITem(EWDisplayMHdl, EWSizeItem, IsEditorWindow(frontwindow) or IsInfoWindow(frontwindow) or (frontwindow = stateswindow)or IsTextWindow(frontwindow));				EnableDisableITem(EWDisplayMHdl, EWStyleItem, IsEditorWindow(frontwindow) & editorSelected & (CharOfCell(editorSelectionTopLeft)=0) & (CharOfCell(editorSelectionBotRight)=0));			end;	end;{-----------------------------------------------------------------------------}	procedure FixSomeCharMenuitems;{note that this also fixes some other tree menu items!}	begin		if treeopen then			begin				if (traceshown = traceDiscrete) then					SetMenuItemText(TraceMHdl, TraceOnOffItem, 'Trace Off')				else					SetMenuItemText(TraceMHdl, TraceOnOffItem, 'Trace Character');				EnableDisableItem(CharactersMHdl, xxxxEvolveCharacterItem, nodes & fileopen & not equivcycle & treeopen & not nullson & not ancon & not Locked(lockData));{EnableDisableItem(NewChartMHdl, sChangesItem, not nullson & not ancon);}				myEnableItem(TraceMHdl, TraceCharItem);				myEnableItem(TreeMHdl, PolyRealItem);				EnableDisableItem(TraceMHdl, TraceLastItem, (traceshown = traceDiscrete) and (oldtracei <> i));				EnableDisableItem(TWDisplayMHdl, BranchPatternsAndColorsItem, ((traceshown = traceContinuous) and ScreenInColor) or nex7on or (traceshown = traceDiscrete) or ((traceshown = traceAllChanges) and (summaryview = aspattern)));				EnableDisableItem(TWDisplayMHdl, TraceLabelItem, (traceshown = traceContinuous) | (traceshown = traceDiscrete) | (traceshown = traceAllChanges) | ((traceshown = traceAllStates) & (BLSWhat <> BLSstatesum)));				EnableDisableItem(TWDisplayMHdl, BarDisplayOptionsItem, (traceshown = traceAllChanges) & (summaryView=asTicks));{$IFC FALSE}				EnableDisableItem(TWDisplayMHdl, BranchLengthsItem, (traceshown = traceAllChanges));{$ENDC}{EnableDisableItem(TWDisplayMHdl, TipLabelsItem, (traceshown = traceDiscrete));}				EnableDisableItem(TraceMHdl, EquivCycleItem, (traceshown = traceDiscrete) & (resolveoption = allpossible) & EquivocalLegal(screenR));				EnableDisableItem(TraceMHdl, NumberMPRsItem, (traceshown = traceDiscrete) & (resolveoption = allpossible) & EquivocalLegal(screenR));				EnableDisableItem(TraceMHdl, ResolveOptionItem, (traceshown = traceDiscrete) & (typeofchar(i) < irreversible) & nodes & not nullson & not ancon & not (charton & (CWTRees[CWChart] = CWCurrentTree) & CWTraced & (CWChart = CWCChanges) & (chartchangesmode <> unambigmode)));				EnableDisableItem(CopySpecialMHdl, CopyConstraintTreeItem, fileopen & not equivcycle & treeopen & not ancon);			end;		EnableDisableItem(SaveOtherMHdl, SvTxtNodeListItem, treeopen & ((traceshown = traceProbability) | (traceshown = traceDiscrete) | (traceshown = traceAllChanges) | (traceshown = traceAllStates) | (traceshown = traceContinuous)));	end;{-----------------------------------------------------------------------------}	procedure FixCharMenu;	begin		EnableDisableItem(xxInclusionSetsMHdl, 0, fileopen & not Locked(lockAssumptions));		EnableDisableItem(xxTypeSetsMHdl, 0, fileopen& not Locked(lockAssumptions));		EnableDisableItem(xxWeightSetsMHdl, 0, fileopen& not Locked(lockAssumptions));		if treeopen then			FixSomeCharMenuitems;	end;{-----------------------------------------------------------------------------}	procedure FixFormatMenu;	begin		myCheckMenuItem(xxDataFormatMHdl, StandFormItem, datatype = standard);		myCheckMenuItem(xxDataFormatMHdl, DNAFormItem, datatype = DNA);		myCheckMenuItem(xxDataFormatMHdl, RNAFormItem, datatype = RNA);		myCheckMenuItem(xxDataFormatMHdl, proteinItem, datatype = protein);		myCheckMenuItem(xxDataFormatMHdl, Stand32Item, datatype = standard32);		if nucleotides then			SetMenuItemText(xxDataFormatMHdl, proteinItem, 'Translate to Protein...')		else			SetMenuItemText(xxDataFormatMHdl, proteinItem, 'Protein');	end;{-----------------------------------------------------------------------------}	procedure CheckColumnWidthMenu;	var	j: integer;		ds, menuString: str255;		widthFound: boolean;	begin		widthFound:= false;		ds := StringFromNum(editorColumnWidth);		for j := 1 to OtherColumnWidthItem-1 do			begin				myCheckMenuItem(ColumnWidthMHdl,j, false);				GetMenuItemText(ColumnWidthMHdl, j, menuString);				if menuString = ds then					begin						myCheckMenuItem(ColumnWidthMHdl,j, true);						widthFound:= true;					end;			end;		myCheckMenuItem(ColumnWidthMHdl,OtherColumnWidthItem, not widthFound);				end;{----------------------------------------------------------------------------}	procedure CheckCalcMenu;	begin		myCheckMenuItem(CalcMHdl, LengthItem, count);		myCheckMenuItem(CalcMHdl, ChangesItem, calctreechanges);		myCheckMenuItem(CalcMHdl, CIItem, calcCI);		myCheckMenuItem(CalcMHdl, RIItem, calcRI);		myCheckMenuItem(CalcMHdl, RCItem, calcRC);		myCheckMenuItem(CalcMHdl, MinPosItem, showMinSteps);		myCheckMenuItem(CalcMHdl, MaxPosItem, showMaxSteps);	end;	{----------------------------------------------------------------------------}	procedure CheckFlashMenu;	begin		myCheckMenuItem(FindMHdl, FlashFindItem, editorFlashMode = FlashFindSequence);		myCheckMenuItem(FindMHdl, FlashNonCodonsItem, editorFlashMode = FlashNonCodons);		myCheckMenuItem(FindMHdl, FlashFindIgnoreGapsItem, flashFindIgnoreGaps);		if fileopen & editorOpen then			EnableDisableItem(FindMHdl, FlashNonCodonsItem,nucleotides & someCoding );{$IFC RESEARCH}		if fileopen & editorOpen then			EnableDisableItem(FindMHdl, FindNonCodonsItem,nucleotides & someCoding );{$ENDC}{$IFC FLASHRNACOMP}		if fileopen & editorOpen then			EnableDisableItem(FindMHdl, FlashRNARCOffItem,nucleotides & (editorFlashMode = flashRNAReverseComplement) );		myCheckMenuItem(FindMHdl, FlashRNARCIgnoreGapsItem, flashRNARevCompIgnoreGaps);	//	myCheckMenuItem(FindMHdl, FlashRNARCOffItem, editorFlashMode = flashRNAReverseComplement);{$ENDC}	end;{----------------------------------------------------------------------------}	procedure EnableCutCopyClear;	begin		myEnableItem(EditMHdl, CutItem);		myEnableItem(EditMHdl, CopyItem);		myEnableItem(EditMHdl, ClearItem);	end;{----------------------------------------------------------------------------}	procedure RebuildWindowsMenu;	var j : integer;		aWindow: WindowPtr;		numVisibleWindows: integer;		var ds: str255;	begin		if fileopen then			begin				for j := 1 to numMacCladeWindows do					MacCladeWindowList[j] := nil;									for j := myCountMenuItems(WindowsMHdl) downto OpenWindowsFirstItem-1 do					DeleteMenuItem(WindowsMHdl, j);								numVisibleWindows := 0;									aWindow := frontwindow;				if frontwindow <> nil then					repeat 												if WindowVisible(aWindow) & MacCladeWindow(aWindow) then							if not IsTreeWindow(aWindow) & not IsEditorWindow(aWindow) & (not IsTextWindow(aWindow)| (aWindow=textWindow[nexusBlockText])) & not IsPaletteWindow(aWindow) then								begin									if numVisibleWindows = 0 then {it's the first one}										AppendMenu(WindowsMHdl, '(-');									GetWTitle(aWindow, ds);									if aWindow = chartwindow then										AppendMenu(WindowsMHdl, 'Chart')									else if aWindow = textWindow[nexusBlockText] then										AppendMenu(WindowsMHdl, 'Nexus Block Editor')									else										AppendMenu(WindowsMHdl, ds);									numVisibleWindows := numVisibleWindows+1;									MacCladeWindowList[numVisibleWindows] := aWindow;								end;						aWindow := myGetNextWindow(aWindow);					until aWindow = nil;			end;	end;{----------------------------------------------------------------------------}	procedure FixPasteMenuItem;	var os: OSStatus;		scrapReference: ScrapRef;		scrapFlavors: ScrapFlavorFlags;		textScrapPresent, pictScrapPresent: boolean;		whichinfo: integer;	begin{$IFC CARBON}	 	os := GetCurrentScrap(scrapReference);	    	os := GetScrapFlavorFlags(scrapReference,kScrapFlavorTypeText,scrapFlavors);	    	textScrapPresent:= os=noErr;	    	os := GetScrapFlavorFlags(scrapReference,kScrapFlavorTypePicture,scrapFlavors);	    	pictScrapPresent:= os=noErr;{$ELSEC}		textScrapPresent := TEGetScrapLength <> 0;		pictScrapPresent:= scrapIsPict;{$ENDC}	    			if IsEditableTextWindow(frontwindow) then			begin				if  textScrapPresent then					myEnableItem(EditMHdl, PasteItem);			end		else if isInfoWindow(frontwindow) then			begin				whichInfo := WhichInfoWindow(frontWindow);				if infoEditing[whichinfo] & textScrapPresent then					myEnableItem(EditMHdl, PasteItem);			end		else if (frontwindow = pictwindow) then			begin				if pictScrapPresent then					myEnableItem(EditMHdl, PasteItem);			end		else if IsEditorWindow(frontwindow) then			begin				if pictScrapPresent and SingleCell and editorSelected then					myEnableItem(EditMHdl, PasteItem);				if textScrapPresent and SingleCell and editorSelected then					myEnableItem(EditMHdl, PasteItem);				if (EWScrapBlockP^.ntax + EWScrapBlockP^.nchar > 0) and editorSelected then					myEnableItem(EditMHdl, PasteItem);			end		else if (frontwindow = stateswindow) then			if  (textScrapPresent & statesEditing) | ((GetHandleSize(statesClipboardH)>2) & statesSelected) then				myEnableItem(EditMHdl, PasteItem);		if pictScrapPresent then			SetMenuItemText(EditMHdl, PasteItem, 'Paste Picture')		else			SetMenuItemText(EditMHdl, PasteItem, 'Paste Text');      end;{----------------------------------------------------------------------------}	procedure FixCopyPasteMenuItems;	var whichText, whichinfo: integer;	begin{$IFC NOT ALWAYSENABLED}		myDisableItem(EditMHdl, CutItem);		myDisableItem(EditMHdl, CopyItem);		myDisableItem(EditMHdl, ClearItem);		myDisableItem(EditMHdl, DeleteItem);		myDisableItem(EditMHdl, PasteItem);{$ENDC}		if fileopen then			begin				if (frontwindow = pictwindow) then					EnableCutCopyClear				else if IsEditableTextWindow(frontwindow) then					begin						whichText := WhichTextWindow(frontWindow);						if  (textWindowInfo[whichText]^.TE^^.selstart <> textWindowInfo[whichText]^.TE^^.selEnd) then							begin								EnableCutCopyClear;							end;					end				else if (frontwindow = Chartwindow) and ((CWView = scatterview) or (CWView = histoview)) then					myEnableItem(EditMHdl, CopyItem)				else if IsTreeWindow(frontWindow) then					myEnableItem(EditMHdl, CopyItem)				else if IsEditorWindow(frontwindow) then					begin						if not (footediting and foottexton) and editorSelected and (((editorCellTE^^.selStart <> editorCellTE^^.selEnd) and SingleCell) or not SingleCell) then							EnableCutCopyClear						else if footediting and foottexton and (noteTE^^.selstart <> noteTE^^.selEnd) then							EnableCutCopyClear;						EnableDisableItem(EditMHdl, DeleteItem, (WholeTaxonSel | WholeCharSel));					end				else if isInfoWindow(frontwindow) then					begin						whichInfo := WhichInfoWindow(frontWindow);						if infoEditing[whichinfo] then							if  (infoTE[whichinfo]^^.selstart <> infoTE[whichinfo]^^.selEnd) then								EnableCutCopyClear;						EnableDisableItem(EditMHdl, DeleteItem, infoSomeSelected[whichinfo]);					end				else if (frontwindow = stateswindow) then					if  (statesEditing or statesSelected) then						EnableCutCopyClear;      				FixPasteMenuItem;			end;	end;{-----------------------------------------------------------------------------}	procedure CheckColorCellsMenu;	begin		myCheckMenuItem(ColorCellsMHdl, ColorCellsOffItem, editorColorCellsMode = editorColorCellsOff);		myCheckMenuItem(ColorCellsMHdl, ColorCellsByStateItem, editorColorCellsMode = editorColorCellsState);		myCheckMenuItem(ColorCellsMHdl, ColorCellsMatchFirstItem, editorColorCellsMode = editorColorCellsMatchFirst);		myCheckMenuItem(ColorCellsMHdl, ColorCellsByAAStateItem, editorColorCellsMode = editorColorCellsAAState);		myCheckMenuItem(ColorCellsMHdl, ColorCellsDimLowerCaseItem, editorColorCellsDimLowerCase);		myCheckMenuItem(ColorCellsMHdl, ColorCellsLettersOnlyItem, not editorColorCellsByFillRect);		{myCheckMenuItem(ColorCellsMHdl, ColorCellsByCodPosItem, editorColorCellsMode = editorColorCellsCodPos);		myCheckMenuItem(ColorCellsMHdl, ColorCellsByPartitionItem, editorColorCellsMode = editorColorCellsPartition);}	end;{----------------------------------------------------------------------------}	procedure FixChangeAllSubmenuName(showSelected: boolean);	begin		if showSelected then			SetMenuItemText(EdUtilitiesMHdl, ReplaceAllSubmenuItem, 'Change Selected')		else			SetMenuItemText(EdUtilitiesMHdl, ReplaceAllSubmenuItem, 'Change All');	end;{----------------------------------------------------------------------------}	procedure FixChartDisplayMenu;	begin		if frontwindow=chartWindow then			begin				EnableDisableItem(ChartDisplayMHdl, ChartDisplayVerticalAxisItem, CWLinear and (CWView = histoview));				EnableDisableItem(ChartDisplayMHdl, ChartDisplayHorizontalAxisItem, CWLinear and (CWView = histoview));				EnableDisableItem(ChartDisplayMHdl, ChartDisplayPercentageItem, not CWLinear and (CWView = tableView) and (NumSpotBar(SpotBarSetToShow) = 1));				EnableDisableItem(ChartDisplayMHdl, ChartDisplayCircleSizeItem, not CWLinear and (CWView = scatterview));				EnableDisableItem(ChartDisplayMHdl, ChartDisplayPatternsColorsItem, ((CWView = histoview) or (CWView = scatterview)) and not MinMaxIrregular);				EnableDisableItem(ChartDisplayMHdl, ChartDisplayValuesItem, MinMaxEnabled);				EnableDisableItem(ShowMHdl, ChartShowTitleItem,  not (CWView = infoview));				EnableDisableItem(ShowMHdl, ChartShowGridItem, ((CWLinear and (CWView = histoview)) or (CWView = scatterview)));				CheckChartViewsMenu;			end;	end;{----------------------------------------------------------------------------}	procedure SetPrintExtraItem(theWindow: WindowPtr);	begin		if theWindow=editorWindow then			SetMenuItemText(FileMHdl,PrintExtraItem, 'Pretty Print Matrix...')		else if theWindow=treeWindow then			SetMenuItemText(FileMHdl,PrintExtraItem, 'Print Multiple Trees...')		else if theWindow=statesWindow then			SetMenuItemText(FileMHdl,PrintExtraItem, 'Print All Names...');	end;{----------------------------------------------------------------------------}	procedure FixEditMenu;		var			it: integer;			whichinfo, whichText: integer;	begin{$IFC LOCKCONTROL}		EnableDisableItem(EditMHdl, LockControlItem,fileopen);{$ELSEC}		myDisableItem(EditMHdl, LockControlItem);{$ENDC}{$IFC NOT ALWAYSENABLED}		myDisableItem(FileMHdl,PrintExtraItem);		EnableDisableItem(FileMHdl, NewItem,not fileopen);		EnableDisableItem(FileMHdl, OpenItem,not fileopen);		EnableDisableItem(FileMHdl, CloseFileItem,fileopen);		if fileopen then			myEnableItem(WindowsMHdl, FileNotesItem)		else			myDisableItem(WindowsMHdl, FileNotesItem);		if not fileopen then 			begin				myDisableItem(FileMHdl, CloseWindowItem);				myDisableItem(EditMHdl, LockControlItem);			end;		myDisableItem(EditMHdl, UndoItem);		myDisableItem(EditMHdl, SelectTaxaWithStateItem);		myDisableItem(EditMHdl, ShrinkWrapSelectionItem);		myDisableItem(EditMHdl, MoveSelectedRowsToTopItem);		myDisableItem(EditMHdl,TransferSelectionItem);		myDisableItem(EditMHdl, xxxxMultiplyItem);		myDisableItem(EditMHdl, xxxxDuplicateItem);		myDisableItem(xxCharacterSetsMHdl, StoreCharacterSetItem);{$IFC FLASHRNACOMP}		myDisableItem(FindMHdl, EnterRNARCItem);		myDisableItem(FindMHdl, FlashRNARCIgnoreGapsItem);		myDisableItem(FindMHdl, FlashRNARCOffItem);{$ENDC}		myDisableItem(CharPartListMHdl, SetSelectedAsGroupItem);		myDisableItem(MismatchMHdl, 0);		myDisableItem(xxTaxonSetsMHdl, StoreTaxonSetItem);		EnableDisableItem(CopySpecialMHdl, CopyConstraintTreeItem, fileopen & not equivcycle & treeopen & not ancon);		EnableDisableItem(CopySpecialMHdl, CopyOutgroupItem, fileopen & infoOpen[taxinfo] & infoSomeSelected[taxinfo]);		EnableDisableItem(FileMHdl, RevertItem, fileopen & not newfile);		myDisableItem(TreeMHdl,ShowTreeItem);		{myDisableItem(EditMHdl, WarnIfCantUndoItem);}				if editorOpen then			begin				EnableDisableItem(EditMHdl, EntryInterpretItem, fileopen & not Locked(lockData));				EnableDisableItem(EditMHdl, TrackCellItem, fileopen & not Locked(lockData));				EnableDisableItem(EditMHdl, TreatMissingAsGapItem, fileopen & not Locked(lockData));				EnableDisableItem(ReplaceAllMHdl,0,fileopen & not Locked(lockData));			end;		{$ENDC}		FixCopyPasteMenuItems;		EnableDisableItem(EditMHdl, ContinuousEditItem, fileopen & not equivcycle & not Locked(lockData));		EnableDisableItem(NexusBlocksMHdl, NewNexusBlockItem, fileopen & not Locked(lockData));		EnableDisableItem(NexusBlocksMHdl, OpenPAUPBlockItem, fileopen & not Locked(lockData));		EnableDisableItem(CopySpecialMHdl,0,fileopen & not Locked(lockData));		EnableDisableItem(EWDisplayMHdl, ConsensusItem, fileOpen & editorOpen & not Locked(lockData));		EnableDisableItem(EWDisplayMHdl, ConsensusTaxSetSubmenuItem, fileOpen & editorOpen & not Locked(lockData));				EnableDisableItem(ReplaceAllMHdl,NtoMissingItem,fileopen & not Locked(lockData) & nucleotides);		EnableDisableItem(ReplaceAllMHdl,MissingToNItem,fileopen & not Locked(lockData) & nucleotides);		EnableDisableItem(ReplaceAllMHdl,TerminalPartTripletsToGapsItem,fileopen & not Locked(lockData) & nucleotides & SomeCoding);		FixChartDisplayMenu;		FixGoToMenu;						if not fileopen then			begin				myDisableItem(EditMHdl, SelectItem);				myDisableItem(EditMHdl, GoToSubmenuItem);				myDisableItem(EditMHdl, NexusBlocksSubmenuItem);				myDisableItem(EditMHdl, CopyPAUPSubmenuItem);			end		else 			begin				myEnableItem(EditMHdl, GoToSubmenuItem);				myEnableItem(EditMHdl, NexusBlocksSubmenuItem);				myEnableItem(EditMHdl, CopyPAUPSubmenuItem);				{myCheckMenuItem(EditMHdl, WarnIfCantUndoItem,warnIfCantUndo);}				EnableDisableItem(FileMHdl,PrintExtraItem,(infoOpen[treeinfo] & infosomeSelected[treeinfo] & treeopen) | (IsEditorWindow(frontwindow) )| (frontWindow=statesWindow));				myCheckMenuItem(TaxonListOptionsMHdl, ConsiderExcludedInTaxonListItem, taxInfoConsiderAllCharacters);				myCheckMenuItem(TaxonListOptionsMHdl, ShowStopCodonsInTaxonListItem, taxInfoShowStopCodons & ((datatype=protein) | (nucleotides&someCoding)));				myCheckMenuItem(TaxonListOptionsMHdl, ShowFirstBaseInTaxonListItem, taxInfoShowFirstBase);				myCheckMenuItem(TaxonListOptionsMHdl, ShowLastBaseInTaxonListItem, taxInfoShowLastBase);				myCheckMenuItem(TaxonListOptionsMHdl, ShowLowerCaseInTaxonListItem, taxInfoShowLowerCase);				myCheckMenuItem(TaxonListOptionsMHdl, ShowUncertaintyInTaxonListItem, taxInfoShowUncertainty);				myCheckMenuItem(TaxonListOptionsMHdl, ShowPolymorphismInTaxonListItem, taxInfoShowPolymorphism);				myCheckMenuItem(TaxonListOptionsMHdl, ShowPartTripletsInTaxonListItem, taxInfoShowPartTriplets & (nucleotides & someCoding));				myCheckMenuItem(TaxonListOptionsMHdl, ShowNucFrequenciesInTaxonListItem, taxInfoShowNucFrequencies & nucleotides);				EnableDisableItem(TaxonListOptionsMHdl, ShowNucFrequenciesInTaxonListItem,nucleotides);				EnableDisableItem(TaxonListOptionsMHdl, ShowStopCodonsInTaxonListItem,(datatype=protein) | (nucleotides&someCoding));				myCheckMenuItem(CharListOptionsMHdl, ShowMissingInCharListItem, charInfoShowMissing);				myCheckMenuItem(CharListOptionsMHdl, ShowGapsInCharListItem, charInfoShowGaps);				myCheckMenuItem(CharListOptionsMHdl, ShowPartitioninCharListItem, charInfoShowPartition);				EnableDisableItem(CharPartListMHdl, SetGroupColorItem,  infoSomeSelected[charpartnameinfo] & (frontwindow=infoWindow[charpartnameinfo]));								myDisableItem(TaxaMHdl, xxxxMergeTaxaItem);				myDisableItem(TaxaMHdl, xxxxFilterTaxaItem);				myDisableItem(CharactersMHdl,xxxxCompressCharactersItem);				CheckColorCellsMenu;				EnableDisableItem(CharactersMHdl, dataFormatSubmenuItem,editorOpen & not Locked(lockData));				EnableDisableItem(CharactersMHdl, xxxxEvolveCharacterItem, nodes & fileopen & not equivcycle & treeopen & not nullson & not ancon & not Locked(lockData));								EnableDisableItem(xxCreateTreesMHdl,RandomTreeItem,treeopen & not Locked(lockTrees));				EnableDisableItem(xxCreateTreesMHdl,AllRootingsItem,treeopen & not Locked(lockTrees));				EnableDisableItem(TreeMHdl, StoreTreeItem,treeopen & not Locked(lockTrees));				EnableDisableItem(TreeMHdl, TransferTreeItem,TransferTreesAvailable);								EnableDisableItem(CharactersMHdl, xxxxAddEmptyCharacterItem,not Locked(lockData)&editorOpen);				{EnableDisableItem(CharactersMHdl, xxxxFilterCharactersItem,not Locked(lockData)&editorOpen);}				EnableDisableItem(CharactersMHdl, xxxxCodonPosItem, not Locked(lockAssumptions)&nucleotides);				EnableDisableItem(CharactersMHdl, xxxxEditTypeItem,not Locked(lockAssumptions));				EnableDisableItem(CharactersMHdl, xxxxImportTypeItem,not Locked(lockAssumptions));				EnableDisableItem(CharactersMHdl, changeTypeSubmenuItem,not Locked(lockAssumptions));				EnableDisableItem(CharactersMHdl, TypeSetListSubMenuItem, not Locked(lockAssumptions));				EnableDisableItem(CharactersMHdl, changeWtSubmenuItem,not Locked(lockAssumptions));				EnableDisableItem(CharactersMHdl, WtSetListSubMenuItem, not Locked(lockAssumptions));				EnableDisableItem(CharactersMHdl, changeIncExcSubmenuItem,not Locked(lockAssumptions));				EnableDisableItem(CharactersMHdl, ExSetListSubMenuItem, not Locked(lockAssumptions));				EnableDisableItem(CharactersMHdl, xxxxStateNamesSymbolsItem, fileopen & not equivcycle & not molecular);		//		EnableDisableItem(CharactersMHdl, xxxxCompressCharactersItem, fileopen & editorOpen & not Locked(lockData));				EnableDisableItem(TaxaMHdl, AddEmptyTaxaItem,not Locked(lockData)&editorOpen);		//		EnableDisableItem(TaxaMHdl, xxxxFilterTaxaItem,not Locked(lockData)&editorOpen);				EnableDisableItem(TaxaMHdl, ImportTaxaSubmenuItem, fileopen & editorOpen & not Locked(lockData)& (molecular| (newfile & not dirtyfile)));				EnableDisableItem(TaxaMHdl, ReorderByTreeItem, fileopen & not equivcycle & treeopen& not Locked(lockData));				EnableDisableItem(TaxaMHdl, ReorderRandomlyItem, fileopen & not equivcycle & not Locked(lockData));				EnableDisableItem(TaxaMHdl, MoveToTaxonItem, fileopen & editorOpen & AnyConsensusSelected& not Locked(lockData));				EnableDisableItem(EdUtilitiesMHdl, SearchAndReplaceItem,not Locked(lockData)&editorOpen);							{	EnableDisableItem(xxImportTaxaMHdl, 0, fileopen & editorOpen & molecular);}			{	EnableDisableItem(xxImportTaxaMHdl, ImportGenbankItem, fileopen & editorOpen & molecular);}				if treeopen then					begin						EnableDisableItem(TraceMHdl,TraceSelectedItem, infoOpen[charinfo] & infoSomeSelected[charinfo]);						if not noundo and not equivcycle then							myEnableItem(editMHdl, UndoItem);						myDisableItem(EditMHdl, xxxxMultiplyItem);						myDisableItem(EditMHdl, xxxxDuplicateItem);						EnableDisableItem(TreeMHdl,ShowTreeItem, fileopen & infoOpen[treeinfo] & infoSomeSelected[treeinfo]);					end;				EnableDisableItem(EditMHdl, SelectItem, IsEditableTextWindow(frontwindow) or IsEditorWindow(frontwindow) or (frontwindow = statesWindow) or((IsInfoWindow(frontwindow)) and not (treeopen and equivcycle)));				EnableDisableItem(EditMHdl, MoveSelectedRowsToTopItem, IsInfoWindow(frontWindow) & infoSomeSelected[WhichInfoWindow(frontWindow)] & not Locked(lockData));				EnableDisableItem(NexusBlocksMHdl, EditNexusBlockItem, ((frontwindow = infoWindow[nexusblockinfo]) & infoSomeSelected[nexusblockinfo]));				if editorOpen then					begin						CheckFlashMenu;						SetStateNamesItem;						EnableDisableItem(DataMatrixStyleMHdl,styleMolecularItem, molecular);						EnableDisableItem(DataMatrixStyleMHdl,styleShadedMolecularItem, molecular);						EnableDisableItem(DataMatrixStyleMHdl,styleWideNamesItem, not molecular);						EnableDisableItem(DataMatrixStyleMHdl,styleDNAwithAAItem, nucleotides&someCoding);						EnableDisableItem(DataMatrixStyleMHdl,styleDNAwithAAColorsItem, nucleotides&someCoding);						EnableDisableItem(DataMatrixStyleMHdl,styleShadedDNAwithAAColorsItem, nucleotides&someCoding);						EnableDisableItem(ColorCellsMHdl, ColorCellsByAAStateItem, nucleotides&someCoding);						EnableDisableItem(ColorCellsMHdl, ColorCellsDimLowerCaseItem, nucleotides);						EnableDisableItem(ColorCellsMHdl, ColorCellsProteinStateColorItem,nucleotides);						EnableDisableItem(AATranslateMHdl, 0, nucleotides & someCoding);						EnableDisableItem(ColorCodPosMHdl, 0, nucleotides & someCoding);						EnableDisableItem(ColorCharPartitionMHdl, 0, not onePartition);												if nucleotides&someCoding then							begin								myCheckMenuItem(AATranslateMHdl,AATranslateShowItem, AAAutoTranslationVisible);								myCheckMenuItem(AATranslateMHdl,AATranslateDimNucItem, editorDimDNAwithAA );								EnableDisableItem(AATranslateMHdl,AATranslateDimNucItem, nucleotides & AAAutoTranslationVisible);								EnableDisableItem(AATranslateMHdl,AATranslateColorItem, nucleotides & AAAutoTranslationVisible);								myCheckMenuItem(AATranslateMHdl,AATranslateColorItem, editorColorAAwithDNA);							end;						myCheckMenuItem(ShowMHdl, EWCellSymbolsItem, editorShowCellSymbol);						CheckColumnWidthMenu;					end;				if IsEditorWindow(frontwindow) then					begin{$IFC FLASHRNACOMP}						EnableDisableItem(FindMHdl, FlashRNARCIgnoreGapsItem, nucleotides);						EnableDisableItem(MismatchMHdl, 0, nucleotides);						EnableDisableItem(FindMHdl, EnterRNARCItem,editorSelected& nucleotides & not SingleCell);						EnableDisableItem(FindMHdl, FlashRNARCOffItem,nucleotides & (editorFlashMode = flashRNAReverseComplement) );{$ENDC}						EnableDisableItem(CharPartListMHdl, SetSelectedAsGroupItem,WholeCharSel);						EnableDisableItem(xxCharacterSetsMHdl, StoreCharacterSetItem,WholeCharSel);						EnableDisableItem(xxTaxonSetsMHdl, StoreTaxonSetItem,WholeTaxonSel);{$IFC SPEECH}						EnableDisableItem(EdUtilitiesMHdl, SpeakmatrixItem, hasSpeechManager);						EnableDisableItem(EdUtilitiesMHdl, SpeechOptionsItem, hasSpeechManager);{$ENDC}						EnableDisableItem(CharactersMHdl, xxxxGeneticCodeItem, molecular );{$IFC NOT ALWAYSENABLED}						myDisableItem(StyleMHdl, 0);						myDisableItem(EWDisplayMHdl, EWStyleItem);						myDisableItem(EdUtilitiesMHdl, UpperCaseItem);						myDisableItem(EdUtilitiesMHdl, LowerCaseItem);						myDisableItem(EdUtilitiesMHdl, FillItem);						myEnableItem(EdUtilitiesMHdl,ReplaceAllSubmenuItem);						myDisableItem(EWDisplayMHdl, PICTShowItem);						myDisableItem(EdUtilitiesMHdl, xxxxImportPictureItem);						myDisableItem(EdUtilitiesMHdl, xxxxRemovePictureItem);						myDisableItem(EdUtilitiesMHdl, ComplementItem);{$IFC RESEARCH}						myDisableItem(EdUtilitiesMHdl, ShiftMinimizeStopsItem);					//	myDisableItem(EdUtilitiesMHdl, ShiftToMatchItem);						myDisableItem(EdUtilitiesMHdl,ShiftOtherToMatchItem);{$ENDC}						myDisableItem(EdUtilitiesMHdl, CondenseTaxonNamesItem);						myDisableItem(EdUtilitiesMHdl, ReverseItem);						myDisableItem(EdUtilitiesMHdl, RecodeItem);						myDisableItem(EdUtilitiesMHdl, RandomFillItem);						myDisableItem(EdUtilitiesMHdl, ShuffleItem);						myDisableItem(EditMHdl, xxxxMultiplyItem);						myDisableItem(EditMHdl, xxxxDuplicateItem);						EnableDisableItem(EdUtilitiesMHdl, TranslateTaxonNamesItem,not Locked(lockData));{$IFC MATCHPROTEINALIGN}						EnableDisableItem(EdUtilitiesMHdl, ImportProteinAlignmentItem,not Locked(lockData));{$ENDC}						{$ENDC}						{EnableDisableItem(EditMHdl, WarnIfCantUndoItem, not Locked(lockData));}						if not Locked(lockData)  then							myEnableItem(EdUtilitiesMHdl, RandomFillItem);						SetMenuItemText(EditMHdl, ClearItem, 'Clear');						if editorSelected then							begin								if not SingleCell & not Locked(lockData) then									begin										if AnyFeet(footPict) then											begin												myEnableItem(EdUtilitiesMHdl, xxxxRemovePictureItem);												SetMenuItemText(EdUtilitiesMHdl, xxxxRemovePictureItem, 'Remove Pictures');											end;										EnableDisableITem(EdUtilitiesMHdl, RecodeItem, WholeCharSel);										EnableDisableITem(EditMHdl,TransferSelectionItem, WholeCharSel | WholeTaxonSel);										myEnableItem(EdUtilitiesMHdl, FillItem);																				EnableDisableItem(EdUtilitiesMHdl, CondenseTaxonNamesItem,OnlyTaxonNamesSelected);										EnableDisableItem(EdUtilitiesMHdl, UpperCaseItem, nucleotides & SomeDataSel & not SingleCell);										EnableDisableItem(EdUtilitiesMHdl, LowerCaseItem, nucleotides  & SomeDataSel & not SingleCell);										EnableDisableITem(EdUtilitiesMHdl, ShuffleItem, (TaxonOfCell(editorSelectionBotRight) > 1) and (TaxonOfCell(editorSelectionBotRight) > TaxonOfCell(editorSelectionTopLeft)) and (CharOfCell(editorSelectionBotRight) > 0));										EnableDisableITem(EdUtilitiesMHdl, ComplementItem, nucleotides & (CharOfCell(editorSelectionBotRight) >= 1));{$IFC RESEARCH}										EnableDisableITem(EdUtilitiesMHdl, ShiftMinimizeStopsItem, nucleotides & (CharOfCell(editorSelectionBotRight) >= 1) & WholeTaxonSel & SomeCoding);//										EnableDisableITem(EdUtilitiesMHdl, ShiftToMatchItem, molecular & (CharOfCell(editorSelectionBotRight) >= 1) & WholeTaxonSel);										EnableDisableITem(EdUtilitiesMHdl, ShiftOtherToMatchItem, molecular  & (CharOfCell(editorSelectionBotRight) >= 1) & SomeDataSel & not SingleCell);{$ENDC}										EnableDisableITem(EdUtilitiesMHdl, ReverseItem, molecular & (CharOfCell(editorSelectionTopLeft) <> 0) & ((CharOfCell(editorSelectionBotRight) - CharOfCell(editorSelectionTopLeft)) > 1));										if WholeTaxonSel and (TaxonOfCell(editorSelectionTopLeft) <> TaxonOfCell(editorSelectionBotRight)) then  {more than one taxon selected}											begin												myEnableItem(TaxaMHdl, xxxxMergeTaxaItem);												myEnableItem(TaxaMHdl, xxxxFilterTaxaItem);											end;										if WholeCharSel and (CharOfCell(editorSelectionTopLeft) <> CharOfCell(editorSelectionBotRight)) then  {more than one character selected}											myEnableItem(CharactersMHdl,xxxxCompressCharactersItem);										if WholeTaxonSel or WholeCharSel then											begin												myEnableItem(EditMHdl, xxxxDuplicateItem);												myEnableItem(EditMHdl, xxxxMultiplyItem);												SetMenuItemText(EditMHdl, ClearItem, 'Delete');											end;										if someDataSel then											myEnableItem(EditMHdl, ShrinkWrapSelectionItem);									end								else if SingleCell then									begin										if someDataSel then											myEnableItem(EditMHdl, SelectTaxaWithStateItem);										if not Locked(lockData)  then											begin												if footpictpresent(TaxonOfCell(editorSelectionTopLeft), CharOfCell(editorSelectionTopLeft)) then													begin														myEnableItem(EWDisplayMHdl, PICTShowItem);														myEnableItem(EdUtilitiesMHdl, xxxxRemovePictureItem);														SetMenuItemText(EdUtilitiesMHdl, xxxxRemovePictureItem, 'Remove Picture');													end;												myEnableItem(EdUtilitiesMHdl, xxxxImportPictureItem);												EnableDisableITem(EditMHdl, UndoItem, SelCellChanged);											end;									end;								if ((editorSelectionBotRight.v = 0) and (editorSelectionTopLeft.v = 0) and editorTransposed) or ((editorSelectionBotRight.h = 0) and (editorSelectionTopLeft.h = 0) and not editorTransposed) then									begin										if IsEditorWindow(frontWindow) then											myEnableItem(EWDisplayMHdl, EWStyleItem);										myCheckMenuItem(EWDisplayMHdl, EWStyleItem, true);										for it := TaxonOfCell(editorSelectionTopLeft) to TaxonOfCell(editorSelectionBotRight) do											if not ItalicTaxon(it) then												begin													myCheckMenuItem(EWDisplayMHdl, EWStyleItem, false);													leave;												end;									end;							end;						EnableDisableITem(EditMHdl, UndoItem, lastChangeInEditor<>lastChangeCantUndo);					end				else if editorOpen then					begin{$IFC NOT ALWAYSENABLED}						myDisableItem(EdUtilitiesMHdl, RecodeItem);						myDisableItem(EdUtilitiesMHdl, UpperCaseItem);						myDisableItem(EdUtilitiesMHdl, LowerCaseItem);						myDisableItem(EdUtilitiesMHdl, FillItem);						myDisableItem(EdUtilitiesMHdl,ReplaceAllSubmenuItem);						myDisableItem(EdUtilitiesMHdl, RandomFillItem);						myDisableItem(EdUtilitiesMHdl, ShuffleItem);						myDisableItem(EditMHdl, xxxxMultiplyItem);						myDisableItem(EditMHdl, xxxxDuplicateItem);						myDisableItem(TaxaMHdl, xxxxMergeTaxaItem);						myDisableItem(TaxaMHdl, xxxxFilterTaxaItem);						myDisableItem(CharactersMHdl,xxxxCompressCharactersItem);						myDisableItem(EdUtilitiesMHdl, SearchAndReplaceItem);{$IFC SPEECH}						myDisableItem(EdUtilitiesMHdl, SpeakMatrixItem);						myDisableItem(EdUtilitiesMHdl, SpeechOptionsItem);  {$ENDC}{$ENDC}						CheckColorCellsMenu;						if not Locked(lockData)  then							begin								// EnableDisableItem(TaxaMHdl, xxxxFilterTaxaItem, (infoWindow[taxinfo] = frontwindow)|(infoWindow[charinfo] = frontwindow));								{EnableDisableItem(CharactersMHdl, xxxxFilterCharactersItem, infoWindow[charinfo] = frontwindow);}								EnableDisableItem(CharactersMHdl, xxxxAddEmptyCharacterItem, infoWindow[charinfo] = frontwindow);								EnableDisableItem(TaxaMHdl, AddEmptyTaxaItem, infoWindow[taxinfo] = frontwindow);								EnableDisableItem(EdUtilitiesMHdl, SearchAndReplaceItem, infoWindow[charinfo]=frontWindow);							end;					end;				if IsEditorWindow(frontwindow) then					begin						if not Locked(lockData)  then							begin								{myEnableItem(CharactersMHdl, xxxxFilterCharactersItem);}								// myEnableItem(TaxaMHdl, xxxxFilterTaxaItem);							end;					end				else if IsInfoWindow(FrontWindow) then					begin						whichInfo := WhichInfoWindow(frontWindow);						case whichinfo of							charinfo:								begin									EnableDisableItem(CharPartListMHdl, SetSelectedAsGroupItem,infoSomeSelected[charinfo]);									EnableDisableItem(xxCharacterSetsMHdl, StoreCharacterSetItem,infoSomeSelected[charinfo]);									if not Locked(lockData) then EnableDisableITem(EditMHdl, UndoItem, (LastChangeInEditor=lastChangeMoveCharacters));								end;							taxinfo:								begin									EnableDisableItem(xxTaxonSetsMHdl, StoreTaxonSetItem,infoSomeSelected[taxinfo]);									if not Locked(lockData) then EnableDisableITem(EditMHdl, UndoItem, (LastChangeInEditor=lastChangeMoveTaxa));								end;							taxsetinfo:								begin									EnableDisableItem(xxTaxonSetsMHdl, StoreTaxonSetItem,infoSomeSelected[taxinfo]);								end;							otherwise;						end;						if not Locked(lockData) &  ((LastChangeInEditor=lastChangeNameRow)& (undoWhichInfo=whichinfo)) then							myEnableItem(EditMHdl, UndoItem);					end;				if editorOpen then					FixFormatMenu;									EnableDisableItem(ExpFileMHdl, NBRFFileItem, molecular);				EnableDisableItem(ExpFileMHdl, NBRFNoGapsFileItem, molecular);				EnableDisableItem(ExpFileMHdl, FastaItem, molecular);				FixCharMenu;			end;	end;{-----------------------------------------------------------------------------}	procedure FixTreeShadingMenus;	begin		myCheckMenuItem(TraceMHdl, TraceAllChangesItem, (traceshown = traceAllChanges));		EnableDisableItem(TraceMHdl, TraceAllChangesItem, numtaxain > 1);		myCheckMenuItem(TraceMHdl, TraceAllStatesItem, (traceshown = traceAllStates));		if (traceshown = traceAllChanges) then			begin				if BranchListmode = unambigmode then					SetWTitle(BranchListWindow, 'Unambiguous Changes')				else if BranchListmode = ambigmode then					SetWTitle(BranchListWindow, 'Almost All Possible Changes')				else if branchlistmode = maxmode then					SetWTitle(Branchlistwindow, 'All Possible Changes')				else if branchlistmode = minmaxmode then					SetWTitle(Branchlistwindow, 'Unambiguous and (All Possible) Changes')				else					SetWTitle(Branchlistwindow, '');				SetMenuItemText(SaveOtherMHdl, SvTxtNodeListItem, 'Branch List...');			end		else			begin				SetMenuItemText(SaveOtherMHdl, SvTxtNodeListItem, 'Node List...');				if (traceshown = traceAllStates) then					SetWTitle(BranchListWindow, 'States');			end;		FixSomeCharMenuitems;	end;{----------------------------------------------------------------------------}	procedure FixTreeUndoItem;	begin		if justundid then			SetMenuItemText(editMHdl, UndoItem, 'Redo')		else			case undotype of				justreroot: 					SetMenuItemText(editMHdl, UndoItem, 'Undo Rerooting');				justswap: 					SetMenuItemText(editMHdl, UndoItem, 'Undo Branch Swap');				justgot: 					SetMenuItemText(editMHdl, UndoItem, 'Undo Display Stored Tree');				justCollapseAll: 					SetMenuItemText(editMHdl, UndoItem, 'Undo Collapse');				justinEx: 					SetMenuItemText(editMHdl, UndoItem, 'Undo Inclusion-Exclusion');				justmove: 					begin						if nomove then							begin								if (undotonull = 0) then									SetMenuItemText(editMHdl, UndoItem, 'Undo Collapse')								else									SetMenuItemText(editMHdl, UndoItem, 'Undo Branch Move')							end						else							SetMenuItemText(editMHdl, UndoItem, 'Undo Branch Move');					end;				otherwise					SetMenuItemText(editMHdl, UndoItem, 'Undo Change');			end;	end;{----------------------------------------------------------------------------}	procedure FixStyleMenu (theStyleMHdl: MenuHandle; thestyle: Style);	begin		myCheckMenuItem(theStyleMHdl, PlainItem, thestyle = []);		myCheckMenuItem(theStyleMHdl, ItalicItem, italic in thestyle);		myCheckMenuItem(theStyleMHdl, BoldItem, bold in thestyle);		myCheckMenuItem(theStyleMHdl, UnderlineItem, underline in thestyle);		myCheckMenuItem(theStyleMHdl, ShadowItem, shadow in thestyle);		myCheckMenuItem(theStyleMHdl, OutlineItem, outline in thestyle);		myCheckMenuItem(theStyleMHdl, CondenseItem, condense in thestyle);		myCheckMenuItem(theStyleMHdl, ExtendItem, extend in thestyle);	end;{----------------------------------------------------------------------------}	procedure FixSizeMenu (theSizeMHdl: MenuHandle; thesize: integer);	begin		myCheckMenuItem(theSizeMHdl, S8Item, thesize = 8);		myCheckMenuItem(theSizeMHdl, S9Item, thesize = 9);		myCheckMenuItem(theSizeMHdl, S10Item, thesize = 10);		myCheckMenuItem(theSizeMHdl, S12Item, thesize = 12);		myCheckMenuItem(theSizeMHdl, S14Item, thesize = 14);		myCheckMenuItem(theSizeMHdl, S18Item, thesize = 18);		if not (thesize in [8, 9, 10, 12, 14, 18]) then			begin				SetMenuItemText(theSizeMHdl, SOtherItem, concat('Other (', StringFromNum(thesize), ')...'));				myCheckMenuItem(theSizeMHdl, SOtherItem, true);			end		else			begin				SetMenuItemText(theSizeMHdl, SOtherItem, 'Other...');				myCheckMenuItem(theSizeMHdl, SOtherItem, false);			end;	end;{----------------------------------------------------------------------------}	procedure FixFontMenu (theFontMHdl: MenuHandle; thefont: integer; namecheck: boolean);{shadows appropriate font menu items, and checks the one corresponding to thefont}{if namecheck is true}		var			j, k: integer;			ds: str255;	begin	{	for j := 1 to SOtherItem do			SetItemStyle(SizeMHdl, j, []);		if RealFont(thefont, 8) then			SetItemStyle(SizeMHdl, S8Item, [shadow]);		if RealFont(thefont, 9) then			SetItemStyle(SizeMHdl, S9Item, [shadow]);		if RealFont(thefont, 10) then			SetItemStyle(SizeMHdl, S10Item, [shadow]);		if RealFont(thefont, 12) then			SetItemStyle(SizeMHdl, S12Item, [shadow]);		if RealFont(thefont, 14) then			SetItemStyle(SizeMHdl, S14Item, [shadow]);		if RealFont(thefont, 18) then			SetItemStyle(SizeMHdl, S18Item, [shadow]);	}		if namecheck then			for j := 1 to myCountMenuItems(theFontMHdl) do				begin					GetMenuItemText(theFontMHdl, j, ds);					GetFNum(ds, k);					myCheckMenuItem(theFontMHdl, j, k = thefont);				end;	end;{----------------------------------------------------------------------------}	procedure FixPrintOtherMenu;	begin		if fileopen then			begin				EnableDisableItem(PrintOtherMHdl, PtTypesItem, (numtypes >= usedef));				EnableDisableItem(PrintOtherMHdl, PtFootTextItem, AnyFeet(footText));				EnableDisableItem(PrintOtherMHdl, PtFootPictsItem, AnyFeet(footPict));				EnableDisableItem(PrintOtherMHdl, PtGenCodeItem, molecular);				EnableDisableItem(PrintOtherMHdl, PtContinuousItem, numcontinuous > 0);				EnableDisableItem(PrintOtherMHdl, PtNodeListItem, treeopen & ((traceshown = traceProbability) | (traceshown = traceDiscrete) | (traceshown = traceAllChanges) | (traceshown = traceAllStates) | (traceshown = traceContinuous)));				if treeopen & ((traceshown = traceProbability) | (traceshown = traceDiscrete) | (traceshown = traceAllStates) | (traceshown = traceContinuous)) then					SetMenuItemText(PrintOtherMHdl, PtNodeListItem, 'Node List...')				else if treeopen & ((traceshown = traceAllChanges)) then					SetMenuItemText(PrintOtherMHdl, PtNodeListItem, 'Branch List...');			end;	end;{----------------------------------------------------------------------------}	procedure FixSelectMenuPrefixes (whichinfo: integer);{this adds * + in front of InfoSelectMenu}		var			j, menuitems: integer;	begin		menuitems := myCountMenuItems(InfoSelectMHdl);		for j := 1 to SaveSetItem[whichinfo]-2 do			if j <> infoSelectReverseItem then   {skip over Reverse}				case selectMode of					selectReplace: 						SetItemMark(InfoSelectMHdl, j, chr(NoMark));					selectUnion: 						if j <> infoSelectNoneItem then						 	SetItemMark(InfoSelectMHdl, j, '+');					selectIntersection: 						if j <> infoSelectAllItem then							SetItemMark(InfoSelectMHdl, j, '*');				end;		EnableDisableItem(InfoSelectMHdl, infoSelectAllItem,selectMode<>selectIntersection);		EnableDisableItem(InfoSelectMHdl, infoSelectNoneItem,selectMode<>selectUnion);	end;{----------------------------------------------------------------------------}	procedure EnableDisableSaveSetMenuItem (whichObject: integer);		var			whichChange: integer;	begin		if SaveSetItem[whichObject] > 0 then			EnableDisableItem(InfoSelectMHdl, SaveSetItem[whichObject], ((frontwindow = infoWindow[whichObject]) and infoSomeSelected[whichObject]));	end;{----------------------------------------------------------------------------}	procedure AppendSetsToMenu (theMHdl: MenuHandle; theChain: Integer);		var			j: integer;			ds: str255;	begin		for j := StartUserLink(theChain) to EndUserLink(theChain) do			begin				AppendMenu(theMHdl, ' ');				ds := LinkNameFromChain(theChain, j);				UnderLineToBlanks(ds);				SetMenuItemText(theMHdl, myCountMenuItems(theMHdl), ds);	{set name separately to avoid any characters in charset name being menu metacharacters}			end;	end;{----------------------------------------------------------------------------}	procedure AppendSetsToSelectMenu (whichObject: integer; theChain: Integer);		var			j: integer;			ds: str255;	begin		AppendSetsToMenu(InfoSelectMHdl,theChain);		AppendMenu(InfoSelectMHdl, '(-');		case whichObject of			charinfo: 				begin					AppendMenu(InfoSelectMHdl, 'Store Char Set...');					AppendMenu(InfoSelectMHdl, 'Rename-Delete Char Sets...');				end;			taxinfo: 				begin					AppendMenu(InfoSelectMHdl, 'Store Taxon Set...');					AppendMenu(InfoSelectMHdl, 'Rename-Delete Taxon Sets...');				end;			{changesetObject: 				begin					AppendMenu(InfoSelectMHdl, 'Store Change Set...');					AppendMenu(InfoSelectMHdl, 'Rename-Delete Change Sets...');				end;			stateSetObject: 				begin					AppendMenu(InfoSelectMHdl, 'Store State Set...');					AppendMenu(InfoSelectMHdl, 'Rename-Delete State Sets...');				end;}			otherwise				;		end;		RenameDeleteSetMenuItem[whichObject] := myCountMenuItems(InfoSelectMHdl);		SaveSetItem[whichObject] := RenameDeleteSetMenuItem[whichObject] - 1;		EnableDisableItem(InfoSelectMHdl, RenameDeleteSetMenuItem[whichObject], UserLinks[theChain] > 0);		EnableDisableSaveSetMenuItem(whichObject);	end;{----------------------------------------------------------------------------}	procedure RebuildCharSetsMenu(theMHdl: MenuHandle; includeGapRuns: boolean; var itemNumOfExcluded: integer);		var			CharHdl: chHdl;			menucode: longint;			ItemNo, currentsel, j, ic: integer;			ds: str255;	begin{if these are changed, need to change 	ShadeCharacter in EditorCellEntry	the ShadeCharacterSets in Globals  (search for AllShadeCharSet)	setEditorFileID setting number value in Settings 	DoInfoWindowSelectMenu in Selection.p}		AppendMenu(theMHdl, 'Included');		AppendMenu(theMHdl, 'Excluded');		itemNumOfExcluded := myCountMenuItems(theMHdl);				AppendMenu(theMHdl, 'Invariant');		AppendMenu(theMHdl, 'All Gaps or Missing');		AppendMenu(theMHdl, '10, 20, 30, 40, etc.');		if molecular & includeGapRuns then			AppendMenu(theMHdl, 'Gap Runs...');		if nucleotides then			begin				AppendMenu(theMHdl, 'Protein Coding');				AppendMenu(theMHdl, 'Non-Coding');				AppendMenu(theMHdl, 'Every 1st Position');				AppendMenu(theMHdl, 'Every 2nd Position');				AppendMenu(theMHdl, 'Every 3rd Position');			end;	end;{----------------------------------------------------------------------------}	procedure CheckSelectMode;	begin		if OptionEvent(Event) then			begin				if selectMode <> selectIntersection then					begin						selectMode := selectIntersection;					end			end		else if ShiftEvent(Event) or CommandEvent(Event) then			begin				if selectMode <> selectUnion then					begin						selectMode := selectUnion;					end;			end		else if selectMode <> selectReplace then			begin				selectMode := selectReplace;			end;	end;{----------------------------------------------------------------------------}	procedure FixSelectMenu (whichinfo: integer);	begin		CheckSelectMode;		FixSelectMenuPrefixes(whichinfo);		{if OptionEvent(Event) then			begin				if selectMode <> selectIntersection then					begin						selectMode := selectIntersection;						FixSelectMenuPrefixes(whichinfo);					end			end		else if ShiftEvent(Event) or CommandEvent(Event) then			begin				if selectMode <> selectUnion then					begin						selectMode := selectUnion;						FixSelectMenuPrefixes(whichinfo);					end;			end		else if selectMode <> selectReplace then			begin				selectMode := selectReplace;				FixSelectMenuPrefixes(whichinfo);			end;}		EnableDisableSaveSetMenuItem(whichinfo);	end;{----------------------------------------------------------------------------}	procedure RebuildSelectMenu (whichObject: integer);	{as it now stands, the ONLY place this can be called is in ConvertToInfoSelectSubMenu in Activates,	as that procedure does the necessary clean-up, which other procedures don't do.}	var itemNumOfExcluded: integer;	begin		 if whichObject <= numinfowindows then			if frontwindow = infoWindow[whichObject] then				begin					case whichObject of						charinfo: 							begin								RebuildCharSetsMenu(InfoSelectMHdl, true, itemNumOfExcluded);								FirstUserSetMenuItem[whichObject] := myCountMenuItems(InfoSelectMHdl) + 1;								AppendSetsToSelectMenu(whichObject, charSetChain);							end;						taxinfo: 							begin								AppendMenu(InfoSelectMHdl, 'Included in tree');								EnableDisableItem(InfoSelectMHdl,myCountMenuItems(InfoSelectMHdl),treeopen);								AppendMenu(InfoSelectMHdl, 'Excluded from tree');								EnableDisableItem(InfoSelectMHdl,myCountMenuItems(InfoSelectMHdl),treeopen);								FirstUserSetMenuItem[whichObject] := myCountMenuItems(InfoSelectMHdl) + 1;								AppendSetsToSelectMenu(whichObject, taxSetChain);							end;						otherwise							FirstUserSetMenuItem[whichObject] := myCountMenuItems(InfoSelectMHdl) + 1;					end;				end;	end;{-----------------------------------------------------------------------------}	procedure ConvertToInfoSelectSubMenu (whichObject: integer);	var theMark: integer;	begin		DeleteMenu(SimpleSelectMenu);		ZapAndReInsertMenu(InfoSelectMenu,InfoSelectMHdl);		SwitchSubmenus(EditMHdl,SelectItem,InfoSelectMenu);		RebuildSelectMenu(whichObject);		  {with just this removed, still crashes}		{with all but zaps in both procedures, doesn't crash}	end;{-----------------------------------------------------------------------------}	procedure ConvertToSimpleSelectSubMenu;	begin		DeleteMenu(InfoSelectMenu);		InsertMenu(SimpleSelectMHdl, -1);		SwitchSubmenus(EditMHdl,SelectItem,SimpleSelectMenu);	end;{----------------------------------------------------------------------------}	procedure CheckShadeCharSetMenu;	var j: integer;	begin		for j:= FirstShadeCharSetItem to myCountMenuItems(ShadeCharSetMHdl) do			myCheckMenuItem(ShadeCharSetMHdl,j,false);		myCheckMenuItem(ShadeCharSetMHdl,editorCharacterSetToShade+FirstShadeCharSetItem-1,true);		myCheckMenuItem(ShadeCharSetMHdl,ShadeDarkerItem,not editorShadeCharSetLighter);		myCheckMenuItem(ShadeCharSetMHdl,ShadeLighterItem,editorShadeCharSetLighter);		myCheckMenuItem(ShadeCharSetMHdl,ShadeTitlesItem,editorShadeCharSetTitle);		myCheckMenuItem(ShadeCharSetMHdl,ShadeCellsItem,editorShadeCharSetCells);		myCheckMenuItem(ShadeCharSetMHdl,ShadeNumbersItem,editorShadeCharSetNumbers);	end;{----------------------------------------------------------------------------}	procedure RebuildShadeCharSetMenu;	var itemNumOfExcluded : integer;	begin		DeleteMenu(ShadeCharSetMenu);		//ShadeCharSetMHdl := GetMenuHandle(ShadeCharSetMenu); 		ZapAndReInsertMenu(ShadeCharSetMenu,ShadeCharSetMHdl);		//SwitchSubmenus(EWDisplayMHdl,ShadeCharSetMenuItem,ShadeCharSetMenu);		ShadeCharSetMHdl := GetMenuHandle(ShadeCharSetMenu); 		RebuildCharSetsMenu(ShadeCharSetMHdl, false, itemNumOfExcluded);		ShadeExcludedItem := itemNumOfExcluded;  //store this for use by data matrix style submenu				FirstUserShadeCharSet := myCountMenuItems(ShadeCharSetMHdl) -FirstShadeCharSetItem+ 2;  		AppendSetsToMenu(ShadeCharSetMHdl, charSetChain);		LastUserShadeCharSet := myCountMenuItems(ShadeCharSetMHdl) -FirstShadeCharSetItem+ 1;	{	LastUserShadeCharSet< FirstUserShadeCharSet then}	{	AppendMenu(ShadeCharSetMHdl, '(-');		AppendMenu(ShadeCharSetMHdl, 'Nucleotides with AA translation');}		{DimDNAwithAAItem := myCountMenuItems(ShadeCharSetMHdl);}		CheckShadeCharSetMenu;						{titles}		{cells}		{-}		{Darken}		{Lighten}		{-}		{FirstShadeCharSetItem = 7}  {1}		{8}		{9}		{10}		{11   FirstUserShadeCharSet=5}  		{12 }		{13 }		{14   LastUserShadeCharSet=8}			end;{----------------------------------------------------------------------------}	procedure CheckConsensusTaxSetMenu;	var j: integer;	begin		for j:= 1 to myCountMenuItems(ConsensusTaxSetMHdl) do			myCheckMenuItem(ConsensusTaxSetMHdl,j,false);		if editorConsensusTaxSet = AllTaxSet then			myCheckMenuItem(ConsensusTaxSetMHdl,1,true)		else			myCheckMenuItem(ConsensusTaxSetMHdl,editorConsensusTaxSet+1,true)	end;{----------------------------------------------------------------------------}	procedure RebuildColorCodPosMenu;	begin		CheckColorCodPosMenu;	end;{----------------------------------------------------------------------------}	procedure CheckColorCodPosMenu;	begin		myCheckMenuItem(ColorCodPosMHdl,PartTitlesItem, editorColorCodPosTitle);		myCheckMenuItem(ColorCodPosMHdl,PartCellsItem, editorColorCodPosCells);		myCheckMenuItem(ColorCodPosMHdl,PartNumbersItem, editorColorCodPosNumbers);	end;{----------------------------------------------------------------------------}	procedure CheckColorCharPartitionMenu;	begin		myCheckMenuItem(ColorCharPartitionMHdl,PartTitlesItem, editorColorPartitionTitle);		myCheckMenuItem(ColorCharPartitionMHdl,PartCellsItem, editorColorPartitionCells);		myCheckMenuItem(ColorCharPartitionMHdl,PartNumbersItem, editorColorPartitionNumbers);	end;{----------------------------------------------------------------------------}	procedure CheckMismatchMenu;	var j: integer;	begin		for j := 1 to myCountMenuItems(MismatchMHdl) do			myCheckMenuItem(MismatchMHdl,j,false);		if flashRNARevCompNumMismatches+1<= myCountMenuItems(MisMatchMHdl) then			myCheckMenuItem(MisMatchMHdl,flashRNARevCompNumMismatches+1, true);	end;{----------------------------------------------------------------------------}	procedure RebuildConsensusTaxSetMenu;	begin		DeleteMenu(ConsensusTaxSetMenu);		ZapAndReInsertMenu(ConsensusTaxSetMenu,ConsensusTaxSetMHdl);		//SwitchSubmenus(EWDisplayMHdl,ShadeCharSetMenuItem,ShadeCharSetMenu);		AppendSetsToMenu(ConsensusTaxSetMHdl, taxSetChain);		CheckConsensusTaxSetMenu;	end;{-----------------------------------------------------------------------------}	procedure CheckChartViewsMenu;	begin		myCheckMenuItem(ChartViewsMHdl,ChartViewsChartItem,(CWView = histoview)|(CWView = scatterview));		myCheckMenuItem(ChartViewsMHdl,ChartViewsTableItem,(CWView = tableview));		myCheckMenuItem(ChartViewsMHdl,ChartViewsSummaryItem,(CWView =infoview));	end;{----------------------------------------------------------------------------}	procedure CheckShowMenu (theWindow: WindowPtr);	begin		if (theWindow=treeWindow) then			begin				myCheckMenuItem(ShowMHdl, BranchNumbersItem, shownodenumbers);				myCheckMenuItem(ShowMHdl, EvolveSegsItem, showEvolveSegments);{$IFC REALLENGTHS}				myCheckMenuItem(ShowMHdl, EvolveRealLengthsItem, showEvolveRealLengths);{$ENDC}				myCheckMenuItem(ShowMHdl, Nex7onItem, nex7on);				EnableDisableItem(ShowMHdl, ShrinkItem, expd);			end		else if (theWindow=editorWindow) then			begin				myCheckMenuItem(ShowMHdl, EWGridItem, grid);				myCheckMenuItem(ShowMHdl, EWTaxonNumbersItem, showtaxnum);				myCheckMenuItem(ShowMHdl, EWTaxonNamesItem, showtaxname);				myCheckMenuItem(ShowMHdl, EWCharacterNumbersItem, showcharnum);				myCheckMenuItem(ShowMHdl,EWCellSymbolsItem, editorShowCellSymbol);				myCheckMenuItem(ShowMHdl, EWStateNamesItem, editorShowFullStateNames);				myCheckMenuItem(ShowMHdl, EWUseIUPACItem, editorShowIUPACSymbols);			end		else if (theWindow=chartWindow) then			begin				myCheckMenuItem(ShowMHdl, ChartShowTitleItem, ShowChartTitle);				myCheckMenuItem(ShowMHdl, ChartShowGridItem, Chartgrid);			end;	end;{----------------------------------------------------------------------------}	procedure RebuildShowMenu (theWindow: WindowPtr);	begin		if editorOpen or treeopen  then			begin				ZapAndReInsertMenu(ShowMenu,ShowMHdl);				if (theWindow=treeWindow) then					begin						AppendMenu(ShowMHdl, 'Branch Numbers');   {BranchNumbersItem}						AppendMenu(ShowMHdl, 'Evolve Segments');   {EvolveSegsItem}						{AppendMenu(ShowMHdl, 'Evolve Lengths for HKY85');   EvolveRealLengthsItem}						AppendMenu(ShowMHdl, 'Data Boxes /B');						AppendMenu(ShowMHdl, 'All Clades');					end				else if (theWindow=editorWindow) then					begin						AppendMenu(ShowMHdl, 'Grid');						AppendMenu(ShowMHdl, 'Taxon Numbers');						AppendMenu(ShowMHdl, 'Taxon Names');						AppendMenu(ShowMHdl, 'Character Numbers');						AppendMenu(ShowMHdl, 'Symbols in Cells');						AppendMenu(ShowMHdl, 'State Names in Cells');						AppendMenu(ShowMHdl, 'IUPAC Symbols');						{AppendMenu(ShowMHdl, 'Colored Cells');						AppendMenu(ShowMHdl, 'Colored AA Translation');}{picture..}					end				else if (theWindow=chartWindow) then					begin						AppendMenu(ShowMHdl, 'Title');						AppendMenu(ShowMHdl, 'Grid');					end;				CheckShowMenu(theWindow);			end;	end;{----------------------------------------------------------------------------}	procedure TypesInUseMenu;{put bullets in front of all type names in use}		var			j: integer;	begin		for j := 1 to numtypes do			if j in curtypes then				SetItemMark(TypeMHdl, j, 'е')			else				SetItemMark(TypeMHdl, j, chr(NoMark));	end;{----------------------------------------------------------------------------}	procedure FixAssumpMenu;		var			maxtype, j,whichinfo: integer;	begin		maxtype := numtypes;		if numtypes > 32 then			maxtype := 32;{if so, remember to check before allowing use of menu items beyond 31}{$IFC NOT ALWAYSENABLED}		for j := 1 to maxtype do			myDisableItem(TypeMHdl, j);{$ENDC}		TypesInUseMenu;		myEnableItem(TypeMHdl, unordered);		myEnableItem(TypeMHdl, ordered);		EnableDisableItem(TypeMHdl, irreversible, (not treeopen or not nullson));		EnableDisableItem(TypeMHdl, fisher, (not treeopen or not nullson));		EnableDisableItem(TypeMHdl, dollo, not nucleotides & (not treeopen | not (nullson | ancon)));{  EnableDisableItem(TypeMHdl, irreversible, IsEditorWindow(frontwindow) | (treeopen and (polyreal | not nullson)) | (frontwindow = infoWindow[charinfo]));}{    EnableDisableItem(TypeMHdl, fisher, IsEditorWindow(frontwindow) | (treeopen and (polyreal | not nullson)) | (frontwindow = infoWindow[charinfo]));}{    if IsEditorWindow(frontwindow) | (treeopen and not nullson) | (frontwindow = infoWindow[charinfo]) then}		if not (treeopen and (nullson or ancon)) then			for j := usedef to maxtype do				myEnableItem(TypeMHdl, j);		if frontWindow=infoWindow[charinfo] then			EnableDisableItem(xxCharacterSetsMHdl, StoreCharacterSetItem,infoSomeSelected[charinfo])		else if frontWindow=infoWindow[taxinfo] then			EnableDisableItem(xxTaxonSetsMHdl, StoreTaxonSetItem,infoSomeSelected[taxinfo]);		if isInfoWindow(frontwindow) then			begin				whichinfo := WhichInfoWindow(frontwindow);				if InfoHasSelectSets(whichinfo) then					begin						EnableDisableItem(InfoSelectMHdl, SaveSetItem[whichinfo], infoSomeSelected[whichinfo]);						EnableDisableItem(InfoSelectMHdl, RenameDeleteSetMenuItem[whichinfo], UserLinks[SelectSetChainFromObjectInfo(whichinfo)] > 0); 					end;			end;	end;{----------------------------------------------------------------------------}	procedure ReBuildAssumpMenu;		var			j: integer;			tname: str32;	begin		InsertMenu(TypeMHdl, -1);		for j := myCountMenuItems(typeMHdl) downto usedef do			DeleteMenuItem(TypeMHdl, j);		for j := 1 to usedef - 1 do			begin				typeHdl := gettypeHdl(j);				if typeHdl^^.polar then					SetItemStyle(TypeMHdl, j, [italic]);			end;		for j := usedef to numtypes do	{adding user-defined types to menu}			begin				typeHdl := gettypeHdl(j);				AppendMenu(TypeMHdl, ' ');				tname := typeHdl^^.name;				SetMenuItemText(TypeMHdl, j, tname);  {set name separately to avoid any characters}																						{in type name being menu metacharacters}				if typeHdl^^.polar then					SetItemStyle(TypeMHdl, j, [italic]);			end;		FixAssumpMenu;		FixCharMenu;	end;{|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}{----------------------------------------------------------------------------}	procedure OpenFileMenus;	begin		SetNoWMBar;		ReBuildAssumpMenu;		myEnableItem(CharactersMHdl, 0);		myEnableItem(GDisplayMHdl, 0);		DrawMenuBar;		myEnableItem(WindowsMHdl, FileNotesItem);{$IFC NOT ALWAYSENABLED}		myDisableItem(FileMHdl, NewItem);		myDisableItem(FileMHdl, OpenItem);{$ENDC}		myEnableItem(FileMHdl, SaveDataItem);		myEnableItem(FileMHdl, SaveDataAsItem);		myEnableItem(FileMHdl, ExportItem);		myEnableItem(FileMHdl, ToTextItem);		myEnableItem(FileMHdl, CloseFileItem);		myEnableItem(FileMHdl, CloseWindowItem);		myEnableItem(FileMHdl, PrintingItem);		myEnableItem(FileMHdl, PrintOtherItem);		myEnableItem(FileMHdl, PageSetUpItem);		myEnableItem(FileMHdl, IOOptionsItem);		{SetItemMark(EditMHdl, SelectItem, char(noMark));}{$IFC NOT ALWAYSENABLED}		myDisableItem(EditMHdl, UndoItem);{$ENDC}		myEnableItem(EditMHdl, ContinuousEditItem);		myEnableItem(EditMHdl, LockControlItem);		myEnableItem(TreeMHdl, OpenTreeFileItem);{$IFC NOT ALWAYSENABLED}		myDisableItem(TreeMHdl, TreeListItem);		myDisableItem(TreeMHdl, StoreTreeItem);		myDisableItem(TreeMHdl, SaveTreeFileItem);		myDisableItem(TreeMHdl, SaveAsTreeFileItem);		myDisableItem(TreeMHdl, ExTreeFileItem);		myDisableItem(SaveOtherMHdl, svTxtWindowItem);{$ENDC}		EnableDisableItem(SaveOtherMHdl, SvTxtNodeListItem, treeopen & ((traceshown = traceProbability) | (traceshown = traceDiscrete) | (traceshown = traceAllChanges) | (traceshown = traceAllStates) | (traceshown = traceContinuous)));{$IFC NOT ALWAYSENABLED}		myDisableItem(CalcMHdl, LengthItem);		myDisableItem(TreeMHdl, IncExcTaxaItem);		myDisableItem(TreeMHdl, AllTermItem);{$ENDC}		FixCharMenu;	end;{-----------------------------------------------------------------------------}	procedure ClosedEditMenus;	begin{    SetMenuItemText(FileMHdl, PrintingItem, 'Print...');}		myEnableItem(TreeMHdl, TreeListItem);{$IFC NOT ALWAYSENABLED}		myDisableItem(EditMHdl, UndoItem);		myDisableItem(EditMHdl, CutItem);		myDisableItem(EditMHdl, CopyItem);		myDisableItem(EditMHdl, PasteItem);		myDisableItem(EditMHdl, ClearItem);		{myDisableItem(EditMHdl, SelectItem);}{		myDisableItem(TreeMHdl, SearchOptionsItem);}		myDisableItem(TreeMHdl, PolyRealItem);		myDisableItem(TaxaMHdl, AddEmptyTaxaItem);		myDisableItem(CharactersMHdl, xxxxAddEmptyCharacterItem);		myDisableItem(EdUtilitiesMHdl, ShuffleItem);				myDisableItem(EditMHdl,TransferSelectionItem);{    myDisableItem(EdUtilitiesMHdl, SpeakSetItem);}{    myDisableItem(EdUtilitiesMHdl, SpeakItem);}{$ENDC}	end;{----------------------------------------------------------------------------}	procedure OpenTraceMenus;	begin{SetMenuItemText(TraceMHdl, TraceCharItem, 'Other Character...');}		myEnableItem(TraceMHdl, TraceLastItem);		FixTreeShadingMenus;	end;{----------------------------------------------------------------------------}	procedure CloseTraceMenus;{v4: this is called in Trace Off menu but not when trace turned off by other means, such as}{by turning on continuous or trace all changes.  Why do we need a separate CloseTraceMenus procedure; why not}{just use universal FixTreeShadingMenus?  Notice I have moved the Trace Character vs. Other character switch to}{a procedure called by FixTreeShadingMenus}	begin		if treeopen then			begin				myDisableItem(TraceMHdl, TraceLastItem);				FixTreeShadingMenus;				myDisableItem(TWDisplayMHdl, BranchPatternsAndColorsItem);				myDisableItem(TWDisplayMHdl, TraceLabelItem);				myDisableItem(TWDisplayMHdl, BarDisplayOptionsItem);{$IFC FALSE}				myDisableItem(TWDisplayMHdl, BranchLengthsItem);{$ENDC}			end;	end;{----------------------------------------------------------------------------}	procedure OpenTreeMenus;	begin{$IFC NOT ALWAYSENABLED}		myDisableItem(EditMHdl, UndoItem);{$ENDC}		ClosedEditMenus;		myEnableItem(TreeMHdl, PolyRealItem);	{	myEnableItem(TreeMHdl, SearchOptionsItem);}		EnableDisableItem(xxCreateTreesMHdl, RandomTreeItem, numtaxa > 1);		if treeopen then			begin				EnableDisableItem(TreeMHdl, StoreTreeItem, not Locked(lockTrees));				if not noundo and not equivcycle then					myEnableItem(EditMHdl, UndoItem);				if ancon then					myEnableItem(TreeMHdl, AllTermItem);				CheckCalcMenu;				myCheckMenuItem(NewChartMHdl, ChartPrintItem, CWFullPrint);				myCheckMenuItem(NewChartMHdl, chartQuietRecalcItem, chartQuietRecalc);				myCheckMenuItem(WindowsMHdl, ToolPaletteItem, toolPaletteOpen[treeTools]);				if (traceshown = traceDiscrete) then					OpenTraceMenus				else					CloseTraceMenus;				if twfullscreen then					SetMenuItemText(TWDisplayMHdl, ZoomTWItem, 'Reduce Window')				else					SetMenuItemText(TWDisplayMHdl, ZoomTWItem, 'Expand Window');				if not ScreenInColor then					SetMenuItemText(TWDisplayMHdl, BranchPatternsAndColorsItem, 'Patterns...')				else					SetMenuItemText(TWDisplayMHdl, BranchPatternsAndColorsItem, 'Patterns & Colors...');				EnableDisableItem(ShowMHdl, ShrinkItem, expd);			end;		FixCharMenu;	end;{----------------------------------------------------------------------------}	procedure ClosedFileMenus;	begin		myDisableItem(WindowsMHdl, FileNotesItem);		{SetMenuItemText(FileMHdl, AboutFileItem, 'About...');}		myEnableItem(FileMHdl, NewItem);		myEnableItem(FileMHdl, OpenItem);		myDisableItem(EditMHdl, LockControlItem);		myDisableItem(FileMHdl, CloseFileItem);		myDisableItem(FileMHdl, CloseWindowItem);		myDisableItem(FileMHdl, SaveDataItem);		myDisableItem(FileMHdl, SaveDataAsItem);		myDisableItem(FileMHdl, ExportItem);		myDisableItem(FileMHdl, GraphicFileItem);		SetMenuItemText(FileMHdl, PrintingItem, 'Print Matrix...');		myDisableItem(FileMHdl, ToTextItem);		myDisableItem(FileMHdl, PrintingItem);		myDisableItem(FileMHdl, PrintOtherItem);		myDisableItem(FileMHdl, IOOptionsItem);		myDisableItem(FileMHdl, PageSetUpItem);		myDisableItem(EditMHdl,TransferSelectionItem);		FixEditMenu;		{myDisableItem(EditMHdl, SelectItem);}		myDisableItem(EditMHdl, ContinuousEditItem);		SetCloseFileMBar;		DrawMenuBar;	end;{----------------------------------------------------------------------------}	procedure SetStateNamesItem;	begin		{if nucleotides then			SetMenuItemText(ShowMHdl, EWStateNamesItem, 'IUPAC Symbols in Cells')		else} if molecular then			SetMenuItemText(ShowMHdl, EWStateNamesItem, 'Three-letter AA Names')		else			SetMenuItemText(ShowMHdl, EWStateNamesItem, 'State Names in Cells');		EnableDisableItem(ShowMHdl,EWUseIUPACItem,nucleotides);	end;{-----------------------------------------------------------------------------}	procedure EnableDisablePrimaryMenus(on: boolean);	var	theMenu : integer;	begin		for theMenu := firstMenu to lastMenu do			if MenuAvailable(theMenu) then				EnableDisableItem(GetMenuHandle(theMenu),0, on);		DrawMenuBar;	end;{----------------------------------------------------------------------------}	procedure EnableDisableMenu (theMenu: integer);{v4: use 2 global arrays: one for hierarchical, one for non-hierarchical - packed array of boolean storing if}{menu present.  Have a procedure that sets these arrays, called with  each SetMenuBar}		var			treetop, charttop: boolean;	begin{$IFC FALSE}		treetop := IsTreeWindow(frontwindow);		charttop := frontwindow = chartwindow;		if MenuAvailable(theMenu) then			case theMenu of				AppleMenu: 					begin{first item always enabled}					end;				FileMenu: 					begin						EnableDisableItem(FileMHdl, NewItem, not fileopen);						EnableDisableItem(FileMHdl, OpenItem, not fileopen);						EnableDisableItem(FileMHdl, CloseFileItem, fileopen);						EnableDisableItem(WindowsMHdl, FileNotesItem, fileopen);						EnableDisableItem(FileMHdl, SaveDataItem, fileopen);						EnableDisableItem(FileMHdl, SaveDataAsItem, fileopen);						EnableDisableItem(FileMHdl, ExportItem, fileopen);{    IOOptionsItem always enabled}						EnableDisableItem(FileMHdl, GraphicFileItem, fileopen and (treetop or (frontwindow = pictwindow) or (charttop & (CWview in [scatterview, histoview]))));						EnableDisableItem(FileMHdl, ToTextItem, fileopen);						EnableDisableItem(FileMHdl, PageSetUpItem, fileopen);						EnableDisableItem(FileMHdl, PrintingItem, fileopen);  {SetMenuItemText in several places}						EnableDisableItem(FileMHdl, PrintOtherItem, fileopen);  {etc?}{    PreferenceItem  always enabled}{    QuitItem  always enabled}					end;				otherwise					;			end;{$ENDC}	end;{----------------------------------------------------------------------------}	procedure EnableDisableAllMenus;		var			theMenu: integer;	begin		{for theMenu := firstMenu to lastMenu do			EnableDisableMenu(theMenu);		for theMenu := firstHierarchicalMenu to lastHierarchicalMenu do			EnableDisableMenu(theMenu);}	end;{----------------------------------------------------------------------------}	procedure SetTWMBar;	begin		SetMenuBar(TWMBar);		AppleMHdl := GetMenuHandle(AppleMenu);		EditMHdl := GetMenuHandle(EditMenu);		FileMHdl := GetMenuHandle(FileMenu);		CharactersMHdl := GetMenuHandle(CharactersMenu);		TaxaMHdl := GetMenuHandle(TaxaMenu);		WindowsMHdl := GetMenuHandle(WindowsMenu);		TreeMHdl := GetMenuHandle(TreeMenu);		TraceMHdl := GetMenuHandle(TraceMenu);		TWDisplayMHdl := GetMenuHandle(TWDisplayMenu);		NewChartMHdl := GetMenuHandle(NewChartMenu);		CalcMHdl := GetMenuHandle(CalcMenu);		ChartDisplayMHdl := GetMenuHandle(ChartDisplayMenu);	end;{----------------------------------------------------------------------------}	procedure SetEWMBar;	begin		SetMenuBar(EWMBar);		AppleMHdl := GetMenuHandle(AppleMenu);		EditMHdl := GetMenuHandle(EditMenu);		FileMHdl := GetMenuHandle(FileMenu);		CharactersMHdl := GetMenuHandle(CharactersMenu);		TaxaMHdl := GetMenuHandle(TaxaMenu);		WindowsMHdl := GetMenuHandle(WindowsMenu);		//if (ShadeCharSetMHdl<> nil) then		//	InsertMenu(ShadeCharSetMHdl, -1);				EWDisplayMHdl := GetMenuHandle(EWDisplayMenu);		EdUtilitiesMHdl := GetMenuHandle(EdUtilitiesMenu);	end;{----------------------------------------------------------------------------}	procedure SetNoWMBar;	begin		SetMenuBar(NoWMBar);		AppleMHdl := GetMenuHandle(AppleMenu);		EditMHdl := GetMenuHandle(EditMenu);		FileMHdl := GetMenuHandle(FileMenu);		WindowsMHdl := GetMenuHandle(WindowsMenu);		TreeMHdl := GetMenuHandle(TreeMenu);		GDisplayMHdl := GetMenuHandle(GDisplayMenu);	end;{----------------------------------------------------------------------------}	procedure SetCloseFileMBar;	begin		SetMenuBar(CloseFileMBar);		AppleMHdl := GetMenuHandle(AppleMenu);		EditMHdl := GetMenuHandle(EditMenu);		FileMHdl := GetMenuHandle(FileMenu);	end;{----------------------------------------------------------------------------}	procedure SetChartMBar;	begin		SetMenuBar(ChartMBar);		AppleMHdl := GetMenuHandle(AppleMenu);		EditMHdl := GetMenuHandle(EditMenu);		FileMHdl := GetMenuHandle(FileMenu);		CharactersMHdl := GetMenuHandle(CharactersMenu);		TaxaMHdl := GetMenuHandle(TaxaMenu);		WindowsMHdl := GetMenuHandle(WindowsMenu);		TreeMHdl := GetMenuHandle(TreeMenu);		TraceMHdl := GetMenuHandle(TraceMenu);		NewChartMHdl := GetMenuHandle(NewChartMenu);		CalcMHdl := GetMenuHandle(CalcMenu);		ChartDisplayMHdl := GetMenuHandle(ChartDisplayMenu);	end;{----------------------------------------------------------------------------}	procedure SetEquivMBar;	begin		SetMenuBar(EquivMBar);		EquivMHdl := GetMenuHandle(EquivMenu);		AppleMHdl := GetMenuHandle(AppleMenu);		EditMHdl := GetMenuHandle(EditMenu);		FileMHdl := GetMenuHandle(FileMenu);	end;{----------------------------------------------------------------------------}	procedure GetFreshMenuHandles;	begin{$IFC CARBON}		AppleMHdl := GetMenuHandle(AppleMenu);		EditMHdl := GetMenuHandle(EditMenu);		FileMHdl := GetMenuHandle(FileMenu);		CharactersMHdl := GetMenuHandle(CharactersMenu);		TaxaMHdl := GetMenuHandle(TaxaMenu);		WindowsMHdl := GetMenuHandle(WindowsMenu);		TreeMHdl := GetMenuHandle(TreeMenu);		TraceMHdl := GetMenuHandle(TraceMenu);		NewChartMHdl := GetMenuHandle(NewChartMenu);		CalcMHdl := GetMenuHandle(CalcMenu);				TWDisplayMHdl := GetMenuHandle(TWDisplayMenu);		EWDisplayMHdl := GetMenuHandle(EWDisplayMenu);		EdUtilitiesMHdl := GetMenuHandle(EdUtilitiesMenu);		ChartDisplayMHdl := GetMenuHandle(ChartDisplayMenu);		GDisplayMHdl := GetMenuHandle(GDisplayMenu);		EquivMHdl := GetMenuHandle(EquivMenu);{$ENDC}	end;end.