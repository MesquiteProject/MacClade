unit Activates;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, 		Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, 		Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, TaxonCHUtil, 		CharUtil, BoxUtil, MenuUtil, TreeUtil, SpreadUtil, Legends, InfoWindows, EditorCellEntry, StatesWindow,Flash;	procedure SetInfoWindowButtonActivate(whichinfo: integer);	procedure InfoWindowDeActivate (whichinfo: integer; oldUpdatePending: boolean);	procedure SelectEditorWindows;	procedure SelectTreeWindows;	procedure DoActivates (targetwindow: WindowPtr);	procedure DoDeActivates (targetwindow: WindowPtr; suspending:boolean);	procedure DeActivateAllWindows;	procedure DealwthActivates;	var		oldScreenInColor: boolean;{еееееееееееееееееееееее}implementation {е$S Activates}{-----------------------------------------------------------------------------}	procedure SetInfoWindowButtonActivate(whichinfo: integer);	var whichRow: longint;		oldClip: RgnHandle;	begin		if infoWithButtons[whichinfo] & ((whichinfo<>charinfo)|treeopen) then			begin				oldClip := NewRgn;				GetClip(oldClip);				ClipRect(WindowPortRect(infoWindow[whichinfo]));				if SingleInfoRowSelected(whichinfo, whichRow) then					DoActivateControl(infoWindowButton[whichinfo])				else					DoDeactivateControl(infoWindowButton[whichinfo]);				DrawControls(infoWindow[whichinfo]);				SetClip(oldClip);			end;	end;{-----------------------------------------------------------------------------}	procedure InfoSelActivate (whichinfo: integer; activ: boolean);{activates or deactivates selection in infowindow}		var			ic, j: integer;			numElements: integer;			tempP: windowPtr;	begin		genericGetPort(tempP);		genericSetPort(infoWindow[whichinfo]);		if infoSomeSelected[whichinfo] then			begin				if activ then					InvalidateWindow(infoWindow[whichinfo], false)				else					begin						numElements := MaximumInfoRows(whichinfo);						for ic := 1 to numElements do   {only have to do it over selected ones}							if InfoRowSelected(whichinfo, ic) & InfoRowVisible(whichinfo, ic) then{$IFC COLORINFOBACKGROUND}								InvertRect(InfoRowBox(whichinfo, InfoHeight(whichinfo, ic)));{$ELSEC}								InvertHiliteRect(InfoRowBox(whichinfo, InfoHeight(whichinfo, ic)));{$ENDC}					end;			end;		genericSetPort(tempP);	end;{-----------------------------------------------------------------------------}	procedure InfoWindowActivate (whichinfo: integer);	begin		DoActivateControl(infoScroll[whichinfo]);		DoActivateControl(infoHScroll[whichinfo]);		SetInfoWindowButtonActivate(whichinfo);		SetMenuItemText(FileMHdl, PrintingItem, 'Print List...');		InfoSelActivate(whichinfo, true);		myEnableItem(SaveOtherMHdl, svTxtWindowItem);		SetMenuItemText(SaveOtherMHdl, svTxtWindowItem, 'Save List as Text...');		DrawGrowBox(infoWindow[whichinfo]);		ConvertToInfoSelectSubMenu(whichinfo);		{if treeopen then			if frontwindow=chartwindow then				ChartDisplayMHdl := GetMenuHandle(ChartDisplayMenu)			else				TWDisplayMHdl := GetMenuHandle(TWDisplayMenu)		else if editoropen then			EWDisplayMHdl := GetMenuHandle(EWDisplayMenu)		else			GDisplayMHdl := GetMenuHandle(GDisplayMenu);}		{RebuildSelectMenu(whichinfo);}	end;{-----------------------------------------------------------------------------}	procedure InfoWindowDeActivate (whichinfo: integer; oldUpdatePending: boolean);	begin		ReturnInfoValue(whichinfo);		InfoSelActivate(whichinfo, false);		DoDeactivateControl(infoScroll[whichinfo]);		DoDeactivateControl(infoHScroll[whichinfo]);		if infoWithButtons[whichinfo] & ((whichinfo<>charinfo)|treeopen) then			DoDeactivateControl(infoWindowButton[whichinfo]);	{	if not oldUpdatePending then			ValidRect(WindowPortRect(infowindow[whichInfo]));}		DrawGrowBox(infoWindow[whichinfo]);		ConvertToSimpleSelectSubMenu;		ReturnComplexDisplayMenu;	end;{-----------------------------------------------------------------------------}	procedure SelectTreeWindows;{selects the treewindows}		var			tempP: windowPtr;	begin		SelectWindow(TreeWindow);		SelectWindow(twmesswindow);		SelectWindow(tlegwindow);{if PaintedBranches then     - sometimes chlegwindow needed even if not paintedbranches}		SelectWindow(chlegwindow);		if (traceshown = traceAllChanges) or (traceshown = traceAllStates) then			SelectWindow(branchlistwindow);		if toolPaletteOpen[treeTools] then			SelectWindow(toolPaletteWindow[treeTools]);{ here (traceshown = traceAllStates) was not in the above question, and this seems to have been the cause of the cyclical flashing}{of windows that occurred when show all states was on with branchliston, char type changed in Char status window, then}{click on tree}{where necessary}				//DoActivateControl(vTWScroll);		//DoActivateControl(hTWScroll);		FlushEvents(ActivateEvt, 0);	end;{-----------------------------------------------------------------------------}	procedure DeSelectTreeWindows;{deselects treewindows}		var			tempP: windowPtr;	begin		genericGetPort(tempP);		genericSetPort(treewindow);		DoDeactivateControl(vTWScroll);		DoDeactivateControl(hTWScroll);		DoDeactivateControl(chlegScroll);		DoDeactivateControl(tlegScroll);		WriteLegendTitles;		HiliteWindow(treewindow, false);		HiliteWindow(toolPaletteWindow[treeTools], false);{$IFC CARBON}		if WindowVisible(tlegWindow) then			HiliteWindow(tlegwindow, false);		if WindowVisible(chlegWindow) then			HiliteWindow(chlegwindow, false);{$ENDC}		genericSetPort(tempP);	end;{-----------------------------------------------------------------------------}	procedure SelectEditorWindows;{selects the editorwindows}	begin		SelectWindow(editorWindow);		if toolPaletteOpen[editorTools] then			SelectWindow(toolPaletteWindow[editorTools]);		FlushEvents(ActivateEvt, 0);	end;{-----------------------------------------------------------------------------}	procedure DoThermoActivates (targetwindow: WindowPtr; theDialog: DialogPtr; on: boolean);	begin		if (TargetWindow = myGetWindowPtrForDialog(theDialog)) & (theDialog<>nil) then			begin				HiliteWindow(myGetWindowPtrForDialog(theDialog), on);				DrawDialog(theDialog);			end	end;{-----------------------------------------------------------------------------}	procedure DoActivates (targetwindow: WindowPtr);		var			nW: WindowPtr;			aWindow: WindowPtr;			tev: EventRecord;			whichinfo, j: integer;			whichText: integer;			tempP: WindowPtr;			bringnext, reorderwinds, encounteredTW, foreignWindow: boolean;{.............................}		function TreeCompanionWindow (nw: WindowPtr): boolean;		begin			TreeCompanionWindow := (nW = branchlistwindow) or (nW = twmesswindow) or (nW = tlegwindow) or (nW = toolPaletteWindow[treeTools]) or (nW = chlegwindow);		end;{.............................}		procedure ReOrderTreeWindows; {this procedure checks to see if treewindows need reordering, and does it if necessary}		begin			reorderwinds := false;			encounteredTW := false;			foreignwindow := false;			aWindow := frontwindow;			while (myGetNextWindow(aWindow) <> nil) and not reorderwinds do				begin					nW := myGetNextWindow(aWindow);					while (nW <> nil) & not WindowVisible(nW) do    {check for visibility to avoid bringing up invisible windows}						nW := myGetNextWindow(nW);					if (aWindow = treewindow) and WindowVisible(aWindow) then						encounteredTW := true 			{current is treewindow}					else if not TreeCompanionWindow(aWindow) and WindowVisible(aWindow) then						foreignwindow := true;    		  {the current window is foreign}{we've encountered a the tree window or a foreign window, }{in which case if the next window is a treecompanion window,}{then the order is screwed up}					if (nW <> nil) & ((encounteredTW | foreignWindow) & (TreeCompanionWindow(nW) & WindowVisible(nW))) then						reorderWinds := true;					aWindow := myGetNextWindow(aWindow);				end;			if Reorderwinds then				begin					if foreignWindow then						SelectTreeWindows					else						SelectWindow(nW);				end;		end;{.............................}		procedure ReOrderEditorWindows; {this procedure checks to see if treewindows need reordering, and does it if necessary}		begin			reorderwinds := false;			encounteredTW := false;			foreignwindow := false;			aWindow := frontwindow;			while (myGetNextWindow(aWindow) <> nil) and not reorderwinds do				begin					nW := myGetNextWindow(aWindow);					while (nW <> nil) & not WindowVisible(nW) do    {check for visibility to avoid bringing up invisible windows}						nW := myGetNextWindow(nW);					if (aWindow = editorWindow) and WindowVisible(aWindow) then						encounteredTW := true 			{current is treewindow}					else if (aWindow <> toolPaletteWindow[editorTools]) and WindowVisible(aWindow) then						foreignwindow := true;    		  {the current window is foreign}{we've encountered a the tree window or a foreign window, }{in which case if the next window is a treecompanion window,}{then the order is screwed up}					if (nW <> nil) & ((encounteredTW | foreignWindow) & ((nW = toolPaletteWindow[editorTools])& WindowVisible(nW))) then						reorderWinds := true;					aWindow := myGetNextWindow(aWindow);				end;			if Reorderwinds then				begin					if foreignWindow then						SelectEditorWindows					else						SelectWindow(nW);				end;		end;{.............................}	begin		myDisableItem(FileMHdl, GraphicFileItem);		if MacCladeWindow(targetWindow) then			begin				aWindow := TargetWindow;				{^&* theWindow := TargetWindow;}				genericSetPort(TargetWindow);{$IFC NOT ALWAYSENABLED}				{Davidundo: myDisableItem(EditMHdl, UndoItem);}{$ENDC}				ReadDeskScrap;				BackColor(whitecolor);				CheckPixelDepth(targetWindow);				if oldScreenInColor <> screenInColor then					begin						if treeopen then							begin								InvalidateWindow(treewindow, true);								InvalidateWindow(chlegwindow, true);								InvalidateWindow(toolPaletteWindow[treeTools], true);								if charton then									InvalidateWindow(chartwindow, true);								if not ScreenInColor then									SetMenuItemText(TWDisplayMHdl, BranchPatternsAndColorsItem, 'Patterns...')								else									SetMenuItemText(TWDisplayMHdl, BranchPatternsAndColorsItem, 'Patterns & Colors...');							end;						for j := 1 to numinfowindows do							if infoOpen[j] then								InvalidateWindow(infoWindow[j], true);						if editorOpen then							InvalidateWindow(editorWindow, true);						InvalidateWindow(statesWindow, true);						oldScreenInColor := screenInColor;					end;				if IsEditorWindow(TargetWindow)  then					begin						{genericSetPort(editorWindow); }						SetEWMBar;						ConvertToSimpleSelectSubMenu;						RebuildShadeCharSetMenu;						genericSetPort(editorWindow);						ClipRect(WindowPortRect(editorWindow)); 						if editorSelected & SingleCell then							begin								if CellVisible(editorSelectionTopLeft, editorSelectionBotRight) then									TEActivate(editorCellTE);								TEActivate(noteTE);							end;						if not IsEditorWindow(frontWindow) then							SelectEditorWindows						else   {edit window is on top; check to see if editwindows all together in right order}							ReOrderEditorWindows;						ReturnComplexDisplayMenu;						RebuildConsensusTaxSetMenu;						HiliteWindow(editorWindow, true);						DoActivateControl(editorVScroll);						DoActivateControl(editorHScroll);						mySetPortTextFont(editorWindow,editorFont);						mySetPortTextSize(editorWindow,editorFontSize);{$IFC NOT ALWAYSENABLED}						{Davidundo: myDisableItem(EditMHdl, UndoItem);}{$ENDC}						FixFontMenu(FontMHdl,editorFont, true);						FixSizeMenu(SizeMHdl,editorFontSize);						SetMenuItemText(FileMHdl, PrintingItem, 'Print Matrix...');						SetPrintExtraItem(editorWindow);						{SetItemMark(EditMHdl, SelectItem, char(0));						SetMenuItemText(EditMHdl, SelectItem, 'Select All');						SetItemCmd(EditMHdl, SelectItem, 'A');}						DrawGrowBox(editorWindow);						{RebuildShowMenu(editorWindow);}						ShowFlash;											end				else if IsTreeWindow(targetwindow) then		{it is one of the treewindows: toolPaletteWindow[treeTools],tlegwindow,chlegwindow,treewindow,tmesswindow}					begin						{^&* theWindow := TreeWindow;}						if equivcycle then							SetEquivMBar						else							SetTWMBar;{$IFC FALSE}						if EventAvail(updateMask, tev) then							if myGetWindowPtrFromEventMessage(tev) = treewindow then								treeonscreen := false;{$ENDC}						WriteLegendTitles;						if not IsTreeWindow(frontwindow) then							SelectTreeWindows						else   {tree window is on top; check to see if treewindows all together in right order}							begin								ReOrderTreeWindows;							end;						if toolPaletteOpen[treeTools] then							HiliteWindow(toolPaletteWindow[treeTools], true);						HiliteWindow(treewindow, true);{$IFC CARBON}						if WindowVisible(tlegWindow) then							HiliteWindow(tlegwindow, true);						if WindowVisible(chlegWindow) then							HiliteWindow(chlegwindow, true);{$ENDC}						DoActivateControl(vTWScroll);						DoActivateControl(hTWScroll);						if not equivcycle then							begin								if (UserLinks[treechain] > 0) then									DoActivateControl(tlegscroll);								if (traceshown = tracediscrete) then									DoActivateControl(chlegscroll);							end;						FixFontMenu(FontMHdl,treetaxafont, true);						FixSizeMenu(SizeMHdl,treetaxafontsize);						FixStyleMenu(StyleMHdl,treetaxaStyle);						SetPrintExtraItem(treeWindow);						SetMenuItemText(FileMHdl, PrintingItem, 'Print Tree...');						RebuildShowMenu(treewindow);						myEnableItem(TWDisplayMHdl, ZoomTWItem);						myEnableItem(xxCreateTreesMHdl, RandomTreeItem);						myEnableItem(FileMHdl, GraphicFileItem);						DrawGrowBox(treeWindow);					end				else					begin						if IsInfoWindow(TargetWindow) then							begin								if treeopen then									begin										if equivcycle then											SetEquivMBar										else											SetTWMBar;									end								else if editorOpen then									SetEWMBar								else									SetNoWMBar;								whichinfo := WhichInfoWindow(TargetWindow);								case whichinfo of									charinfo: 										if {editorOpen and } dirtymaxst then											ReCalcMaxstAndStates(1,numchars);									otherwise										;								end;								ReturnGDisplayMenu;								FixFontMenu(FontMHdl,infoFont[whichinfo], true);								FixSizeMenu(SizeMHdl,infoFontSize[whichinfo]);																InfoWindowActivate(whichinfo);								{### myDisableItem(FileMHdl,PrintExtraItem);}								{### if (whichinfo=treeinfo) & infoSomeSelected[treeinfo] then									myEnableItem(FileMHdl,PrintExtraItem);}							end						else if TargetWindow = ChartWindow then							begin								CheckPixelDepth(Chartwindow);								SetChartMBar;								ReBuildShowMenu(chartWindow);								FixFontMenu(FontMHdl,CWfont, true);								FixSizeMenu(SizeMHdl,CWfontsize);								FixStyleMenu(StyleMHdl,CWStyle);  {v3.02: added & CWLinear in following line}								if ((CWView = infoview) & CWLinear) | (CWLinear & ((CWView = tableview) | ((CWView = histoview) & (biggraph & isforeground)))) then									begin										DoActivateControl(CWScroll);										{ShowControl(CWScroll);}									end;								EnableDisableItem(FileMHdl, GraphicFileItem, CWview in [scatterview, histoview]);								myEnableItem(SaveOtherMHdl, svTxtWindowItem);								SetMenuItemText(SaveOtherMHdl, svTxtWindowItem, 'Save Chart as Text...');								myEnableItem(NewChartMHdl, ChartPrintItem);{myEnableItem(NewChartMHdl, ChartquietRecalcItem);}								EnableDisableItem(NewChartMHdl, ChartWtTypeItem, (CWView <> infoview) and not emptychart and (((CWChart = CWCSteps) and (sequencechart or positionchart)) or (CWChart = CWCChanges)));								DrawGrowBox(targetWindow);								SetMenuItemText(FileMHdl, PrintingItem, 'Print Chart...');							end						else if IsTextWindow(TargetWindow) then							begin								{^&* theWindow := TargetWindow;}								whichText := WhichTextWindow(targetWindow);								ReturnGDisplayMenu;								DoActivateControl(textWindowInfo[whichText]^.scroll);								FixFontMenu(FontMHdl,textWindowInfo[whichText]^.font, true);								FixSizeMenu(SizeMHdl,textWindowInfo[whichText]^.size);								if not TextWindowLocked(whichText) then									TEActivate(textWindowInfo[whichText]^.TE);								{SetItemMark(EditMHdl, SelectItem, char(0));								SetMenuItemText(EditMHdl, SelectItem, 'Select All');								SetItemCmd(EditMHdl, SelectItem, 'A');}								SetMenuItemText(FileMHdl, PrintingItem, 'Print Notes...');								DrawGrowBox(targetWindow);							end						else if TargetWindow = statesWindow then							begin								{^&* theWindow := TargetWindow;}								DoActivateControl(statesWindowVScroll);								DoActivateControl(statesWindowHScroll);								ReturnGDisplayMenu;								ConvertToSimpleSelectSubMenu;								SetPrintExtraItem(statesWindow);								if statesEditing then									TEActivate(statesTE);								DrawGrowBox(targetWindow);								SetMenuItemText(FileMHdl, PrintingItem, 'Print Names...');								FixFontMenu(FontMHdl,statesFont, true);								FixSizeMenu(SizeMHdl,statesFontSize);								{ConvertToInfoSelectSubMenu(stateSetObject);}								{RebuildSelectMenu(stateSetObject);}							end						else if TargetWindow = pictwindow then							begin								SetMenuItemText(FileMHdl, PrintingItem, 'Print Picture...');								myEnableItem(FileMHdl, GraphicFileItem);								DrawGrowBox(targetWindow);							end						else 							begin								DoThermoActivates(targetWindow,searchThermo,true);								DoThermoActivates(targetWindow,ioThermo,true);								DoThermoActivates(targetWindow,thermo1Window,true);								DoThermoActivates(targetWindow,thermo2Window,true);							end;					end;				myEnableItem(FileMHdl, PrintingItem);  {need to put this at the end as otherwise FileMHdl might not be accurate}			end;		FixEditMenu;		FixPrintOtherMenu;		RebuildWindowsMenu;	end;	{-----------------------------------------------------------------------------}	procedure DoDeActivates (targetwindow: WindowPtr; suspending:boolean);		var			tempP: WindowPtr;			oldUpdatePending: boolean;			whichinfo, whichText: integer;			box: rect;	begin		genericGetPort(tempP);		if (targetWindow<> nil) & MacCladeWindow(targetWindow) & WindowVisible(targetWindow)  then			begin				genericSetPort(targetwindow);				oldUpdatePending := updatePending(targetwindow);				myDisableItem(FileMHdl, GraphicFileItem);				myDisableItem(SaveOtherMHdl, svTxtWindowItem);				oldScreenInColor := ScreenInColor;				myDisableItem(FileMHdl, PrintingItem);{    DebugStr('in deactivates');}				if IsEditorWindow(targetWindow) & editorOpen then					begin						if not isforeground |  not IsEditorWindow(frontwindow) then							begin								if targetWindow<> editorWindow then 									genericSetPort(editorWindow);								ClipRect(WindowPortRect(editorWindow));								if editorSelected and SingleCell then									begin										ReturnValue(editorSelectionTopLeft,false);										TEDeactivate(editorCellTE);										TEDeactivate(noteTE);									end;								DoDeactivateControl(editorVScroll);								DoDeactivateControl(editorHScroll);																HiliteWindow(editorWindow, false);								HiliteWindow(toolPaletteWindow[editorTools], false);								{if not oldUpdatePending then									begin										SetRect(box, -10000, -10000, 10000, 10000);  										ValidRect(box); 															end;}								DrawGrowBox(editorWindow);															end;						HideFlash;					end				else if LockedToTreeWindow(targetWindow) & treeOpen then					begin						if not isforeground | not IsTreeWindow(frontwindow) then							begin								DeselectTreeWindows;								DrawGrowBox(treeWindow);								myDisableItem(TWDisplayMHdl, ZoomTWItem);								{### myDisableItem(FileMHdl,PrintExtraItem);}							end;					end				else if IsInfoWindow(targetWindow) then					begin						whichInfo := WhichInfoWindow(targetWindow);						if infoOpen[whichinfo] then							begin								InfoWindowDeActivate(whichinfo, oldUpdatePending);							end;					end				else if IsTextWindow(targetWindow) then					begin						whichtext := WhichTextWindow(targetWindow);						ReturnComplexDisplayMenu;						DoDeactivateControl(textWindowInfo[whichText]^.scroll);						if not TextWindowLocked(whichText) then							TEDeActivate(textWindowInfo[WhichTextWindow(targetWindow)]^.TE);						DrawGrowBox(targetWindow);					end				else if TargetWindow = statesWindow then					begin						DoDeactivateControl(statesWindowVScroll);						DoDeactivateControl(statesWindowHScroll);						if treeopen then							SetPrintExtraItem(treeWindow)						else if editorOpen then							SetPrintExtraItem(editorWindow);						ReturnComplexDisplayMenu;						if statesEditing then							begin								TurnOffSymbolsEditing;								TurnOffStatesEditing;							end;						DrawGrowBox(targetWindow);						{ConvertToSimpleSelectSubMenu;}					end				else if targetWindow = ChartWindow then					begin						DoDeactivateControl(CWScroll);						{if not oldUpdatePending then							myValidRect(chartWindow,WindowPortRect(chartWindow));}						SetTWMBar;						ReBuildShowMenu(treeWindow);						myDisableItem(NewChartMHdl, ChartPrintItem);{myDisableItem(NewChartMHdl, ChartquietRecalcItem);}						myDisableItem(NewChartMHdl, ChartWtTypeItem);						DrawGrowBox(targetWindow);					end				else 					begin						DoThermoActivates(targetWindow,searchThermo,false);						DoThermoActivates(targetWindow,ioThermo,false);						DoThermoActivates(targetWindow,thermo1Window,false);						DoThermoActivates(targetWindow,thermo2Window,false);					end;				{^&* theWindow := nil;}			end;		if (frontwindow <> nil) then			begin				if not MacCladeWindow(frontwindow) and not suspending then					WriteDeskScrap;  {if suspending have already done this}				if (myGetWindowKind(frontwindow) < 0) then {desk acc coming up}					begin						{Davidundo:  myEnableItem(EditMHdl, UndoItem);}						SetMenuItemText(EditMHdl, UndoItem, 'Undo');						myEnableItem(EditMHdl, CutItem);						myEnableItem(EditMHdl, CopyItem);						myEnableItem(EditMHdl, PasteItem);						myEnableItem(EditMHdl, ClearItem);					end;			end;		genericSetPort(tempP);		FixEditMenu;		FixPrintOtherMenu;		RebuildWindowsMenu;	end;{-----------------------------------------------------------------------------}	procedure DealwthActivates;	begin		{### myDisableItem(FileMHdl,PrintExtraItem);}		if BAnd(activeFlag, Event.modifiers) <> 0 then			DoActivates(myGetWindowPtrFromEventMessage(Event))		else			DoDeActivates(myGetWindowPtrFromEventMessage(Event),false);		MacCladeUpFront := (frontwindow = nil) | MacCladeWindow(frontwindow);		FixTextMenus;		editorCursorTaxon:=0;		editorCursorCharacter:=0;	end;end.