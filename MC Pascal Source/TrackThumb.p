unit TrackThumb;{본본본본본본본본본본본}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, 		Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, 		Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, 		StrUtil, BoxUtil, TaxonCHUtil, CharUtil, MenuUtil, 		SymbolsNames, TreeUtil, ChartWUtil;	procedure TrackFeedbackThumb (whichControl: ControlRef; wh: point; whichWindow: WindowPtr);{본본본본본본본본본본본}implementation	const 		kPageOverlap = 10;		kThumbTrackWidthSlop = 25;		kThumbTrackLengthSlop = 113;		kScrollArrowWidth = 16;		kScrollThumbWidth = 16;		kTotalWidthAdjust = (kScrollArrowWidth * 2) + kScrollThumbWidth;	var activeControl: ControlRef;		gStartValue, gSaveValue: longint;		temporaryStringBox: rect;		gValueSlop: integer;		gScrollWindow: WindowPtr;		gWhichScrollInfo: integer;{----------------------------------------------------------------------------}	function ScrollIsVertical(theControl: ControlRef): boolean;	{only works for those scrolls used by track thumb!!!!!}	begin		ScrollIsVertical :=   ((theControl = CWScroll)& (CWView <> histoview))| (theControl = infoScroll[gWhichScrollInfo]) |(theControl = editorVScroll) | (theControl = dataBoxScroll) ;	end;{----------------------------------------------------------------------------}	function CalcValueFromPoint(theControl: ControlRef; wh: point): longint;	var 			theValue, theDistance, thePin, theRange: longint;		box: rect;	begin		box := myGetControlRect(theControl);		theRange := GetControlMaximumLong (theControl) - GetControlMinimumLong (theControl);		if  ScrollIsVertical(theControl) then			begin			// Scroll distance adjusted for scroll arrows and the thumb				theDistance := box.bottom - box.top - kTotalWidthAdjust;						// Pin thePoint to the middle of the thumb				thePin := box.top + RoundValue (kTotalWidthAdjust / 2);							theValue := RoundValue((1.00* (wh.v - thePin) * theRange) / theDistance);			end		else			begin			// Scroll distance adjusted for scroll arrows and the thumb				theDistance := box.right - box.left - kTotalWidthAdjust;						// Pin thePoint to the middle of the thumb				thePin := box.left + RoundValue(kTotalWidthAdjust / 2);							theValue := RoundValue((1.00*(wh.h - thePin) * theRange) / theDistance);			end;				theValue := theValue + gValueSlop;						if ( theValue < GetControlMinimumLong (theControl) ) then			theValue := GetControlMinimumLong (theControl)		else if ( theValue > GetControlMaximumLong (theControl) ) then			theValue := GetControlMaximumLong (theControl);		CalcValueFromPoint := theValue;	end;{----------------------------------------------------------------------------}	procedure BeginThumbTracking(theControl: ControlRef; whichWindow: WindowPtr);	var wh: point;	begin		gScrollWindow := whichWindow;		activeControl := theControl;		gStartValue := GetControlValueLong (activeControl);		gSaveValue := gStartValue;		if IsInfoWindow(gScrollWindow) then			gWhichScrollInfo := WhichInfoWindow(gScrollWindow);						gValueSlop := 0;		GetMouse (wh);		gValueSlop := GetControlValueLong (activeControl) - CalcValueFromPoint (activeControl, wh );		end;{----------------------------------------------------------------------------}	function TrackFeedbackThumbString(value: integer): str255;	var whichinfo: integer;	begin		TrackFeedbackThumbString := StringFromNum(value);		if gScrollWindow=editorWindow then			if (activeControl = editorVScroll) = editorTransposed then				TrackFeedbackThumbString :=concat('character:   ', StringFromNum(value+1))			else				TrackFeedbackThumbString :=concat('taxon:   ', StringFromNum(value+1))		else if (gScrollWindow=chlegwindow) then			TrackFeedbackThumbString :=concat('character:   ', StringFromNum(value))		else if (gScrollWindow=chartwindow) then			begin				TrackFeedbackThumbString :=CategoryString(value,3, false,false);			end		else if (gScrollWindow=statesWindow) then			begin				if activeControl=statesWindowHScroll then					TrackFeedbackThumbString :=concat('character:   ', StringFromNum(value))			end		else if (gScrollWindow=treeWindow) then			begin				if activeControl=dataBoxScroll then					TrackFeedbackThumbString :=concat('character:   ', StringFromNum(value));			end		else if gScrollWindow=tlegwindow then			TrackFeedbackThumbString :=concat('tree:   ', StringFromNum(value))		else if IsInfoWindow(gScrollWindow) then			begin				whichInfo := WhichInfoWindow(gScrollWindow);				case whichInfo of						charinfo:							TrackFeedbackThumbString :=concat('character:   ', StringFromNum(value));						taxinfo:							TrackFeedbackThumbString :=concat('taxon:   ', StringFromNum(value));						treeinfo:							TrackFeedbackThumbString :=concat('tree:   ', StringFromNum(value));						taxsetinfo:							TrackFeedbackThumbString :=concat('taxon set:   ', StringFromNum(value));						charsetinfo:							TrackFeedbackThumbString :=concat('character set:   ', StringFromNum(value));						typesetinfo:							TrackFeedbackThumbString :=concat('type set:   ', StringFromNum(value));						wtsetinfo:							TrackFeedbackThumbString :=concat('weight set:   ', StringFromNum(value));						charpartinfo:							TrackFeedbackThumbString :=concat('character partition:   ', StringFromNum(value));						charpartnameinfo:							TrackFeedbackThumbString :=concat('part name:   ', StringFromNum(value));						exsetinfo:							TrackFeedbackThumbString :=concat('inclusion set:   ', StringFromNum(value));						nexusblockinfo:							TrackFeedbackThumbString :=concat('nexus block:   ', StringFromNum(value));					otherwise;				end;							end;	end;{----------------------------------------------------------------------------}	procedure trackEditorThumbActionProc;	var 	tempP: WindowPtr;		wPort: cGrafPtr; 		box: rect;		wh: point;		theValue: longint;	begin		box := myGetControlRect(activeControl);		GetMouse(wh);		theValue := CalcValueFromPoint (activeControl,wh);		if theValue <> gSaveValue {GetControlValueLong(activeControl)} then			begin				gSaveValue := theValue;			 	{SetControlValueLong (activeControl, theValue );}				genericGetPort(tempP);{$IFC NOT CARBON}				GetCWMgrPort(wPort);				genericSetPort(myGetWindowFromPort(wPort));{$ENDC}				DrawTemporaryText(TrackFeedbackThumbString(gSaveValue),temporaryStringBox);				genericSetPort(tempP);			end;	end;{----------------------------------------------------------------------------}	procedure TrackFeedbackThumb (whichControl: ControlRef; wh: point; whichWindow: WindowPtr);	var myOffScreenWorld: GWorldPtr;		offPixMapHandle:  PixMapHandle;		offScreenbox,onScreenBox: Rect;		wPort: CGrafPtr;		tempP: WindowPtr;		oldClip: RgnHandle;		theString: str255; 		t: integer;		notePt: point;		whichinfo: integer;				trackControlUPP:DragGrayRgnUPP;	begin		genericSetPort(whichWindow);		BeginThumbTracking(whichControl, whichWindow);		theString :=TrackFeedbackThumbString(15000);				CalcTemporaryTextBox (theString,wh,offscreenBox,onscreenBox);		notePt := wh;{$IFC NOT CARBON}		LocalToGlobal(notePt);{$ENDC}		if ScrollIsVertical(whichControl) then			begin				notePt.h := notePt.h-offScreenBox.right-scrollwidth-20;				if notePt.v+offScreenBox.bottom > ScreenBoundsRect.bottom then					notePt.v := ScreenBoundsRect.bottom- offScreenBox.bottom-5;			end		else			begin				notePt.v := notePt.v-offScreenBox.bottom-scrollwidth-20;				t := ScreenBoundsRect.right;				if notePt.h+offScreenBox.right > ScreenBoundsRect.right then					notePt.h := ScreenBoundsRect.right- offScreenBox.right-5;			end;							OffSetRect(onscreenBox,notePt.h,notePt.v);		SetUpTemporaryPicture(myOffScreenWorld,wPort,offScreenbox,onScreenBox,tempP,offPixMapHandle);	{		SetUpTemporaryText(theString,notePt,myOffScreenWorld,offPixMapHandle, offScreenbox,onScreenBox,wPort,tempP);}		DrawTemporaryText(TrackFeedbackThumbString(gSaveValue),onScreenBox);		temporaryStringBox:= onScreenBox;				trackControlUPP := DragGrayRgnUPP(MyNewDragGrayRgnUPP(@trackEditorThumbActionProc)); 		t := myTrackControl(whichControl, wh, UniversalProcPtr( trackControlUPP));		RePlaceTemporaryText(myOffScreenWorld,offPixMapHandle, offScreenbox,onScreenBox,wPort,tempP);		MyDisposeDragGrayRgnUPP(UniversalProcPtr(trackControlUPP));		SetControlValueLong ( whichControl, gSaveValue );	end;end.