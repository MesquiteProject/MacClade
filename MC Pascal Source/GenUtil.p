unit GenUtil;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}interface	uses		Quickdraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound,		 Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources,		  Scrap,  Globals, MemoryUtil, WindowUtil, EventUtil, ErrorUtil,		   SetLibInterface, UtilLibInterface,   Script, Appearance;{$IFC NOT RELEASEVERSION}	procedure StartTime;	procedure ReportTime;	procedure TimeSinceLast (message: str255);		{$ENDC}{$IFC DEBUG}	procedure StartDebugFile;	procedure WriteDebugFile (message: str255);	procedure EndDebugFile;{$ENDC}	procedure BeginDragSound;	procedure EndDragSound;	procedure SetLinkBit(theChain: Integer; theLink: longint; linkH: Handle; theBit: integer; onoff: boolean);	function TestLinkBit(theChain: Integer; theLink: longint; linkH: Handle; theBit: integer): boolean;	procedure CheckDirty;	function TaxonOfCell (thecell: point): integer;	function CharOfCell (thecell: point): integer;	function OnlyTaxonNamesSelected: boolean;	function OnlySingleRowNameSelected: boolean;	function OnlySingleColumnNameSelected: boolean;	function OnlySingleNameSelected: boolean;	function WholeCharSel: boolean;	function WholeTaxonSel: boolean;	function SingleCell: boolean;	function someDataSel: boolean;	function IsDataCell(it,ic:integer): boolean;	function CellIsData(cell: point): boolean;	procedure CalcSelectedTaxaCharacters (var st, et, sc, ec: integer; bounded: boolean);	function CellIsSingleSelected (it,ic: integer): boolean;	function CellInSelection  (rownum, colnum: integer): boolean;	function WholeCharIsSelected(ic: integer): boolean;	function WholeTaxonIsSelected(it: integer): boolean;	{function RandomPosLong (var seed: longint): Longint;	function RandomInteger (var seed: longint): integer;}	procedure NewRandomSeed;	procedure GetRandomSeed;	function RandomBetween (minnum, maxnum: integer): integer;	function CheckChartStop (numbuttons: integer): boolean;	function AddGenDist (a, b: longint): longint;  {make longint or real if appropriate}	function myKillScrap: OSErr;	function myPutScrap(thePublic: boolean; theCount: SInt32; theFlavorType: ScrapFlavorType; theBuffer: UNIV Ptr): OSErr;	function myGetScrap(theDestination: Handle; theFlavorType: ScrapFlavorType; var theOffset: SInt32): longint;	procedure ReadDeskScrap;	procedure WriteDeskScrap;{еееееееееееееееееееееее}implementation {е$S genutils}{-----------------------------------------------------------------------------}	procedure BeginDragSound;	begin		if hasAppearanceManager then			dragSoundActive := (NoErr = BeginThemeDragSound(kThemeDragSoundDragging));	end;{-----------------------------------------------------------------------------}	procedure EndDragSound;	begin		if hasAppearanceManager & dragSoundActive then			dragSoundActive :=  (NoErr <> EndThemeDragSound);	end;{-----------------------------------------------------------------------------}	procedure SetLinkBit(theChain: Integer; theLink: longint; linkH: Handle; theBit: integer; onoff: boolean);{sets bits at start of link.  linkH is not nil, then that is where bits of setif linkH is nil, then use theChain and theLink to find the link handle}		var			oldState: SignedByte;			H: Handle;	begin		if linkH <> nil then			H := linkH		else			H := HdlPtr(GetMaster(strCHUNKs[theChain]) + HdlSize * ord4(thelink))^;		LockHandle(H, oldstate);		if onoff then			Bitset(ptr(GetMaster(H)), theBit)		else			BitClr(ptr(GetMaster(H)), theBit);		ResetHandle(H, oldstate);	end;{-----------------------------------------------------------------------------}	function TestLinkBit(theChain: Integer; theLink: longint; linkH: Handle; theBit: integer): boolean;{tests bits at start of link.  linkH is not nil, then that is where bits of setif linkH is nil, then use theChain and theLink to find the link handle}		var			oldState: SignedByte;			H: Handle;	begin		if linkH <> nil then			H := linkH		else			H := HdlPtr(GetMaster(strCHUNKs[theChain]) + HdlSize * ord4(thelink))^;		LockHandle(H, oldstate);		TestLinkBit := BitTST(ptr(GetMaster(H)), theBit);  {checking wtisreal}		ResetHandle(H, oldstate);	end;{----------------------------------------------------------------------------}	procedure CheckDirty;	begin		if fileopen then			begin				dirtyfile := (dirtyfile or datachanged or dirtyfix);				if MenuAvailable(treeMenu) then					begin						EnableDisableItem(TreeMHdl, NewTreeFileItem, not treefile);						EnableDisableItem(TreeMHdl, OpenTreeFileItem, not treefile);						EnableDisableItem(TreeMHdl, CloseTreeFileItem, treefile);						EnableDisableItem(TreeMHdl, SaveAsTreeFileItem, UserLinks[treechain] > 0);						EnableDisableItem(TreeMHdl, ExTreeFileItem, UserLinks[treechain] > 0);						EnableDisableItem(TreeMHdl, TransferTreeItem, (UserLinks[treechain] > 0) & not Locked(lockTrees) & infoOpen[treeinfo] & infoSomeSelected[treeinfo]);						EnableDisableItem(TreeMHdl, SaveTreeFileItem, dirtytreefile & treefile);  {v3.02: added & treefile}					end;				if treeopen then					EnableDisableItem(NewChartMHdl, sTwoTreesItem, (UserLinks[treeCHAIN] > 1));			end;	end;{|||||||||||||||||||||||||||||||  EDITOR  |||||||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	function TaxonOfCell (thecell: point): integer;	begin		if not editorTransposed then			TaxonOfCell := thecell.v		else			TaxonOfCell := thecell.h;	end;{-----------------------------------------------------------------------------}	function CharOfCell (thecell: point): integer;	begin		if not editorTransposed then			CharOfCell := thecell.h		else			CharOfCell := thecell.v;	end;{-----------------------------------------------------------------------------}	function OnlyTaxonNamesSelected: boolean;	begin		OnlyTaxonNamesSelected := editorSelected & (TaxonOfCell(editorSelectionTopLeft) > 0) & (TaxonOfCell(editorSelectionBotRight) >0)& (CharOfCell(editorSelectionBotRight)=0);	end;{-----------------------------------------------------------------------------}	function OnlySingleRowNameSelected: boolean;	begin		OnlySingleRowNameSelected := editorSelected & SingleCell & (editorSelectionTopLeft.h=0) ;	end;{-----------------------------------------------------------------------------}	function OnlySingleColumnNameSelected: boolean;	begin		OnlySingleColumnNameSelected := editorSelected & SingleCell & (editorSelectionTopLeft.v=0);	end;{-----------------------------------------------------------------------------}	function OnlySingleNameSelected: boolean;	begin		OnlySingleNameSelected := editorSelected & SingleCell & ((TaxonOfCell(editorSelectionTopLeft) = 0) | (CharOfCell(editorSelectionBotRight)=0));	end;{-----------------------------------------------------------------------------}	function WholeCharSel;	begin		WholeCharSel := editorSelected & (TaxonofCell(editorSelectionTopLeft) <= 1) & (TaxonofCell(editorSelectionBotRight) = numtaxa) & (CharofCell(editorSelectionTopLeft) > 0);	end;{-----------------------------------------------------------------------------}	function WholeTaxonSel;	begin		WholeTaxonSel := editorSelected & (CharOfCell(editorSelectionTopLeft) <= 1) & (CharOfCell(editorSelectionBotRight) = numchars) & (TaxonofCell(editorSelectionTopLeft) > 0);	end;{-----------------------------------------------------------------------------}	function SingleCell;	begin		SingleCell := (editorSelectionTopLeft.v = editorSelectionBotRight.v) & (editorSelectionTopLeft.h = editorSelectionBotRight.h);	end;{----------------------------------------------------------------------------}	function someDataSel: boolean;	begin		someDataSel := editorSelected & ((editorSelectionBotRight.v > 0) & (editorSelectionBotRight.h > 0));	end;{----------------------------------------------------------------------------}	function IsDataCell(it,ic:integer): boolean;	begin		IsDataCell:= (it>0) & (it<= numtaxa) & (ic> 0) & (ic<= numchars);	end;{----------------------------------------------------------------------------}	procedure CalcSelectedTaxaCharacters (var st, et, sc, ec: integer; bounded: boolean);{calculates the range of taxa and characters selected in the data editor}{note: doesn't check to see if characters selected}{also, can't be applied unless actual data cell selected, as otherwise et<st or ec<sc}	begin		if not editorTransposed then			begin				st := editorSelectionTopLeft.v;				et := editorSelectionBotRight.v;				sc := editorSelectionTopLeft.h;				ec := editorSelectionBotRight.h;			end		else			begin				st := editorSelectionTopLeft.h;				et := editorSelectionBotRight.h;				sc := editorSelectionTopLeft.v;				ec := editorSelectionBotRight.v;			end;		if bounded then			begin				if st <= 0 then					st := 1;				if sc <= 0 then					sc := 1;			end;	end;{----------------------------------------------------------------------------}	function CellIsSingleSelected (it,ic: integer): boolean;	begin		CellIsSingleSelected := SingleCell & editorSelected & (TaxonOfCell(editorSelectionTopLeft)=it)& (CharOfCell(editorSelectionTopLeft)=ic) ;	end;{----------------------------------------------------------------------------}	function CellInSelection  (rownum, colnum: integer): boolean;	begin		CellInSelection := editorSelected & (rowNum >= editorSelectionTopLeft.v) & (rowNum <= editorSelectionBotRight.v) & (colNum >= editorSelectionTopLeft.h) & (colNum <= editorSelectionBotRight.h);	end;{----------------------------------------------------------------------------}	function WholeCharIsSelected(ic: integer): boolean;	begin		if editorTransposed then			WholeCharIsSelected := WholeCharSel &  (ic >= editorSelectionTopLeft.v) & (ic <= editorSelectionBotRight.v)		else			WholeCharIsSelected := WholeCharSel &  (ic >= editorSelectionTopLeft.h) & (ic <= editorSelectionBotRight.h);	end;{----------------------------------------------------------------------------}	function WholeTaxonIsSelected(it: integer): boolean;	begin		if editorTransposed then			WholeTaxonIsSelected := WholeTaxonSel &  (it >= editorSelectionTopLeft.h) & (it<= editorSelectionBotRight.h)		else			WholeTaxonIsSelected := WholeTaxonSel &  (it >= editorSelectionTopLeft.v) & (it <= editorSelectionBotRight.v);	end;{----------------------------------------------------------------------------}{|||||||||||||||||||||  RANDOM ||||||||||||||||||||||}{-----------------------------------------------------------------------------}{	function RandomPosLong (var seed: longint): Longint;	EXTERNAL;	function RandomInteger (var seed: longint): integer;	EXTERNAL;}{-----------------------------------------------------------------------------}	function RandomBetween (minnum, maxnum: integer): integer;		var			range: integer;			temprandom: integer;	begin		range := maxnum - minnum + 1;		if range <= 1 then			temprandom := minnum		else			begin				repeat					temprandom := RandomInteger(ourRandSeed);					BitCLR(@temprandom, 0);   {quick and dirty converting to positive}				until temprandom < 32767 div range * range;				temprandom := (temprandom mod range) + minnum;			end;		RAndomBetween := temprandom;	end;{-----------------------------------------------------------------------------}	procedure NewRandomSeed;		var			secs: UInt32;	begin		GetDateTime(secs);		ourRandSeed := abs(secs);	end;{-----------------------------------------------------------------------------}	procedure GetRandomSeed;		label			1;		var			TD: DialogPtr;			itemtype: integer;			tempP: WindowPtr;			H: handle;			ds: str255;			B: REct;			localItemHit: integer;	begin		StartDLOG(553, TD, tempP);		GetDialogItem(TD, 3, itemtype, H, B);		SetDialogItemText(H, StringFromNum(OurRandSeed));		SelectDialogItemText(TD, 3, 0, 32000);		myShowDialog(TD);		FrameButton(TD, 1);1:		repeat			ModalDialog(nil, localItemHit);			if localItemHit = 4 then				begin					OurRandSeed := oldRandSeed;					SetDialogItemText(H, StringFromNum(OurRandSeed));					SelectDialogItemText(TD, 3, 0, 32000);				end;		until localItemHit in [1, 2];		GetDialogItemText(H, ds);		if (localitemhit = 1) & ((pos('-', ds) > 0) | not NumericalToken(ds)) then			begin				Beep;				SelectDialogItemText(TD, 3, 0, 32000);				goto 1;			end		else			EndDLOG(TD, tempP);		if localItemHit = 1 then			StringToNum(ds, OurRandSeed);	end;{|||||||||||||||||||||||||||||||    |||||||||||||||||||||||||||||||||||}{$IFC NOT RELEASEVERSION}{-----------------------------------------------------------------------------}	procedure StartTime;	begin		lasttime := TickCount;	end;{-----------------------------------------------------------------------------}	procedure ReportTime;	begin		InstantInfo(StringFromNum(TickCount - LastTime));		lasttime := TickCount;	end;{-----------------------------------------------------------------------------}	procedure TimeSinceLast (message: str255);		{a procedure that tells you how many seconds}										{ have elapsed since last time it was called}		var			ds: str255;	begin		if lasttime <> 0 then			ds := concat(message, chr(13), StringFromNum(TickCount - LastTime), ' ticks')		else			ds := message;		InstantInfo(ds);		lasttime := TickCount;	end;{$ENDC}{$IFC DEBUG}{----------------------------------------------------------------------------}	procedure WriteDebugFile (message: str255);	begin		writeln(debugfile, message);	end;{----------------------------------------------------------------------------}	procedure StartDebugFile;	begin		rewrite(debugfile, 'DebugFile');	end;{----------------------------------------------------------------------------}	procedure EndDebugFile;	begin		close(debugfile);	end;{$ENDC}{-----------------------------------------------------------------------------}	function CheckChartStop (numbuttons: integer): boolean;{if numbuttons = 3, then buttons are stop immediately, after next tree, or cancel abort}{if numbuttons = 2, then buttons are stop immediately, or cancel abort}		var			localItemHit: integer;	begin		CheckChartStop := false;		if numbuttons = 3 then			localItemHit := DoAlert(598, CautionA)		else			localItemHit := DoAlert(599, CautionA);{$IFC CARBON}		if isMacOSX then			InvalidateAllWindows;{$ENDC}		if localItemHit = 3 then			Stopaftertree := true		else if localItemHit = 2 then			begin				PleaseOffChart := true;				NewError(72, 0);				CheckChartStop := true;			end		else			begin				Stopaftertree := false;				abortedThermo := false;			end;		DrawThermos;	end;{-----------------------------------------------------------------------------}	function AddGenDist (a, b: longint): longint;  {make longint or real if appropriate}		var			monitor: longint;	begin		if (a = infinity) or (b = infinity) then			AddGenDist := infinity		else			begin				monitor := multaddC(a, b, 1);				if monitor < 0 then					begin						NewError(325, 0);{check for integer overflow}						monitor := 0;					end;				AddGenDist := monitor;			end;	end;{-----------------------------------------------------------------------------}{$IFC NOT TARGET_CARBON}	function myKillScrap: OSErr;	begin		myKillScrap := ZeroScrap;	end;{$ELSEC}	function myKillScrap: OSErr;	begin		myKillScrap := ClearCurrentScrap;	end;{$ENDC}{-----------------------------------------------------------------------------}{$IFC NOT TARGET_CARBON}	function myPutScrap(thePublic: boolean; theCount: SInt32; theFlavorType: ScrapFlavorType; theBuffer: UNIV Ptr): OSErr;	begin		myPutScrap := PutScrap(theCount, theFlavorType, theBuffer);	end;{$ELSEC}		function myPutScrap(thePublic: boolean; theCount: SInt32; theFlavorType: ScrapFlavorType; theBuffer: UNIV Ptr): OSErr;		var			myFlavorFlags: ScrapFlavorFlags;			myScrapRef: ScrapRef;			myErr: OSErr;	begin		if thePublic then			myFlavorFlags := kScrapFlavorMaskNone		else				myFlavorFlags := kScrapFlavorMaskSenderOnly;		myErr := GetCurrentScrap(myScrapRef);		if myErr = noErr then			myErr := PutScrapFlavor(myScrapRef, theFlavorType, myFlavorFlags, theCount, theBuffer);		myPutScrap := myErr;	end;{$ENDC}{-----------------------------------------------------------------------------}{$IFC NOT TARGET_CARBON}	function myGetScrap(theDestination: Handle; theFlavorType: ScrapFlavorType; var theOffset: SInt32): longint;	begin		myGetScrap := GetScrap(theDestination, theFlavorType, theOffset);	end;{$ELSEC}	function myGetScrap(theDestination: Handle; theFlavorType: ScrapFlavorType; var theOffset: SInt32): longint;		var			myScrapRef: ScrapRef;			myErr: OSErr;			mySize: Size;			myFlavorFlags: flavorFlags;	begin		myGetScrap := 0;		myErr := GetCurrentScrap(myScrapRef);		{this sepeates the two calls for size and data internally}		if myErr = noErr then			if theDestination = nil then				begin				{get scrap size}					myErr := GetScrapFlavorFlags(myScrapRef, theFlavorType, myFlavorFlags);					if myErr = noErr then					{if there is data of this flavor, otherwise we would wait forever}						begin							myErr := GetScrapFlavorSize(myScrapRef, theFlavorType, mySize);							if myErr = noErr then								myGetScrap := mySize;						end;				end			else				begin				{get scrap}					HLock(theDestination);					myGetScrap := GetScrapFlavorData(myScrapRef, theFlavorType, theOffset, theDestination^);					HUnlock(theDestination);				end;	end;{$ENDC}{-----------------------------------------------------------------------------}	procedure ReadDeskScrap;{called when MacClade starts up, when a MacClade window is activated, and when MacClade resumes under multifinder}		var			scrapLength, ignore: Longint;{$IFC NOT CARBON} 			Scrap: ScrapStuffPtr;{$ENDC}	begin{$IFC NOT CARBON}  		Scrap := infoscrap;		if scrapcompare <> scrap^.scrapcount then		{scrap has changed}			begin				scrapLength := myGetScrap(nil, 'TEXT', ignore);				if scrapLength >= 0 then					begin						if scrapLength > 32766 then   {v3.02: added}							begin								scrapLength := 0;								NewError(401, 0);							end						else							begin								resultcode := TEfromScrap;								if resultcode > 0 then									begin										scrapLength := resultcode;										scrapispict := false;									end;							end;					end				else					begin						scrapLength := myGetScrap(nil, 'PICT', ignore);						if scrapLength > 32766 then   {v3.02: added}							begin								scrapLength := 0;								if clippicture <> nil then									KillPicture(clippicture);								clippicture := nil;								NewError(401, 0);							end						else if scrapLength >= 0 then							begin								if clippicture <> nil then									KillPicture(clippicture);								clippicture := picHandle(NewHandle(0));								resultcode := myGetScrap(Handle(clippicture), 'PICT', ignore);								if resultcode > 0 then									begin										scrapLength := resultcode;										scrapispict := true;									end								else									begin   {v4: if resultcode < 0 then must have been an error - better reporting}										scrapLength := 0;									end;							end					end;				if scrapLength > 0 then					EnableDisableItem(EditMHdl, PasteItem, fileopen)				else					begin						TESetScrapLength(0);						myDisableItem(EditMHdl, PasteItem);					end;				Scrap := infoscrap;				ScrapCompare := Scrap^.scrapCount;			end;{$ENDC}	end;{-----------------------------------------------------------------------------}	procedure WriteDeskScrap;		var			oldstate: SignedByte;{called when MacClade quits, when a non-MacClade window is activated, and when MacClade suspends under multifinder}	begin{$IFC NOT DEMO}{$IFC NOT CARBON}		if scraptextdirty and not scrapispict then			begin				scrapcompare := myKillScrap;				resultcode := TEToScrap;				scraptextdirty := false;{v4: write tab-delimited  clipboard for a block of cells}{v4: write tab or return delimited clipboard for a set of taxon or character names}			end		else if scrappictdirty and scrapisPICT then			begin				scrapcompare := myKillScrap;				LockHandle(clippicture, oldstate);				resultcode := myPutScrap(true,GetHandleSize(Handle(clippicture)), 'PICT', Ptr(GetMaster(Handle(clippicture))));				ResetHandle(clippicture, oldstate);				scrappictdirty := false;			end;{$ENDC}{$ENDC}	end;end.