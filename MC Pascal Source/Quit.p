unit QUIT;{еееееееееееееееееееееее}interface	uses		Printing, QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit,		 QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface, 		  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, CHUNK, Settings, ChartWUtil, 		  ReadWriteUtil, ReadUtil, PrintingUtil, StartUp, NexusBlocks, CharPartitions;	procedure Bye;{еееееееееееееееееееееее}implementation {е$S QUIT}{-----------------------------------------------------------------------------} procedure DisposeUPPs; begin  MyDisposeControlActionUPP(ScrollContinuousUpDownUPP);  {MyDisposeControlActionUPP(ScrollHelpUpDownUPP);}  MyDisposeControlActionUPP(ScrollTypeUpDownUPP);  MyDisposeControlActionUPP(ScrollInfoUpDownUPP);  MyDisposeControlActionUPP(ScrollCWUpDownUPP);  MyDisposeControlActionUPP(ScrollSpreadUpDownUPP);  MyDisposeControlActionUPP(ScrollLegUpDownUPP);  MyDisposeControlActionUPP(ScrollN7UpDownUPP);  MyDisposeControlActionUPP(ScrollTreeUpDownUPP);  MyDisposeControlActionUPP(ScrollTextUpDownUPP);  MyDisposeControlActionUPP(ScrollStatesUpDownUPP);MyDisposeModalFilterUPP(UniversalDLOGFilterUPP); end;{-----------------------------------------------------------------------------}{ procedure DisposeListWindows; begin 	ZapPointer(listWindow); 	ZapPointer(listWindowPublic); end;}{-----------------------------------------------------------------------------}	procedure DisposeTextEdits;	var j: integer;	begin		TEDispose(editorCellTE);		TEDispose(noteTE);		for j := 1 to numTextWindows do			TEDispose(textWindowInfo[j]^.TE);		TEDispose(statesTE);		{TEDispose(stringTE);}		for j := 1 to numInfoWindows do			TEDispose(infoTE[j]);	end;{-----------------------------------------------------------------------------}	procedure DisposeWindows;	var j: integer;	begin		ZapWindow(TreeWindow);		ZapWindow(statesWindow);		ZapWindow(editorWindow);	{	ZapWindow(infoWindow[charinfo]);}		ZapWindow(BranchListWindow);		for j := 1 to numToolPalettes do			ZapWindow(toolPaletteWindow[j]);		ZapWindow(tlegWindow);		ZapWindow(twmessWindow);		ZapWindow(chlegWindow);		{ZapWindow(commWindow);}		ZapWindow(ChartWindow);		ZapWindow(pictWindow);		for j := 1 to numinfowindows do			ZapWindow(infoWindow[j]);					for j := 1 to numTextWindows do			DestroyTextWindow(j);	end;{-----------------------------------------------------------------------------}	procedure Bye;		var			j, k: integer;	begin		DisposeTextEdits;		DisposeWindows;		DisposeUPPs;		ZapRegion(NodeClip);		KillPoly(NodeTriangle);		ZapRegion(EWClip);		ZapRegion(oldGlobalClip);		ZapRegion(updateRgn);		ZapRegion(TWClip);		ZapRegion(theFlashRgn);				ZapPixPat(equivocalPPH);		ZapPointer(changesSel);		ZapPointer(errorsposted);		{ZapPointer(memoryErrors);}		ZapPointer(errorsturnedoff);				UnlockPixels(selectPixMapH);		DisposeGWorld(selectOffScreenWorld);		DestroyCellBlock(EWScrapBlockP);		DestroyCellBlock(EWUndoBlockP);		DestroyCellBlock(EWFindSequenceBlockP);		DestroyCellBlock(EWMoveBlockP);		DestroyCellBlock(EWFindRNARCBlockP);		ZapPointer(colorkey);		ZapPointer(patkey);		ZapPointer(summarycolors);		ZapPointer(summarypat);		ZapPointer(nucleotideColorKey);		ZapPointer(proteinColorKey);		for j := 1 to numinfoWindows do			for k := MaximumInfoColumns(j) downto 0 do				DestroyInfoColumn(j, k);						repeat			DestroyConsensus(1);		until editorNumConsensusSequences=1;		ZapPointer(editorConsensus);				repeat			DestroyNexusBlock(1);		until numNexusBlocks<=1;		ZapHandle(NexusBlocks^.H);		ZapPointer(NexusBlocks);  		repeat			DestroyCharPartName(1);		until numCharPartNames<=1;		ZapPointer(CharPartNames);  		for j := 1 to numSettingLinkedLists do			begin				repeat					DestroySettings(j,1);				until numSettings[j]<=1;				ZapHandle(baseSettings[j]^.H);				ZapPointer(baseSettings[j]);  			end;		DestroyFootPicts;{еее above here fine еее}					ZapHandle(statesClipboardH);		ZapHandle(statesUndoH);		ZapHandle(symbolsUndoSH);				ZapHandle(copySpecialCustomH1);		ZapHandle(copySpecialCustomH2);{еее below here fine еее}					ZapHandle(fixdataH);		ZapHandle(segdataH); {Segments}		ZapHandle(realBranchLengthsDataH);		for j := 0 to maxfoottype do			ZapHandle(footH[j]);		ZapHandle(treedataH);		ZapHandle(oldtreeH);		ZapHandle(AminoAcidNamesHdl);		ZapHandle(storeH);		for j := 0 to maxchain do			begin				ZapHandle(ChainNames[j]);				ZapHandle(curLinkNames[j]);			end;		for j := 1 to 2 do			ZapHandle(extratreefilename[j]);		DestroyCHUNKs(taxonCHUNKs);		DestroyCHUNKs(taxstsCHUNKs);		DestroyCHUNKs(chCHUNKs);		DestroyCHUNKs(statenamesCHUNKs);		DestroyCHUNKs(statenamesCHUNKsBU);		{fff DestroyCHUNKs(foreignCHUNKs);}		DestroyCHUNKs(typeCHUNKs);		for j := 0 to stringchains do			DestroyCHUNKs(strCHUNKs[j]);		ZapPointer(readBufferBasePtr);		ZapPointer(writeBufferBasePtr);		WriteDeskScrap;		ZapHandle(clippicture);		ZapHandle(RandomObservedFillH);		ZapHandle(RandomFillH);		ZapHandle(RandomAncH);		{ZapHandle(HelpTopics);}		ZapHandle(TTPR);		ZapHandle(TTC);		for j := 0 to numCLkinds do			ZapHandle(ChartLinearData[j]);		for j := 0 to numCMkinds do			ZapPointer(ChartMatrixData[j]);		ZapHandle(equates);		ZapPointer(laser);		ZapPointer(newlaser);		ZapPointer(laserboxes);		ZapPointer(gencode);		ZapPointer(SetPtr31);		ZapPointer(locSetPtr31);		ZapPointer(SetPtr15);		if grabpicture <> nil then			KillPicture(grabpicture);		grabpicture := nil;		ZapHandle(growH);		ZapHandle(iofilename);		ZapHandle(treefilename);		ZapHandle(filename);		ZapHandle(treename);		ZapHandle(CWClassName);		ZapHandle(ChartToTypeName);		ZapHandle(ChartToWtName);		ZapHandle(undoNameCellStringH);		if emptybrush.colorH <> nil then			DisposeCCursor(emptybrush.colorH);		if emptybrush.H <> nil then			ReleaseResource(Handle(emptybrush.H));		emptybrush.colorH := nil;		emptybrush.H := nil;		tool^[treeTools,arrowT].curs := diamond;  {set these up to be destroyed below}		tool^[treeTools,paintT].curs := fullbrush;		for k := 1 to numToolPalettes do			for j := 0 to numTools[k] do				begin					if tool^[k,j].curs.colorH <> nil then						DisposeCCursor(tool^[k,j].curs.colorH);					if tool^[k,j].curs.H <> nil then						ReleaseResource(Handle(tool^[k,j].curs.H));				end;		ZapPointer(FDI);		ZapPointer(tool);		ZapPointer(infoTools);			end;end.