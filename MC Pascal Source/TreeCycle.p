unit TreeCycle;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, CharUtil, MenuUtil, Prohibitions, ReadWriteUtil, ReadUtil, CHUNK, Thermos, TreeUtil, TreeMaker, LinkUtil, RandomTree;	procedure StoreCurrentTree (var H: Handle);	procedure RestoreCurrentTree (var H: Handle; disposeHandle: boolean);	procedure BuildTree (packH: Handle; theTree: longint; var status, querycyclepoly: boolean; makeanyway: boolean; OKtoPolytomy, OKtoFixanc: boolean);{    procedure BuildTree (theTree: integer; doSetStates, doCount: boolean; var status: boolean; makeanyway: boolean);}	function RandomTreeDLOG (var NRT: longint; tostore: boolean): boolean;	procedure DoRandomTrees;{еееееееееееееееееееееее}implementation {е$S TreeCycle}{-----------------------------------------------------------------------------}	procedure StoreCurrentTree (var H: Handle);		var			oldState: SignedByte;	begin		H := NewHandle(2);		LockHandle(treename, oldstate);		StoreTree(H, treename^^);		ResetHandle(treename, oldstate);			{here pass that snapshot is needed}		SaveFixdataForTree(H, fixdataH);		SaveSegmentsForTree(H, segdataH); {Segments:}		SaveRealLengthsForTree(H, realBranchLengthsDataH);		myDisableItem(ShowMHdl, ShrinkItem);		expd := FALSE;	end;{-----------------------------------------------------------------------------}	procedure RestoreCurrentTree (var H: Handle; disposeHandle: boolean);		var			status, querycyclepoly: boolean;	begin		CopyHandles(H, treedataH);		ancon := false;		status := true;		querycyclepoly := false;		Maketree(status, querycyclepoly, false, PolytomiesLegal(false), FixancLegal(subR, false),true,true);		if not printon then			FixTreeShadingMenus;		if disposeHandle then			ZapHandle(H);		godraw := true;		FullTreeOnScreenGoList; {request redo of calculations for new tree on screen}		if infoOpen[taxinfo] then			InvalidateWindow(infoWindow[taxinfo], false);		noundo := true;		fixlostbyundo := false;		justundid := false;{$IFC NOT ALWAYSENABLED}		myDisableItem(EditMHdl, UndoItem);{$ENDC}	end;{-----------------------------------------------------------------------------}	procedure PrepareRandomTree (treetype: integer; var treeH: Handle);{This procedure creates special handles for random trees}		var			LH: Handle;			dL: longint;			specialstring: str255;			nt: integer;			oldState: SignedByte;	begin		specialstring := '                ';	//	specialstring := '                             ';		specialstring[1] := chr(0);		specialstring[2] := chr(10);		specialstring[3] := chr(0);		specialstring[4] := chr(0);		specialstring[5] := chr(0);		specialstring[6] := chr(0);		specialstring[11] := chr(-128);		specialstring[12] := chr(0);		specialstring[13] := chr(-1);		specialstring[14] := chr(treetype);		UnLockHandle(treeH, oldstate);		ReplaceHandleContentsWithString(treeH, specialString);		if RTAlltaxa then			nt := numtaxa		else			nt := numtaxain;		HLock(treeH);		SetNumTaxaInPackedTree(treeH, nt);		ResetHandle(treeH, oldstate);	end;{-----------------------------------------------------------------------------}	procedure BuildTree (packH: Handle; theTree: longint; var status, querycyclepoly: boolean; makeanyway: boolean; OKtoPolytomy, OKtoFixanc: boolean);{NOTE: every place where this procedure is called, status=false should be expected in calling procedure}{as failure to build tree and dealt with as if tree is not built, because MAKETREE will not}{build the tree whenever status is passed to it as false, and it encounters problems.  Since}{Build tree passes status as false, if Maketree encounters problems we will be treeless.}{The only exception is if it is impossible for problems to be encountered (!), as with}{building random trees, where Buildtree can safely be called without a subsequent status=false}{parachute}		var			dL: longint;	begin		if packH <> nil then			CopyHandles(packH, treedataH){this used to say treedataH := packH, and was the cause of the TreeDataH BadHandleBits bug.  }{Basically, by setting treedataH to packH, when packH was later }{disposed of at the end of ChartTreeCycle, this of course also deallocated treedataH, as packH = treedataH}{(that is, they were using the same master pointer). Later, when treedataH was accessed, there was junk at}{the master pointer, and this often showed up with a Bad Handle Bits warning.}		else if (theTree < 0) then			PrepareRandomTree(theTree, treedataH)		else			GetLink(treeChain, theTree, treedataH, true);		status := false;		MakeTree(status, querycyclepoly, makeanyway, OKtoPolytomy, OKtofixanc,false,false);		if status then			StringToH(' ', treedataH);	end;{-----------------------------------------------------------------------------}	function RandomTreeDLOG; {(var NRT: longint; tostore: boolean): boolean}		var			theDialog: DialogPtr;			tempP: WindowPtr;			oldRTkind: integer;			oldRTallTaxa: Boolean;			localItemHit: integer;			oldState: SignedByte;{.....}		procedure CheckRandomTree;		begin			ItemCheckMark(theDialog, 4, RTkind = RTjoining);			ItemCheckMark(theDialog, 5, RTkind = RTpartition);			ItemCheckMark(theDialog, 6, RTkind = RTequiprobable);			ItemCheckMark(theDialog, 14, RTkind = RTResolve);			ItemCheckMark(theDialog, 11, (RTallTaxa or (numtaxain = numtaxa)) and (RTKind <> RTResolve));			if SaveRndTreesReport & (RTKind = RTResolve) then				SaveRndTreesReport := false;			if (RTAllTaxa & (numtaxa > maxRandomTreeReportTaxa)) | (not RTAllTaxa & (numtaxain > maxRandomTreeReportTaxa)) then				begin					EnableDisableDLOGItem(theDialog, 15, false, false);					saveRndTreesReport := false;				end			else				EnableDisableDLOGItem(theDialog, 15, (RTKind <> RTResolve), false);			ItemCheckMark(theDialog, 15, saveRndTreesReport);			EnableDisableDLOGItem(theDialog, 11, nodes & (numtaxain > 1) & (numtaxain <> numtaxa) & (RTKind <> RTResolve), false);		end;{.....}	begin		NewRandomSeed;		StartDLOG(423, theDialog, tempP);		if not nodes or (numtaxain < minTaxaIn) then			RTallTaxa := true;		if nodes & not nullson & (RTKind = RTResolve) then			RTKind := RTjoining;		oldRTkind := RTkind;		oldRTAllTaxa := RTAllTaxa;		LockHandle(treefilename, oldstate);		if tostore then			if treefile then				ParamText(concat('Stored in file ', treefilename^^), '', '', '')			else				ParamText('Stored in data file', '', '', '')		else			ParamText('', '', '', '');		ResetHandle(treefilename, oldstate);		SetDLOGText(theDialog, 3, '1', true);		EnableDisableDLOGItem(theDialog, 14, nodes & nullson, false);		CheckRandomTree;		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			if localItemHit in [4, 5, 6, 14, 15] then				begin					case localItemHit of						4: 							RTkind := RTjoining;						5: 							RTkind := RTpartition;						6: 							RTkind := RTequiprobable;						14: 							RTkind := RTResolve;						15: 							saveRndTreesReport := not saveRndTreesReport;						otherwise							;					end;				end			else if (localItemHit = 11) and (numtaxa <> numtaxain) then				begin					RTAllTaxa := not RTAllTaxa;					if (numtaxain < minTaxaIn) and not RTallTaxa then						begin							RTallTaxa := true;							InstantError(187);						end;					ItemCheckMark(theDialog, 11, RTallTaxa);				end			else if localItemHit = 13 then				GetRandomSeed;			CheckRandomTree;		until localItemHit in [1, 2];		NRT := 1;		if localItemHit = 1 then			NRT := EditTextInt(theDialog, 3,true);		EndDLOG(theDialog, tempP);		if localItemHit = 2 then			begin				RTAllTAxa := oldRTAllTaxa;				RTKind := oldRTKind;			end		else			begin				oldTreeSeed := OurRandSeed;				oldRandSeed := OurRandSeed;			end;		RandomTreeDLOG := (localItemHit = 1) and (NRT > 0);	end;{-----------------------------------------------------------------------------}	procedure DoRandomTrees;		var			theDialog: DialogPtr;			tport: WindowPtr;			NRT, j: longint;			ds, ds2: str255;			H: Handle;			status, querycyclepoly: boolean;			wasnodes: boolean;			TaxonHdl: thdl;	begin		if RandomTreeDLOG(NRT, true) then			begin				wasnodes := nodes;				if nodes then					begin						ds2 := treename^^;						StoreCurrentTree(H);{Note that one can make random trees without a tree window active by canceling GetTree DLOG on way to}{tree window.  Therefore we cannot require storing current tree.  Also, see below.}					end;				case RTkind of					RTjoining: 						ds := 'RndJn.';					RTpartition: 						ds := 'RndPrt.';					RTequiprobable: 						ds := 'RndEqu.';					RTResolve: 						ds := 'Resol.';					otherwise						;				end;				DisableWindowUpdates(infowindow[treeinfo]);				DisableWindowUpdates(treewindow);				StartThermo(theDialog, tport, 0, NRT, 'Creating random trees', 'trees', false);				status := false;				querycyclepoly := false;				if RTKind = RTResolve then					PrepareToRandomPoly(R);				if SaveRndTreesReport then					InitializeRndTreesReport;				for j := 1 to NRT do					begin						if abortedthermo then							leave;						if RTKind = RTResolve then							RandomizeAllPolytomies(R)						else							BuildTree(nil, RTkind, status, Querycyclepoly, false, true, true);						if treemakingfailed then							begin								NewError(381, 0);								errorflag := true;								leave;							end;						if SaveRndTreesReport then							UpdateRndTreesReport;						SaveLinkToChain(treeChain, concat(ds, StringFromNum(j)), false,false);						UpdateThermo(theDialog, 0, j, NRT, false);						if errorflag then							leave;					end;				EndThermo(theDialog, tport, true);				if SaveRndTreesReport & not errorflag then					SaveRndTreesReportToFile(j - 1, rtkind);				if wasnodes then					begin						treename^^ := ds2;						RestoreCurrentTree(H, true);					end				else					treeinmemory := false;				if not errorflag then					ChangeStoredTreesGoList;				InvalidateWindow(tlegwindow, false);				if infoOpen[treeinfo] then					InvalidateWindow(infowindow[treeinfo], true);				infoDirtyNames[treeinfo] := true;				if treefile then					dirtytreefile := true				else					dirtyfile := true;			end;	end;end.