unit TypeDLOG;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, 		Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, 		Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, 		TaxonCHUtil, TypeUtil, N7On, MenuUtil, Thermos, BoxUtil, InfoWindows, Prohibitions, CharUtil, SymbolsNames, CHUNK, TypeDLOGUtil, TypeDLOGdraw, TypeNewDLOG, TypeDLOGFilter, CharStateTree;	function ChangeType (totype: integer; FW: WindowPtr): boolean;	procedure DefineType (showtype: integer);{еееееееееееееееееееееее}implementation {е$S TypeDLOG}{-----------------------------------------------------------------------------}	function ChangeType (totype: integer; FW: WindowPtr): boolean;		var			ic, icfound: integer;			retrace, werereals, didchange: boolean;			numfound: integer;			box: rect;			ht: integer;			tport: windowptr;{.................}		procedure ChangeCharType (ic, totype: integer);			var				oldtype: integer;		begin			if (TrueTypeOfChar(ic) <> totype) then  {no need to change it otherwise}				begin					oldtype := TypeOfChar(ic);					didchange := true;					SetType(ic, totype);					UseToTypeStorage(ic);					if oldtype = excluded then						SetType(ic, excluded);					numfound := numfound + 1;					icfound := ic;				end;		end;{.................}	begin		genericGetPort(tport);		Setcursor(clockCursor);		retrace := false;		numfound := 0;		didchange := false;		if IsTreeWindow(FW) and (traceshown = traceDiscrete) then			begin				if TypeLegalForChar(totype, i) then					begin						ChangeCharType(i, totype);						genericSetPort(chlegWindow);						WriteB(chlegtypeB, TypeName(totype));						genericSetPort(tport);						retrace := true;					end				else					NewError(76, i);			end		else if (FW = infoWindow[charinfo]) and infoSomeSelected[charinfo] then			begin{genericSetPort(infoWindow[charinfo]);}				for ic := 1 to numchars do					if InfoRowSelected(charinfo, ic) then						if TypeLegalForChar(totype, ic) then							begin								ChangeCharType(ic, totype);								if (traceshown = traceDiscrete) and (i = ic) then									retrace := true;							end						else							NewError(76, ic);			end		else if IsEditorWindow(FW) then			for ic := CharOfCell(editorSelectionTopLeft) to CharOfCell(editorSelectionBotRight) do				if TypeLegalForChar(totype, ic) then					ChangeCharType(ic, totype)				else					NewError(76, ic);		if didchange then			begin				InvalidateInfoColumn(charinfo, CharInfoTypes, 1, numchars);				dirtylink[typesetchain] := true;				InvalidateInfoWindow(typesetinfo);				CheckCurrentTypes;				TypesInUseMenu;				if treeopen then					begin						if numfound = 1 then							begin{Single character type changed; to save calculation times just send update for calculations concerning this character,}{whose number is stored below in global variable i2.}{Note that below the gomask is checked because the i2 and reset golist items are on demand, always available}{FROZEN 3.0}								i2 := icfound;								if CharIncluded(icfound) then									begin				{changesall, brchangesall need to be fully done because can't isolate effect of one character}				{settaxdni2 is called because needs to be redone regardless of what calcs are in effect}				{all charts need to be updated except those dealing with only character i (if i2=i dealt with later)}				{or if just states charts}										golist := golist + [settaxdni2, brchangesall, changesall] + (((fullgochartone - [statesichart, statesallchart]) + fullgochartmult) - igos);										if countall in gomask then  {if count then count i2 and reset length}											golist := golist + [counti2, resetlengthall];										if ciall in gomask then {likewise for CI & minlengths}											golist := golist + [calcminleni2, resetminlengthall, ciall];										if calcminlenall in gomask then											golist := golist + [calcminleni2, resetminlengthall];										if calcmaxlenall in gomask then											golist := golist + [calcmaxleni2, resetmaxlengthall];										if riall in gomask then {likewise for CI, RI, & minlengths, maxlengths}											golist := golist + [calcminleni2, resetminlengthall, calcmaxleni2, resetmaxlengthall, riall];										if reconstructall in gomask then											golist := golist + [reconstructi2];										if (i2 = i) then											golist := golist + igos; {if i was one changed then redo all i calculations}									end;								if nex7on & (i2 >= i7) & (i2 <= i7 + numboxes - 1) then									begin										genericSetPort(treewindow);										ht := N7Height(i2);										SetRect(box, databoxB.left, ht - n7LW, databoxB.right, ht);										InvalidateWindowRect(myGetWindowPtrForDialog(editTypeDialog),box,false);									end;							end						else if numfound > 1 then							begin{FROZEN 3.0}								ChangeTypesGoList;								goNex7on := nex7on & treeopen;							end;						if retrace then							OpenTraceMenus;					end;				dirtyfile := true;				myEnableItem(xxTypeSetsMHdl, StoreTypeSetItem);			end;		SetCursorToArrow;		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	procedure TypeConvertDiscCont;		var			isfrom, isto: integer;	begin		if not CurTypeHdl^^.isreal then  {inflate all dists by 10 since newly decimal}			begin				if CWARNING(' Do you want to simply append a decimal point to each cost value, or divide by 10 first?', 'Append', 'Divide') then					begin						for isfrom := 0 to maxmat do {First Check if OK to make continuous}							for isto := 0 to maxmat do								if TypeInflate * CurTypeHdl^^.dist[isfrom, isto] > MaxTypeReal then									begin										InstantError(200);										Exit(TypeConvertDiscCont);									end;						for isfrom := 0 to maxmat do {Now make continuous}							for isto := 0 to maxmat do								if CurTypeHdl^^.dist[isfrom, isto] <> infinity then									CurTypeHdl^^.dist[isfrom, isto] := CurTypeHdl^^.dist[isfrom, isto] * TypeInflate;					end;				CurTypeHdl^^.isreal := true;				InvalidateWindowRect(myGetWindowPtrForDialog(editTypeDialog),specRect,false);			end		else   {deflate all dists by 10 since no longer decimal}			begin				if CWARNING(' Do you want to truncate each cost value to next smallest integer, or multiply by 10 first?', 'Truncate', 'Multiply') then					for isfrom := 0 to maxmat do						for isto := 0 to maxmat do							if CurTypeHdl^^.dist[isfrom, isto] <> infinity then								CurTypeHdl^^.dist[isfrom, isto] := CurTypeHdl^^.dist[isfrom, isto] div TypeInflate;				CurTypeHdl^^.isreal := false;				InvalidateWindowRect(myGetWindowPtrForDialog(editTypeDialog),specRect,false);			end;		TypeEdited(curTypeHdl);	end;{$SETC DRMLN=FALSE}{$SETC DRMMETRIC=FALSE}{$IFC DRMMETRIC}{-----------------------------------------------------------------------------}	procedure ForceRandomType;		var			i, j, maxdef: integer;	begin		maxdef := curtypehdl^^.max;		for i := 0 to maxdef do			for j := 0 to maxdef do				typeHdl^^.dist[i, j] := RandomBetween(1, 10);		InvalidateWindowRect(myGetWindowPtrForDialog(editTypeDialog),specrect);	end;{-----------------------------------------------------------------------------}	function CheckFixMetricity (typHDL: typehandle): boolean;		label			1;		var			ia, ib, ic: integer;			ddist1, ddist2: distancetype;			maxdef, triangleDist: integer;			setdef: largestsetchars;			same, clean, nottriangle: boolean;	begin		SetCursor(clockCursor);		ddist1 := typHDL^^.dist;		ddist2 := typHDL^^.dist;		maxdef := typHDL^^.max;		Setdef := typHDL^^.setdefined;		nottriangle := false;		repeat			clean := true;			for ia := 0 to maxdef do				if ia in setdef then					for ib := 0 to maxdef do						if ib in setdef then							for ic := 0 to maxdef do								if ic in setdef then									begin										triangleDist := AddGEndist(ddist1[ia, ib], ddist1[ib, ic]);										if GenLessThan(triangleDist, ddist1[ia, ic]) then											begin												ddist1[ia, ic] := triangleDist;												clean := false;												nottriangle := true;											end;									end;		until clean;		if nottriangle then			repeat				clean := true;				for ia := maxdef downto 0 do					if ia in setdef then						for ib := maxdef downto 0 do							if ib in setdef then								for ic := maxdef downto 0 do									if ic in setdef then										begin											triangleDist := AddGEndist(ddist2[ia, ib], ddist2[ib, ic]);											if GenLessThan(triangleDist, ddist2[ia, ic]) then												begin													ddist2[ia, ic] := triangleDist;													clean := false;												end;										end;			until clean		else			InstantError(201);		same := true;		for ia := 0 to maxdef do			if ia in setdef then				for ib := 0 to maxdef do					if ib in setdef then						if ddist2[ia, ib] <> ddist1[ia, ib] then							begin								same := false;								goto 1;							end;1:		CheckFixMetricity := same;		SetCursorToArrow;	end;{$ENDC}{-----------------------------------------------------------------------------}{$IFC DRMLN}	procedure NatLogType;{converts current type to -ln; assumes values in current type 1 to max}		var			i, j, maxdef: integer;			max: longint;			probchange: real;			success: boolean;	begin		max := GetLongint('for probabilities, divide value by:', 1, 1, 100000, success);  {is 100000 best value?}		if success then			begin				maxdef := curtypehdl^^.max;				for i := 0 to maxdef do					for j := 0 to maxdef do						begin							probchange := 1.0 * typeHdl^^.dist[i, j] / (max * 1.0);							typeHdl^^.dist[i, j] := RoundValue(-ln(probchange) * 100);						end;				InvalidateWindowRect(myGetWindowPtrForDialog(editTypeDialog),specrect);			end;	end;{$ENDC}{-----------------------------------------------------------------------------}	procedure CheckTypesInUse;		var			j, ic: integer;			ctypP: IP;			oldState: SignedByte;	begin		LockHandle(chstoretypH, oldState);    {note that this is among included and excluded characters}		for j := 1 to numtypes do			begin				typeHdl := gettypeHdl(j);				typeHdl^^.inuse := false;				ctypP := IP(GetMaster(chstoretypH));				for ic := 1 to numchars do					begin						if ctypP^ = j then							begin								typeHdl^^.inuse := true;								leave;							end;						ctypP := IP(ord4(ctypP) + chtb);					end;			end;		ResetHandle(chstoretypH, oldstate);	end;{-----------------------------------------------------------------------------}	procedure MakeTypList;		var			firstrow, j: integer;			thecell: point;			ds: str255;			ic, dumi: integer;{......}	begin{v4:  don't include strat if DNA,RNA,or protein data file}{v4:  have separate list of strat types, store separately}		while typList^^.databounds.bottom > 0 do			LDelRow(1, 0, typList);		thecell.h := 0;		thecell.v := 0;		if showmatrix then			begin				numitems := numtypes;				firstrow := LAddRow(numitems, 0, typList);				for j := 1 to numtypes do					begin						ds := TypeListName(j);						LSetCell(Pointer(ord4(@ds) + 1), length(ds), thecell, typList);						thecell.v := thecell.v + 1;					end;			end		else			begin				numitems := 0;				for j := 1 to numtypes do					begin						typeHdl := gettypeHdl(j);						if typeHdl^^.root >= 0 then							begin								numitems := numitems + 1;								firstrow := LAddRow(1, numitems, typList);								thecell.v := firstrow;								ds := TypeListName(j);								LSetCell(Pointer(ord4(@ds) + 1), length(ds), thecell, typList);							end;					end;			end;	end;{-----------------------------------------------------------------------------}	procedure DeleteCurType (theDialog: DialogPtr; deletecell: point);		var			ds: str255;	begin		if Curtype = fisher then			ds := 'reset'		else			ds := 'delete';		ds := concat('That type is in use for some characters!  If you ', ds, ' it these characters will be assigned a default type.');		if not (CurType in curTypes) | ((Curtype = fisher) & Cwarning(ds, 'Reset', 'Cancel')) | ((Curtype <> fisher) & Cwarning(ds, 'Delete', 'Cancel')) then			begin				TypeEdited(curTypeHdl);				specchanged := false;				SubtractType(CurType, true, deletecell);				if CurType <> fisher then					ResetCurType(theDialog)				else					begin						ds := TypeListName(fisher);						LSetCell(Pointer(ord4(@ds) + 1), length(ds), deletecell, typList);						ReDrawTypeSpecs(theDialog, 7);					end;			end;	end;{-----------------------------------------------------------------------------}	procedure DefineType (showtype: integer);{$IFC DRMMETRIC}		const			numrandtypes = 1000;{$ENDC}		var{$IFC DRMMETRIC}			td: dialogptr;			tport: windowptr;{$ENDC}			tempP: WindowPtr;			itemtype, tnumtypes, firstrow, j, k, newdeftype, olddeftype: integer;			H, oldchtypH, oldchstoretypH, typeCHUNKsB, tempH: Handle;			box, databounds: rect;			db: boolean;			cellsize, thecell, olddefcell, deletecell: point;			ds: str255;			OS: OSerr;			thp: typeHdlPtr;			intP: IP;			oldFrontWindow: WindowPTr;			oldCurType, localItemHit: integer;UserItemUProcP: UniversalProcPtr;UserItemUProcP2: UniversalProcPtr;DLOGFilterUPP: UniversalProcPtr;{...............}		procedure EraseTypeRect;		begin			box := WindowPortRect(myGetWindowPtrForDialog(editTypeDialog));			box.top := fulltyprect.bottom + 6;			box.right := AvailR.right;			EraseRect(box);			InvalidateWindowRect(myGetWindowPtrForDialog(editTypeDialog),box,false);		end;{...............}		procedure CleanTypeDLOG;		begin			LSetDrawingMode(false, typList);			MakeTypList;			ButHilite(editTypeDialog);			ItemCheckMark(editTypeDialog, TDshowmatrix, showMatrix);			ItemCheckMark(editTypeDialog, TDcstree, not showmatrix);			LSetSelect(true, curTypeCell, typList);			LAutoScroll(typList);			EraseTypeRect;			EraseRect(fulltyprect);			InvalidateWindowRect(myGetWindowPtrForDialog(editTypeDialog),fulltyprect,false);			LSetDrawingMode(true, typList);			maxMat := CurTypeHdl^^.max;			CheckMaxMat;			DrawMatScrolls;			ShowHideEnter(editTypeDialog);		end;{...............}	begin		StepCellHeight := 16;		oldCurType := curType;		StepCellWidth := 20;		oldfrontwindow := frontwindow;		maxTypeEditMat := 9;		StepCells := StepCellsPtr(NewPtr(SizeOf(StepCellsArray)));		for j := 0 to absmaxstate do			for k := 0 to absmaxstate do				StepCells^[j, k] := false;		tnumtypes := numtypes;		oldchtypH := NewHandle(ord4(numchars) * chtb);		oldchstoretypH := NewHandle(ord4(numchars) * chtb);		CopyHandles(chtypH, oldchtypH);		CopyHandles(chstoretypH, oldchstoretypH);		typeCHUNKsB := NewHandle(numtypes * HdlSize);		for j := usedef to numtypes do			begin				H := Handle(gettypeHdl(j));				OS := HandToHand(H);				thp := typeHdlPtr(GetMaster(typeCHUNKsB) + (j - 1) * HdlSize);				thp^ := typeHandle(H);			end;		StartDLOG(322, editTypeDialog, tempP);		SetRect(nameRect, 110, 8, 210, 68);		nameRect := GetDLOGItemBox(editTypeDialog, 8);		SetRect(SpecRect, specleft, spectop, specleft + 10 * StepCellWidth + 1, spectop + 10 * StepCellHeight);		SetRect(moveB, 10, topPalette, 36, topPalette + 26);		SetRect(JoinB, 38, topPalette, 64, topPalette + 26);		SetRect(rrootB, 66, topPalette, 92, topPalette + 26);		mode := join;		SetRect(AvailR, Availleft - 5, firstCh, HtAvail + Availleft, topPalette - 5);		if maxstate > 12 then			SetRect(paletteR, leftPalette, topPalette, 360, topPalette + 36)		else			SetRect(paletteR, leftPalette, topPalette, 360, topPalette + 30);		numitems := numtypes;		fulltyprect := nameRect;		fulltyprect.right := fulltyprect.right + 15;		cellsize.h := namerect.right - namerect.left;		cellsize.v := 15;		SetRect(databounds, 0, 0, 1, 0);		typList := LNew(namerect, databounds, cellsize, 0, myGetWindowPtrForDialog(editTypeDialog), false, false, false, true);		typList^^.selFlags := typList^^.selFlags + lOnlyOne;		InsetRect(namerect, -1, -1);		LSetDrawingMode(FALSE, typList);		showmatrix := true;		typeBoundaryRect := GetDLOGItemBox(editTypeDialog, 7);{===== scrolls ======}		CurType := unordered;    {v3.03: set to unordered to get proper positioning of scroll bars}		CurTypeHdl := gettypeHdl(CurType);		Maxmat := CurTypeHdl^^.max;		CheckMaxMat;		CalcSpecRect(unordered, specleft, spectop, specrect);		SetRect(box, SpecRect.right + 5, specrect.top, specrect.right + 6 + scrollwidth, specrect.bottom);		vTypeScroll := NewControl(myGetWindowPtrForDialog(editTypeDialog), box, ' ', false, 0, 0, 9, scrollBarProc, 5);		SetRect(box, specrect.left, specrect.bottom + 5, specrect.right, specrect.bottom + 6 + scrollwidth);		hTypeScroll := NewControl(myGetWindowPtrForDialog(editTypeDialog), box, ' ', false, 0, 0, 9, scrollBarProc, 5);		vTypeStart := 0;		hTypeStart := 0;{====== set up current type ======}		CurType := showtype;		CurTypeHdl := gettypeHdl(CurType);		Maxmat := CurTypeHdl^^.max;		CheckMaxMat;		CalcSpecRect(CurType, specleft, spectop, specrect);		showmatrix := (CurTypeHdl^^.root < 0);		DrawMatScrolls;		ItemCheckMark(editTypeDialog, TDshowmatrix, showmatrix);		ItemCheckMark(editTypeDialog, TDcstree, not showmatrix);		if not showmatrix then			GetCSTree;		CheckTypesInUse;		MakeTypList;		curTypeCell.h := 0;		curTypeCell.v := ListCellofType(Curtype);		LSetSelect(true, curTypeCell, typList);		LAutoScroll(typList);		LSetDrawingMode(TRUE, typList);		CalcScrollTypeRect;		specchanged := false;		anyTypeChanged := false;		typeInUseChanged := false;{StepCellSel := false;}UserItemUProcP := MyNewUserItemUPP(@redrawtypeSpecs);  tempH := Handle(UserItemUProcP);		SetDialogItem(editTypeDialog, 7, UserItem, tempH, Specrect);UserItemUProcP2 := MyNewUserItemUPP(@typeNames);  tempH := Handle(UserItemUProcP2);		SetDialogItem(editTypeDialog, 8, UserItem, tempH, NameRect);		ButHilite(editTypeDialog);		EnableDisableDLOGItem(editTypeDialog, TDpaste, false, false);		EnableDisableDLOGItem(editTypeDialog, TDApply, ((IsEditorWindow(frontwindow)) and WholeCharSel) or ((frontwindow = infoWindow[charinfo]) and infoSomeSelected[charinfo]) or (IsTreeWindow(oldfrontwindow) and (traceshown = traceDiscrete)), false);		myShowDialog(editTypeDialog);		ShowHideEnter(editTypeDialog);		DLOGFilterUPP := MyNewModalFilterUPP(@typesfilter);  		repeat			myModalDialog(DLOGFilterUPP, localItemHit);			case localItemHit of				1: 					if not TypeValid(deletecell) then						begin							if deletecell.v <> -1 then								TidyDelete(editTypeDialog, deletecell);							localItemHit := notindialog;						end;				TDcopy: 					begin						if CurType = fisher then							Beep						else if TypeValid(deletecell) then							begin								if deletecell.v <> -1 then									TidyDelete(editTypeDialog, deletecell);								CopyTypeSpecs(CurType, dollo, true);								EnableDisableDLOGItem(editTypeDialog, TDpaste, true, false);							end;					end;				TDpaste: 					if CurType >= usedef then						begin							if not showmatrix and (cliproot < 0) then								Beep							else								begin									CopyTypeSpecs(dollo, CurType, false);									if not showmatrix then										GetCSTree;									ButHilite(editTypeDialog);									maxMat := MaxStateDefined(CurType);									CheckMaxMat;									TypeNames(editTypeDialog, 8);									ReDrawTypeSpecs(editTypeDialog, 7);									DrawMatScrolls;									specchanged := true;									TypeEdited(curTypeHdl);								end;						end					else						Beep;				TDclear:   {delete button}					DeleteCurType(editTypeDialog, deletecell);				TDrename:  {rename}{$IFC DRMMETRIC}					if optiondown then						ForceRandomType					else{$ENDC}						begin							RenameType;							InvalidateWindowRect(myGetWindowPtrForDialog(editTypeDialog),WindowPortRect(myGetWindowPtrForDialog(editTypeDialog)),false);						end;				TDnew: {new}{$IFC DRMLN}					if Optiondown and Commanddown then  {it converts current values to -ln}						NatLogType					else{$ENDC}						if numtypes = maxtypes then							InstantErrorPlus(202, StringFromNum(maxtypes))						else if TypeValid(deletecell) then							begin								if deletecell.v <> -1 then									TidyDelete(editTypeDialog, deletecell);								thecell.v := 0;								thecell.h := 0;								while LGetSelect(true, thecell, typList) do									LSetSelect(false, thecell, typList);								if CreateType(editTypeDialog) then									begin										CurType := numtypes;										CurTypeHdl := gettypeHdl(CurType);										maxmat := CurTypeHdl^^.max;										if not showmatrix then											GetCSTree;										EraseTypeRect;									end								else									LSetSelect(true, thecell, typList);								InvalidateWindowRect(myGetWindowPtrForDialog(editTypeDialog),WindowPortRect(myGetWindowPtrForDialog(editTypeDialog)),false);								ButHilite(editTypeDialog);							end;				TDshowmatrix: {matrix radio}					if not showmatrix then						if TypeValid(deletecell) then							begin								showmatrix := true;								if deletecell.v <> -1 then									TidyDelete(editTypeDialog, deletecell);								curTypeCell.v := CurType - 1;								CleanTypeDLOG;							end;				TDcstree: {cstree radio}					if showmatrix then						begin							showmatrix := false;{StepCellSel := false;}							if CurTypeHdl^^.root < 0 then								begin									CurType := ordered;									CurTypeHdl := gettypeHdl(CurType);									curTypeCell.v := 0;								end							else								curTypeCell.v := ListCellOfType(CurType);							CleanTypeDLOG;							GetCSTree;						end;				TDcleancheck: 	{clean up, check triangle inequal}					if not showmatrix then						begin							SetCursor(clockCursor);							if TypeValid(deletecell) then								begin									if deletecell.v <> -1 then										TidyDelete(editTypeDialog, deletecell);									CalcCleanCSTree;									UpdateCSTree;								end;						end					else {$IFC DRMMETRIC}						if Optiondown then							begin								if not CheckFixMetricity(curtypeHdl) then									begin										Beep;										Beep;										Beep;									end;							end						else if Commanddown then							begin								StartThermo(TD, tport, 0, numrandtypes, 'types', '', false);								for j := 1 to numrandtypes do									begin										UpdateThermo(td, 0, j, numrandtypes,false);										if abortedthermo then											leave;										ForceRandomType;										if not CheckFixMetricity(curtypeHdl) then											begin												Beep;												Beep;												Beep;												leave;											end;									end;								EndThermo(td, tport, true);							end						else{$ENDC}							TriangleDLOG;				TDdefault: 	{defaults}					if showmatrix | (CurTypeHdl^^.root >= 0) then						begin							olddefcell.h := 0;							olddefcell.v := ListCellOfType(deftype);							olddeftype := deftype;							thecell := ListCellSelected(typList, true);							newdeftype := TypeNumFromList(thecell);							if deftype <> newdeftype then {we have a new default}								deftype := newdeftype							else								{we are hitting Not Default}								deftype := unordered;{unsetting old default}							if olddefcell.v >= 0 then								begin									ds := TypeListName(olddeftype);									LSetCell(Pointer(ord4(@ds) + 1), length(ds), olddefcell, typList);								end;							olddefcell.v := ListCellOfType(deftype);							ds := TypeListName(deftype);							LSetCell(Pointer(ord4(@ds) + 1), length(ds), olddefcell, typList);							ButHilite(editTypeDialog);						end					else						Beep;   {can't set as empty cst}				TDsize: 	{change size...}					ReSizeType(editTypeDialog);				TDenter:   {enter}					begin						ds := GetEditText(editTypeDialog, 15);						if ds <> '' then							EnterStepValues(ds);					end;				TDsym: 	{Symmetrize...}					SymmetrizeType;  {in TypeNewDLOG}				TDApply:   {Apply}					if (curtype = dollo) & nucleotides then						Beep					else						begin							thecell := ListCellSelected(typList, true);							if ChangeType(CurType, oldFrontWindow) then								begin									curtypeHdl^^.inuse := true;									ds := TypeListName(curtype);									LSetCell(Pointer(ord4(@ds) + 1), length(ds), thecell, typList);									anyTypeChanged := true;									typeInUseChanged := true;								end;						end;				TDDiscCont: 					if CurType < usedef then						Beep					else if (CurTypeHdl^^.isreal) then						begin							if Cwarning('Do you want to convert the values in this transformation type to integers (discrete values)?', 'Yes', 'Cancel') then								begin									TypeConvertDiscCont;									if not CurtypeHdl^^.isreal then										SetButtonTitle(editTypeDialog, TDDiscCont, 'Decimal...');								end;						end					else						begin							if Cwarning('Do you want this transformation type to use continuous values (decimals)?', 'Yes', 'Cancel') then								begin									TypeConvertDiscCont;									if CurtypeHdl^^.isreal then										SetButtonTitle(editTypeDialog, TDDiscCont, 'Integral...')								end;						end;				otherwise					;			end;			if goerror then				if localItemHit = 1 then					showerrors('')				else if localItemHit <> 2 then					ShowErrors('');		until localItemHit in [1, 2];		LDispose(typList);		MyDisposeUserItemUPP(UserItemUProcP);		MyDisposeUserItemUPP(UserItemUProcP2);		MyDisposeModalFilterUPP(DLOGFilterUPP);		EndDLOG(editTypeDialog, tempP);		if localItemHit = 1 then			begin				if anyTypeChanged then					dirtyfile := true;				for j := usedef to numtypes do					CheckPolarity(j);				CheckCurrentTypes;				goNex7on := nex7on & treeopen;				ReBuildAssumpMenu;				if treeopen then					begin						genericSetPort(treewindow);						myValidRect(treeWindow,WindowPortRect(treeWindow));						genericSetPort(tempP);						godraw := true;{David- is it easy to find out if any type in use has been changed in the editor, e.g. save a set of changed types and compare}{to list of types in use, so we can redo calculations only if type is in use?}{Wayne- well,  I have had this on the list of things to do for v 3.1, as I didn't think I had time (and I didn't)}{I have tried to do it anyways, as it was really bothering me too. }{The difficulty is in picking up all things that can change types.  My list is as follows:}	{things that can change types in use:}		{* hitting the enter key or clicking on the enter button}		{* clicking on the Apply button}		{* deleting types}		{* copying and pasting types}		{* resizing types}		{* fixing triangle inequality on types}		{* changing type from discrete to continuous}		{* type symmetrized}		{* joining or unjoining CST balls, subtracting CST because it is empty, rerooting}{Basically, at any point that you change a type, in use or not, then call TypeEdit(curTypeHdl).  This will set}{the booleans anyTypeChanged and typeInUseChanged.  }						if typeInUseChanged then{FROZEN 3.0}							ChangeTypesGoList;					end;				if gettypeHdl(fisher)^^.dist[0, 0] = -2 then					fisheredited := true;			end		else			begin {realtypes:=oldrealtype;}				DeleteCHUNKs(typeCHUNKs, usedef, numtypes - usedef + 1);				numtypes := tnumtypes;				curType := oldCurType;				HUnlock(typeCHUNKs);				SetHandleSize(typeCHUNKs, numtypes * HdlSize);				for j := usedef to numtypes do					begin						thp := typeHdlPtr(GetMaster(typeCHUNKsB) + (j - 1) * HdlSize);						H := Handle(thp^);						OS := HandToHand(H);						thp := typeHdlPtr(GetMaster(typeCHUNKs) + (j - 1) * HdlSize);						thp^ := typeHandle(H);					end;				CopyHandles(oldchtypH, chtypH);				CopyHandles(oldchstoretypH, chstoretypH);				CheckCurrentTypes;			end;		DeleteCHUNKs(typeCHUNKsB, usedef, tnumtypes - usedef + 1);		ZapHandle(typeCHUNKsB);		ZapHandle(oldchtypH);		ZapHandle(oldchstoretypH);		ZapPointer(StepCells);	end;end.