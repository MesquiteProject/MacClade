unit ReadWriteUtil;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}interface	uses		Quickdraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound,		 Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources,  Scrap,  Navigation,		 Globals, MemoryUtil, WindowUtil, EventUtil, ErrorUtil,		SetLibInterface, UtilLibInterface,   Script, Printing, StandardFile;	function EqualFileSpecs (fileSpec1, fileSpec2: FSSpec): boolean;	procedure FlushFile(fileNum: integer);{FSSpec}		function FSpIsStationeryFile (fileSpec: FSSpec): boolean;	function FSpTempFileSpec (originalFileSpec: FSSpec): FSSpec;	procedure FSpSetFileCreatorType (FileSpec: FSSpec; setCreator, settype: OSType);	function LastModified (volnum: integer; fname: str255): longint;{	function FileInUse (volnum: integer; fname: str255; filenum: integer): boolean;}	function FSpLastModified (FileSpec: FSSpec): longint;	function FSpCreateResourceFork (FileSpec: FSSpec; ctype,ftype: OSType): boolean;	function FileIsBusy(fileSpec: FSSpec): boolean;  {FSSpec}	function FileIsLocked(fileSpec: FSSpec): boolean;  {FSSpec}	function FSpCreatorIsMacClade (FileSpec: FSSpec): boolean;	procedure SFPutSuffixedFile (var ds: str255; ext, SFstr: str255; var Freply: StandardFileReply);	procedure PutStandardFile (prompt, SFstr: str255; var Freply: StandardFileReply);	procedure PutCustomFile (prompt, SFstr: str255; var Freply: StandardFileReply; where: point; UPP: UniversalProcPtr);{$IFC POWERPC}	function MyNewNavEventUPP(theProc:Ptr): UniversalProcPtr;	procedure MyDisposeNavEventUPP(UPP:UniversalProcPtr);{$ENDC}{еееееееееееееееееееееее}implementation {е$S genutils}{-----------------------------------------------------------------------------}	procedure FlushFile(fileNum: integer);{FSSpec}	var 	PB: IOParam;		db: boolean;	begin 	{	PB.ioRefNum := fileNum;		PB.ioCompletion := nil;		db := IOSuccessful(PBFlushFileSync(@PB));}			end;{-----------------------------------------------------------------------------}	function EqualFileSpecs (fileSpec1, fileSpec2: FSSpec): boolean;	begin		EqualFileSpecs :=  (fileSpec1.parID = fileSpec2.parID)&  (fileSpec1.vRefNum = fileSpec2.vRefNum)& (fileSpec1.name = fileSpec2.name);	end;	{-----------------------------------------------------------------------------}	function FSpIsStationeryFile (fileSpec: FSSpec): boolean;		const			isStationery = 11;		var			theInfo: FInfo;	begin		FSpIsStationeryFile := (FSpGetFInfo(fileSpec, theInfo) = NoErr) & BitTst(@theInfo.fdFlags, 15 - isStationery);	end;{----------------------------------------------------------------------------}	procedure FSpSetFileCreatorType (FileSpec: FSSpec; setCreator, settype: OSType);{labels file fname in volume vnumber as being created by setCreator,}{ and having type settype}		var			theInfo: FInfo;			db: boolean;	begin		currentIOPosition := 83;		if IOSuccessful(FSpGetFInfo(FileSpec, theInfo)) & ((theInfo.fdCreator <> setCreator) | (theInfo.fdtype <> settype)) then			begin				theInfo.fdCreator := setcreator;				theInfo.fdType := settype;				currentIOPosition := 84;				db := IOSuccessful(FSpSetFInfo(FileSpec, theInfo));			end;	end;{-----------------------------------------------------------------------------}	function FSpTempFileSpec (originalFileSpec: FSSpec): FSSpec;		var			theInfo: FInfo;			ds, shortds: str255;			j: integer;			os: OSErr;			theFileSpec: FSSpec;	begin		j := 1;		shortds := Copystring(originalFileSpec.name, 1, 25);	{to prevent going over 31 character file name limit}		currentIOPosition := 50;   {v3.05}			repeat				numtostring(j, ds);				ds := concat(shortds, ' T', ds);				j := j + 1;			until HGetFInfo(originalFileSpec.vRefNum, originalFileSpec.parID, ds, theInfo) = FNFErr;		os := FSMakeFSSpec(originalFileSpec.vRefNum, originalFileSpec.parID, ds, theFileSpec);		if (os<>FNFErr) & not OSSuccessful(os) then			if not OSSuccessful(FSMakeFSSpec(0,0,ds,theFileSpec)) then				InstantInfo('Can''t make temporary FSSpecs');		FSpTempFileSpec:= theFileSpec;	end;{-----------------------------------------------------------------------------}	function FSpLastModified (FileSpec: FSSpec): longint;		var			PB: HFileParam;			ds : str255;	begin		PB.ioDirID := FileSpec.parID;		ds := FileSpec.name;		PB.ioCompletion := nil;		PB.iovRefNum := FileSpec.vRefNum;		PB.ioFVersNum := 0;		PB.ioFDirIndex := 0;		PB.ioNamePtr := @ds;		currentIOPosition := 551;   {v3.05}		if OSSuccessful(PBHGetFInfoSync(@PB)) then			FSpLastModified := PB.ioFlMdDat		else			FSpLastModified := 0;	end;{-----------------------------------------------------------------------------}{	function LastModified (volnum: integer; fname: str255): longint;		var			paramBlock: ParmBlkPtr;	begin		paramBlock := ParmBlkPtr(NewPtr(SizeOf(ParamBlockRec)));		paramBlock^.ioFDirIndex := 0;		paramBlock^.ioNamePtr := @fname;		paramBlock^.iovRefNum := volnum;		currentIOPosition := 55;   		if OSSuccessful(PBGetFInfoSync(paramBlock)) then			LastModified := paramBlock^.ioFlMdDat		else			LastModified := 0;		ZapPointer(paramBlock);	end;}{-----------------------------------------------------------------------------}	{-----------------------------------------------------------------------------}	function FSpCreateResourceFork (FileSpec: FSSpec; ctype,ftype: OSType): boolean;		var			err: OSErr;	begin		FSpCreateResFile(FileSpec,ctype,ftype,scriptTag);		err := ResError;		FSpCreateResourceFork := (err=dupFNErr) | OSSuccessful(err);	end;{-----------------------------------------------------------------------------}	function FileIsBusy(fileSpec: FSSpec): boolean;  {FSSpec}	var PB: HFileParam;	begin 		FileIsBusy := false;		PB.ioCompletion := nil;		PB.ioVRefNum := FileSpec.vRefNum;		PB.ioFVersNum := 0;		PB.ioFDirIndex := 0;		PB.ioNamePtr := @FileSpec.Name;		PB.ioDirID := FileSpec.parID;		if IOSuccessful(PBHGetFInfoSync(@PB)) then			FileIsBusy := BitTst(@PB.ioFlAttrib,0)|BitTst(@PB.ioFlAttrib,4)|BitTst(@PB.ioFlAttrib,1);	end;{-----------------------------------------------------------------------------}	function FileIsLocked(fileSpec: FSSpec): boolean;  {FSSpec}	var PB: HFileParam;	begin 		FileIsLocked := false;		PB.ioCompletion := nil;		PB.ioVRefNum := FileSpec.vRefNum;		PB.ioFVersNum := 0;		PB.ioFDirIndex := 0;		PB.ioNamePtr := @FileSpec.Name;		PB.ioDirID := FileSpec.parID;		if IOSuccessful(PBHGetFInfoSync(@PB)) then			FileIsLocked := BitTst(@PB.ioFlAttrib,7);	end;{-----------------------------------------------------------------------------}	function FileInUse (volnum: integer; fname: str255; filenum: integer): boolean;	begin				end;{-----------------------------------------------------------------------------}	function FSpCreatorIsMacClade (FileSpec: FSSpec): boolean;		var			resultCode : integer;			theInfo: FInfo;	begin		resultCode := FSpGetFInfo(FileSpec, theInfo);		FSpCreatorIsMacClade := (resultcode = NoErr) & (theInfo.fdCreator = 'CLAD');	end;{----------------------------------------------------------------------------}	procedure SFPutSuffixedFile (var ds: str255; ext, SFstr: str255; var Freply: StandardFileReply);	begin		ds := Copystring(ds, 1,maxFileNameLength-length(ext));		ds := concat(ds, ext);		PutStandardFile(SFstr, ds, Freply);	end;{$IFC POWERPC}{----------------------------------------------------------------------------}	function MyNewNavEventUPP(theProc:Ptr): UniversalProcPtr;	begin{$IFC NOT CARBON}		MyNewNavEventUPP :=  NewRoutineDescriptor(theProc,uppNavEventProcInfo, GetCurrentISA);{$ELSEC}		MyNewNavEventUPP := UniversalProcPtr(NewNavEventUPP(theProc)); {$ENDC}	end;{----------------------------------------------------------------------------}	procedure MyDisposeNavEventUPP(UPP:UniversalProcPtr);	begin{$IFC NOT CARBON}		DisposeRoutineDescriptor(UPP);{$ELSEC}		DisposeNavEventUPP(NavEventUPP(UPP));{$ENDC}	end;{----------------------------------------------------------------------------}	procedure NavPutEventProc(callBackSelector: NavEventCallbackMessage;  callBackParms: NavCBRecPtr;   callBackUD: NavCallBackUserData);        var navWindow: WindowPtr;	begin	    case callBackSelector of	    	kNavCBCustomize:	    		begin	    		end;	    	kNavCBAdjustRect:	    		begin	    		end;	    	kNavCBStart:	    		begin	    		end;	    	kNavCBTerminate:	    		begin	    		end;	    	kNavCBEvent:	    		begin	  			navWindow := callBackParms^.window;	  			case callBackParms^.eventData.eventDataParms.event^.what of	  				mouseDown:	  					begin	  					end;	  				otherwise;	  			end;	  					    		end;	    	otherwise;	    end;	end;{----------------------------------------------------------------------------}	procedure NavPutFileLocal (prompt, SFstr: str255; var Freply: StandardFileReply);	var		os: OSErr;			navReply: NavReplyRecord;			dialogOptions: NavDialogOptions;			numItems : longint;			actualSize: Size;			returnedType: DescType;			keywd: AeKeyword;			navUPP: UniversalProcPtr;	begin		Freply.sfGood := false;		if OSSuccessful(NavGetDefaultDialogOptions(dialogOptions)) then			begin				dialogOptions.savedFileName := SFstr;				dialogOptions.message := prompt;				navUPP := MyNewNavEventUPP(@NavPutEventProc);				os := NavPutFile(nil, navReply, @dialogOptions, NavEventUPP(navUPP), 'TEXT', 'CLAD', nil);				myDisposeNavEventUPP(navUPP);				if (os<>UserCanceledErr) & OSSuccessful(os) & navReply.validRecord then					begin						os := AECountItems(navReply.selection, numItems);						if (os=noErr) & (numItems>0) then							begin								os := AEGetNthPtr(navReply.selection, 1, typeFSS, keywd, returnedType, @Freply.sfFile, SizeOf(Freply.sfFile), actualSize);								if (os=noErr) then									Freply.sfGood := true;							end;					end;			end;	end;{$ENDC}{----------------------------------------------------------------------------}	procedure PutStandardFile (prompt, SFstr: str255; var Freply: StandardFileReply);	begin{$IFC POWERPC}		if hasNavigationalServices then			NavPutFileLocal(prompt, SFStr, Freply)		else {$ENDC}{$IFC NOT CARBON}		StandardPutFile(ConstStringPtr(@prompt), SFstr, Freply);{$ENDC}	end;{----------------------------------------------------------------------------}	procedure PutCustomFile (prompt, SFstr: str255; var Freply: StandardFileReply; where: point; UPP: UniversalProcPtr);	begin{$IFC POWERPC}		if hasNavigationalServices then			NavPutFileLocal(prompt, SFStr, Freply)		else {$ENDC}{$IFC NOT CARBON}		CustomPutFile(ConstStringPtr(@prompt),SFStr, Freply,-6043,where,UPP,nil,nil,nil,nil);{$ENDC}	end;end.