unit LinkUtil;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, 		TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, 		EventUtil, GenUtil, StrUtil, BoxUtil, ToolPalette, TaxonCHUtil, CharUtil, TypeUtil, TreeUtil, MenuUtil, CHUNK,		NexusBlocks, SimpleUtil;	procedure SetLinkBits(theChain: Integer; theLink: longint; linkH: Handle; theBit: integer; onoff: boolean);	function TestLinkBits(theChain: Integer; theLink: longint; linkH: Handle; theBit: integer): boolean;	function ChainFromInfo(whichInfo: integer): integer;	procedure SetLinkNameOfInfoRow (whichinfo: integer; theChain: Integer; theRow: longint; nom: str255);	function GetNumberElementsInLink (theChain: Integer; theLink: longint; linkH: Handle): integer;	procedure SetNumberElementsInLink (theChain: Integer; theLink: longint; linkH: Handle; number: integer);	function IsSetChain (theChain: Integer): boolean;	procedure PrepareLinkName (var ds: str255);	function LinkNameLength (linkH: Handle): integer;	function CurLinkName (H: Handle): str255;	procedure ClearLinkBytes (LinkH: Handle);	procedure SetLinkName (LinkH: Handle; nom: str255);	procedure InsertLinkStart (var linkH: Handle; nom: str255);	procedure RemoveLinkStart (linkH: Handle);	procedure SetWtLinkBits (linkH: Handle; isreal: boolean);	{function WtLinkIsReal (linkH: Handle): boolean;}	procedure MemoryToTaxSet (extendH: Handle; nom: str255);	procedure MemoryToCharExSet (extendH: Handle; nom: str255; theChain: Integer);	procedure SetOtherSelected(theChain: integer; ir: longint; on: boolean);	procedure InitOtherSelected(theChain: integer);	procedure CharSetLinkToBools (linkH: Handle; theSet: integer; setOperator: integer; setShadeCharSet: boolean);	procedure SetShadeCharSetBooleans(theSet: integer);	procedure TaxSetLinkToBools (linkH: Handle; theSet: integer; setOperator: integer);	procedure GetCurLinkName (theChain: Integer; linkH: Handle);	procedure SetLink (theChain: Integer; theLink: longint; H: Handle);	procedure GetLink (theChain: Integer; theLink: longint; var H: Handle; setCurLinkName: boolean);	procedure ChooseLink (theChain: Integer; checktypes: boolean);	procedure StoreTree (var packedH: handle; nom: str255);	procedure StoreOldTreeForUndo;	procedure SaveFixdataForTree (tH, fdH: handle);	procedure SaveSegmentsForTree (tH, fdH: handle);	procedure SaveRealLengthsForTree (tH, fdH: handle);	procedure SaveLinkToChain (theChain: Integer; nom: str255; savedefault, useSecondarySource: boolean);	function SaveLinkDLOG (theCHAIN: Integer): boolean;	procedure SaveDefaultAssumpLinks;	procedure SaveDefaultLink (theChain: Integer);	procedure ExciseDefaultLink (theChain: Integer);	procedure ExciseDefaultAssumpLinks;	procedure SetTreeLinkBytes (linkH: Handle; ispoly, isfixanc: boolean);	procedure LoadLinkUtil;{еееееееееееееееееееееее}implementation {е$S LinkUtil}{there are two types of links, (1) those as they exist in the CHAINS, with SLB starting bytes of info,}{the link name, and the link description  (2) links with no starting bytes and no name, just the description}{The second type include the handles chtypH, chstoretypH, chwtH, chstorewtH, and temporary handles}{(e.g. tree handles with packed tree immediately after packing, before starting info added}{NOTE on structure of an extended link, stored in the handle linkH:}{Bytes 0,1: integer giving offset to start of link description = SLB + length of link name}{Byte 2-5:  storage of various info about link}{Bytes 6... : name of link;  NOTE: 6 is a constant, = SLB}{description begins at offset given in bytes 0, 1}{Bytes 2-5:}{treeLinks:   }	{Byte 2:  leftmost bit set if polytomies in tree; next leftmost if fixanced}	{Byte 3: unused}	{Bytes 4,5:  integer giving number of legal terminal taxa in description				note that byte 4 is numberInLinkByte}{otherLinks: }	    {Byte 2: some bits used for selection and stuff    Bytes 4,5 used in some links to store number of elements in set    	(note: numberInLinkByte=4)    }{description}{treeLinks: }{Tree description is list of two-byte integers, each referring to a node.}{0 = internal node}{nullpacked = -32768 = internal node which does not really exist }{			because collapsed for polytomy}{positive integer = number of terminal taxon; position in matrix; needs adjustment if taxa }{			added, cut or rearranged in matrix}{negative integer = number of taxon fixed to ancestral position; occupies position in}{			tree description of internal node}{otherLinks:}{description is a list of two or four-byte integers, each referring to a particular }{character.  This desciption is thus numchars*2 or numchars*4 bytes long}{for boolean links}{||||||||||||||||||||||||||||  Basic Link Utilities  |||||||||||||||||||||||||||||||}{----------------------------------------------------------------------------}	procedure SetNumberElementsInLink (theChain: Integer; theLink: longint; linkH: Handle; number: integer);	var H: Handle;			ippt: ip;	begin		if linkH <> nil then			H := linkH		else			H := HdlPtr(GetMaster(strCHUNKs[theChain]) + HdlSize * ord4(thelink))^;		ippt := ip(GetMaster(H) + numberInLinkByte);  {don't need to lock}		ippt^ := number;	end;{----------------------------------------------------------------------------}	function GetNumberElementsInLink (theChain: Integer; theLink: longint; linkH: Handle): integer;	var H: Handle;	begin		if linkH <> nil then			H := linkH		else			H := HdlPtr(GetMaster(strCHUNKs[theChain]) + HdlSize * ord4(thelink))^;		GetNumberElementsInLink := ip(GetMaster(H) + numberInLinkByte)^;  {don't need to lock}	end;{----------------------------------------------------------------------------}	function LinkNameLength (linkH: Handle): integer;	begin		LinkNameLength := IP(GetMaster(linkH))^ - SLB;  {don't need to lock}	end;{----------------------------------------------------------------------------}	procedure SetLinkNameLength (linkH: Handle; strLength: integer);		var			iptt: ip;	begin		iptt := ip(GetMaster(LinkH));  {Don't need to lock}		iptt^ := strLength + SLB;  {setting offset byte}	end;{----------------------------------------------------------------------------}	procedure PrepareLinkName (var ds: str255);	begin		ds := CopyString(ds, 1, linknw);		StripBlanks(ds);		if odd(length(ds)) then			ds := concat(ds, ' ')		else			ds := concat(ds, '  ');	end;{----------------------------------------------------------------------------}	procedure SetLinkNameOfInfoRow (whichinfo: integer; theChain: Integer; theRow: longint; nom: str255);	var linkH: Handle;		theChainNumber: Integer;	begin		LinkH := newHandle(2);    {must create as GetLink expects it created}		if whichinfo=noinfo then			theChainNumber := theChain		else			theChainNumber := ChainFromInfo(whichInfo);		GetLink(theChainNumber, LinkNumberFromInfoRow(theChainNumber,theRow), linkH, false);		SetLinkName(linkH, nom);		SetLink(theChainNumber, LinkNumberFromInfoRow(theChainNumber,theRow), linkH);		ZapHandle(linkH);		if whichinfo <> noinfo then infoDirtyNames[whichinfo] := true;		dirtyfile := true;	end;{----------------------------------------------------------------------------}	procedure SetLinkName (LinkH: Handle; nom: str255);		var			ds: str255;			dL: longint;			oldLength: integer;			oldstate: SignedByte;	begin		if GetHandleSize(LinkH) < SLB then			begin				ClearLinkBytes(LinkH);				oldLength := 0;			end		else			oldLength := LinkNameLength(linkH);		ds := nom;		PrepareLinkName(ds);		UnlockHandle(linkH, oldstate);		dL := Munger(LinkH, SLB, nil, oldLength, Pointer(ord(@ds) + 1), length(ds));		ResetHandle(linkH, oldstate);		SetLinkNameLength(linkH, length(ds));	end;{-----------------------------------------------------------------------------}	procedure InsertLinkStart (var linkH: Handle; nom: str255);{takes the linkH without starting bytes and inserts starting info}		var			newLinkH: Handle;			db: boolean;	begin		newLinkH := NewHandle(2);		ClearLinkBytes(newLinkH);		SetLinkName(newLinkH, nom);		currentIOPosition := 66;   {v3.05}		db := OSSuccessful(HandAndHand(linkH, newlinkH));		ZapHandle(linkH);		linkH := newlinkH;	end;{-----------------------------------------------------------------------------}	procedure RemoveLinkStart (linkH: Handle);		var			dL: longint;			offset: integer;			oldstate: SignedByte;	begin		offset := LinkOffset(linkH);		UnlockHandle(linkH, oldstate);		DeletePieceOfHandle(LinkH, 0, offset);		ResetHandle(linkH, oldstate);	end;{----------------------------------------------------------------------------}	procedure ClearLinkBytes (LinkH: Handle);		var			iptt: ip;			j: integer;			oldstate: SignedByte;	begin		UnlockHandle(linkH, oldstate);		if GetHandleSize(LinkH) < SLB then			SetHandleSize(LinkH, SLB);		HLock(LinkH);		for j := 1 to SLB div 2 do			begin				iptt := ip(GetMaster(LinkH) + 2 * (j - 1));				iptt^ := 0;			end;		ResetHandle(linkH, oldstate);	end;{||||||||||||||||||||||||||||  GettingSetting Links  |||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	procedure SetLink (theChain: Integer; theLink: longint; H: Handle);{sets theLink in theChain to be H; note that the link must already exist within the chain}		var			dhp: HdlPtr;			oldstate: SignedByte;	begin		LockHandle(strCHUNKs[theChain], oldstate);		dhp := HdlPtr(GetMaster(strCHUNKs[theChain]) + HdlSize * ord4(theLink)); {assumes 0-based theLink}		CopyHandles(H, dhp^);		ResetHandle(strCHUNKs[theChain], oldstate);	end;{----------------------------------------------------------------------------}	procedure GetCurLinkName (theChain: Integer; linkH: Handle);	begin		curLinkNames[theChain]^^ := GetLinkName(linkH);		if curLinkNames[theChain]^^ = UnStoredLink then			begin				curLinkNames[theChain]^^ := '';				if theChain = treeChain then					dirtytree := true;				dirtylink[thechain] := true;			end		else			dirtylink[thechain] := false;		if theChain = treeChain then			treename^^ := curLinkNames[theChain]^^;	end;{----------------------------------------------------------------------------}	procedure GetLink (theChain: Integer; theLink: longint; var H: Handle; setCurLinkName: boolean);{this returns in H the handle for a link.   NOTE THAT H must ALREADY EXIST!!!!}		var			dhp: HdlPtr;			oldState: SignedByte;	begin		LockHandle(strCHUNKs[theChain], oldState);		dhp := HdlPtr(GetMaster(strCHUNKs[theChain]) + HdlSize * ord4(theLink));  {assumes passed 0-based theLink}		CopyHandles(dhp^, H);		ResetHandle(strCHUNKs[theChain], oldstate);		if setcurLinkname then			GetCurLinkName(theChain, H);	end;{----------------------------------------------------------------------------}	procedure ExSetLinkToMemory (extendH: Handle);		var			charHdl: chHdl;			exP: IP;			ic: integer;			offset: integer;			oldstate1, oldstate2: SignedByte;	begin		LockHandle(extendH, oldstate1);		offset := LinkOffSet(extendH);		for ic := 1 to numchars do			begin				charHdl := chHdlPtr(GetMaster(chCHUNKs) + HdlSize * longint(ic - 1))^;				LockHandle(charHdl, oldstate2);				exP := IP(GetMaster(extendH) + offset + exb * longint(ic - 1));				with charHdl^^ do					if deleted and (exp^ = 1) then 		{including character}						begin							deleted := false;							WtStorageToUse(ic);							TypeStorageToUse(ic);							if not TypeLegalForChar(typeofchar(ic), ic) then								begin									NewError(41, ic);									deleted := true;									SetType(ic, excluded);								end;						end					else if not deleted and (exp^ = 0) then  {excluding a character}						begin							deleted := true;							UseToWtStorage(ic);							UseToTypeStorage(ic);							UseToPartStorage(ic);							SetType(ic, excluded);						end;				ResetHandle(charHdl, oldstate2);{    if ((exP^ = 0) and CharIncluded(ic)) or ((exP^ = 1) and not CharIncluded(ic)) then SwitchIncExc(ic);}			end;		ResetHandle(extendH, oldstate1);	end;{-----------------------------------------------------------------------------}	procedure CheckTypeLegality (oldH: Handle);		var			ds: str255;			j, defAssignType: integer;			intP: IP;			oldstate: SignedByte;	begin		if nullson and AnyType([irreversible, fisher, dollo, usedef]) then			begin				defAssignType := deftype;				if defAssignType <> ordered then					defAssignType := unordered;				ds := TypeName(defAssignType);				if CWarning(concat('Only unordered and ordered types allowed with polytomies.  Do you wish to replace other types with ', ds, '?'), 'Replace', 'Cancel') then					begin						LockHandle(chstoretypH, oldstate);						intP := IP(GetMaster(chstoretypH));						for j := 1 to numchars do							begin								if (intP^ >= irreversible) then									intP^ := defAssignType;								intP := IP(ord4(intP) + chtb);							end;						ResetHandle(chstoretypH, oldstate);					end				else					CopyHandles(oldH, chstoretypH);			end		else if ancon and AnyType([dollo, usedef]) then			begin				defAssignType := deftype;				if defAssignType >= dollo then					defAssignType := unordered;				ds := TypeName(defAssignType);				if CWarning(concat('Dollo and user-defined types not allowed with fixed ancestors.  Do you wish to replace other types with ', ds, '?'), 'Replace', 'Cancel') then					begin						LockHandle(chstoretypH, oldstate);						intP := IP(GetMaster(chstoretypH));						for j := 1 to numchars do							begin								if (intP^ >= dollo) then									if deftype < dollo then										intP^ := defAssigntype;								intP := IP(ord4(intP) + chtb);							end;						ResetHandle(chstoretypH, oldstate);					end				else					CopyHandles(oldH, chstoretypH);			end;	end;{----------------------------------------------------------------------------}{  setReplace = 0;}{    setUnion = 1;}{    setIntersection = 2;}{    setSubtraction = 3;}{    setComplement = 4;    }	procedure CharSetLinkToBools (linkH: Handle; theSet: integer; setOperator: integer;setShadeCharSet: boolean);{sets charsetbit for each char with 1 in the extended charset Handle linkH}{setOperator tells whether to replace the old set with this new set, or whatever...}		var			charHdl: chHdl;			exP: IP;			ic: integer;			offset: integer;			oldstate1, oldstate2: SignedByte;	begin		if (linkH=nil) & setShadeCharSet then			Exit(CharSetLinkToBools);		if (linkH = nil) then {v3.05: it is a pre-defined set}			begin				for ic := 1 to numchars do					begin						charHdl := chHdlPtr(GetMaster(chCHUNKs) + HdlSize * longint(ic - 1))^;						LockHandle(charHdl, oldstate2);						with charHdl^^ do							if theSet = invarCharSet then								charset := InvariantChar(ic)							else if theSet = uninformCharSet then {note that currently MacClade ignores this character set}								charset := false							else								charSet := ((theSet = pos1CharSet) & (codpos = 1)) | ((theSet = pos2CharSet) & (codpos = 2)) | ((theSet = pos3CharSet) & (codpos = 3)) | ((theSet = nonCodingCharSet) & (codpos = noncoding));						ResetHandle(charHdl, oldstate2);					end;			end		else			begin				LockHandle(linkH, oldstate1);				offset := LinkOffSet(linkH);				for ic := 1 to numchars do					begin						charHdl := chHdlPtr(GetMaster(chCHUNKs) + HdlSize * longint(ic - 1))^;						LockHandle(charHdl, oldstate2);						exP := IP(GetMaster(linkH) + offset + exb * longint(ic - 1));						if setShadeCharSet then							begin								if (exp^ = 1) then 		{removing from charset}									charHdl^^.charSetToShade := false								else if (exp^ = 0) then  {including within charset}									charHdl^^.charSetToShade := true;							end						else							begin								if (exp^ = 1) then 		{removing from charset}									charHdl^^.charSet := false								else if (exp^ = 0) then  {including within charset}									charHdl^^.charset := true;							end;						ResetHandle(charHdl, oldstate2);					end;				ResetHandle(linkH, oldstate1);			end;	end;{----------------------------------------------------------------------------}	procedure SetShadeCharSetBooleans(theSet: integer);	var linkH: Handle;	begin		linkH := NewHandle(2);		GetLink(charSetChain,theSet, LinkH, true);		CharSetLinkToBools(linkH, 0, setReplace, true);		ZapHandle(linkH);	end;{----------------------------------------------------------------------------}	procedure TaxSetLinkToBools (linkH: Handle; theSet: integer; setOperator: integer);{sets taxset bit for each taxa with 1 in the extended taxset Handle linkH}{setOperator tells whether to replace the old set with this new set, or whatever...}		var			TaxonHdl: THdl;			exP: IP;			it: integer;			offset: integer;			oldstate1, oldstate2: SignedByte;	begin		LockHandle(linkH, oldstate1);		offset := LinkOffSet(linkH);		for it := 1 to numtaxa do			begin				TaxonHdl := THdlPtr(GetMaster(TaxonCHUNKs) + HdlSize * longint(it - 1))^;				LockHandle(TaxonHdl, oldstate2);				exP := IP(GetMaster(linkH) + offset + exb * longint(it - 1));				with taxonHdl^^ do					if (exp^ = 1) then 		{removing from taxSet}						taxSet := false					else if (exp^ = 0) then  {including within taxSet}						taxset := true;				ResetHandle(TaxonHdl, oldstate2);			end;		ResetHandle(linkH, oldstate1);	end;{-----------------------------------------------------------------------------}	procedure SetWtLinkBits (linkH: Handle; isreal: boolean);		var			oldState: SignedByte;	begin		LockHandle(linkH, oldstate);		if isreal then			Bitset(ptr(GetMaster(linkH)), wtrealbit)		else			BitClr(ptr(GetMaster(linkH)), wtrealbit);		ResetHandle(linkH, oldstate);	end;{-----------------------------------------------------------------------------}{	function WtLinkIsReal (linkH: Handle): boolean;		var			oldState: SignedByte;	begin		LockHandle(linkH, oldstate);		WtLinkIsReal := BitTST(ptr(GetMaster(linkH)), wtrealbit);  		ResetHandle(linkH, oldstate);	end;}{-----------------------------------------------------------------------------}	procedure ChooseLink (theChain: Integer; checktypes: boolean);		var			oldH, linkH: Handle;			defAssignType: integer;	begin		dirtylink[thechain] := false;		InvalidateInfoWindow(typesetinfo);		if thechain in [treefilechain, datafilechain] then			dirtytree := false;		SetCursor(clockCursor);		linkH := NewHandle(2);		GetLink(theChain, Linknumber[theChain], LinkH, true);		if not (theChain in [treefilechain, datafilechain]) then			dirtyLink[theChain] := GetLinkName(LinkH) = UnStoredLink;		case theChain of			typeSetChain: 				begin					oldH := NewHandle(2);					CopyHandles(chstoretypH, oldH);					CopyHandles(LinkH, chstoretypH);					RemoveLinkStart(chstoretypH);					if nodes then						CheckTypeLegality(oldH);					ZapHandle(oldH);					CopyHandles(chstoretypH, chtypH);					TypeSetExclude(chtypH);{FROZEN 3.0}					if nodes then  {if change types then everthing is updated except charts showing freq of states or continuous char}						ChangeTypesGolist;					if checktypes then						CheckCurrentTypes;					goNex7on := nex7on & treeopen;					InvalidateInfoWindow(typesetinfo);				end;			wtSetChain: 				begin					realwt := TestLinkBit(0,0,linkH,wtrealbit);					CopyHandles(linkH, chstorewtH);					RemoveLinkStart(chstorewtH);					CopyHandles(chstorewtH, chwtH);					WtSetExclude(chwtH);					if nodes then						WtChangeGoList;					CheckWt1;					InvalidateInfoWindow(wtsetinfo);				end;{$IFC CHARPARTITIONS}			charPartitionChain: 				begin					CopyHandles(linkH, chStorePartitionH);					RemoveLinkStart(chStorePartitionH);					CopyHandles(chStorePartitionH, chPartitionH);				//	WtSetExclude(chPartitionH);					CheckAllOnePartition;					InvalidateInfoWindow(charpartinfo);				end;{$ENDC}			datafileChain, treefileChain: 				begin					CopyHandles(linkH, treedataH);					SetControlValueLong(tlegscroll, linknumber[treechain] - StartUserLink(treechain) + 1);					InvalidateInfoWindow(treeinfo);				end;			exSetChain: 				begin					ExSetLinkToMemory(linkH);					if checktypes then						CheckCurrentTypes;					if nucleotides then						CheckForCodPos(false);					CalcNumCharIncluded;{FROZEN 3.0}					if nodes then  {if change exset then do all things having to do with non-traced and non-continuous}						ChangeExclusionsGolist;					InvalidateInfoWindow(exsetinfo);				end;			charSetChain: 				CharSetLinkToBools(linkH, 0, setReplace, false);			taxSetChain: 				TaxSetLinkToBools(linkH, 0, setReplace);			otherwise				;		end;		ZapHandle(linkH);		SetCursorToArrow;	end;{-----------------------------------------------------------------------------}	{function StoredTreeIsPolytomous (theTrees): boolean;		var			oldState: SignedByte;	begin		LockHandle(linkH, oldstate);		StoredTreeIsPolytomous:= BitTest(ptr(GetMaster(linkH)), polytomybit);		ResetHandle(linkH, oldstate);	end;}{-----------------------------------------------------------------------------}{SetTreeNameAndBytes(packinhereH, tn, numterminals)}{has been replaced by two general procedures.  Thus, you can duplicate the affect of SetTreeNameAndBytes}{by calling       InsertLinkStart(packinhereH, tn);}				{SetNumtaxaInPackedTree ( packinhereH , numterminals );}{Note also in LinkUtil (formerly StringIn and StringSave), the procedure SetTreeLinkBytes}	procedure SetTreeLinkBytes (linkH: Handle; ispoly, isfixanc: boolean);		var			oldState: SignedByte;	begin		LockHandle(linkH, oldstate);		if ispoly then			Bitset(ptr(GetMaster(linkH)), polytomybit)		else			BitClr(ptr(GetMaster(linkH)), polytomybit);		if isfixanc then			Bitset(ptr(GetMaster(linkH)), fixancbit)		else			BitClr(ptr(GetMaster(linkH)), fixancbit);		ResetHandle(linkH, oldstate);	end;{----------------------------------------------------------------------------}	procedure StoreTree (var packedH: handle; nom: str255);  {stores current tree in packedH}		var			dL: longint;			thisnode: integer;			packedP: ptr;			tempH: handle;			ds: str255;			arepoly, arefixanc: boolean;			ipoff: integer;			iptt: ip;			numterminals: integer;			oldstate: SignedByte;{..............}		procedure StoreTreeRec (N: Nptr);  {converts tree to packed tree}		begin			if NodeIsTerminal(N) then				begin					Numterminals := numterminals + 1;					if not N^.fixanc then						begin							thisnode := thisnode + 1;							SetPackedNode(PackedP, thisnode, N^.name);						end					else						arefixanc := true;				end			else				begin					if not N^.fixanc then						begin							thisnode := thisnode + 1;							if not N^.null then								SetPackedNode(PackedP, thisnode, 0)							else								begin									SetPackedNode(PackedP, thisnode, nullpacked);									arepoly := true;								end;							StoreTreeRec(N^.lf);							StoreTreeRec(N^.rt);						end					else						begin							arefixanc := true;							thisnode := thisnode + 1;							Numterminals := numterminals + 1;							SetPackedNode(PackedP, thisnode, -TermOfFixanc(N)^.name);							StoreTreeRec(DescOfFixanc(N));						end;				end;		end;{..............}	begin		if nodes then			begin {save tree name in appropriate place}				arepoly := false;				arefixanc := false;				thisnode := 0;				Numterminals := 0;				UnlockHandle(packedH, oldstate);				SetHandleSize(packedH, longint(numtaxa * 2 + 2) * 4 + 4);{ + SLB + 2}				InsertLinkStart(packedH, nom);  {insert starting bytes and name}				HLock(packedH);				PackedP := StartOfPackedTree(0, 0, packedH);				StoreTreeRec(R);				ipoff := LinkOffset(packedh);  {getting offset to start of tree}				SetNumTaxaInPackedTree(packedH, numterminals);				SetTreeLinkBytes(packedH, arepoly, arefixanc);				HUnlock(packedH);				SetHandleSize(packedH, ord4(thisnode) * 2 + ipoff);				ResetHandle(packedH, oldstate);			end		else			InstantError(170);	end;{----------------------------------------------------------------------------}	procedure StoreOldTreeForUndo;		var			oldstate: SignedByte;	begin		oldlinknumber[treechain] := linknumber[treechain];		if dirtytree then			begin				StoreTree(oldtreeH, UnStoredLink)			end		else			begin				LockHandle(treename, oldstate);				StoreTree(oldtreeH, treename^^);				ResetHandle(treename, oldstate);			end;		SaveSegmentsForTree(oldtreeH, segdataH); {Segments:}		SaveRealLengthsForTree(oldtreeH, realBranchLengthsDataH);		FixLostByUndo := fixon;	end;{----------------------------------------------------------------------------}	procedure SaveRealLengthsForTree (tH, fdH: handle);		var			ds: str255;{.......}		procedure SaveBranchLengthsRec (N: Nptr);  		begin			if NodeIsInternal(N) then				begin					if BranchExists(N) then						begin							AppendToHandle(fdH, '(');							RealToString(N^.realLength,ds,1000000,branchLengthSigDigits,false); 							AppendToHandle(fdH, ds);						end;					SaveBranchLengthsRec(N^.lf);					SaveBranchLengthsRec(N^.rt);				end			else if Branchexists(N) then				begin					AppendToHandle(fdH, 't');					RealToString(N^.realLength,ds,1000000,branchLengthSigDigits,false); 					AppendToHandle(fdH, ds);				end;		end;{.......}	begin		if not allRealLengthsDefault then			begin				StringToH('default ', fdH);  {v3.05: replaced 'segs' by 'default'}				SaveBranchLengthsRec(R);				AppendToHandle(fdH, ';');  {v3.02:}				BitSet(ptr(GetMaster(tH)), branchLengthStoredBit);			end		else			begin				StringToH('0', fdH);				BitClr(ptr(GetMaster(tH)), branchLengthStoredBit);			end;	end;{----------------------------------------------------------------------------}	procedure SaveSegmentsForTree (tH, fdH: handle);  {Segments:}		var			ds: str255;{.......}		procedure SaveSegRec (N: Nptr);  {converts segments to string of numbers}		begin			if NodeIsInternal(N) then				begin					if BranchExists(N) then						begin							AppendToHandle(fdH, '(');							Numtostring(N^.setLength, ds);							AppendToHandle(fdH, ds);						end;					SaveSegRec(N^.lf);					SaveSegRec(N^.rt);				end			else if Branchexists(N) then				begin					AppendToHandle(fdH, 't');					Numtostring(N^.setLength, ds);					AppendToHandle(fdH, ds);				end;		end;{.......}	begin		if not allSetLengths1 then			begin				StringToH('default ', fdH);  {v3.05: replaced 'segs' by 'default'}				SaveSegRec(R);				AppendToHandle(fdH, ';');  {v3.02:}				BitSet(ptr(GetMaster(tH)), segstoredbit);			end		else			begin				StringToH('0', fdH);				BitClr(ptr(GetMaster(tH)), segstoredbit);			end;	end;{----------------------------------------------------------------------------}	procedure SaveFixdataForTree (tH, fdH: handle);		var			ds: str255;{..............}		procedure SaveFixRec (N: Nptr);  {converts fixdata to parenthesis strings}		begin			if NodeIsInternal(N) then				begin					if BranchExists(N) then						begin							if N^.fix then								begin									AppendToHandle(fdH, '{');									ds := settostring(N^.fixsts);									AppendToHandle(fdH, ds)								end							else								AppendToHandle(fdH, '(');						end;					SaveFixRec(N^.lf);					SaveFixRec(N^.rt);				end			else if BranchExists(N) then				begin					if N^.fix then						begin							AppendToHandle(fdH, 'T');							ds := settostring(N^.fixsts);							AppendToHandle(fdH, ds)						end					else						AppendToHandle(fdH, 't');				end;		end;	begin		if fixon then			begin				StringToH('default ', fdH);  {v3.05: replaced 'fixed' by 'default'}				SaveFixRec(R);				BitSet(ptr(GetMaster(tH)), charfixedbit);			end		else			begin				StringToH('0', fdH);				if currentTool[treeTools] = turpentineT then					currentTool[treeTools] := arrowT;				DimTool(treeTools,turpentineT);				BitClr(ptr(GetMaster(tH)), charfixedbit);			end;	end;{-----------------------------------------------------------------------------}	procedure SetOtherSelected(theChain: integer; ir: longint; on: boolean);		var			charHdl: chHdl;			TaxonHdl: tHdl;	begin		case theChain of			taxSetChain:				begin					taxonHdl := gettaxonHdl(ir);					taxonHdl^^.otherSelected := on;				end;			charSetChain:				begin					charHdl := getChHdl(ir);					charHdl^^.otherSelected := on;				end;			otherwise;		end;	end;{-----------------------------------------------------------------------------}	procedure InitOtherSelected(theChain: integer);		var			charHdl: chHdl;			TaxonHdl: tHdl;			ir: integer;	begin		case theChain of			taxSetChain:				for ir := 1 to numtaxa do					begin						taxonHdl := gettaxonHdl(ir);						taxonHdl^^.otherSelected := false;					end;			charSetChain:				for ir := 1 to numchars do					begin						charHdl := getChHdl(ir);						charHdl^^.otherSelected := false;					end;			otherwise;		end;	end;{-----------------------------------------------------------------------------}	procedure TaxInfoSeltoTaxSet(useSecondarySource: boolean);{transfers currently selected rows in char status window into charHdl^^.charSet}		var			TaxonHdl: tHdl;			it: integer;	begin		for it := 1 to numtaxa do			begin				taxonHdl := gettaxonHdl(it);				if useSecondarySource then					taxonHdl^^.taxSet := taxonHdl^^.otherSelected				else					taxonHdl^^.taxSet := taxonHdl^^.infoSelected;			end;	end;{-----------------------------------------------------------------------------}	procedure EditorSeltoTaxSet;{transfers currently selected rows in editor into charHdl^^.charSet}		var			TaxonHdl: tHdl;			it: integer;	begin		for it := 1 to numtaxa do			begin				taxonHdl := gettaxonHdl(it);				taxonHdl^^.taxSet := WholeTaxonIsSelected(it);			end;	end;{-----------------------------------------------------------------------------}	procedure CharInfoSeltoCharSet(useSecondarySource: boolean);{transfers currently selected rows in char status window into charHdl^^.charSet}		var			charHdl: chHdl;			ic: integer;	begin		for ic := 1 to numchars do			begin				charHdl := getChHdl(ic);				if useSecondarySource then					charHdl^^.charSet := charHdl^^.otherSelected				else					charHdl^^.charSet := charHdl^^.infoSelected;			end;	end;{-----------------------------------------------------------------------------}	procedure EditorSeltoCharSet;{transfers currently selected rows in editor into charHdl^^.charSet}		var			charHdl: chHdl;			ic: integer;	begin		for ic := 1 to numchars do			begin				charHdl := getChHdl(ic);				charHdl^^.charSet := WholeCharIsSelected(ic);			end;	end;{----------------------------------------------------------------------------}	procedure MemoryToTaxSet (extendH: Handle; nom: str255);		var			offset: integer;			exP: IP;			it: integer;			oldstate: SignedByte;			numElements : integer;	begin		ClearLinkBytes(extendH);		SetLinkName(extendH, nom);		offset := LinkOffset(extendH);		UnlockHandle(extendH, oldstate);		SetHandleSize(extendH, offset + ord4(numtaxa) * exb);		HLock(extendH);		numElements := 0;		for it := 1 to numtaxa do			begin				exP := IP(GetMaster(extendH) + offset + exb * longint(it - 1));				if not InTaxSet(it) then					begin						exP^ := 1;					end				else					begin						exP^ := 0;						numElements := numElements + 1;					end;			end;		SetNumberElementsInLink(0,0,extendH,numElements);		ResetHandle(extendH, oldstate);	end;{----------------------------------------------------------------------------}	procedure MemoryToCharExSet (extendH: Handle; nom: str255; theChain: Integer);		var			offset: integer;			exP: IP;			ic: integer;			oldstate: SignedByte;			numElements: integer;	begin		ClearLinkBytes(extendH);		SetLinkName(extendH, nom);		offset := LinkOffset(extendH);		UnlockHandle(extendH, oldstate);		SetHandleSize(extendH, offset + ord4(numchars) * exb);		numElements := 0;		HLock(extendH);		for ic := 1 to numchars do			begin				exP := IP(GetMaster(extendH) + offset + exb * longint(ic - 1));				if ((theChain = exsetChain) & charIncluded(ic)) | ((theChain = charsetChain) & not InCharSet(ic)) then					begin						exP^ := 1;						if theChain=exSetChain then numElements := numElements+1;					end				else					begin						exP^ := 0;						if theChain=charsetChain then numElements := numElements+1;					end;			end;		SetNumberElementsInLink(0,0,extendH,numElements);		ResetHandle(extendH, oldstate);	end;{-----------------------------------------------------------------------------}	procedure SaveLinkToChain (theChain: Integer; nom: str255; savedefault, useSecondarySource: boolean);		var			oldtreechain: Integer;			ldhp: HdlPtr;			ds: str255;			memrequired: longint;			linkH: Handle;			amountneeded: longint;	begin		linkH := NewHandle(2);		case thechain of			treefileChain, datafilechain: 				memrequired := longint(numtaxa * 2 + 2) * 4 + 4 + SLB + 2;			taxsetChain:				memrequired := longint(numtaxa)*2;			otherwise				memrequired := longint(numchars) * 2;		end;		if not EnoughMemory(3 * memrequired, amountneeded) then			begin				InstantErrorPlus(171, concat(StringFromNum(amountneeded div 1024), 'K'));				errorflag := true;				Exit(SaveLinkToChain);			end;		{setcursor(clockCursor);}		UserLinks[theChain] := UserLinks[theChain] + 1;		ds := nom;		if thechain in [treefilechain, datafilechain] then			begin{note that treechains do not require PrepareToken as they read tree names}{in their own special way, not using a GetToken system}				if not savedefault then					begin						UnderLineToBlanks(nom);						treename^^ := nom;						SetControlMaximumLong(tlegScroll, UserLinks[treechain]);						SetControlValueLong(tlegScroll, UserLinks[treechain]);					end;			end;		curLinkNames[theChain]^^ := ds;		case theChain of			typesetChain: 				begin					CopyHandles(chstoretypH, linkH);					InsertLinkStart(linkH, ds);				end;			wtSetChain: 				begin					CopyHandles(chstorewtH, linkH);					InsertLinkStart(linkH, ds);					SetWtLinkBits(linkH, realwt);				end;			charPartitionChain: 				begin					CopyHandles(chstorePartitionH, linkH);					InsertLinkStart(linkH, ds);				end;			exSetChain: 				begin					MemoryToCharExSet(linkH, ds, exsetChain);				end;			charSetChain: 				begin					if IsEditorWindow(frontWindow) & WholeCharSel then						EditorSelToCharSet					else						CharInfoSeltoCharSet(useSecondarySource);					MemoryToCharExSet(linkH, ds, charsetChain);				end;			taxSetChain: 				begin					if IsEditorWindow(frontWindow) & WholeTaxonSel then						EditorSelToTaxSet					else						TaxInfoSeltoTaxSet(useSecondarySource);					MemoryToTaxSet(linkH, ds);				end;			treefileChain, datafilechain: 				begin					oldtreechain := treechain;					treechain := theChain;					if nodes then						begin							StoreTree(treedataH, ds);							if savedefault then								begin									SaveFixdataForTree(treedataH, fixdataH);									SaveSegmentsForTree(treedataH, segdataH); {Segments:}									SaveRealLengthsForTree(treedataH, realBranchLengthsDataH);								end;						end;					treechain := oldtreechain;					CopyHandles(treedataH, linkH);					InvalidateWindow(textWindow[AboutTreesText], false);					InvalidateWindow(textWindow[AboutTreeFileText], false);				end;			otherwise				;		end;		AddCHUNKs(strCHUNKs[theChain], 1, SLB);{this is already protected against badmemory}		SetLink(theChain, EndUserLink(theChain), linkH);		if theChain = CharSetChain then			begin				EnableDisableItem(InfoSelectMHdl, RenameDeleteSetMenuItem[charinfo], UserLinks[charsetchain] > 0);				{RebuildSelectMenu(charinfo);}				RebuildShadeCharSetMenu;			end		else if theChain = TaxSetChain then			begin				EnableDisableItem(InfoSelectMHdl,  RenameDeleteSetMenuItem[taxinfo], UserLinks[taxsetchain] > 0);				{RebuildSelectMenu(taxinfo);}				RebuildConsensusTaxSetMenu;			end;		ZapHandle(linkH);		dirtylink[thechain] := savedefault;		if thechain = treefilechain then			dirtytreefile := true		else			dirtyfile := true;		AdjustAllNexusBlockWillWrites;		{SetCursorToArrow;}	end;{----------------------------------------------------------------------------}	procedure SaveDefaultLink;	begin		defaultLink[theChain] := EndUserLink(theChain) + 1; {add 1 as userlinks not updated until next call}		SaveLinkToChain(theChain, UnStoredLink, true,false);	end;{----------------------------------------------------------------------------}	function SaveNoDefault (thechain: Integer): boolean;{if no default is to be saved, then this returns true}{no UNTITLED default is saved when the link is not dirty, and when the linknumber is that of a user-stored link}	begin		SaveNoDefault := not dirtyLink[thechain] and (linknumber[thechain] >= StartUserLink(thechain));	end;{----------------------------------------------------------------------------}	procedure SaveDefaultAssumpLinks;  {xxxxx: only called in WriteData}	begin		if SaveNoDefault(wtsetchain) then   {then we don't have to create a brand new default link}			defaultLink[wtsetchain] := linknumber[wtsetchain]		else if not allwt1 then			SaveDefaultLink(wtsetchain)		else			defaultLink[wtsetchain] := -1;   {v3.05: set default link to be implicitly equal weighting}		if SaveNoDefault(typesetchain) then			defaultLink[typesetchain] := linknumber[typesetchain]		else if curtypes <> [deftype] then			SaveDefaultLink(typesetchain)		else			defaultLink[typesetchain] := -1;   {v3.05: set default link to be implicitly all deftype}		if SaveNoDefault(exsetchain) then			defaultLink[exsetchain] := linknumber[exsetchain]		else if numcharin <> numchars then			SaveDefaultLink(exsetchain)		else			defaultLink[exsetchain] := -1;   {v3.05: set default link to be implicitly all included}{$IFC CHARpartitions}		if SaveNoDefault(charPartitionchain) then   {then we don't have to create a brand new default link}			defaultLink[charPartitionchain] := linknumber[charPartitionchain]		else if not onePartition then			SaveDefaultLink(charPartitionchain)		else			defaultLink[charPartitionchain] := -1;   {v3.05: set default link to be implicitly equal weighting}{$ENDC}	end;{----------------------------------------------------------------------------}	procedure ExciseDefaultLink;		var			dhp: HdlPtr;	begin		if DefaultLink[theChain] > 0 then			begin				if (MakeCaps(LinkNameFromChain(theChain, DefaultLink[theChain])) = UnStoredLink) then					begin						DeleteCHUNKs(strCHUNKs[theChain], DefaultLink[theChain] + 1, 1);						UserLinks[theChain] := UserLinks[theChain] - 1;						if theChain in [treefilechain, datafilechain] then							DefaultLink[theChain] := -1						else							DefaultLink[theChain] := 0;					end				else if theChain in [treefilechain, datafilechain] then					begin{don't need to lock}						dhp := HdlPtr(GetMaster(strCHUNKs[Thechain]) + HdlSize * ord4(DefaultLink[Thechain]));						BitClr(ptr(GetMaster(dhp^)), 18);					end;			end;	end;{----------------------------------------------------------------------------}	procedure ExciseDefaultAssumpLinks;	begin		if not SaveNoDefault(wtsetchain) then  {a default was saved}			ExciseDefaultLink(wtsetchain);		if not SaveNoDefault(typesetchain) then			ExciseDefaultLink(typesetchain);		if not SaveNoDefault(exsetchain) then			ExciseDefaultLink(exsetchain);		if not SaveNoDefault(CharPartitionChain) then			ExciseDefaultLink(CharPartitionChain);	end;{-----------------------------------------------------------------------------}	function SaveLinkDLOG (theCHAIN: Integer): boolean;		var			theDialog: DialogPtr;			tempP: WindowPtr;			namestr: str255;			localItemHit: integer;			OldState1, oldstate2: signedByte;	begin		StartDLOG(259, theDialog, tempP);		LockHandle(treefilename, oldstate1);		LockHandle(ChainNames[theChain], oldstate2);		if (thechain = treefilechain) then			ParamText(ChainNames[theChain]^^, concat(' in tree file ', treefilename^^), '', '')		else if (thechain = datafilechain) then			ParamText(ChainNames[theChain]^^, ' in data file', '', '')		else if thechain = charsetchain then			ParamText('selection of characters', '', '', '')		else			ParamText(ChainNames[theChain]^^, '', '', '');		ResetHandle(treefilename, oldstate1);		ResetHandle(ChainNames[theChain], oldstate2);		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);		until localItemHit in [1, 2];		if localItemHit = 1 then			begin				namestr := GetEditText(theDialog, 4);				if (theChain = charsetchain) then					FixTaxCharName(namestr, true, 0);			end;		EndDLOG(theDialog, tempP);		if localItemHit = 1 then			begin				SaveLinkToChain(theChain, namestr, false,false);				if theChain = treechain then					begin						dirtytree := false;						dirtyfix := false;						ChangeStoredTreesGoList;					end;				linknumber[theChain] := EndUserLink(theChain);			end;		SaveLinkDLOG := localitemhit = 1;	end;{-----------------------------------------------------------------------------}	procedure LoadLinkUtil;	begin	end;end.