unit TypeDLOGFilter;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, SymbolsNames, TypeUtil, CharUtil, MenuUtil, CHUNK, TypeDLOGUtil, TypeDLOGdraw, TypeNewDLOG, CharStateTree;	procedure doTypeScroll (whichControl: ControlRef; theCode: INTEGER);	procedure ResetCurType (theDialog: DialogPtr);	procedure TidyDelete (theDialog: DialogPtr; deletecell: point);	procedure EnterStepValues (var ds: str255);	function TypesFilter (theDialog: DialogPtr; var Event: EventRecord; var localItemHit: INTEGER): BOOLEAN;{еееееееееееееееееееееее}implementation {е$S TypeDLOGFilter}{-----------------------------------------------------------------------------}	procedure ResetCurType (theDialog: DialogPtr);	begin		genericSetPort(myGetWindowPtrForDialog(theDialog));		if showmatrix then			CurType := unordered		else			CurType := ordered;		CurTypeHdl := gettypeHdl(CurType);		curtypeCell.v := ListCellofType(curType);		maxMat := maxstbit;		CheckMaxMat;		if not showmatrix then			GetCSTree;		ButHilite(theDialog);		TypeNames(theDialog, 8);		DrawMatScrolls;		ReDrawTypeSpecs(theDialog, 7);	end;{-----------------------------------------------------------------------------}	procedure TidyDelete (theDialog: DialogPtr; deletecell: point);	begin		ResetCurType(theDialog);		LDelRow(1, deletecell.v, typList);	end;{-----------------------------------------------------------------------------}	procedure EnterStepValues (var ds: str255);		var			isfrom, isto, newvalue: integer;			frontds: str255;{...........}		procedure SetNewValues (newvalue: integer);			var				isfrom, isto: integer;		begin			if (CurType = fisher) & (newvalue = 0) then				InstantError(388)			else				begin					for isfrom := 0 to maxmat do						for isto := 0 to maxmat do							if StepCells^[isfrom, isto] then								begin									CurTypeHdl^^.dist[isfrom, isto] := newvalue;									InvalidateWindowRect(myGetWindowPtrForDialog(editTypeDialog),FindStepCellRect(isfrom, isto),false);									curtypeHdl^^.setdefined := curtypeHdl^^.setdefined + [isfrom, isto];								end;					if CurType = fisher then						CurTypeHdl^^.dist[0, 0] := -2;					specchanged := true;				end;		end;{...........}	begin		if length(ds) <> 0 then			begin				StripBlanks(ds);				if ds[length(ds)] = '.' then					delete(ds, length(ds), 1);				if pos('.', ds) > 0 then					begin						if not CurTypeHdl^^.isreal then							begin								InstantError(198);								Exit(EnterStepValues);							end						else							begin								frontds := CopyString(ds, 1, pos('.', ds) - 1);								if length(frontds) = 0 then									newvalue := ord(ds[pos('.', ds) + 1]) - 48								else									newvalue := TokenToInteger(frontds, true) * TypeInflate + ord(ds[pos('.', ds) + 1]) - 48;								if newvalue > MaxTypeReal then									begin										InstantError(199);										Exit(EnterStepValues);									end;								SetNewValues(newvalue);							end;					end				else					begin						if (ds = 'i') or (ds = 'I') or (ds = '░') then							newvalue := infinity						else							begin								newvalue := TokenToInteger(ds, true);								if CurTypeHdl^^.isreal then									begin										newvalue := newvalue * TypeInflate;										if newvalue > MaxTypeReal then											begin												InstantError(199);												Exit(EnterStepValues);											end;									end								else if newvalue > MaxTypeInt then									begin										InstantError(199);										Exit(EnterStepValues);									end;							end;						SetNewValues(newValue);					end;				TypeEdited(curTypeHdl);			end;	end;{----------------------------------------------------------------------------}	procedure ScrollTypes;		var			oldv, oldh: integer;			oldfont, oldsize: integer;	begin		oldv := vTypeStart;		oldh := hTypeStart;		vTypeStart := GetControlValueLong(vTypeScroll);		hTypeStart := GetControlValueLong(hTypeScroll);		if (oldv <> vTypeStart) or (oldh <> hTypeStart) then			begin				CalcSpecRect(CurType, specleft, spectop, specrect);				CalcScrollTypeRect;				DrawVTypeLabels(specrect);				if curtype <> fisher then					DrawHTypeLabels(specrect);				oldfont := QDThePortTextFont;				oldsize := QDThePortTextSize;				SetStepMatrixFont;				FillTypeMatrix(CurType, SpecRect, true);				textfont(oldfont);				textsize(oldsize);			end;	end;{----------------------------------------------------------------------------}	procedure SetTypeScrollValue (whichControl: ControlRef; amount: integer);	begin		if curtype = fisher then			begin				SetControlValueLong(vTypeScroll, GetControlValueLong(vTypeScroll) + amount);				SetControlValueLong(hTypeScroll, GetControlValueLong(hTypeScroll) + amount);			end		else			SetControlValueLong(whichControl, GetControlValueLong(whichControl) + amount);	end;{----------------------------------------------------------------------------}	procedure doTypeScroll (whichControl: ControlRef; theCode: INTEGER);	begin		if scrollup then			begin				if theCode = kControlUpButtonPart then					begin						SetTypeScrollValue(whichControl, -1);						ScrollTypes;					end			end		else if theCode = kControlDownButtonPart then			begin				SetTypeScrollValue(whichControl, +1);				ScrollTypes;			end;{Delay(4, ticks);}	end;{----------------------------------------------------------------------------}	procedure InTypeScroll (Event: EventRecord);		var			t: integer;			wh: point;			code: integer;			whichControl: ControlRef;	begin		code := FindControl(Event.where, whichWindow, whichControl);		if whichControl<> nil then			case code of				kControlUpButtonPart: 					begin						scrollup := true;						t := myTrackControl(whichControl, Event.where, ScrollTypeUpDownUPP);  					end;				kControlDownButtonPart: 					begin						scrollup := false;						t := myTrackControl(whichControl, Event.where, ScrollTypeUpDownUPP);					end;				kControlPageUpPart: 					repeat						GetMouse(wh);						if TestControl(whichControl, wh) = code then							begin								SetTypeScrollValue(whichControl, -5);								ScrollTypes;							end					until not StillDown;				kControlPageDownPart: 					repeat						GetMouse(wh);						if TestControl(whichControl, wh) = code then							begin								SetTypeScrollValue(whichControl, +5);								ScrollTypes;							end					until not StillDown;				kControlIndicatorPart: 					begin						t := myTrackControl(whichControl, Event.where, nil);						if curtype = fisher then							if whichControl = vtypescroll then								SetControlValueLong(htypescroll, GetControlValueLong(whichControl))							else								SetControlValueLong(vtypescroll, GetControlValueLong(whichControl));						ScrollTypes;					end;				otherwise					;			end;	end;{----------------------------------------------------------------------------}	procedure InTypeList (theDialog: DialogPtr; Event: EventRecord);		var			goahead: boolean;			j, listpos, isfrom, isto: integer;			deletecell, thecell, newcell: point;			db: boolean;	begin		goahead := true;		deletecell.v := -1;		if PtInRect(Event.where, namerect) then			begin				if not TypeValid(deletecell) then					goahead := false				else if deletecell.v <> -1 then					TidyDelete(theDialog, deletecell);			end;		if goahead then			begin				db := LClick(Event.where, event.modifiers, typList);				if PtinRect(Event.where, namerect) then					begin						newcell := ListCellSelected(typList, false);						if (newcell.v < 0) or (newcell.v > numitems - 1) then   {clicked outside of bounds}							LSetSelect(true, curTypeCell, typList)   {set it back to old value}						else							begin								oldCurType := CurType;								curtypecell := newcell;								CurType := TypeNumFromList(curTypeCell);								if (oldCurType <> CurType) and specchanged and (oldCurType >= usedef) then									CurTypeHdl^^.setdefined := [0..CurTypeHdl^^.max];  {if oldtype was edited at all, then reset setdefined}									{v4: keep track of editorOpen, and only add to setdefined those rows and columns that were edited}								CurTypeHdl := gettypeHdl(CurType);								if not showmatrix and (CurType <> dollo) then									GetCSTree;								if (oldCurType <> CurType) and showmatrix then									begin										for isfrom := 0 to maxstbit do											for isto := 0 to maxstbit do												StepCells^[isfrom, isto] := false;										FillEnterEdit(theDialog, -3);										ZeroStepMatrixPos;									end;								ShowC(theDialog);							end;					end;			end;	end;{----------------------------------------------------------------------------}	procedure ScrollToStepCell;		var			newV, newH: integer;	begin		newH := HTypeStart;		newV := VTypeStart;{$IFC FALSE}{here get the first stepcell visible}		if (StepCell.v < vTypeStart) then			newV := StepCell.v		else if (StepCell.v > vTypeStart + maxdrawmat) then			newV := StepCell.v - maxdrawmat;		if (StepCell.h < hTypeStart) then			newH := StepCell.h		else if (StepCell.h > hTypeStart + maxdrawmat) then			newH := StepCell.h - maxdrawmat;{$ENDC}		SetControlValueLong(vTypeScroll, newV);		SetControlValueLong(hTypeScroll, newH);		ScrollTypes;	end;{----------------------------------------------------------------------------}	function HStepCell (horpos: integer): integer;	begin		HStepCell := (horpos - SpecRect.left) div StepCellWidth + hTypeStart;	end;{----------------------------------------------------------------------------}	function VStepCell (vertpos: integer): integer;	begin		VStepCell := (vertpos - SpecRect.top) div StepCellHeight + VTypeStart;	end;{----------------------------------------------------------------------------}	function TypesFilter; {(theDialog : DialogPtr; var Event : EventRecord; var localItemHit : INTEGER) : BOOLEAN;}		var			MouseLoc: Point;			WindoLoc, t, j, charcode, itemtype, isfrom, isto: integer;			box, specrectbox, vrect, hrect: rect;			tempH: handle;			oldRgn: RgnHandle;			row, col, fromsel, tosel: integer;			theChar: char;			avg: integer;			deletecell: point;			ds: str255;			diddelete: boolean;	begin		specrectbox := specrect;		specrectbox.right := specrectbox.right - 1;		specrectbox.left := specrectbox.left - 1;		MouseLoc := Event.Where;		GlobalToLocal(Event.where);		if not showmatrix then			if PtInRect(Event.where, AvailR) then				begin					if (mode = movemode) or (ShiftEvent(Event) and not CommandEvent(Event)) then						SetCursH(handcurs)					else if mode = join then						SetCursor(linkcurs)					else if mode = rerootmode then						SetCursH(tool^[treeTools,rerootT].curs)				end			else if PtInREct(Event.where, PaletteR) then				SetCursH(handcurs)			else				SetCursorToArrow;		WindoLoc := FindWindow(MouseLoc, Whichwindow);		TypesFilter := FALSE;		if (Event.what = keyDown) then			begin				if ((event.message mod 256) = 13) then   {only return key, not enter}					begin						if TypeValid(deletecell) then							begin								if deletecell.v <> -1 then									TidyDelete(theDialog, deletecell);								localItemHit := PressButton(theDialog, 1);							end						else							localItemHit := NotinDialog;						TypesFilter := TRUE;					end				else if ((event.message mod 256) = 3) & (curType <> Dollo) then					begin						ds := GetEditText(theDialog, 15);						if ds <> '' then							EnterStepValues(ds);						localItemHit := NotinDialog;						TypesFilter := TRUE;					end;{    else if StepCellSel then KeyInStepMatrixCell(theChar)}{    else Beep}			end;		if (Event.what = mouseDown) then			begin				if PtInRect(Event.where, fulltyprect) then			{in list of types}					begin						TypesFilter := TRUE;						localItemHit := NotinDialog;						InTypeList(theDialog, Event);					end{========= show matrix =======}				else if showmatrix then					begin{--- scroll bars ---}						hrect := myGetControlRect(hTypeScroll);						vrect := myGetControlRect(vTypeScroll);						if (maxmat > maxTypeEditMat) and (PtinRect(Event.where, hrect) or PtinRect(Event.where, vrect)) then							begin			{in scroll bars}								InTypeScroll(Event);								localItemHit := NotinDialog;								TypesFilter := TRUE;							end{--- in Step Matrix itself ---}						else if PtInRect(Event.where, SpecRectbox) and (CurType <> dollo) then							begin								fromsel := VStepCell(Event.where.v);								tosel := HStepCell(Event.where.h);								if ((CurType < usedef) and not (CurType = fisher)) or (CurTypeHdl^^.root >= 0) then									begin										if curtype < usedef then   {can't edit as predefined type}											InstantError(366)										else if (CurTypeHdl^^.root >= 0) then  {can't edit as CST usedef type}											InstantError(364)										else											Beep;									end								else									begin										if (CurType <> fisher) or (fromsel = tosel - 1) then											begin												if not (ShiftEvent(Event) or CommandEvent(Event)) then													begin														for isfrom := 0 to maxmat do															for isto := 0 to maxmat do																begin																	if StepCells^[isfrom, isto] then																		InvertStepCellRect(isfrom, isto);																	StepCells^[isfrom, isto] := false;																end;														StepCells^[fromsel, tosel] := true;														FillEnterEdit(theDialog, CurTypeHdl^^.dist[fromsel, tosel]);													end												else													begin														StepCells^[fromsel, tosel] := not StepCells^[fromsel, tosel];{FillEnterEdit(thedialog, -3);}													end;												InvertStepCellRect(fromsel, tosel);{StepCellSel := true;}												localItemHit := NotinDialog;												TypesFilter := TRUE;												EnableDisableDLOGItem(theDialog, TDenter, true, false);											end										else											Beep;									end;							end					end{========= not show matrix (cstree) =======}				else if not showmatrix then					begin						if (PtinRect(Event.where, AvailR) or PtinRect(Event.where, PaletteR)) then							begin								if CurType >= usedef then									ScanCSTree(Event)								else									InstantError(366);								localItemHit := NotinDialog;								TypesFilter := TRUE;							end						else if ptinrect(Event.where, joinB) and not (mode = join) then							begin								if mode = movemode then									invertrect(moveB)								else									invertrect(rrootB);								mode := join;								invertrect(joinB);							end						else if ptinrect(Event.where, moveB) and not (mode = movemode) then							begin								if mode = join then									invertrect(joinB)								else									invertrect(rrootB);								mode := movemode;								invertrect(moveB);							end						else if ptinrect(Event.where, rrootB) and not (mode = rerootmode) then							begin								if mode = movemode then									invertrect(moveB)								else									invertrect(joinB);								mode := rerootmode;								invertrect(rrootB);							end					end;			end;		if (Event.what = mouseup) then			oldtime := Event.when;		LocaltoGlobal(Event.where);	end;end.