unit ChartWCST;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, BoxUtil, CharUtil, typeutil, ChartWUtil, ChartWWrite, Thermos, PolyCalc, Prohibitions, ChartWChangesCalc, SymbolsNames, SetStates, CHUNK, WriteUtil, ReadWriteUtil, ReadUtil, ReadTreeFile, StrUtil, MenuUtil, TreeUtil, Count, RandomTree, TreeCycle, TaxonCHUtil, TraceAllChangesCalc, equivocal;	procedure AllCST;{еееееееееееееееееееееее}implementation {е$S ChartWCST}{$IFC DRMCST}{-----------------------------------------------------------------------------}	procedure AllCST;		label			1;		type			stateintarray = array[0..absmaxstate] of integer;		var			numst, maxst, minst: integer;			sia, currentSIA: stateintarray;			thecycle, j, b1, oldtype, maxstar: integer;			lowest, legalset, chsts: LargestSetChars;			tH: TypeHandle;			foundit: boolean;			thP: TypeHdlPtr;			tot, currentCST: longint;			theDialog: DialogPtr;			tempP: WindowPtr;{.............}		procedure CheckLowest (startsymbol: integer);			var				j, k: integer;				foundint: boolean;		begin			for j := minst to maxst do   {now let's check to see if j is in list}				begin					foundit := false;					for k := startsymbol to numst - 2 do						if sia[k] = j then { it is in the list}							begin								foundit := true;								leave;							end;					if not foundit and (j in Lowest) then {we've found lowest one not in sia}						begin							b1 := j;							Lowest := Lowest - [b1];							leave;						end;				end;		end;{...........}		procedure SIAtoCST;{converts StateIntegerArray into Character State Tree}			var				j, k: integer;				Neighbors: neighbortype;				mxs: integer;				tempdist: distancetype;				legalset: largestsetchars;				clen: longint;		begin			Lowest := [minst..maxst];			for j := 0 to maxst do				neighbors[j] := [];			for j := 0 to numst - 2 do				begin					CheckLowest(j);  {get value of b1, lowest state set not in sia and not used up}					neighbors[SIA[j]] := neighbors[SIA[j]] + [b1];					neighbors[b1] := neighbors[b1] + [SIA[j]];				end;{now see which ones are left in Lowest, and join those up}			for j := minst to maxst do				if j in Lowest then					for k := minst to maxst do						if (k in Lowest) and (j <> k) then							begin								neighbors[j] := neighbors[j] + [k];								neighbors[k] := neighbors[k] + [j];							end;{now convert neighbors matrix to CST}			TH^^.nbors := Neighbors;			NborToDistance(neighbors, maxstar, tempdist, mxs, legalset);			TH^^.dist := tempdist;			CountChar(i);			clen := CharSteps(i, false, false);			AddToChartLinear(CLkind, clen, minChartLinearCat, maxChartLinearCat);			if ErrorFlag or pleaseNoMoreChart then				Exit(SIAtoCST);			if ChartCalcToText then				begin					for j := 0 to numst - 2 do						putSingleLongint(sia[j]);  {v4: use ChartWrite functions}					putSimpleLongint(clen);					putReturn;				end;			currentCST := currentCST + 1;			UpdateThermo(theDialog, 0, currentCST, tot,false);			if abortedThermo then				goto 1;   {v4: check?}		end;{...........}		procedure CSTcycle (var numcycle: integer);			var				is: integer;		begin			if numcycle <= (numst - 2) then				begin					numcycle := numcycle + 1;					for is := minst to maxst do						begin							sia[numcycle - 1] := is;							if numcycle = numst - 1 then								SIAtoCST;							CSTCycle(numcycle);						end;					numcycle := numcycle - 1;				end;		end;{..........}	begin		currentCST := 0;		chsts := CharStatesLargest(i);		maxst := maxLg(chsts);  {v4: this allow unobserved states for user-defined characters}		minst := minLg(chsts);		chsts := [minst..maxst];		numst := maxst - minst;		Lowest := [minst..maxst];		legalset := [minst..maxst];		AddCHUNKs(typeCHUNKs, 1, Sizeof(typeRecord));		if badmemory then			Exit(AllCST);		numtypes := numtypes + 1;		thp := typeHdlPtr(GetMaster(typeCHUNKs) + GetHandleSize(typeCHUNKs) - HdlSize);		tH := thp^;		TH^^.root := minst;		TH^^.maxstar := maxstate;		tH^^.setdefined := [minst..maxst];		TH^^.max := maxst;		maxstar := maxst;		oldtype := TypeOfChar(i);		SetType(i, numtypes);		UseToTypeStorage(i);		tot := numst + 1;		for j := 1 to numst - 2 do			tot := tot * (numst + 1);		for j := 0 to absmaxstate do			sia[j] := 0;		thecycle := 0;		DisableWindowUpdates(chartwindow);		DisableWindowUpdates(treewindow);		DisableWindowUpdates(tlegwindow);		DisableWindowUpdates(chlegwindow);		StartThermo(theDialog, tempP, 0, tot, 'Processing CST', 'CST', false);		CSTCycle(thecycle);1:		EndThermo(theDialog, tempP, true);		DeleteCHUNKS(typeCHUNKS, numtypes, 1);		numtypes := numtypes - 1;		SetType(i, oldtype);		UseToTypeStorage(i);		CountChar(i);	end;{$ENDC}end.