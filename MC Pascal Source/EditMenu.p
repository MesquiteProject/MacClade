unit EditMenu;{ееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, 		TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, 		EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, Settings, InfoWindows, GeneticCode, StatesWindow, 		SymbolsNames, ReadWriteUtil, ReadUtil, TypeUtil, TypeDLOGUtil, WriteUtil, 		UndoTree, Continuous, CharUtil, MenuUtil, Footnote, SpreadUtil, PICT, GeneticCode, ScrollSpread, 		RowColumn, CopyPaste, TraceMenu, EditControl, Windows, ChartWindow, ReadDataBlock, EditorUndo,		TextTree,LaserTree;	procedure DoNexusBlocksMenu (ItemNo: Integer);	procedure DoCopySpecialMenu(ItemNo: Integer);	procedure DoNonInfoSelectMenu (ItemNo: Integer);	procedure DoEditMenu (ItemNo: Integer);{ееееееееееееееееееееее}implementation {е$S EditMenu}{$IFC LOCKCONTROL}{-----------------------------------------------------------------------------}	procedure DoLockControls;	label 1;		var			theDialog: DialogPtr;			tempP: WindowPtr;			j, ir: integer;			localItemHit: integer;			oldTreesLocked: boolean;			oldDataEditorLocked: boolean;			oldAssumptionsLocked: boolean;			oldSavingLocked: boolean;			oldNexusBlocksLocked: boolean;			oldapplyLockOnlyToRestrictedVersion: boolean; {........}		procedure CheckLocks;		begin			ItemCheckMark(theDialog, 3, treesLocked);			ItemCheckMark(theDialog, 4, dataLocked);			ItemCheckMark(theDialog, 5, assumptionsLocked);			ItemCheckMark(theDialog, 6, savingLocked);			ItemCheckMark(theDialog, 9, nexusBlocksLocked);			ItemCheckMark(theDialog, 8, not applyLockOnlyToRestrictedVersion);		end; {........}	begin		oldTreesLocked := treesLocked;		oldDataEditorLocked := dataLocked;		oldAssumptionsLocked := assumptionsLocked;		oldNexusBlocksLocked := nexusBlocksLocked;		oldSavingLocked := savingLocked;		oldapplyLockOnlyToRestrictedVersion := applyLockOnlyToRestrictedVersion;		StartDLOG(169, theDialog, tempP);		CheckLocks;		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			case localitemhit of				3: 	treesLocked := not treesLocked;				4: 	dataLocked := not dataLocked;				5: 	assumptionsLocked := not assumptionsLocked;				6: 	savingLocked := not savingLocked;				9:  	nexusBlocksLocked := not nexusBlocksLocked;				8: 	applyLockOnlyToRestrictedVersion := not applyLockOnlyToRestrictedVersion;				otherwise;			end;			CheckLocks;		until localItemHit in [1, 2];		EndDLOG(theDialog, tempP);		if localitemHit = 1 then			begin				if editorOpen & ((applyLockOnlyToRestrictedVersion<>oldapplyLockOnlyToRestrictedVersion)|(dataLocked<>oldDataEditorLocked))  then					begin						if  dataLocked & not applyLockOnlyToRestrictedVersion then							begin								if editorSelected then									begin										UnSelectAll;										if badcellentry then											begin 											end;										InvalidateWindow(editorWindow,true);									end								else									begin										 DeselectAllConsenses;										 InvalidateWindow(editorWindow,true);									end;								if statesWindowOpen then									begin										TurnOffStatesEditing;										TurnOffSymbolsEditing;									end;							end;									CheckToolValidity(editorTools);						if toolPaletteOpen[editorTools] then							begin								SetTool(editorTools,editorArrowT);								DrawPalette(editorTools);							end;						FixEditMenu;						DrawDataEditorLock;					end;				if treeOpen & ((applyLockOnlyToRestrictedVersion<>oldapplyLockOnlyToRestrictedVersion)|(TreesLocked<>oldtreesLocked))  then					begin					end;				if ((applyLockOnlyToRestrictedVersion<>oldapplyLockOnlyToRestrictedVersion)|(AssumptionsLocked<>oldassumptionsLocked)) then					begin					end;				if ((applyLockOnlyToRestrictedVersion<>oldapplyLockOnlyToRestrictedVersion)|(SavingLocked<>oldSavingLocked)) then					begin					end;				if (nexusBlocksLocked<>oldnexusBlocksLocked) & textWindowInfo[NexusBlockText]^.open then					begin						TESetSelect(0,0, textWindowInfo[NexusBlockText]^.TE);						InvalidateWindow(textWindow[NexusBlockText], true);					end;				for j := 1 to numinfowindows do					begin						if InfoNameLocked(j,1) & infoEditing[j] then  {can't edit name but it is being edited}							TurnOffInfoEditing(j);						for ir := 1 to MaximumInfoRows(j) do							if not InfoRowSelectable(j,ir) then								SelectInfoRow (j,ir,false);						infoSomeSelected[j] := AnyInfoRowSelected(j);						InvalidateWindow(infowindow[j],false);					end;				dirtyfile := true;			end		else1:			begin				TreesLocked := oldtreesLocked;				dataLocked := olddataEditorLocked;				AssumptionsLocked := oldassumptionsLocked;				NexusBlocksLocked := oldNexusBlocksLocked;				SavingLocked := oldsavingLocked;				applyLockOnlyToRestrictedVersion := oldapplyLockOnlyToRestrictedVersion;			end;	end;{$ENDC}{-----------------------------------------------------------------------------}	procedure ReplicateSelected (multiply: integer; copyinfo, copynames: boolean);		var			theChar: integer;			CharHdl: chHdl;			ds: str255;			thename: str255;			j, it, ic, st, et, sc, ec: integer;			ischaracter: boolean;			fromH, toH: Handle;			oldState: SignedByte;	begin		if (multiply > 0) & not Locked(lockData) then			begin				SetCursor(clockCursor);{note, can't have both rows and column selected}				CalcSelectedTaxaCharacters(st, et, sc, ec, true);								ischaracter := WholeCharSel;				if not ischaracter then					begin						if multiply * (et - st + 1) + numtaxa <= mntaxa then							begin								InsertNewTaxa(multiply * (et - st + 1), et + 1,molecular);								SetLastChangeInEditor(lastChangeAddTaxa);								if not badmemory then									for it := st to et do										for j := 1 to multiply do											begin												thename := CopyString(TaxonName(it), 1, 25);												NumToString(j + 1, ds);												thename := Concat(thename, '.', ds);												SetTaxonName(et + multiply * (it - st) + j, thename);												for ic := 1 to numchars do													settaxonstslargest(et + multiply * (it - st) + j, ic, gettaxonstsLargestCase(it, ic));											end;							end						else							NewError(398, 0);					end				else					begin						if multiply * (ec - sc + 1) + numchars <= mnchars then							begin								SetLastChangeInEditor(lastChangeAddCharacters);								InsertNewCharacters(multiply * (ec - sc + 1), ec + 1, false);								if not badmemory then									for ic := sc to ec do										for j := 1 to multiply do											begin												thename := CopyString(CharName(ic), 1, 25);												NumToString(j + 1, ds);												thename := Concat(thename, '.', ds);												theChar := ec + multiply * (ic - sc) + j;												SetCharName(theChar, thename);												for it := 1 to numtaxa do													settaxonstslargest(it, theChar, gettaxonstsLargestCase(it, ic));												if copyinfo then													begin														SetWeight(theChar, CharWeight(ic));														UsetoWtStorage(theChar);														SetType(theChar, TrueTypeOfChar(ic));														UseToTypeStorage(theChar);														if not CharIncluded(ic) then															begin																charHdl := getCHHdl(theChar);																charHdl^^.deleted := true;																SetWeight(theChar, 0);																SetType(theChar, Excluded);															end;													end;												if copynames then													begin														LockHandle(statenamesCHUNKs, oldState);														fromH := HdlPtr(GetMaster(statenamesCHUNKs) + HdlSize * longint(ic - 1))^;														toH := HdlPtr(GetMaster(statenamesCHUNKs) + HdlSize * longint(theChar - 1))^;														CopyHandles(fromH, toH);														ResetHandle(statenamesCHUNKs, oldState);													end;											end;							end						else							NewError(398, 0);					end;				genericSetPort(editorWindow);				ClipRect(WindowPortRect(editorWindow));				EraseRect(WindowPortRect(editorWindow));				InvalidateWindowRect(editorWindow,WindowPortRect(editorWindow),false);				CalcEditorMatrixRect;				ReCalcMaxstAndStates(1,numchars);   {v4: don't really need to do all characters, just ones changed}			end		else			Beep;	end;{-----------------------------------------------------------------------------}	procedure ReplicateUser (theDialog: DialogPtr; itemNo: Integer);	begin		if not WholeCharSel then			begin				DimBox(GetDLOGItemBox(theDialog, 7));				DimBox(GetDLOGItemBox(theDialog, 9));			end;	end;{-----------------------------------------------------------------------------}	procedure MultiplicateRC;		var			theDialog: DialogPtr;			tempP: windowptr;			multiply: integer;			copyInfo, copynames, ischaracter: boolean;			box: rect;			H: Handle;			localItemHit: integer;UserItemUProcP: UniversalProcPtr;	begin		badmemory := false;		StartDLOG(361, theDialog, tempP);		setrect(box, 0, 0, 0, 0);UserItemUProcP := MyNewUserItemUPP(@ReplicateUser);  H := Handle(UserItemUProcP);		SetDialogItem(theDialog, 10, UserItem, H, box);		ischaracter := WholeCharSel;		if not ischaracter then			ParamText('taxa', '', '', '')		else			ParamText('characters', '', '', '');		copyInfo := ischaracter;		copynames := ischaracter;		myShowDialog(theDialog);		SetDLOGText(theDialog, 3, '1', true);		FrameButton(theDialog, 1);		EnableDisableDLOGItem(theDialog, 6, ischaracter, false);		ItemCheckMark(theDialog, 6, copyinfo);		EnableDisableDLOGItem(theDialog, 8, ischaracter, false);		ItemCheckMark(theDialog, 8, copynames);		repeat			ModalDialog(nil, localItemHit);			if (localItemHit = 6) or ((localItemHit = 7) and ischaracter) then				begin					copyinfo := not copyinfo;					ItemCheckMark(theDialog, 6, copyinfo);				end			else if (localItemHit = 8) or ((localItemHit = 9) and ischaracter) then				begin					copynames := not copynames;					ItemCheckMark(theDialog, 8, copynames);				end;		until (localItemHit in [1, 2]);		if localItemHit = 1 then			begin				multiply := EditTextInt(theDialog, 3,true);				MyDisposeUserItemUPP(UserItemUProcP);				DisposeDialog(theDialog);				ReplicateSelected(multiply, copyinfo, copynames);			end		else			begin				MyDisposeUserItemUPP(UserItemUProcP);				DisposeDialog(theDialog);			end;		genericSetPort(tempP);	end;{-----------------------------------------------------------------------------}	procedure AppendHandleToNexusBlock(H: univ Handle; blockName: str255; isString: boolean);	var 	db: boolean;		paupBlockNumber: integer;		paupBlock : NexusBlockPtr;		ds: str255;		oldSize: longint;		oldBack: RGBColor;	begin		if not NamedObjectExists(nexusblockinfo,blockName) then			MakeNewObject(nexusBlockinfo,blockName,false, false,false);		paupBlockNumber:= NamedObjectNumber(nexusblockinfo,blockName);		paupBlock := NexusBlock(paupBlockNumber);		if textWindowInfo[NexusBlockText]^.open & (nexusBlockBeingEdited=paupBlock) then			begin				oldSize := GetHandleSize(textWindowInfo[NexusBlockText]^.TE^^.hText);				HLock(Handle(textWindowInfo[NexusBlockText]^.TE));				if isString then					begin						ds := StringHandle(H)^^;						AppendToHandle(textWindowInfo[NexusBlockText]^.TE^^.hText,chr(9));						AppendToHandle(textWindowInfo[NexusBlockText]^.TE^^.hText,ds);						AppendToHandle(textWindowInfo[NexusBlockText]^.TE^^.hText,chr(13));					end				else					db := OSSuccessful(HandAndHand(H, textWindowInfo[NexusBlockText]^.TE^^.hText));  {need to copy to end of TE, not H}				HUnLock(Handle(textWindowInfo[NexusBlockText]^.TE));				TECalText(textWindowInfo[NexusBlockText]^.TE);				TEUpDate(textWindowInfo[NexusBlockText]^.TE^^.viewRect, textWindowInfo[NexusBlockText]^.TE);				TESetSelect(oldSize,32760, textWindowInfo[NexusBlockText]^.TE);				if frontwindow<> textWindow[NexusBlockText] then					SelectWindow(textWindow[NexusBlockText]);			end		else			begin				oldSize := GetHandleSize(paupBlock^.H);				if isString then					begin						ds := StringHandle(H)^^;						AppendToHandle(paupBlock^.H,chr(9));						AppendToHandle(paupBlock^.H,ds);						AppendToHandle(paupBlock^.H,chr(13));					end				else					db := OSSuccessful(HandAndHand(H, paupBlock^.H));				OpenEditNexusBlockNumber(NamedObjectNumber(nexusblockinfo,'paup'));				TESetSelect(oldSize,32760, textWindowInfo[NexusBlockText]^.TE);			end;	end;{-----------------------------------------------------------------------------}	procedure HandleToClipboard(clipH: Handle; isString: boolean);	var tempTE: TEHandle;		box:rect;		oldstate:SignedByte;	begin		SetRect(box, 0, 0, 10, 10);		tempTE := TENew(box, box);		LockHandle(clipH,oldstate);		if isString then 			TESetText(Pointer(GetMaster(clipH)+1), GetHandleSize(clipH)-1, tempTE)		else			TESetText(clipH^, GetHandleSize(clipH), tempTE);		TESetSelect(0, 32700, tempTE);		TECopy(tempTE);		TEDispose(tempTE);		UnLockHandle(clipH,oldstate);		scrapispict := false;		scraptextdirty := true;	end;{-----------------------------------------------------------------------------}	procedure PlacePAUPCommandHandle(clipH: univ Handle; doClip, isString: boolean);	var tempTE: TEHandle;	box:rect;	begin		if doClip then			HandleToClipboard(clipH, isString)		else			begin				AppendHandleToNexusBlock(clipH,'paup', isString);			end;	end;		{-----------------------------------------------------------------------------}	procedure OutgroupToClip(doCopy: boolean);	var clipH: Handle;		it: integer;		ds: str255;	begin		clipH := NewHandle(0);		if infoSomeSelected[taxinfo] then			begin				AppendToHandle(clipH,chr(9));				AppendToHandle(clipH, 'outgroup ');				for it := 1 to MaximumInfoRows(taxinfo) do					if infoRowSelected(taxinfo,it) then						begin							ds := TaxonName(it);							PrepareToken(ds, tnw);														AppendToHandle(clipH,ds);							AppendToHandle(clipH, ' ');						end;				AppendToHandle(clipH, ';');				AppendToHandle(clipH,chr(13));			end;		PlacePAUPCommandHandle(clipH,doCopy,false);		ZapHandle(clipH);	end;{-----------------------------------------------------------------------------}	procedure WriteTreeToHandle(clipH: Handle; N: Nptr);	var ds: str255;	begin		if NodeisTerminal(N) then			begin				ds := TaxonName(N^.name);				PrepareToken(ds,tnw);				AppendToHandle(clipH,ds);			end		else				begin				if not N^.null then					AppendToHandle(clipH,'(');				WriteTreeToHandle(clipH,N^.lf);				AppendToHandle(clipH,', ');				WriteTreeToHandle(clipH,N^.rt);				if not N^.null then					AppendToHandle(clipH,')');			end;	end;{-----------------------------------------------------------------------------}	function GetConstraintTreeName(var theString: str255; var backbone: boolean; doCopy: boolean): boolean;		var			theDialog: DialogPtr;			tempP: WindowPtr;			localItemHit: integer;	begin		backbone := numtaxa<>numtaxain;		GetConstraintTreeName := false;		StartDLOG(152, theDialog, tempP);		if doCopy then			begin				SetDLOGText(theDialog, 6, 'Copy Constraint Tree to Clipboard',false);				SetButtonTitle(theDialog, 1, 'Copy');			end		else			begin				SetDLOGText(theDialog, 6, 'Place Constraint Tree in PAUP Block',false);				SetButtonTitle(theDialog, 1, 'Place');			end;		ItemCheckMark(theDialog,5,backbone);		EnableDisableDLOGItem(theDialog,5,numtaxa<>numtaxain,false);		SetDLOGText(theDialog, 3, 'untitled', true);		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			if localItemHit = 5 then				begin					backbone := not backbone;					ItemCheckMark(theDialog,5,backbone);				end;		until localItemHit in [1, 2];		if localItemHit = 1 then			begin 				theString := GetEditText(theDialog, 3);				GetConstraintTreeName:= true;			end;		EndDLOG(theDialog, tempP);	end;{-----------------------------------------------------------------------------}	procedure CurrentTreeToPAUPConstraint(doCopy: boolean);	var clipH: Handle;		it: integer;		ds: str255;		backbone: boolean;	begin		if GetConstraintTreeName(ds,backbone,doCopy) then			begin				clipH := NewHandle(0);				AppendToHandle(clipH,chr(9));				AppendToHandle(clipH, 'constraint  ');				PrepareToken(ds, maxtok);											AppendToHandle(clipH, ds);				if backbone then AppendToHandle(clipH,' (backbone)');				AppendToHandle(clipH, ' =  ');				WriteTreeToHandle(clipH, R);				AppendToHandle(clipH, ';');				AppendToHandle(clipH,chr(13));				PlacePAUPCommandHandle(clipH,doCopy,false);								ZapHandle(clipH);			end;	end;{-----------------------------------------------------------------------------}	{procedure CopyStringToClipBoard(ds:str255);	var tempTE: TEHandle;	box:rect;	begin		SetRect(box, 0, 0, 10, 10);		tempTE := TENew(box, box);		TESetText(Ptr(ord4(@ds)+1),length(ds), tempTE);		TESetSelect(0, 32700, tempTE);		TECopy(tempTE);		TEDispose(tempTE);		scrapispict := false;		scraptextdirty := true;	end;}{-----------------------------------------------------------------------------}{	procedure CopyCustomStringToClipBoard(sH: StringHandle);	var ds: str255;	begin		ds := sH^^;		CopyStringToClipBoard(ds);	end;}{-----------------------------------------------------------------------------}	procedure PaupCommandsOptions; 		var			theDialog: DialogPtr;			tempP: WindowPtr;			localItemHit: integer;			oldH1,oldH2, ds: str255;			oldpaupCommandCopyToClipBoard: boolean;	begin		StartDLOG(147, theDialog, tempP);		oldH1 := copySpecialCustomH1^^;		SetDLOGText(theDialog, 7, oldH1, false);		oldH2 := copySpecialCustomH2^^;		SetDLOGText(theDialog, 3, oldH2, false);		oldpaupCommandCopyToClipBoard := paupCommandCopyToClipBoard;		ItemCheckMark(theDialog,9,not paupCommandCopyToClipBoard);		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			if localitemhit = 6 then				begin					ds := GetEditText(theDialog, 7);					copySpecialCustomH1^^ := ds;					ds := GetEditText(theDialog, 3);					copySpecialCustomH2^^ := ds;										SetDialogValuesAsDefaults(theDialog,paupCommandsID,0,0);				end			else if localItemHit = 9 then				begin					paupCommandCopyToClipBoard := not paupCommandCopyToClipBoard;					ItemCheckMark(theDialog,9,not paupCommandCopyToClipBoard);				end;		until localItemHit in [1, 2];		if localItemHit = 1 then			begin 				ds := GetEditText(theDialog, 7);				copySpecialCustomH1^^ := ds;				ds := GetEditText(theDialog, 3);				copySpecialCustomH2^^ := ds;			end		else			begin				paupCommandCopyToClipBoard := oldpaupCommandCopyToClipBoard;				copySpecialCustomH1^^ := oldH1;				copySpecialCustomH2^^ := oldH2;			end;		EndDLOG(theDialog, tempP);	end;{-----------------------------------------------------------------------------}	procedure DoCopySpecialMenu(ItemNo: Integer);	begin			case itemNo of			CopyConstraintTreeItem:				CurrentTreeToPAUPConstraint(paupCommandCopyToClipBoard <> OptionEvent(Event));			CopyOutgroupItem:				OutgroupToClip(paupCommandCopyToClipBoard <> OptionEvent(Event));			CopyCustom1Item:				PlacePAUPCommandHandle(copySpecialCustomH1,paupCommandCopyToClipBoard <> OptionEvent(Event),true);			CopyCustom2Item:				PlacePAUPCommandHandle(copySpecialCustomH2,paupCommandCopyToClipBoard <> OptionEvent(Event), true);  			PAUPCommandsOptionsItem:				PaupCommandsOptions;			otherwise;		end;	end;{-----------------------------------------------------------------------------}	procedure EntryInterpetation;		var			theDialog: DialogPtr;			tempP: WindowPtr;			oldOrdefsep: boolean;			localItemHit: integer;			oldinterpretStateNames: boolean;			db: boolean;{......}		procedure CheckEntryInterpret;		begin			ItemCheckMark(theDialog, 3, ordefsep);			ItemCheckMark(theDialog, 4, not ordefsep);			ItemCheckMark(theDialog, 8, interpretStateNames);		end;{......}	begin		StartDLOG(555, theDialog, tempP);		oldordefsep := ordefsep;		oldinterpretStateNames := interpretStateNames;		CheckEntryInterpret;		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			if localItemHit in [3, 4] then				ordefsep := (localItemHit = 3)			else if localItemHit = 8 then				interpretStateNames := not interpretStateNames			else if localItemHit = 7 then				SetDialogValuesAsDefaults(theDialog, entryInterpretid, 0, 0);			CheckEntryInterpret;		until localItemHit in [1, 2];		EndDLOG(theDialog, tempP);		if localItemHit = 2 then			begin				ordefsep := oldordefsep;				interpretStateNames := oldinterpretStateNames;			end;		CheckStateNamesSymbolsDanger(false, db);	end;{-----------------------------------------------------------------------------}	procedure SetEWScrap;	begin		EmptyCellBlock(EWScrapBlockP);		{with EWScrapBlockP^ do			begin				ntax := 1;				nchar := 1;				if not editorTransposed then					begin						starttaxa := editorSelectionTopLeft.v;						endtaxa := editorSelectionBotRight.v;						startchars := editorSelectionTopLeft.h;						endchars := editorSelectionBotRight.h;					end				else					begin						starttaxa := editorSelectionTopLeft.h;						endtaxa := editorSelectionBotRight.h;						startchars := editorSelectionTopLeft.v;						endchars := editorSelectionBotRight.v;					end;			end;}		InvalidateTool(editorTools,stampPasteT);	end;{-----------------------------------------------------------------------------}	procedure DoNexusBlocksMenu (ItemNo: Integer);	var whichRow: longint;	begin		case ItemNo of			NexusBlockListItem:				begin					OpenOrSelectInfoWindow(nexusblockinfo);				end;			NewNexusBlockItem:				MakeNewObject(nexusblockinfo,'untitled',true, false,true);			OpenPAUPBlockItem:				begin					if not NamedObjectExists(nexusblockinfo,'paup') then						MakeNewObject(nexusBlockinfo,'paup',false, false,false);					OpenEditNexusBlockNumber(NamedObjectNumber(nexusblockinfo,'paup'));				end;			EditNexusBlockItem:				if SingleInfoRowSelected(nexusblockinfo,whichRow) then					UseSelectedObject(nexusblockinfo,whichRow);			otherwise;		end;	end;{-----------------------------------------------------------------------------}	procedure DoNonInfoSelectMenu (ItemNo: Integer);	var			oldSelCellTL, oldSElCellBR: point;			whichText, consensusNumber: integer;	begin		case ItemNo of			SelectAllItem:  				if IsEditorWindow(frontwindow) then    {Selects all cells}					begin						if not Locked(lockData)  then							begin								DeselectAllConsenses;								oldSelCellTL := editorSelectionTopLeft;								oldSelCellBR := editorSelectionBotRight;								if editorSelected & not someDataSel then									begin										if editorSelectionTopLeft.h = 0 then											begin												SetPt(editorSelectionTopLeft, 0, 1);												SetPt(editorSelectionBotRight, 0, editorTotalRows);											end										else											begin												SetPt(editorSelectionTopLeft, 1, 0);												SetPt(editorSelectionBotRight, editorTotalColumns, 0);											end;									end								else									begin										SetPt(editorSelectionTopLeft, 1, 1);										SetPt(editorSelectionBotRight, editorTotalColumns, editorTotalRows);									end;								if not EqualPt(OldSelCellTL, editorSelectionTopLeft) or not EqualPt(OldSelCellBR, editorSelectionBotRight) then									begin										CleanOldCell(OldselCellTL, OldselCellBR);										if poorentry then											Exit(DoNonInfoSelectMenu);										FixNewCell(editorSelectionTopLeft, editorSelectionBotRight);										ClipRect(WindowPortRect(editorWindow));										DrawFootText(not EqualPt(editorSelectionTopLeft, OldSelCellTL), true);									end;							end;					end				else if IsEditableTextWindow(frontwindow) then					begin						whichText := WhichTextWindow(frontwindow);						TESetSelect(0, 32767, textWindowInfo[whichText]^.TE);						SetControlValueLong(textWindowInfo[whichText]^.scroll, 0);					end				else if statesWindow=frontwindow then					SelectAllStatesWindow(true);			SelectNoneItem:				if IsEditorWindow(frontwindow) then    {Selects no cells}					if SomeConsensusSelected(consensusNumber) then						begin							SelectConsensus(consensusNumber,false);							DrawConsensusSequence(consensusNumber,selectionModeAsIs);						end					else 						UnSelectAll				else if IsEditableTextWindow(frontwindow) then					begin						whichText := WhichTextWindow(frontwindow);						TESetSelect(0, 0, textWindowInfo[whichText]^.TE);						{SetControlValueLong(textWindowInfo[whichText]^.scroll, 0);}					end				else if statesWindow=frontwindow then					SelectAllStatesWindow(false);			otherwise;		end;		FixEditMenu;	end;{-----------------------------------------------------------------------------}	procedure MoveSelectedToListWindow(select: boolean);	var st,et,sc,ec: integer;		ir: integer;	begin		if IsEditorWindow(frontwindow) then			begin				CalcSelectedTaxaCharacters(st, et, sc, ec,true);				If WholeTaxonSel then					begin						for ir := st to et do							SelectInfoCell (taxinfo, ir, select,false);						ChangeInfoSelectMenuFix(taxinfo);					end				else if WholeCharSel then					begin						for ir := sc to ec do							SelectInfoCell (charinfo, ir, select,false);						ChangeInfoSelectMenuFix(charinfo);					end;			end;	end;{-----------------------------------------------------------------------------}	procedure UndoEditor;	var	oldState, oldstate2: SignedByte;		alternativeSymbol: boolean;		ds: str255;	begin		case lastChangeInEditor of			lastChangeDataCell:					begin						settaxonstsLargestOverwriteCase(undoCellTaxon, undoCellCharacter, undoCellStates);						if SingleCell & editorSelected & CellIsSingleSelected(undoCellTaxon,undoCellCharacter) then							begin								LockHandle(editorCellTE, oldState);								FillsTE(editorCellTE, CellString);								MovesTE;								EndSetUpEdit(editorCellTE);								ResetHandle(editorCellTE, oldState);							end						else							begin								WriteTaxonCharacterCell (undoCellTaxon,undoCellCharacter, false,writeStandardCells,selectionModeAsIs);							end;						if ConsensusSequenceVisible & CharacterIsVisible(undoCellCharacter) then							WriteAllConsensesForCharacters(undoCellCharacter,undoCellCharacter,writeStandardCells,selectionModeAsIs);						if UpdateAsSensitiveToFirstTaxonChange(undoCellTaxon) & CharacterIsVisible(undoCellCharacter) then							MatchCharUpdate(undoCellCharacter, undoCellCharacter);					end;			lastChangeNameCell:  {a row or column name cell}					begin						LockHandle(undoNameCellStringH, oldState2);						ds := undoNameCellStringH^^;						if undoCellTaxon> 0 then							begin								SetTaxonName(undoCellTaxon,ds);								ds := TaxonName(undoCellTaxon);							end						else							begin								SetCharName(undoCellCharacter,ds);								ds := CharName(undoCellCharacter);							end;						ResetHandle(undoNameCellStringH, oldState2);						if SingleCell & editorSelected & CellIsSingleSelected(undoCellTaxon,undoCellCharacter) then							begin								LockHandle(editorCellTE, oldState);								FillsTE(editorCellTE, ds);								MovesTE;								EndSetUpEdit(editorCellTE);								ResetHandle(editorCellTE, oldState);							end						else	if editorTransposed then							if (undoCellCharacter>0) then								DrawRowName (undoCellCharacter, selectionModeAsIs)							else								DrawColName (undoCellTaxon, selectionModeAsIs)						else							if (undoCellCharacter>0) then								DrawColName (undoCellCharacter, selectionModeAsIs)							else								DrawRowName (undoCellTaxon, selectionModeAsIs);					end;			lastChangeNameRow:  {a row or column name cell}					begin						LockHandle(undoNameCellStringH, oldState2);						SetInfoRowName(undoWhichInfo,undoNameRow,undoNameCellStringH^^);						if infoEditing[undoWhichInfo] &  (infoEditRow[undoWhichInfo] = undoNameRow) then							TurnOnInfoEditing(undoWhichInfo,undoNameRow)						else							InvalidateInfoColumn(undoWhichInfo,infoName,1,MaximumInfoRows(undoWhichInfo));						{if editorTransposed then							if (undoCellCharacter>0) then								DrawRowName (undoCellCharacter, selectionModeAsIs)							else								DrawColName (undoCellTaxon, selectionModeAsIs)						else							if (undoCellCharacter>0) then								DrawColName (undoCellCharacter, selectionModeAsIs)							else								DrawRowName (undoCellTaxon, selectionModeAsIs);}						ResetHandle(undoNameCellStringH, oldState2);					end;			lastChangeCellBlock:				begin					UndoCellBlock(true);				end;			lastChangeInsertCharAndCellBlock:				begin					DeleteNewlyInsertedCharacters;					UndoCellBlock(false);					InvalidateWindow(editorWindow,true);				end;			lastChangeInsertTaxaAndCellBlock:				begin					DeleteNewlyInsertedTaxa;					UndoCellBlock(false);					InvalidateWindow(editorWindow,true);				end;			lastChangeAddCharacters:				begin					DeleteNewlyInsertedCharacters;					InvalidateWindow(editorWindow,true);				end;			lastChangeAddTaxa:				begin					DeleteNewlyInsertedTaxa;					InvalidateWindow(editorWindow,true);				end;			lastChangeMoveCharacters:				UndoRowMoves(charinfo);			lastChangeMoveTaxa:				UndoRowMoves(taxinfo);			otherwise;		end;		SetLastChangeInEditor(lastChangeCantUndo);	end;{-----------------------------------------------------------------------------}	procedure ShrinkWrapSelection;		label 1;		var st,et,sc,ec: integer;			newst,newet,newsc,newec: integer;			it,ic : integer;			tPort: WindowPtr;	begin		CalcSelectedTaxaCharacters(st, et, sc, ec,true);		//InvalidateCellBlock(st, et, sc, ec,true);		genericGetPort(tport);		genericSetPort(editorWindow);		EraseRect(editorSelectionRect);		InvalidateWindowRect(editorWindow,editorSelectionRect,false);		newst := st;		newet := et;		newsc := sc;		newec := ec;1: 		if st <> et then			begin				for it := st to et do					if CheckIfAllGaps(it,it,newsc,newec,editorToolsTreatMissingAsGaps) then 						newst := newst+1					else 						leave;				for it := et  downto st do					if CheckIfAllGaps(it,it,newsc,newec,editorToolsTreatMissingAsGaps) then 						newet := newet-1					else 						leave;			end;		if sc <> ec then			begin				for ic := sc to ec do					if CheckIfAllGaps(newst,newet,ic,ic,editorToolsTreatMissingAsGaps) then 						newsc:= newsc+1					else 						leave;				for ic := ec  downto sc do					if CheckIfAllGaps(newst,newet,ic,ic,editorToolsTreatMissingAsGaps) then 						newec := newec-1					else 						leave;			end;		if (newst<>st)|(newet<>et)|(newsc<>sc)|(newec<>ec) then			begin				st := newst;				et := newet;				sc := newsc;				ec := newec;				goto 1;			end;		if (newst>newet) | (newsc> newec) then			ZeroSelection		else			begin				if not editorTransposed then					begin						if (editorSelectionTopLeft.v>=1) | (newst>1) then							editorSelectionTopLeft.v := newst;						editorSelectionBotRight.v := newet;						if (editorSelectionTopLeft.h>=1) | (newsc>1) then							editorSelectionTopLeft.h := newsc;						editorSelectionBotRight.h := newec;					end				else					begin						if (editorSelectionTopLeft.h>=1) | (newst>1) then							editorSelectionTopLeft.h := newst;						editorSelectionBotRight.h := newet;						if (editorSelectionTopLeft.v>=1) | (newsc>1) then							editorSelectionTopLeft.v := newsc;						editorSelectionBotRight.v := newec;					end;				CalcEditorSelectionRect(editorSelectionTopLeft,editorSelectionBotRight);			end;		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	procedure MoveSelectedInfoToTopBottom(whichinfo: integer; up: boolean);	label 1;	var		theRow: longint;		currentRow, rowToMove, maxRows: longint;		moveDone: boolean;		theDialog: DialogPtr;		tempP: WindowPtr;		pleaseUndo: boolean;	begin		StoreOldNumbers(whichinfo);		SetUpBeforeRowMove(whichinfo);		moveDone  := false;		maxRows := MaximumInfoRows(whichinfo);		StartThermo(theDialog,tempP,0,maxRows ,'Moving...','',false);				if up then			begin				currentRow := 1;				repeat					UpdateThermo (theDialog,0,currentRow, maxRows,false);					if abortedThermo then leave;					rowToMove := 0;					for theRow := currentRow to maxRows do						if InfoRowSelected(whichinfo,theRow) then							begin								rowToMove := theRow;								leave;							end;					if rowToMove > currentRow then						begin							if not MoveIndividualInfoRow(whichinfo,rowToMove,currentRow) then								begin									goto 1;								end;							movedone:= true;						end;					currentRow := currentRow+1;				until currentRow = MaximumInfoRows(whichinfo);			end		else			begin				currentRow := maxRows;				repeat					UpdateThermo (theDialog,0,maxRows-currentRow, maxRows,false);					if abortedThermo then leave;					rowToMove := maxRows+1;					for theRow := currentRow downto 1 do						if InfoRowSelected(whichinfo,theRow) then							begin								rowToMove := theRow;								leave;							end;					if rowToMove < maxRows then						begin							if not MoveIndividualInfoRow(whichinfo,rowToMove,currentRow) then								begin									goto 1;								end;							movedone:= true;						end;					currentRow := currentRow-1;				until currentRow = 0;			end;								pleaseUndo := abortedThermo;1: 		EndThermo (theDialog,tempP,false);		if moveDone then			CleanUpAfterRowMove(whichinfo,pleaseUndo);	end;{-----------------------------------------------------------------------------}	procedure myCutText(TE: TEHandle);	var os: OSErr;	begin{$IFC CARBON}		if (ClearCurrentScrap =  noErr) then			begin{$ENDC}			TECut(TE);{$IFC CARBON}		os := TEToScrap;		if (os<>noErr) then			os := ClearCurrentScrap		else			begin{$ENDC}		scrapispict := false;		scraptextdirty := true;{$IFC CARBON}			end;		end;{$ENDC}	end;{-----------------------------------------------------------------------------}	procedure myCopyText(TE: TEHandle);	var os: OSErr;	begin{$IFC CARBON}		if (ClearCurrentScrap =  noErr) then			begin{$ENDC}			TECopy(TE);{$IFC CARBON}		os := TEToScrap;		if (os<>noErr) then			os := ClearCurrentScrap		else			begin{$ENDC}		scrapispict := false;		scraptextdirty := true;{$IFC CARBON}			end;		end;{$ENDC}	end;{-----------------------------------------------------------------------------}	procedure CheckIfScrapIsPict;	var os: OSErr;		scrapReference: ScrapRef;		flavorFlags: ScrapFlavorFlags;	begin{$IFC CARBON}		os := GetCurrentScrap(scrapReference);		os := GetScrapFlavorFlags(scrapReference,kScrapFlavorTypePicture,flavorFlags);		scrapIsPict := (os =  noErr);{$ENDC}	end;{-----------------------------------------------------------------------------}	function myPastePicture(var pictH: PicHandle): boolean;	var os: OSErr;		scrapReference: ScrapRef;		dataSize: Size;		oldState: SignedByte;		flavorFlags: ScrapFlavorFlags;	begin{$IFC CARBON}		os := GetCurrentScrap(scrapReference);		os := GetScrapFlavorFlags(scrapReference,kScrapFlavorTypePicture,flavorFlags);		if (os =  noErr) then			begin				os := GetScrapFlavorSize(scrapReference,kScrapFlavorTypePicture,dataSize);				if (os = noErr) & (dataSize>0) then					begin						clippicture := picHandle(NewHandle(dataSize));						os := MemError;						if (os=memFullErr) then						else							begin								LockHandle(clippicture,oldState);								os := GetScrapFlavorData(scrapReference,kScrapFlavorTypePicture,dataSize,Ptr(GetMaster(Handle(clippicture))));								ResetHandle(clippicture, oldState);							end;					end;			end;		if os = noErr then{$ENDC}			myPastePicture := PictToPict(clippicture, pictH);	end;{-----------------------------------------------------------------------------}	procedure RetitleNexusBlock;	var			theRow: longint;			whichinfo: integer;	begin				if IsInfoWindow(frontWindow) then					begin						whichInfo := WhichInfoWindow(frontWindow);						if (whichInfo=NexusBlockInfo) & SingleInfoRowSelected(whichinfo,theRow) then							QueryUserNexusBlockTitle(theRow);					end;	end;{-----------------------------------------------------------------------------}	procedure DoEditMenu(ItemNo : Integer);		var			ChartpicH: PicHandle;			theDialog: DialogPtr;			os: OSErr;			tempP: windowptr;			oldState, oldstate2: SignedByte;			amountneeded: longint;			whichinfo: integer;			whichText: integer;			it,ic: integer;			db: boolean;	begin		case ItemNo of			UndoItem: 				if IsEditorWindow(frontwindow)  then 					UndoEditor				else if treeopen and not noundo then					UndoMove				else if (IsInfoWindow(frontWindow) & (lastChangeInEditor=lastChangeNameRow) & (WhichInfoWindow(frontWindow)=undoWhichInfo)) | lastChangeIsEither then					UndoEditor				else					Beep;								{WarnIfCantUndoItem:				begin					warnIfCantUndo := not warnIfCantUndo;					myCheckMenuItem(EditMHdl, WarnIfCantUndoItem,warnIfCantUndo);				end;}			CutItem: 				begin					SetEWScrap;					if IsEditableTextWindow(frontwindow) then						begin							whichText := WhichTextWindow(frontwindow);							myCutText(textWindowInfo[whichText]^.TE);							SizeTextWindowText(whichText, false, false, true);							dirtyfile := true;						end					else if IsInfoWindow(frontWindow) then						begin							whichInfo := WhichInfoWindow(frontWindow);							if infoEditing[whichinfo] then								myCutText(infoTE[whichinfo]);						end					else if IsEditorWindow(frontwindow) and editorSelected then						begin							if SingleCell and footediting then								begin									myCutText(noteTE);									Datachanged := true;									CheckNoteLength;								end							else if SingleCell then								begin									myCutText(editorCellTE);									StoreSelectedSingleCellForUndo;									myEnableItem(EditMHdl, UndoItem);									SetEWScrap;									Datachanged := true;									if CharOfCell(editorSelectionTopLeft) > 0 then										begin											if TaxonOfCell(editorSelectionTopLeft) > 0 then												begin													FillsTE(editorCellTE, missing);													MovesTE;													EndSetUpEdit(editorCellTE);												end;											dirtymaxst := true;										end;								end							else								begin									StoreEWScrap;									scrapispict := false;									scraptextdirty := true;									db := ClearSelected(true);								end;						end					else if (frontwindow=stateswindow) then						begin							if statesSelected then								begin									CopyStatesToClipBoard(statesWindowCharacter);									ClearStatesInWindow(statesWindowCharacter);								end							else if statesEditing then								begin									myCutText(statesTE);									dirtyfile := true;								end;						end					else if frontwindow = pictwindow then						if EnoughMemory(GetHandleSize(Handle(grabpicture)), amountneeded) then							begin								myCutCopyPicture(grabpicture);								DestroyFoot(footPict, TaxonOfCell(editorSelectionTopLeft), CharOfCell(editorSelectionTopLeft));								ClosePictWindow;							end						else							InstantErrorPlus(294, concat(StringFromNum(amountneeded div 1024), 'K'));				end;			CopyItem: 				begin					SetEWScrap;					if IsTreeWindow(frontwindow) then						if OptionEvent(Event) then 							TextTreeToClipBoard						else							LaserTree(treeOutputToClipBoard)					else if IsEditableTextWindow(frontwindow) then						begin							whichText := WhichTextWindow(frontwindow);							myCopyText(textWindowInfo[whichText]^.TE);							SizeTextWindowText(whichText, false, false, true);						end					else if (frontwindow=stateswindow) then						begin							if statesSelected then								CopyStatesToClipBoard(statesWindowCharacter)							else if statesEditing then								myCopyText(statesTE);						end					else if IsEditorWindow(frontwindow) and editorSelected then						begin							scrapispict := false;							scraptextdirty := true;							if SingleCell and footediting then								begin									TECopy(noteTE);									CheckNoteLength;								end							else if SingleCell then								begin									myCopyText(editorCellTE);									{SetEWScrap;}								end							else if OptionEvent(Event) then								StoreCellBlockAsText							else								StoreEWScrap;{Datachanged := true;}						end					else if frontwindow = pictwindow then						begin							myCutCopyPicture(grabpicture);						end					else if (frontwindow = Chartwindow) and (CWView in [scatterview, histoview]) then						begin							genericSetPort(ChartWindow);							Printon := true;   {turn this on so doesn't draw controls etc.}							ChartPicH := OpenNewPicture(WindowPortRect(chartWindow));							DrawChartWindow(WindowPortRect(chartWindow));							ClosePicture;							printon := false;							myCutCopyPicture(ChartPicH);						end					else if IsInfoWindow(frontWindow) then						begin							whichInfo := WhichInfoWindow(frontWindow);							if infoEditing[whichinfo] then								myCopyText(infoTE[whichinfo]);						end;				end;			PasteItem: 				begin					CheckIfScrapIsPict;					if IsEditableTextWindow(frontwindow) then						begin							whichText := WhichTextWindow(frontwindow);							myPasteText(textWindowInfo[whichText]^.TE);							SizeTextWindowText(whichText, false, false, true);							myDisableItem(EditMHdl, CutItem);							myDisableItem(EditMHdl, CopyItem);							myDisableItem(EditMHdl, ClearItem);							dirtyfile := true;						end					else if (frontwindow=stateswindow) then						begin							if statesSelected then								PasteStatesFromClipBoard(statesWindowCharacter)							else if statesEditing then								begin									PasteAndRemoveReturns(statesTE);									dirtyfile := true;								end;						end					else if IsEditorWindow(frontwindow) and not scrapispict and editorSelected then						DoEWPaste					else if (frontwindow = pictwindow) or (IsEditorWindow(frontwindow) and scrapispict) then						begin							if myPastePicture(grabpicture) & (grabpicture<>nil) then								begin							{nathan: if not pictEditable then								CreatePICTresfile;							if pictEditable then								begin}									AttachPicHandleToFoot(footPict, editorSelectionTopLeft, grabpicture);									InvalidateWindow(pictWindow, true);									ShrinkWrapPict;							{nathan:	end;}								end;						end					else if IsInfoWindow(frontWindow) then						begin							whichInfo := WhichInfoWindow(frontWindow);							if infoEditing[whichinfo] then								PasteAndRemoveReturns(infoTE[whichinfo]);						end;				end;			ClearItem: 				begin					if IsEditableTextWindow(frontwindow) then						begin							whichText := WhichTextWindow(frontwindow);							TEDelete(textWindowInfo[whichText]^.TE);							SizeTextWindowText(whichText, false, false, true);							dirtyfile := true;						end					else if (frontwindow=stateswindow) then						begin							if statesSelected then								ClearStatesInWindow(statesWindowCharacter)							else if statesEditing then								begin									TEDelete(statesTE);									dirtyfile := true;								end;						end					else if IsEditorWindow(frontwindow) and editorSelected then						begin							if SingleCell and footediting then								begin									TEDelete(noteTE);									StoreSelectedSingleCellForUndo;									CheckNoteLength;									Datachanged := true;								end							else if not SingleCell then								db := ClearSelected(false)							else if OptionEvent(Event) and (AnyFeet(footText) or AnyFeet(footPict)) then			{single cell - remove feet}								begin									if AnyFeet(footPict) then										begin											DestroyFoot(footPict, TaxonOfCell(editorSelectionTopLeft), CharOfCell(editorSelectionTopLeft));											ClosePictWindow;										end;									if AnyFeet(footText) then										DestroyFoot(footText, TaxonOfCell(editorSelectionTopLeft), CharOfCell(editorSelectionTopLeft));									Datachanged := true;									if foottexton then										begin											FillNoteTE;											EraseRect(editorFootNoteRect);										end;								end							else						{single cell - clear}								begin									TEDelete(editorCellTE);									myEnableItem(EditMHdl, UndoItem);									Datachanged := true;									if CharOfCell(editorSelectionTopLeft) > 0 then										begin											if TaxonOfCell(editorSelectionTopLeft) > 0 then												begin													FillsTE(editorCellTE, missing);													MovesTE;													EndSetUpEdit(editorCellTE);												end;											dirtymaxst := true;										end;								end;						end					else if frontwindow = pictwindow then						begin							DestroyFoot(footPict, TaxonOfCell(editorSelectionTopLeft), CharOfCell(editorSelectionTopLeft));							ClosePictWindow;						end					else if IsInfoWindow(frontWindow) then						begin							whichInfo := WhichInfoWindow(frontWindow);							if infoEditing[whichinfo] then								TEDelete(infoTE[whichinfo]);						end;				end;							DeleteItem:				begin					if IsEditorWindow(frontwindow) & (WholeTaxonSel | WholeCharSel) then						begin							db := QueryRemoveWholeRowColumn;						end					else if IsInfoWindow(frontWindow) then						begin							whichInfo := WhichInfoWindow(frontWindow);							if infoSomeSelected[whichinfo] then 								QueryDeleteSelectedInfoRows(whichinfo);						end;				end;			ContinuousEditItem: 				if nucleotides & OptionEvent(Event) & ControlEvent(Event) then					SetContinuousToGCBias				else ContinuousEdit; 			xxxxMultiplyItem: 				if editorOpen then					MultiplicateRC;			xxxxDuplicateItem: 				if editorOpen then					ReplicateSelected(1, true, true);								SelectTaxaWithStateItem:				if editorOpen & editorSelected & SingleCell then					begin						ic := CharOfCell(editorSelectionTopLeft);						it := TaxonOfCell(editorSelectionTopLeft);						SelectAllTaxaWithState(gettaxonstslargest(it,ic),ic);					end;								TransferSelectionItem:				if editorOpen & editorSelected & (WholeCharSel | WholeTaxonSel) then					MoveSelectedToListWindow(not OptionEvent(Event));								MoveSelectedRowsToTopItem:				if IsInfoWindow(frontWindow) then					begin						whichInfo := WhichInfoWindow(frontWindow);						if infoSomeSelected[whichinfo] & InfoRowsMassMovable(whichinfo) then							MoveSelectedInfoToTopBottom(whichinfo, not OptionEvent(Event))						else 							NewError(429,0);					end;								ShrinkWrapSelectionItem:				if editorOpen & editorSelected & not SingleCell then					ShrinkWrapSelection;					{$IFC LOCKCONTROL}			LockControlItem:				DoLockControls;				//RetitleNexusBlock;				{$ENDC}			otherwise				if editorOpen then					begin						case ItemNo of							EntryInterpretItem: 								{if not CellVisible(editorSelectionTopLeft, editorSelectionBotRight) then											ScrollToSelection(true);}								EntryInterpetation;							TreatMissingAsGapItem: 								begin									editorToolsTreatMissingAsGaps := not editorToolsTreatMissingAsGaps;									myCheckMenuItem(EditMHdl, TreatMissingAsGapItem, editorToolsTreatMissingAsGaps);								end;															TrackCellItem: 								begin									trackcell := not trackcell;									myCheckMenuItem(EditMHdl, TrackCellItem, trackcell);								end;															{BlockMoveItem: 								begin									moveCellBlocks := not moveCellBlocks;									if moveCellBlocks then 										editorMode := edBlockMove									else										editorMode := edNormal;									myCheckMenuItem(EditMHdl, BlockMoveItem, moveCellBlocks);								end;}							otherwise								;						end;					end;		end;		FixEditMenu;	end;		end.