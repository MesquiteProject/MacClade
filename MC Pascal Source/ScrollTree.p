unit ScrollTree;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, CharUtil, TreeUtil, N7on, InfoWindows, Coloring, TreeDrawer;	procedure ScrollTreeWindow;	procedure ScrollTreeUpDown (whichControl: ControlRef; theCode: INTEGER);	procedure ScrollTree (wh: point);	procedure ScrollTreeHome;{еееееееееееееееееееееее}implementation {е$S ScrollTree}{-----------------------------------------------------------------------------}	procedure ScrollTreeWindow;		var{$IFC CARBON}			oldTWOrigin: LongPoint;{$ELSEC}			oldTWOrigin: Point;{$ENDC}			dv, dh: integer;			box, box2: rect;			scrollRgn: RgnHandle;			oldClip, dClip: RgnHandle;	begin		oldClip := NewRgn;		dClip := NewRgn;		scrollRgn := NewRgn;		TWScrolling := true;		GetClip(oldClip);		oldTWOrigin := TWOrigin;{$IFC FLIPTREE}		if treeflipped then			begin				TWOrigin.h := GetControlValueLong(vTWScroll);				TWOrigin.v := GetControlValueLong(hTWScroll);				dv := oldTWOrigin.h - TWOrigin.h;				dh := oldTWOrigin.v - TWOrigin.v;			end		else			begin				TWOrigin.v := GetControlValueLong(vTWScroll);				TWOrigin.h := GetControlValueLong(hTWScroll);				dv := oldTWOrigin.v - TWOrigin.v;				dh := oldTWOrigin.h - TWOrigin.h;			end;{$ELSEC}		TWOrigin.v := GetControlValueLong(vTWScroll);		TWOrigin.h := GetControlValueLong(hTWScroll);		dv := oldTWOrigin.v - TWOrigin.v;		dh := oldTWOrigin.h - TWOrigin.h;{$ENDC}		if (dv <> 0) or (dh <> 0) then			begin{========= setting the clip for scrolling the tree =========}				if nex7on then								{don't scroll the data boxes vertically}					begin						SetRect(box, 0, 0, visTWR.right, dataBoxB.bottom + 1);						RectRgn(dClip, box);						DiffRgn(TWClip, dClip, scrollRgn);						if twfullscreen then							begin								Box := claspRect;								InsetRect(box, -1, 0);								RectRgn(dClip, box);								DiffRgn(scrollRgn, dClip, scrollRgn);							end;						SetClip(scrollRgn);					end				else					SetClip(TWClip);{========= scrolling the tree =========}				ScrollRect(visTWR, dh, dv, scrollRgn); 	{scroll over main tree area}				SetClip(scrollRgn);				DrawTree;				ReshadeTree;{========= scrolling the databoxes =========}				if nex7on and (dh <> 0) then				{scroll databoxes horizontally if needed}					begin						Box := databoxB;						box.left := box.left + 15;						box.top := 0;						ClipRect(box);						ScrollRect(box, dh, 0, dclip);						UnionRgn(dClip, scrollRgn, scrollRgn);						treerect.top := dataBoxB.bottom;						SetClip(scrollRgn);						NextSevenChars;					end;				godraw := false;				myValidRect(treeWindow,WindowPortRect(treeWindow));				ClipRect(WindowPortRect(treeWindow));				DrawControls(treeWindow);				SetUpRect;			end;		TWScrolling := false;		ZapRegion(scrollRgn);		ZapRegion(dClip);		ZapRegion(oldClip);	end;{----------------------------------------------------------------------------}	procedure ScrollTreeUpDown (whichControl: ControlRef; theCode: INTEGER);	begin		if scrollup then			begin				if theCode = kControlUpButtonPart then					begin						SetControlValueLong(whichControl, GetControlValueLong(whichControl) - 20);						ScrollTreeWindow					end			end		else if theCode = kControlDownButtonPart then			begin				SetControlValueLong(whichControl, GetControlValueLong(whichControl) + 20);				ScrollTreeWindow			end	end;{----------------------------------------------------------------------------}	procedure ScrollTree (wh: point);		var			MyControl, t: integer;			mypt: point;			oldClip: RgnHandle;	begin		MyControl := FindControl(wh, treeWindow, whichControl);		if whichControl= nil then Exit(ScrollTree);		TWscrolling := true;		case MyControl of			kControlUpButtonPart: 				begin					scrollup := true;					t := myTrackControl(whichControl, wh, ScrollTreeUpDownUPP);				end;			kControlDownButtonPart: 				begin					scrollup := false;					t := myTrackControl(whichControl, wh, ScrollTreeUpDownUPP);				end;			kControlPageUpPart: 				repeat					GetMouse(myPt);					if TestControl(whichControl, myPt) = mycontrol then						begin							SetControlValueLong(whichControl, GetControlValueLong(whichControl) - 500);							ScrollTreeWindow						end				until not StillDown;			kControlPageDownPart: 				repeat					GetMouse(myPt);					if TestControl(whichControl, myPt) = mycontrol then						begin							SetControlValueLong(whichControl, GetControlValueLong(whichControl) + 500);							ScrollTreeWindow						end				until not StillDown;			kControlIndicatorPart: 				begin					oldClip := NewRgn;					GetClip(oldClip);					ClipRect(WindowPortRect(treeWindow));					t := myTrackControl(whichControl, wh, nil);					SetClip(oldClip);					ZapRegion(oldClip);					ScrollTreeWindow;				end;			otherwise				;		end;		TWscrolling := false;	end;{----------------------------------------------------------------------------}	procedure ScrollTreeHome;	begin		SetControlValueLong(vTWScroll, GetControlMinimumLong(vTWScroll));		SetControlValueLong(hTWScroll, GetControlMinimumLong(hTWScroll));		ScrollTreeWindow;	end;end.