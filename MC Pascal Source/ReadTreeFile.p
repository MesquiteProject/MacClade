unit ReadTreeFile;{본본본본본본본본본본본볗{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{본본본본본본본본본본본볗{본본본본본본본본본본본볗interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, LinkUtil, TaxonCHUtil, CharUtil, Thermos, TreeUtil, CHUNK, ReadWriteUtil, ReadUtil, WriteUtil, TreeCycle, WriteTreefile, UtilLibInterface;	function MyTreeFileHook7 (localItemHit: integer; theDialog: DialogPtr; mydataPtr: Ptr): integer;	function MyTreeFileHook (localItemHit: integer; theDialog: DialogPtr): integer;	procedure DescTreeToPackTree (var descH, packH: Handle; var success: boolean; var status, numberterminals: integer; var theName: str255);	procedure GetTranslateTable (wastree: boolean);	procedure ReadTreeBlock (theNexusBlock: NexusBlockPtr; addToExistingTrees: boolean; firstCommand: str255);	procedure ReadForeignTrees (filetype: integer; firsttoken: str255);	procedure StartNewTreeFile;	procedure GetTreeFile;	function StartFileTrees (j: integer; var ds: str255; var oldtreechain: integer; var packH: Handle): boolean;	procedure EndFileTrees (oldtreechain: integer; var packH: Handle);	function GetFileTree (var ds: str255; var packH: Handle; var numtrees: longint): boolean;{본본본본본본본본본본본볗implementation	const		badtaxon = 8192;		vaportaxon = 8193;		taxsetToken = 4048;		nodeLimit = 400;    {corresponds to about 200 taxa}	var		TaxonCHUNKMaster: longint;{    numberTerminals: integer;}{$SETC TAXSETINTREE=TRUE}{$IFC TAXSETINTREE}{----------------------------------------------------------------------------}	procedure SetTaxSetBools (taxsetNumber: integer);{this procedure takes the taxset numbered taxSetNumber, and sticks into taxonHdl^^.taxSet whether or not}{the taxon is a member of that taxset.}{Note that one can get the taxSetNumber from the name of the taxset by calling }{	the function SetNumber(token, theChain <> taxsetchain, taxsetchain)}{If this returns -1, then you know that token is not the name of a taxset}{otherwise it returns an integer equal to the taxSetNumber.}		var			linkH: Handle;	begin		linkH := NewHandle(2);		GetLink(taxsetchain, taxSetNumber, linkH, false);		TaxSetLinkToBools(linkH, 0, setReplace);		ZapHandle(linkH);	end;{$ENDC}{----------------------------------------------------------------------------}	function FindTaxonNumber (var taxtoken: str255): integer;  {v3.05: changed to var }{returns number of taxon whose label is "taxtoken"}		var			TaxonHdl: thdl;			found: boolean;			it, itset, tokenNum, taxNum, taxSetNumber: integer;			TaxonHdlP: THdlPtr;			dL: Longint;			tname: strTaxName;			oldstate: signedbyte;	{.....}		procedure CheckSetAlreadyIn (var taxNum: integer);		begin			taxonHdl := getTaxonHdl(taxNum);			if taxonHdl^^.taxonInTreeDesc then   {we have already found this taxon in the tree!}				begin					NewError(115, 0);					taxNum := badtaxon;   {pretend like we couldn't find it, so that it is cut out of tree}				end			else				taxonHdl^^.taxonInTreeDesc := true;		end;	{.....}	begin{    DebugStr('; A7; g;');}			tname := '';		if NumericalToken(taxToken) then			begin				StringToNum(taxtoken, dL);				tokenNum := LowWord(dL);   {get numerical equivalent to token, just in case it is just a taxon number}			end		else			tokenNum := badtaxon;{$SETC USEASMCOMPARE=TRUE}		if quickTranslate then{if the translation table is in data matrix order, with no extra taxa, and none missing, then}{we can just convert the taxtoken to an integer and go directly to that line in the translation}{table}			begin				if (tokenNum > 0) and (tokenNum <= numtaxa) then					begin						TaxonHdl := THdlPtr(TaxonCHUNKMaster + HdlSize * ord4(tokenNum - 1))^;						tname := taxonHdl^^.labl;{$IFC USEASMCOMPARE}						found := CompareStringC(@tname, @taxtoken);{$ELSEC}						found := (length(tname) = length(taxtoken)) & (tname = taxtoken);{$ENDC}						if found then							it := tokenNum;					end				else					found := false;				quickTranslate := found;			end		else			found := false;		if not found then  {look in the translation table}			begin				TaxonHdlP := THdlPtr(TaxonCHUNKMaster);				for it := 1 to numtaxa do					begin						taxonHdl := TaxonHdlP^;						tname := taxonHdl^^.labl;{$IFC USEASMCOMPARE}						if CompareStringC(@tname, @taxtoken) then{$ELSEC}							if (length(tname) = length(taxtoken)) & (tname = taxtoken) then{$ENDC}								begin									found := true;									leave;								end;						TaxonHdlP := THdlPtr(ord4(taxonhdlP) + HdlSize);					end;			end;		if not found then  {look for it in taxonNames}			if translatetable then {but only do so if there is a translation table}{ otherwise, we have already done this, as the taxon labels are taxon names!}				begin					TaxonHdlP := THdlPtr(TaxonCHUNKMaster);					for it := 1 to numtaxa do						begin							TaxonHdl := TaxonHdlP^;							tname := taxonHdl^^.name;{$IFC USEASMCOMPARE}							if CompareStringC(@tname, @taxtoken) then{$ELSEC}								if (length(tname) = length(taxtoken)) & (tname = taxtoken) then{$ENDC}									begin										found := true;										leave;									end;							TaxonHdlP := THdlPtr(ord4(taxonhdlP) + HdlSize);						end;				end;		if found then			taxNum := it		else if (tokenNum > 0) and (tokenNum <= numtaxa) then			taxNum := tokenNum		else			begin				taxNum := badtaxon;{$IFC TAXSETINTREE}	{OK, we've looked everywhere else, let's see if it is a taxset}	{first let's check to see if there are any taxsets}				if (UserLinks[taxsetchain] > 0) then					begin						taxSetNumber := SetNumber(MakeCaps(taxToken), true, taxsetchain);						if taxSetNumber <> notASet then							begin								taxNum := taxSetToken;								SetTaxSetBools(taxSetNumber);							end;					end;{$ENDC}			end;		if (taxNum > 0) and (taxNum <= numtaxa) then   {let's check if already in tree desc}			CheckSetAlreadyIn(taxNum){$IFC TAXSETINTREE}		else if taxNum = taxsettoken then			begin				for it := 1 to numtaxa do					if InTaxSet(it) then						begin							itset := it;							CheckSetAlreadyIn(itset);							if itset = badtaxon then								taxnum := badtaxon;						end;			end; {$ENDC}		FindTaxonNumber := taxNum;	end;{-----------------------------------------------------------------------------}	procedure RemoveNewNode (PackedP: ptr; var thisnode: longint; assignnode: longint);	begin		Newerror(27, 0);		dirtytree := true;		SetPackedNode(PackedP, thisnode, assignnode);		DeletePackedTaxon(PackedP, thisnode, thisnode);		if thisnode <= 1 then			thisnode := 0		else			thisnode := thisnode - 2;	end;{-----------------------------------------------------------------------------}{PackTree should go in readin from file;  success returns whether tree successfully made; if not}{then an error is given and the link should be ignored/deleted/nevermade}{-----------------------------------------------------------------------------}	function PackedRightDescendantOf (startP: ptr; ie: integer): integer;		var			inow: integer;		procedure recursethroughclade;			var				nodecode: integer;		begin			inow := inow + 1;			nodecode := GetPackedNode(startP, inow);			if (nodecode = 0) or (nodecode = nullpacked) then				begin					recursethroughclade;					recursethroughclade;				end			else if (nodecode < 0) then				recursethroughclade;		end;	begin		inow := ie;		RecurseThroughClade;		PackedRightDescendantOf := inow + 1;	end;{-----------------------------------------------------------------------------}	function PackedSisterOf (startP: ptr; ie: integer): integer;		var			ancnode: integer;	begin		ancnode := packedancestorof(startP, ie);		if ancnode <> ie - 1 then			PackedSisterOf := PackedAncestorOf(startP, ancnode) + 1		else			PackedSisterOf := PackedRightDescendantOf(StartP, ancnode);	end;{-----------------------------------------------------------------------------}	procedure CleanUpPackedTree (packedP: Ptr; var endN: longint; var status: integer); {cleans out taxa not in matrix; also notes polytomies and fixanc}		var			nodecode, ancnode, thN, ancwasnumbered: integer;	begin		thN := endN;  {start at end of description and move right to left}		repeat			nodecode := GetPackedNode(packedP, thN);  {find integer at this spot}			if (abs(nodecode) = badtaxon) or (abs(nodecode) = vaportaxon) then  {taxon not in matrix; not to be removed}				begin					if (abs(nodecode) = badtaxon) then						begin							Newerror(27, 0);							dirtytree := true;						end;					if thN <> 1 then						begin							ancnode := PackedAncestorOf(PackedP, thN);  {find location of ancestor}							ancwasnumbered := GetPackedNode(packedP, ancnode);  {find integer at ancestor}							if (ancwasnumbered = 0) & (GetPackedNode(packedP, PackedSisterOF(packedP, thN)) = nullpacked) then								SetPackedNode(packedP, PackedSisterOF(packedP, thN), 0);  {destroys polytomies undone by removal}						end;					DeletePackedTaxon(PackedP, thN, endN);  {removes taxon not in matrix}		{calculating how description has been compressed by removal}					if (nodecode > 0) and (thN > 1) then  {removed bad taxon in terminal position}						begin							if (ancwasnumbered = nullpacked) or (ancwasnumbered >= 0) then  {ancestor of bad taxon was internal node and thus was also removed}								begin									thN := thN - 1;									endN := endN - 2  {recalculating length of description}								end							else {ancestor of bad taxon was observed taxon fixed as ancestor and thus was not removed}								endN := endN - 1; {recalculating length of description}						end					else  {removed bad taxon in ancestral position}						endN := endN - 1; {recalculating length of description}				end;			thN := thN - 1;		until (thN = 0) or (endN < 3); {stop when at front or when already reduced too far}		if thN = 0 then  {go back through description and check for polytomies and fixanc}			begin				thN := endN;  {start at end of description and move right to left}				repeat					nodecode := GetPackedNode(packedP, thN);  {find integer at this spot}					if nodecode = nullpacked then   {setting bits for polytomies and fixanc}						BitSet(@status, 0) {polytomy}					else if (nodecode < 0) then						BitSet(@status, 1); {ancestor}					thN := thN - 1;				until (thN = 0) or (endN < 3);			end;	end;{-----------------------------------------------------------------------------}{packed tree description: }{consist of a relocatable block of two-byte integers, each one representing a node in the usual clockwise recursion sequence}{through the tree }{0 				= internal node, not null}{nullpacked 	= -32768 = null node}{a 				= terminal node for ath observed taxon in matrix}{-a 			= fixed ancestor for ath observed taxon in matrix}{badtaxon 		= 8192 = terminal node for taxon not in data matrix }{-badtaxon 	= fixed ancestor for taxon not in data matrix }{Thus a simple right-leaning ladder of 4 taxa would be 0/1/0/2/0/3/4;  a left-leaning ladder 0/0/0/1/2/3/4; a bush}{0/1/-32768/2/-32768/3/4, a ladder with taxon 1 fixed as ancestor to the whole tree -1/0/2/0/3/4}{After the description is built, other information is concatenated to front of handle that stores information}{including name of tree (see description before PackTreeLink}	procedure PackTree (descH: handle; var packedH: Handle; var success: boolean; var status, numberterminals: integer);		var			onlythismany: longint;			it: integer;			token: str255;			thisnode, oldchunkpos: longint;			descP: ptr;			PackedP: ptr;			oldState1, oldState2, oldState3: SignedByte;			rightparenswaslast: boolean;			punc: char;			lastwas: integer;			branchLengthLocal: double;			hasBranchLength: boolean;			hasSomeBranchLengths : boolean;			firstBranchLength: boolean;{..................................................................................}{$IFC TAXSETINTREE}		procedure MakeTaxsetBush;			var				itset, firstnode: integer;				firstin, onlyone: boolean;		begin		{just write 0-tax1-nullpacked-tax2-nullpacked-tax3-nullpacked-tax4...taxn}			firstin := true;			firstnode := -1;			onlyone := false;			for itSet := 1 to numtaxa do				if InTaxSet(itSet) then   {check to see if itset is in current taxset, that is, the taxset we just found}					begin						if firstin then							begin								SetPackedNode(PackedP, thisnode, nullpacked);								firstnode := thisnode;								onlyone := true;								firstin := false;							end						else							begin								onlyone := false;								thisnode := thisnode + 1;								SetPackedNode(PackedP, thisnode, nullpacked);							end;						thisnode := thisnode + 1;						SetPackedNode(PackedP, thisnode, itSet);						if thisnode > onlythismany then							begin								success := false;  {treemaking stumbled; too many extra taxa}								Newerror(38, 0);							end;						numberterminals := numberterminals + 1;					end;			if onlyone then				SetPackedNode(PackedP, firstnode, 0);			MovePackedToLeft(PackedP, thisnode, thisnode);			thisnode := thisnode - 1;		end;{$ENDC}{................................}		const			wasleftparens = 1;			wastaxset = 2;		procedure InPackTree;  {constructs packedtree from tree description in buffer descH}			label				1;			var				NameOfN: integer;				baseofnode: integer;{...........................}			procedure PackRight;  {after right descendant is encountered, deal with it}				var					baseofright: integer;			begin				baseofright := thisnode;				InPackTree;  {deal with descendant's clade}								getNodeTokenC(@descP, @token, @punc, branchLengthLocal, hasBranchLength);				if hasBranchLength then hasSomeBranchLengths := true;				if punc <> chr(0) then					token := punc;				if token = '(' then					lastwas := wasleftparens				else					lastwas := 0;				if (Token = ')') then					rightparenswaslast := true				else if token <> ',' then					if rightparenswaslast then						begin		     {LABELLED INTERNAL NODE FOUND HERE}							getNodeTokenC(@descP, @token, @punc, branchLengthLocal, hasBranchLength);							if hasBranchLength then hasSomeBranchLengths := true;							if punc <> chr(0) then								token := punc;							lastwas := 0;							rightparenswaslast := (Token = ')');						end;				if Token = ',' then  {this descendant node has yet another sister to its right, therefore polytomy}					begin {need to open up space to left and insert null node}						rightparenswaslast := false;						MovePackedtoRight(PackedP, baseofright + 1, thisnode);						SetPackedNode(PackedP, baseofright + 1, nullpacked);						thisnode := thisnode + 1;						if thisnode > onlythismany then							begin								success := false;  {treemaking stumbled; too many extra taxa}								Newerror(38, 0);							end;						PackRight;					end;			end; {procedure PackRight}{...........................}		begin			getNodeTokenC(@descP, @token, @punc, branchLengthLocal, hasBranchLength);			if hasBranchLength then hasSomeBranchLengths := true;			if punc <> chr(0) then				token := punc;			if (Token <> ';') and success then				begin  {not ';'}					rightparenswaslast := false;					thisnode := thisnode + 1;					if thisnode > onlythismany then						begin							success := false;  {treemaking stumbled; too many extra taxa}							Newerror(38, 0);							goto 1;						end;					baseofnode := thisnode;					if (Token = '(') then						begin		{본== internal nodes}							lastwas := wasleftparens;							SetPackedNode(packedP, thisnode, 0);  {set value to 0 for internal node}							InPackTree;  {deal with first descendant}							getNodeTokenC(@descP, @token, @punc, branchLengthLocal, hasBranchLength);							if hasBranchLength then hasSomeBranchLengths := true;							if punc <> chr(0) then								token := punc;							if rightparenswaslast and (token <> ',') and (token <> ')') then								begin				  {LABELLED INTERNAL NODE FOUND HERE}									getNodeTokenC(@descP, @token, @punc, branchLengthLocal, hasBranchLength);									if hasBranchLength then hasSomeBranchLengths := true;									if punc <> chr(0) then										token := punc;									lastwas := 0;								end;							rightparenswaslast := false;							if Token = ',' then  {comma; there is sister to first descendant, thus do it as right descendant}								begin									lastwas := 0;									PackRight								end							else if token = ')' then								begin									if lastwas = wastaxset then {no sister; check if monophyletic taxset}										begin											thisnode := thisnode + 1;											SetPackedNode(PackedP, thisnode, vaportaxon);										end									else										begin {no sister; parens hence next should be label for observed taxon fixed as ancestor}											thisnode := thisnode + 1;											if thisnode > onlythismany then												begin													success := false;  {treemaking stumbled; too many extra taxa}													Newerror(38, 0);													goto 1;												end;											getNodeTokenC(@descP, @token, @punc, branchLengthLocal, hasBranchLength);											if hasBranchLength then hasSomeBranchLengths := true;											if punc <> chr(0) then												token := punc;											NameOfN := FindTaxonNumber(Token);											if (nameOfN<>badTaxon) then												begin																										//DAVID:  if NameOfN is badtaxon then bail here 		{$IFC TAXSETINTREE}													if nameOfN = taxsettoken then  {can't allow taxset in here}														nameofN := badtaxon;		{$ENDC}													SetPackedNode(packedP, baseofnode, -NameOfN);  {replace name that had been 0 with name of this fixed ancestor}													thisnode := thisnode - 1;													if (NameOfN > 0) and (NameOfN <> badtaxon) then  {count if good terminal taxon had been found}														numberterminals := numberterminals + 1;													lastwas := 0;												end											else												begin													success := false;  {treemaking stumbled; shouldn't get here}													Newerror(28, 0);													lastwas := 0;												end;										end								end							else								begin									success := false;  {treemaking stumbled; shouldn't get here}									Newerror(28, 0);									lastwas := 0;								end;						end					else			{본== terminal taxon}						begin							NameOfN := FindTaxonNumber(Token);{$IFC TAXSETINTREE}{Wayne: this stuff in TAXSETINTREE is mine, you can remove}							if NameOfN = taxSetToken then								begin									MakeTaxsetBush;									if lastwas = wasleftparens then										lastwas := wastaxset									else										lastwas := 0;								end							else								begin{$ENDC}									lastwas := 0;									SetPackedNode(PackedP, thisnode, NameOfN);									if (NameOfN > 0) and (NameOfN <> badtaxon) then {count if good terminal taxon had been found}										numberterminals := numberterminals + 1;{$IFC TAXSETINTREE}								end;{$ENDC}						end;				end;  {not ';'}1:		end;  {procedure InPackTree}{..................................................................................}	begin		{StringToH('0', realBranchLengthsDataH);}		{Davidv4.1: do this for treedataH}		{BitClr(ptr(GetMaster(tH)), branchLengthStoredBit);}		rightparenswaslast := false;		hasSomeBranchLengths := false;		firstBranchLength := true;				LockHandle(TaxonCHUNKs, oldstate1);		TaxonCHUNKMaster := GetMaster(TaxonCHUNKs);		success := true;		for it := 1 to numtaxa do			getTaxonHdl(it)^^.taxonInTreeDesc := false;		numberterminals := 0;		UnLockHandle(packedH, oldstate2);		if numtaxa * 6 > nodeLimit then  {setting maximum number of nodes; allowing tree with 3 times as many terminals as in data matrix}			onlythismany := numtaxa * 6		else			onlythismany := nodeLimit;		SetHandleSize(packedH, longint(onlythismany * 2) + 12);		HLock(packedH);		packedP := pointer(GetMaster(packedH));		CHUNKpos := 0;		token := GetHToken(descH);   {skip tree name}		token := MakeCaps(GetHToken(descH));		if (token = 'STANDARD') then			repeat			until GetHToken(descH) = '='		else if (token <> '=') then			begin				NewError(29, 0);  {unknown format of tree}				success := false;			end;		oldchunkpos := chunkpos;		thisnode := 0;		LockHandle(descH, oldstate3);		descP := pointer(ord4(GetMaster(descH)) + oldCHUNKpos - 1);		if success then			begin				InPackTree;  {first, tree is built as is}				if success then					CleanUpPackedTree(packedP, thisnode, status);  {then, non-existent taxa are cleaned out, polytomies and fixanced sought, etc.}			end;		ResetHandle(descH, oldstate3);		if numberterminals < minTaxaIn then			begin				success := false;				NewError(39, 0);			end;		HUnlock(packedH);		SetHandleSize(packedH, (thisnode) * 2);  {set handle to only as big as was needed}		ResetHandle(packedH, oldstate2);		ResetHandle(TaxonChunks, oldstate1);	end;{----------------------------------------------------------------------------}	procedure DescTreeToPackTree (var descH, packH: Handle; var success: boolean; var status, numberterminals: integer; var theName: str255);		var			oldState: SignedByte;	begin{======setting up pack H; getting name======}{    CHUNKpos := SLB;}		CHUNKpos := 0;  {note that descH now has no starting bytes pasted to it}		theName := GetHToken(descH);{====== packing ======}		LockHandle(descH, oldstate);		status := 0;		PackTree(descH, packH, success, status, numberterminals);		HUnLock(descH);		SetHandleSize(descH, 0);		ResetHandle(descH, oldstate);	end;{----------------------------------------------------------------------------}{NOTE on structure of packed trees:}{Bytes 0,1: integer giving offset to start of tree description}{Byte 2:  leftmost bit set if polytomies in tree; next leftmost if fixanced}{Byte 3: unused}{Bytes 4,5:  integer giving number of legal terminal taxa in description}{Bytes 6... : name of tree;  NOTE: 6 is a constant, SLB}{Tree description begins at offset given in bytes 0, 1}{Tree description is list of two-byte integers, each referring to a node.}{0 = internal node}{nullpacked = -32768 = internal node which does not really exist }{			because collapsed for polytomy}{positive integer = number of terminal taxon; position in matrix; needs adjustment if taxa }{			added, cut or rearranged in matrix}{negative integer = number of taxon fixed to ancestral position; occupies position in}{			tree description of internal node}	procedure PackTreeLink (thechain, thelink: longint; var success: boolean);		var			descH, packinhereH: handle;			theName: str255;			status: integer;			numberterminals: integer;			descHsize, packinhereHsize: longint;	begin		descH := newHandle(0);		GetLink(theChain, thelink, descH, false);		descHSize := GetHandleSize(descH);		packinhereH := newhandle(2);		status := 0;		DescTreeToPackTree(descH, packinhereH, success, status, numberterminals, theName);		packinhereHsize := GetHandleSize(packinhereH);				ZapHandle(descH); {====== setting TreeLinkName ======}		InsertLinkStart(packinhereH, theName);		SetNumtaxaInPackedTree(packinhereH, numberterminals);		SetTreeLinkBytes(packinhereH, BitTst(@status, 0), BitTst(@status, 1));		SetLink(thechain, thelink, packinhereH);		ZapHandle(packinhereH);	end;{-----------------------------------------------------------------------------}	procedure GetTranslateTable (wastree: boolean);{processes translation table if present, or invents translation table entries if not}		var			TaxonHdl: thdl;			quitloop: boolean;			ds, tn, semi, shortname: str255;			k, labelnumber: integer;			TaxonHdlP: THdlPtr;			isnexttaxon, foundTaxon, anyFound: boolean;			dip: IP;			tname: strTaxName;			oldState1, oldState2: SignedByte;{...............}	begin		quickTranslate := true;		for k := 1 to numtaxa do			begin				taxonHdl := GetTaxonHdl(k);				TaxonHdl^^.labl := TaxonHdl^^.name;			end;		if translateTable then			begin				anyFound := false;				next := nextdarkchar;				quitloop := false;				labelnumber := 1;{||||||||||||||||||||||||}				repeat					ds := GetFileToken(maxtok);			{left hand column - taxon label as it appears in tree description}					if ds = ';' then						leave;					tn := GetFileToken(maxtok);			{right hand column - taxon name}					FixTaxCharName(tn, false,0);					if tn = ';' then						leave;					semi := GetFileToken(maxtok);  	 {a comma or semicolon}					if semi = ';' then						quitloop := true;					if quicktranslate then						begin							tname := taxonHdl^^.name;							isnexttaxon := StringsEqual(@Tname, @tn, tnw);						end					else						isnexttaxon := false;					foundTaxon := false;					if isnexttaxon then						begin							TaxonHdl^^.labl := ds;							foundTaxon := true;						end					else						begin							LockHandle(TaxonChunks, oldstate1);							TaxonHdlP := THdlPtr(GetMaster(TaxonCHUNKs));							for k := 1 to numtaxa do								begin									TaxonHdl := TaxonHdlP^;									LockHandle(TaxonHdl, oldstate2);									if StringsEqual(@TaxonHdl^^.name, @tn, tnw) then										begin											TaxonHdl^^.labl := ds;											foundTaxon := true;											ResetHandle(TaxonHdl, oldstate2);											if k <> labelnumber then												quicktranslate := false;											leave;										end									else										ResetHandle(TaxonHdl, oldstate2);									TaxonHdlP := THdlPtr(ord4(taxonHdlP) + Hdlsize);								end;							ResetHandle(TaxonChunks, oldstate1);						end;					if not foundTaxon then						NewError(116, 0)					else						anyFound := true;					labelnumber := labelnumber + 1;				until quitloop | (fpos >= mcFileLength) | errorFlag;{||||||||||||||||||||||||}				if not anyFound then					begin						NewError(394, 0);						errorFlag := true;					end;			end;	end;{-----------------------------------------------------------------------------}	procedure UnderLineTaxonNames(addUnderline: boolean);	var it: integer;		TaxonHdl: thdl;		oldState: SignedByte;		ds: str255;	begin		for it := 1 to numtaxa do			begin				taxonHdl := gettaxonHdl(it);				LockHandle(TaxonHdl, oldstate);				ds := taxonHdl^^.name;				if addunderline then					begin						ds := CopyString(ds, 1, tnw);						BlanksToUnderLine(ds);					end				else					UnderLineToBlanks(ds);				taxonHdl^^.name := ds;				ResetHandle(TaxonHdl, oldstate);			end;	end;{-----------------------------------------------------------------------------}	procedure ReadTreeBlock (theNexusBlock: NexusBlockPtr; addToExistingTrees: boolean; firstCommand: str255);{note that this procedure assumes that one has already skipped past the}{semicolon after BEGIN TREES}		label			1, 2;		var			success, expectedtoken: boolean;			theDialog: DialogPtr;			tempP: WindowPtr;			ds, foreignDS, command, upperCaseCommand: str255;			wastree, foreigntrees: boolean;			olduserlinks, currenttree: longint;			oldState: SignedByte;			whichText: integer;	begin		quickTranslate := false;{put underlines in to speed up FindTaxonNumbers}		UnderLineTaxonNames(true);		foreigntrees := false;		commreadon := true;		SetCursID(tree);		if treechain = treefilechain then			begin				EmptyForeignBlockText(treefileblock);				treesblock := treefileblock;				whichText := aboutTreeFileText;			end		else			begin				treesblock := treesDataBlock;				whichText := aboutTreesText;			end;		if infoOpen[treeinfo] then			InvalidateWindow(infowindow[treeinfo], true);		curTextH := textWindowInfo[whichText]^.H;		if not addToExistingTrees then  {v3.05}			begin				DefaultLink[treeChain] := -1;				UserLinks[treeChain] := 0;			end;		translateTable := false;		command := firstCommand;		upperCaseCommand := MakeCaps(command);		foreignDS := command;		expectedtoken := (upperCaseCommand = 'TRANSLATE') or (upperCaseCommand = 'TREE') or EndOfBlock(upperCaseCommand) or (upperCaseCommand = 'UTREE');		if EndOfBlock(upperCaseCommand) then		{nothing there!!!}			goto 2;		wastree := (upperCaseCommand = 'TREE') or (upperCaseCommand = 'UTREE');		translateTable := (upperCaseCommand = 'TRANSLATE');		GetTranslateTable(wastree);		if wastree then			upperCaseCommand := 'TREE'		else if not expectedtoken then			begin				foreignDS := concat(command, chr(9));				ReadForeignLine(treesblock, foreignDS);				NextTokenPastSemi(command);				upperCaseCommand := MakeCaps(command);				foreigntrees := true;			end		else			begin				foreignDS := concat(command, chr(9));				next := ';';				NextTokenPastSemi(command);				upperCaseCommand := MakeCaps(command);			end;		currenttree := 1;				if treefile then			begin				DisableWindowUpdates(infowindow[treeinfo]);				if endreadtree < 0 then					StartThermo(theDialog, tempP, 0, mcFileLength, 'Reading Trees from File', 'percent', true)				else					StartThermo(theDialog, tempP, startreadtree, endreadtree, 'Reading Trees from File', 'trees', false);			end;		SetCursID(tree);		while not EndOfBlock(upperCaseCommand) & (fpos < mcFileLength) & ((endreadtree < 0) | (currenttree <= endreadtree)) & not badmemory do			begin				if (upperCaseCommand = 'TREE') | (upperCaseCommand = 'UTREE') then					begin						if treefile then							if endreadtree < 0 then								UpdateThermo(theDialog, 0, fpos, mcFileLength,true)							else								UpdateThermo(theDialog, startreadtree, currenttree, endreadtree,false)						else							UpdateThermo(iothermo, 0, fpos, mcFileLength,true);						if abortedThermo then							errorflag := true;						if errorflag then							goto 1;						if (currenttree >= startreadtree) and ((endreadtree < 0) or (currenttree <= endreadtree)) then							begin								olduserLinks := UserLinks[treeChain];								ReadstrCHUNK(treeChain);								if olduserLinks < UserLinks[treechain] then  {it's not foreign}									begin										PackTreeLink(treechain, EndUserLink(treechain), success);										if not success then											RemoveLink(treechain, EndUserLink(treechain));									end;							end;						NextTokenPastSemi(command);						upperCaseCommand := MakeCaps(command);						currenttree := currenttree + 1;					end				else if upperCaseCommand = ';' then					begin						command := GetFileToken(maxtok);						upperCaseCommand := MakeCaps(command);					end				else if not EndOfBlock(upperCaseCommand) then{v3.05: not EndOfBlock added}					begin						foreignDS := concat(command, chr(9));						ReadForeignLine(treesblock, foreignDS);						NextTokenPastSemi(command);						upperCaseCommand := MakeCaps(command);						foreigntrees := true;					end;			end;		if EndOfBlock(upperCaseCommand) then			Skipper(punctuation, true)		else if (endreadtree < 0) & FindEndOfBlock(treesblock, true) then  {don't need to FindEndOfBlock if reading only part of file}			Skipper(punctuation, true);1:		if treefile then			EndThermo(theDialog, tempP, false);2:		if (currenttree <= startreadtree) & (endreadtree > 0) then  {v3.05: endreadtree>0}			begin				NewError(342, 0);				errorflag := true;			end		else if (UserLinks[treeChain] = 0) and not foreigntrees and not errorflag then			begin				InstantError(299);			end;		SetControlMaximumLong(tlegScroll, UserLinks[treechain]);		LockHandle(textWindowInfo[whichText]^.H,oldState);		TESetText(textWindowInfo[whichText]^.H^, GetHandleSize(textWindowInfo[whichText]^.H), textWindowInfo[whichText]^.TE);		ResetHandle(textWindowInfo[whichText]^.H,oldState);		TECalText(textWindowInfo[whichText]^.TE);		curTextH := textWindowInfo[whichText]^.H;		commreadon := false;{take the underlines back out}		UnderLineTaxonNames(false);	end;{----------------------------------------------------------------------------}	procedure ReadForeignTrees (filetype: integer; firsttoken: str255);		var			TaxonHdl: thdl;			ds, lasttoken, thistoken: str255;			k, nn: integer;			thisCHUNK: longint;			c, lastc, nextc: char;			dh: handle;			dl, cpos, nextpos, startpos, endpos, oldpos: longint;			atend, success, db: boolean;			cp: Ptr;			H: handle;			theDialog: DialogPtr;			tempP: Windowptr;			tname: strTaxName;			currenttree: longint;			dhp: HdlPtr;			oldpunct: set of char;			oldState1, oldState2: SignedByte;	begin		quickTranslate := false;		if treefile then			begin				DisableWindowUpdates(infowindow[treeinfo]);				if endreadtree < 0 then					StartThermo(theDialog, tempP, 0, mcFileLength, 'Reading Trees from File', 'percent', true)				else					StartThermo(theDialog, tempP, startreadtree, endreadtree, 'Reading Trees from File', 'trees', false);			end;		H := NewHandle(2);		DefaultLink[treeChain] := -1;		UserLinks[treeChain] := 0;		if filetype = hennig then			for k := 1 to numtaxa do				begin					taxonHdl := GetTaxonHdl(k);{    tname := StringFromNum(k - 1);}					ds := TaxonHdl^^.name;					BlanksToUnderline(ds);					TaxonHdl^^.labl := ds;				end		else if filetype = phylip then			for k := 1 to numtaxa do				begin					taxonHdl := GetTaxonHdl(k);					ds := TaxonHdl^^.name;					BlanksToUnderline(ds);					tname := CopyString(ds, 1, 10);					TaxonHdl^^.labl := tname;				end;		if firsttoken = '(' then			c := '('		else			c := nextdarkchar;		startpos := fpos;		if c = '''' then   {skip over any quotes - from Hennig86}			repeat				c := nextdarkchar;				cpos := fpos;			until c = '''';		nextc := nextdarkchar;		oldpunct := punctuation;		punctuation := ['(', ')', ',', ';'];		if filetype = hennig then			punctuation := punctuation + ['*'];		nextpos := fpos;		atend := false;		currenttree := 1;{=======================}		while not atend do			begin				if treefile then					if endreadtree < 0 then						UpdateThermo(theDialog, 0, fpos, mcFileLength, true)					else						UpdateThermo(theDialog, startreadtree, currenttree, endreadtree, false)				else					UpdateThermo(iothermo, 0, fpos, mcFileLength,true);				if UserLinks[treechain] > 0 then					startpos := fpos;				if (currenttree = 1) and (startreadtree > 1) then					begin						repeat							if filetype = hennig then								db := FindRawFileChar('*', false)							else								db := FindRawFileChar(';', false);							currenttree := currenttree + 1;						until currenttree = startreadtree;						if fpos < mcFileLength then							next := nextchar;					end;				if fpos >= mcFileLength then					leave;				lasttoken := GetFileToken(maxtok);				thistoken := lasttoken;				AddCHUNKs(strCHUNKs[treeChain], 1, SLB);				if badmemory then					Exit(ReadForeignTrees)				else					UserLinks[treeChain] := UserLinks[treeChain] + 1;				thisCHUNK := LinksInChain(treeChain);				LockHandle(strCHUNKs[treeChain], oldstate1);				dhp := HdlPtr(GetMaster(strCHUNKs[treeChain]) + HdlSize * ord4(thisCHUNK - 1));				dh := dhp^;				NumToString(UserLinks[treeChain] + startreadtree - 1, ds);				if filetype = hennig then					ds := concat('      tree_', ds, ' = ')				else if filetype = phylip then					ds := concat('      PHYLIP_', ds, ' = ');				ReplaceHandleContentsWithString(dh, ds);{=========== hennig ============}				if filetype = hennig then					begin						AppendToHandle(dh, thistoken);						repeat							thistoken := GetFileToken(maxtok);							if Thistoken = '*' then								AppendToHandle(dh, ';')							else if thistoken = ')' then								AppendToHandle(dh, ')')							else								begin									if lasttoken <> '(' then										AppendToHandle(dh, ',');									if (thistoken = '(') or (thistoken = ';') then										Appendtohandle(dh, thistoken)									else										begin											nn := tokentointeger(thistoken, false);											if (nn > 0) | (thistoken = '0') then												begin													AppendToHandle(dh, stringfromnum(nn + 1));												end											else												AppendToHandle(dh, thistoken);										end;								end;							lasttoken := thistoken;						until (thistoken = '*') or (thistoken = ';') or (fpos >= mcFileLength);{if fpos <= mcFileLength then c := nextdarkchar; skip this char}					end{=========== phylip ============}				else if filetype = phylip then					begin						repeat							next := nextdarkchar;						until (next = ';') or (fpos >= mcFileLength);						endpos := fpos + 1;						next := nextchar;						FilePiecetoH(startpos, endpos, H);						LockHandle(H, oldstate2);						if HandAndHand(H, dh) <> NoErr then							Beep;						ResetHandle(H, oldstate2);						Skipper([chr(13), chr(10)], false);					end;				ResetHandle(strCHUNKs[treeChain], oldstate1);				PackTreeLink(treechain, EndUserLink(treechain), success);				if not success then					RemoveLink(treechain, EndUserLink(treechain));				currenttree := currenttree + 1;				if (thistoken = ';') or (fpos >= mcFileLength) or ((endreadtree > -1) and (currenttree > endreadtree)) then					atend := true;			end;{=======================}		punctuation := oldpunct;		if UserLinks[treeChain] = 0 then			InstantError(300);		SetControlMaximumLong(tlegScroll, UserLinks[treechain]);		ZapHandle(H);		if treefile then			EndThermo(theDialog, tempP, false);	end;{----------------------------------------------------------------------------}	procedure StartNewTreeFile;	begin		if charton & ((CWChart = CWCC2T) | (CWTrees[CWChart] = CWStoredTrees)) then			if CWarning('Starting a new tree file will force the chart to close.', 'Continue', 'Cancel') then				PleaseOffChart := true			else				Exit(StartNewTreeFile);		if infoEditing[treeinfo] then			TurnOffInfoEditing(treeinfo);		treeFileLastModified := 0;		treefile := true;		treefilename^^ := 'Untitled';		treeChain := treefileChain;		treefileSaved := false;		UserLinks[treeChain] := 0;		SetDirtyTree;		if treeopen then			InvalidateWindow(tlegwindow, false);		InvalidateInfoWindow(treeinfo);		CloseTextWindowIfOpen(aboutTreesText, true);	end;{----------------------------------------------------------------------------}	procedure InitTreefile (treeFileSpec: FSSpec);	begin		treeChain := treefileChain;		treefile := true;	end;{----------------------------------------------------------------------------}	var		treefiletype: integer;{----------------------------------------------------------------------------}	procedure ReadTreeFile (treeFileSpec: FSSpec);		var			ds: str255;			theDialog: DialogPtr;			tempP: WindowPtr;			localItemHit: integer;	begin		readon := true;		FDI^[readFileFDI].fs := treeFileSpec;		FDI^[treeFileFDI].fs := treeFileSpec;		fpos := kInitialReadPos;		next := nextchar;		if next in whitespace then			next := nextdarkchar;		if next = '(' then			ds := '('		else			ds := MakeCaps(GetFileToken(maxtok));		if (ds = 'TREAD') then			begin				treefilename^^ := 'Untitled';				InitTreeFile(treeFileSpec);				treefileSaved := false;				ReadForeignTrees(hennig, ds);				treefiletype := hennig;			end		else if (ds = '#NEXUS') then			begin				treefiletype := macclade;				treefilename^^ := treeFileSpec.name;				InitTreeFile(treeFileSpec);				treefileSaved := true;				OpenAsUntitled := false;				treeFileLastModified := FspLastModified(treeFileSpec);				SetHandleSize(textWindowInfo[AboutTreeFileText]^.H, 0);				if FindFileToken('BEGIN', true) then					if MakeCaps(GetFileToken(maxtok)) = 'TREES' then						begin							Skipper([';'], true);							commreadon := true;							curTextH := textWindowInfo[aboutTreeFileText]^.H;							ReadTreeBlock(nil,false,GetFileToken(maxTok));						end					else						begin  			 {foreign block at start of file}							openasUntitled := true;							repeat								if FindEndOfBlock(treesBlock,false) & FindFileToken('BEGIN', false) then									ds := MakeCaps(GetFileToken(maxtok));							until (ds = 'TREES') or (fpos >= mcFileLength);							if (ds = 'TREES') then								begin									Skipper([';'], true);									commreadon := true;									curTextH := textWindowInfo[aboutTreeFileText]^.H;									ReadTreeBlock(nil,false,GetFileToken(maxTok));									InstantError(169);								end							else								begin									InstantError(144);									errorflag := true;								end;						end				else					begin						InstantError(144);						errorflag := true;					end;				if ErrorPosted(394) then					begin						RemoveError(116);						RemoveError(169);						RemoveError(342);					end;			end		else			begin				StartDLOG(365, theDialog, tempP);				myShowDialog(theDialog);				Beep;				repeat					ModalDialog(nil, localItemHit);				until localItemHit in [2, 3, 4];				EndDLOG(theDialog, tempP);				if localItemHit <> 2 then					begin						treefilename^^ := 'Untitled';						InitTreeFile(treeFileSpec);						treefileSaved := false;					end;				case localItemHit of					2:	{cancel}						errorflag := true;					3: 	{Hennig86}						begin							if FindFileToken('TREAD', true) then								ReadForeignTrees(hennig, 'TREAD');							treefiletype := hennig;						end;					4: 	{PHYLIP}						begin							ReadForeignTrees(phylip, ds);							treefiletype := phylip;						end;					otherwise						;				end;			end;		readon := false;	end;{----------------------------------------------------------------------------}	function MyTreeFileHook7 (localItemHit: integer; theDialog: DialogPtr; mydataPtr: Ptr): integer;	begin		if localItemHit = sys7NewButton then			begin				TreeFileOptions;				MyTreeFileHook7 := NotInDialog;			end		else			begin				if not initGetButtons then					SetButtonTitle(theDialog, sys7NewButton, 'Options');				initGetButtons := true;				MyTreeFileHook7 := localItemHit;			end;	end;{----------------------------------------------------------------------------}	function MyTreeFileHook (localItemHit: integer; theDialog: DialogPtr): integer;	begin		if localItemHit = sys6NewButton then			begin				TreeFileOptions;				MyTreeFileHook := NotInDialog;			end		else			begin				if not initGetButtons then					SetButtonTitle(theDialog, sys6NewButton, 'Options');				initGetButtons := true;				MyTreeFileHook := localItemHit;			end;	end;{----------------------------------------------------------------------------}	procedure GetTreeFile;		var			typeList: SFTypeList;			theFile: str255;    		UPP: UniversalProcPtr;    		tempFileSpec: FSSpec;			turnoffchart: boolean;	begin		typeList[0] := 'TEXT';		startreadtree := 1;		endreadtree := -1;		fileIsStationery := false;{$IFC NOT CARBON}		UPP := MyNewDlgHookYDUPP(@MyTreeFileHook7);  {$ELSEC}		UPP := nil;{$ENDC}		if ChooseFile(1, @typeList, UPP, theFile, tempFileSpec,false,false,true) then			begin				TurnOffInfoEditing(treeinfo);				if treefile then					DeleteCHUNKs(strCHUNKs[treeChain], StartUserLink(treechain) + 1, UserLinks[treechain]);				if theFile = filename^^ then					begin						if CloseTreeFile('switching to data file?') then							DeSelectAllInfo(treeinfo);					end				else					begin						if charton & (CWChart = CWCC2T) then							if CWarning('Opening a tree file will force the chart to close.', 'Continue', 'Cancel') then								PleaseOffChart := true							else								Exit(GetTreeFile);						treeFileLastModified := FSpLastModified(tempFileSpec);						FDI^[readFileFDI].fs := tempFileSpec;						fileIsStationery := FSpIsStationeryFile(tempFileSpec);						ReadTreeFile(tempFileSpec);						dirtytreefile := false;						if UserLinks[treechain] > 0 then							linknumber[treechain] := StartUserLink(treechain)						else							linknumber[treechain] := 0;						if treeopen then							begin								SetDirtyTree;								InvalidateWindow(tlegwindow, false);							end;						if fileIsStationery or (endreadtree >= 1) then  {v4: actually see if partial file read in}							begin								OpenAsUntitled := true;								if (endreadtree >= 1) then  {v4: actually see if partial file read in}									begin										dirtytreefile := true;										NewError(330, 0);									end;							end;						if not OpenAsUntitled and not errorflag and (treefiletype = macclade) then							if FindFileToken('BEGIN', false) then   {there is a foreign block after trees block}								begin									OpenAsUntitled := true;									InstantError(169);								end;						if OpenAsUntitled then							begin								iofilename^^ := 'Untitled';								treefileSaved := false;							end;						CloseTextWindowIfOpen(aboutTreesText, true);					end;			end		else			Errorflag := true;{$IFC NOT CARBON}		MyDisposeDlgHookYDUPP(UPP);{$ENDC}	end;{-----------------------------------------------------------------------------}	function StartFileTrees (j: integer; var ds: str255; var oldtreechain: integer; var packH: Handle): boolean;{tree file initialization routine if trees to be processed come from an unopened, external treefile}{note that these files must be NEXUS files;  they cannot be Hennig86 or PHYLIP files: note in Manual!!!}		var			wastree: boolean;			command: str255;	begin		oldtreechain := treechain;		UnderLineTaxonNames(true);		ZapHandle(packH);		packH := NewHandle(0);{W//}		treechain := extratreechain;		StartFileTrees := false;		if j = 1 then 		    FDI^[readFileFDI].fs := FDI^[extraTreeFile1FDI].fs		  else 		    FDI^[readFileFDI].fs := FDI^[extraTreeFile2FDI].fs;		fpos := kInitialReadPos;		translateTable := false;		if MakeCaps(GetFileToken(maxtok)) = '#NEXUS' then			if FindFileToken('TREES', true) then				begin					repeat						ds := MakeCaps(GetFileToken(maxtok));					until (ds = 'TRANSLATE') or (ds = 'TREE') or (ds = 'UTREE') or (fpos >= mcFileLength);					wastree := (ds = 'TREE') or (ds = 'UTREE');					translateTable := (ds = 'TRANSLATE');					GetTranslateTable(wastree);					if wastree then						ds := 'TREE'					else						begin							next := ';';							NextTokenPastSemi(command);							ds := MakeCaps(command);						end;					StartFileTrees := true;				end			else				InstantError(144)		else if errorFlag then   {must have been problem reading file}			NewError(117, 0)		else			InstantError(188);	end;{-----------------------------------------------------------------------------}	procedure EndFileTrees (oldtreechain: integer; var packH: Handle);	begin		UnderLineTaxonNames(false);		ZapHandle(packH);		treechain := oldtreechain;		packH := nil;   {put here so easier to pick up errors}	end;{-----------------------------------------------------------------------------}	function GetFileTree (var ds: str255; var packH: Handle; var numtrees: longint): boolean;		var			status, db: boolean;			descH: Handle;			ds2,command: str255;			dL: longint;			fixpolystatus: integer;			currenttree: longint;			numterminals: integer;	begin		GetfileTree := false;		if (ds = 'TREE') or (ds = 'UTREE') then			begin				if numTrees = 0 then {we're getting the first tree}					if startreadtree > 1 then						begin							currenttree := 1;							repeat								NextTokenPastSemi(command);								ds := MakeCaps(command);								currenttree := currenttree + 1;{what if not a TREE or UTREE?}							until currenttree = startreadtree;						end;				descH := NewHandle(0);				SetHandleSize(packH,2);				LineToH(descH);				db := AsteriskPresent(descH);				ds2 := '  ';{    dL := Munger(descH, 0, @ds2, 0, Pointer(ord(@ds2) + 1), SLB); } {set starting bytes}				fixpolystatus := 0;				DescTreeToPackTree(descH, packH, status, fixpolystatus, numterminals, ds2);				if status then					getfiletree := true;				InsertLinkStart(packH, ds2);				SetNumtaxaInPackedTree(packH, numterminals);				SetTreeLinkBytes(packH, BitTst(@fixpolystatus, 0), BitTst(@fixpolystatus, 1));				NextTokenPastSemi(command);				ds := MakeCaps(command);				ZapHandle(descH);			end		else if ds = ';' then			ds := MakeCaps(GetFileToken(maxtok))		else			Skipper(punctuation, true);	end;end.