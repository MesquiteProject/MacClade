unit SetLibInterface;interface	uses		quickdraw, Types, Events, QuickDrawText, OSUtils, TextUtils, Windows, Sound, Dialogs, TextEdit, Lists, ToolUtils, Memory, Fonts, Resources, Scrap, 		Globals;{===The following are general utilities in SetLib.a.o, which will be used more and more later}{Most concern the new lgsetchars type}	procedure SetStateSetBoundaries (smallest: boolean); {$SETC NEWSETS=FALSE}	function Union2 (s1, s2: lgsetchars): lgsetchars;	function Union3 (s1, s2, s3: lgsetchars): lgsetchars;	function UnordOperator2 (s1, s2: lgsetchars): lgsetchars;	function UnordOperator3 (s1, s2, s3: lgsetchars): lgsetchars;	function Intersect2 (s1, s2: lgsetchars): lgsetchars;	function Intersect3 (s1, s2, s3: lgsetchars): lgsetchars;	function Un3ofInt2 (s1, s2, s3: lgsetchars): lgsetchars;	function SubtractSets (s1, s2: lgsetchars): lgsetchars;	function MakeSet (i1: longint): lgsetchars;	function MakeSpan (i1, i2: longint): lgsetchars;	function StateInSet (s: longint; s1: largestSetChars): boolean;	function EmptySet (s1: largestSetChars): boolean;	function EqualSets (s1, s2: largestSetChars): boolean;{$IFC NEWSETS}   	function AddToSet (s1: lgsetchars; i1: longint): lgsetchars;  {**}	function SubtractFromSet (s1: lgsetchars; i1: longint): lgsetchars;  {**}	function EnSet (i1: longint; s1: DiscreteSet): boolean;  {**}	procedure ZeroHighBitsLg (var s: largestsetchars);  {**}	procedure set15to31 (sp15, sp31: ptr);  {**}	procedure set31to15 (sp31, sp15: ptr);  {**}	{$ELSEC}	function AddToSet (s1: lgsetchars; i1: longint): lgsetchars;	function SubtractFromSet (s1: lgsetchars; i1: longint): lgsetchars;	function EnSet (i1: longint; s1: lgsetchars): boolean;	function ZeroHighBitsLg (s: largestsetchars): largestsetchars; {NEWW: changed to function}//	function Set15to31G (inset: integer): lgsetchars;  {v4:  change integer to smsetchars}//	function Set31to15S (inset: lgsetchars): integer;		function set15to31 (inset: integer): setchars31;	function set31to15 (inset: lgsetchars): integer;	function set15to31P (sp15: ptr): setchars31;	{$ENDC}		function MinG (s1: lgsetchars): longint;  {**}	function MaxG (s1: lgsetchars): longint;  {**}	function CardG (s1: lgsetchars): longint;  {**}	function CardLg (s: largestsetchars): longint; {본본}	function MonomorphG (s: lgsetchars): boolean;	function MultipleStatesG (s: lgsetchars): boolean;	function SetfromMin (s1: lgsetchars): lgsetchars;	function OldSetFromNew (s1: lgsetchars): largestsetchars;	function NewSetFromOld (s1: largestsetchars): lgsetchars;		function MinP (s: ptr; slength: longint): longint;	function MaxP (s: ptr; slength: longint): longint;	function CardP (s: ptr; slength: longint): longint;	function MinLg (s: largestsetchars): longint; {본본}	function MaxLg (s: largestsetchars): longint; {본본}	procedure MaxMinLg (s: largestsetchars; var mins, maxs: INTEGER); {본본}	function CardFrom (sptr: ptr; length: longint): longint;	function MonomorphLg (s: largestsetchars): boolean; {returns true if cardlg(s)=1}{본본}	function MultipleStatesLg (s: largestsetchars): boolean; {본본}implementation	procedure SetStateSetBoundaries (smallest: boolean); 	external; {in C}	function Union2 (s1, s2: lgsetchars): lgsetchars;	external; {in C}	function Union3 (s1, s2, s3: lgsetchars): lgsetchars;	external; {in C}	function UnordOperator2 (s1, s2: lgsetchars): lgsetchars;	external; {in C}	function UnordOperator3 (s1, s2, s3: lgsetchars): lgsetchars;	external; {in C}	function Intersect2 (s1, s2: lgsetchars): lgsetchars;	external; {in C}	function Intersect3 (s1, s2, s3: lgsetchars): lgsetchars;	external; {in C}	function Un3ofInt2 (s1, s2, s3: lgsetchars): lgsetchars;	external; {in C}	function SubtractSets (s1, s2: lgsetchars): lgsetchars;	external; {in C}	function MakeSet (i1: longint): lgsetchars;	external; {in C}	function MakeSpan (i1, i2: longint): lgsetchars;	{Note: assumes i2>i1}	external; {in C}	function SetfromMin (s1: lgsetchars): lgsetchars;	external; {in C}	function StateInSet (s: longint; s1: largestSetChars): boolean;	external; {in C}	function EmptySet (s1: largestSetChars): boolean;	external; {in C}	function EqualSets (s1, s2: largestSetChars): boolean;	external; {in C}{$IFC NEWSETS}	function AddToSet (s1: lgsetchars; i1: longint): lgsetchars;	external; {in C}	function SubtractfromSet (s1: lgsetchars; i1: longint): lgsetchars;	external; {in C}	function EnSet (i1: longint; s1: DiscreteSet): boolean;	external; {in C}{$ELSEC}	function AddToSet (s1: lgsetchars; i1: longint): lgsetchars;	External;	function SubtractfromSet (s1: lgsetchars; i1: longint): lgsetchars;	External;	function EnSet (i1: longint; s1: lgsetchars): boolean;	External;{$ENDC}	function MinG (s1: lgsetchars): longint;	external; {in C}	function MaxG (s1: lgsetchars): longint;	external; {in C}	function CardG (s1: lgsetchars): longint;	external; {in C}	function CardLg (s: largestsetchars): longint;	external;{본본본note: ptr to set to avoid problems passing set to C} {in C}	function MinP (s: ptr; slength: longint): longint;	external;{in C}	function MaxP (s: ptr; slength: longint): longint;	external;{in C}	function MinLg (s: largestsetchars): longint;	external; {본본본note: ptr to set to avoid problems passing set to C} {in C}	function MaxLg (s: largestsetchars): longint;	external; {본본본note: ptr to set to avoid problems passing set to C} {in C}	procedure MaxMinLg (stset: largestsetchars; var mins, maxs: INTEGER);	external;{note: ptr to set to avoid problems passing set to C} {in C}	function CardP (s: ptr; slength: longint): longint;	external;	function CardFrom (sptr: ptr; length: longint): longint;	external;	function MonomorphG (s: lgsetchars): boolean; {returns true if cardlg(s)=1}	external;{in C}	function MonomorphLg (s: largestsetchars): boolean; {returns true if cardlg(s)=1}	external;{본본본note: ptr to set to avoid problems passing set to C} {in C}	function MultipleStatesG (s: lgsetchars): boolean;	external;{in C}	function MultipleStatesLg (s: largestsetchars): boolean;	external;{본본본note: ptr to set to avoid problems passing set to C}{$IFC NEWSETS}	procedure ZeroHighBitsLg (var s: largestsetchars);	external;  {in C}	procedure set15to31 (sp15, sp31: ptr);	external;	procedure set31to15 (sp31, sp15: ptr);	external;{$ELSEC}	//function Set15to31G (inset: integer): lgsetchars;  {v4: change integer to smsetchars}	//begin	{Wayne: v3.5 DELETE}	//end;	//function Set31to15S (inset: lgsetchars): integer;	{Wayne: v3.5 NOT USED ANYWHERE}	//External;{-----------------------------------------------------------------------------}	procedure ZeroHighBits31 (sp : ptr);	external;{-----------------------------------------------------------------------------}	function ZeroHighBitsLg (s: largestsetchars): largestsetchars; {admestina}		var temp: largestSetChars;	begin		temp := s;		ZeroHighBits31(@temp);		ZeroHighBitsLg := temp;{zeros high bits which only contain info re footnotes, uncertainty, etc.}	end;{-----------------------------------------------------------------------------}{-----------------------------------------------------------------------------}	function set15to31C (sp15: ptr): lgsetchars;{ admestina}	external;{-----------------------------------------------------------------------------}	function set15to31P (sp15: ptr): setchars31;{ admestina}	begin{writeln('set15to31P ', longint(set15to31C(sp15)));}		set15to31P := OldSetFromNew(set15to31C(sp15));	end;{-----------------------------------------------------------------------------}	function set15to31 (inset: integer): setchars31;{ Wayne: v3.5 use C procedures here}{	external;}var temp: integer; {admestina}begin 	temp := inset;	set15to31 := set15to31P(@temp);end;{-----------------------------------------------------------------------------}	function set31to15C (sp31: ptr): integer;{ admestina}	external;{-----------------------------------------------------------------------------}	function set31to15P (sp31: ptr): integer;{ admestina}	begin		set31to15P := set31to15C(sp31);	end;{------------------------------------------}	function set31to15 (inset: lgsetchars): integer;{Wayne: v3.5 use C procedures here??}	var temp: lgsetchars;begin 	temp := inset;	set31to15 := set31to15P(@temp);{	set31to15 := (setpointer15(@inset)^) * [10..15] + (setpointer15(ord4(@inset) + 2)^) * [0..9];}end;{$ENDC}	function OldSetFromNew (s1: lgsetchars): largestsetchars;	begin		OldSetFromNew := largestsetchars(s1);	end;	function NewSetFromOld (s1: largestsetchars): lgsetchars;	begin		NewSetFromOld := lgsetchars(s1);	end;{-------------------------------------------}end.