unit EditUtilMenu;{ееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, 		TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  SetLibInterface, UtilLibInterface,  MemoryUtil,		CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, TaxonCHUtil, BoxUtil,		TraceMenu, ClickInInfoWindow, ReadWriteUtil, ReadUtil, SymbolsNames, TypeUtil, WriteUtil, 		Thermos, CHUNK, CharUtil, MenuUtil, Footnote, SpreadUtil, PICT, GeneticCode, DrawSpread, 		Fill, ScrollSpread, RowColumn, CopyPaste, EditControl, Windows, ChartWindow, Recode, Speak,		ImportAlignment, AutoAlign;	procedure DoReplaceAllMenu(Event: EventRecord; ItemNo: integer);	procedure DoFindMenu (ItemNo: integer);	procedure DoMismatchMenu (ItemNo: integer);	procedure DoEdUtilitiesMenu (ItemNo: Integer);{ееееееееееееееееееееее}implementation {е$S EditUtilMenu}{-----------------------------------------------------------------------------}	procedure FindSequence(next,validateWindow: boolean);	label 1;	var ic: integer;		 it: integer;		 similarP, originalP: Ptr;		 oldstate1,oldstate2: SignedByte;		 taxStsH: Handle;		 st, et, sc, ec: integer;		 sequenceFound: boolean;		 firsticstart,icstart,itstart,itend,icend: integer;		 TL,BR: point;	begin		if editorOpen & (EWFindSequenceBlockP^.ntax+EWFindSequenceBlockP^.nchar>0) then			begin				sequenceFound := false;				icstart := 1;				icend := numchars;				if not editorSelected then					begin						if not next then 							begin								Beep;								Exit(FindSequence);							end;						st:= 1;						et:=  1;						sc := 0;						ec := 0;					end				else					CalcSelectedTaxaCharacters(st, et, sc, ec, true);				if next then 					begin						itstart:=et;						itend := numtaxa;						if (ec<=0) then  {this is what you get if you have selected a taxon name}							firsticstart := 1 						else							firsticstart := sc+1;						icend := numchars;						if firsticstart > numchars then							begin								firsticstart := 1;								itstart := itstart+1;								if itstart > numtaxa then									begin										Beep;										Exit(FindSequence);									end;							end;					end				else					begin						itstart:=st;						itend := 1;						firsticstart := sc-1;						icend := 1;						if firsticstart < 1 then							begin								firsticstart := numchars;								itstart := itstart-1;								if itstart < 1 then									begin										Beep;										Exit(FindSequence);									end;							end;					end;				LockHandle(EWFindSequenceBlockP^.H, oldstate1);				similarP := Ptr(GetMaster(EWFindSequenceBlockP^.H));				if next then					for it := itstart to itend do						begin							taxStsH:= GetTaxStsHdl(it);							LockHandle(taxStsH, oldstate2);							if itstart= it then								icstart := firsticstart							else 								icstart := 1;							for ic := icstart to numchars do								begin									originalP:=GetSetPtr(it,ic);									if ComparePointers (nil, findSequenceMatchMustBeExact, findSequenceRespectCase&nucleotides, false, EWFindSequenceBlockP^.blockNumBytes,similarP,originalP,EWFindSequenceBlockP^.nchar,findNumMismatches) then										begin											sequenceFound := true;											goto 1;										end;								end;							ResetHandle(taxStsH, oldstate2);						end				else					for it := itstart  downto itend do						begin							taxStsH:= GetTaxStsHdl(it);							LockHandle(taxStsH, oldstate2);							if itstart= it then								icstart := firsticstart							else 								icstart := numchars;							for ic := icstart downto icend do								begin									originalP:=GetSetPtr(it,ic);									if ComparePointers (nil, findSequenceMatchMustBeExact, findSequenceRespectCase&nucleotides, false, EWFindSequenceBlockP^.blockNumBytes,similarP,originalP,EWFindSequenceBlockP^.nchar,findNumMismatches) then										begin											sequenceFound := true;											goto 1;										end;								end;							ResetHandle(taxStsH, oldstate2);						end;1:				ResetHandle(EWFindSequenceBlockP^.H, oldstate1);				if sequenceFound then					begin						RowColumnFromTaxonCharacter(it,ic,TL.v,TL.h);						RowColumnFromTaxonCharacter(it,ic+EWFindSequenceBlockP^.nchar-1,BR.v,BR.h);						ResetHandle(taxStsH, oldstate2);						CleanOldCell(editorSelectionTopLeft, editorSelectionBotRight);						if badcellEntry then							Exit(FindSequence);						editorSelectionTopLeft:= TL;						editorSelectionBotRight:= BR;						FixNewCell(editorSelectionTopLeft, editorSelectionTopLeft);						if SingleCell then								SetUpCellEdit;						DrawDataCellsBetweenCorners(editorSelectionTopLeft,editorSelectionBotRight,selectionModeAsIs);						ScrollToSelection(false,validateWindow);					end				else					Beep;							end;	end;{----------------------------------------------------------------------------}	procedure SetFindTSTS(cellBlock: CellBlockPtr; ic: integer; tsts: LargestSetChars);		var oldstate: SignedByte;			H: Handle;			statePtr: Ptr;				begin		if ic > cellBlock^.nchar then			begin				Beep;				Exit(SetFindTSTS);			end;		LockHandle(cellBlock^.H, oldstate);		if cellBlock^.blocknumbytes = 2 then			begin				statePtr:= Ptr(GetMaster(cellBlock^.H)+cellBlock^.blocktcb*ord4(ic-1));				IP(statePtr)^ := set31to15(NewSetFromOld(tsts));			end		else			begin				statePtr := Ptr(GetMaster(cellBlock^.H)+cellBlock^.blocktcb*ord4(ic-1));				LIP(statePtr)^ := longint(tsts);			end;		ResetHandle(cellBlock^.H, oldstate);	end;{-----------------------------------------------------------------------------}	procedure InitFindCellBlock(cellBlock: CellBlockPtr; numC: integer);		var			oldstate: SignedByte;	begin		with cellBlock^ do			begin				starttaxa := 1;				endtaxa := 1;				ntax := 1;				startchars := 1;				endchars := numC;				nchar := numC;				blocktcb := tcb;				blocknumbytes := numbytes;				UnLockHandle(cellBlock^.H, oldstate);				SetHandleSize(cellBlock^.H, ord4(tcb) * ntax * nchar);				ResetHandle(cellBlock^.H, oldstate);			end;	end;{-----------------------------------------------------------------------------}	procedure ReverseString(var seq: str255);	var ds : str255;		len,j: integer;	begin		len := length(seq);		ds := seq;		for j := 1 to len do			ds[j] := seq[len-j+1];		seq := ds;	end;{-----------------------------------------------------------------------------}	procedure ComplementString(var seq: str255);	var j: integer;	begin		for j := 1 to  length(seq) do			case seq[j] of				'A': seq[j] := 'T';				'a': seq[j] := 't';				'C': seq[j] := 'G';				'c': seq[j] := 'g';				'G': seq[j] := 'C';				'g': seq[j] := 'c';				'T': seq[j] := 'A';				't': seq[j] := 'a';				otherwise;			end;	end;{----------------------------------------------------------------------------}	function SetFindStringFilter (theDialog: DialogPtr; var Event: EventRecord; var localItemHit: INTEGER): BOOLEAN;		var			WindoLoc: integer;			dragArea: rect;			whichWindow: WindowPtr;	begin		WindoLoc := FindWindow(Event.where, Whichwindow);		SetFindStringFilter := FALSE;		case Event.what of			updateEvt: 				begin					if myGetWindowPtrFromEventMessage(Event)<> myGetWindowPtrForDialog(theDialog) then						begin							DealWithUpdates(Event,false); 							SetFindStringFilter := TRUE;						end;				end;			keyDown:				if HitReturn(Event) then					begin						localItemHit := PressButton(theDialog, 1);						SetFindStringFilter := true;					end;			mouseDown:				begin					case WindoLoc of							inDrag: 								if whichwindow = myGetWindowPtrForDialog(theDialog) then									if StillDown then										begin											DragArea := ScreenRectangle;											InsetREct(DragArea, 4, 4);											DragArea.top := DragArea.top + 12;											DragWindow(whichwindow, Event.where, @DragArea);											SetFindStringFilter := TRUE;										end;							otherwise								;						end;					{					GlobalToLocal(Event.where);					if PtInRect(Event.where, fullRect) then						begin							if LClick(Event.where, event.modifiers, theList) then								localItemHit := 1							else								localItemHit := notinDialog;							SetFindStringFilter := TRUE;						end;					LocaltoGlobal(Event.where);}				end;			otherwise;		end;	end;{-----------------------------------------------------------------------------}	procedure SetFindString;	var			theDialog: DialogPtr;			tempP: windowptr;			ds, seq: str255;			localItemHit: integer;			tsts: LargestSetChars;			j,numCells: integer;			oldfindSequenceMatchMustBeExact: boolean;			oldfindSequenceRespectCase: boolean;			small, addUncertainty: boolean;			oldNumMismatches: integer;			DLOGFilterUPP: UniversalProcPtr;{...............}	procedure GetNumMismatches;	var LI: longint;	begin		ds := GetEditText(theDialog, 11);		if StringIsLongint(ds) then			begin				StringToNum(ds, LI);				findNumMismatches := LI;			end		else			begin				Beep;			end;	end;{...............}	begin		oldfindSequenceMatchMustBeExact:= findSequenceMatchMustBeExact;		oldfindSequenceRespectCase := findSequenceRespectCase;		oldNumMismatches := findNumMismatches;		seq := '';		ds := '*';		StartDLOG(163, theDialog, tempP);		if not nucleotides then HideDialogItem(theDialog,8);		myShowDialog(theDialog);		seq := CellBlockString(EWFindSequenceBlockP,true);		SetDLOGText(theDialog, 3, seq, false);		ItemCheckMark(theDialog, 6, not findSequenceMatchMustBeExact);		ItemCheckMark(theDialog, 9, findSequenceRespectCase);		EnableDisableDLOGItem(theDialog,9,nucleotides,true);		SelectDialogItemText(theDialog,3,0,32767);		SetDLOGText(theDialog, 11, StringFromNum(findNumMismatches), false);		FrameButton(theDialog, 1);		DLOGFilterUPP := MyNewModalFilterUPP(@SetFindStringFilter);  		repeat			myModalDialog(DLOGFilterUPP, localItemHit);			case localitemhit of				6:					begin						findSequenceMatchMustBeExact:= not findSequenceMatchMustBeExact;						ItemCheckMark(theDialog, 6, not findSequenceMatchMustBeExact);					end;				9:					begin						findSequenceRespectCase := not findSequenceRespectCase;						ItemCheckMark(theDialog, 9, findSequenceRespectCase);					end;				7:   {reverse}					begin						seq := GetEditText(TheDialog, 3);						ReverseString(seq);						SetDLOGText(theDialog, 3, seq, true);					end;				8:   {complement}					begin						seq := GetEditText(TheDialog, 3);						ComplementString(seq);						SetDLOGText(theDialog, 3, seq, true);					end;				11:					GetNumMismatches;				otherwise;			end;		until (localItemHit in [1, 2, 5]);		if (localitemHit in[1,5]) then			seq := GetEditText(TheDialog, 3)		else 			begin				findSequenceMatchMustBeExact:= oldfindSequenceMatchMustBeExact;				findSequenceRespectCase := oldfindSequenceRespectCase;				findNumMismatches :=oldNumMismatches;			end;		MyDisposeModalFilterUPP(DLOGFilterUPP);		EndDLOG(thedialog, tempP);		if (localitemHit in[1,5]) & (seq<>'') then			begin				EmptyCellBlock(EWFindSequenceBlockP);				j := 1;				numCells := 0;				while (j<=length(seq)) do   {cycle through length of string}					begin						if seq[j] = '{' then   {uncertainty}							begin								repeat									j := j+1;								until (seq[j]='}') | (j>length(seq));								if seq[j]='}' then									j := j+1;								numCells := numCells+1							end						else if seq[j] = '(' then   {polymorphism}							begin								repeat									j := j+1;								until (seq[j]=')') | (j>length(seq));								if seq[j]=')' then									j := j+1;								numCells := numCells+1							end						else       {single symbol}							begin								j := j+1;								numCells := numCells+1							end;					end;				InitFindCellBlock(EWFindSequenceBlockP, numCells);				j := 1;				numCells := 0;				while (j<=length(seq)) do   {cycle through length of string}					begin						addUncertainty := false;						small := false;						ds := '';						if seq[j] = '{' then   {uncertainty}							begin								repeat									if (seq[j]<>'{') & (seq[j]<>'}') then										begin											ds := concat(ds,seq[j]);											small := nucleotides & (seq[j]>='a')& (seq[j]<='z');										end;									j := j+1;								until (seq[j]='}') | (j>length(seq));								if seq[j]='}' then									j := j+1;								addUncertainty := true;								numCells := numCells+1							end						else if seq[j] = '(' then   {polymorphism}							begin								repeat									if (seq[j]<>'(') & (seq[j]<>')') then										begin											ds := concat(ds,seq[j]);											small := nucleotides & (seq[j]>='a')& (seq[j]<='z');										end;									j := j+1;								until (seq[j]=')') | (j>length(seq));								if seq[j]=')' then									j := j+1;								numCells := numCells+1							end						else       {single symbol}							begin								small := nucleotides & (seq[j]>='a')& (seq[j]<='z');								ds:= seq[j];								j := j+1;								numCells := numCells+1							end;						if StringToSetChars(ds, tsts, 0, 0) then  {now that we have the "cell" contents, let's convert it to a set}							begin								if small then tsts := tsts+[SSl];								if addUncertainty then tsts := tsts + [UCl];								SetFindTSTS(EWFindSequenceBlockP,numCells,tsts);							end						else							begin								EmptyCellBlock(EWFindSequenceBlockP);								NewError(433,0);								leave;							end;					end;				if (localitemhit=1) & CellBlockHasDataOfLegalSize(EWFindSequenceBlockP) then					FindSequence(true,false);			end;	end;{-----------------------------------------------------------------------------}	const		findElementPartTriplet = 1;{-----------------------------------------------------------------------------}	procedure FindElement(findElementType: integer; next: boolean; validateWindow: boolean);	label 1;	var ic: integer;		 it: integer;		 st, et, sc, ec: integer;		 sequenceFound: boolean;		 firsticstart,icstart,itstart,itend,icend: integer;		 TL,BR: point;		 elementLength: integer;	begin		if editorOpen then			begin				sequenceFound := false;				elementLength := 1;				case findElementType of					findElementPartTriplet: 						elementLength := 3;					otherwise						Exit(FindElement);				end;				icstart := 1;				icend := numchars;				if not editorSelected then					begin						if not next then 							begin								Beep;								Exit(FindElement);							end;						st:= 1;						et:=  1;						sc := 0;						ec := 0;					end				else					CalcSelectedTaxaCharacters(st, et, sc, ec, true);				if next then 					begin						itstart:=et;						itend := numtaxa;						if (ec<=0) then  {this is what you get if you have selected a taxon name}							firsticstart := 1 						else							firsticstart := sc+1;						icend := numchars;						if firsticstart > numchars then							begin								firsticstart := 1;								itstart := itstart+1;								if itstart > numtaxa then									begin										Beep;										Exit(FindElement);									end;							end;					end				else					begin						itstart:=st;						itend := 1;						firsticstart := sc-1;						icend := 1;						if firsticstart < 1 then							begin								firsticstart := numchars;								itstart := itstart-1;								if itstart < 1 then									begin										Beep;										Exit(FindElement);									end;							end;					end;				if next then					for it := itstart to itend do						begin							if itstart= it then								icstart := firsticstart							else 								icstart := 1;							for ic := icstart to numchars do								begin									case findElementType of										findElementPartTriplet: 											if PartTripletStartsHere(it,ic) then												sequenceFound := true;										otherwise  ;									end;									if sequenceFound then										goto 1;								end;						end				else					for it := itstart  downto itend do						begin							if itstart= it then								icstart := firsticstart							else 								icstart := numchars;							for ic := icstart downto icend do								begin									case findElementType of										findElementPartTriplet: 											if PartTripletStartsHere(it,ic) then												sequenceFound := true;										otherwise  ;									end;									if sequenceFound then										goto 1;								end;						end;1:				if sequenceFound then					begin						RowColumnFromTaxonCharacter(it,ic,TL.v,TL.h);						RowColumnFromTaxonCharacter(it,ic+elementLength-1,BR.v,BR.h);						CleanOldCell(editorSelectionTopLeft, editorSelectionBotRight);						if badcellEntry then							Exit(FindElement);						editorSelectionTopLeft:= TL;						editorSelectionBotRight:= BR;						FixNewCell(editorSelectionTopLeft, editorSelectionTopLeft);						if SingleCell then								SetUpCellEdit;						DrawDataCellsBetweenCorners(editorSelectionTopLeft,editorSelectionBotRight,selectionModeAsIs);						ScrollToSelection(false,validateWindow);					end				else					Beep;							end;	end;{-----------------------------------------------------------------------------}	procedure DoFindMenu (ItemNo: integer);	begin		case ItemNo of			FindItem :				SetFindString;			EnterFindItem :				if not StoreDataIntoCellBlock(EWFindSequenceBlockP,editorSelectionBotRight,editorSelectionTopLeft, true, true, true, false,false,false) then					Beep;			FindNextItem :				FindSequence(true,true);			FindPreviousItem :				FindSequence(false,true);							FlashFindItem:				begin					if editorFlashMode = FlashFindSequence then						editorFlashMode := flashOff					else						editorFlashMode := flashFindSequence;					if (editorFlashMode = FlashFindSequence) & not CellBlockHasDataOfLegalSize(EWFindSequenceBlockP) then						editorFlashMode := flashOff;						{if editorFlashFindSequence then						begin							if SingleCell then								editorFlashFindSequence := false							else								editorFlashFindSequence:= StoreDataIntoCellBlock(EWFindSequenceBlockP,editorSelectionBotRight,editorSelectionTopLeft, true, true,false);						end					else						begin							SetHandleSize(EWFindSequenceBlockP^.H,0);							EWFindSequenceBlockP^.ntax := 0;							EWFindSequenceBlockP^.nchar := 0;						end;}					CheckFlashMenu;				end;			FlashFindIgnoreGapsItem:				begin					flashFindIgnoreGaps := not flashFindIgnoreGaps;					CheckFlashMenu;				end;			FLashNonCodonsItem:				begin					if editorFlashMode = FlashNonCodons then						editorFlashMode := flashOff					else						editorFlashMode := FlashNonCodons;					CheckFlashMenu;				end;{$IFC RESEARCH}			FindNonCodonsItem:				begin					FindElement(findElementPartTriplet, true, true);				end;{$ENDC}{$IFC FLASHRNACOMP}			EnterRNARCItem:					begin						editorFlashMode := flashRNAReverseComplement;						flashRNARCFirstChar:=CharOfCell(editorSelectionTopLeft);						if flashRNARCFirstChar < 0 then 							flashRNARCFirstChar := 1;						flashRNARCLastChar:=CharOfCell(editorSelectionBotRight);						flashRNARCFirstTax:=TaxonOfCell(editorSelectionTopLeft);						if flashRNARCFirstTax < 0 then 							flashRNARCFirstTax := 1;						flashRNARCLastTax:=TaxonOfCell(editorSelectionBotRight);						if (editorFlashMode = flashRNAReverseComplement) & not flashRNARCHasLegalOriginalBlock then							editorFlashMode := flashOff;						CheckFlashMenu;					end;			FlashRNARCIgnoreGapsItem:				begin					flashRNARevCompIgnoreGaps := not flashRNARevCompIgnoreGaps;					CheckFlashMenu;				end;			FlashRNARCOffItem:					begin						if editorFlashMode = flashRNAReverseComplement then							editorFlashMode := flashOff;						CheckFlashMenu;					end;{$ENDC}			otherwise				;		end;	end;{-----------------------------------------------------------------------------}	procedure DoMismatchMenu (ItemNo: integer);	begin		if (ItemNo>0) then			begin				flashRNARevCompNumMismatches := ItemNo-1;				CheckMismatchMenu;			end;	end;{-----------------------------------------------------------------------------}{-----------------------------------------------------------------------------}	procedure MolecularInvert;{will invert the selected block of cells - that is, if characters 1 through 100 are selected,}{then the characters will be reversed, so that what was character 1 is now 100,}{what was 2 is now 99,... and what was 100 is not 1}{note that this and several other molecular procedures do not }{check for legality of new states of characters, as with molecular data}{one would presumably not have such drastically different transformation types}		var			it, ic, st, et, sc, ec: integer;			SetPtrTS, scrapPtr: Ptr;			H, dhdl: Handle;			db: boolean;	begin		CalcSelectedTaxaCharacters(st, et, sc, ec, true);		if not StoreCellBlockForUndo(st, et, sc, ec, false,false,true) then Exit(MolecularInvert);		H := NewHandle(tcb * ord4(et - st + 1) * (ec - sc + 1));		currentIOPosition := 79;   {v3.05}		if not OSSuccessful(MemError) then			Exit(MolecularInvert);		HLock(H);		scrapPtr := Ptr(GetMaster(H));		for it := st to et do			begin				dhdl := GetTaxStsHdl(it);				SetPtrTS := Ptr(GetMaster(dhdl));				SetPtrTS := Ptr(ord4(SetPtrTS) + ord4(sc - 1) * tcb);				for ic := sc to ec do					begin						TransferStates(scrapPtr, SetPtrTS);						scrapPtr := Ptr(ord4(scrapPtr) + tcb);						SetPtrTS := Ptr(ord4(SetPtrTS) + tcb);					end;			end;		scrapPtr := Ptr(GetMaster(H));		for it := st to et do			begin				dhdl := GetTaxStsHdl(it);				SetPtrTS := Ptr(GetMaster(dhdl));				SetPtrTS := Ptr(ord4(SetPtrTS) + ord4(ec - 1) * tcb);				for ic := sc to ec do					begin						TransferStates(SetPtrTS, scrapPtr);						scrapPtr := Ptr(ord4(scrapPtr) + tcb);						SetPtrTS := Ptr(ord4(SetPtrTS) - tcb);					end;			end;		HUnLock(H);		CheckRedrawFullCharactersInEditor(st,et,sc,ec,true);		{if UpdateAsSensitiveToFirstTaxonChange(st) then			MatchCharUpdate(sc, ec);}		ZapHandle(H);		SetDirtyEditor(true);	end;{-----------------------------------------------------------------------------}	procedure DNARNAComplement;{will take the complement of the selected block of nucleotides}{that is, will convert all A to T, all T to A, all C to G, all G to C}		var			it, ic, st, et, sc, ec: integer;			tsts, newtsts: largestsetchars;			db: boolean;	begin		CalcSelectedTaxaCharacters(st, et, sc, ec, true);		if not StoreCellBlockForUndo(st, et, sc, ec, false,false,true) then Exit(DNARNAComplement);		for it := st to et do			for ic := sc to ec do				begin					tsts := gettaxonstsLargest(it, ic);					newtsts := tsts - [0..3];					if 0 in tsts then						newtsts := newtsts + [3];			{A->T}					if 1 in tsts then						newtsts := newtsts + [2];			{C->G}					if 2 in tsts then						newtsts := newtsts + [1];			{G->C}					if 3 in tsts then						newtsts := newtsts + [0];			{T->A}					settaxonstsLargestFoot(it, ic, newtsts);				end;		CheckRedrawFullCharactersInEditor(st,et,sc,ec,true);		{if UpdateAsSensitiveToFirstTaxonChange(st) then			MatchCharUpdate(sc, ec);}		SetDirtyEditor(true);	end;{-----------------------------------------------------------------------------}	function TaxonSelectedInWindow(it: integer; whichWindow: WindowPtr): boolean;	var st,et,sc,ec: integer;	begin		TaxonSelectedInWindow:= false;		if whichWindow = editorWindow then			begin				CalcSelectedTaxaCharacters(st, et, sc, ec, true);				TaxonSelectedInWindow:= (it >= st) & (it <=et);			end		else if whichWindow=infoWindow[taxinfo] then			begin				TaxonSelectedInWindow:= InfoRowSelected(taxinfo,it);			end;	end;{-----------------------------------------------------------------------------}	function CharacterSelectedInWindow(ic: integer; whichWindow: WindowPtr): boolean;	var st,et,sc,ec: integer;	begin		CharacterSelectedInWindow:= false;		if whichWindow = editorWindow then			begin				CalcSelectedTaxaCharacters(st, et, sc, ec, true);				CharacterSelectedInWindow:= (ic >= sc) & (ic <=ec);			end		else if whichWindow=infoWindow[charinfo] then			begin				CharacterSelectedInWindow:= InfoRowSelected(charinfo,ic);			end;	end;{-----------------------------------------------------------------------------}	procedure SearchAndReplace;		label			2;		var			theDialog: DialogPtr;			tempP: WindowPtr;			FW: WindowPtr;			selectiononly: BOOLEAN;			ChangeOrToAnd, ChangeAndToOr, goodchange, db: boolean;			it, ic, sc, ec, st, et: integer;			searchset, replaceSet, oldset, finalSet: largestsetchars;			ds: str255;			replacements: longint;			localItemHit: integer;	begin		selectiononly := true;		FW := frontWindow;		StartDLOG(556, theDialog, tempP);		ItemCheckMark(theDialog, 5, wholeword);		if ((frontWindow=infoWindow[charinfo])&not infoSomeSelected[charinfo]) |(IsEditorWindow(frontWindow)&(not editorSelected | SingleCell | not ((editorSelectionBotRight.v > 0) & (editorSelectionBotRight.h > 0)))) then			begin				EnableDisableDLOGItem(theDialog, 6, false, false);				selectiononly := false;			end		else			ItemCheckMark(theDialog, 6, selectiononly);		myShowDialog(theDialog);2:		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			if localItemHit = 5 then				begin					wholeword := not wholeword;					ItemCheckMark(theDialog, 5, wholeword);				end			else if localItemHit = 6 then				begin					selectiononly := not selectiononly;					ItemCheckMark(theDialog, 6, selectiononly);				end;		until localItemHit in [1, 2];		if localItemHit = 1 then			begin				ds := GetEditText(theDialog, 3);				StripBlanks(ds);				changeOrtoAnd := (ds = orsep);				changeAndToOr := (ds = andsep);				goodchange := (ds <> '') & ((ChangeOrToAnd | ChangeAndToOr) | StringToSetChars(ds, searchset, 0, 0)); {pass zero to mean any char}				ds := GetEditText(theDialog, 4);				StripBlanks(ds);				if ds = '' then					goodchange := false;				if goodchange then					if ChangeOrToAnd then						begin							changeOrtoAnd := (ds = andsep);							goodchange := changeOrToAnd;						end					else if ChangeAndToOr then						begin							changeAndToOr := (ds = orsep);							goodchange := changeAndToOr;						end					else						begin							goodchange := (ds <> andsep) and (ds <> orsep) and StringToSetChars(ds, replaceSet, 0, 0);							if searchset = replaceSet then								begin									InstantError(230);									goto 2;								end;						end;				if not goodchange then					begin						InstantError(231);						goto 2;					end;			end;		EndDLOG(theDialog, tempP);		if localItemHit = 1 then			begin				replacements := 0;				SetCursor(clockCursor);				if IsEditorWindow(FW) then FW := editorWindow;				if selectionOnly & (FW=editorWindow) then					begin 						if not StoreSelectedCellBlockForUndo(false,false,true) then Exit(SearchAndReplace);					end				else					if not StoreCellBlockForUndo(1, numtaxa, 1, numchars, false,false,false) then Exit(SearchAndReplace);				if changeOrToAnd then					begin						for ic := 1 to numchars do							if not selectionOnly | CharacterSelectedInWindow(ic,FW) then								for it := 1 to numtaxa do									if not selectionOnly | TaxonSelectedInWindow(it,FW) then										begin											oldset := gettaxonstsLargest(it, ic) - [UCl];											if MultipleStatesLg(oldset) then												begin													settaxonstsLargestFoot(it, ic, oldset);													replacements := replacements + 1;												end;										end					end				else if ChangeAndToOr then					begin						for ic := 1 to numchars do							if not selectionOnly | CharacterSelectedInWindow(ic,FW) then								for it := 1 to numtaxa do									if not selectionOnly | TaxonSelectedInWindow(it,FW) then									begin										oldset := gettaxonstsLargest(it, ic) + [UCl];										if MultipleStatesLg(oldset) then											begin												settaxonstsLargestFoot(it, ic, oldset);												replacements := replacements + 1;											end;									end					end				else					begin						for ic := 1 to numchars do							if not selectionOnly | CharacterSelectedInWindow(ic,FW) then								for it := 1 to numtaxa do									if not selectionOnly | TaxonSelectedInWindow(it,FW) then									begin										oldset := gettaxonstsLargest(it, ic);										if wholeword and (oldset = searchset) then		{only change if cell exactly matches searchset}											begin												if MakeLegalSet(replaceSet, finalSet, ic) then													begin														settaxonstsLargestFoot(it, ic, finalSet);														replacements := replacements + 1;													end;											end										else if not wholeword and (searchset <= oldset) then											begin												if MakeLegalSet(replaceSet, finalSet, ic) then													begin														finalSet := finalSet + (oldset - searchset);														if (finalSet - [MSl, GAl] <> []) then   {there is something else in set beside missing and gap}															finalSet := finalSet - [MSl, GAl];														settaxonstsLargestFoot(it, ic, finalSet);														replacements := replacements + 1;													end;											end;									end;					end;				if editorSelected & SingleCell & (CharOfCell(editorSelectionTopLeft) > 0) & (TaxonOfCell(editorSelectionTopLeft) > 0) then					FillsTE(editorCellTE, CellString);				InstantInfo(concat(StringFromNum(replacements), ' changes made.'));				InvalidateWindow(editorWindow,true);				{if (matchcharon | (editorColorCellsMode=editorColorCellsMatchFirst)) then					MatchCharUpdate(FirstVisibleCharacter, LastVisibleCharacter);}				SetDirtyEditor(selectiononly);			end;	end;{-----------------------------------------------------------------------------}	procedure ShuffleSelected;{е procedure shuffles the states in a character between taxa, for all selected characters}		var			theDialog: DialogPtr;			tempP: WindowPtr;			db: boolean;			j, st, et, sc, ec, it, ic, randtaxon, numleft: integer;			tsts: largestsetchars;			dL: longint;			H: Handle;			sp: Ptr;			removefeet: boolean;			localItemHit: integer;	begin{v4: shuffles up states of characters WITHIN a taxon}		if Locked(lockData) then			Exit(ShuffleSelected);		removefeet := false;		StartDLOG(568, theDialog, tempP);		myShowDialog(theDialog);		FrameButton(theDialog, 1);		NewRandomSeed;		EnableDisableDLOGItem(theDialog, 5, AnyFeet(footText) or AnyFeet(footPict), false);{ooooooooooooooooooooooooooooooooooo}		repeat			ModalDialog(nil, localItemHit);			if localItemHit = 3 then				begin					GetRandomSeed;					FrameButton(theDialog, 1);				end			else if localItemHit = 5 then				begin					removefeet := not removefeet;					ItemCheckMark(theDialog, 5, removefeet);				end;		until localItemHit in [1, 2];{ooooooooooooooooooooooooooooooooooo}		EndDLOG(theDialog, tempP);		if localItemHit = 2 then			exit(shuffleselected)		else			begin				SetCursor(clockCursor);				oldRandSeed := OurRandseed;				CalcSelectedTaxaCharacters(st, et, sc, ec, true);				if not StoreCellBlockForUndo(st, et, sc, ec, false,false,true) then Exit(ShuffleSelected);				if removefeet then					for j := 0 to maxfoottype do						RemoveFeetSelected(j);   {bits are destroyed during shuffling}				H := NewHandle(2);				for ic := sc to ec do					begin						SetHandleSize(H, ord4(et - st + 1) * tcb);{=== filling H with states of taxa st through et ===}						HLock(H);						dL := GetMaster(H);						for it := st to et do							begin								tsts := gettaxonstsLargest(it, ic);								sp := Ptr(dL + ord4(it - st) * tcb);								TransferStatesFromLargest(sp, tsts);							end;						HUnLock(H); {=== moving H pieces to taxonsts ===}						for it := st to et do							begin								numleft := GetHandleSize(H) div tcb;{randtaxon := abs(Random) mod (numleft);}								randtaxon := randombetween(0, numleft - 1);								tsts := GetLargestFromPtr(Ptr(GetMaster(H) + randtaxon * tcb));								DeletePieceOfHandle(H, tcb * (randtaxon), tcb);   {removing H piece that was just used}								if removeFeet then									settaxonstsLargest(it, ic, tsts)								else									settaxonstsLargestOverWriteCase(it, ic, tsts);							end;					end;				datachanged := true;				{if UpdateAsSensitiveToFirstTaxonChange(st) then					MatchCharUpdate(sc, ec);}				CheckRedrawFullCharactersInEditor(st,et,sc,ec,true);				ZapHandle(H);				SetDirtyEditor(true);				SetCursorToArrow;			end;	end;	{-----------------------------------------------------------------------------}	procedure SwitchEditorCase(makeUpper: boolean);	var st,et,sc,ec: integer;		it,ic: integer;		db: boolean;	begin		CalcSelectedTaxaCharacters(st,et,sc,ec,true);		if not StoreCellBlockForUndo(st, et, sc, ec, false,false,true) then Exit(SwitchEditorCase);		for it := st to et do			for ic := sc to ec do				if not HasMissingBit(it,ic) then					SetAlternativeSymbol(it,ic,not makeUpper);		DrawDataCellsBetweenCorners(editorSelectionTopLeft,editorSelectionBotRight, selectionModeAsIs);		dirtyfile := true;	end;{----------------------------------------------------------------------------}	function FirstFullTriplet(it: integer): integer;	{this calculates the first character that is a non-gap in taxon it}	var first, ic: integer;	begin		first := firstNonGap(it);		FirstFullTriplet := 0;		if first < numchars then			for ic := first to numchars do				if FullTripletStartsHere(it,ic) then					begin						FirstFullTriplet := ic;						leave;					end;	end;{----------------------------------------------------------------------------}	function LastFullTriplet(it: integer): integer;	{this calculates the first character that is a non-gap in taxon it}	var last, ic: integer;	begin		last := lastNonGap(it);		LastFullTriplet := 0;		if last > 0 then			for ic := last downto 1 do				if FullTripletStartsHere(it,ic) then					begin						LastFullTriplet := ic;						leave;					end;	end;{-----------------------------------------------------------------------------}	procedure RemoveTerminalPartTriplets(justSelected: boolean);	var st,et,sc,ec: integer;		it,ic, first, preTriplet, postTriplet: integer;		db: boolean;		topleft,botright: point;	begin		if justSelected then 			begin				if not editorSelected | singleCell then					Exit(RemoveTerminalPartTriplets);				CalcSelectedTaxaCharacters(st,et,sc,ec,true);			end		else			begin				st := 1;				et  := numtaxa;				sc := 1;				ec := numchars;			end;		if not StoreCellBlockForUndo(st, et, sc, ec, false,false,true) then Exit(RemoveTerminalPartTriplets);				if not justSelected | ((sc=1)|(ec=numchars)) then			for it := st to et do 				begin					if sc = 1 then						begin							preTriplet:= FirstFullTriplet(it)-1;							if (preTriplet > 0) & (preTriplet <= ec) then							for ic := 1 to preTriplet do								setTaxonStsLargest(it,ic,[MSl,GAl]);						end;					if ec = numchars then 						begin							postTriplet:= LastFullTriplet(it)+3;							if (postTriplet > 3) &(postTriplet >= sc) & (postTriplet <= numchars) then								for ic := postTriplet to numchars do									setTaxonStsLargest(it,ic,[MSl,GAl]);						end;				end;				RowColumnFromTaxonCharacter(st,sc, topleft.v,topleft.h);		RowColumnFromTaxonCharacter(et,ec, botright.v,botright.h);		DrawDataCellsBetweenCorners(topLeft,botRight, selectionModeAsIs);		dirtyfile := true;	end;	{-----------------------------------------------------------------------------}	procedure SwitchStatesInEditor(switchItem: integer;  justSelected: boolean);	var st,et,sc,ec: integer;		it,ic,preTriplet, postTriplet: integer;		db: boolean;		topleft,botright: point;	begin		if editorSelected and editorOpen and SingleCell then  			begin				ReturnValue(editorSelectionTopLeft,false);				if badcellentry then					if BadCellEntryQuery then						badcellentry := false					else						Exit(SwitchStatesInEditor);				ZeroSelection;			end;		if justSelected then 			begin				if not editorSelected | singleCell then					begin						if (switchItem=TerminalMissingToGapsItem)|(switchItem=TerminalGapsToMissingItem) | (switchItem=TerminalPartTripletsToGapsItem) then 							NewError(439,0)						else							NewError(440,0);						Exit(SwitchStatesInEditor);					end;				CalcSelectedTaxaCharacters(st,et,sc,ec,true);				if (et<1) | (ec<1) then 					begin						if (switchItem=TerminalMissingToGapsItem)|(switchItem=TerminalGapsToMissingItem)| (switchItem=TerminalPartTripletsToGapsItem) then 							NewError(439,0)						else							NewError(440,0);						Exit(SwitchStatesInEditor);					end;			end		else			begin				st := 1;				et  := numtaxa;				sc := 1;				ec := numchars;			end;		if not StoreCellBlockForUndo(st, et, sc, ec, false,false,true) then Exit(SwitchStatesInEditor);				case switchitem of			TerminalMissingToGapsItem:				if justSelected & (sc<>1) & (ec<>numchars) then					NewError(439,0)				else if not justSelected | ((sc=1)|(ec=numchars)) then					for it := st to et do 						begin							if sc = 1 then								for ic := sc to ec do									if MSl in GetTaxonStsLargest(it,ic) then										setTaxonStsLargest(it,ic,[MSl,GAl])									else										leave;							if ec = numchars then 								for ic := ec downto sc do									if MSl in GetTaxonStsLargest(it,ic) then										setTaxonStsLargest(it,ic,[MSl,GAl])									else										leave;						end;								TerminalGapsToMissingItem:				if justSelected & (sc<>1) & (ec<>numchars) then					NewError(439,0)				else if not justSelected | ((sc=1)|(ec=numchars)) then					for it := st to et do 						begin							if sc = 1 then								for ic := sc to ec do									if MSl in GetTaxonStsLargest(it,ic) then										setTaxonStsLargest(it,ic,[MSl])									else										leave;							if ec = numchars then 								for ic := ec downto sc do									if MSl in GetTaxonStsLargest(it,ic) then										setTaxonStsLargest(it,ic,[MSl])									else										leave;						end;			NtoMissingItem:				for it := st to et do					for ic := sc to ec do						if getTaxonStsLargest(it,ic) = [MSl]  then							SetAlternativeSymbol(it,ic,false);			MissingToNItem:				for it := st to et do					for ic := sc to ec do						if getTaxonStsLargest(it,ic) = [MSl]  then							SetAlternativeSymbol(it,ic,true);										TerminalPartTripletsToGapsItem:					if not justSelected | ((sc=1)|(ec=numchars)) then						for it := st to et do 							begin								if sc = 1 then									begin										preTriplet:= FirstFullTriplet(it)-1;										if (preTriplet > 0) & (preTriplet <= ec) then										for ic := 1 to preTriplet do											setTaxonStsLargest(it,ic,[MSl,GAl]);									end;								if ec = numchars then 									begin										postTriplet:= LastFullTriplet(it)+3;										if (postTriplet > 3) &(postTriplet >= sc) & (postTriplet <= numchars) then											for ic := postTriplet to numchars do												setTaxonStsLargest(it,ic,[MSl,GAl]);									end;							end;			otherwise;		end;				RowColumnFromTaxonCharacter(st,sc, topleft.v,topleft.h);		RowColumnFromTaxonCharacter(et,ec, botright.v,botright.h);		DrawDataCellsBetweenCorners(topLeft,botRight, selectionModeAsIs);		dirtyfile := true;	end;	{-----------------------------------------------------------------------------}	procedure DoReplaceAllMenu(Event: EventRecord; ItemNo: integer);	begin		{in order for it to do just selected, the option key can't be held down, and the editor has to be selected appropriately}		SwitchStatesInEditor(ItemNo,not OptionEvent(Event) & (editorSelected & not singleCell & SomeDataSel));	end;{-----------------------------------------------------------------------------}{	procedure CondenseTaxonNames(itstart,itend, numLeading: integer);	var it,firstPos: integer;		ds,dsStart,dsEnd: str255;	begin		ds := '';		for it := itstart to itend do			begin				ds := TaxonName(it);				firstPos := 0;				if (pos(' ',ds)>0) then					begin						firstPos := pos(' ',ds);						if (pos('.',ds)>0) & (pos('.',ds)<firstPos) then							firstPos :=  pos('.',ds);					end				else if  (pos('.',ds)>0) then					firstPos :=  pos('.',ds);				if firstPos > 0 then					begin						dsStart := copy(ds,1,numleading);						if firstPos < length(ds) then							dsEnd := copy(ds,firstPos+1, length(ds)-firstPos)						else							dsEnd := '';						ds := concat(dsStart,'.',dsEnd);						SetTaxonName(it, ds);					end;			end;		infoDirtyNames[taxinfo] := true;		dirtytaxnames := true;		if treefile then			dirtytreefile := true;   		EraseRect(editorSelectionRect);		InvalidateWindowRect(editorWindow,editorSelectionRect,false);		datachanged := true;	end;}{-----------------------------------------------------------------------------}	procedure PrefixTaxonNames(itstart,itend: integer; prefix: str255);	var it,firstPos: integer;		ds,dsStart,dsEnd: str255;	begin		ds := '';		for it := itstart to itend do			begin				ds := TaxonName(it);				ds := concat(prefix,ds);				{ds := copy(ds,1,tnw);}				SetTaxonName(it, ds);			end;		infoDirtyNames[taxinfo] := true;		dirtytaxnames := true;		if treefile then			dirtytreefile := true;   {at least translation table is}		EraseRect(editorSelectionRect);		InvalidateWindowRect(editorWindow,editorSelectionRect,false);		datachanged := true;	end;{-----------------------------------------------------------------------------}	procedure PrefixTaxonNamesDLOG;		var			theDialog: DialogPtr;			tempP: WindowPtr;			sc, ec, st, et: integer;			ds: str255;			localItemHit: integer;			leading : longint;	begin{		leading := 1;		StartDLOG(177, theDialog, tempP);		myShowDialog(theDialog);		SetDLOGText(theDialog,3,StringFromNum(leading),true);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			if localItemHit = 3 then				begin					ds := GetEditText(theDialog, 3);					if StringIsLongint(ds) then						StringToNum(ds, leading)					else						begin							SetDLOGText(theDialog,3,StringFromNum(leading),true);							Beep;						end;				end;		until localItemHit in [1, 2];		EndDLOG(theDialog, tempP);		if localitemhit = 1 then			begin}				CalcSelectedTaxaCharacters(st, et, sc, ec,true);				if (st>0) & (et<=numtaxa) then					PrefixTaxonNames(st,et,'4');		{	end;}	end;{-----------------------------------------------------------------------------}{	procedure CondenseNamesDLOG;		var			theDialog: DialogPtr;			tempP: WindowPtr;			sc, ec, st, et: integer;			ds: str255;			localItemHit: integer;			leading : longint;	begin		leading := 1;		StartDLOG(177, theDialog, tempP);		myShowDialog(theDialog);		SetDLOGText(theDialog,3,StringFromNum(leading),true);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			if localItemHit = 3 then				begin					ds := GetEditText(theDialog, 3);					if StringIsLongint(ds) then						StringToNum(ds, leading)					else						begin							SetDLOGText(theDialog,3,StringFromNum(leading),true);							Beep;						end;				end;		until localItemHit in [1, 2];		EndDLOG(theDialog, tempP);		if localitemhit = 1 then			begin				CalcSelectedTaxaCharacters(st, et, sc, ec,true);				if (st>0) & (et<=numtaxa) then					CondenseTaxonNames(st,et,leading);			end;	end;}{-----------------------------------------------------------------------------}	procedure MakeNamesUnique;		var			oldState: SignedByte;			it, tt: integer;			tn, tn2: strTaxName;			dupfound: boolean;			dL: longint;			TaxonHdl: THdl;			count: integer;	begin		LockHandle(TaxonCHUNKs, oldState);		dL := GetMaster(TaxonCHUNKs);		SetCursor(clockCursor);		for it := 1 to numtaxa - 1 do			begin				count :=1;				TaxonHdl := THdlPtr(dL + HdlSize * (it - 1))^;				tn := TaxonHdl^^.name;				for tt := it + 1 to numtaxa do					begin						TaxonHdl := THdlPtr(dL + HdlSize * (tt - 1))^;						tn2 := TaxonHdl^^.name;						if (length(tn) = length(tn2)) & CompareStringC(@tn, @tn2) then   {much faster string comparison}							begin								SetTaxonName(tt,concat(tn2,' ',StringFromNum(count)));								count := count+1;							end;					end;			end;		ResetHandle(TaxonCHUNKs, oldState);		SetCursorToArrow;	end;{----------------------------------------------------------------------------}	procedure ImportTaxonTranslation;		var			typeList: SFTypelist;  {typelist::}			it: integer;			theFile,ds,condensed,fullName: str255;			db: boolean;			tempP: WindowPtr;	begin		typeList[0] := 'TEXT';		if ChooseFile(2, @typeList, nil, theFile, FDI^[extraIOFileFDI].fs,false,false,false) then			begin				FDI^[readFileFDI].fs:= FDI^[extraIOFileFDI].fs;				if singleCell & OnlyTaxonNamesSelected then					ReturnValue(editorSelectionTopLeft,false);{еее if taxon name selected, then return value!}										fpos := kInitialReadPos;				FDI^[readFileFDI].fs := FDI^[extraIOFileFDI].fs;				ioFileFDI := extraIOFileFDI;				{iofilename^^ := filename^^;}				{ioWorkingDirectoryNumber := WorkingDirectoryNumber; }				SetFileLength(FDI^[readFileFDI].fs);				ds := MakeCaps(GetFileToken(maxtok));				if ds <> '#NEXUS' then					begin						if not errorflag then 							NewError(438,0);						Exit(ImportTaxonTranslation);					end;				DisableWindowUpdates(editorwindow);				DisableWindowUpdates(infowindow[taxinfo]);				SetCursor(clockCursor);				if FindBlock('TRANSLATE','') then					begin						if FindCommand('TRANSLATETAXA','') then							begin								if fpos < mcFileLength then									repeat										condensed := GetFileToken(maxTok);										while condensed = ',' do											condensed := GetFileToken(maxTok);										if (condensed = ';') then											begin												//NewError(438,0);												leave;											end;										fullName := GetFileToken(maxTok);										if (fullName = ',') | (fullName = ';') then											begin												NewError(438,0);												leave;											end;										ds := GetFileToken(maxtok);  {this is the comma or semicolon}										UnderLineToBlanks(fullName);										it := GetTaxonNumber(condensed);										if it > 0 then 											begin												SetTaxonName(it,fullName);												if singleCell & OnlyTaxonNamesSelected & (it=TaxonOfCell(editorSelectionTopLeft)) then													FillsTE(editorCellTE, fullName);											end;									until (fpos>=mcFileLength) | (fullName = '') | (fullName=' ') | (ds=';')|errorFlag ;							end						else if not errorflag then							NewError(438,0);					end				else if not errorflag then					NewError(438,0);				InvalidateAllWindowsMarkedUnupdatable;			end;	end;{----------------------------------------------------------------------------}	procedure CondenseName(it: integer; var name: str255; maxLength: integer);	begin				if length(name)>maxLength-length(StringFromNum(it))-1 then			name := copy(name,1,maxLength-length(StringFromNum(it))-1);		name := concat(name,'.');		name := concat(name,StringFromNum(it));		ReplaceIllegalCharsWithBlank(name);	end;{-----------------------------------------------------------------------------}	procedure CondenseTaxonNames(itstart,itend, maxLength: integer; saveHidden: boolean);	var it: integer;		ds: str255;	begin		ds := '';		for it := itstart to itend do			begin				if (saveHidden) then					ds := concat('hidden.',StringFromNum(it))				else 					begin						ds := TaxonName(it);						CondenseName(it,ds,maxLength);					end;				SetTaxonName(it,ds);			end;		infoDirtyNames[taxinfo] := true;		dirtytaxnames := true;		if treefile then			dirtytreefile := true;   		EraseRect(editorSelectionRect);		InvalidateWindowRect(editorWindow,editorSelectionRect,false);		datachanged := true;	end;{----------------------------------------------------------------------------}	procedure WriteTranslationFile(itstart,itend, maxLength: integer; saveHidden: boolean);	var ds: str255;		it: integer;	begin		puttoken('#NEXUS');		putReturn;		putReturn;		puttokenReturn('BEGIN Translate;');		putTab;		puttokenReturn('TranslateTaxa');		for it := itstart to itend do			begin				putTab;				putTab;				if (saveHidden) then					ds := concat('hidden.',StringFromNum(it))				else 					begin						ds := TaxonName(it);						CondenseName(it,ds,maxLength);					end;				PrepareToken(ds, tnw);				putToken(ds);				putTab;				ds := TaxonName(it);				PrepareToken(ds, tnw);				putToken(ds);				if it<> itend then putSingleChar(',');				putReturn;			end;		putTab;		puttokenReturn(';');		putTokenReturn('END;');	end;{----------------------------------------------------------------------------}	function SaveTranslationTable(itstart,itend, maxLength: integer; saveHidden: boolean): boolean;	var oldexists, db: boolean;		Freply: StandardFileReply;		tempFs: FSSpec;		oldState: SignedByte;		ds: str255;	begin		SaveTranslationTable := false;		LockHandle(filename,oldstate);		ds := filename^^;		ResetHandle(filename,oldstate);		SFPutSuffixedFile(ds, '.trn', 'Save translation file as:', fReply);		if Freply.sfgood then			begin				SaveTranslationTable := true;				FSpCreateSaveFile(Freply.sfFile, oldexists, 'ttxt', 'TEXT');				if not Errorflag then					begin						if oldexists then   							tempFs:= Freply.sffile;											StartWrite;						WriteTranslationFile(itstart,itend,maxLength, saveHidden);						EndWrite;						if oldexists then							FSpExchangeFilesDeleteTemp(tempFs)						else 							tempFs:= FDI^[writeFileFDI].fs; 					end				else					begin						currentIOPosition := 48;   {v3.05}						db := IOSuccessful(resultcode);					end;			end;	end;{-----------------------------------------------------------------------------}	procedure CondenseNamesDLOG;		var			theDialog: DialogPtr;			tempP: WindowPtr;			sc, ec, st, et: integer;			ds: str255;			localItemHit: integer;			maxLength, oldLength : longint;			saveTranslateFile: boolean;	begin		maxLength := 10;		saveTranslateFile := true;		StartDLOG(177, theDialog, tempP);		myShowDialog(theDialog);		SetDLOGText(theDialog,3,StringFromNum(maxLength),true);		ItemCheckMark(theDialog, 7, saveTranslateFile);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			if localItemHit = 3 then				begin					ds := GetEditText(theDialog, 3);					if StringIsLongint(ds) then						begin							oldLength := maxLength;							StringToNum(ds, maxLength);							if maxLength < 4 then 								begin									maxLength := oldLength;									SetDLOGText(theDialog,3,StringFromNum(maxLength),true);									Beep;								end;						end					else						begin							SetDLOGText(theDialog,3,StringFromNum(maxLength),true);							Beep;						end;				end			else if localItemHit in [7,8] then				begin					saveTranslateFile := not saveTranslateFile;					ItemCheckMark(theDialog, 7, saveTranslateFile);				end;		until localItemHit in [1, 2];		EndDLOG(theDialog, tempP);		if localitemhit = 1 then			begin				CalcSelectedTaxaCharacters(st, et, sc, ec,true);				if (st>0) & (et<=numtaxa) then					begin						if not saveTranslateFile | SaveTranslationTable(st,et,maxLength, false) then							CondenseTaxonNames(st,et,maxLength, false);					end;			end;	end;{-----------------------------------------------------------------------------}	procedure HideTaxonNames;		var			sc, ec, st, et: integer;			ds: str255;			maxLength : longint;			saveTranslateFile: boolean;	begin		maxLength := 10;		saveTranslateFile := true;		CalcSelectedTaxaCharacters(st, et, sc, ec,true);		if (st>0) & (et<=numtaxa) then			begin				if SaveTranslationTable(st,et,maxLength, true) then					CondenseTaxonNames(st,et,maxLength, true);			end;	end;{----------------------------------------------------------------------------}	procedure ShowStateFreq;	var ic,j : integer;		sc,ec,st,et, it: integer;		tsts: LargestSetChars;		freq: stateFreqType;	begin		CalcSelectedTaxaCharacters(st, et, sc, ec, true);		for j := 0 to absmaxstate do			freq[j] := 0;		for it := st to et do			for ic := sc to ec do				begin					tsts := GetTaxonStsLargest(it, ic);					for j := 0 to absmaxstate do						if j in tsts then							freq[j] := freq[j]+1;				end;		InstantInfo(concat('Frequencies (A,C,G,T): (',StringFromNum(freq[0]),',',StringFromNum(freq[1]),',',StringFromNum(freq[2]),',',StringFromNum(freq[3]),')'));	end;{----------------------------------------------------------------------------}	procedure OptimizeStopCodonsInSelected;	var 		sc,ec,st,et, it: integer;		numStops0, numStops1, numStops2, minStops, endGaps: longint;		oldNumChars: integer;	begin		if WholeTaxonSel & SomeCoding then			begin				CalcSelectedTaxaCharacters(st, et, sc, ec, true);				if not StoreCellBlockForUndo(st, et, 1, numchars, true,false,true) then Exit(OptimizeStopCodonsInSelected);				endGaps := 0;				oldNumChars := numChars;				if CheckIfAllGaps(st,et,numchars,numchars,editorToolsTreatMissingAsGaps) then					begin						endGaps := 1;						if CheckIfAllGaps(st,et,numchars-1,numchars-1,editorToolsTreatMissingAsGaps) then							endGaps := 2;					end;				if endGaps<2 then					AddNewCharacters (2-endGaps, true);				for it := st to et do					begin						numStops0 := NumStopCodonsInTaxon(it,false);    // number of stops unshifted						ShiftMolecularDataInTaxon(it,1);						numStops1 := NumStopCodonsInTaxon(it,false);   // number of stops shifted by 1						ShiftMolecularDataInTaxon(it,1);						numStops2 := NumStopCodonsInTaxon(it,false);   // number of stops shifted by 2						minStops := 0;						if (numStops0<=numStops1) & (numStops0<=numStops2) then  // can't do better than original, return it to that							begin								minStops := 2;								if (numStops0=numStops1) | (numStops0=numStops2) then									NewError(462,0);							end						else if (numStops1<=numStops0) & (numStops1<=numStops2) then  // best if we shift by 1							begin								minStops := 1;								if (numStops1=numStops0) | (numStops1=numStops2) then									NewError(462,0);							end						else if (numStops2<=numStops0) & (numStops2<=numStops1) then  // best if we shift by 2; leave it as it is							begin								minStops := 0;								if (numStops2=numStops0) | (numStops2=numStops1) then									NewError(462,0);							end;						if minStops>0 then							ShiftMolecularDataInTaxon(it,-minStops);					end;				if (oldNumChars<> numChars) then					begin						if editorTransposed then							editorSelectionBotRight.v := numChars						else							editorSelectionBotRight.h := numChars;						CalcEditorSelectionRect(editorSelectionTopLeft,editorSelectionBotRight);					end;				InvalidateWindow(editorwindow,true);			end;	end;{----------------------------------------------------------------------------}	function CalcSeqMatch(it, icStart, it2, ic2Start, numic: integer): integer;  { calculates sequence match for between first numic characters																in sequence it from icStart to those in sequence it2 from 																ic2Start}	var ic, matchValue: integer;		ic2, icCount: integer;		set1, set2: largestsetchars;	begin		matchValue := 0;		icCount := 1;		ic := icStart;		ic2 := ic2Start;		while (icCount<=numic) do			begin				set1:= gettaxonstsLargest(it,ic);				set2:= gettaxonstsLargest(it2,ic2);				if EqualSets(set1,set2) then					matchValue := matchValue+1;				ic := ic+1;				while (ic <= numchars) & (HasMissingBit(it, ic)) do					ic := ic+1;				ic2 := ic2+1;				while (ic2 <= numchars) & (HasMissingBit(it2, ic2)) do					ic2 := ic2+1;				if ((ic=numchars) & hasMissingBit(it,ic)) |  ((ic2=numchars) & hasMissingBit(it2,ic2)) then					 leave;				icCount := icCount +1;			end;		CalcSeqMatch := matchValue;	end;{----------------------------------------------------------------------------}	function SearchForMatch(it, startic, it2, numic, threshold: integer; var move: integer; findFirst: boolean): boolean;	// searches for match in it2 to the region in taxon it that begins at character startic and goes for numic characters	var ic, matchValue: integer;		maxMatch: integer;	begin		SearchForMatch := false;		maxMatch := 0;		for ic := 1 to numchars do   // go through characters in it2			if not HasMissingBit(it2,ic) then				begin					matchValue:= CalcSeqMatch(it,startic, it2,ic, numic);					if matchValue >= threshold then						begin							if maxMatch < matchValue then 								begin									move := ic-startic;  									maxMatch := matchValue;								end;							SearchForMatch := true;							if findFirst then								leave;						end;				end;	end;{----------------------------------------------------------------------------	function SearchForMaximumMatchToSelected(fixedit, it, sc, ec, threshold: integer; var move: integer): boolean;	var ic, count : integer;	begin		SearchForMaximumMatchToSelected := false;				// find how much data is in the selected piece		count := 0;		for ic := sc to ec do			if not HasMissingBit(fixedit,ic) then				count := count + 1;						SearchForMaximumMatchToSelected := SearchForMatch(fixedit,sc, it, count, threshold, move);	end;{-----------------------------------------------------------------------------}	function ShiftMatchToSelectedDialog(var st, et: integer; var thresholdValue: double; var findFirst: boolean): boolean;		label			1;		var			theDialog: DialogPtr;			tempP: WindowPtr;			ds: str255;			LI: longint;			localItemHit: integer;			dd: double;			oldFindFirst: boolean;			{...............}	procedure GetEditValuesMatchDialog(itemNumber, min, max: integer; var value: integer);	begin		ds := GetEditText(theDialog, itemNumber);		if StringIsLongint(ds) then			begin				StringToNum(ds, LI);				if (LI<min) | (LI>max) then					begin						Beep;						goto 1;					end				else					value := LI;			end		else			begin				Beep;				goto 1;			end;	end;{...............}	begin		oldFindFirst := findFirst;		StartDLOG(187, theDialog, tempP);		SetDLOGText(theDialog,3, StringFromNum(st), true);		SetDLOGText(theDialog,4, StringFromNum(et), false);		ds := "";		RealToString(thresholdValue, ds, 1000.0, 3, false);		SetDLOGText(theDialog,5, ds, false);		ItemCheckMark(theDialog, 10, not findFirst);		myShowDialog(theDialog);		FrameButton(theDialog, 1);1:		repeat			ModalDialog(nil, localItemHit);			if (localItemHit = 10) then				begin					findFirst := not findFirst;					ItemCheckMark(theDialog, 10, not findFirst);				end;		until localItemHit in [1, 2];		if localItemHit = 1 then			begin				GetEditValuesMatchDialog(3, 1, numtaxa, st);				GetEditValuesMatchDialog(4, 1, numtaxa, et);				dd := TokenToReal(GetEditText(theDialog, 5));				if (dd<=0.0) | (dd>= 1.0) then					begin						Beep;						goto 1;					end;			end		else			findFirst := oldFindFirst;		EndDLOG(theDialog, tempP);		ShiftMatchToSelectedDialog := localitemhit = 1;	end;{----------------------------------------------------------------------------}	procedure QueryShiftAlignmentToSelected;	var 		sc,ec,st,et, it, ic, count, selectionLength: integer;		fixedit: integer;		 threshold, move, startGaps, changedTaxon: integer;		thresholdValue: double;		endGaps: longint;		oldNumChars, numToAdd: integer;		canMove, findFirst, success: boolean;	begin		CalcSelectedTaxaCharacters(st, et, sc, ec, true);		selectionLength := ec-sc+1;		fixedit := st;		//things to query for		st := st+1;		et := numtaxa;		thresholdValue := 0.75;		findFirst := true;				if not ShiftMatchToSelectedDialog(st, et, thresholdValue, findFirst) then				Exit(QueryShiftAlignmentToSelected);		StoreStateFrequencies(st,et);		if not StoreCellBlockForUndo(st, et, 1, numchars, true,false,true) then Exit(QueryShiftAlignmentToSelected);		move := 0;		threshold := RoundValue(thresholdValue * (ec - sc + 1));		oldNumChars := numChars;		// find how much data is in the selected piece		count := 0;		for ic := sc to ec do			if not HasMissingBit(fixedit,ic) then				count := count + 1;		for it := st to et do			if (it<> fixedit) then				begin					if SearchForMatch(fixedit,sc, it, count, threshold, move, findFirst) & (move<>0) then						begin							move := - move;							canMove := true;							if move<0 then								begin									startGaps := NumStartGaps(it, editortoolstreatMissingAsGaps);									if (startGaps< -move) then										begin											numToAdd := -(startGaps+move);											if (numChars + numToAdd > mnChars) then												begin													canMove := false;													NewError(466,0);												end											else												begin													InsertNewCharacters(numToAdd, 1, molecular);													sc := sc+numToAdd;  //adjust starting number													lastChangeInEditor := lastChangeInsertCharAndCellBlock;												end;										end;								end							else if move>0 then								begin									endGaps := NumEndGaps(it, editortoolstreatMissingAsGaps);									if (endGaps< move) then										begin											numToAdd := move-endGaps;											if (numChars + numToAdd > mnChars) then												begin													canMove := false;													NewError(466,0);												end											else												begin													AddNewCharacters (move-endGaps, true);													lastChangeInEditor := lastChangeInsertCharAndCellBlock;												end;										end;								end;							if canMove then								ShiftMolecularDataInTaxon(it,move);						end;				end;		success := true;		if not CheckStateFrequencies(st,et,changedTaxon) then			begin				if not CWarning(concat('Shift Other command has altered state frequencies of taxon ',StringFromNum(changedTaxon),'!  Please report this to clade@arizona.edu!!'), 'Proceed','Cancel') then				  	begin				  		UndoAlignment;				  		success := false;				  	end;			end;		if (oldNumChars<> numChars) & success then			begin				if editorTransposed then					begin						editorSelectionTopLeft.v := sc;						editorSelectionBotRight.v := sc + selectionLength - 1;					end				else					begin						editorSelectionTopLeft.h:= sc;						editorSelectionBotRight.h:= sc + selectionLength - 1;					end;				CalcEditorSelectionRect(editorSelectionTopLeft,editorSelectionBotRight);			end;		InvalidateWindow(editorwindow,true);	end;{----------------------------------------------------------------------------}	function SearchForMaximumMatchBothWays(fixedit, it, searchStartic, searchEndic, threshold: integer; var move: integer; findFirst: boolean): boolean;	var ic, startic, endic: integer;	count : integer;	begin		SearchForMaximumMatchBothWays := false;		// first search if matching region bounded by searchStartic and searchEndic is in moveable piece				// find the characters that corresponds to searchStartic and searchEndic in the moveable sequence		count := 0;		startic := 0;		endic := 0;		for ic := 1 to numchars do			if not HasMissingBit(it,ic) then				begin					count := count + 1;					if count = searchStartic then						startic := ic;					if count = searchEndic then						begin							endic := ic;							leave;						end;				end;		if (startic>0) & (endic>0) then			begin				if SearchForMatch(it,startic, fixedit, endic-startic+1, threshold, move, findFirst) then					begin						SearchForMaximumMatchBothWays := true;					end				else					begin						// didn't work in that direction, so now find the characters that corresponds to searchStartic and searchEndic in the fixed sequence						count := 0;						startic := 0;						endic := 0;						for ic := 1 to numchars do							if not HasMissingBit(fixedit,ic) then								begin									count := count + 1;									if count = searchStartic then										startic := ic;									if count = searchEndic then										begin											endic := ic;											leave;										end;								end;						if (startic>0) & (endic>0) & SearchForMatch(fixedit,startic, it, endic-startic+1, threshold, move, findFirst) then							begin								move := -move;								SearchForMaximumMatchBothWays := true;							end;					end;			end;	end;{-----------------------------------------------------------------------------}	function ShiftMatchDialog(var fixedit, searchStartic, searchEndic: integer; var thresholdValue: double; var findFirst: boolean): boolean;		label			1;		var			theDialog: DialogPtr;			tempP: WindowPtr;			ds: str255;			LI: longint;			localItemHit: integer;			oldFindFirst: boolean;			dd: double;			{...............}	procedure GetEditValuesMatchDialog(itemNumber, min, max: integer; var value: integer);	begin		ds := GetEditText(theDialog, itemNumber);		if StringIsLongint(ds) then			begin				StringToNum(ds, LI);				if (LI<min) | (LI>max) then					begin						Beep;						goto 1;					end				else					value := LI;			end		else			begin				Beep;				goto 1;			end;	end;{...............}	begin		oldFindFirst := findFirst;		StartDLOG(185, theDialog, tempP);		SetDLOGText(theDialog,3, StringFromNum(fixedit), true);		SetDLOGText(theDialog,4, StringFromNum(searchStartic), false);		SetDLOGText(theDialog,5, StringFromNum(searchEndic), false);		ds := "";		RealToString(thresholdValue, ds, 1000.0, 3, false);		SetDLOGText(theDialog,6, ds, false);		ItemCheckMark(theDialog, 12, not findFirst);		myShowDialog(theDialog);		FrameButton(theDialog, 1);1:		repeat			ModalDialog(nil, localItemHit);			if (localItemHit = 12) then				begin					findFirst := not findFirst;					ItemCheckMark(theDialog, 12, not findFirst);				end;		until localItemHit in [1, 2];		if localItemHit = 1 then			begin				GetEditValuesMatchDialog(3, 1, numtaxa, fixedit);				GetEditValuesMatchDialog(4, 1, numchars, searchStartic);				GetEditValuesMatchDialog(5,1, numchars, searchEndic);				dd := TokenToReal(GetEditText(theDialog, 6));				if (dd<=0.0) | (dd>= 1.0) then					begin						Beep;						goto 1;					end;			end		else findFirst := oldFindFirst;		EndDLOG(theDialog, tempP);		ShiftMatchDialog := localitemhit = 1;	end;{----------------------------------------------------------------------------}	procedure QueryShiftAlignment;	var 		sc,ec,st,et, it: integer;		fixedit: integer;		searchStartic, searchEndic, threshold, move, startGaps: integer;		thresholdValue: double;		endGaps: longint;		oldNumChars, numToAdd: integer;		canMove, findFirst: boolean;	begin		if WholeTaxonSel then			begin				CalcSelectedTaxaCharacters(st, et, sc, ec, true);				if not StoreCellBlockForUndo(st, et, 1, numchars, true,false,true) then Exit(QueryShiftAlignment);				//things to query for				fixedit := st;				searchStartic := 20;				searchEndic := 50;				thresholdValue := 0.75;				findFirst := true;								if not ShiftMatchDialog(fixedit, searchStartic, searchEndic, thresholdValue, findFirst) then					Exit(QueryShiftAlignment);				move := 0;				threshold := RoundValue(thresholdValue * (searchEndic - searchStartic+1));				oldNumChars := numChars;				for it := st to et do					if (it<> fixedit) then						begin							if SearchForMaximumMatchBothWays(fixedit, it, searchStartic, searchEndic, threshold, move, findFirst)  & (move<>0) then								begin									canMove := true;									if move<0 then										begin											startGaps := NumStartGaps(it, editortoolstreatMissingAsGaps);											if (startGaps< -move) then												begin													numToAdd := -(startGaps+move);													if (numChars + numToAdd > mnChars) then														begin															canMove := false;															NewError(466,0);														end													else														InsertNewCharacters(numToAdd, 1, molecular);												end;										end									else if move>0 then										begin											endGaps := NumEndGaps(it, editortoolstreatMissingAsGaps);											if (endGaps< move) then												begin													numToAdd := move-endGaps;													if (numChars + numToAdd > mnChars) then														begin															canMove := false;															NewError(466,0);														end													else														AddNewCharacters (move-endGaps, true);												end;										end;									if canMove then										ShiftMolecularDataInTaxon(it,move);								end;						end;				if (oldNumChars<> numChars) then					begin						if editorTransposed then							editorSelectionBotRight.v := numChars						else							editorSelectionBotRight.h := numChars;						CalcEditorSelectionRect(editorSelectionTopLeft,editorSelectionBotRight);					end;				InvalidateWindow(editorwindow,true);			end;	end;{----------------------------------------------------------------------------}	procedure ShowNumNonGaps;	var it,ic: integer;		numnonGaps: longint;		tsts: largestsetchars;	begin		numnonGaps:= 0;		for it := 1 to numtaxa do			for ic := 1 to numchars do				if CharIncluded(ic) then					begin						tsts := gettaxonstsLargest(it, ic);						if tsts <> [MSl,GAl] then							numnonGaps := numnonGaps + 1;					end;		InstantInfo(concat('Number of  non-gaps: ',StringFromNum(numNonGaps)));	end;{-----------------------------------------------------------------------------}	procedure DoEdUtilitiesMenu;  {ItemNo : Integer}		var			serr: OsErr;			{theType: array[0..3] of OSType;}			theType: OSType;			pictFS: FSSpec;			theFile: str255;			db: boolean;	begin		case ItemNo of			RecodeItem: 				DoRecode;			FillItem: 				if ((editorSelectionTopLeft.v = 0) and (editorSelectionBotRight.v = 0)) or ((editorSelectionTopLeft.h = 0) and (editorSelectionBotRight.h = 0)) then					begin						{if OptionEvent(Event) & (TaxonOfCell(editorSelectionTopLeft)>0) then							CondenseNamesDLOG						else if ControlEvent(Event) & (TaxonOfCell(editorSelectionTopLeft)>0) then							begin								PrefixTaxonNamesDLOG;							end						else}						FillNamesDLOG;					end				else					if OptionEvent(Event)  then							ShowStateFreq						else							FillInnerCellDLOG;			ComplementItem: 				{if OptionEvent(Event) then					CalcSumOfPairwise				else }					DNARNAComplement;									RandomFillItem: 				FillSelectedWithRandom;			ShuffleItem: 				ShuffleSelected;			ReverseItem: 				MolecularInvert;			SearchAndReplaceItem: 				{if OptionEvent(Event) then					RemoveTerminalPartTriplets(false)				else}					SearchAndReplace;							UpperCaseItem:				if nucleotides & editorSelected then					SwitchEditorCase(true);							LowerCaseItem:				if nucleotides & editorSelected  then					SwitchEditorCase(false);													CondenseTaxonNamesItem:				if OptionEvent(Event) then					HideTaxonNames				else					CondenseNamesDLOG;							TranslateTaxonNamesItem:				if OptionEvent(Event) then					MakeNamesUnique				else					ImportTaxonTranslation;{$IFC SHIFTMINSTOPS}			ShiftMinimizeStopsItem: 				if nucleotides & WholeTaxonSel & SomeCoding  then					OptimizeStopCodonsInSelected;{$ENDC}{$IFC RESEARCH}		{	ShiftToMatchItem: 				if molecular & WholeTaxonSel then  // & more than one selected!					QueryShiftAlignment;			}						ShiftOtherToMatchItem:				if molecular  then					QueryShiftAlignmentToSelected;{$ENDC}{$IFC MATCHPROTEINALIGN}			ImportProteinAlignmentItem:				db := ChooseImportAlignment(nbrf);{$ENDC}								{$IFC SPEECH}			SpeakMatrixItem: 				if hasSpeechManager then					SpeakMatrix(OptionEvent(Event));			SpeechOptionsItem: 				SpeakSettings;{$ENDC}				xxxxImportPictureItem: 					begin						theType := 'PICT';						{theType[1] := '    ';						theType[2] := '    ';						theType[3] := '    ';}						if ChooseFile(1, ConstSFTypeListPtr(@theType), nil, theFile,pictFS,false,false,false) then							AddFootPictFromFile(pictFS, editorSelectionTopLeft);					end;				xxxxRemovePictureItem: 					begin						if SingleCell then							begin								DestroyFoot(footPict, TaxonOfCell(editorSelectionTopLeft), CharOfCell(editorSelectionTopLeft));								ClosePictWindow;							end						else							RemoveFeetSelected(footPict)					end;			otherwise				;		end;		FixEditMenu;	end;end.