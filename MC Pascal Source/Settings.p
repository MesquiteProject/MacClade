unit Settings;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Palettes,		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, 		GenUtil, StrUtil, BoxUtil, CharUtil, SymbolsNames, WriteUtil, ReadWriteUtil, ReadUtil, NexusBlocks,{$IFC SPEECH}		Speech, {$ENDC}		Legends, InfoWindows, SpreadUtil,ReadWriteGeneticCode, SettingsUtil;	procedure InitLaser;	procedure SetPreferenceValues(theSettings: SettingsPtr; id,action: integer; unmodified: boolean);	procedure ReadSettingsCommandIntoH(whichSettings: integer; unmodified: boolean; subVersionNumber: integer; name: str255);	function ReadNexusPreferencesFile: boolean;	procedure StoreSettingsCommandIntoH(whichSettings: integer; theSettings: SettingsPtr);	procedure StoreSettingsCommandFromIDIntoH(whichSettings: integer; id: integer);	procedure PrepareAllSettingsCommands(whichSettings: integer; prepareAll: boolean);	procedure WriteAllSettingsCommands(whichSettings: integer; writeAll: boolean);	procedure WriteSettingsCommands(whichSettings, id: integer);	procedure WriteMacCladeBlockStart;	procedure WriteNexusPreferencesFile(writeAll: boolean);	procedure SetDialogValuesAsDefaults (theDialog: DialogPtr; id1, id2, id3: integer);		procedure SetToFactoryDefaults(id: integer);	procedure SetAllToFactoryDefaults(whichSettings: integer);	procedure InitFilePreferences;	procedure InitProgramPreferences;	procedure ProcessMacCladePreferencesBlock;	procedure StartSettings;	const		preferencesRead = 0;		preferencesWrite =1;		preferencesFactory=2;				setFileID=1;		setSinglesID= 2;		infoWindowsID=4;		setStateNamesID=5;		setFileCorrelationID = 6;		setFileEndID=6;		setEditorFileID = 7;  {file only}		{program defaults, only reset at start of program}		patkeyid = 256;		colorkeyid = 257;		sumcolorid = 258;		sumpatid = 259;		EntryInterpretid = 260;		searchid = 261;		saveoptionsid = 262;		printOtherFontid = 263;		treewinid = 264;		TraceCharColorid = 265;		TraceChangesColorid = 266;		TraceContsColorid = 267;		Speechid = 268;		useOldPunctID = 270;		palettesID = 271;		paupCommandsID=272;		decayIndexID=273;		proteinColorsID =274;		nucleotideColorsID = 275;		editorToolsID=276;		colorOptionsID = 277;		treeToolsID=278;		bothToolsID=279;{this block should be reset with each new file, and stored in file }	{previously was stored in resource fork}		continuousid = 301;    {**}		setEditorID=302;        {program and file}		setTreeWindowID = 303;  {program and file}		calcid = 304;		summodeid = 305;		laserid = 306;		chartid = 307;		pgsetupid = 308;		NexusOptionsid = 309;  {**}		calcNotationid = 310;		{chartFontsid = 311;}		TipLabelID = 312;		BranchLabelID = 313;		chartPaintid = 314;		BiggestSpotid = 315;		scatterPercentid = 316;		chartPixWidID = 317;		chartVertAxisid = 318;		chartMinMaxid = 319;		traceAllChangesDisplayID = 320;		treeshapeID = 321;		contBranchLabelID = 322;		AllStatesBranchLabelID = 323;		locksID = 324;		autoAlignOptionsID = 325;		gencodeid = 327;		gencodeextraid = 328;		matchCharid = 329;		deftypeid = 330;		polytomyid = 331;		formatid = 332;		gencodenameid = 333;		symbolsid = 334;		othersymbolsid = 335;				undoWarningID = 336;		textWindowsID = 337;		editorSelectionColorID = 338;		chartLogID = 339;		tickOptionsID = 340;		writeHTMLOptionsID = 341;		prettyPrintID = 342;		editWindowPositionID = 343;		treeWindowPositionID = 344;		editorToolsPositionID = 345;		treeToolsPositionID = 346;		chartWindowPositionID = 347;		chLegPositionID = 348;		treeLegPositionID = 349;		warningsID=350;		windowOrderID = 351;		MPRCalculationsID = 352;		ImportSequencesOptionsID = 353;		TreeFontID = 354;{$IFC SPEECH}{    voice: VoiceSpec;}{$ENDC}{еееееееееееееееееееееее}implementation {е$S Settings}{-----------------------------------------------------------------------------}	procedure InitLaser;		var			j: integer;	begin		for j := 0 to maxTraceKinds do			laser^.branchShades[j] := branchPatterns;		laser^.summaryview := summaryview;		with newlaser^ do			begin				ticksNoNames := true;				ticknames := false;				tickboxes := false;				tickstates := false;			end;		with laser^ do			begin				showstepslaser := false;				showtype := true;				laserTreeLegendInit := false;				circleanglept.h := 4;		{get these from string resource 1 in MacClade}				circleanglept.v := -39;   {this is for 6 degrees}				nameanglept.h := 0;		{get these from string resource 1 in MacClade}				nameanglept.v := -40;				for j := 0 to numlaserB do					begin						fonts[j].font := kFontIDGeneva;						fonts[j].size := 9;						fonts[j].face := [];						starts[j].v := 0;						starts[j].h := 0;					end;				fonts[taxanameB].size := 10;				txsp := 0;				versp := 0;				fonts[treenamB].face := [bold];				width := 1;				tracewidth := 8;				square := false;				for j := 0 to numtreeshapes do					begin						treeshape[j] := false;						SetRect(treeshapeB[j], 0, 0, 0, 0);					end;				treeshape[slanttree] := true;				pixelperchg := 10.0;				all := false;				postscripton := true;				condensedTree := true;				databoxes := false;				printequiv := false;				numbernodes := false;				showEvolveSegments := false;				showEvolveRealLengths := false;				treepages.h := 1;				treepages.v := 1;				treesPerPage.h := 1;				treesPerPage.v := 1;				multicharacters := false;				LPPCconstant := false;				LPPCvalue := 2;				scaleon := false;				PrintBranchLengths := false;				mmEnd := mmMean;				mmShow := mmShowBars;			end;		for j := 0 to numlaserB do			begin				laser^.showbox[j] := false;				LaserBoxes^[j].growbox := true;			end;		laser^.showbox[treeB] := true;		laser^.showbox[taxanameB] := true;{    laser^.showbox[treenamB] := true;}{    laser^.showbox[treestatsB] := true;}		laser^.showbox[legB] := true;	end;{-----------------------------------------------------------------------------}	procedure ColorKeyPalettesFromResource(KindOfData: integer);	var		paletteH: PaletteHandle;			j,k: integer;	begin		case KindOfData of			standard:				begin					paletteH := GetNewPalette(1002);					if paletteH <>nil then						begin							GetEntryColor(paletteH,2,colorkey^[2,0]);  							GetEntryColor(paletteH,3,colorkey^[2,1]);  							DisposePalette(paletteH);						end;					for j := 3 to absmaxnumstates do						begin							colorkey^[j,0]:= whiteRGB;							paletteH := GetNewPalette(1000+j);							if paletteH <> nil then								begin									for k := 1 to j-1 do										GetEntryColor(paletteH,k+1,colorkey^[j,k]);  									DisposePalette(paletteH);								end;							colorkey^[j,j-1]:= blackRGB;						end;				end;			DNA:				begin					paletteH := GetNewPalette(129);					if paletteH <>nil then						begin							for j := 0 to maxDNAstate do								GetEntryColor(paletteH,j+2,nucleotideColorKey^[j]);  {have to do +2 because pltt have to have leading black and white}							DisposePalette(paletteH);						end;				end;			protein:				begin					paletteH := GetNewPalette(128);					if paletteH <>nil then						begin							for j := 0 to maxproteinstate do								GetEntryColor(paletteH,j+2,proteinColorKey^[j]);  {have to do +2 because pltt have to have leading black and white}							DisposePalette(paletteH);						end;				end;			otherwise;		end;	end;{-----------------------------------------------------------------------------}	procedure SummaryColorKeyPalettesFromResource;	var		paletteH: PaletteHandle;			j,k: integer;	begin		summarycolors^[0]:= whiteRGB;		summarycolors^[maxchangesshown]:= blackRGB;		paletteH := GetNewPalette(2000);		if paletteH <> nil then			begin				for j := 1 to maxchangesshown-1 do					begin						GetEntryColor(paletteH,j+1,summarycolors^[j]);  					end;			end;		DisposePalette(paletteH);	end;{----------------------------------------------------------------------------}	procedure SetAllFactoryDefaults(whichSettings: integer);	var theSettings: SettingsPtr;	begin		theSettings := baseSettings[whichSettings];		while theSettings<> nil do			begin				SetPreferenceValues(nil,theSettings^.id,preferencesFactory,true);				theSettings:= theSettings^.next;			end;	end;{-----------------------------------------------------------------------------}	procedure InitFilePreferences;{these are reset with opening each file}	begin		symbols := '01';				SetAllFactoryDefaults(fileSettings);						editorMatchAgainstConsensus := false;		colorSetCells := false;		colorCellSet := [];		branchLengthSpacingUser := 1;		screenExtraBranchLength := 4;		writeInTriplets := false;		autoScaleTicks := true;		vertMatrixNames := false;				branchLengthSigDigits := 6;				maxNumberEquivocalCycles := 0;				flashRNARevCompNumMismatches:= 0;		flashRNARevCompIgnoreGaps:= false;		flashFindIgnoreGaps:= false;		findNumMismatches := 0;		{$IFC FLIPTREE}		treeflipped := true;{$ENDC}{$IFC TINKERTOY}		tinkertoy := false;{$ENDC}{$IFC SHADOWTREE}		shadowTree := false;{$ENDC}	end;{-----------------------------------------------------------------------------}	procedure InitProgramPreferences;	begin		SetAllFactoryDefaults(programSettings);			end;{-----------------------------------------------------------------------------}	procedure ProcessPatKey;		var			H: Handle;			oldFPos, oldFileLength, oldReadBufferP, oldreadBufLength: longint;			oldNext: char;			j,k: integer;	begin		H := GetResource('TEXT', 134);		HLock(H);		StartReadingFromHandle(H,oldFPos, oldFileLength, oldReadBufferP, oldreadBufLength,oldnext);		for j := 2 to absmaxnumstates do			for k := 0 to j-1 do				GetSignedByteFromFile(patkey^[j,k]);		EndReadingFromHandle(H,oldFPos, oldFileLength, oldReadBufferP, oldreadBufLength,oldnext);		HUnlock(H);		ReleaseResource(H);	end;{----------------------------------------------------------------------------}	procedure PutWindowOrder;	var 	theWindow: WindowPtr;		editPut,treePut: boolean;	begin		editPut:= false;		treePut := false;		theWindow := frontwindow;		while (theWindow <> nil) & MacCladeWindow(theWindow) do			begin				if WindowVisible(theWindow)&MacCladeWindow(theWindow) then					if IsEditorWindow(theWindow) then						begin							if not editPut then								begin									putSpace;									putToken(GetWindowName(editorWindow));								end;							editPut := true;						end					else if IsTreeWindow(theWindow) then						begin							if not treePut then								begin									putSpace;									putToken(GetWindowName(treeWindow));								end;							treePut := true;						end					else if IsInfoWindow(theWindow) then						begin							putToken(' List ');							putToken(GetWindowName(infoWindow[WhichInfoWindow(theWindow)]));						end					else if IsTextWindow(theWindow) then						begin							putToken(' Text ');							putToken(GetWindowName(textWindow[WhichTextWindow(theWindow)]));						end					else if (theWindow=statesWindow) then						begin							putSpace;							putToken(GetWindowName(statesWindow));						end;				theWindow := myGetNextWindow(theWindow);			end;	end;{----------------------------------------------------------------------------}{----------------------------------------------------------------------------}	procedure GetWindowOrderFromFile;	var ds : str255;		windowNumber, whichInfo, whichText, j: integer;	begin		windowNumber:= 1;		repeat			ds := MakeCaps(GetFileToken(maxtok));			if ds='LIST' then				begin					ds := MakeCaps(GetFileToken(maxtok));  // get name of list window					whichInfo:=noInfo;					for j := 1 to numInfoWindows do						if ds  = MakeCaps(GetWindowName(infoWindow[j])) then							begin								whichInfo := j;								leave;							end;					if whichinfo <> noinfo then						SetWindowOrder(infoWindow[whichinfo],windowNumber);				end			else if ds ='TEXT' then				begin					ds := MakeCaps(GetFileToken(maxtok));					whichText:=notAText;					for j := 1 to numTextWindows do						if ds  = MakeCaps(GetWindowName(textWindow[j])) then							begin								whichText := j;								leave;							end;					if whichText <> notAText then						SetWindowOrder(textWindow[whichText],windowNumber);				end			else if ds = MakeCaps(GetWindowName(treeWindow)) then				SetWindowOrder(treeWindow,windowNumber)			else if ds = MakeCaps(GetWindowName(editorWindow)) then				SetWindowOrder(editorWindow,windowNumber)			else if ds = MakeCaps(GetWindowName(statesWindow)) then				SetWindowOrder(statesWindow,windowNumber);			windowNumber := windowNumber + 1;		until (ds = ';')|(fpos>=mcFileLength);		windowOrderRead := true;	end;	{editor	treeWindow	states	infoWindows	textwindows	}{----------------------------------------------------------------------------}	procedure SetPreferenceValues(theSettings: SettingsPtr; id, action: integer; unmodified: boolean);		var			sH: StringHandle;			ds, oldsymbols: str255;			whichinfo,j,k, taxsetnumber, whichText, subid: integer;			oldFPos, oldFileLength, oldReadBufferP, oldreadBufLength: longint;			oldNext: char;			oldReadon, db: boolean;			olddatatype: integer;			theID : integer;	begin		if action=preferencesRead then			begin				StartReadingFromHandle(theSettings^.H,oldFPos, oldFileLength, oldReadBufferP, oldreadBufLength,oldnext);				oldReadOn := readon;			{	readon:= true;}			end		else if action=preferencesWrite then			StartWritingToHandle(theSettings^.H);		if theSettings<> nil then			begin				theID := theSettings^.id;				subID := theSettings^.subid;			end		else			begin				theID := id;				subID := 0;			end;		case theID of			setFileID:				if action=preferencesRead then					begin						ds := MakeCaps(GetFileToken(maxtok));						if ds = 'EDITOR' then editwasopen := true						else if ds = 'TREEWINDOW' then 							begin								treewasopen := true;								editwasopen := false; 							end;						GetIntegerFromFile(traceShown);						GetIntegerFromFile(curTrace);						GetIntegerFromFile(i);						GetIntegerFromFile(icont);					end				else if action=preferencesWrite then					begin						if editorOpen then 							puttoken('editor ');						if treeopen then 							puttoken('treewindow ');						PutNumberToFile(traceShown);						PutNumberToFile(curTrace);						PutNumberToFile(i);						PutNumberToFile(icont);					end				else if action=preferencesFactory then					begin						editwasopen := true;						treewasopen := false;						editorOpen := false;						treeOpen := false;						traceshown := tracenothing;						curTrace := tracenothing;						i := 1;						icont := 1;					end;			EntryInterpretid :				if action=preferencesRead then					begin						GetBooleanFromFile(ordefsep);						GetBooleanFromFile(interpretStateNames);					end				else if action=preferencesWrite then					begin						putBoolean(ordefsep);						putBoolean(interpretStateNames);					end				else if action=preferencesFactory then					begin						ordefsep := false;						interpretStateNames := true;					end;	{		searchid:				if action=preferencesRead then					begin						GetBooleanFromFile(slowbranchswap);						GetBooleanFromFile(showbranchswappath);						GetBooleanFromFile(quickestdescent);					end				else if action=preferencesWrite then					begin						putBoolean(slowbranchswap);						putBoolean(showbranchswappath);						putBoolean(quickestdescent);					end				else if action=preferencesFactory then					begin						slowbranchswap := false;						showbranchswappath := false;						Quickestdescent := true;					end;}			colorOptionsID:				if action=preferencesRead then					begin						GetBooleanFromFile(sameStateColorsForAllCharacters);						GetBooleanFromFile(useMOSForSameColorsForAll);					end				else if action=preferencesWrite then					begin						putBoolean(sameStateColorsForAllCharacters);						putBoolean(useMOSForSameColorsForAll);					end				else if action=preferencesFactory then					begin						sameStateColorsForAllCharacters := false;						useMOSForSameColorsForAll := false;					end;			saveoptionsid:				if action=preferencesRead then					begin						ds := GetFileToken(maxtok);						for j := 1 to 4 do							pictCreator[j] := ds[j];						for j := 0 to maxFileTypes do							GetIntegerFromFile(ExportDelimiter[j]);						GetBooleanFromFile(writeExpon);						GetBooleanFromFile(alwaysCLAD);						GetBooleanFromFile(nonCLADwarn);					end				else if action=preferencesWrite then					begin						for j := 1 to 4 do							putSingleChar(pictCreator[j]);						for j := 0 to maxFileTypes do							PutNumberToFile(ExportDelimiter[j]);						putSpace;						putBoolean(writeExpon);						putBoolean(alwaysCLAD);						putBoolean(nonCLADwarn);					end				else if action=preferencesFactory then					begin						pictCreator := 'ttxt';						for j := 0 to maxFileTypes do							ExportDelimiter[j] := ExpCR;						ExportDelimiter[MEGA] := ExpCRLF;  {v3.05}						ExportDelimiter[hennig] := ExpCRLF;  {v3.05}						ExportDelimiter[nona] := ExpCRLF;  {v3.05}						ExportDelimiter[malign] := ExpCRLF;  {v3.05}						WriteExpon := true;						alwaysCLAD := true;						nonCLADwarn := false;					end;			treewinid: 				if action=preferencesRead then					begin						GetBooleanFromFile(locklegends);						GetBooleanFromFile(TWfullscreen);					end				else if action=preferencesWrite then					begin						putBoolean(locklegends);						putBoolean(TWfullscreen);					end				else if action=preferencesFactory then					begin						locklegends := true;						twfullscreen := false;  					end;			setTreeWindowID:  				if action=preferencesRead then					begin						GetBooleanFromFile(showNodeNumbers);						GetBooleanFromFile(showEvolveSegments);						GetBooleanFromFile(showEvolveRealLengths);						GetBooleanFromFile(nex7on);					end				else if action=preferencesWrite then					begin						putBoolean(showNodeNumbers);						putBoolean(showEvolveSegments);						putBoolean(showEvolveRealLengths);						putBoolean(nex7on);					end				else if action=preferencesFactory then					begin						showNodeNumbers := false;						showEvolveSegments := false;						showEvolveRealLengths := false;						nex7on := false;					end;			gencodeid:				if action=preferencesRead then					begin						oldsymbols:= symbols;						olddatatype := datatype;						SetDataFormat(protein,true);						ReadCustomGeneticCode;						SetDataFormat(olddatatype,true);						symbols := oldsymbols;					end				else if action=preferencesWrite then					begin						WriteCustomGeneticCode;					end				else if action=preferencesFactory then					begin	{done using SetStandardCode in GeneticCode.p}					end;								gencodenameid:				if action=preferencesRead then					begin						ReadCodeSet;					end				else if action=preferencesWrite then					begin						WriteSetGeneticCode;					end				else if action=preferencesFactory then					begin						theGeneticCode := universalCode;  {v3.05}					end;								gencodeextraid:				if action=preferencesRead then					begin						for j := 1 to 4 do							GetIntegerFromFile(extraAAstates[j]);					end				else if action=preferencesWrite then					begin						for j := 1 to 4 do							PutNumberToFile(extraAAstates[j]);					end				else if action=preferencesFactory then					begin						for j := 1 to 4 do							extraAAstates[j] := -1;					end;													othersymbolsid:				if action=preferencesRead then					begin						andsep := nextdarkchar;						orsep := nextdarkchar;						if (nextdarkchar = '1') then							missing := ' ';  						if (nextdarkchar = '1') then							gap := ' ';  						if missing = ' ' then							next := nextdarkchar						else missing := nextdarkchar;						if gap = ' ' then							next := nextdarkchar						else gap := nextdarkchar;					end				else if action=preferencesWrite then					begin						putSingleChar(andsep);						putSingleChar(orsep);						putSpace;						putBoolean(missing = ' ');						putBoolean(gap = ' ');						putSpace;						if missing=' ' then							putSingleChar(missingDef)						else							putSingleChar(missing);						if gap=' ' then							putSingleChar(gapDef)						else							putSingleChar(gap);					end				else if action=preferencesFactory then					begin						missing := missingDef; 						gap := gapDef;						orsep := orsepDef;						andsep := andsepDef;					end;								setSinglesID:				if action=preferencesRead then					begin						dirtytaxnames := (nextdarkchar = '1') or not unmodified;						GetBooleanFromFile(dirtytree);						resolveOption := TokenToInteger(nextchar, true);					end				else if action=preferencesWrite then					begin						putBoolean(dirtytaxnames);						putBoolean(dirtytree);						putSingleChar(char(resolveOption + 48));					end				else if action=preferencesFactory then					begin						dirtytaxnames := true;						dirtytree := false;						resolveoption := allpossible;					end;								symbolsid:				if action=preferencesRead then					begin						symbols := GetFileToken(maxtok);					end				else if action=preferencesWrite then					begin						putLegalToken(symbols);					end				else if action=preferencesFactory then					begin						symbols := '01'; 					end;			matchCharid:				if action=preferencesRead then					begin						GetBooleanFromFile(matchcharon);						if (nextdarkchar = '1') then  							matchchar := ' ';						if matchchar=' ' then							next := nextdarkchar						else							matchchar := nextdarkchar;					end				else if action=preferencesWrite then					begin						putBoolean(matchcharon);						putBoolean(matchchar = ' ');						putSpace;						if matchchar=' ' then							putSingleChar(matchchardef)						else							putSingleChar(matchchar);					end				else if action=preferencesFactory then					begin						matchcharon := false;						matchchar := matchchardef;					end;			MPRCalculationsID:				if action=preferencesRead then					begin						GetIntegerFromFile(MPRCalculationsMode);					end				else if action=preferencesWrite then					begin						PutNumberToFile(MPRCalculationsMode);					end				else if action=preferencesFactory then					begin						MPRCalculationsMode := MPRNewMode;					end;			ImportSequencesOptionsID:				if action=preferencesRead then					begin						GetBooleanFromFile(allowCLADImportFromFinder);					end				else if action=preferencesWrite then					begin						putBoolean(allowCLADImportFromFinder);					end				else if action=preferencesFactory then					begin						allowCLADImportFromFinder := false;					end;			BranchLabelID:				if action=preferencesRead then					begin						GetBooleanFromFile(showTraceLabels);						GetBooleanFromFile(showfix);						GetBooleanFromFile(tracelabelsbyname);						GetBooleanFromFile(chlegbynames);					end				else if action=preferencesWrite then					begin						putBoolean(showTraceLabels);						putBoolean(showfix);						putBoolean(tracelabelsbyname);						putBoolean(chlegbynames);					end				else if action=preferencesFactory then					begin						showtracelabels := false;						showfix := true;						chlegbynames := true;						tracelabelsbyname := false;					end;			contBranchLabelID:				if action=preferencesRead then					begin						GetBooleanFromFile(ShowContTraceLabels);					end				else if action=preferencesWrite then					begin						putBoolean(ShowContTraceLabels);					end				else if action=preferencesFactory then					begin						ShowContTraceLabels := false;					end;			AllStatesBranchLabelID:				if action=preferencesRead then					begin						GetBooleanFromFile(BranchListStatesBynames);					end				else if action=preferencesWrite then					begin						putBoolean(BranchListStatesBynames);					end				else if action=preferencesFactory then					begin						BranchListStatesBynames := true;					end;			polytomyid:				if action=preferencesRead then					begin							GetBooleanFromFile(polyreal);					end				else if action=preferencesWrite then					begin						putBoolean(polyreal);					end				else if action=preferencesFactory then					begin						polyreal := false;					end;			treeshapeID: 				if action=preferencesRead then					begin						GetSingleFromFile(treeScale);						GetSingleFromFile(treeScaleVert);						GetBooleanFromFile(squareBranches);						GetBooleanFromFile(centerSquareBranches);						GetBooleanFromFile(condensedBranches);						GetBooleanFromFile(showbranchlengths);					end				else if action=preferencesWrite then					begin						PutRealToFile(treeScale,1);						PutRealToFile(treeScaleVert,1);						putSpace;						putBoolean(squareBranches);						putBoolean(centerSquareBranches);						putBoolean(condensedBranches);						putBoolean(showbranchlengths);					end				else if action=preferencesFactory then					begin						treeScale := 1.0;						treeScaleVert := 1.0;						squareBranches := false;						centerSquareBranches := true;						condensedBranches := false;						showBranchLengths := false;					end;			deftypeid:				if action=preferencesRead then					begin						deftype := ConvertToType(MakeSmall(GetFileToken(maxtok)));					end				else if action=preferencesWrite then					begin						if (deftype < usedef) and (deftype <> fisher) then							case deftype of								unordered: 									puttoken('unord');								ordered: 									puttoken('ord');								irreversible: 									puttoken('irrev');								fisher: 									puttoken('strat');								dollo: 									puttoken('Dollo');								otherwise									puttoken(TypeName(deftype));							end						else							InstantError(345);					end				else if action=preferencesFactory then					begin						deftype := unordered;					end;			formatid:				if action=preferencesRead then					begin						GetIntegerFromFile(datatype);						SetDataFormat(datatype, false);					end				else if action=preferencesWrite then					begin						PutNumberToFile(datatype);					end				else if action=preferencesFactory then					begin						datatype := standard;						{Davidv4.1: note that this does not actually fully set data format}					end;			calcNotationid: 				if action=preferencesRead then					begin						GetIntegerFromFile(sigindices);						GetBooleanFromFile(CharInfoExpon);					end				else if action=preferencesWrite then					begin						PutNumberToFile(sigindices);						putSpace;						putBoolean(CharInfoExpon);					end				else if action=preferencesFactory then					begin						sigindices := 2;						CharInfoExpon := true;					end;			setEditorID: {program and file; takes place of editorid}				if action=preferencesRead then					begin						GetBooleanFromFile(editorShowAAwithDNA);						GetBooleanFromFile(editorColorAAwithDNA);						GetBooleanFromFile(editorDimDNAwithAA);						GetBooleanFromFile(editorShowCellSymbol);						GetBooleanFromFile(trackcell);						GetBooleanFromFile(editorTransposed);						GetBooleanFromFile(editorShowFullStateNames);						GetBooleanFromFile(editorShowIUPACSymbols);						GetBooleanFromFile(foottexton);						GetBooleanFromFile(colorCodPosEditor);						GetBooleanFromFile(grid);						GetBooleanFromFile(showTaxNum);						GetBooleanFromFile(showcharnum);						GetBooleanFromFile(showtaxname);						GetBooleanFromFile(editorColorCodPosNumbers);						GetBooleanFromFile(editorColorCodPosTitle);						GetBooleanFromFile(editorColorCodPosCells);						GetBooleanFromFile(editorColorPartitionNumbers);						GetBooleanFromFile(editorColorPartitionTitle);						GetBooleanFromFile(editorColorPartitionCells);						GetBooleanFromFile(editorShadeCharSetTitle);						GetBooleanFromFile(editorShadeCharSetCells);						GetBooleanFromFile(editorShadeCharSetNumbers);						GetBooleanFromFile(editorShadeCharSetLighter);						GetBooleanFromFile(editorColorCellsByFillRect);						GetBooleanFromFile(editorColorCellsDimLowerCase);						next := nextChar;												GetIntegerFromFile(editorColorCellsMode);						GetIntegerFromFile(editorColumnWidth);						GetFontNumberFromFile(editorFont);						GetIntegerFromFile(editorFontSize);						GetIntegerFromFile(editorRowNameWidth);						GetIntegerFromFile(footNoteLines);						ds := MakeCaps(GetFileToken(maxtok));						if (ds <> 'ALL') & (UserLinks[taxsetchain] > 0) then							begin								taxSetNumber := SetNumber(ds, true, taxsetchain);								if taxSetNumber <> notASet then									editorConsensusTaxSet := taxSetNumber+1-PreDefLinks[taxsetChain];							end						else							editorConsensusTaxSet := AllTaxSet;					end				else if action=preferencesWrite then					begin						putBoolean(editorShowAAwithDNA);						putBoolean(editorColorAAwithDNA);						putBoolean(editorDimDNAwithAA);						putBoolean(editorShowCellSymbol);						putBoolean(trackcell);						putBoolean(editorTransposed);						putBoolean(editorShowFullStateNames);						putBoolean(editorShowIUPACSymbols);						putBoolean(foottexton);						putBoolean(colorCodPosEditor);						putBoolean(grid);						putBoolean(showTaxNum);						putBoolean(showcharnum);						putBoolean(showtaxname);						putBoolean(editorColorCodPosNumbers);						putBoolean(editorColorCodPosTitle);						putBoolean(editorColorCodPosCells);						putBoolean(editorColorPartitionNumbers);						putBoolean(editorColorPartitionTitle);						putBoolean(editorColorPartitionCells);						putBoolean(editorShadeCharSetTitle);						putBoolean(editorShadeCharSetCells);						putBoolean(editorShadeCharSetNumbers);						putBoolean(editorShadeCharSetLighter);						putBoolean(editorColorCellsByFillRect);						putBoolean(editorColorCellsDimLowerCase);												PutNumberToFile(editorColorCellsMode);						PutNumberToFile(editorColumnWidth);						PutFontNameToFile(editorFont);						PutNumberToFile(editorFontSize);						PutNumberToFile(editorRowNameWidth);						PutNumberToFile(footNoteLines);						putSpace;						if editorConsensusTaxSet = AllTaxSet then							putToken('all')						else							begin								ds := LinkNameFromChain(taxSetChain,editorConsensusTaxSet+PreDefLinks[taxsetChain]-1);								PrepareToken(ds,maxtok);								putToken(ds);							end;					end				else if action=preferencesFactory then					begin						editorUseTripletColor:= true;						editorShowAAwithDNA:= false;						editorColorAAwithDNA := false;						editorDimDNAwithAA := false;						editorShowCellSymbol := true;						trackcell := true;						editorTransposed := false;						editorShowFullStateNames := false;						editorShowIUPACSymbols := true;						foottexton := true;						colorCodPosEditor := true;						grid := true;						showTaxNum := true;						showCharNum := true;						showTaxName := true;						editorColorCodPosNumbers := true;						editorColorCodPosTitle := false;						editorColorCodPosCells:=false;						editorColorPartitionNumbers := true;						editorColorPartitionTitle := false;						editorColorPartitionCells:=false;						editorShadeCharSetTitle:= false;						editorShadeCharSetCells:= true;						editorShadeCharSetNumbers:= false;						editorShadeCharSetLighter:= false;						editorColorCellsByFillRect := true;						editorColorCellsDimLowerCase := false;																		editorColorCellsMode:= editorColorCellsOff;						editorColumnWidth := 24;						editorFont := kFontIDGeneva;						editorFontSize := 9;						editorRowNameWidth := 100;						footNoteLines := 1;						editorConsensusTaxSet := AllTaxSet;					end;			undoWarningID:				if action=preferencesRead then					begin							GetBooleanFromFile(warnIfCantUndo);					end				else if action=preferencesWrite then					begin						putBoolean(warnIfCantUndo);					end				else if action=preferencesFactory then					begin						warnIfCantUndo := true;					end;								warningsID:				if action=preferencesRead then					begin							GetBooleanFromFile(warnIfUnstoredTreeWillDisappear);					end				else if action=preferencesWrite then					begin						putBoolean(warnIfUnstoredTreeWillDisappear);					end				else if action=preferencesFactory then					begin						warnIfUnstoredTreeWillDisappear := false;					end;			editorSelectionColorID:				if action=preferencesRead then					begin							GetIntegerFromFile(standardSelectionColorNumber);						SetStandardSelectionColor(standardSelectionColorNumber);					end				else if action=preferencesWrite then					begin						PutNumberToFile(standardSelectionColorNumber);					end				else if action=preferencesFactory then					begin						standardSelectionColorNumber := 1;						SetStandardSelectionColor(standardSelectionColorNumber);					end;			chartLogID:				if action=preferencesRead then					begin							GetIntegerFromFile(ChartLogSigDigits);					end				else if action=preferencesWrite then					begin						PutNumberToFile(ChartLogSigDigits);					end				else if action=preferencesFactory then					begin						ChartLogSigDigits := 3;					end;			textWindowsID:				if action=preferencesRead then					begin							ds := GetFileToken(maxtok);  {skip over name of list window}						whichText := subid;						GetWindowPositionFromFile(textWindow[whichText]);						GetFontNumberFromFile(textWindowInfo[whichText]^.font);						GetIntegerFromFile(textWindowInfo[whichText]^.size);						GetStyleFromFile(textWindowInfo[whichText]^.face);						if SizeWindowByBoxStorage(textWindow[whichText]) then							textWindowInfo[whichText]^.hasbeenopen := true;						GetBooleanFromFile(textWindowInfo[whichText]^.wasOpen);						next := nextdarkchar;						if whichText = NexusBlockText then							nexusBlockNameBeingEdited := GetFileToken(maxtok);					end				else if action=preferencesWrite then{note that this will only be written if the window is open at the time}					begin						putLegalToken(theSettings^.subName);  {name of text window}						putSpace;						whichText := subid;						PutWindowPositionToFile(textWindow[whichText]);						PutFontNameToFile(textWindowInfo[whichText]^.font);						PutNumberToFile(textWindowInfo[whichText]^.size);						PutStyleToFile(textWindowInfo[whichText]^.face);						putSpace;						putBoolean(textWindowInfo[whichText]^.open);						putSpace;						if whichText = NexusBlockText then							if nexusBlockBeingEdited<> nil then								begin									ds := nexusBlockBeingEdited^.blockName;									PrepareToken(ds,maxtok);									putToken(ds);								end							else								putToken(notABlockName);					end				else if action=preferencesFactory then					begin			{ can't do this here, as memory for textWindowInfo hasn't been allocated yet on startup!						textWindowInfo[whichText]^.font := kFontIDMonaco;						textWindowInfo[whichText]^.size := 9;						textWindowInfo[whichText]^.face := [];			}						for whichText := 1 to numTextWindows do							textWindowInfo[whichText]^.hasbeenopen := false;						nexusBlockNameBeingEdited := notABlockName;					end;			setEditorFileID:  {just file}				if action=preferencesRead then					begin						GetIntegerFromFile(editorCharacterSetToShade);					end				else if action=preferencesWrite then					begin						PutNumberToFile(editorCharacterSetToShade);					end				else if action=preferencesFactory then					begin						editorCharacterSetToShade := defaultCharSetToShade;   {this is "none"}					end;								windowOrderid:				if action=preferencesRead then					begin						GetWindowOrderFromFile;					end				else if action=preferencesWrite then					begin						PutWindowOrder;					end;									continuousid:				if action=preferencesRead then					begin						GetIntegerFromFile(Continuousmode);						GetIntegerFromFile(sigcontinuous);						GetBooleanFromFile(contWeighted);					end				else if action=preferencesWrite then					begin						PutNumberToFile(Continuousmode);						PutNumberToFile(sigcontinuous);						putSpace;						putBoolean(contWeighted);					end				else if action=preferencesFactory then					begin						continuousmode := manhattan;						sigcontinuous := 3;						contWeighted := true;  {Wayne:v3.5: is this appropriate default?  it was not previously set}					end;			prettyPrintID:				if action=preferencesRead then					begin						GetBooleanFromFile(prettyPrintWhiteSymbols);						GetBooleanFromFile(prettyPrintSpaceBetweenCodons);					end				else if action=preferencesWrite then					begin						putBoolean(prettyPrintWhiteSymbols);						putBoolean(prettyPrintSpaceBetweenCodons);					end				else if action=preferencesFactory then					begin						prettyPrintWhiteSymbols := true;						prettyPrintSpaceBetweenCodons := false;					end;								editWindowPositionID:				if action=preferencesRead then					begin						GetWindowPositionFromFile(editorWindow);						db := SizeWindowByBoxStorage(editorWindow);					end				else if action=preferencesWrite then					PutWindowPositionToFile(editorWindow);			treeWindowPositionID:				if action=preferencesRead then					begin						GetWindowPositionFromFile(treeWindow);						db := SizeWindowByBoxStorage(treeWindow);					end				else if action=preferencesWrite then					PutWindowPositionToFile(treeWindow);			chartWindowPositionID:				if action=preferencesRead then					begin						GetWindowPositionFromFile(chartWindow);						db := SizeWindowByBoxStorage(chartWindow);					end				else if action=preferencesWrite then					PutWindowPositionToFile(chartWindow);			editorToolsPositionID:				if action=preferencesRead then					begin						GetWindowPositionFromFile(toolPaletteWindow[editorTools]);						if SizeWindowByBoxStorage(toolPaletteWindow[editorTools]) then							begin								toolPaletteFirstAppearance[editorTools] := false;								toolPalettePositionRead[editorTools] := true;							end;					end				else if action=preferencesWrite then					PutWindowPositionToFile(toolPaletteWindow[editorTools])				else if action=preferencesFactory then					begin						toolPaletteFirstAppearance[editorTools] := true;						toolPalettePositionRead[editorTools] := false;					end;								treeToolsPositionID:				if action=preferencesRead then					begin						GetWindowPositionFromFile(toolPaletteWindow[treeTools]);						if SizeWindowByBoxStorage(toolPaletteWindow[treeTools]) then							begin								toolPaletteFirstAppearance[treeTools] := false;								toolPalettePositionRead[treeTools] := true;							end;					end				else if action=preferencesWrite then					PutWindowPositionToFile(toolPaletteWindow[treeTools])				else if action=preferencesFactory then					begin						toolPaletteFirstAppearance[treeTools] := true;						toolPalettePositionRead[treetools] := false;					end;						chLegPositionID:				if action=preferencesRead then					begin						GetWindowPositionFromFile(chlegWindow);						if SizeWindowByBoxStorage(chlegWindow) then							CharLegendPositionRead := true;					end				else if action=preferencesWrite then					PutWindowPositionToFile(chlegWindow);						treeLegPositionID:				if action=preferencesRead then					begin						GetWindowPositionFromFile(tlegWindow);						if SizeWindowByBoxStorage(tlegWindow) then							TreeLegendPositionRead := true;					end				else if action=preferencesWrite then					PutWindowPositionToFile(tlegWindow);						writeHTMLOptionsID:				if action=preferencesRead then					begin						writeHTMLPageTitle := GetFileToken(maxtok);						ds := GetFileToken(maxtok);						for j := 1 to 4 do							writeHTMLCreator[j] := ds[j];						GetIntegerFromFile(writeHTMLBlockLength);						GetBooleanFromFile(writeHTMLAsTable);						GetBooleanFromFile(writeHTMLShowGaps);						GetBooleanFromFile(writeHTMLShowCellBorders);						GetBooleanFromFile(writeHTMLCharacterNames);						GetBooleanFromFile(writeHTMLCharacterNumbers);						GetBooleanFromFile(writeHTMLInterleaved);					end				else if action=preferencesWrite then					begin						putLegalToken(writeHTMLPageTitle);  {name of list window}						putSpace;						for j := 1 to 4 do							putSingleChar(writeHTMLCreator[j]);						putSpace;						PutNumberToFile(writeHTMLBlockLength);						putSpace;						putBoolean(writeHTMLAsTable);						putBoolean(writeHTMLShowGaps);						putBoolean(writeHTMLShowCellBorders);						putBoolean(writeHTMLCharacterNames);						putBoolean(writeHTMLCharacterNumbers);						putBoolean(writeHTMLInterleaved);					end				else if action=preferencesFactory then					begin						writeHTMLPageTitle := '';						writeHTMLCreator := 'MOSS';						writeHTMLBlockLength := 100;						writeHTMLAsTable := true;						writeHTMLShowGaps := true;						writeHTMLShowCellBorders := false;						writeHTMLCharacterNames := false;						writeHTMLCharacterNumbers := false;						writeHTMLInterleaved := false;					end;			chartMinMaxid:				if action=preferencesRead then					begin						GetIntegerFromFile(CWScatterMinMax);					end				else if action=preferencesWrite then					begin						PutNumberToFile(CWScatterMinMax);					end				else if action=preferencesFactory then					begin						CWScatterMinMax := CWScatterExtremes;					end;			printOtherFontid:				if action=preferencesRead then					begin						GetFontNumberFromFile(printOtherFonts.font);						GetIntegerFromFile(printOtherFonts.size);						GetStyleFromFile(printOtherFonts.face);					end				else if action=preferencesWrite then					begin						PutFontNameToFile(printOtherFonts.font);						PutNumberToFile(printOtherFonts.size);						PutStyleToFile(printOtherFonts.face);					end				else if action=preferencesFactory then					begin						PrintOtherFonts.font := kFontIDGeneva;						PrintOtherFonts.size := 9;						PrintOtherFonts.face := [];					end;			treeToolsID:				if action=preferencesRead then					begin						GetIntegerFromFile(evolveSegmentsToolMode);						GetIntegerFromFile(horizontalTools[treeTools]);						GetIntegerFromFile(verticalTools[treeTools]);						GetIntegerFromFile(ancestorToolMode);						GetIntegerFromFile(searchAncestorReps);						GetIntegerFromFile(searchAncestorRandomNumber);						GetIntegerFromFile(BLSWhat);						GetBooleanFromFile(showNewTreeWhileSearching);						GetBooleanFromFile(searchForLongTrees);						GetBooleanFromFile(fancySearch);						GetBooleanFromFile(slowbranchswap);						GetBooleanFromFile(showbranchswappath);						GetBooleanFromFile(quickestdescent);						GetBooleanFromFile(rerootToolRootsDrawR);						GetBooleanFromFile(scissorsCutAbove);						GetBooleanFromFile(collapseAllCollapsesAbove);						GetBooleanFromFile(swapAbove);						GetBooleanFromFile(multipleSwaps);						oneSwap := not multipleSwaps;   {do this so even though not in settings}						GetBooleanFromFile(ladderizeRight);						GetBooleanFromFile(paintToolTriesAllStates);						GetBooleanFromFile(queryToolsPopUp);						GetBooleanFromFile(traceTickToolTemporary);						GetBooleanFromFile(SearchAncestorReportReps);						GetBooleanFromFile(searchAncestorStartWithAncestors);					end				else if action=preferencesWrite then					begin						PutNumberToFile(evolveSegmentsToolMode);						PutNumberToFile(horizontalTools[treeTools]);						PutNumberToFile(verticalTools[treeTools]);						PutNumberToFile(ancestorToolMode);						PutNumberToFile(searchAncestorReps);						PutNumberToFile(searchAncestorRandomNumber);						PutNumberToFile(BLSWhat);						putSpace;						putBoolean(showNewTreeWhileSearching);						putBoolean(searchForLongTrees);						putBoolean(fancySearch);						putBoolean(slowbranchswap);						putBoolean(showbranchswappath);						putBoolean(quickestdescent);						putBoolean(rerootToolRootsDrawR);						putBoolean(scissorsCutAbove);						putBoolean(collapseAllCollapsesAbove);						putBoolean(swapAbove);						putBoolean(multipleSwaps);						putBoolean(ladderizeRight);						putBoolean(paintToolTriesAllStates);						putBoolean(queryToolsPopUp);						putBoolean(traceTickToolTemporary);						putBoolean(SearchAncestorReportReps);						putBoolean(searchAncestorStartWithAncestors);					end				else if action=preferencesFactory then					begin						evolveSegmentsToolMode := evolveSegmentsNormalMode;						horizontalTools[treeTools] := 5;						verticalTools[treeTools] := 4;						ancestorToolMode:= ancestorToolNormalMode;						searchAncestorReps := 10;						searchAncestorRandomNumber := 4;						BLSWhat := BLSstates;												showNewTreeWhileSearching := false;						searchForLongTrees := false;						fancySearch := true;						slowbranchswap := false;						showbranchswappath := false;						Quickestdescent := true;						rerootToolRootsDrawR:= true;						scissorsCutAbove:= true;						collapseAllCollapsesAbove:= true;						swapAbove:= true;						multipleSwaps:= true;						oneSwap := not multipleSwaps;   {do this so even though not in settings}						ladderizeRight:= true;						paintToolTriesAllStates:= false;						queryToolsPopUp := true;						traceTickToolTemporary := true;						SearchAncestorReportReps := true;						searchAncestorStartWithAncestors := false;						searchAncestorAbove:= true;					end;			bothToolsID:				if action=preferencesRead then					begin						GetIntegerFromFile(showPicturesMode);					end				else if action=preferencesWrite then					begin						PutNumberToFile(showPicturesMode);					end				else if action=preferencesFactory then					begin						showPicturesMode := showPicturesPopUpMode;					end;			editorToolsID:				if action=preferencesRead then					begin						GetIntegerFromFile(selectToEndMode);						GetIntegerFromFile(magicWandMode);						GetIntegerFromFile(paintBucketMode);						GetIntegerFromFile(paintBucketFillFraction);						GetIntegerFromFile(evolveSegmentsToolMode);						GetIntegerFromFile(selectedBlockMoveMode);						GetIntegerFromFile(horizontalTools[editorTools]);						GetIntegerFromFile(verticalTools[editorTools]);						GetIntegerFromFile(closeGapsMode);																		GetBooleanFromFile(selectToEndIncludeTerminalGaps);						GetBooleanFromFile(blockMovePushBoundaries);						GetBooleanFromFile(blockMoveAccumulate);						GetBooleanFromFile(blockMoveEntireSequence);						GetBooleanFromFile(blockMoveSplitBlockToo);						GetBooleanFromFile(magicWandEntireSequence);						GetBooleanFromFile(editorSortAscending);						GetBooleanFromFile(editorToolsTreatMissingAsGaps);						GetBooleanFromFile(editorScissorsShiftsToStart);						GetBooleanFromFile(editorScissorsWarn);						GetBooleanFromFile(closeGapsTowardEnd);						GetBooleanFromFile(splitBlockEntireSequence);						GetBooleanFromFile(splitBlockPushBoundaries);						GetBooleanFromFile(splitBlockMultiSequence);						GetBooleanFromFile(popUpEnterStates)					end				else if action=preferencesWrite then					begin						PutNumberToFile(selectToEndMode);						PutNumberToFile(magicWandMode);						PutNumberToFile(paintBucketMode);						PutNumberToFile(paintBucketFillFraction);						PutNumberToFile(evolveSegmentsToolMode);						PutNumberToFile(selectedBlockMoveMode);						PutNumberToFile(horizontalTools[editorTools]);						PutNumberToFile(verticalTools[editorTools]);						PutNumberToFile(closeGapsMode);						putSpace;												putBoolean(selectToEndIncludeTerminalGaps);						putBoolean(blockMovePushBoundaries);						putBoolean(blockMoveAccumulate);						putBoolean(blockMoveEntireSequence);						putBoolean(blockMoveSplitBlockToo);						putBoolean(magicWandEntireSequence);						putBoolean(editorSortAscending);						putBoolean(editorToolsTreatMissingAsGaps);						putBoolean(editorScissorsShiftsToStart);						putBoolean(editorScissorsWarn);						putBoolean(closeGapsTowardEnd);						putBoolean(splitBlockEntireSequence);						putBoolean(splitBlockPushBoundaries);						putBoolean(splitBlockMultiSequence);						putBoolean(popUpEnterStates);					end				else if action=preferencesFactory then					begin					{	splitMode := splitNormalMode;  						splitOtherMode := splitOtherNormalMode;}												selectToEndMode := selectToLastCharacterMode;						magicWandMode := magicWandNormalMode;						paintBucketMode:= paintBucketNormalMode;						paintBucketFillFraction := defaultFillFraction;						paintBucketFillCellsWithState := [];						paintBucketPaint := [MSl, GAl];						evolveSegmentsToolMode := evolveSegmentsNormalMode;						selectedBlockMoveMode:=selectedBlockMoveNormalMode;						horizontalTools[editorTools] := 6;						verticalTools[editorTools] := 3;						closeGapsMode := closeGapsCloseAllMode;  //4.08						selectToEndIncludeTerminalGaps := true;						blockMovePushBoundaries:= false;						blockMoveAccumulate:= false;						blockMoveEntireSequence := false;						blockMoveSplitBlockToo := true;  //4.08						magicWandEntireSequence:= false;						editorMagicWandExactMatch := false;						editorSortAscending := true;						editorToolsTreatMissingAsGaps:= false;						editorScissorsShiftsToStart:= true;						editorScissorsWarn := true;						closeGapsTowardEnd := true;						splitBlockEntireSequence:= false;						splitBlockPushBoundaries:= false;						splitBlockMultiSequence:= true;   //4.08						popUpEnterStates := true;					end;				decayIndexID: 				if action=preferencesRead then					begin						decaySearchSubcommandStr := GetFileToken(maxtok);						UnderLineToBlanks(decaySearchSubcommandStr);						GetBooleanFromFile(decaySearchHS);					end				else if action=preferencesWrite then					begin						putLegalToken(decaySearchSubcommandStr);						putSpace;						putBoolean(decaySearchHS);					end				else if action=preferencesFactory then					begin						decaySearchSubcommandStr := '';						decaySearchHS:= true;					end;			paupCommandsID:				if action=preferencesRead then					begin						ds := GetFileToken(maxtok);						UnderLineToBlanks(ds);						copySpecialCustomH1^^ := ds;						ds := GetFileToken(maxtok);						UnderLineToBlanks(ds);						copySpecialCustomH2^^ := ds;						putSpace;						putBoolean(paupCommandCopyToClipBoard);					end				else if action=preferencesWrite then					begin						ds := copySpecialCustomH1^^;						PutLegalToken(ds);						putSpace;						ds := copySpecialCustomH2^^;						PutLegalToken(ds);						GetBooleanFromFile(paupCommandCopyToClipBoard);					end				else if (action=preferencesFactory)  then					begin						sH := GetString(1128);  {Davidv4.1: do i need to set the resource file to use?}						if (sH<>nil)  then							copySpecialCustomH1^^ := sH^^;						sH := GetString(1129);						if (sH<>nil)  then							copySpecialCustomH2^^ := sH^^;						paupCommandCopyToClipBoard:= false;					end;			palettesID:  {should this be one unit, or should the editor and tree paletteOpens be saved separately}				if action=preferencesRead then					begin						for j := 1 to numToolPalettes do							GetBooleanFromFile(toolPaletteOpen[j]);					end				else if action=preferencesWrite then					begin						for j := 1 to numToolPalettes do							putBoolean(toolPaletteOpen[j]);					end				else if action=preferencesFactory then					begin						for j := 1 to numToolPalettes do							toolPaletteOpen[j] := true;					end;			TraceCharColorid :				if action=preferencesRead then					begin						GetIntegerFromFile(defbranchShades[traceDiscrete]);						branchShades[traceDiscrete] := defBranchShades[traceDiscrete];					end				else if action=preferencesWrite then					begin						PutNumberToFile(branchShades[traceDiscrete]);						defbranchShades[traceDiscrete] := BranchShades[traceDiscrete];					end				else if action=preferencesFactory then					begin						if colorQDexists then							begin								defBranchShades[traceDiscrete] := branchColors;								BranchShades[traceDiscrete] := branchColors;							end						else							begin								defBranchShades[traceDiscrete] := branchPatterns;								BranchShades[traceDiscrete] := branchPatterns;							end;					end;			TraceChangesColorid:				if action=preferencesRead then					begin						GetIntegerFromFile(defbranchShades[traceAllChanges]);						branchShades[traceAllChanges] := defBranchShades[traceAllChanges];					end				else if action=preferencesWrite then					begin						PutNumberToFile(branchShades[TraceAllChanges]);						defbranchShades[TraceAllChanges] := BranchShades[TraceAllChanges];					end				else if action=preferencesFactory then					begin						if colorQDexists then							begin								defBranchShades[TraceAllChanges] := branchColors;								BranchShades[TraceAllChanges] := branchColors;							end						else							begin								defBranchShades[TraceAllChanges] := branchPatterns;								BranchShades[TraceAllChanges] := branchPatterns;							end;					end;			TraceContsColorid:				if action=preferencesRead then					begin						GetIntegerFromFile(defbranchShades[traceContinuous]);						branchShades[traceContinuous] := defBranchShades[traceContinuous];					end				else if action=preferencesWrite then					begin						PutNumberToFile(branchShades[traceContinuous]);						defbranchShades[traceContinuous] := BranchShades[traceContinuous];					end				else if action=preferencesFactory then					begin						if colorQDexists then							begin								defBranchShades[traceContinuous] := branchGrayScale;								BranchShades[traceContinuous] := branchGrayScale;							end						else							begin								defBranchShades[traceContinuous] := branchPatterns;								BranchShades[traceContinuous] := branchPatterns;							end;					end;			Speechid:				if action=preferencesRead then					begin						GetIntegerFromFile(speechdelay);						GetLongintFromFile(speechpause);					end				else if action=preferencesWrite then					begin						PutNumberToFile(speechdelay);						PutNumberToFile(speechpause);					end				else if action=preferencesFactory then					begin						speechdelay := 0;						speechpause := 5;					end;			useOldPunctID: 				if action=preferencesRead then					begin						GetBooleanFromFile(useOldPunct);					end				else if action=preferencesWrite then					begin						putBoolean(useOldPunct);					end				else if action=preferencesFactory then					begin						useOldPunct := false;  {v3.05; default changed to false in 3.06}					end;			laserid:				if action=preferencesRead then					begin						GetSingleFromFile(laser^.pixelperchg);						for j := 0 to maxTraceKinds do							GetIntegerFromFile(laser^.branchShades[j]);						for j := 0 to numLaserB do							begin								GetFontNumberFromFile(laser^.fonts[j].font);								GetIntegerFromFile(laser^.fonts[j].size);								GetStyleFromFile(laser^.fonts[j].face);							end;						for j := 0 to numtreeshapes do							begin								GetIntegerFromFile(laser^.treeshapeB[j].top);								GetIntegerFromFile(laser^.treeshapeB[j].bottom);								GetIntegerFromFile(laser^.treeshapeB[j].left);								GetIntegerFromFile(laser^.treeshapeB[j].right);							end;						for j := 0 to numLaserB do							begin								GetIntegerFromFile(laser^.starts[j].v);								GetIntegerFromFile(laser^.starts[j].h);							end;						GetIntegerFromFile(laser^.treepages.v);						GetIntegerFromFile(laser^.treepages.h);						GetIntegerFromFile(laser^.treesPerPage.v);						GetIntegerFromFile(laser^.treesPerPage.h);						GetIntegerFromFile(laser^.anglept.v);						GetIntegerFromFile(laser^.anglept.h);						GetIntegerFromFile(laser^.circleanglept.v);						GetIntegerFromFile(laser^.circleanglept.h);						GetIntegerFromFile(laser^.nameanglept.v);						GetIntegerFromFile(laser^.nameanglept.h);												GetIntegerFromFile(laser^.summaryView);						GetIntegerFromFile(laser^.LPPCvalue);						GetIntegerFromFile(laser^.width);						GetIntegerFromFile(laser^.tracewidth);						GetIntegerFromFile(laser^.txsp);						GetIntegerFromFile(laser^.versp);						GetSignedByteFromFile(laser^.mmShow);						GetSignedByteFromFile(laser^.mmEnd);												for j := 0 to numtreeshapes do							GetBooleanFromFile(laser^.treeshape[j]);						for j := 0 to numlaserB do							GetBooleanFromFile(laser^.showbox[j]);						GetBooleanFromFile(laser^.printbranchlengths);						GetBooleanFromFile(laser^.numbernodes);						GetBooleanFromFile(laser^.showEvolveSegments);						GetBooleanFromFile(laser^.showEvolveRealLengths);						GetBooleanFromFile(laser^.LaserTreeLegendInit);						GetBooleanFromFile(laser^.LPPCconstant);						GetBooleanFromFile(laser^.square);						GetBooleanFromFile(laser^.all);						GetBooleanFromFile(laser^.postscripton);						GetBooleanFromFile(laser^.databoxes);						GetBooleanFromFile(laser^.printequiv);						GetBooleanFromFile(laser^.multicharacters);						GetBooleanFromFile(laser^.scaleon);						GetBooleanFromFile(laser^.showstepslaser);						GetBooleanFromFile(laser^.showtype);						GetBooleanFromFile(laser^.condensedTree);						GetBooleanFromFile(newlaser^.ticksNoNames);						GetBooleanFromFile(newlaser^.tickstates);						GetBooleanFromFile(newlaser^.ticknames);						GetBooleanFromFile(newlaser^.tickboxes);						defLaserShowChLeg := laser^.showbox[legB];					end				else if action=preferencesWrite then					begin						PutRealToFile(laser^.pixelperchg,2);						for j := 0 to maxTraceKinds do							PutNumberToFile(laser^.branchShades[j]);						for j := 0 to numLaserB do							begin								PutFontNameToFile(laser^.fonts[j].font);								PutNumberToFile(laser^.fonts[j].size);								PutStyleToFile(laser^.fonts[j].face);							end;						for j := 0 to numtreeshapes do							begin								PutNumberToFile(laser^.treeshapeB[j].top);								PutNumberToFile(laser^.treeshapeB[j].bottom);								PutNumberToFile(laser^.treeshapeB[j].left);								PutNumberToFile(laser^.treeshapeB[j].right);							end;						for j := 0 to numLaserB do							begin								PutNumberToFile(laser^.starts[j].v);								PutNumberToFile(laser^.starts[j].h);							end;						PutNumberToFile(laser^.treepages.v);						PutNumberToFile(laser^.treepages.h);						PutNumberToFile(laser^.treesPerPage.v);						PutNumberToFile(laser^.treesPerPage.h);						PutNumberToFile(laser^.anglept.v);						PutNumberToFile(laser^.anglept.h);						PutNumberToFile(laser^.circleanglept.v);						PutNumberToFile(laser^.circleanglept.h);						PutNumberToFile(laser^.nameanglept.v);						PutNumberToFile(laser^.nameanglept.h);						PutNumberToFile(laser^.summaryView);						PutNumberToFile(laser^.LPPCvalue); 										PutNumberToFile(laser^.width);						PutNumberToFile(laser^.tracewidth);						PutNumberToFile(laser^.txsp);						PutNumberToFile(laser^.versp);						PutNumberToFile(laser^.mmShow);						PutNumberToFile(laser^.mmEnd);						putSpace;						for j := 0 to numtreeshapes do							putBoolean(laser^.treeshape[j]);						for j := 0 to numlaserB do							putBoolean(laser^.showbox[j]);						putBoolean(laser^.printbranchlengths);						putBoolean(laser^.numbernodes);						putBoolean(laser^.showEvolveSegments);						putBoolean(laser^.showEvolveRealLengths);						putBoolean(laser^.LaserTreeLegendInit);						putBoolean(laser^.LPPCconstant);						putBoolean(laser^.square);						putBoolean(laser^.all);						putBoolean(laser^.postscripton);						putBoolean(laser^.databoxes);						putBoolean(laser^.printequiv);						putBoolean(laser^.multicharacters);								putBoolean(laser^.scaleon);   										putBoolean(laser^.showstepslaser);						putBoolean(laser^.showtype);						putBoolean(laser^.condensedTree);						putBoolean(newlaser^.ticksNoNames);						putBoolean(newlaser^.tickstates);						putBoolean(newlaser^.ticknames);						putBoolean(newlaser^.tickboxes);					end				else if action=preferencesFactory then					begin						InitLaser;					end;			tickOptionsID:				if action=preferencesRead then					begin{$IFC COLORTICKS}						GetIntegerFromFile(colorTicksClass);						GetIntegerFromFile(colorTicksIndexClass);						GetIntegerFromFile(highestValueColor.red);						GetIntegerFromFile(highestValueColor.green);						GetIntegerFromFile(highestValueColor.blue);						GetIntegerFromFile(highValueColor.red);						GetIntegerFromFile(highValueColor.green);						GetIntegerFromFile(highValueColor.blue);						GetIntegerFromFile(lowValueColor.red);						GetIntegerFromFile(lowValueColor.green);						GetIntegerFromFile(lowValueColor.blue);						GetIntegerFromFile(colorTicksBarWidth);						GetIntegerFromFile(colorTicksMinSpaceBetween);{$ENDC}						GetBooleanFromFile(ticknames);						GetBooleanFromFile(tickstates);						GetBooleanFromFile(tickboxes);						GetBooleanFromFile(ticksNoNames);						GetBooleanFromFile(ambigdistinguish);						GetBooleanFromFile(showTickClass);{$IFC COLORTICKS}						GetBooleanFromFile(colorTicksFramed);{$ENDC}					end				else if action=preferencesWrite then					begin{$IFC COLORTICKS}						PutNumberToFile(colorTicksClass);						PutNumberToFile(colorTicksIndexClass);						PutNumberToFile(highestValueColor.red);						PutNumberToFile(highestValueColor.green);						PutNumberToFile(highestValueColor.blue);						PutNumberToFile(highValueColor.red);						PutNumberToFile(highValueColor.green);						PutNumberToFile(highValueColor.blue);						PutNumberToFile(lowValueColor.red);						PutNumberToFile(lowValueColor.green);						PutNumberToFile(lowValueColor.blue);						PutNumberToFile(colorTicksBarWidth);						PutNumberToFile(colorTicksMinSpaceBetween);{$ENDC}						putSpace;						putBoolean(ticknames);						putBoolean(tickstates);						putBoolean(tickboxes);						putBoolean(ticksNoNames);						putBoolean(ambigdistinguish);						putBoolean(showTickClass);{$IFC COLORTICKS}						putBoolean(colorTicksFramed);{$ENDC}					end				else if action=preferencesFactory then					begin{$IFC COLORTICKS}						colorTicksClass := colorTicksNone;						colorTicksIndexClass := colorTicksCI;						highestValueColor.red := 60000;						highestValueColor.green := 10000;						highestValueColor.blue := 10000;						highValueColor.red := 10000;						highValueColor.green := 10000;						highValueColor.blue := 60000;						lowValueColor.red :=65000;						lowValueColor.green := 65000;						lowValueColor.blue := 65000;												colorTicksBarWidth := 6;						colorTicksMinSpaceBetween := 1;{$ENDC}						ticknames := false;						tickstates := false;						tickboxes := false;						ticksNoNames := false;						ambigdistinguish := true;						showTickClass := false;{$IFC COLORTICKS}						colorTicksFramed := true;{$ENDC}					end;			traceAllChangesDisplayID:				if action=preferencesRead then					begin						GetIntegerFromFile(summaryview);						GetBooleanFromFile(BranchListChgbynames);					end				else if action=preferencesWrite then					begin						PutNumberToFile(summaryview);						putSpace;						putBoolean(BranchListChgbynames);					end				else if action=preferencesFactory then					begin						summaryview := aspattern;						BranchListChgBynames := true;					end;			chartVertAxisid:				if action=preferencesRead then					begin						GetBooleanFromFile(axisleft);						GetBooleanFromFile(axisright);						GetBooleanFromFile(CW100Axis);						GetBooleanFromFile(CWScaleToMax);						GetBooleanFromFile(C2TsayShorter);					end				else if action=preferencesWrite then					begin						putBoolean(axisleft);						putBoolean(axisright);						putBoolean(CW100Axis);						putBoolean(CWScaleToMax);						putBoolean(C2TsayShorter);					end				else if action=preferencesFactory then					begin						axisleft := true;						axisright := false;						CW100Axis := true;						C2TsayShorter := true;						CWScaleToMax := false;					end;			chartPixWidID:				if action=preferencesRead then					begin						GetIntegerFromFile(pixwid);						GetBooleanFromFile(autoPixWid);					end				else if action=preferencesWrite then					begin						PutNumberToFile(pixwid);						putSpace;						putBoolean(autoPixWid);					end				else if action=preferencesFactory then					begin						autoPixWid := true;						pixwid := 10;					end;			autoAlignOptionsID:				if action=preferencesRead then					begin						GetIntegerFromFile(alignmentAccuracy);						GetIntegerFromFile(approxAlignRange);						GetIntegerFromFile(gapStartCost);						GetIntegerFromFile(gapExtensionCost);						if (gapStartCost + gapExtensionCost)<=0 then							begin								gapStartCost := 3;								gapExtensionCost := 2;							end;						GetIntegerFromFile(terminalgapStartCost);						GetIntegerFromFile(terminalgapExtensionCost);						if (terminalGapStartCost + terminalGapExtensionCost)<=0 then							begin								terminalGapStartCost := 1;								terminalGapExtensionCost := 1;							end;						GetIntegerFromFile(alignmentChangeCost);						GetIntegerFromFile(alignmentCostMatrix);						GetIntegerFromFile(alignmentInnerCodonCost);					//	for j := -1 to 3 do					//		GetIntegerFromFile(alignmentCodonCosts[j]);												GetBooleanFromFile(alignTreatsTerminalMissingAsGaps);						GetBooleanFromFile(approximateAlignment);						GetBooleanFromFile(useGotohIfPossible);						GetBooleanFromFile(autoAlignSelected);					end				else if action=preferencesWrite then					begin						PutNumberToFile(alignmentAccuracy);						PutNumberToFile(approxAlignRange);						PutNumberToFile(gapStartCost);						PutNumberToFile(gapExtensionCost);						PutNumberToFile(terminalgapStartCost);						PutNumberToFile(terminalgapExtensionCost);						PutNumberToFile(alignmentChangeCost);						PutNumberToFile(alignmentCostMatrix);						PutNumberToFile(alignmentInnerCodonCost);					//	for j := -1 to 3 do					//		PutNumberToFile(alignmentCodonCosts[j]);						putSpace;						putBoolean(alignTreatsTerminalMissingAsGaps);						putBoolean(approximateAlignment);						putBoolean(useGotohIfPossible);						putBoolean(autoAlignSelected);					end				else if action=preferencesFactory then					begin							alignmentAccuracy:= alignmentBest;						approxAlignRange := 2;						gapStartCost := 3;						gapExtensionCost := 2;						alignmentInnerCodonCost := 3;						terminalGapStartCost := 1;						terminalGapExtensionCost := 1;						alignmentChangeCost := 2;						alignmentCostMatrix := unordered;						for j := -1 to 3 do							alignmentCodonCosts[j]:=1;												alignTreatsTerminalMissingAsGaps:= true;						approximateAlignment := false;						useGotohIfPossible := true;						autoAlignSelected := false;					end;								BiggestSpotid:				if action=preferencesRead then					begin						GetBooleanFromFile(CWScatterArea);					end				else if action=preferencesWrite then					begin						putBoolean(CWScatterArea);					end				else if action=preferencesFactory then					begin						CWScatterArea := true;					end;								scatterPercentid:				if action=preferencesRead then					begin						GetBooleanFromFile(CWnormRows);						GetBooleanFromFile(CWPercent);					end				else if action=preferencesWrite then					begin						putBoolean(CWnormRows);						putBoolean(CWPercent);					end				else if action=preferencesFactory then					begin						CWPercent := false;						CWnormRows := true;					end;					colorkeyid:				if action=preferencesRead then					begin						for j := 2 to absmaxnumstates do							for k := 0 to j-1 do								begin									GetIntegerFromFile(colorkey^[j,k].red);									GetIntegerFromFile(colorkey^[j,k].green);									GetIntegerFromFile(colorkey^[j,k].blue);								end;					end				else if action=preferencesWrite then					begin						for j := 2 to absmaxnumstates do							for k := 0 to j-1 do								begin									PutNumberToFile(colorkey^[j,k].red);									PutNumberToFile(colorkey^[j,k].green);									PutNumberToFile(colorkey^[j,k].blue);								end;					end				else if action=preferencesFactory then					begin						ColorKeyPalettesFromResource(standard);					end;			nucleotideColorsID:				if action=preferencesRead then					begin						for k := 0 to maxDNAstate do							begin								GetIntegerFromFile(nucleotidecolorkey^[k].red);								GetIntegerFromFile(nucleotidecolorkey^[k].green);								GetIntegerFromFile(nucleotidecolorkey^[k].blue);							end;					end				else if action=preferencesWrite then					begin						for k := 0 to maxDNAstate do							begin								PutNumberToFile(nucleotidecolorkey^[k].red);								PutNumberToFile(nucleotidecolorkey^[k].green);								PutNumberToFile(nucleotidecolorkey^[k].blue);							end;					end				else if action=preferencesFactory then					begin						ColorKeyPalettesFromResource(DNA);					end;			proteinColorsID:				if action=preferencesRead then					begin						for k := 0 to maxProteinstate do							begin								GetIntegerFromFile(proteinColorkey^[k].red);								GetIntegerFromFile(proteinColorkey^[k].green);								GetIntegerFromFile(proteinColorkey^[k].blue);							end;					end				else if action=preferencesWrite then					begin						for k := 0 to maxProteinstate do							begin								PutNumberToFile(proteinColorkey^[k].red);								PutNumberToFile(proteinColorkey^[k].green);								PutNumberToFile(proteinColorkey^[k].blue);							end;					end				else if action=preferencesFactory then					begin						ColorKeyPalettesFromResource(protein);					end;			sumcolorid:				if action=preferencesRead then					begin						for j := 0 to maxchangesshown do							begin								GetIntegerFromFile(summarycolors^[j].red);								GetIntegerFromFile(summarycolors^[j].green);								GetIntegerFromFile(summarycolors^[j].blue);							end;					end				else if action=preferencesWrite then					begin						for j := 0 to maxchangesshown do							begin								PutNumberToFile(summarycolors^[j].red);								PutNumberToFile(summarycolors^[j].green);								PutNumberToFile(summarycolors^[j].blue);							end;					end				else if action=preferencesFactory then					begin						SummaryColorKeyPalettesFromResource;					end;						patkeyid:				if action=preferencesRead then					begin						for j := 2 to absmaxnumstates do							for k := 0 to j-1 do								GetSignedByteFromFile(patkey^[j,k]);					end				else if action=preferencesWrite then					begin						for j := 2 to absmaxnumstates do							for k := 0 to j-1 do								PutNumberToFile(patkey^[j,k]);					end				else if action=preferencesFactory then					begin						ProcessPatKey;					end;			sumpatid:				if action=preferencesRead then					begin						for j := 0 to maxchangesshown do							GetSignedByteFromFile(summarypat^[j]);					end				else if action=preferencesWrite then					begin						for j := 0 to maxchangesshown do							PutNumberToFile(summarypat^[j]);					end				else if action=preferencesFactory then					begin						for j := 0 to maxchangesshown do							summarypat^[j] := 25;						summarypat^[0] := 0;						summarypat^[1] := 1;						summarypat^[2] := 2;						summarypat^[3] := 4;						summarypat^[4] := 5;						summarypat^[5] := 8;						summarypat^[6] := 9;						summarypat^[7] := 19;						summarypat^[8] := 22;						summarypat^[9] := 25;					end;						chartPaintid:				if action=preferencesRead then					begin						GetIntegerFromFile(histocolor.red);						GetIntegerFromFile(histocolor.green);						GetIntegerFromFile(histocolor.blue);						GetIntegerFromFile(histopat);						GetIntegerFromFile(chartColorMode);						GetBooleanFromFile(CWScatterMultiColor);					end				else if action=preferencesWrite then					begin						PutNumberToFile(histocolor.red);						PutNumberToFile(histocolor.green);						PutNumberToFile(histocolor.blue);						PutNumberToFile(histopat);						PutNumberToFile(chartColorMode);						putSpace;						putBoolean(CWScatterMultiColor);					end				else if action=preferencesFactory then					begin						histocolor.red := $0000;						histocolor.green := $0000;						histocolor.blue := $FFFF;						histopat := 9;  {9 is 50% QDGray,  25 is QDBlack}						CWScatterMultiColor := true;						chartColorMode := chartColorNone;						//chartColorMode := chartColorPartitions;					end;			TipLabelID:				if action=preferencesRead then					begin						GetIntegerFromFile(tiplabel);					end				else if action=preferencesWrite then					begin						PutNumberToFile(tiplabel);					end				else if action=preferencesFactory then					begin						tiplabel := tiptaxa;					end;			TreeFontID:				if action=preferencesRead then					begin						GetFontNumberFromFile(treetaxafont);						GetIntegerFromFile(treetaxafontsize);						GetStyleFromFile(treetaxastyle);					end				else if action=preferencesWrite then					begin						PutFontNameToFile(treetaxafont);						PutNumberToFile(treetaxafontsize);						PutStyleToFile(treetaxastyle);					end				else if action=preferencesFactory then					begin						treetaxafont := kFontIDGeneva;  {was macCladeSmall}						treetaxafontsize := 9;						treetaxastyle := [];					end;			{chartFontsid:   				if action=preferencesRead then					begin						GetFontNumberFromFile(CWfont);						GetIntegerFromFile(CWfontsize);						GetStyleFromFile(CWStyle);					end				else if action=preferencesWrite then					begin						PutFontNameToFile(CWfont);						PutNumberToFile(CWfontsize);						PutStyleToFile(CWStyle);					end				else if action=preferencesFactory then					begin						CWfont := kFontIDGeneva;						CWstyle := [];						CWfontsize := 9;					end;}			chartid:  {---++еееееее++---}{xxx}				if action=preferencesRead then					begin						GetFontNumberFromFile(CWfont);  						GetIntegerFromFile(CWfontsize);						GetStyleFromFile(CWStyle);												GetBooleanFromFile(Chartgrid);						GetBooleanFromFile(CWfullprint);						GetBooleanFromFile(ShowChartTitle);						GetBooleanFromFile(chartQuietRecalc);					end				else if action=preferencesWrite then					begin						PutFontNameToFile(CWfont);						PutNumberToFile(CWfontsize);						PutStyleToFile(CWStyle);						putSpace;						putBoolean(Chartgrid);						putBoolean(CWfullprint);						putBoolean(ShowChartTitle);						putBoolean(chartQuietRecalc);					end				else if action=preferencesFactory then					begin						CWfont := kFontIDGeneva;						CWstyle := [];						CWfontsize := 9;												Chartgrid := false;						CWfullprint := false;						ShowChartTitle := true;						chartQuietRecalc := false;					end;			NexusOptionsid:				if action=preferencesRead then					begin						GetIntegerFromFile(NexusDelim);						GetIntegerFromFile(TreeOrUTree);						GetIntegerFromFile(interleavelength);						GetBooleanFromFile(interleave);						GetBooleanFromFile(saveAmbiguities);						GetBooleanFromFile(saveNonGaps);						GetBooleanFromFile(spaceEveryTenth);						GetBooleanFromFile(saveAbbrevHeader);						GetBooleanFromFile(includeTranslate);						GetBooleanFromFile(singleCharNamePerLine);						GetBooleanFromFile(writeTaxaCharBlocks);						GetBooleanFromFile(fullNexus1);					end				else if action=preferencesWrite then					begin						PutNumberToFile(NexusDelim);						PutNumberToFile(TreeOrUTree);						PutNumberToFile(interleavelength);						putSpace;						putBoolean(interleave);						putBoolean(saveAmbiguities);						putBoolean(saveNonGaps);						putBoolean(spaceEveryTenth);						putBoolean(saveAbbrevHeader);						putBoolean(includeTranslate);						putBoolean(singleCharNamePerLine);						putBoolean(writeTaxaCharBlocks);						putBoolean(fullNexus1);					end				else if action=preferencesFactory then					begin						NexusDelim := ExpCR;						TreeOrUTree := tutRooted;						interleavelength := 50;						interleave := false;						saveAmbiguities := false;						saveNonGaps := true;						spaceEveryTenth := false;						saveAbbrevHeader := true;						includeTranslate := true;						singleCharNamePerLine := false;						nexusSpaceAfterTriplet := false;{$IFC SPACETRIPLETS}						spaceTriplets := true;{$ENDC}						writeTaxaCharBlocks := true;						fullNexus1 := true;	{v3.05:  added feature; changed default to true in v3.08}					end;			infoWindowsID: 				if action=preferencesRead then					begin						whichinfo := subid;						ds := GetFileToken(maxtok);  {skip over name of list window}						infowasOpen[whichinfo] := (MakeCaps(GetFileToken(maxtok)) = 'OPEN');						GetFontNumberFromFile(infoFont[whichinfo] );						GetIntegerFromFile(infoFontSize[whichinfo]);						GetWindowPositionFromFile(infoWindow[whichinfo]);						if SizeWindowByBoxStorage(infoWindow[whichinfo]) then							infoHasBeenOpen[whichinfo] := true;						if whichinfo=taxinfo then							begin								GetBooleanFromFile(taxInfoConsiderAllCharacters);								GetBooleanFromFile(taxInfoShowNucFrequencies);								GetBooleanFromFile(taxInfoShowStopCodons);								GetBooleanFromFile(taxInfoShowFirstBase);								GetBooleanFromFile(taxInfoShowLastBase);								GetBooleanFromFile(taxInfoShowLowerCase);								GetBooleanFromFile(taxInfoShowLowerCase);								GetBooleanFromFile(taxInfoShowUncertainty);								GetBooleanFromFile(taxInfoShowPolymorphism);							end						else if whichinfo=charinfo then							begin								GetBooleanFromFile(charInfoShowMissing);								GetBooleanFromFile(charInfoShowGaps);								GetBooleanFromFile(charInfoShowPartition);							end;					end				else if action=preferencesWrite then					begin						putLegalToken(theSettings^.subName);  {name of list window}						putSpace;						whichinfo := subid;						if infoOpen[whichinfo] then							puttoken('open')						else							puttoken('closed');						PutFontNameToFile(infoFont[whichinfo]);						PutNumberToFile(infoFontSize[whichinfo]);						PutWindowPositionToFile(infoWindow[whichinfo]);						putSpace;						if whichinfo=taxinfo then							begin								putBoolean(taxInfoConsiderAllCharacters);								putBoolean(taxInfoShowNucFrequencies);								putBoolean(taxInfoShowStopCodons);								putBoolean(taxInfoShowFirstBase);								putBoolean(taxInfoShowLastBase);								putBoolean(taxInfoShowLowerCase);								putBoolean(taxInfoShowPartTriplets);								putBoolean(taxInfoShowUncertainty);								putBoolean(taxInfoShowPolymorphism);							end						else if whichinfo=charinfo then							begin								putBoolean(charInfoShowMissing);								putBoolean(charInfoShowGaps);								putBoolean(charInfoShowPartition);							end;					end				else if action=preferencesFactory then					begin  {even though reading and writing here deals with only one list window, for this we do all}						for j := 1 to numInfoWindows do							begin								infoFont[j] := kFontIDGeneva;								infoStyle[j] := [];								infoFontSize[j] := 9;								infoOpen[j] := false;								infoWasOpen[j] := false;								infoHasBeenOpen[j] := false;							end;						taxInfoConsiderAllCharacters := true;						taxInfoShowNucFrequencies := false;						taxInfoShowStopCodons := false;						taxInfoShowFirstBase := false;						taxInfoShowLastBase := false;						taxInfoShowLowerCase := false;						taxInfoShowPartTriplets := false;						taxInfoShowUncertainty := false;						taxInfoShowPolymorphism := false;						nexusBlockInfoShowTitleLink := false;						charInfoShowMissing := false;						charInfoShowGaps := false;						charinfoShowPolymorphisms := false;						charinfoShowUncertainty := false;						charInfoShowPartition := false;					end;								setStateNamesID:				if action=preferencesRead then					begin						statesWindowWasOpen := (MakeCaps(GetFileToken(maxtok)) = 'OPEN');						GetFontNumberFromFile(statesFont);						GetIntegerFromFile(statesFontSize);						GetIntegerFromFile(statesWindowRows);						GetWindowPositionFromFile(statesWindow);						db := SizeWindowByBoxStorage(statesWindow);					end				else if action=preferencesWrite then					begin						if statesWindowOpen then							puttoken('open')						else							puttoken('closed');						PutFontNameToFile(statesFont);						PutNumberToFile(statesFontSize);						PutNumberToFile(statesWindowRows);						PutWindowPositionToFile(statesWindow);					end				else if action=preferencesFactory then					begin						statesWindowWasOpen := false;						statesFont := kFontIDGeneva;						statesFontSize := 9;						statesWindowRows := statesWindowDefaultRows;					end;								setFileCorrelationID: 				if action=preferencesRead then					begin						GetLongintFromFile(statedgains);						GetLongintFromFile(statedlosses);						GetLongintFromFile(maxsample);						GetIntegerFromFile(Compensation);						GetIntegerFromFile(simulationAncestor);						GetBooleanFromFile(actual);						GetBooleanFromFile(firstres);						GetBooleanFromFile(lastres);						GetBooleanFromFile(exactcount);						GetBooleanFromFile(checkabortoften);						GetBooleanFromFile(zeroblack);						GetBooleanFromFile(oneblack);						GetBooleanFromFile(equivblack);					end				else if action=preferencesWrite then					begin						PutNumberToFile(statedgains);						PutNumberToFile(statedlosses);						PutNumberToFile(maxsample);						PutNumberToFile(Compensation);						PutNumberToFile(simulationAncestor);						putSpace;											putBoolean(actual);						putBoolean(firstres);						putBoolean(lastres);						putBoolean(exactcount);						putBoolean(checkabortoften);						putBoolean(zeroblack);						putBoolean(oneblack);						putBoolean(equivblack);					end				else if action=preferencesFactory then					begin						statedgains := 0;						statedlosses := 0;						maxsample := 1000;						compensation := 0;						simulationAncestor := 0;						actual := true;						firstres := false;						lastres := false;						exactcount := true;						checkabortoften := true;						ZeroBlack := false;						OneBlack := true;						EquivBlack := false;					end;								locksID: 				if action=preferencesRead then					begin						GetBooleanFromFile(allEditingLocked);						GetBooleanFromFile(dataLocked);						GetBooleanFromFile(assumptionsLocked);						GetBooleanFromFile(treesLocked);						GetBooleanFromFile(savingLocked);						GetBooleanFromFile(nexusBlocksLocked);						GetBooleanFromFile(editorDisplayLocked);						GetBooleanFromFile(applyLockOnlyToRestrictedVersion);					end				else if action=preferencesWrite then					begin						putBoolean(allEditingLocked);						putBoolean(dataLocked);						putBoolean(assumptionsLocked);						putBoolean(treesLocked);						putBoolean(savingLocked);						putBoolean(nexusBlocksLocked);						putBoolean(editorDisplayLocked);						putBoolean(applyLockOnlyToRestrictedVersion);					end				else if action=preferencesFactory then					begin						allEditingLocked:= false;						dataLocked:= false;						assumptionsLocked:= false;						treesLocked:= false;						savingLocked := false;						nexusBlocksLocked := false;						editorDisplayLocked := false;						applyLockOnlyToRestrictedVersion := true;					end;			summodeid:				if action=preferencesRead then					begin						GetSignedByteFromFile(BranchListmode);						GetSignedByteFromFile(meanByMode);						GetBooleanFromFile(branchlengthsweighted);					end				else if action=preferencesWrite then					begin						PutNumberToFile(BranchListmode);						PutNumberToFile(meanByMode);						putSpace;						putBoolean(branchlengthsweighted);					end				else if action=preferencesFactory then					begin						branchlengthsweighted := false;						meanBymode := meanbyResolutions;						BranchListmode := unambigmode;					end;			calcid:				if action=preferencesRead then					begin						GetBooleanFromFile(calcCI);						GetBooleanFromFile(calcRI);						GetBooleanFromFile(calcRC);						GetBooleanFromFile(calcTreeChanges);						GetBooleanFromFile(showMinSteps);						GetBooleanFromFile(showMaxSteps);						GetBooleanFromFile(count);					end				else if action=preferencesWrite then					begin						putBoolean(calcCI);						putBoolean(calcRI);						putBoolean(calcRC);						putBoolean(calcTreeChanges);						putBoolean(showMinSteps);						putBoolean(showMaxSteps);						putBoolean(count);					end				else if action=preferencesFactory then					begin						calcCI := false;						calcRI := false;						calcRC := false;						calctreechanges := false;						showminsteps := false;						showmaxsteps := false;						count := true;					end;			otherwise;		end;	if action=preferencesRead then		begin			EndReadingFromHandle(theSettings^.H,oldFPos, oldFileLength, oldReadBufferP, oldreadBufLength,oldnext);			readon := oldreadon;		end	else if action=preferencesWrite then		EndWritingToHandle;		end;	{----------------------------------------------------------------------------}	procedure StoreSettingsCommandIntoH(whichSettings: integer; theSettings: SettingsPtr);	begin		SetPreferenceValues(theSettings,0,preferencesWrite,false);	end;{-----------------------------------------------------------------------------}	procedure StoreSettingsCommandFromIDIntoH(whichSettings: integer; id: integer);	var theSettings : SettingsPtr;	begin		theSettings := GetSettingsPtrFromID(whichSettings,id);		if theSettings <> nil then			begin				StoreSettingsCommandIntoH(whichSettings, theSettings);				theSettings^.willWrite := true;			end;	end;{----------------------------------------------------------------------------}	procedure PrepareAllSettingsCommands(whichSettings: integer; prepareAll: boolean);	var theSettings: SettingsPtr;	begin		theSettings := baseSettings[whichSettings];		while theSettings<> nil do			begin				if theSettings^.willWrite or prepareAll then						StoreSettingsCommandIntoH(whichSettings, theSettings);				theSettings:= theSettings^.next;			end;	end;	{----------------------------------------------------------------------------}	procedure ReadSettingsCommandIntoH(whichSettings: integer; unmodified: boolean; subVersionNumber: integer; name: str255);	var startpos, endpos: longint;		theSettings: SettingsPtr;		subName: str255;	begin		startpos:= fpos;		if MultipleSettingsWithName(whichSettings,name) then			subName := GetFileToken(maxtok)		else			subName := '';		theSettings:= GetSettingsPtrFromName(whichSettings,name, subName);		Skipper([';'], false);  		endpos := fpos;		next := nextchar;		if (theSettings <> nil) then			begin			{subversionNumber is the number in the file.			if that version is less than or equal to the one for this version of MacClade, then this version of MacClade should be able to understand it			as long as the subversionNumber is not too old.}				if  (subVersionNumber >= theSettings^.subVersionRequired) & (subVersionNumber <= MacCladeBlockSubVersionNumber) then					begin						FilePiecetoH(startpos, endPos, theSettings^.H);						SetPreferenceValues(theSettings,0,preferencesRead,unmodified);						theSettings^.willWrite := true;					end				else					begin						SetHandleSize(theSettings^.H,0);						if whichSettings=programSettings then theSettings^.willWrite := false;					end;			end;	end;{----------------------------------------------------------------------------}	procedure WriteAllSettingsCommands(whichSettings: integer; writeAll: boolean);	var theSettings: SettingsPtr;		writeSetting: boolean;	begin		theSettings := baseSettings[whichSettings];		while theSettings<> nil do			begin				writeSetting := theSettings^.willWrite | (writeAll& ( theSettings<> baseSettings[whichSettings]));				writeSetting := writeSetting & not ((theSettings^.id=gencodeid)&(theGeneticCode<> customCode));				if writeSetting then						begin						putTab;						putLegalToken(theSettings^.name);						putSpace;						WriteHandle(theSettings^.H,NexusDelim);						putSingleChar(';');						putReturn;					end;				theSettings:= theSettings^.next;			end;	end;{----------------------------------------------------------------------------}	procedure ProcessMacCladePreferencesBlock;	var 		db: boolean;			secs, startpos, endpos: longint;			unmodified: boolean;			ds,capds: str255;			c: char;			whichinfo: integer;			subVersionNumber : integer;	begin		ds := MakeCaps(GetFileToken(maxtok));		if ds='VERSION' then			begin				ds := GetFileToken(maxtok);				if (ds = MacCladeBlockVersionString) | (ds='3.5') then					begin						ds := GetFileToken(maxtok); {get subversion number}						subVersionNumber:= TokenToInteger(ds,false);						Skipper([';'], true);  {skip past semicolon}						ds := MakeCaps(GetFileToken(maxtok));						if (ds = 'LASTMODIFIED') then							begin								StringToNum(GetFileToken(maxtok), secs);								if fileLastModified <> 0 then									unmodified := abs(fileLastModified - secs) <= 1								else									unmodified := false;								Skipper([';'], true);  {skip past semicolon}								repeat									ds := GetFileToken(maxtok);									ReadSettingsCommandIntoH(programSettings,unmodified,subVersionNumber,ds);								until EndOfBlock(ds) or errorflag or (fpos >= mcFileLength);							end;					end;			end;	end;{----------------------------------------------------------------------------}	procedure CycleThroughBlocks;		var			blockName: str255;			theBlock: integer;			db: boolean;	begin		db := false;		repeat			blockName := MakeCaps(GetFileToken(maxtok));			if blockName = 'BEGIN' then				begin					blockName := MakeCaps(GetFileToken(maxtok));					Skipper([';'], true);					if blockName='MACCLADE' then						begin							ProcessMacCladePreferencesBlock;							leave;						end					else						db := FindEndofBlock(0,false);				end;		until (fpos >= mcFileLength);	end;{----------------------------------------------------------------------------}	function ReadNexusPreferencesFile: boolean;		var			blockName: str255;			ds: str255;			oldioThermo: DialogPtr;				begin		if FSpFileExists(FDI^[preferencesFDI].fs) then			begin				tempgencode := gencodePtr(NewPtr(SizeOf(gencodearray)));				FDI^[readFileFDI].fs := FDI^[preferencesFDI].fs;				ioFileFDI := preferencesFDI;				ReadingSettings := true;				oldioThermo := iothermo;				iothermo := nil;				fpos := kInitialReadPos;				blockName := MakeCaps(GetFileToken(maxtok));				if blockName = '#NEXUS' then					begin						CycleThroughBlocks;						ReadNexusPreferencesFile:= true;					end;				ioThermo := oldiothermo;				ReadingSettings := false;				ZapPointer(tempgencode);			end		else			ReadNexusPreferencesFile:= false;	end;{-----------------------------------------------------------------------------}	procedure WriteMacCladeBlockStart;		var			secs: UInt32;	begin		PutTokenReturn('BEGIN MacClade;');		PutTabToken('Version ');		puttoken(MacCladeBlockVersionString);		putSpace;		putSpace;		puttoken(MacCladeBlockSubVersionString);		putSingleChar(';');		putReturn;		PutTabToken('LastModified ');		GetDateTime(secs);		PutToken(StringFromNum(secs));		putSingleChar(';');		putReturn;	end;{-----------------------------------------------------------------------------}	procedure WriteNexusPreferencesFile(writeAll: boolean);	var oldExists: boolean;	begin		SetCursID(scallop);		FDI^[writefileFDI].fs:= FDI^[preferencesFDI].fs;		ioFileFDI := preferencesFDI;		FSpCreateSaveFile(FDI^[writefileFDI].fs, oldexists, 'CLAD', 'pref');				if writeAll then 			PrepareAllSettingsCommands(programSettings, writeAll);				{FSpStampCLAD(FDI^[writefileFDI].fs);}		StartWrite;		if errorflag then 			Exit(WriteNexusPreferencesFile);		PutTokenReturn('#NEXUS');		WriteMacCladeBlockStart;		WriteAllSettingsCommands(programSettings, writeAll);		putEndOfBlock;		EndWrite;		if oldexists then			FSpExchangeFilesDeleteTemp(FDI^[preferencesFDI].fs); 	end;{-----------------------------------------------------------------------------}	procedure SetDialogValuesAsDefaults (theDialog: DialogPtr; id1, id2, id3: integer);	begin		if id1 > 0 then			StoreSettingsCommandFromIDIntoH(programSettings, id1);		if id2 > 0 then			StoreSettingsCommandFromIDIntoH(programSettings, id2);		if id3 > 0 then			StoreSettingsCommandFromIDIntoH(programSettings, id3);		WriteNexusPreferencesFile(false);	end;{-----------------------------------------------------------------------------}	procedure StartSettings;	var j : integer;	begin		writingToHandle:= false;		writingH := nil;				for j := 1 to numSettingLinkedLists do			begin				baseSettings[j] := SettingsPtr(NewPtrClear(SizeOf(settingsRecord)));				InitSettingsPtr(baseSettings[j]);				numSettings[j]:=1;			end;		{set first settings}		AddNewSettings(fileSettings,'FileSettings','',setFileID,0,6,true);		AddNewSettings(fileSettings,'Singles','',setSinglesID,0,6,true);		AddNewSettings(bothSettings,'Editor','',setEditorID,0,86,true);		AddNewSettings(fileSettings,'EditorPosition', '', editWindowPositionID,0,62,true);		AddNewSettings(fileSettings,'TreeWindowPosition', '', treeWindowPositionID,0,62,true);		AddNewSettings(fileSettings,'ListWindow','Characters',infoWindowsID,charinfo,78,true);		AddNewSettings(fileSettings,'ListWindow','Taxa',infoWindowsID,taxinfo,87,true);		AddNewSettings(fileSettings,'ListWindow','Trees',infoWindowsID,treeinfo,71,true);		AddNewSettings(fileSettings,'ListWindow','TypeSets',infoWindowsID,typesetinfo,71,true);		AddNewSettings(fileSettings,'ListWindow','WtSets',infoWindowsID,wtsetinfo,71,true);		AddNewSettings(fileSettings,'ListWindow','ExSets',infoWindowsID,exsetinfo,71,true);		AddNewSettings(fileSettings,'ListWindow','CharSets',infoWindowsID,charsetinfo,71,true);		AddNewSettings(fileSettings,'ListWindow','TaxSets',infoWindowsID,taxsetinfo,71,true);		AddNewSettings(fileSettings,'ListWindow','CharPartitions',infoWindowsID,charpartinfo,71,true);		AddNewSettings(fileSettings,'ListWindow','CharPartNames',infoWindowsID,charpartnameinfo,71,true);		AddNewSettings(fileSettings,'ListWindow','WtSets',infoWindowsID,wtsetinfo,71,true);		AddNewSettings(fileSettings,'TextWindow','AboutFile',textWindowsID,aboutFileText,64,true);		AddNewSettings(fileSettings,'TextWindow','AboutTrees',textWindowsID,aboutTreesText,64,true);		AddNewSettings(fileSettings,'TextWindow','AboutTreeFile',textWindowsID,aboutTreeFileText,64,true);		AddNewSettings(fileSettings,'TextWindow','NexusBlock',textWindowsID,NexusBlockText,64,true);		AddNewSettings(fileSettings,'ChartWindowPosition', '', chartWindowPositionID,0,62,true);		AddNewSettings(fileSettings,'StateNamesSymbols','',setStateNamesID,0,65,true);		AddNewSettings(fileSettings,'WindowOrder','',windowOrderID,0,75,true);		AddNewSettings(bothSettings,'OtherSymbols','',othersymbolsid,0,8,true); 		{AddNewSettings(fileSettings,'Consensus','',setConsensusID,0,true);}		AddNewSettings(fileSettings,'Correlation','',setFileCorrelationID,0,62,true);		AddNewSettings(fileSettings,'Salmo','',locksID,0,38,true);		AddNewSettings(fileSettings,'EditorFile','',setEditorFileID,0,45,true);		AddNewSettings(fileSettings,'ExportHTML','',writeHTMLOptionsID,0,61,true);		AddNewSettings(fileSettings,'PrettyPrint','',prettyPrintID,0,56,true);						AddNewSettings(bothSettings,'CharLegendPosition', '', chLegPositionID,0,63,true);		AddNewSettings(bothSettings,'TreeLegendPosition', '', treeLegPositionID,0,63,true);		AddNewSettings(bothSettings,'EditorToolsPosition', '', editorToolsPositionID,0,62,true);		AddNewSettings(bothSettings,'TreeToolsPosition', '', treeToolsPositionID,0,62,true);				AddNewSettings(bothSettings,'TreeWindowProgram','',treewinid,0,6,true);		AddNewSettings(bothSettings,'TreeWindow','',setTreeWindowID,0,13,true); 		AddNewSettings(bothSettings,'Continuous','',continuousid,0,6,true);		AddNewSettings(bothSettings,'Calculations','',calcid,0,8,true);		AddNewSettings(bothSettings,'SummaryMode','',summodeid,0,37,true);		AddNewSettings(bothSettings,'Charts','',chartid,0,6,true);		AddNewSettings(bothSettings,'NexusOptions','',NexusOptionsid,0,9,true);		{AddNewSettings(bothSettings,'ChartFont','',chartFontsid,0,6,true);}		AddNewSettings(bothSettings,'TipLabel','',TipLabelID,0,74,true);		AddNewSettings(bothSettings,'TreeFont','',TreeFontID,0,74,true);		AddNewSettings(bothSettings,'TreeShape','',treeshapeID,0,63,true);		AddNewSettings(bothSettings,'TraceLabels','',BranchLabelID,0,6,true);		AddNewSettings(bothSettings,'ChartColors','',chartPaintid,0,79,true);		AddNewSettings(bothSettings,'ChartBiggestSpot','',BiggestSpotid,0,6,true);		AddNewSettings(bothSettings,'ChartPercent','',scatterPercentid,0,6,true);		AddNewSettings(bothSettings,'ChartBarWidth','',chartPixWidID,0,6,true);		AddNewSettings(bothSettings,'ChartVerticalAxis','',chartVertAxisid,0,41,true);		AddNewSettings(bothSettings,'ChartMinMax','',chartMinMaxid,0,6,true);		AddNewSettings(bothSettings,'TraceAllChangesDisplay','',traceAllChangesDisplayID,0,49,true);		AddNewSettings(bothSettings,'BarsOnBranchesDisplay','',tickOptionsID,0,53,true);		AddNewSettings(bothSettings,'ContinuousBranchLabels','',contBranchLabelID,0,6,true);		AddNewSettings(bothSettings,'AllStatesBranchLabels','',AllStatesBranchLabelID,0,6,true);		AddNewSettings(bothSettings,'IndexNotation','',calcNotationid,0,6,true);		AddNewSettings(bothSettings,'PrintTree','',laserid,0,30,true);		AddNewSettings(bothSettings,'MatchChar','',matchCharid,0,8,false);  		AddNewSettings(bothSettings,'EntryInterpretation','',EntryInterpretid,0,6,false);		AddNewSettings(bothSettings,'ColorOptions','',colorOptionsID,0,82,false);				AddNewSettings(bothSettings,'TreeTools','',treeToolsID,0,75,true);		AddNewSettings(bothSettings,'EditorTools','',editorToolsID,0,80,true);		AddNewSettings(bothSettings,'PairAlign','',autoAlignOptionsID,0,73,false);		AddNewSettings(bothSettings,'BothTools','',bothToolsID,0,11,false);						AddNewSettings(programSettings,'GeneticCode','',gencodeid,0,6,false);		AddNewSettings(programSettings,'CodeSet','',gencodenameid,0,6,false);		AddNewSettings(programSettings,'ExtraCodeElements','',gencodeextraid,0,8,false);				AddNewSettings(programSettings,'DefaultType','',deftypeid,0,6,false);		AddNewSettings(programSettings,'Polytomies','',polytomyid,0,6,false);		AddNewSettings(programSettings,'Datatype','',formatid,0,6,false);		AddNewSettings(programSettings,'Symbols','',symbolsid,0,6,false);		AddNewSettings(programSettings,'StatePatterns','',patkeyid,0,6,false);		AddNewSettings(programSettings,'StateColors','',colorkeyid,0,6,false);		AddNewSettings(programSettings,'TraceAllColors','',sumcolorid,0,6,false);		AddNewSettings(programSettings,'TraceAllPatterns','',sumpatid,0,6,false);		AddNewSettings(programSettings,'NucleotideColors','',nucleotideColorsID,0,7,false);		AddNewSettings(programSettings,'ProteinColors','',proteinColorsID,0,7,false);		AddNewSettings(programSettings,'UseColorForTraceChar','',TraceCharColorid,0,6,false);		AddNewSettings(programSettings,'UseColorForTraceAll','',TraceChangesColorid,0,6,false);		AddNewSettings(programSettings,'UseColorForTraceConts','',TraceContsColorid,0,6,false);				AddNewSettings(programSettings,'MPRCalcMode','',MPRCalculationsID,0,73,false);  		AddNewSettings(programSettings,'ImportSeqOptions','',ImportSequencesOptionsID,0,73,false);  			{	AddNewSettings(programSettings,'TreeSearch','',searchid,0,6,false);}		AddNewSettings(programSettings,'SaveNexusOptions','',saveoptionsid,0,76,false);		AddNewSettings(programSettings,'PrintOtherFonts','',printOtherFontid,0,6,false);		AddNewSettings(programSettings,'Palettes','',palettesID,0,6,false);		AddNewSettings(programSettings,'Speech','',Speechid,0,6,false);		AddNewSettings(programSettings,'UseOldPunctuation','',useOldPunctID,0,6,false);		AddNewSettings(programSettings,'DecayIndex','',decayIndexID,0,6,false);		AddNewSettings(programSettings,'PAUPCommands','',paupCommandsID,0,26,false);		AddNewSettings(programSettings,'UndoWarning','',undoWarningID,0,52,false);		AddNewSettings(programSettings,'EditorSelectionColor','',editorSelectionColorID,0,37,false);		AddNewSettings(programSettings,'ChartLog','',chartLogID,0,42,false);		AddNewSettings(programSettings,'Warnings','',warningsID,0,64,false);		{AddNewSettings(fileSettings,'PageSetup','',pgsetupid,0,6,true);		}	end;{----------------------------------------------------------------------------}end.