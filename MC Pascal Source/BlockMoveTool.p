unit BlockMoveTool;{ееееееееееееееееееееее}interface	uses		QuickDraw,  		Types, Events, QuickDrawText, OSUtils, TextUtils,Controls, Menus, Files,  Windows, 		Sound, Dialogs, TextEdit, Lists, ToolUtils, Memory, Fonts, Resources, Scrap, 		Globals, WindowUtil, GenUtil, StrUtil, BoxUtil, SetLibInterface, TaxonCHUtil,		CharUtil, MenuUtil, SymbolsNames, TreeUtil, Fill, SpreadUtil, Footnote, DrawSpread, 		RowColumn, StatesWindow, ScrollSpread, CopyPaste, ToolPalette, MoveData, AlignmentUtil,		EditorUndo;		function GapsInDirection(towardStart: boolean; itstart,itend,ic: integer; missingAsGaps: boolean): integer;	procedure ShiftCharacters(st,et,sc,ec, amount: integer; towardStart: boolean; closeGapsMode: integer);	procedure ShiftSelection(direction, amount: integer; collapseGaps: boolean);	procedure MoveSelectedBlockAsFarAsPossible(moveLeft, missingAsGaps: boolean; closeGapsMode: integer);	procedure SpecifySelectedBlockMove(missingAsGaps:boolean; toClick: boolean; clickChar: integer);	procedure TrackBlockMove(originalMousePoint: point; var success, moveOK: boolean; blockMoveKind, whichTool: integer; var oldst, oldet, oldsc, oldec: integer; var oldSelCellTL, oldSelCellBR: point; clickChar: integer);				{ееееееееееееееееееееее}implementation {е$S BlockMoveTool} 	var redrawEditor : boolean;	{----------------------------------------------------------------------------}	function GapsInDirection(towardStart: boolean; itstart,itend,ic: integer; missingAsGaps: boolean): integer;	var 		icCheck, numGaps: integer;	begin		numGaps:= 0;		if towardStart then			begin				if ic > 1 then					 for icCheck := ic-1 downto 1 do					 	if  CheckIfAllGaps(itstart,itend,icCheck, icCheck,missingAsGaps) then					 		numGaps := numGaps+1					 	else					 		leave;			 end		else if ic < numchars then			 for icCheck := ic+1 to numChars do			 	if  CheckIfAllGaps(itstart,itend,icCheck, icCheck,missingAsGaps) then			 		numGaps := numGaps+1			 	else			 		leave;		GapsInDirection := numGaps;	end;{----------------------------------------------------------------------------}	procedure ShiftCharacters(st,et,sc,ec, amount: integer; towardStart: boolean; closeGapsMode: integer);	var it,ic, icSource: integer;		tsts,oldtsts: LargestSetChars;		newAmount: integer;	begin		if molecular then			oldtsts := [MSl, GAl]		else			oldtsts := [MSl];		newAmount := amount;		icSource := 0;		if towardStart then			begin				if sc-amount < 1 then					newAmount := sc-1;				for it := st to et do					begin						if closeGapsMode = closeGapsExactlyOneBaseMode then							begin								if IsGapLike(it,sc,editorToolsTreatMissingAsGaps) then   // edge character is a gap, so just move first non-gap									begin										for ic := sc to ec do											if not IsGapLike(it,ic,editorToolsTreatMissingAsGaps) then 												begin 													tsts := gettaxonstsLargestCase(it, ic);													settaxonstsLargest(it, sc, tsts);													settaxonstsLargest(it, ic, oldtsts);													leave;												end;									end								else   									begin										ic := sc;										icSource := ec+1;										while (ic< ec) do   // look for first gap											begin												ic := ic+1;												if (ic<=numchars) & IsGapLike(it,ic,editorToolsTreatMissingAsGaps) then													begin														icSource := ic;														leave;													end;											end;										for ic := icSource to ec do											if not IsGapLike(it,ic,editorToolsTreatMissingAsGaps) then 												begin 													tsts := gettaxonstsLargestCase(it, ic);													settaxonstsLargest(it, icSource, tsts);													settaxonstsLargest(it, ic, oldtsts);													leave;												end;									end;							end						else							begin								ic := sc-newAmount;								icSource := sc;								while ic <= ec-newAmount do									begin										if closeGapsMode<>closeGapsNormalMode then											begin												if (icSource>ec) then													settaxonstsLargest(it, ic, oldtsts)												else													begin														tsts := gettaxonstsLargestCase(it, icSource);														if IsGapLike(it,icSource,editorToolsTreatMissingAsGaps) then															repeat																icSource := icSource+1;																if (icSource<=ec) then																	tsts := gettaxonstsLargestCase(it, icSource);															until (icSource>ec) | not IsGapLike(it,icSource,editorToolsTreatMissingAsGaps);														if (icSource<=ec) then															begin																settaxonstsLargest(it, ic, tsts);																if (closeGapsMode=closeGapsSingleBaseMode) & (ic<>icSource) then																	settaxonstsLargest(it, icSource, oldtsts);															end														else															settaxonstsLargest(it,ic,oldtsts);  {v4: ideally should have MakeLegalSet?}														if (closeGapsMode=closeGapsSingleBaseMode) then															leave;													end;											end										else											begin												tsts := gettaxonstsLargestCase(it, icSource);												settaxonstsLargest(it, ic, tsts);  {v4: ideally should have MakeLegalSet?}											end;										ic := ic+1;										icSource := icSource+1;									end;						end;					end;				for it := st to et do					for ic := ec-newAmount+1 to ec do						settaxonstsLargest(it, ic, oldtsts);				CheckRedrawFullCharactersInEditor(st,et,sc-newAmount,ec,true);								{if ConsensusSequenceVisible then					WriteAllConsensesForCharacters(sc - newAmount,ec,writeStandardCells,selectionModeAsIs);				if UpdateAsSensitiveToFirstTaxonChange(st) then					begin 						MatchCharUpdate(sc - newAmount, ec);					end;}			end		else   // moving it toward end			begin				if ec+amount > numchars then					newAmount := numchars-ec;				for it := st to et do					begin						if closeGapsMode = closeGapsExactlyOneBaseMode then							begin								if IsGapLike(it,ec,editorToolsTreatMissingAsGaps) then   // edge character is a gap, so just move first non-gap									begin										for ic := ec downto sc do											if not IsGapLike(it,ic,editorToolsTreatMissingAsGaps) then 												begin 													tsts := gettaxonstsLargestCase(it, ic);													settaxonstsLargest(it, ec, tsts);													settaxonstsLargest(it, ic, oldtsts);													leave;												end;									end								else   									begin										ic := ec;										icSource := sc-1;   										while (ic> sc) do   // look for first gap											begin												ic := ic-1;												if (ic>=1) & IsGapLike(it,ic,editorToolsTreatMissingAsGaps) then													begin														icSource := ic;														leave;													end;											end;										for ic := icSource downto sc do											if not IsGapLike(it,ic,editorToolsTreatMissingAsGaps) then 												begin 													tsts := gettaxonstsLargestCase(it, ic);													settaxonstsLargest(it, icSource, tsts);													settaxonstsLargest(it, ic, oldtsts);													leave;												end;									end;							end						else							begin								ic := ec+newAmount;								icSource := ec;								while (ic >= sc+newAmount) do									begin										if (closeGapsMode<>closeGapsNormalMode) then											begin												if (icSource<sc) then													settaxonstsLargest(it, ic, oldtsts)												else													begin														tsts := gettaxonstsLargestCase(it, icSource);														if IsGapLike(it,icSource,editorToolsTreatMissingAsGaps) then															repeat																icSource := icSource-1;																if  (icSource>= sc) then 																	tsts := gettaxonstsLargestCase(it, icSource);															until (icSource<sc) | not IsGapLike(it,icSource,editorToolsTreatMissingAsGaps);														if  (icSource>= sc) then 															begin																settaxonstsLargest(it, ic, tsts);																if (closeGapsMode=closeGapsSingleBaseMode) & (ic<>icSource) then																	settaxonstsLargest(it, icSource, oldtsts);															end														else															settaxonstsLargest(it,ic,oldtsts);  {v4: ideally should have MakeLegalSet?}														if (closeGapsMode=closeGapsSingleBaseMode) then															leave;													end;											end										else											begin												tsts := gettaxonstsLargestCase(it, icSource);												settaxonstsLargest(it, ic, tsts);  {v4: ideally should have MakeLegalSet?}											end;										ic := ic-1;										icSource := icSource-1;									end;						end;					end;				for it := st to et do					for ic := sc to sc+newAmount-1 do						settaxonstsLargest(it, ic, oldtsts);				CheckRedrawFullCharactersInEditor(st,et,sc,ec+newAmount,true);			{	if ConsensusSequenceVisible then					WriteAllConsensesForCharacters(sc, ec+newAmount,writeStandardCells,selectionModeAsIs);				if UpdateAsSensitiveToFirstTaxonChange(st) then					MatchCharUpdate(sc, ec+newAmount);}			end;	end;{----------------------------------------------------------------------------}	procedure ShiftSelection(direction, amount: integer; collapseGaps: boolean);	begin		EraseRect(editorSelectionRect);		InvalidateWindowRect(editorWindow,editorSelectionRect,false);		if direction = upA then			begin				editorSelectionTopLeft.v := editorSelectionTopLeft.v - amount;				editorSelectionBotRight.v := editorSelectionBotRight.v - amount;			end		else if direction = DownA then			begin				editorSelectionTopLeft.v := editorSelectionTopLeft.v + amount;				editorSelectionBotRight.v := editorSelectionBotRight.v + amount;			end		else if direction = leftA then			begin				editorSelectionTopLeft.h := editorSelectionTopLeft.h - amount;				editorSelectionBotRight.h := editorSelectionBotRight.h - amount;			end		else if direction = rightA then			begin				editorSelectionTopLeft.h := editorSelectionTopLeft.h + amount;				editorSelectionBotRight.h := editorSelectionBotRight.h + amount;			end;		CalcEditorSelectionRect(editorSelectionTopLeft, editorSelectionBotRight);		SetDirtyEditor(true);	end;{----------------------------------------------------------------------------}	procedure ShiftCharactersAndSelection(moveLeft: boolean; st,et,sc,ec,amount: integer; closeGapsMode: integer);	var db: boolean;	begin		if not StoreCellBlockForUndo(st, et, sc, ec, true,false,true) then			Exit(ShiftCharactersAndSelection);		ShiftCharacters(st,et,sc,ec,amount,moveLeft,closeGapsMode);		if moveLeft then			begin				if editorTransposed then					ShiftSelection(upA,amount,closeGapsMode<>closeGapsNormalMode)				else					ShiftSelection(leftA,amount,closeGapsMode<>closeGapsNormalMode);			end		else			begin				if editorTransposed then					ShiftSelection(downA,amount,closeGapsMode<>closeGapsNormalMode)				else					ShiftSelection(rightA,amount,closeGapsMode<>closeGapsNormalMode);			end;	end;{----------------------------------------------------------------------------}	procedure MoveSelectedBlockAsFarAsPossible(moveLeft, missingAsGaps: boolean; closeGapsMode: integer);	var st,et,sc,ec,changedTaxon: integer;		amount: integer;	begin		CalcSelectedTaxaCharacters(st, et, sc, ec,true);		StoreStateFrequencies(st,et);		if moveLeft then			amount := GapsInDirection(moveLeft,st,et,sc,missingAsGaps)		else			amount := GapsInDirection(moveLeft,st,et,ec,missingAsGaps);		if (closeGapsMode<>closeGapsNormalMode) then			amount := 0;		if (amount > 0) | (closeGapsMode<>closeGapsNormalMode) then			begin				ShiftCharactersAndSelection(moveLeft,st,et,sc,ec,amount,closeGapsMode);				CheckRedrawFullCharactersInEditor(st,et,sc,ec,true);			end;		if not CheckStateFrequencies(st,et,changedTaxon) then			InstantInfo('Beware!  Tool has altered state frequencies!  Don''t save data, and report this to clade@arizona.edu.');	end;{----------------------------------------------------------------------------}	function RequestedAmountToMoveBlock(maximumToStart,maximumToEnd: integer): integer;	var			theDialog: DialogPtr;			tempP: windowptr;			amount: integer;			localItemHit: integer;			towardStart: boolean;	begin		RequestedAmountToMoveBlock := 0;		if (maximumToStart = 0) & (maximumToEnd=0)  then 			begin				InstantInfo('Block cannot be moved as data would be erased.');				Exit (RequestedAmountToMoveBlock);			end;		towardStart := maximumToEnd = 0;		StartDLOG(170, theDialog, tempP);		SetDLOGText(theDialog, 8, concat('( ▓ ',StringFromNum(maximumToStart),' )'), false);		SetDLOGText(theDialog, 9, concat('( ▓ ',StringFromNum(maximumToEnd),' )'), false);				myShowDialog(theDialog);		EnableDisableDLOGItem(theDialog, 6, maximumToStart > 0,false);		EnableDisableDLOGItem(theDialog, 7, maximumToEnd > 0,false);		SelectDialogItemText(theDialog,3,0,32767);		ItemCheckMark(theDialog,6,towardStart);		ItemCheckMark(theDialog,7,not towardStart);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			if ((localItemHit=6) & not towardStart)| ((localItemHit=7) & towardStart) then				begin					towardStart := not towardStart;					ItemCheckMark(theDialog,6,towardStart);					ItemCheckMark(theDialog,7,not towardStart);				end;		until (localItemHit in [1, 2]);		if localItemHit = 1 then			amount := EditTextInt(TheDialog, 3,true);		EndDLOG(thedialog, tempP);		if localItemHit = 1 then			if towardStart then				begin					if amount > maximumToStart then						amount := maximumToStart;					RequestedAmountToMoveBlock := -amount				end			else				begin					if amount > maximumToEnd then						amount := maximumToEnd;					RequestedAmountToMoveBlock := amount;				end;	end;{----------------------------------------------------------------------------}	procedure SpecifySelectedBlockMove(missingAsGaps:boolean; toClick: boolean; clickChar: integer);	var st,et,sc,ec: integer;		amount, maximumToStart, maximumToEnd: integer;	begin		CalcSelectedTaxaCharacters(st, et, sc, ec,true);		maximumToStart := GapsInDirection(true,st,et,sc,missingAsGaps);		maximumToEnd := GapsInDirection(false,st,et,ec,missingAsGaps);		if toClick then 			begin 				amount := clickChar- sc;				if (amount > maximumToEnd) | (amount < -maximumToStart) then					begin						if not CWarning('There is not enough room to make the requested move without overwriting sequences or going beyond the edges of the matrix. Do you want to move the sequence as far as possible?', 'Move', 'Cancel') then							amount := 0						else if (amount > maximumToEnd) then							amount := maximumToEnd						else amount := -maximumToStart;					end;			end		else			amount:= RequestedAmountToMoveBlock(maximumToStart,maximumToEnd);				if amount < 0 then			ShiftCharactersAndSelection(amount<0,st,et,sc,ec,-amount,closeGapsNormalMode)		else if amount > 0 then			ShiftCharactersAndSelection(amount<0,st,et,sc,ec,amount,closeGapsNormalMode);	end;{-----------------------------------------------------------------------------}{----------------------------------------------------------------------------}	procedure DoMoveCellBlock(cellBlock: CellBlockPtr);	var		db: boolean;	begin	with cellBlock^ do		begin			if not MoveWillEraseCharacters(startTaxa, endTaxa, startChars, endChars, currentStartTaxa, currentEndTaxa, currentStartChars, currentEndChars) then				db :=  PasteCellblock(cellBlock,[],currentStartTaxa, currentEndTaxa, currentStartChars, currentEndChars)			else				begin 					db :=  PasteCellblock(cellBlock,[],startTaxa, endTaxa, startChars, endChars);					InvalidateWindow(editorWindow,true);				end;		end;	end;{-----------------------------------------------------------------------------}	procedure CalcCellBlockRects(cellBlock: CellBlockPtr; bounded: boolean);	var		left, right, top, bottom, d: integer;		TL,BR: point;	begin{calculating cells of boundary of cellblock}		RowColumnFromTaxonCharacter(cellBlock^.currentStartTaxa,cellBlock^.currentStartChars, TL.v,TL.h);		{if lowerSplit then			RowColumnFromTaxonCharacter(cellBlock^.currentEndTaxa,cellBlock^.currentEndChars+1, BR.v,BR.h)		else}			RowColumnFromTaxonCharacter(cellBlock^.currentEndTaxa,cellBlock^.currentEndChars, BR.v,BR.h);{calculating fullRect of cellblock on screen}		CellHor(TL.h,left,d,bounded);		CellHor(BR.h,d, right,bounded);		CellVer(TL.v,top,d,bounded);		CellVer(BR.v,d,bottom,bounded);		SetRect(cellBlock^.fullRect,left,top,right,bottom);		{calculating visibleRect}		if left < editorFirstColumnLeft then			left := editorFirstColumnLeft;		if right > editorMatrixRect.right then			right := editorMatrixRect.right;		if top < editorFirstRowTop then			top := editorFirstRowTop;		if bottom > editorMatrixRect.bottom then			bottom := editorMatrixRect.bottom;		SetRect(cellBlock^.visibleRect, left, top, right, bottom);	end;{-----------------------------------------------------------------------------}	procedure CalcCellBlockVisibleTaxChar(cellBlock: CellBlockPtr);	begin{now calculate which of the characters in the cell block are the ones to be drawn}{we know they are within startchars-endchars, starttaxa-endtaxa}{first, set them to the current start and end of the block}		cellBlock^.visibleStartChars:= cellBlock^.currentStartChars;		cellBlock^.visibleEndChars:= cellBlock^.currentEndChars;		cellBlock^.visibleStartTaxa:= cellBlock^.currentStartTaxa;		cellBlock^.visibleEndTaxa:= cellBlock^.currentEndTaxa;{now we need to shrink the visible chars to fit within what we need}		if (cellBlock^.visibleStartChars < FirstVisibleCharacter) then			 cellBlock^.visibleStartChars := cellBlock^.visibleStartChars+(FirstVisibleCharacter-cellBlock^.visibleStartChars);		if (cellBlock^.visibleStartTaxa < FirstVisibleTaxon) then			 cellBlock^.visibleStartTaxa := cellBlock^.visibleStartTaxa+(FirstVisibleTaxon-cellBlock^.visibleStartTaxa);		if (cellBlock^.visibleEndChars > LastVisibleCharacter) then			 cellBlock^.visibleEndChars := cellBlock^.visibleEndChars-(cellBlock^.visibleEndChars-LastVisibleCharacter);		if (cellBlock^.visibleEndTaxa > LastVisibleTaxon) then			 cellBlock^.visibleEndTaxa := cellBlock^.visibleEndTaxa-(cellBlock^.visibleEndTaxa-LastVisibleTaxon);			 {now we have to reset visible's to be relative to start of cellblock, as data will be obtained from there}		cellBlock^.visibleStartChars := cellblock^.visibleStartchars-cellBlock^.currentStartChars+1;		cellBlock^.visibleEndChars := cellblock^.visibleEndChars-cellBlock^.currentStartChars+1;		cellBlock^.visibleStartTaxa := cellblock^.visibleStartTaxa-cellBlock^.currentStartTaxa+1;		cellBlock^.visibleEndTaxa := cellblock^.visibleEndTaxa-cellBlock^.currentStartTaxa+1;	end;{-----------------------------------------------------------------------------}	procedure CalcCurrentCellBlockPositions (cellBlock: CellBlockPtr; wh: point;  bounded, lowerSplit: boolean; var effectiveOriginalMousePoint,originalMousePoint: point; icScrolled : integer);{calculates the current positions of the clickCell, as well as the fullRect, and the visibleRect}		var			topcell, bottomcell, d: integer;			AddedMoreCharacters: boolean;			leftcell, rightcell: integer;			currentTopLeftMouseCell, currentBotRightMouseCell: point;			quantity: longint;	begin		cellBlock^.currentMouseCell := FindCell(wh, bounded, true);		AddedMoreCharacters := false;				currentTopLeftMouseCell.h := cellBlock^.currentMouseCell.h- cellBlock^.clickCellOffset.h;		currentTopLeftMouseCell.v := cellBlock^.currentMouseCell.v- cellBlock^.clickCellOffset.v;		currentBotRightMouseCell.h := currentTopLeftMouseCell.h + cellBlock^.horCells-1;		currentBotRightMouseCell.v := currentTopLeftMouseCell.v + cellBlock^.vertCells-1;{calculate currentClickCell, considering boundaries}		cellBlock^.currentClickCell := cellBlock^.currentMouseCell;		if editorTransposed then 			begin				if cellBlock^.taxaLocked then cellBlock^.currentClickCell.h := cellBlock^.clickTaxon;				if (currentTopLeftMouseCell.v < cellBlock^.lowerLimit) then					if (bounded | (cellBlock^.lowerLimit>1))  then						cellBlock^.currentClickCell.v := cellBlock^.lowerLimit+cellBlock^.clickCellOffset.v;				if (bounded | (cellBlock^.upperLimit<numchars)) & (currentBotRightMouseCell.v > cellBlock^.upperLimit) then					cellBlock^.currentClickCell.v := cellBlock^.upperLimit-cellBlock^.vertCells+1+ cellBlock^.clickCellOffset.v;				cellBlock^.currentStartChars := cellBlock^.currentClickCell.v - cellBlock^.clickCellOffset.v;				cellBlock^.currentStartTaxa := cellBlock^.currentClickCell.h - cellBlock^.clickCellOffset.h;			end		else			begin				if cellBlock^.taxaLocked then cellBlock^.currentClickCell.v := cellBlock^.clickTaxon;				if (currentTopLeftMouseCell.h < cellBlock^.lowerLimit) then					if (bounded | (cellBlock^.lowerLimit>1)) then						cellBlock^.currentClickCell.h := cellBlock^.lowerLimit+cellBlock^.clickCellOffset.h;				if  (bounded | (cellBlock^.upperLimit<numchars)) & (currentBotRightMouseCell.h > cellBlock^.upperLimit) then					cellBlock^.currentClickCell.h := cellBlock^.upperLimit-cellBlock^.horCells+1+ cellBlock^.clickCellOffset.h;				cellBlock^.currentStartChars := cellBlock^.currentClickCell.h - cellBlock^.clickCellOffset.h;				cellBlock^.currentStartTaxa := cellBlock^.currentClickCell.v - cellBlock^.clickCellOffset.v;			end;		cellBlock^.currentEndChars := cellBlock^.currentStartChars + cellBlock^.nchar-1;		cellBlock^.currentEndTaxa := cellBlock^.currentStartTaxa+ cellBlock^.ntax-1;		if cellBlock^.currentEndChars > numchars then			begin				quantity:= cellBlock^.CurrentEndChars-numchars;				AddNewCharacters(quantity,true);				lastChangeInEditor := lastChangeInsertCharAndCellBlock;				DrawCells(false,false,false);				{add more characters}				cellBlock^.currentStartChars := numchars - cellBlock^.nchar+1;				cellBlock^.currentEndChars := numchars;				cellBlock^.upperLimit := numchars;				cellBlock^.gapsLower := cellBlock^.gapsLower+quantity;				AddedMoreCharacters := true;			end		else if cellBlock^.currentStartChars < 1 then			begin				{insert characters, shift all values over by however many added}				quantity:= 1-cellBlock^.CurrentStartChars;				InsertNewCharacters(quantity,1,true);				lastChangeInEditor := lastChangeInsertCharAndCellBlock;				DrawCells(false,false,false);				cellBlock^.currentStartChars := 1;				cellBlock^.currentEndChars := cellBlock^.currentStartChars + cellBlock^.nchar-1;				cellBlock^.upperLimit := cellBlock^.upperLimit+quantity;				cellBlock^.gapsUpper := cellBlock^.gapsUpper+quantity;				cellBlock^.startChars := cellBlock^.startChars+quantity;				cellBlock^.endChars := cellBlock^.endChars+quantity;				{EWUndoBlockP^.startChars := EWUndoBlockP^.startChars +quantity;				EWUndoBlockP^.endChars := EWUndoBlockP^.startChars +endChars;}				if editorTransposed then 					begin						effectiveOriginalMousePoint.v := effectiveOriginalMousePoint.v + quantity*editorLineWidth;						{originalMousePoint.v := originalMousePoint.v +quantity*editorLineWidth;}						{cellBlock^.currentClickCell.v := cellBlock^.lowerLimit+cellBlock^.clickCellOffset.v;						if (bounded | (cellBlock^.upperLimit<numchars)) & (currentBotRightMouseCell.v > cellBlock^.upperLimit) then							cellBlock^.currentClickCell.v := cellBlock^.upperLimit-cellBlock^.vertCells+1+ cellBlock^.clickCellOffset.v;}						cellBlock^.currentClickCell.v := cellBlock^.currentStartChars + cellBlock^.clickCellOffset.v;					end				else					begin						effectiveOriginalMousePoint.h := effectiveOriginalMousePoint.h + quantity*editorColumnWidth;						{originalMousePoint.h := OriginalMousePoint.h + quantity*editorColumnWidth;}						{if (bounded | (cellBlock^.lowerLimit>1)) & (currentTopLeftMouseCell.h < cellBlock^.lowerLimit) then							cellBlock^.currentClickCell.h := cellBlock^.lowerLimit+cellBlock^.clickCellOffset.h;						if  (bounded | (cellBlock^.upperLimit<numchars)) & (currentBotRightMouseCell.h > cellBlock^.upperLimit) then							cellBlock^.currentClickCell.h := cellBlock^.upperLimit-cellBlock^.horCells+1+ cellBlock^.clickCellOffset.h;}						cellBlock^.currentClickCell.h := cellBlock^.currentStartChars + cellBlock^.clickCellOffset.h;					end;				AddedMoreCharacters := true;			end 		else if (icScrolled <> 0) then				if editorTransposed then 					begin						effectiveOriginalMousePoint.v := effectiveOriginalMousePoint.v - icScrolled*editorLineWidth;						{originalMousePoint.v := originalMousePoint.v +icScrolled*editorLineWidth;}					end				else					begin						effectiveOriginalMousePoint.h := effectiveOriginalMousePoint.h - icScrolled*editorColumnWidth;						{originalMousePoint.h := OriginalMousePoint.h + icScrolled*editorColumnWidth;}					end;							CalcCellBlockRects(cellBlock, bounded);				CalcCellBlockVisibleTaxChar(cellBlock);			 			 		if AddedMoreCharacters then			DrawAndCopyCellBlockImage(cellBlock^.visibleRect, cellBlock^.visiblestarttaxa, cellBlock^.visibleendtaxa, cellBlock^.visiblestartchars, cellBlock^.visibleendchars,writeStandardCells);	end;			{----------------------------------------------------------------------------}	procedure CalculateClickBlockBoundaries(cellblock: CellBlockPtr; allonSide, splitMulti, PartBlock,isLower: boolean);	{allOnSIde is true if Shift is down, will move entire sequence except for end gaps}	{partBlock is true if it is an insertMove; 		isLower is then true if you are moving the lower part of the block,		as opposed to the upper part of the block}		var 	ic,ic2,it: integer;		maxEndChars, minStartChars: longint;	begin	if splitMulti then		begin			with cellBlock^ do 				begin					if allonSide then						begin							minStartChars := FirstNonGap(splitTaxonStart);							maxEndChars := LastNonGap(splitTaxonStart);							for it := splitTaxonStart to splitTaxonEnd do								begin									ic := FirstNonGap(it);									if (ic < minStartChars)  then minStartChars := ic;									ic := LastNonGap(it);									if (ic > maxEndChars)  then maxEndChars := ic;								end;							gapsLower := minStartChars-1;							gapsUpper := numChars-maxEndChars;						end					else						begin							minStartChars := 1;							maxEndChars := numChars;							gapsLower := 0;							gapsUpper := 0;							for ic := cellBlock^.clickCharacter downto 1 do								if CheckIfAllGaps(splitTaxonStart,splitTaxonEnd,ic,ic, editorToolsTreatMissingAsGaps) then									begin										minStartChars := ic+1;										gapsLower := 1;										for ic2 := ic-1 downto 1 do											if CheckIfAllGaps(splitTaxonStart,splitTaxonEnd,ic2,ic2, editorToolsTreatMissingAsGaps) then												gapsLower := gapsLower+1											else												leave;										leave;									end;							for ic := cellBlock^.clickCharacter+1 to numchars do								if CheckIfAllGaps(splitTaxonStart,splitTaxonEnd,ic,ic, editorToolsTreatMissingAsGaps) then									begin										maxEndChars := ic-1;										gapsUpper := 1;										for ic2 := ic+1 to numchars do											if CheckIfAllGaps(splitTaxonStart,splitTaxonEnd,ic2,ic2, editorToolsTreatMissingAsGaps) then												gapsUpper := gapsUpper+1											else												leave;										leave;									end;						end;					startChars := minStartChars;					endChars := maxEndChars;					if isLower then 						begin							cellblock^.endChars := cellBlock^.clickCharacter;							cellBlock^.gapsUpper := 0;						end					else						begin							cellblock^.startChars := cellBlock^.clickCharacter;							cellBlock^.gapsLower := 0; 						end;					lowerLimit := startChars - gapsLower;					upperLimit := endChars + gapsUpper;					ntax := splitTaxonEnd-splitTaxonStart+1;					SizeEdgeTSTS(true,1);					SizeEdgeTSTS(false,1);					nchar := cellblock^.endChars-cellblock^.startChars+1;					starttaxa := splitTaxonStart;					endtaxa := splitTaxonEnd;				end;		end	else 		begin			it := cellBlock^.clickTaxon;			if allonside then  {this is if Shift is down; in which case, you do the Entire sequence, except for gaps at ends}				begin					cellblock^.startChars := FirstNonGap(it);					cellBlock^.gapsLower := cellblock^.startChars-1;					cellblock^.endChars := LastNonGap(it);					cellBlock^.gapsUpper := numchars -cellblock^.endChars;				end			else				begin					cellBlock^.gapsLower := -1;					ic := cellBlock^.clickCharacter;					repeat 						ic := ic-1;					until (ic < 1) | IsGapLike (it,ic,editorToolsTreatMissingAsGaps);  {finding the left boundary of the block}					if (ic<1) then 						begin							ic:=1;							cellBlock^.gapsLower := 0;  {there are no gaps}						end					else ic := ic+1;					cellblock^.startChars := ic;					if cellBlock^.gapsLower = -1 then  {calculate how many gaps there are immediately to the left of the block}						begin							repeat 								ic := ic-1;							until (ic < 1) | not IsGapLike (it,ic,editorToolsTreatMissingAsGaps);							if (ic<1) then ic:=1 else ic := ic+1;							cellBlock^.gapsLower := cellblock^.startChars-ic;						end;											cellBlock^.gapsUpper := -1;					ic := cellBlock^.clickCharacter;					repeat 						ic := ic+1;					until (ic > numchars) | IsGapLike (it,ic,editorToolsTreatMissingAsGaps);  {finding the right boundary of the block}					if (ic> numchars) then 						begin							ic:=numchars;							cellBlock^.gapsUpper := 0;						end					else ic := ic-1;					cellblock^.endChars := ic;					if cellBlock^.gapsUpper = -1 then  {calculate how many gaps there are immediately to the right of the block}						begin							repeat 								ic := ic+1;							until (ic > numchars) | not IsGapLike (it,ic,editorToolsTreatMissingAsGaps);							{if (ic> numchars) then 								ic:=numchars;}							ic := ic - 1;							cellBlock^.gapsUpper := ic - cellblock^.endChars;						end;				end;				if partblock then					if isLower then 						begin							cellblock^.endChars := cellBlock^.clickCharacter;							cellBlock^.gapsUpper := 0;						end					else						begin							cellblock^.startChars := cellBlock^.clickCharacter;							cellBlock^.gapsLower := 0; 						end;				with cellBlock^ do 					begin						lowerLimit := cellblock^.startChars - gapsLower;						upperLimit := cellblock^.endChars + gapsUpper;						ntax := 1;						SizeEdgeTSTS(true,1);						SizeEdgeTSTS(false,1);						nchar := cellblock^.endChars-cellblock^.startChars+1;						starttaxa := it;						endtaxa := it;					end;			end;	end;{----------------------------------------------------------------------------}	procedure CalculateSelectedBlockBoundaries(cellblock: CellBlockPtr);	var ic,it: integer;	begin			if (editorSelectionTopLeft.v < 0) | (editorSelectionTopLeft.h < 0) then				redrawEditor := true;			GetTaxonCharacterFromDataCell(cellBlock^.startTaxa,cellBlock^.startChars, editorSelectionTopLeft,true);			GetTaxonCharacterFromDataCell(cellBlock^.endTaxa,cellBlock^.endChars, editorSelectionBotRight,true);			cellBlock^.ntax := cellBlock^.endTaxa-cellBlock^.startTaxa+1;			SizeEdgeTSTS(true,cellBlock^.ntax);			SizeEdgeTSTS(false,cellBlock^.ntax);			cellBlock^.nchar := cellBlock^.endChars-cellBlock^.startChars+1;			cellBlock^.lowerLimit := cellBlock^.startChars;			cellBlock^.gapsLower := -1;			ic := cellBlock^.startChars - 1;			while (ic>=1) do				if not CheckIfAllGaps(cellBlock^.startTaxa,cellBlock^.endTaxa,ic,ic,false) then					begin						ic := ic+1;						leave;					end				else					ic := ic-1;			if ic = 0 then cellBlock^.lowerLimit := 1			else cellBlock^.lowerLimit := ic;			cellBlock^.gapsLower := cellBlock^.startChars-cellBlock^.lowerLimit;			cellBlock^.upperLimit := cellBlock^.endChars;			ic := cellBlock^.endChars + 1;			while (ic<=numchars) do				if not CheckIfAllGaps(cellBlock^.startTaxa,cellBlock^.endTaxa,ic,ic,false) then					begin						ic := ic-1;						leave;					end				else					ic := ic+1;			if ic > numchars then cellBlock^.upperLimit := numchars			else cellBlock^.upperLimit := ic;			cellBlock^.gapsUpper := cellBlock^.upperLimit-cellBlock^.endchars;	end;{----------------------------------------------------------------------------}{----------------------------------------------------------------------------}	procedure DrawConsensusSequenceNames;	var j, ic: integer;		theConsensus: ConsensusPtr;		consensusRowCol: integer;	begin		genericSetPort(editorWindow);		if ConsensusSequenceVisible then			for j := 1 to editorNumConsensusSequences do				begin					theConsensus := Consensus(j);					if theConsensus <> nil then						begin							RowColumnFromConsensusSequence(consensusRowCol,j);							if editorTransposed then								DrawColName(consensusRowCol,selectionModeOff)							else								DrawRowName(consensusRowCol,selectionModeOff);						end;									end;		end;{----------------------------------------------------------------------------}	procedure CalcConsensusSequenceTotals;	var j, ic: integer;		theConsensus: ConsensusPtr;		tsts: LargestSetChars;		trueMajority: boolean;		dataFraction: double;	begin{		lasttime := TickCount;}		if ConsensusSequenceVisible then			for j := 1 to editorNumConsensusSequences do				begin					theConsensus := Consensus(j);					if theConsensus <> nil then						begin							theConsensus^.modalFreq := 0;							theConsensus^.modalFullFreq := 0;							if theConsensus^.showModalFreqOnMove then								for ic := 1 to numchars do									begin										tsts := GetConsensusSet(j,ic,j=1,false,trueMajority,[],dataFraction);										if tsts <> [] then											begin												theConsensus^.modalFreq := theConsensus^.modalFreq + 1;												if trueMajority then theConsensus^.modalFullFreq := theConsensus^.modalFullFreq + 1;											end;									end;													end;									end;{		InstantInfo(StringFromNum(TickCount - LastTime));}	end;		var oldCellBlockVisibleRect : rect;{----------------------------------------------------------------------------}	procedure TrackCellBlock (cellBlock: CellBlockPtr; wh: point; bounded: boolean; clickChar: integer; lowerSplit, switchingDirections, didScroll: boolean; icScrolled: integer; var effectiveOriginalMousePoint,originalMousePoint: point);{if hangUpperLeft is true, the outline drops down from the cursor, with the cursor at the upperleft of the box}{if bounded is true, then the outline is forced to remain within the confines of the data matrix}		var	justDataAndConsensusRect, exposedBox,oldVisibleInData, hiddenBox: rect;			oldEditorOrigin: point;			db: boolean;			icstart,icend, oldicstart,oldicend,it, ic: integer;			lowestChar, highestChar: integer;	begin		{ScrollEditorToMouse(wh,cellblock,didScroll);}		{now we need to calculate the full rectangle of where the moving block would be now.  		We want to record 3 things:			1. where the block is in terms of characters			2. what the block's rectangle would be			3. what part of the block would be visible on screen}					oldicstart := cellBlock^.currentStartChars;		oldicend := cellBlock^.currentEndChars;		CalcCurrentCellBlockPositions(cellBlock,wh, bounded,lowerSplit,effectiveOriginalMousePoint,originalMousePoint, 0);		blockMoveOn:= true;		SetEWClip(justdataAndConsenses);		SetClip(EWClip);		DrawAndCopyCellBlockImage(cellBlock^.visibleRect, cellBlock^.visiblestarttaxa, cellBlock^.visibleendtaxa, cellBlock^.visiblestartchars, cellBlock^.visibleendchars,writeCellBlock);		if not EqualRect(oldCellBlockVisibleRect,cellBlock^.visibleRect)| didScroll  then { | (cellBlock^.visibleStartChars=FirstVisibleCharacter) | (cellBlock^.visibleEndChars=LastVisibleCharacter)} 			begin				DiffRect(oldCellBlockVisibleRect,cellBlock^.visibleRect, exposedBox,hiddenBox); 	{in exposedBox is returned the part of oldCellBlockVisibleRect that is not present in cellBlock^.visibleRect	in hiddenBox, returns the part of oldCellBlockVisibleRect that is present in cellBlock^.visibleRect}				if not EmptyRect(exposedBox)  then					begin						DrawAndCopyCellBlockImage(exposedBox, 1,1,1,1,writeCellsUnderMovingBlock);						//invertrect(exposedBox);						//SysBeep(2);					end;				if didScroll then					DrawConsensusBlock(cellBlock,FirstVisibleCharacter,LastVisibleCharacter)				else					DrawConsensusBlock(cellBlock,oldicstart,oldicend);				if ConsensusSequenceVisible then					begin						CalcConsensusSequenceTotals;						DrawConsensusSequenceNames;					end;				DrawCellBlockBoundaryAAwithDNA(cellBlock, oldicstart,oldicend, selectionModeOff);				{FillRect(oldCellBlockVisibleRect, QDGray);}			end;		blockMoveOn:= false;		oldCellBlockVisibleRect := cellBlock^.visibleRect;	end;{----------------------------------------------------------------------------}	procedure TrackBlockMove(originalMousePoint: point; var success, moveOK: boolean; blockMoveKind, whichTool: integer; var oldst, oldet, oldsc, oldec: integer; var oldSelCellTL, oldSelCellBR: point; clickChar: integer);	label 2,3;	var		st, et, sc, ec,itstart,itend: integer;		oldnumchars: integer;		left, right, top, bottom: integer;		cell, wh, datacell, oldwh, startPoint: point;		bounded, isLower, wasIsLower: boolean;		 it,ic: integer;		icstart,icend, chartotal: integer;		 moveUnselectedBlock, splitBlock, wasOption: boolean;		 didScroll,scrolledOnce: boolean;		 oldClip: RgnHandle;		 splitwh: point;		effectiveOriginalMousePoint: point;		 splitic, originalit: integer;		 isLowerCalculated, moveEntireSequence, switchingDirections: boolean;		 firstTimeThrough: boolean;		 originalMouseBoundaryPoint: point;		 db, splitMoveAllOnOneSide: boolean;		 d, lowerChar,icScrolled,changedTaxon: integer;		 tempOldVisibleRect: rect;		 pointMoved: point;	begin//	rewrite(debugfile, 'consensus');		{selectedBlockMove is default};{setting values}		scrolledOnce := false;		redrawEditor := false;		SetRect(oldCellBlockVisibleRect,0,0,0,0);		genericSetPort(editorWindow);		firsttimethrough:= true;		EWCurrentDrawBlockP:= nil;		splitBlock := (blockMoveKind = splitBlockMove)|(blockMoveKind=splitMultiBlockMove);		splitMoveAllOnOneSide := (splitBlockEntireSequence & (blockMoveKind=splitBlockMove) & (whichTool=splitBlockT))|(blockMoveEntireSequence & (blockMoveKind=splitBlockMove) & (whichTool=blockMoveT));		moveEntireSequence := splitMoveAllOnOneSide |  (splitBlockEntireSequence & (blockMoveKind=splitMultiBlockMove))| (blockMoveEntireSequence & (blockMoveKind=unselectedBlockMove));		moveUnselectedBlock  := blockMoveKind = unselectedBlockMove;		bounded:= not ((splitBlock & splitBlockPushBoundaries & (whichTool=splitBlockT))|(splitBlock & blockMovePushBoundaries & (whichTool=blockMoveT)) | (moveUnselectedBlock & blockMovePushBoundaries));		success := true;		switchingDirections:= false;		effectiveOriginalMousePoint:=originalMousePoint;		for ic := 1 to numchars do			SetNewlyInsertedCharacter(ic,false);				{finding taxa and cell original values}		datacell := FindCell(originalMousePoint, false, false);		GetTaxonCharacterFromDataCell(originalit,ic,datacell,false);		if blockMoveKind = splitMultiBlockMove then			begin				itstart := splitTaxonStart;				itend := splitTaxonEnd;				originalit := splitTaxonStart;			end		else			begin				itstart := originalit;				itend := originalit;			end;		if blockMoveKind=selectedBlockMove then			begin				if not StoreSelectedCellBlockForUndo(true,false,true) then					Exit(TrackBlockMove);			end		else			if (itstart+itend=0) | (ic=0) | not StoreCellBlockForUndo(itstart,itend,ic,ic, true,false,false) then					Exit(TrackBlockMove);{this is where we need to start again if we are accumulating sticky blocks}3:		wh := effectiveOriginalMousePoint;               		isLower := not JustAboveCellLine(not editorTransposed,wh) ;		if isLower then lowerChar := ic		else lowerChar := ic-1;		if not EditorTransposed then			begin				originalMouseBoundaryPoint.v := originalMousePoint.v;				CellHor(lowerChar,d,originalMouseBoundaryPoint.h,true);			end		else			begin				originalMouseBoundaryPoint.h := originalMousePoint.h;				CellVer(lowerChar,d,originalMouseBoundaryPoint.v,true);			end;		wasIsLower := isLower;		isLowerCalculated:= true;		datacell := FindCell(wh, false, false);		GetTaxonCharacterFromDataCell(it,ic,datacell,false);		it := originalit;		if blockMoveKind=splitMultiBlockMove then			begin				itstart := splitTaxonStart;				itend := splitTaxonEnd;			end		else			begin				itstart := it;				itend := it;			end;		StoreStateFrequencies(itstart,itend);		EWCurrentDrawBlockP:= EWMoveBlockP;{old label 2 spot}{this is where we start again if we are using the split block tool and have changed direction}2:		startPoint := effectiveOriginalMousePoint;		wh := startPoint;		datacell := FindCell(wh, false, false);		GetTaxonCharacterFromDataCell(it,ic,datacell,false);		it := originalit;					if blockMoveKind=splitBlockMove then			begin				if isLowerCalculated then					if JustAboveCellLine(not editorTransposed,wh) & isLower then						ic := ic-1					else if not JustAboveCellLine(not editorTransposed,wh) & not isLower then						ic := ic+1;								splitic := ic;				if isLower then splitic := ic+1;				if IsGapLike(it,splitic,editorToolsTreatMissingAsGaps) & not IsGapLike(it,splitic-1,editorToolsTreatMissingAsGaps) then					begin						moveUnselectedBlock  := true;						splitic := splitic-1;						splitBlock:= false;						EWCurrentDrawBlockP:= nil;						Beep;						Exit(TrackBlockMove);					end				else if not IsGapLike(it,splitic,editorToolsTreatMissingAsGaps) & IsGapLike(it,splitic-1,editorToolsTreatMissingAsGaps) then					begin						moveUnselectedBlock  := true;						splitBlock:= false;						EWCurrentDrawBlockP:= nil;						Beep;						Exit(TrackBlockMove);					end;			end		else if blockMoveKind=splitMultiBlockMove then			begin				if isLowerCalculated then					if JustAboveCellLine(not editorTransposed,wh) & isLower then						ic := ic-1					else if not JustAboveCellLine(not editorTransposed,wh) & not isLower then						ic := ic+1;								splitic := ic;				if isLower then splitic := ic+1;			end;						wh := startPoint;		EWMoveBlockP^.taxaLocked := true;		EWMoveBlockP^.clickTaxon := it;		EWMoveBlockP^.clickCharacter := ic;		EWMoveBlockP^.lowerLimit := 0;		EWMoveBlockP^.upperLimit := 0;{Calculate clickCell}		RowColumnFromTaxonCharacter(it,ic,EWMoveBlockP^.clickCell.v,EWMoveBlockP^.clickCell.h);		EWMoveBlockP^.currentMouseCell := EWMoveBlockP^.clickCell;		EWMoveBlockP^.currentClickCell := EWMoveBlockP^.clickCell;{Calculate click offset from upper left corner of that cell}		CellHor(EWMoveBlockP^.clickCell.h, left, right, true);		CellVer(EWMoveBlockP^.clickCell.v, top, bottom, true);		EWMoveBlockP^.offSetToCellTopLeft.h := startPoint.h - left;		EWMoveBlockP^.offSetToCellTopLeft.v := startPoint.v - top;		{where label 1 was}{Calculate the boundaries of the block to move, including how far down and up it can be moved}		EmptyCellBlock(EWMoveBlockP);		if blockMoveKind = selectedBlockMove then			CalculateSelectedBlockBoundaries(EWMoveBlockP)		else			CalculateClickBlockBoundaries(EWMoveBlockP,moveEntireSequence, blockMoveKind=splitMultiBlockMove, splitBlock, isLower);		{if splitBlock then 			if editorTransposed then 				begin					if isLower then						startPoint.v := originalMousePoint.v-editorLineWidth div 2					else						startPoint.v := originalMousePoint.v;					wh.v := startPoint.v;				end			else				begin					if isLower then						startPoint.h:= originalMousePoint.h-editorColumnWidth div 2					else						startPoint.h := originalMousePoint.h;					wh.h := startPoint.h;				end;}				{Calculate topleft of botright cells,  & click offset from upper left corner of entire block	also calculate full rectangle}		RowColumnFromTaxonCharacter(EWMoveBlockP^.startTaxa,EWMoveBlockP^.startChars,EWMoveBlockP^.topLeftCell.v,EWMoveBlockP^.topLeftCell.h);		RowColumnFromTaxonCharacter(EWMoveBlockP^.endTaxa,EWMoveBlockP^.endChars,EWMoveBlockP^.botRightCell.v,EWMoveBlockP^.botRightCell.h);		CellHor(EWMoveBlockP^.topLeftCell.h, left, right, true);		CellVer(EWMoveBlockP^.topLeftCell.v, top, bottom, true);		EWMoveBlockP^.offSetToBlockTopLeft.h := startPoint.h - left;		EWMoveBlockP^.offSetToBlockTopLeft.v := startPoint.v - top;{clickCellOffset is a point that stores the number of cells over to the right and down the click point is relative to the top left cell of the block}		EWMoveBlockP^.clickCellOffset.h :=EWMoveBlockP^.clickCell.h-EWMoveBlockP^.topLeftCell.h;		EWMoveBlockP^.clickCellOffset.v :=EWMoveBlockP^.clickCell.v-EWMoveBlockP^.topLeftCell.v;		EWMoveBlockP^.vertCells := EWMoveBlockP^.botRightCell.v-EWMoveBlockP^.topLeftCell.v+1;		EWMoveBlockP^.horCells := EWMoveBlockP^.botRightCell.h-EWMoveBlockP^.topLeftCell.h+1;{the above doesn't change as the block is moved.  the things that do change are:		fullRect: Rect;    - this doesn't change shape, just offset		visibleRect: Rect;		currentClickCell: point;		currentStartChars, currentEndChars, currentStartTax, currentEndTax: integer;}{Calculate the total rectangle for the block}		EWMoveBlockP^.fullRect.top := top;  {from previous CellVer}		EWMoveBlockP^.fullRect.left := left; {from previous CellHor}		CellHor(EWMoveBlockP^.botRightCell.h, left, right, true);		CellVer(EWMoveBlockP^.botRightCell.v, top, bottom, true);		EWMoveBlockP^.fullRect.bottom := bottom;		EWMoveBlockP^.fullRect.right := right;				EWMoveBlockP^.currentStartChars := EWMoveBlockP^.startChars;		EWMoveBlockP^.currentEndChars := EWMoveBlockP^.endChars;		EWMoveBlockP^.currentStartTaxa := EWMoveBlockP^.startTaxa;		EWMoveBlockP^.currentEndTaxa := EWMoveBlockP^.endTaxa;		CalcCellBlockRects(EWMoveBlockP, bounded);		CalcCellBlockVisibleTaxChar(EWMoveBlockP);				if not StoreDataIntoCellBlock(EWMoveBlockP,EWMoveBlockP^.botRightCell,EWMoveBlockP^.topLeftCell, not ((blockMoveKind = selectedBlockMove) | (blockMoveKind = splitMultiBlockMove)),blockMoveKind = selectedBlockMove, true, false, false, false) then			Exit(TrackBlockMove);				if not PasteCellblock(nil,[MSl,GAl],EWMoveBlockP^.startTaxa,EWMoveBlockP^.endTaxa,EWMoveBlockP^.startChars,EWMoveBlockP^.endChars) then			Exit(TrackBlockMove);{==============}				didscroll := false;		GetMouse(wh);		ScrollEditorToMouse(wh,nil,true,true,didScroll,icScrolled, pointMoved);		if didScroll then			begin				{OffSetRect(EWMoveBlockP^.visibleRect,pointMoved.h,pointMoved.v);}				scrolledOnce := true;				UpdateMovedTaxa(itstart,itend,blockMoveKind=selectedBlockMove, true);			end;		if switchingDirections then			tempOldVisibleRect := EWMoveBlockP^.visibleRect;		CalcCurrentCellBlockPositions(EWMoveBlockP,wh, bounded,(isLower&splitBlock),effectiveOriginalMousePoint,originalMousePoint, icScrolled);{oldCellBlockVisibleRect is the area where the block used to be before the current move.  With the move, some of its territory will be freed up, and will need to be replaced visually by gaps.However, there are two sorts of move which might change what area needs to be updated: switching directions, and scrolling.}		if switchingDirections then 			begin				if not editorTransposed then					begin						if isLower then							begin								oldCellBlockVisibleRect.right := tempOldVisibleRect.left;								oldCellBlockVisibleRect.left := EWMoveBlockP^.visibleRect.right;							end						else							begin								oldCellBlockVisibleRect.left := tempOldVisibleRect.right;								oldCellBlockVisibleRect.right := EWMoveBlockP^.visibleRect.left;							end;					end				else					begin						if isLower then							begin								oldCellBlockVisibleRect.bottom := tempOldVisibleRect.top;								oldCellBlockVisibleRect.top := EWMoveBlockP^.visibleRect.bottom;							end						else							begin								oldCellBlockVisibleRect.top := tempOldVisibleRect.bottom;								oldCellBlockVisibleRect.bottom := EWMoveBlockP^.visibleRect.top;							end;					end;				switchingDirections := false;			end;{		OffSetRect(oldCellBlockVisibleRect,pointMoved.h,pointMoved.v);}				{CalcAlignmentBlockRect(EWMoveBlockP, wh, bounded);}		if ConsensusSequenceVisible then			begin				blockMoveOn := true;				CalcConsensusSequenceTotals;				DrawConsensusSequenceNames;				blockMoveOn := false;			end;		TrackCellBlock(EWMoveBlockP, wh, bounded,  clickChar, (isLower&splitBlock), false,didScroll, icScrolled, effectiveOriginalMousePoint,originalMousePoint);		oldwh:= wh;				while StillDown do			begin				wasIsLower := IsLower;				didScroll := false;				GetMouse(wh);				ScrollEditorToMouse(wh,nil,true,true,didScroll, icScrolled, pointMoved);				if didScroll then					begin						{OffSetRect(EWMoveBlockP^.visibleRect,pointMoved.h,pointMoved.v);}						scrolledOnce := true;						UpdateMovedTaxa(itstart,itend,blockMoveKind=selectedBlockMove, true);						CalcCurrentCellBlockPositions(EWMoveBlockP,wh, bounded,(isLower&splitBlock),effectiveOriginalMousePoint,originalMousePoint, icScrolled);						{OffSetRect(oldCellBlockVisibleRect,pointMoved.h,pointMoved.v);}					end;				if blockMoveKind<> selectedBlockMove then					begin						if not editorTransposed then							isLower := wh.h < effectiveOriginalMousePoint.h						else						 	isLower := wh.v < effectiveOriginalMousePoint.v; 						 isLowerCalculated:= true;						if (splitBlock) & (isLower<>wasIsLower) then {}							begin								if  PasteCellblock(EWMoveBlockP,[],EWMoveBlockP^.startTaxa,EWMoveBlockP^.endTaxa,EWMoveBlockP^.startChars,EWMoveBlockP^.endChars) then									begin										switchingDirections := true;									end								else									isLower := wasIsLower;							end;						if not SplitBlock & blockMoveAccumulate & (((EWMoveBlockP^.currentStartChars = EWMoveBlockP^.lowerLimit)&(EWMoveBlockP^.currentStartChars>1))|((EWMoveBlockP^.currentEndChars = EWMoveBlockP^.upperLimit)&(EWMoveBlockP^.currentEndChars<numchars))) then							begin								if  PasteCellblock(EWMoveBlockP,[],EWMoveBlockP^.currentstartTaxa,EWMoveBlockP^.currentendTaxa,EWMoveBlockP^.currentstartChars,EWMoveBlockP^.currentendChars) then									begin										effectiveOriginalMousePoint:= wh;										goto 3;									end;							end;					end;				{bounded :=  not blockMovePushBoundaries;}				{if (moveUnselectedBlock | splitBlock) & not bounded then					bounded :=  (EWMoveBlockP^.lowerLimit > 1) & (EWMoveBlockP^.upperLimit < numchars);}				if not EqualPt(wh,oldwh) | didScroll then						TrackCellBlock(EWMoveBlockP, wh,  bounded,  clickChar,(isLower&splitBlock), switchingDirections,didScroll,icScrolled,effectiveOriginalMousePoint,originalMousePoint);				oldwh := wh;				if switchingDirections then					goto 2;			end;				TrackCellBlock(EWMoveBlockP, wh, bounded,  clickChar,(isLower&splitBlock), false,didScroll,icScrolled,effectiveOriginalMousePoint,originalMousePoint);				moveOK := true;		DoMoveCellBlock(EWMoveBlockP);		if not CheckStateFrequencies(itstart,itend,changedTaxon) then			InstantInfo('Beware!  Sequence alignment tool has altered state frequencies!  Don''t save data, and report this to clade@arizona.edu.');		if (blockMoveKind = selectedBlockMove) then			begin				RowColumnFromTaxonCharacter(EWMoveBlockP^.currentStartTaxa,EWMoveBlockP^.currentStartChars,editorSelectionTopLeft.v,editorSelectionTopLeft.h);				RowColumnFromTaxonCharacter(EWMoveBlockP^.currentEndTaxa,EWMoveBlockP^.currentEndChars,editorSelectionBotRight.v,editorSelectionBotRight.h);				oldClip := NewRgn;				GetClip(oldClip);				SetEWClip(justdataAndConsenses);				SetClip(EWClip);				DrawDataCellsBetweenCorners(editorSelectionTopLeft,editorSelectionBotRight,selectionModeAsIs);				SetEWClip(noscroll);				SetClip(oldClip);			end;		EmptyCellBlock(EWMoveBlockP);		EWCurrentDrawBlockP := nil;		DrawConsensusSequenceNames;		if editorFrequentRedraw | redrawEditor then			InvalidateWindow(editorWindow,true)		else if (blockMoveKind = splitMultiBlockMove)|((editorColorCellsMode = editorColorCellsAAState) & nucleotides) | (matchcharon | (editorColorCellsMode=editorColorCellsMatchFirst)) | scrolledOnce | (editorFlashMode<>flashOff) then			begin				if blockMoveKind = selectedBlockMove then					begin						CalcSelectedTaxaCharacters(st, et, sc, ec,true);						InvalidateCellBlock(st,et,FirstVisibleCharacter,LastVisibleCharacter,true);					end				else					InvalidateCellBlock(itstart,itend,FirstVisibleCharacter,LastVisibleCharacter,true);			end;		CheckRedrawFullCharactersInEditor(itstart,itend,1,numchars,true);//close(debugfile);	end;end.