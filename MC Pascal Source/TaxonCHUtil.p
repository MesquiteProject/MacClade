unit TaxonCHUtil;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface, 		 MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, UtilLibInterface, SetLibInterface;	function getCHUNKHdl (CHUNKHandleBlock: Handle; CHUNKnumber: integer): Handle;	function GetTaxonNumber (taxtoken: str255): integer;	function GetTaxonHdl (it: integer): thdl;	function TaxonName (it: integer): strTaxName;	function TokenToTaxNum (token: str255): integer;	function AvailTaxonName (it: integer): strTaxName;	function DuplicateNames: boolean;	function TaxonInTree (it: integer): boolean;	function MaxTaxNameLength (screenOnly: boolean): integer;	procedure CalcTaxonHeight;	function ItalicTaxon (it: integer): boolean;	procedure SetTaxonName (it: integer; var ds: str255);	procedure ClearNewTaxon (it: integer);	procedure SetAsNewTaxon (it: integer);	function IsNewTaxon (it: integer): boolean;	function NumStartGaps(it: integer; missingAsGaps: boolean): integer;	function NumEndGaps(it: integer; missingAsGaps: boolean): integer;	function GetTaxStsHdl (it: integer): Handle;	function GetSetPtr (it, ic: integer): Ptr;{ptr based state set operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}{The following all move setchars around, with at least one of the setchars referred to by}{a pointer to its location.  The setchars at the pointer is interpreted as 2 or 4 byte }{depending on current maxbit}	function HasMissingBit (it, ic: integer): boolean;	function IsAlternativeSymbolString(ds: str255): boolean;	function IsAlternativeSymbolChar(c: char): boolean;	function IsAlternativeSymbolSet(tsts: largestSetChars): boolean;	function AlternativeSymbol (it, ic: integer): boolean;	procedure SetAlternativeSymbol (it, ic: integer; addit: boolean);	procedure TransferStatesfromLargest (dest: ptr; sourceset: largestsetchars);	procedure TransferStates (dest: ptr; source: ptr);	procedure TransferStatesRNARC (dest: ptr; source: ptr);	function GetLargestFromPtr (source: ptr): largestsetchars;	procedure settaxonstsFromPtr (it, ic: integer; scp: Ptr);{largestsetchars based state set operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}{The following all move setchars to and from the basic taxon, dnst, upst, sts storage.}{Regardless of the original size of the stored setchars, a Get returns a largestsetchars,}{and a Set is input a largestsetchars}	function gettaxonstsLargestCase (it, ic: integer): largestsetchars;	function gettaxonstsLargest (it, ic: integer): largestsetchars;	function GetdnstLargest (N: Nptr; ic: integer): largestSetchars;	function GetupstLargest (N: Nptr; ic: integer): largestSetchars;	function GetstsLargest (N: Nptr; ic: integer): largestSetchars;	function GetstsLiterallargest (N: Nptr; ic: integer): largestsetchars;	procedure settaxonstsLargestOverwriteCase (it, ic: integer; newset: largestsetchars);	procedure settaxonstsLargestFoot (it, ic: integer; newset: largestsetchars);	procedure SettaxonStsLargest (it, ic: integer; newset: largestsetchars);	procedure SetdnstLargest (N: Nptr; ic: integer; newset: largestSetchars);	procedure SetupstLargest (N: Nptr; ic: integer; newset: largestSetchars);	procedure SetstsLargest (N: Nptr; ic: integer; newset: largestSetchars);{lgsetchars based state set operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}{same as above but don't pass largestsetchars.}	function GetTaxonStsG (it, ic: integer): lgsetchars;	procedure SetTaxonStsG (it, ic: integer; newset: lgsetchars);	function GetdnstG (N: Nptr; ic: integer): lgsetchars;	function GetupstG (N: Nptr; ic: integer): lgsetchars;	function GetstsG (N: Nptr; ic: integer): lgsetchars;	{procedure ExpandCHBlock (dest, source: ptr; numchars: integer);	procedure contractCHBlock (newmaxstate: integer; dest, source: ptr; numchars: integer);}	procedure FixTaxCharName (var ds: str255; warn: boolean; number: integer);{====}	function GetchHdl (ic: integer): chHdl;	function CharIncluded (ic: integer): boolean;	function CharCodPos (ic: integer): integer;	procedure SetWeight (ic, wt: integer);	procedure WtStorageToUse (ic: integer);	procedure UseToWtStorage (ic: integer);	procedure WtSetExclude (extendH: Handle);	function CodPosRGB(ic: integer): RGBColor;	function CharCodonPosRGB(ic: integer): RGBColor;	function FullTripletStartsHere(it,sc: integer): boolean;	function PartTripletStartsHere(it,sc: integer): boolean;	function CharWeight (ic: integer): integer;	function TrueCharWeight (ic: integer): integer;	procedure CheckWt1;	function CharMaxstOBS (ic: integer): SignedByte;{    function CharMaxstDEF (ic: integer): SignedByte; moved to charutil}{$IFC CHARPARTITIONS}	procedure PartStorageToUse (ic: integer);	procedure UseToPartStorage (ic: integer);	function CharPartition (ic: longint): integer;	procedure CheckAllOnePartition;	procedure SetPartition (ic: longint; partition: integer);	function CharPartitionName (partition: longint): str255;{$ENDC}	function CodPosSet (ic: integer): boolean;	function IsCoding (ic: integer): boolean;	procedure SetCoding (ic: integer; iscod: boolean);	function PrepareTSTSforCodons(tsts: LargestSetChars): LargestSetChars;	function AAFromCodon (codons: codontype; warn: boolean): LargestSetChars;	function PolyMInCharTree (ic: integer): boolean;	function TerminalMSTaxaInCharacter(ic: integer; onlyifInTree,justPolym: boolean): boolean;	function TerminalPolymorphisms: boolean;	function MSTaxaInCharTree (ic: integer): boolean;	function MSTaxaInCharData (ic: integer): boolean;	function IsGap (it,ic: integer): boolean;  {MoveGlobals}	function IsGapLike (it,ic: integer; missingAsGaps: boolean): boolean;  	function CheckIfAllGaps(itstart,itend,icstart,icend: integer; missingAsGaps: boolean): boolean;	function IsLargestSetCharsGapLike (tsts: Largestsetchars; missingAsGaps: boolean): boolean;  	function CharStatesLargest (ic: integer): Largestsetchars;	function InvariantChar (ic: integer): boolean;	function AllGaps(ic: integer; missingAsGaps: boolean): boolean;	function AllGapsInTaxa(st,et, ic: integer; missingAsGaps: boolean): boolean;	function UninformativeChar (ic: integer): boolean;	function CharName (ic: integer): strCharName;	function AvailCharName (ic: integer): strCharName;	procedure SetCharName (ic: integer; var ds: str255);	function GetCharNumber (ds: str255): integer;  {given the name of a character, ds, returns the number of character}	function TokenToCharNum (token: str255): integer;	procedure SetFootBits (theFoot, it, ic: integer; addit: boolean);	function GetFootPresent (theFoot, it, ic: integer): boolean;	function footpresent (it, ic: integer): boolean;	function footpictpresent (it, ic: integer): boolean;	function SomeFeetPresent: boolean;{    function StatePicture (ic, is: integer; var thetaxon: integer): boolean;}	procedure setInCharSet (ic: integer; on: boolean);	function InCharSet (ic: integer): boolean;	function InShadeCharSet (ic: integer): boolean;	function InCharSetLink (theLink: longint;  ic: integer): boolean;	function InTaxSetLink (theLink: longint; it: integer): boolean;	procedure setInTaxSet (it: integer; on: boolean);	function InTaxSet (it: integer): boolean;	function SetNumber (ds: str255; checkLast: boolean; theChain: Integer): integer;	procedure setCharSetLinkValue (theLink: longint;  ic: integer; on: boolean);	procedure setTaxSetLinkValue (theLink: longint;  it: integer; on: boolean);	procedure StoreOldNumbers(whichinfo: integer);	function NewlyDeletedTaxaFollowing(it: integer): integer;	procedure SetNewlyDeletedTaxa(it: integer; amount: integer);	function NewlyDeletedCharactersFollowing(ic: integer): integer;	procedure SetNewlyDeletedCharacter(ic: integer;amount: integer);	function TaxonIsNewlyInserted(it: integer): boolean;	procedure SetNewlyInsertedTaxon(it: integer; on: boolean);	function CharIsNewlyInserted(ic: integer): boolean;	procedure SetNewlyInsertedCharacter(ic: integer; on: boolean);		procedure SetLastChangeInEditor(lastChange: integer);	procedure LoadTaxonCHUtil;{еееееееееееееееееееееее}implementation {е$S TaxonCHUtil}{----------------------------------------------------------------------------}	function getCHUNKHdl (CHUNKHandleBlock: Handle; CHUNKnumber: integer): Handle;	begin		getCHUNKHdl := HdlPtr(GetMaster(CHUNKHandleBlock) + HdlSize * ord4(CHUNKnumber - 1))^;	end;	{procedure ExpandCHBlock (dest, source: ptr; numchars: integer);	external;	procedure contractCHBlock (newmaxstate: integer; dest, source: ptr; numchars: integer);	external;}{||||||||||||||||||||||||||||||||||||||||   Taxon Names & Numbers   ||||||||||||||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	function GetTaxonNumber (taxtoken: str255): integer;		var			ds: str255;			it: integer;	begin		GetTaxonNumber := 0;		for it := 1 to numtaxa do			begin				ds := TaxonName(it);				if StringsEqual(@ds, @taxtoken, tnw) then					begin						GetTaxonNumber := it;						leave;					end;			end;	end;{----------------------------------------------------------------------------}	function TokenToTaxNum (token: str255): integer;  		var			it: integer;	begin		if NumericalToken(token) then			it := TokenToInteger(token, true)		else			it := GetTaxonNumber(token);		if it > numtaxa then			it := numtaxa		else if it < 1 then			it := 1;		TokenToTaxNum := it;	end;{-----------------------------------------------------------------------------}	function TaxonName (it: integer): strTaxName;{returns the taxon name}		var			TaxonHdl: THdl;			oldState: SignedByte;			ds:str255;	begin		if (it<1) | (it>numtaxa) then			TaxonName := ""		else			begin				TaxonHdl := THdlPtr(GetMaster(TaxonCHUNKs) + HdlSize * longint(it - 1))^;   {v4: eventually change all (it-1) to ord4(it-1)}				LockHandle(TaxonHdl, oldState);				ds := TaxonHdl^^.name;				ResetHandle(TaxonHdl, oldState);				TaxonName := CopyString(ds, 1, tnw);			end;	end;{----------------------------------------------------------------------------}	function AvailTaxonName (it: integer): strTaxName;{returns the taxon name, if it is defined, otherwise returns "Taxon x"}		var			tds: strTaxName;	begin		tds := TaxonName(it);		if (tds = '') or (tds = ' ') then			tds := concat('Taxon ', StringFromNum(it));		AvailTaxonName := tds;	end;{-----------------------------------------------------------------------------}	function DuplicateNames: boolean;{returns true if there are duplicate taxon names}		label			1;		var			oldState: SignedByte;			it, tt: integer;			tn, tn2: strTaxName;			dupfound: boolean;			dL: longint;			TaxonHdl: THdl;	begin		LockHandle(TaxonCHUNKs, oldState);		dL := GetMaster(TaxonCHUNKs);		SetCursor(clockCursor);		dupfound := false;		if dirtytaxnames then			for it := 1 to numtaxa - 1 do				begin					TaxonHdl := THdlPtr(dL + HdlSize * (it - 1))^;					tn := TaxonHdl^^.name;					for tt := it + 1 to numtaxa do						begin							TaxonHdl := THdlPtr(dL + HdlSize * (tt - 1))^;							tn2 := TaxonHdl^^.name;							if (length(tn) = length(tn2)) & CompareStringC(@tn, @tn2) then   {much faster string comparison}								begin									dupfound := true;									goto 1;								end;						end;				end;1:		ResetHandle(TaxonCHUNKs, oldState);		SetCursorToArrow;		dirtytaxnames := dupfound;		DuplicateNames := dupfound;	end;{---------------------------------------------------------------------------}	procedure SetTaxonName (it: integer; var ds: str255);		var{    tname: str128;}			TaxonHdl: THdl;			oldState: SignedByte;	begin		Stripblanks(ds);		if (ds = '') then			ds := ' ';		if length(ds)>tnw then 			ds := CopyString(ds, 1, tnw);		FixTaxCharName(ds, true, 0);		if length(ds) > tnw then			delete(ds, tnw, 1);  {only delete one, as at most tnw+1 long}		taxonHdl := GetTaxonHdl(it);		LockHandle(taxonHdl,oldstate);		taxonHdl^^.name := ds;		ResetHandle(taxonHdl,oldstate);	end;{||||||||||||||||||||||||||||||||||||||||   Taxon Utilities   ||||||||||||||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	procedure ClearNewTaxon (it: integer);		var			taxonHdl: tHdl;	begin		taxonHdl := GetTaxonHdl(it);		taxonHdl^^.newTaxon := false;	end;{-----------------------------------------------------------------------------}	procedure SetAsNewTaxon (it: integer);		var			taxonHdl: tHdl;	begin		taxonHdl := GetTaxonHdl(it);		taxonHdl^^.newTaxon := true;	end;{-----------------------------------------------------------------------------}	function IsNewTaxon (it: integer): boolean;		var			taxonHdl: tHdl;	begin		taxonHdl := GetTaxonHdl(it);		IsNewTaxon := taxonHdl^^.newTaxon;	end;{-----------------------------------------------------------------------------}	function GetTaxonHdl (it: integer): thdl;	begin		GetTaxonHdl := THdlPtr(GetMaster(TaxonCHUNKs) + HdlSize * (it - 1))^;	end;{-----------------------------------------------------------------------------}	function TaxonInTree (it: integer): boolean;{returns true if taxon is in the current tree}		var			TaxonHdl: thdl;	begin		if numtaxa = numtaxain then			TaxonInTree := true		else			begin				TaxonHdl := THdlPtr(GetMaster(TaxonCHUNKs) + HdlSize * (it - 1))^;				TaxonInTree := not taxonHdl^^.deleted;			end;	end;{----------------------------------------------------------------------------}{----------------------------------------------------------------------------}	function MaxTaxNameLength (screenOnly: boolean): integer;		var			th: integer;			it: integer;{..........}		procedure TreeCheckNameLen (NP: Nptr);  {finds if any nulls}		begin			if (NP^.name = 0) then				begin					TreeCheckNameLen(NP^.lf);					TreeCheckNameLen(NP^.rt);				end			else				th := IntegerMax(th, StringWidth(TaxonName(NP^.name)));		end;{..........}	begin		th := 0;		if screenOnly & nodes then			TreeCheckNameLen(screenR)		else			for it := 1 to numtaxa do				if TaxoninTree(it) then					th := IntegerMax(th, StringWidth(TaxonName(it)));		MaxTaxNameLength := th;	end;{----------------------------------------------------------------------------}	procedure CalcTaxonHeight;{calculates the maximum length of taxon names, in the current font of the treewindow taxon}{names, and stores it in the global variable taxonheight.  Used to calculate position of tree on screen.}{also, calculates mintxsp, the minimum taxon spacing}		var			it: integer;			tport: windowptr;			fi: FontInfo;	begin		genericGetPort(tport);		genericSetPort(treewindow);		TextFont(treetaxafont);		TextSize(treetaxafontsize);		TextFace(treetaxastyle);		GetFontInfo(fi);		mintxsp := IntegerMax(6, fi.ascent + fi.descent + 1);		if (traceshown = traceAllChanges) & (summaryview = asticks) & squarebranches & not TicksNoNames then			if mintxsp < 25 then				mintxsp := 25;		taxonHeight := MaxTaxNameLength(true);		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	function ItalicTaxon (it: integer): boolean;{returns true if a taxon name is to be italicized}		var			TaxonHdl: thdl;	begin		if it > 0 then   {v3.04}			begin				TaxonHdl := THdlPtr(GetMaster(TaxonCHUNKs) + HdlSize * (it - 1))^;				ItalicTaxon := taxonHdl^^.isItalic;			end		else			ItalicTaxon := false;	end;{|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}	procedure TransferStatesFromLargest (dest: ptr; sourceset: largestsetchars);{v4: eventually in assembly}	var di: integer;		s: lgsetchars;	begin{InstantInfo(concat('set31to15 ', StringFromNum(longint(NewSetFromOld(sourceset)))));}		if maxbit = 15 then			begin				s := NewSetFromOld(sourceset);				di := set31to15(s);				IP(dest)^ := di;				{IP(dest)^ := set31to15(NewSetFromOld(sourceset))} {admestina}			end		else			SetPointer31(dest)^ := sourceset;	end;{---------------------------------------------------------------------------}	procedure TransferStates (dest: ptr; source: ptr);{v4: eventually in assembly}	begin		if maxbit = 15 then			IP(dest)^ := IP(source)^   {admestina}		else			LIP(dest)^ := LIP(source)^; {admestina}	end;{---------------------------------------------------------------------------}	procedure TransferStatesRNARC (dest: ptr; source: ptr);	var sourceset: largestsetchars;		RNARCset: largestSetChars;	begin		sourceset := GetLargestFromPtr(source);		RNARCset := [];		if (0 in sourceset) then  // A			RNARCset := RNARCset +[3]		else if (1 in sourceset) then  // C			RNARCset := RNARCset +[2]		else if (2 in sourceset) then  // G			RNARCset := RNARCset +[1,3]  // goes with C or T		else if (3 in sourceset) then  // T			RNARCset := RNARCset +[0,2]  // goes with A or G		else			RNARCset := sourceset;		if CardLg(RNARCSet)>1 then			RNARCset := RNARCset+[UCl];		TransferStatesFromLargest(dest,RNARCSet);	end;{-----------------------------------------------------------------------------}	function GetLargestFromPtr (source: ptr): largestsetchars;{v4: eventually in assembly}	begin		if maxbit = 15 then			{ GetLargestFromPtr := set15to31(SetPointer15(source)^) admestina}			GetLargestFromPtr := set15to31P(source)		else			GetLargestFromPtr := SetPointer31(source)^;	end;{-----------------------------------------------------------------------------}	function Getdnstlargest (N: Nptr; ic: integer): largestsetchars;	begin		if maxbit = 15 then			{Getdnstlargest := set15to31(SetPointer15(GetMaster(N^.dnstH) + tcb * longint(ic - 1))^) admestina}			Getdnstlargest := set15to31P(Ptr(GetMaster(N^.dnstH) + tcb * longint(ic - 1)))		else			Getdnstlargest := SetPointer31(GetMaster(N^.dnstH) + tcb * longint(ic - 1))^;	end;{-----------------------------------------------------------------------------}	procedure SetdnstLargest (N: Nptr; ic: integer; newset: largestsetchars);	begin		TransferStatesFromLargest(Ptr(GetMaster(N^.dnstH) + tcb * longint(ic - 1)), newset);	end;{-----------------------------------------------------------------------------}	function Getupstlargest (N: Nptr; ic: integer): largestsetchars;	begin		if maxbit = 15 then			{Getupstlargest := set15to31(SetPointer15(GetMaster(N^.upstH) + tcb * longint(ic - 1))^) admestina}			Getupstlargest := set15to31P(Ptr(GetMaster(N^.upstH) + tcb * longint(ic - 1)))		else			Getupstlargest := SetPointer31(GetMaster(N^.upstH) + tcb * longint(ic - 1))^;	end;{-----------------------------------------------------------------------------}	procedure SetUpstLargest (N: Nptr; ic: integer; newset: largestsetchars);	begin		TransferStatesFromLargest(Ptr(GetMaster(N^.upstH) + tcb * longint(ic - 1)), newset);	end;{-----------------------------------------------------------------------------}	function Getstslargest (N: Nptr; ic: integer): largestsetchars; { note highbits zeroed}	begin		if maxbit = 15 then			GetStsLargest := ZerohighBitsLg(set15to31P(Ptr(GetMaster(N^.stsH) + tcb * longint(ic - 1)))) {admestina}		else 			begin				{writeln('GSL ', LIP(GetMaster(N^.stsH) + tcb * longint(ic - 1))^);				writeln('GSL zeroed ', longint(NewSetFromOld(ZeroHighbitsLg(SetPointer31(GetMaster(N^.stsH) + tcb * longint(ic - 1))^))));}			GetStsLargest := ZeroHighbitsLg(SetPointer31(GetMaster(N^.stsH) + tcb * longint(ic - 1))^);			end;	end;{-----------------------------------------------------------------------------}	function GetstsLiterallargest (N: Nptr; ic: integer): largestsetchars;	begin		if maxbit = 15 then			GetstsLiterallargest := set15to31P(Ptr(GetMaster(N^.stsH) + tcb * longint(ic - 1)))			{GetstsLiterallargest := set15to31(SetPointer15(GetMaster(N^.stsH) + tcb * longint(ic - 1))^) admestina}		else			GetstsLiterallargest := SetPointer31(GetMaster(N^.stsH) + tcb * longint(ic - 1))^;	end;{-----------------------------------------------------------------------------}	procedure SetStsLargest (N: Nptr; ic: integer; newset: largestsetchars);	begin		TransferStatesFromLargest(Ptr(GetMaster(N^.stsH) + tcb * longint(ic - 1)), newset);	end;{-----------------------------------------------------------------------------}	function GetTaxStsHdl (it: integer): Handle;{returns the handle to the LargestSetChars CHUNK for taxon it; that is, for the}{taxstsHdl of taxon it}	begin		GetTaxstsHdl := HdlPtr(GetMaster(TaxstsCHUNKs) + HdlSize * (it - 1))^;	end;{-----------------------------------------------------------------------------}	function GetSetPtr (it, ic: integer): Ptr;{returns pointer to the LargestSetChars for taxon it and char ic}	begin		GetSetPtr := Pointer(GetMaster(HdlPtr(GetMaster(TaxstsCHUNKs) + HdlSize * (it - 1))^) + longint(ic - 1) * tcb);	end;{-----------------------------------------------------------------------------}	function HasMissingBit (it, ic: integer): boolean;	begin		if (it>0) & (ic>0) then			HasMissingBit := MSl in gettaxonstsLargest(it,ic)		else			HasMissingBit := false;	end;{-----------------------------------------------------------------------------}	function AlternativeSymbol (it, ic: integer): boolean;	begin		if (it>0) & (ic>0) then			AlternativeSymbol := SSl in set15to31P(Ptr(GetMaster(HdlPtr(GetMaster(TaxstsCHUNKs) + HdlSize * (it - 1))^) + longint(ic - 1) * tcb))		else			AlternativeSymbol := false;	end;{----------------------------------------------------------------------------}	procedure SetAlternativeSymbol (it, ic: integer; addit: boolean);		var			tsp: Ptr;	begin		if nucleotides then			begin				tsp := Ptr(GetMaster(HdlPtr(GetMaster(TaxstsCHUNKs) + HdlSize * (it - 1))^) + longint(ic - 1) * tcb);				if addit then					Bitset(tsp, SSo)				else					Bitclr(tsp, SSo);			end;	end;{----------------------------------------------------------------------------}	function IsAlternativeSymbolString(ds: str255): boolean;	begin		IsAlternativeSymbolString := false;		if nucleotides then			IsAlternativeSymbolString := (ds='a')| (ds='c')| (ds='g')| (ds='t')| (ds='N')| (ds='n');	end;	{----------------------------------------------------------------------------}	function IsAlternativeSymbolSet(tsts: largestSetChars): boolean;	begin		IsAlternativeSymbolSet := false;		if nucleotides then			IsAlternativeSymbolSet := SSl in tsts;	end;{----------------------------------------------------------------------------}	function IsAlternativeSymbolChar(c: char): boolean;	begin		IsAlternativeSymbolChar := false;		if nucleotides then			IsAlternativeSymbolChar := (c='a')| (c='c')| (c='g')| (c='t')| (c='N')| (c='n');	end;{-----------------------------------------------------------------------------}	function gettaxonstsLargestCase (it, ic: integer): largestsetchars;{returns LargestSetChars for taxon it and character ic, without the footnote, footpict, and error bits}	begin{writeln }{InstantInfo(concat('gtsL ', StringFromNum(longint(NewSetFromOld(set15to31P(Ptr(GetMaster(HdlPtr(GetMaster(TaxstsCHUNKs) + HdlSize * (it - 1))^) + longint(ic - 1) * tcb)))))));{Note that this procedure is already clean for FT, FP, ER}		if maxbit = 15 then			gettaxonstsLargestCase := set15to31P(Ptr(GetMaster(HdlPtr(GetMaster(TaxstsCHUNKs) + HdlSize * (it - 1))^) + longint(ic - 1) * tcb)) - [FTl, FPl, ERl]			{gettaxonstsLargest := set15to31(setPointer15(GetMaster(HdlPtr(GetMaster(TaxstsCHUNKs) + HdlSize * (it - 1))^) + longint(ic - 1) * tcb)^) - [FTl, FPl, ERl] admestina}		else			gettaxonstsLargestCase := LargestSetPointer(GetMaster(HdlPtr(GetMaster(TaxstsCHUNKs) + HdlSize * (it - 1))^) + longint(ic - 1) * tcb)^ - [FTl, FPl, ERl];	end;{-----------------------------------------------------------------------------}	function gettaxonstsLargest (it, ic: integer): largestsetchars;{returns LargestSetChars for taxon it and character ic, without the footnote, footpict, smallsymbol, and error bits}	begin{writeln }{InstantInfo(concat('gtsL ', StringFromNum(longint(NewSetFromOld(set15to31P(Ptr(GetMaster(HdlPtr(GetMaster(TaxstsCHUNKs) + HdlSize * (it - 1))^) + longint(ic - 1) * tcb)))))));{Note that this procedure is already clean for FT, FP, ER}		if nucleotides then			if maxbit = 15 then				gettaxonstsLargest := set15to31P(Ptr(GetMaster(HdlPtr(GetMaster(TaxstsCHUNKs) + HdlSize * (it - 1))^) + longint(ic - 1) * tcb)) - [FTl, FPl, ERl, SSl]				{gettaxonstsLargest := set15to31(setPointer15(GetMaster(HdlPtr(GetMaster(TaxstsCHUNKs) + HdlSize * (it - 1))^) + longint(ic - 1) * tcb)^) - [FTl, FPl, ERl] admestina}			else				gettaxonstsLargest := LargestSetPointer(GetMaster(HdlPtr(GetMaster(TaxstsCHUNKs) + HdlSize * (it - 1))^) + longint(ic - 1) * tcb)^ - [FTl, FPl, ERl,SSl]		else if maxbit = 15 then			gettaxonstsLargest := set15to31P(Ptr(GetMaster(HdlPtr(GetMaster(TaxstsCHUNKs) + HdlSize * (it - 1))^) + longint(ic - 1) * tcb)) - [FTl, FPl, ERl]			{gettaxonstsLargest := set15to31(setPointer15(GetMaster(HdlPtr(GetMaster(TaxstsCHUNKs) + HdlSize * (it - 1))^) + longint(ic - 1) * tcb)^) - [FTl, FPl, ERl] admestina}		else			gettaxonstsLargest := LargestSetPointer(GetMaster(HdlPtr(GetMaster(TaxstsCHUNKs) + HdlSize * (it - 1))^) + longint(ic - 1) * tcb)^ - [FTl, FPl, ERl];	end;{-----------------------------------------------------------------------------}	procedure settaxonstsLargestFoot (it, ic: integer; newset: largestsetchars);{sets the LargestSetChars of taxon it and character ic, PRESERVING the footnote bit}{and footpict bit previously in taxon it and character ic's storage}		var			txp: ptr;			AddFootNoteBit, AddFootPictBit, AddSmallSymbol: boolean;	begin		if (it>0) & (ic>0) & (it<=numtaxa) & (ic <= numchars) then			begin				txp := Ptr(GetMaster(HdlPtr(GetMaster(TaxstsCHUNKs) + HdlSize * (it - 1))^) + longint(ic - 1) * tcb);				AddFootNoteBit := BitTst(txp, FTo);				AddFootPictBit := BitTst(txp, FPo);				AddSmallSymbol:= nucleotides & BitTst(txp,SSo);				TransferStatesFromLargest(txp, newset);				if AddFootNoteBit then					BitSet(txp, fto)				else					bitclr(txp, fto);				if AddFootPictBit then					BitSet(txp, fpo)				else					bitclr(txp, fpo);				if nucleotides then					if AddSmallSymbol then						BitSet(txp, SSo)					else						bitclr(txp, SSo);			end		else			NewError(453,0);	end;{-----------------------------------------------------------------------------}	procedure settaxonstsLargestOverwriteCase (it, ic: integer; newset: largestsetchars);{sets the LargestSetChars of taxon it and character ic, PRESERVING the footnote bit}{and footpict bit previously in taxon it and character ic's storage}		var			txp: ptr;			AddFootNoteBit, AddFootPictBit: boolean;	begin		if (it>0) & (ic>0) & (it<=numtaxa) & (ic <= numchars) then			begin				txp := Ptr(GetMaster(HdlPtr(GetMaster(TaxstsCHUNKs) + HdlSize * (it - 1))^) + longint(ic - 1) * tcb);				AddFootNoteBit := BitTst(txp, FTo);				AddFootPictBit := BitTst(txp, FPo);				TransferStatesFromLargest(txp, newset);				if AddFootNoteBit then					BitSet(txp, fto)				else					bitclr(txp, fto);				if AddFootPictBit then					BitSet(txp, fpo)				else					bitclr(txp, fpo);			end		else			NewError(453,0);	end;{-----------------------------------------------------------------------------}	procedure settaxonstsFromPtr (it, ic: integer; scp: ptr);{identical to setTaxonstsLargestFoot but with newLargestsetchars passed as pointer}{rather than as a set}		var			txp: ptr;			AddFootNoteBit, AddFootPictBit, AddSmallSymbolsBit: boolean;	begin		if (it>0) & (ic>0) & (it<=numtaxa) & (ic <= numchars) then			begin				txp := Ptr(GetMaster(HdlPtr(GetMaster(TaxstsCHUNKs) + HdlSize * (it - 1))^) + longint(ic - 1) * tcb);				AddFootNoteBit := BitTst(txp, FTo);				AddFootPictBit := BitTst(txp, FPo);				AddSmallSymbolsBit := nucleotides & BitTst(txp, SSo);				TransferStates(txp, scp);				if AddFootNoteBit then					BitSet(txp, fto)				else					bitclr(txp, fto);				if AddFootPictBit then					BitSet(txp, fpo)				else					bitclr(txp, fpo);				if AddSmallSymbolsBit then					BitSet(txp, SSo)				else					bitclr(txp, SSo);			end		else			NewError(453,0);	end;{-----------------------------------------------------------------------------}	procedure SettaxonStsLargest (it, ic: integer; newset: largestsetchars);	begin	{writeln('settaxonstslargest ', longint(NewSetFromOld(newset)));}		if (it>0) & (ic>0) & (it<=numtaxa) & (ic <= numchars) then			TransferStatesFromLargest(Ptr(GetMaster(HdlPtr(GetMaster(TaxstsCHUNKs) + HdlSize * (it - 1))^) + longint(ic - 1) * tcb), newset)		else			NewError(453,0);	end;{|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}	function GetchHdl (ic: integer): chHdl;	begin		GetchHdl := chHdlPtr(GetMaster(chCHUNKs) + HdlSize * longint(ic - 1))^;	end;{-----------------------------------------------------------------------------}	procedure FixTaxCharName (var ds: str255; warn: boolean; number: integer);{adjusts taxon, character, and charset name so is not strictly numerical}	begin		if NumericalToken(ds) then			if readon then				begin					errorflag := true;					badfile := true;					NewError(371, number);				{	InstantInfo(StringFromNum(length(ds)));}				end			else				begin					ds := concat(ds, '.');					if warn then						NewError(328, number);				end;	end;{-----------------------------------------------------------------------------}	function CharIncluded (ic: integer): boolean;		var			charHdl: chHdl;	begin		charHdl := chHdlPtr(GetMaster(chCHUNKs) + HdlSize * longint(ic - 1))^;		CharIncluded := not charhdl^^.deleted;	end;{-----------------------------------------------------------------------------}	function InvariantChar (ic: integer): boolean;	begin		InvariantChar := cardLg(CharStatesLargest(ic)) <= 1;	end;{----------------------------------------------------------------------------}	function IsGap (it,ic: integer): boolean;  	begin		IsGap :=GAl in gettaxonstsLargest(it,ic);	end;{----------------------------------------------------------------------------}	function IsGapLike (it,ic: integer; missingAsGaps: boolean): boolean;  	var tsts : largestsetchars;	begin		tsts := gettaxonstsLargest(it,ic);		IsGapLike :=(GAl in tsts) | (missingAsGaps & (MSl in tsts));	end;{----------------------------------------------------------------------------}	function CheckIfAllGaps(itstart,itend,icstart,icend: integer; missingAsGaps: boolean): boolean;	var it, ic: integer;	begin		CheckIfAllGaps := true;		for ic := icstart to icend do			for it := itstart to itend do				if not IsGapLike(it,ic,missingAsGaps) then					begin						CheckIfAllGaps := false;						leave;					end;	end;{----------------------------------------------------------------------------}	function IsLargestSetCharsGapLike (tsts: Largestsetchars; missingAsGaps: boolean): boolean;  	begin		IsLargestSetCharsGapLike :=(GAl in tsts) | (missingAsGaps & (MSl in tsts));	end;{-----------------------------------------------------------------------------}	function AllGaps(ic: integer; missingAsGaps: boolean): boolean;	var it: integer;	begin		if (ic<1) | (ic>numchars) then			AllGaps := false		else if cardLg(CharStatesLargest(ic)) > 1 then			AllGaps := false		else			begin				AllGaps := true;				for it := 1 to numtaxa do					if not IsGapLike(it,ic,missingAsGaps) then						begin							AllGaps := false;							leave;						end;			end;	end;{-----------------------------------------------------------------------------}	function AllGapsInTaxa(st,et, ic: integer; missingAsGaps: boolean): boolean;	var it: integer;	begin		if (ic<1) | (ic>numchars) then			AllGapsInTaxa := false		else if cardLg(CharStatesLargest(ic)) > 1 then			AllGapsInTaxa := false		else			begin				AllGapsInTaxa := true;				for it := st to et do					if not IsGapLike(it,ic,missingAsGaps) then						begin							AllGapsInTaxa := false;							leave;						end;			end;	end;{-----------------------------------------------------------------------------}	function NumStartGaps(it: integer; missingAsGaps: boolean): integer;	var ic: integer;		num : integer;	begin		num := 0;		for ic := 1 to numChars do			if IsGapLike(it,ic,missingAsGaps) then				num := num+1			else				leave;		NumStartGaps := num;	end;{-----------------------------------------------------------------------------}	function NumEndGaps(it: integer; missingAsGaps: boolean): integer;	var ic: integer;		num : integer;	begin		num := 0;		for ic := numChars downto 1 do			if IsGapLike(it,ic,missingAsGaps) then				num := num+1			else				leave;		NumEndGaps := num;	end;{-----------------------------------------------------------------------------}	function UninformativeChar (ic: integer): boolean;  {note this does not yet work; on the other hand, it is never called!}	begin		UninformativeChar := false;	end;{-----------------------------------------------------------------------------}	function CodPosRGB(ic: integer): RGBColor;	begin		case ic of			1: 	CodPosRGB := blueRGB;			2: 	CodPosRGB := greenRGB;			3:  	CodPosRGB := redRGB;			codeNotSet:  	CodPosRGB := codeNotSetRGB;			otherwise				CodPosRGB := blackRGB;		end;	end;{-----------------------------------------------------------------------------}	function CharCodonPosRGB(ic: integer): RGBColor;	begin		CharCodonPosRGB := CodPosRGB(CharCodPos(ic));	end;{-----------------------------------------------------------------------------}	function CharCodPos (ic: integer): integer;		var			charHdl: chHdl;	begin		if (ic <= numchars) & (ic>0) then			begin				charHdl := GetChHdl(ic);				CharCodPos := charHdl^^.codpos;			end		else			CharCodPos := nonCoding;	end;{-----------------------------------------------------------------------------}	procedure SetWeight (ic, wt: integer);		var			intp: IP;	begin		intp := IP(GetMaster(chwtH) + chwb * longint(ic - 1));		intp^ := wt;	end;{----------------------------------------------------------------------------}	function FullTripletStartsHere(it,sc: integer): boolean;	begin		FullTripletStartsHere := false;		if (sc+2 <= numchars) & (sc>0) then 			if (CharCodPos(sc) = 1) & (CharCodPos(sc+1) = 2) & (CharCodPos(sc+2) = 3) then				if (GetTaxonStsLargest(it,sc)<>[MSl,GAl]) & (GetTaxonStsLargest(it,sc+1)<>[MSl,GAl]) & (GetTaxonStsLargest(it,sc+2)<>[MSl,GAl]) then					FullTripletStartsHere := true;	end;{----------------------------------------------------------------------------}	function PartTripletStartsHere(it,sc: integer): boolean;	begin		PartTripletStartsHere := false;		if (sc+2 <= numchars) & (sc>0) then 			if (CharCodPos(sc) = 1) & (CharCodPos(sc+1) = 2) & (CharCodPos(sc+2) = 3) then				if not CheckIfAllGaps(it,it,sc,sc+2, editorToolsTreatMissingAsGaps) then {some non-gaps}					if IsGapLike(it,sc,editorToolsTreatMissingAsGaps) | IsGapLike(it,sc+1,editorToolsTreatMissingAsGaps) | IsGapLike(it,sc+2,editorToolsTreatMissingAsGaps) then						PartTripletStartsHere := true;	end;{-----------------------------------------------------------------------------}	function PrepareTSTSforCodons(tsts: LargestSetChars): LargestSetChars;	begin		if tsts = [MSl] then			PrepareTSTSforCodons := [0, 1, 2, 3, UCl]		else if tsts = [MSl, GAl] then			PrepareTSTSforCodons := [0, 1, 2, 3, UCl, GAl]		else			PrepareTSTSforCodons := tsts;	end;{-----------------------------------------------------------------------------}	function AAFromCodon (codons: codontype; warn: boolean): LargestSetChars;		type			cardarray = array[0..2] of integer;		var			j, k, m: integer;			tsts: largestsetchars;			cards: cardarray;			ucpresent, polympresent, mstaxpres, someGaps: boolean;			codonIntersect, codonUnion: largestsetchars;	begin		CodonIntersect := codons[0] * codons[1] * codons[2];		CodonUnion := codons[0] + codons[1] + codons[2];		someGaps := (codons[0] =[0, 1, 2, 3, UCl, GAl])|(codons[1] =[0, 1, 2, 3, UCl, GAl])|(codons[2] =[0, 1, 2, 3, UCl, GAl]);		if (CodonIntersect = [0, 1, 2, 3, UCl, GAl]) then   {3 gaps in a row}			tsts := [MSl, GAl]		else			begin				if warn & (GAl in CodonUnion)then {at least one gap, and some non-gaps}					NewError(348, 0);				if (CodonIntersect = [0, 1, 2, 3, UCl]) then					if GAl in CodonUnion then						tsts := [MSl, GAl]					else						tsts := [MSl]				else if someGaps then					tsts := [MSl]				else					begin						ucpresent := false;						polympresent := false;						mstaxpres := false;						for j := 0 to 2 do							begin								cards[j] := cardLg(codons[j]);								if (cards[j] > 1) then									begin										if UCl in codons[j] then											ucpresent := true										else											polympresent := true;										mstaxpres := true;									end;							end;						if not mstaxpres then							tsts := [gencode^[minLg(codons[0]), minLg(codons[1]), minLg(codons[2])]]						else							begin								tsts := [];								for j := 0 to maxDNAstate do									if j in codons[0] then										for k := 0 to maxDNAstate do											if k in codons[1] then												for m := 0 to maxDNAstate do													if m in codons[2] then														tsts := tsts + [gencode^[j, k, m]];							end;						if (ucpresent & not polympresent) & (CardLg(tsts)>1) & not ((codons[0] = [0, 1, 2, 3, UCl]) | (codons[1] = [0, 1, 2, 3, UCl]) | (codons[2] = [0, 1, 2, 3, UCl])) then{that is, if uncertain bit is present, and it is not a polymorphism, and the UCl is there *NOT* because of MSl -> [0, 1, 2, 3, UCl]}{AND it must be the case that tsts has multiple states!}							tsts := tsts + [UCl];					end;			end;		AAFromCodon := tsts;	end;{$IFC CHARPARTITIONS}{-----------------------------------------------------------------------------}	procedure PartStorageToUse (ic: integer);		var			intp: IP;	begin		intp := IP(GetMaster(chpartitionH) + chpartb * longint(ic - 1));		intp^ := IP(GetMaster(chStorePartitionH) + chpartb * longint(ic - 1))^;	end;{-----------------------------------------------------------------------------}	procedure UseToPartStorage (ic: integer);		var			intp: IP;	begin		intp := IP(GetMaster(chStorePartitionH) + chpartb * longint(ic - 1));		intp^ := IP(GetMaster(chpartitionH) + chpartb * longint(ic - 1))^;	end;{-----------------------------------------------------------------------------}	function CharPartition (ic: longint): integer;	begin		CharPartition := IP(GetMaster(chpartitionH) + chpartB * longint(ic - 1))^;	end;{-----------------------------------------------------------------------------}	procedure SetPartition (ic: longint; partition: integer);		var			intp: IP;	begin		intp := IP(GetMaster(chPartitionH) + chpartb * longint(ic - 1));		intp^ := partition;	end;{-----------------------------------------------------------------------------}	function CharPartitionName (partition: longint): str255;	begin		CharPartitionName := concat('part ', StringFromNum(partition));	end;{-----------------------------------------------------------------------------}	procedure CheckAllOnePartition;		var			ic: integer;	begin		onePartition := true;		if (linknumber[charPartitionchain] = 0) and not dirtylink[charPartitionchain] then			onePartition := true		else			for ic := 1 to numchars do				if CharPartition(ic) <> defaultPartition then   					begin						onePartition := false;						leave;					end;	end;{$ENDC}{-----------------------------------------------------------------------------}	procedure WtStorageToUse (ic: integer);		var			intp: IP;	begin		intp := IP(GetMaster(chwtH) + chwb * longint(ic - 1));		intp^ := IP(GetMaster(chstorewtH) + chwb * longint(ic - 1))^;	end;{-----------------------------------------------------------------------------}	procedure UseToWtStorage (ic: integer);		var			intp: IP;	begin		intp := IP(GetMaster(chstorewtH) + chwb * longint(ic - 1));		intp^ := IP(GetMaster(chwtH) + chwb * longint(ic - 1))^;	end;{-----------------------------------------------------------------------------}	procedure WtSetExclude (extendH: Handle);  {sets wt of all excluded characters to zero; presumes an extendedHandle with no leading bytes & name etc.}		var			ic: integer;			intP: IP;			oldState: SignedByte;	begin		LockHandle(extendH, oldState);		intP := IP(GetMaster(extendH));		for ic := 1 to numchars do			begin				if not CharIncluded(ic) then					intP^ := 0;				intP := IP(ord4(intP) + chwb);			end;		ResetHandle(extendH, oldstate);	end;{-----------------------------------------------------------------------------}	function CharWeight (ic: integer): integer;	begin		CharWeight := IP(GetMaster(chwtH) + chwb * longint(ic - 1))^;	end;{-----------------------------------------------------------------------------}	function TrueCharWeight (ic: integer): integer;	begin		TrueCharWeight := IP(GetMaster(chstorewtH) + chwb * longint(ic - 1))^;	end;{-----------------------------------------------------------------------------}	procedure CheckWt1;		var			ic: integer;	begin		CheckInflate;		allwt1 := true;		if realwt then			allwt1 := false		else if (linknumber[wtsetchain] = 0) and not dirtylink[wtsetchain] then			allwt1 := true		else			for ic := 1 to numchars do				if CharIncluded(ic) then					if CharWeight(ic) <> 1 then   {note this doesn't deal with inflation}											{thus a realwt set of all 1.00 is considered to be allwt1 := false}						begin							allwt1 := false;							leave;						end;		myCheckMenuItem(WeightMHdl, ContWtsItem, realwt);	end;{-----------------------------------------------------------------------------}	function CharMaxstOBS (ic: integer): SignedByte;   {this is always EDITOR based, not treebased}		var			charHdl: chHdl;	begin		charHdl := chHdlPtr(GetMaster(chCHUNKs) + HdlSize * longint(ic - 1))^;		CharMaxstOBS := charHdl^^.maxst;	end;{-----------------------------------------------------------------------------}	function CodPosSet (ic: integer): boolean;{true if the character ic is set to pos 1, 2 , or 3}		var			charHdl: chHdl;	begin		charHdl := chHdlPtr(GetMaster(chCHUNKs) + HdlSize * longint(ic - 1))^;		CodPosSet := charHdl^^.codpos > 0;	end;{-----------------------------------------------------------------------------}	function IsCoding (ic: integer): boolean;		var			charHdl: chHdl;	begin		charHdl := chHdlPtr(GetMaster(chCHUNKs) + HdlSize * longint(ic - 1))^;		IsCoding := charHdl^^.coding;	end;{-----------------------------------------------------------------------------}	procedure SetCoding (ic: integer; iscod: boolean);		var			charHdl: chHdl;	begin		charHdl := chHdlPtr(GetMaster(chCHUNKs) + HdlSize * longint(ic - 1))^;		charHdl^^.coding := iscod;	end;{-----------------------------------------------------------------------------}	function CharStatesLargest; {(ic : integer) : Largestsetchars;}{this is editor-based just after leaving editor, but is treebased in treewindow}	begin		if maxbit = 15 then			CharStatesLargest := set15to31P(Ptr(GetMaster(chStatesH) + chsb * longint(ic - 1)))		else			CharStatesLargest := LargestSetPointer(GetMaster(chStatesH) + chsb * longint(ic - 1))^;	end;{|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}	function PolyMInCharTree (ic: integer): boolean;  {v4: this is not yet used; use it} {returns true if there are multistate taxa in character ic, false if not}	begin		PolyMInCharTree := GetchHdl(ic)^^.PMTree;	end;{-----------------------------------------------------------------------------}	function TerminalMSTaxaInCharacter(ic: integer; onlyifInTree,justPolym: boolean): boolean;{returns true if there are polymorphisms in character ic}		var			it: integer;			tsts: largestsetchars;			polyfound: boolean;	begin		polyfound := false;		if ((onlyifInTree & MSTaxaInCharTree(ic)) | MSTaxaInCharData(ic)) then			for it := 1 to numtaxa do				if TaxonInTree(it) then					begin						tsts := gettaxonstsLargest(it, ic);						if MultipleStatesLg(tsts) then						if justPolym <> (Ucl in tsts) then							begin								polyfound := true;								leave;							end;					end;		TerminalMSTaxaInCharacter := polyfound;	end;{-----------------------------------------------------------------------------}	function TerminalPolymorphisms: boolean;{returns true if there are some chars have polymorphisms,for use}		label			1;		var			it, ic: integer;			tsts: largestsetchars;			polyfound: boolean;	begin		polyfound := false;		for ic := 1 to numchars do			if CharIncluded(ic) & MSTaxaInCharTree(ic) then				begin					for it := 1 to numtaxa do						if TaxonInTree(it) then							begin								tsts := gettaxonstsLargest(it, ic);								if MultipleStatesLg(tsts) & not (Ucl in tsts) then									begin										polyfound := true;										goto 1;									end;							end;				end;1:		TerminalPolymorphisms := polyfound;	end;{-----------------------------------------------------------------------------}	function MSTaxaInCharTree (ic: integer): boolean; {returns true if there are multistate taxa in character ic, false if not}	begin		MSTaxaInCharTree := GetchHdl(ic)^^.MSTTree;	end;{-----------------------------------------------------------------------------}	function MSTaxaInCharData (ic: integer): boolean; {returns true if there are multistate taxa in character ic, false if not}	begin		MSTaxaInCharData := GetChHdl(ic)^^.MSTData;	end;{|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	function CharName (ic: integer): strCharName;		var			charHdl: chHdl;			ds31: strCharName;			ds: str255;	begin		if (ic < 1) | (ic>numchars) then			ds31 := ''		else			begin				charHdl := GetchHdl(ic);				ds31 := charHdl^^.name;				ds := ds31;				UnderLineToBlanks(ds);				if (ds = ' ') then					ds31 := ''				else					ds31 := ds;			end;		CharName := ds31;	end;{----------------------------------------------------------------------------}	function AvailCharName (ic: integer): strCharName;		var			tds: strCharName;	begin		tds := CharName(ic);		if (tds = '') then			tds := concat('Character ', StringFromNum(ic));		AvailCharName := tds;	end;{---------------------------------------------------------------------------}	procedure SetCharName (ic: integer; var ds: str255);		var			charHdl: chHdl;			tname: strCharName;	begin		Stripblanks(ds);		if (ds = '') then {or (ds = '.')}  {v4: why as '.' an illegal char name?}			ds := '_'		else			BlanksToUnderLine(ds);		charHdl := GetchHdl(ic);		if length(ds) > cnw then			NewError(450,ic);		ds := CopyString(ds, 1, cnw);		FixTaxCharName(ds, true, ic);		if length(ds) > cnw then			delete(ds, cnw, 1);		tname := ds;		if infoOpen[charinfo] & (charHdl^^.name <> tname) then			InvalidateWindow(infoWindow[charinfo], false);		charHdl^^.name := tname;	end;{----------------------------------------------------------------------------}	function GetCharNumber (ds: str255): integer;  {given the name of a character, ds, returns the number of character}		var			ic: integer;			theCharNum: integer;			tds: str255;	begin		theCharNum := 0;		UnderLineToBlanks(ds);		if ds <> '' then			for ic := 1 to numchars do				begin					tds := CharName(ic);					if StringsEqual(@tds, @ds, cnw) then						begin							theCharNum := ic;							leave;						end;				end;		if theCharNum = 0 then			NewError(329, 0);		GetCharNumber := theCharNum;	end;{----------------------------------------------------------------------------}	function TokenToCharNum (token: str255): integer;		var			ic: integer;	begin		if NumericalToken(token) then			ic := TokenToInteger(token, true)		else			ic := GetCharNumber(token);		if ic > numchars then			ic := numchars		else if ic < 1 then			ic := 1;		TokenToCharNum := ic;	end;{|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	function footpresent (it, ic: integer): boolean;{true iff taxon it and character ic have a footnote attached}		var			taxstsHdlPtr: HdlPtr;	begin		footpresent := false;		if AnyFeet(footText) then			if (it <= numtaxa) and (ic <= numchars) then				begin					if (it > 0) & (ic > 0) then	{it's an inner data cell}						begin							TaxstsHdlPtr := HdlPtr(GetMaster(TaxstsCHUNKs) + HdlSize * (it - 1));							footpresent := Bittst(Ptr(GetMaster(TaxStsHdlPtr^) + longint(ic - 1) * tcb), FTo);						end					else if it = 0 then		{it is in a character name}						footpresent := getchHdl(ic)^^.footText					else							{it is in a taxon name}						footpresent := gettaxonHdl(it)^^.footText				end;	end;{-----------------------------------------------------------------------------}	function footpictpresent (it, ic: integer): boolean;{true iff taxon it and character ic have a picture attached}		var			taxstsHdlPtr: HdlPtr;	begin		footpictpresent := false;		if AnyFeet(footPict) then			if (it <= numtaxa) and (ic <= numchars) then				begin					if (it > 0) & (ic > 0) then						begin							TaxstsHdlPtr := HdlPtr(GetMaster(TaxstsCHUNKs) + HdlSize * (it - 1));							footpictpresent := Bittst(Ptr(GetMaster(TaxStsHdlPtr^) + longint(ic - 1) * tcb), FPo);						end					else if it = 0 then						footpictpresent := getchHdl(ic)^^.footpict					else						footpictpresent := gettaxonHdl(it)^^.footPict				end;	end;{----------------------------------------------------------------------------}	procedure SetFootBits (theFoot: Integer; it, ic: integer; addit: boolean);{this procedure sets the bits saying that feet are either present (addit=true)}{or absent (addit=false) for cell it, ic}		var			charHdl: chHdl;			TaxonHdl: thdl;			cellbit: integer;			tsp: Ptr;	begin		if theFoot = footText then			cellbit := FTo		else			cellbit := FPo;		if (it <> 0) and (ic <> 0) then			{it is in an internal cell}			begin				tsp := Ptr(GetMaster(HdlPtr(GetMaster(TaxstsCHUNKs) + HdlSize * (it - 1))^) + longint(ic - 1) * tcb);				if addit then					Bitset(tsp, cellbit)				else					Bitclr(tsp, cellbit);			end		else if it = 0 then			begin				charHdl := getchHdl(ic);				if theFoot = footText then					charHdl^^.footText := addit				else if theFoot = footPict then					charHdl^^.footPict := addit;			end		else			begin				TaxonHdl := gettaxonHdl(it);				if theFoot = footText then					TaxonHdl^^.footText := addit				else if theFoot = footPict then					TaxonHdl^^.footPict := addit;			end;	end;{----------------------------------------------------------------------------}	function SomeFeetPresent: boolean;	var somefeet: boolean;		thefoot: integer;	begin		somefeet := false;		for theFoot := 0 to maxfoottype do			if AnyFeet(theFoot) then				somefeet := true;		SomeFeetPresent := somefeet;	end;{----------------------------------------------------------------------------}{$IFC FALSE}	function StatePicture (ic, is: integer; var thetaxon: integer): boolean;{returns true iff state 'is' if character 'ic' has at least one picture;}{that is, there exists a taxon, possessing state is for character ic, }{that has a picture for character ic}{ in thetaxon is returned the number of the taxon that contains that picture}		var			it: integer;	begin		StatePicture := false;		thetaxon := 0;		if AnyFeet(footPict) then			for it := 1 to numtaxa do				if footpictpresent(it, ic) & (is in GetTaxonStsLargest(it, ic)) then					begin						StatePicture := true;						thetaxon := it;						leave;					end;	end;{$ENDC}{-----------------------------------------------------------------------------}	function InShadeCharSet (ic: integer): boolean;{returns true if character ic is in the current charset}		var			charHdl: chHdl;	begin		charHdl := chHdlPtr(GetMaster(chCHUNKs) + HdlSize * longint(ic - 1))^;		InShadeCharSet := charhdl^^.charSetToShade;	end;{-----------------------------------------------------------------------------}	function InCharSet (ic: integer): boolean;{returns true if character ic is in the current charset}		var			charHdl: chHdl;	begin		charHdl := chHdlPtr(GetMaster(chCHUNKs) + HdlSize * longint(ic - 1))^;		InCharSet := charhdl^^.charSet;	end;{-----------------------------------------------------------------------------}	procedure setInCharSet (ic: integer; on: boolean);		var			charHdl: chHdl;	begin		charHdl := chHdlPtr(GetMaster(chCHUNKs) + HdlSize * longint(ic - 1))^;		charhdl^^.charSet := on;	end;{----------------------------------------------------------------------------}	procedure setSetLinkValue (theChain, theLink, ir: integer; on: boolean);		var			oldState: SignedByte;			linkH: Handle;			exP: IP;			it: integer;			offset: integer;			wasOn: boolean;				begin		linkH := GetDirectLinkH(theChain,theLink);		LockHandle(linkH, oldState);		offset := LinkOffSet(linkH);		exP := IP(GetMaster(linkH) + offset + exb * longint(ir - 1));		wasOn := exp^=1;		if on then			begin				exp^:= 1;				if not wasOn then					begin						exp := ip(GetMaster(linkH) + numberInLinkByte);  {don't need to lock}						exp^ := exp^+1;					end;			end		else  			begin				exp^ := 0;				if wasOn then					begin						exp := ip(GetMaster(linkH) + numberInLinkByte);  {don't need to lock}						exp^ := exp^-1;					end;			end;		ResetHandle(linkH, oldState);	end;{----------------------------------------------------------------------------}	procedure setCharSetLinkValue (theLink: longint;  ic: integer; on: boolean);	begin//		InstantInfo(LinkNameFromChain(charSetChain, theLink));		setSetLinkValue(charSetChain,theLink,ic, on);	end;{----------------------------------------------------------------------------}	procedure setTaxSetLinkValue (theLink: longint;  it: integer; on: boolean);	begin		setSetLinkValue(taxSetChain,theLink,it, on);	end;{----------------------------------------------------------------------------}	function InSetLink (theChain, theLink, ir: integer): boolean;		var			oldState: SignedByte;			linkH: Handle;			exP: IP;			it: integer;			offset: integer;			inSet: boolean;	begin		linkH := GetDirectLinkH(theChain,theLink);		LockHandle(linkH, oldState);		offset := LinkOffSet(linkH);		exP := IP(GetMaster(linkH) + offset + exb * longint(ir - 1));		if (exp^ = 1) then			inSet := false		else if (exp^ = 0) then 			inSet := true;		ResetHandle(linkH, oldState);		InSetLink := inSet;	end;{----------------------------------------------------------------------------}	function InCharSetLink (theLink: longint;  ic: integer): boolean;	begin		InCharSetLink := InSetLink(charSetChain,theLink,ic);	end;{----------------------------------------------------------------------------}	function InTaxSetLink (theLink: longint; it: integer): boolean;	begin		InTaxSetLink := InSetLink(taxSetChain,theLink,it);	end;{----------------------------------------------------------------------------}	procedure setInTaxSet (it: integer; on: boolean);		var			taxonHdl: tHdl;	begin		TaxonHdl := THdlPtr(GetMaster(TaxonCHUNKs) + HdlSize * longint(it - 1))^;		taxonHdl^^.taxSet := on;	end;{-----------------------------------------------------------------------------}	function InTaxSet (it: integer): boolean;{returns true if taxon it is in the current taxset}		var			taxonHdl: tHdl;	begin		TaxonHdl := THdlPtr(GetMaster(TaxonCHUNKs) + HdlSize * longint(it - 1))^;		InTaxSet := taxonHdl^^.taxSet;	end;{-----------------------------------------------------------------------------}	function SetNumber (ds: str255; checkLast: boolean; theChain: Integer): integer;{given the name of a charset or taxset, returns the number of the charset or taxset in the userlinks}{ds will be in upper case}{this is only used in ReadMisc, in GetCharListPiece}		var			j, oldchunkpos: integer;			theSetNumber: integer;			tds: str255;			endpoint: integer;	begin		oldchunkPos := chunkpos;		theSetNumber := notASet;		if (theChain = charSetChain) then			if nucleotides then				begin					if ds = 'POS1' then						theSetNumber := pos1charSet					else if ds = 'POS2' then						theSetNumber := pos2charSet					else if ds = 'POS3' then						theSetNumber := pos3charSet					else if ds = 'NONCODING' then						theSetNumber := nonCodingCharSet;				end			else if ds = 'INVAR' then				theSetNumber := invarCharSet			else if ds = 'UNINFORM' then				begin					theSetNumber := uninformCharSet;					NewError(413, 0);				end;		if theSetNumber = notASet then {we haven't found it among pre-defined charsets}			begin				if checkLast then    {v3.04: added this as there are some circumstances in which we do *not* want}							{to check the last link in the chain}					endpoint := EndUserLink(theChain)				else					endpoint := EndUserLink(theChain) - 1;				for j := StartUserLink(theChain) to endpoint do					begin						tds := LinkNameFromChain(theChain, j);						if StringsEqual(@tds, @ds, cnw) then							begin								theSetNumber := j;								leave;							end;					end;			end;		setNumber := theSetNumber;		chunkpos := oldchunkpos;  {restore this so that reading of other links doesn't get messed up}	end;{-----------------------------------------------------------------------------}	function NewlyDeletedTaxaFollowing(it: integer): integer;	begin		 NewlyDeletedTaxaFollowing := GetTaxonHdl (it)^^.newlyDeletedFollowing;	end;{-----------------------------------------------------------------------------}	procedure SetNewlyDeletedTaxa(it: integer; amount: integer);	begin		 GetTaxonHdl (it)^^.newlyDeletedFollowing := amount;	end;{-----------------------------------------------------------------------------}	function NewlyDeletedCharactersFollowing(ic: integer): integer;	begin		 NewlyDeletedCharactersFollowing := GetchHdl (ic)^^.newlyDeletedFollowing;	end;{-----------------------------------------------------------------------------}	procedure SetNewlyDeletedCharacter(ic: integer;amount: integer);	begin		 GetchHdl (ic)^^.newlyDeletedFollowing := amount;	end;	{-----------------------------------------------------------------------------}	function TaxonIsNewlyInserted(it: integer): boolean;	begin		 TaxonIsNewlyInserted := GetTaxonHdl (it)^^.newlyInserted;	end;{-----------------------------------------------------------------------------}	procedure SetNewlyInsertedTaxon(it: integer; on: boolean);	begin		 GetTaxonHdl (it)^^.newlyInserted := on;	end;{-----------------------------------------------------------------------------}	function CharIsNewlyInserted(ic: integer): boolean;	begin		 CharIsNewlyInserted := GetchHdl (ic)^^.newlyInserted;	end;{-----------------------------------------------------------------------------}	procedure SetNewlyInsertedCharacter(ic: integer; on: boolean);	begin		 GetchHdl (ic)^^.newlyInserted := on;	end;{-----------------------------------------------------------------------------}	procedure StoreOldNumbers(whichinfo: integer);	var ir: integer;	begin		case whichinfo of			charinfo:				for ir := 1 to numchars do					GetchHdl (ir)^^.oldNumber := ir;			taxinfo:				for ir := 1 to numtaxa do					GetTaxonHdl (ir)^^.oldNumber := ir;			otherwise;		end;	end;{-----------------------------------------------------------------------------}	procedure SetLastChangeInEditor(lastChange: integer);  	{this one wipes out previous memory/settings for last change, as recorded by lastChangeInEditor,	and then sets lastChangeInEditor to the new type of change}	var ic, it: integer;	begin				if lastChange <> lastChangeInEditor then			begin				case lastChangeInEditor of					lastChangeCellBlock:						EmptyCellBlock(EWUndoBlockP);											lastChangeInsertCharAndCellBlock:						begin							EmptyCellBlock(EWUndoBlockP);							for ic := 1 to numchars do								SetNewlyInsertedCharacter(ic,false);						end;											lastChangeInsertTaxaAndCellBlock:						begin							EmptyCellBlock(EWUndoBlockP);							for it := 1 to numTaxa do								SetNewlyInsertedTaxon(it,false);						end;											lastChangeAddCharacters:						for ic := 1 to numchars do							SetNewlyInsertedCharacter(ic,false);													lastChangeAddTaxa:						for it := 1 to numTaxa do							SetNewlyInsertedTaxon(it,false);					lastChangeDataCell, lastChangeNameCell:						if (lastChange<>lastChangeDataCell) & (lastChange<>lastChangeNameCell) then							begin								undoCellTaxon:= 0;								undoCellCharacter := 0;							end;					lastChangeNameRow:						begin							undoNameRow := 0;							undoWhichInfo := noInfo;						end;					lastChangeMoveCharacters,lastChangeMoveTaxa:						begin							lastChangeIsEither := true;						end					otherwise;				end;			end;		lastChangeInEditor := lastChange;		lastChangeIsEither := false;		case lastChangeInEditor of			lastChangeMoveCharacters,lastChangeMoveTaxa:				lastChangeIsEither := true;			otherwise;		end;		EnableDisableITem(EditMHdl, UndoItem, lastChangeInEditor<>lastChangeCantUndo);	end;{-----------------------------------------------------------------------------}	procedure LoadTaxonCHUtil;	begin	end;end.