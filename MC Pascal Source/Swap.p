unit Swap;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, TypeUtil, MenuUtil, CharUtil, Prohibitions, SetStates, TreeUtil, LinkUtil, CalcUtil, Calc, Genchar, InfoWindows, Legends, Count, Coloring, TraceControl, TreeMaker, TreeMover, RandomTree, TreeDrawer;	procedure LoadSearchCursors(whichCurs: integer); 	procedure NextSearchCursor(whichCurs: integer); 	procedure ReleaseSearchCursors(whichCurs: integer); 	procedure BranchSwap (N: Nptr; swapisabove: boolean);{	procedure OptimalAncestorSearch (N: Nptr; swapisabove, tryAll: boolean);}			var		swapabort: boolean;		swapdone: BOOLEAN;{еееееееееееееееееееееее}implementation {е$S Swap}var rerootAfterSwap: boolean;{###################===BRANCH SWAPPING====####################################}{This unit performs local branch swapping}{-----------------------------------------------------------------------------}	procedure SwapReport (ds1, ds2: str255);{This presents little swap report regarding swap completed, etc.}		var			tport: WindowPtr;	begin		genericGetPort(tport);		genericSetPort(tlegwindow);		cliprect(WindowPortRect(tlegwindow));		EraseRect(WindowPortRect(tlegwindow));		Beep;		Beep;		MoveTo(5, 10);		DrawString('Search');		MoveTo(5, 20);		DrawString(ds1);		MoveTo(5, 35);		DrawString(ds2);		MoveTo(5, 55);		DrawString('Click To Continue');		pause;		InvalidateWindow(tlegWindow, true);		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	procedure QuickTreeUpdate;		var			oldRgn: RgnHandle;	begin		OldRgn := newRgn;		GetClip(oldRgn);		ClipRect(WindowPortRect(treeWindow));		DrawTree;		SetClip(oldRgn);		ZapRegion(oldRgn);	end;{-----------------------------------------------------------------------------}{-----------------------------------------------------------------------------}	procedure NextSearchCursor(whichCurs: integer); 	begin		searchCursorNumber[whichCurs] := searchCursorNumber[whichCurs] + 1;		if searchCursorNumber[whichCurs] > maxSearchCursors[whichCurs] then			searchCursorNumber[whichCurs] := 0;		SetCursor(searchCursor[whichCurs,searchCursorNumber[whichCurs]]^^);	end;{-----------------------------------------------------------------------------}	procedure LoadSearchCursors(whichCurs: integer); 	var j: integer;	begin		for j := 0 to maxSearchCursors[whichCurs] do  {load cursors}			searchCursor[whichCurs,j] := GetCursor(searchCursorBaseID[whichCurs] + j);	end;{-----------------------------------------------------------------------------}	procedure ReleaseSearchCursors(whichCurs: integer); 	var j: integer;	begin		for j := 0 to maxSearchCursors[whichCurs] do  {load cursors}			ReleaseResource(Handle(searchCursor[whichCurs,j]));	end;{-----------------------------------------------------------------------------}	procedure checkPauseAbort;	begin		if commandperiod then			SwapAbort := true		else if eventavail(mdownmask, event) then			repeat			until not button;    {this is a pause, lets you record things while mouse held down}	end;{-----------------------------------------------------------------------------}		procedure SetEasterColor;			var				choice: integer;		begin			textmode(srcOR);			choice := RandomBetween(1, 5);			case choice of				1: 					ForeColor(bluecolor);				2: 					ForeColor(redcolor);				3: 					ForeColor(greencolor);				4: 					ForeColor(cyancolor);				5: 					ForeColor(yellowcolor);			end;		end;{-----------------------------------------------------------------------------}		procedure DrawCharOnNode (c: char; nN: Nptr; easterEgg: boolean);		var tport: WindowPtr;		begin			if not showNewTreeWhileSearching then				if IsAnc(ScreenR, nN) then					begin						genericGetPort(tport);						genericSetPort(treewindow);						penmode(patxor);						MoveToOrient(nN^.loc.h - 6 + edw div 2, nN^.loc.v + 11); {was 2,2}						textfont(kFontIDGeneva);						textsize(18);						textface([bold]);						if easterEgg & colorQDExists & ScreenInColor & (c = 'е') then							SetEasterColor						else							textmode(srcXOR);						drawchar(c);						if easterEgg & colorQDExists then							ForeColor(blackcolor);						textmode(srcOr);						textfont(TWFont);						textsize(TWFontSize);						textface([]);						penmode(patcopy);						if slowbranchswap then							Delay(10, ticks);						genericSetPort(tport);					end;		end;{-----------------------------------------------------------------------------}		procedure SwapAboveLocalCount (theDialog: DialogPtr; pN: Nptr; result1, result2: Ptr; stopN: Nptr;easterEgg, longTrees:boolean; var atLeastOneSwapFound, swapFoundThisPass: boolean);{FROZEN 3.0}{Swaps, traversing up until hits stopN}{Swaps by counting local differences among different local rearrangements}{Can only be done when all characters of unord, ord, irrev}{if any fisher, dollo, user-defined, then uses SwapAboveFullCount}			var				ic, len1, len2, len3: longint;				oldState: SignedByte;				A, B, C, D: Handle;				Ap, Bp, Cp, Dp: Ptr;				sideN: Nptr;{...............}			procedure ResetTreeLengthSpecial (doIrrevAndOnly: boolean);{Resets length of tree, assuming lengths of characters already calculated.}{This is special version which either adds in only irreversible, or}{everything but irreversible}				var					cwtP, cTypP: IP;					clenP: LIP;					ic: integer;					oldState3: SignedByte;			begin				LockHandle(chwtH, oldstate3);				clenP := LIP(GetMaster(chlenH)); {don't need to lock these since already locked outside}				cwtP := IP(GetMaster(chwtH));				ctypP := IP(GetMaster(chtypH));				if doirrevAndOnly then					for ic := 1 to numchars do  {adding lengths of only irreversible characters}						begin							if (ctypP^ = irreversible) then								if AddToLength(treelength, clenP^, cwtP^, ctypP^) = false then									NewError(308, 0);							clenP := LIP(ord4(clenP) + chlb);							cwtP := IP(ord4(cwtp) + chwb);							ctypP := IP(ord4(ctypp) + chtb);						end				else					for ic := 1 to numchars do {adding lengths of only unordered and ordered characters}						begin							if (ctypP^ <= ordered) then								if AddToLength(treelength, clenP^, cwtP^, ctypP^) = false then									NewError(308, 0);							clenP := LIP(ord4(clenP) + chlb);							cwtP := IP(ord4(cwtp) + chwb);							ctypP := IP(ord4(ctypp) + chtb);						end;				ResetHandle(chwtH, oldstate3);			end;{...............}			procedure TryArrange (Ap, Bp, Cp, Dp: Ptr; var len: longint; atroot: boolean);{Calculates local length for arrangement, over all characters.}{Only works when all characters are ordered, unordered, irreversible}				var					ctypP: ip;					clenP: lip;					ic: integer;					oldState1, oldState2: SignedByte;			begin				NextSearchCursor(searchSwap);				treelength := 0; {initialized treelength to 0}				LockHandle(chlenH, oldstate1);				LockHandle(chtypH, oldstate2);				ctypP := IP(GetMaster(chtypH));				clenP := LIP(GetMaster(chlenH));				ZeroBlockLongWords(Ptr(clenP), numchars);{memory: depends on longint storage for lengths} {  C    A   B  }{   \     \/    }{     \   pN    }{       \/       }{       /         }{      D          }{First Combine A and B, using assembly procedures which take two node dnst/upst blocks and combine}				StSetsOpC(tcb, result1, Ap, Bp, clenP, ctypP, numchars); {note using general ASM procs}   {DDDD}{Then Combine to result1 at pN with C}				StSetsOpC(tcb, result2, result1, Cp, clenP, ctypP, numchars);   {DDDD}				if Anytype([irreversible]) then					ResetTreelengthSpecial(true);  {we are done with irreversible; add them to count}				if Anytype([unordered, ordered]) then					begin{Now for all unord and ordered types combine with D to get total local distance}						if not atroot then							StSetsOpC(tcb, result1, result2, Dp, clenP, ctypP, numchars);   {DDDD}						ResetTreelengthSpecial(false);  {now add non-irrev to count}					end;				ResetHandle(chlenH, oldstate1);				ResetHandle(chtypH, oldstate2);				len := treelength;			end;{...............}	begin		if (pN <> stopN) and not swapAbort then			begin				if showbranchswappath then					DrawCharOnNode('?', pN,easterEgg);				sideN := sis(pN);{getting the four blocks of downstates and upstates that will be participating in local calculations}				A := pN^.lf^.dnstH;  {descendant's downstates}				B := pN^.rt^.dnstH;				C := sideN^.dnstH;  {sister's downstates}				D := pN^.anc^.upstH;  {ancestor's upstates}{lock blocks of dnst upst and get master pointers}				Ap := SetPtrFromHandleLock(A, 1);				Bp := SetPtrFromHandleLock(B, 1);				Cp := SetPtrFromHandleLock(C, 1);				Dp := SetPtrFromHandleLock(D, 1);{  C    A   B  }{   \     \/    }{     \   pN    }{       \/       }{       /         }{      D          }				TryArrange(Ap, Bp, Cp, Dp, len1, pN^.anc = R); {Calculate local length for rearr. 1 (current)}				TryArrange(Ap, Cp, Bp, Dp, len2, pN^.anc = R); {Calculate local length for rearr. 2}				TryArrange(Cp, Bp, Ap, Dp, len3, pN^.anc = R); {Calculate local length for rearr. 3}				Unlock3Handles(A, B, C);				HUnlock(D);{compare three lengths to see if any are better than current arrangment (quickestdescent)}{or better than best rearrangment so far found (steepestdescent)}				if (not longtrees & ((maxswap < len1 - len2) & (len2 < len3))) | (longtrees & ((maxswap < len2 - len1) & (len2 > len3))) then					begin  {........ Best Rearrangment is number 2}						if not longtrees then							maxswap := len1 - len2						else							maxswap := len2 - len1;						fromN := pN^.lf;						toN := sideN;						atLeastOneSwapFound := true;						swapFoundThisPass := true;					end				else if (not longtrees & (maxswap < len1 - len3)) | (longtrees & (maxswap < len3 - len1)) then					begin {........ Best Rearrangment is number 3}						if not longtrees then							maxswap := len1 - len3						else							maxswap := len3 - len1;						fromN := pN^.rt;						toN := sideN;						atLeastOneSwapFound := true;						swapFoundThisPass := true;					end				else if oneswap and not atLeastOneSwapFound and (maxswap = 0) then			{we have yet to find any swap yet, and rearrangements might be as good}					begin {........ Current Rearrangment is at least as good}						if len1 = len2 then {if rearr.2 is as good and we are doing SingleSwap}							begin								fromN := pN^.lf;								toN := sideN;								atLeastOneSwapFound := true;								swapFoundThisPass := true;							end						else if len1 = len3 then{if rearr.3 is as good and we are doing SingleSwap}							begin								fromN := pN^.rt;								toN := sideN;								atLeastOneSwapFound := true;								swapFoundThisPass := true;							end;					end;				if ThermoWasAborted(theDialog) then swapAbort := true;				{CheckPauseAbort;}				if showbranchswappath then					DrawCharOnNode('?', pN,easterEgg);{if not quickestdescent then continue regardless}{if quickestdescent then need to to quit as soon as maxswap>0 or when oneswap and atLeastOneSwapFound}{are true}				if not quickestdescent | not ((Maxswap > 0) | (oneswap & atLeastOneSwapFound)) then					begin						if NodeIsInternal(pn^.lf) then							SwapAboveLocalCount(theDialog,pN^.lf, result1, result2, stopN, easterEgg, longTrees,atLeastOneSwapFound, swapFoundThisPass);						if (NodeIsInternal(pn^.rt)) & (not quickestdescent | not ((Maxswap > 0) | (oneswap & atLeastOneSwapFound))) then							SwapAboveLocalCount(theDialog,pN^.rt, result1, result2, stopN, easterEgg, longTrees,atLeastOneSwapFound, swapFoundThisPass);					end;			end;	end;{-----------------------------------------------------------------------------}	function RearrangementIsBetter(longtrees: boolean; nativelength: longint): boolean;	begin		RearrangementIsBetter := ((not longtrees and (treelength < nativelength)) or (longtrees and (treelength > nativelength)));	end;{-----------------------------------------------------------------------------}	procedure ClearCheckedNodes (qN: Nptr);{zero nodes checked}	begin		qN^.int1 := 0;		if (NodeIsInternal(qn)) then			begin				ClearCheckedNodes(qN^.lf);				ClearCheckedNodes(qN^.rt);			end;	end;{-----------------------------------------------------------------------------}	function GetNextStartingNode (qN: Nptr; stopN: Nptr): Nptr;{moves to next unchecked node above pN, following standard pathway.}{Returns SubR if all checked}		var			nf: Nptr;{..............}		procedure FindNextStartingNode (qqN: Nptr);		begin			if (NodeIsInternal(qqn)) and (qqN <> stopN) then				begin					if (qqN^.int1 = 0) then						nf := qqN					else						begin							FindNextStartingNode(qqN^.lf);							FindNextStartingNode(qqN^.rt);						end;				end;		end;{..............}	begin		nF := subR;		FindNextStartingNode(qN);		GetNextStartingNode := Nf;	end;{-----------------------------------------------------------------------------}	procedure SwapAboveFullCount (theDialog: DialogPtr; pN: Nptr; stopN: Nptr;easterEgg, longTrees:boolean; var atLeastOneSwapFound, swapFoundThisPass: boolean; var nativelength, changetreelength: longint);{FROZEN 3.0}{Swaps, traversing up until hits stopN}{When there are fisher, dollo, user-defined types, the above local counting cannot}{be done easily therefore need to do full tree counts after actually moving the branches}{for each rearrangement.}{This procedure keeps track of which branch rearrangments it has tried,}{and which it needs to try, by setting N^.int1 to 0 if untried, 1 if tried.}{This procedure always does QuickestDescent; swaps on first good swap found.}		var			thisnode, TNlf, TNrt, TNC, TNanc: nptr;			j: integer;			TNWasright: boolean;		A, B, C, D: Handle;{............}	begin{ note: does not give same results as local count even when local count and}{full count are both quickestdescent, because full count chooses first}{of two swaps at node that improves length (quickest quickest descent) while local count}{checks both swaps and chooses best, thus locally is steepest even if overall is quickest}		ClearCheckedNodes(pN);		thisnode := GetNextStartingNode(pN, stopN); {get first node unchecked}		while (thisnode <> subR) and not swapAbort and not (swapFoundThisPass) do{oneswap and}			begin				if (NodeIsInternal(thisnode)) and (thisnode <> stopN) then					begin						if showbranchswappath then							DrawCharOnNode('?', thisnode, easterEgg);						thisnode^.int1 := 1;{TNC	TNlf	TNrt	}{   \        \      /  		}{     \        \  /  		}{       \       TN 		}{         \   /  			}{           \/ 			}{         TNanc 			}						NextSearchCursor(searchSwap);						TNC := SIS(thisnode);						TNanc := Thisnode^.anc;						TNlf := thisnode^.lf;						TNrt := thisnode^.rt;{first adjust so TNC is leaning left and TN right}						TNwasright := thisNode = thisNode^.anc^.rt; {remember so as to change back later}						if not TNwasright then							begin {rotate TNanc}								TNanc^.lf := TNC;								TNC^.slant := -1;								TNanc^.rt := thisNode;								Thisnode^.slant := 1;							end;{first Exchange TNC & TNrt}						TNanc^.lf := TNrt;						TNrt^.slant := -1;						TNrt^.anc := TNanc;						thisNode^.rt := TNC;						TNC^.slant := 1;						TNC^.anc := thisNode;						if not CountTree then							NewError(308, 0); {SECOND REARRANGEMENT }						if RearrangementIsBetter(longtrees,nativelength) or ((treelength = nativelength) and oneswap) then							begin {Second Rearrangment better or good enough - use it}								fromN := TNlf; {mark branchswap for 'е'}								atLeastOneSwapFound := true;								swapfoundThisPass := true;								if RearrangementIsBetter(longtrees,nativelength) then									maxswap := 1;  {for quickestdescent, don't need to remember how much better, only that better}								changetreelength := changetreelength + abs(nativelength - treelength);								nativelength := treelength; {setting new nativelength}							end						else							begin{Second Rearrangement not better - try exchanging TNlf and TNrt}								thisNode^.lf := TNrt;								TNrt^.anc := thisNode;								TNanc^.lf := TNlf;								TNlf^.anc := TNanc;								if not CountTree then									NewError(308, 0); {THIRD REARRANGEMENT }								if RearrangementIsBetter(longtrees,nativelength) or ((treelength = nativelength) and oneswap) then									begin {Third Rearrangment better or good enough - use it}										fromN := TNRT; {mark branchswap for 'е'}										atLeastOneSwapFound := true;										swapfoundThisPass := true;										if RearrangementIsBetter(longtrees,nativelength) then											maxswap := 1;  {for quickestdescent, don't need to remember how much better, only that better}										changetreelength := changetreelength + abs(nativelength - treelength);										nativelength := treelength; {setting new nativelength}									end								else									begin{Third Rearrangement not better - undo it}										thisNode^.lf := TNlf; {TNlf^.anc := thisNode;}										TNlf^.slant := -1;										thisNode^.rt := TNrt;										TNrt^.slant := 1;										TNlf^.anc := thisNode;										TNC^.anc := TNanc;										if not TNwasRight then											begin {rotate back if necessary}												TNanc^.rt := TNC;												TNC^.slant := 1;												TNanc^.lf := thisNode;												thisnode^.slant := -1;											end										else											begin												TNanc^.lf := TNC;												TNC^.slant := -1;											end;									end;							end;					end;				if showbranchswappath then					DrawCharOnNode('?', thisnode,easterEgg);				thisnode := GetNextStartingNode(pN, stopN);				if ThermoWasAborted(theDialog) then swapAbort := true;			end;	end;{-----------------------------------------------------------------------------}	function GetNextNodeToMove (qN: Nptr; stopN: Nptr): Nptr;{moves to next unchecked node above pN, following standard pathway.}{Returns SubR if all checked}		var			nf: Nptr;			found: boolean;{..............}		procedure FindNextMovingNode (qqN: Nptr);		begin			if (qqN^.int1 = 0) then				nf := qqN			else if (NodeIsInternal(qqn)) and (qqN <> stopN) then				begin					FindNextMovingNode(qqN^.lf);					FindNextMovingNode(qqN^.rt);				end;		end;{..............}	begin		nF := subR;		FindNextMovingNode(qN);		GetNextNodeToMove := Nf;	end;{-----------------------------------------------------------------------------}	procedure ClearCheckedDestinationNodes (qN: Nptr);{zero nodes checked}	begin		qN^.int2 := 0;		if (NodeIsInternal(qn)) then			begin				ClearCheckedDestinationNodes(qN^.lf);				ClearCheckedDestinationNodes(qN^.rt);			end;	end;{-----------------------------------------------------------------------------}	function GetNextDestinationNode (qN: Nptr): Nptr;{moves to next unchecked node above pN, following standard pathway.}{Returns SubR if all checked}		var			nf: Nptr;			found: boolean;{..............}		procedure FindFirstUnmarkedNode (qqN: Nptr);		begin			if (qqN^.int2 = 0) then				begin					nf := qqN;					found := true;				end;			if (NodeIsInternal(qqn)) & not found then				begin					FindFirstUnmarkedNode(qqN^.lf);					FindFirstUnmarkedNode(qqN^.rt);				end;		end;{..............}	begin		nF := subR;		found := false;		FindFirstUnmarkedNode(qN);		GetNextDestinationNode := Nf;	end;{-----------------------------------------------------------------------------}	procedure SwapSPRFirstImprovement (theDialog: DialogPtr;wholeTreeSearch: boolean; startN: Nptr; stopN: Nptr;easterEgg, longTrees:boolean; var atLeastOneSwapFound, swapFoundThisPass: boolean; var nativelength, changetreelength: longint);{Swaps, traversing up until hits stopN}{This procedure keeps track of which nodes it has tried,}{and which it needs to try, by setting N^.int1 to 0 if untried, 1 if tried.}{This procedure always does QuickestDescent; swaps on first good swap found.}		label 1;		var			nodeToMove: Nptr;  {this is the node that is currently being examined, to see if it could be moved elsewhere}			TNSis, TNanc, TNAncAnc, TNAS: nptr;			dNSis, dNanc: nptr;			destinationNode: Nptr;			TNWasright, TNAncWasRight, dNwasRight, TNAncWasRoot: boolean;			A, B, C, D: Handle;			foundone: boolean;			numt: integer;			destStartN: Nptr;			numnodesexamined: integer;	begin		ClearCheckedNodes(startN);		startN^.int1 := 1; 		numNodesExamined := 0;		nodeToMove := GetNextNodeToMove(startN, stopN); {get first node unchecked}		while (nodeToMove <> subR) and not swapAbort and not (swapFoundThisPass) do   {oneswap and}			begin				numNodesExamined := numNodesExamined+1;				if numNodesExamined=4 then					begin						numT := 1;						numT := 1;					end;				numT := SizeOfClade(R,false);				nodeToMove^.int1 := 1; 				if (nodeToMove=startN^.lf) then					destStartN := startN^.rt				else if (nodeToMove=startN^.rt) then					destStartN := startN^.lf				else					destStartN := startN;				if (nodeToMove <> stopN) then					begin						if showbranchswappath then							DrawCharOnNode('?', nodeToMove, easterEgg);{TNAS    TNSis   nodeToMove}{   \        \      /  		}{     \        \  /  		}{       \       TNAnc 		}{         \   /  			}{           \/ 			}{         TNAncAnc 			}						NextSearchCursor(searchSwap);						TNanc := nodeToMove^.anc;						TNSis := SIS(nodeToMove);						TNwasright := nodeToMove = nodeToMove^.anc^.rt; {remember so as to change back later}						TNAncAnc  := TNAnc^.anc;						TNAncWasRight := TNAnc = TNAncAnc^.rt;						TNAS := SIS(TNAnc);						TNAncWasRoot := TNAnc=R;						if TNAncWasRoot then							begin								R := TNSis;								screenR := R;								drawR := R;							end;						{now disconnect subtree}						TNSis^.anc := TNAncAnc;						if TNAncWasRight then 							begin								TNAncAnc^.rt :=TNSis;								TNAncAnc^.lf := TNAS;							end						else							begin								TNAncAnc^.lf :=TNSis;								TNAncAnc^.rt := TNAS;							end;						{nodeToMove^.anc := subR; }						foundone := false;												{now try reconnections}{dNSis	 }{   \        \      /  		}{     \        \  /  		}{       \       destinationNode 		}{         \   /  			}{           \/ 			}{         dNanc 			}						ClearCheckedDestinationNodes(destStartN);						destStartN^.int2 := 1;						TNSis^.int2 := 1;  {this is where it used to be, so don't place it there}						repeat							destinationNode := getNextDestinationNode(destStartN);							if (destinationNode <> subR) & (destinationNode <> TNSis) then								begin									destinationNode^.int2 := 1;									dNanc := destinationNode^.anc;									dNSis := SIS(destinationNode);									dNwasRight := destinationNode = dNanc^.rt;									{reconnect}									destinationNode^.anc := TNAnc;									TNAnc^.anc := dNanc;									if dNWasRight then 										begin											TNAnc^.rt := destinationNode;											TNAnc^.lf := nodeToMove;											dNAnc^.rt := TNAnc;											dNAnc^.lf := dNSis;										end																		else										begin											TNAnc^.rt := nodeToMove;											TNAnc^.lf := destinationNode;												dNAnc^.lf := TNAnc;											dNAnc^.rt := dNSis;										end;																								{SetTaxaDnSts(1, numchars);}									{numt := SizeofClade (R,false);}									if not CountTree then										begin											NewError(308,0);											{now need to reconnect tree}											destinationNode^.anc := dNanc;											if dNwasRight then												dnAnc^.rt := destinationNode											else												dnAnc^.lf := destinationNode;											goto 1;										end;									foundone := RearrangementIsBetter(longtrees,nativelength) | ((treelength = nativelength) & oneswap);									if not foundone then											begin  {restore destination subtree}											destinationNode^.anc := dNanc;											if dNwasRight then												dnAnc^.rt := destinationNode											else												dnAnc^.lf := destinationNode;										end;								end;							{CheckThermo (theDialog);							if abortedThermo then swapAbort := true;}						until  foundone | (destinationNode=subR) | swapabort;						if foundone then							begin 								if rerootAfterSwap & wholeTreeSearch then									ReRoot(destinationNode,R);  								fromN := nodeToMove; {mark branchswap for 'е'}								atLeastOneSwapFound := true;								swapfoundThisPass := true;								if RearrangementIsBetter(longtrees,nativelength) then									maxswap := 1;  {for quickestdescent, don't need to remember how much better, only that better}								changetreelength := changetreelength + abs(nativelength - treelength);								nativelength := treelength; {setting new nativelength}							end						else							begin1:								nodeToMove^.anc := TNAnc;								TNSis^.anc := TNAnc;								TNAnc^.anc := TNAncAnc;								if TNWasRight then									begin										TNAnc^.rt := nodeToMove;										TNAnc^.lf := TNSis;									end								else									begin										TNAnc^.rt := TNSis;										TNAnc^.lf := nodeToMove;									end;								if TNAncWasRight then									begin										TNAncAnc^.rt := TNAnc;										TNAncAnc^.lf := TNAS;									end								else									begin										TNAncAnc^.rt := TNAS;										TNAncAnc^.lf := TNAnc;									end;								if TNAncWasRoot then									begin										R := TNAnc;										screenR := R;										drawR := R;									end;							end;					end;				if showbranchswappath then					DrawCharOnNode('?', nodeToMove,easterEgg);				nodeToMove := GetNextNodeToMove(startN, stopN);				{if foundOne then					UpdateSearchThermo (theDialog,nativelength)				else					}				if ThermoWasAborted(theDialog) then swapAbort := true;{				CheckPauseAbort;}			end;	end;{-----------------------------------------------------------------------------}	procedure BranchSwap (N: Nptr; swapisabove: boolean);{FROZEN 3.0}{The grand branch swapping procedure, swapping locally either above or below}{node N}		var			easterEgg: boolean;			tempP: WindowPtr;			wascount, wasnullson: boolean;			longtrees: boolean;			ir: INTEGER;			changetreelength: longint;			atLeastOneSwapFound, swapFoundThisPass: BOOLEAN;			fullswapcount: boolean;			nativeLength: longint;			j: integer;			result1, result2: Ptr;			startN, stopN: Nptr;			ds: str255;			tpmain: windowptr;			doupdatequick: boolean;			numt: integer;			SPRSwap, wholeTreeSearch: boolean;			numSPRSwaps: longint;			maxSPRSwaps: longint;			oldR: NPtr;	begin		allowCursorChange := false;		rerootAfterSwap := ControlDown;		maxSPRSwaps :=1;		SPRSwap := fancySearch & (maxSPRSwaps=-1);		if ancon then			InstantError(180){can't search if ancon}		else if allexcluded then			InstantError(121) {can't swap if no included characters}		else			begin				wholeTreeSearch := false;				if swapisabove then   {Search starts at StartN and proceeds until hits StopN}					begin						startN := N;						stopN := subR;						if (startN=R) then wholeTreeSearch := true;					end				else					begin						startN := R;						stopN := N;						if NodeIsTerminal(N) then wholeTreeSearch := true;					end;												genericGetPort(tpmain);				genericSetPort(treewindow);				if fancySearch then					ShrinkTree;				StoreOldTreeForUndo;				noundo := true;				wasnullson := nullson;				doupdatequick := false;				if nullson then					begin{v4: if swap above, why not randomize polytomies just above swap node???}						if Cwarning('Polytomies not allowed with branch swapping.  Do you want to resolve them randomly before swapping?', 'Resolve', 'Cancel') then							begin								PrepareToRandomPoly(R);								RandomizeAllPolytomies(R);								nullson := false;								doupdatequick := true;								drawR := screenR;								undotype := justswap;								justundid := false;								noundo := false;								SetDirtyTree;							end						else							noundo := true;					end;				if fixon then					begin						if Cwarning('Swapping will unfix all states fixed in traced character.  Do you want to proceed?', 'Proceed', 'Cancel') then							begin								Offfix(true);								doupdatequick := true;							end;					end;				if not nullson and not fixon then					begin						if doupdatequick | (traceshown = traceDiscrete) | (traceshown = traceProbability) | (traceshown = traceAllChanges) | (traceshown = traceAllStates) | (traceshown = traceContinuous) then			{get rid of any display of character tracing, etc.}							begin								myHideWindow(chlegWindow);								QuickTreeUpdate;							end;						LoadSearchCursors(searchSwap);{If the boolean longtrees is true, then MacClade will search for longer rather than shorter trees.}						longtrees := searchForLongTrees;						easterEgg := controlEvent(Event);						{if longtrees then							begin								NewError(109, 0);								InvalidateWindow(toolPaletteWindow[treeTools], false);  							end;}{Note OPTIONS:}{QuickestDescent: choose first rearrangement found that improves count or keeps it same (latter only on singleswap).}{SteepestDescent (not QuickestDescent): check all rearrangements, waiting until done, and chose first rearrangment}{that was found which had the greatest effect on treelength.}{Note that if any characters of fisher, dollo, or user-defined types, then must use procedure SwapAboveFullCount}{which only does quickestdescent option.}{Otherwise if all unord, ord, and irrev, use SwapAboveLocalCount which supports either QuickestDescent or SteepestDescent}						fullswapcount := AnyType([fisher, usedef, dollo]) ;						if (fullswapcount) & not quickestdescent then							begin								quickestdescent := true;								NewError(77, 0);							end						else if (fancySearch) & not quickestdescent then							begin								quickestdescent := true;								NewError(417, 0);							end;						swapdone := false;						swapabort := false; { USER requested abort}						atLeastOneSwapFound := false; { Swap has been found}						ir := i; {saving character traced just in case}						setcursor(clockCursor);						{if not oneswap then							begin								TWMessage := 'Hit и-. to cancel';   								WriteTWMessageB;							end;}						wascount := count;						if not count then {must turn on count if not already counted}							begin								SetOnOffCount(true);								if not CountTree then									NewError(110, 0);							end;						changetreelength := 0;						searchCursorNumber[searchSwap] := -1;						result1 := Newptr(tcb * ord4(numchars));  {character blocks for use as intermediates in StSetOpASM}						result2 := Newptr(tcb * ord4(numchars));						Cliprect(treerect);   {primarily for nex7on}						SetUpdatesAllowed(treewindow,showNewTreeWhileSearching);						StartSearchThermo (searchThermo, tempP,treelength);												numSPRSwaps := 0;						nativelength := treelength;												repeat {+++++++++++   Swapping loop  ++++++++++++++++++++}							swapfoundThisPass := false;							{setcursor(clockCursor);}							maxswap := 0;							UpdateSearchThermo (searchThermo,nativelength);							if abortedThermo then swapAbort := true;							{CheckPauseAbort;}							if not SwapAbort then								begin									if fancySearch & SPRSwap & (numSPRSwaps=maxSPRSwaps) then										begin											numSPRSwaps := 0;											SPRSwap := false;										end;									if SPRSwap then										begin											if not CountTree then												NewError(308, 0); {First rearrangement - nativelength}											nativelength := treelength;											oldR := R;											SwapSPRFirstImprovement(searchThermo,wholeTreeSearch, startN,stopN, easterEgg, longTrees,atLeastOneSwapFound, swapFoundThisPass, nativelength, changetreelength);											if (oldR<>R) & (startN = oldR) then												startN := R;											DrawTreeLeg;  											if swapFoundThisPass then												numSPRSwaps := numSPRSwaps+1;										end									else if fullswapcount then  {===Full swap count===}										begin											if not CountTree then												NewError(308, 0); {First rearrangement - nativelength}											nativelength := treelength;											if NodeIsInternal(startN^.lf) then												SwapAboveFullCount(searchThermo,startN^.lf,stopN, easterEgg, longTrees,atLeastOneSwapFound, swapFoundThisPass, nativelength, changetreelength);											if NodeIsInternal(startN^.rt) & not swapAbort & not swapfoundthispass & not (oneswap & atLeastOneSwapFound) then												SwapAboveFullCount(searchThermo,startN^.rt,stopN, easterEgg, longTrees,atLeastOneSwapFound, swapFoundThisPass, nativelength, changetreelength);											DrawTreeLeg;  										end									else										begin  				{===Local swap Count===}											if not CountTree then  {Downpass}												NewError(308, 0);											DrawTreeLeg;  											nativeLength := treelength;											UpPass(R, 1, numchars);  {uppass}											if NodeIsInternal(startN^.lf) then												SwapAboveLocalCount(searchThermo,startN^.lf, result1,result2, stopN, easterEgg, longTrees,atLeastOneSwapFound, swapFoundThisPass);											if NodeIsInternal(startN^.rt) & not swapabort & not (quickestdescent & swapFoundThisPass) then												SwapAboveLocalCount(searchThermo,startN^.rt, result1,result2,stopN, easterEgg, longTrees,atLeastOneSwapFound, swapFoundThisPass);											changetreelength := changetreelength + maxswap;										end;								end;							if (maxswap > 0) or (oneswap and atLeastOneSwapFound) or swapfoundthispass then								begin									DrawCharOnNode('е', fromN,easterEgg);									atLeastOneSwapFound := true;									if not fullswapcount & not SPRSwap then  {if had been using SwapAboveLocalCount, still need to make branch move}										MoveEdge;									if SPRSwap then										DrawR := R;								end							else if fancySearch & not SPRSwap then								begin									SPRSwap := true;									numSPRSwaps := 0;								end							else								swapdone := true;							{Getmouse(wh);}														if showNewTreeWhileSearching then								begin									genericSetPort(treewindow);									DrawTree;									genericSetPort(tempP);								end;						until oneswap or swapdone or swapAbort; {+++++++++++++++++++++++++++++++++++++++}						EndSearchThermo (searchThermo,tempP,true);						SetUpdatesAllowed(treewindow,true);						ZapPointer(result1);						ZapPointer(result2);						i := ir;						if swapabort or atLeastOneSwapFound then							begin								undotype := justswap;								justundid := false;								godraw := true;								dontcancelUpdate := false;								noundo := false;								SetDirtyTree;								if not swapisabove then									ShrinkTree								else									drawR := screenR;								if (changetreelength = 0) & atLeastOneSwapFound & oneswap then									ds := 'one tree found'								else if longtrees then									ds := concat(LengthString(changetreelength, true), ' steps increase')								else									ds := concat(LengthString(changetreelength, true), ' steps decrease');								{if swapabort then									SwapReport('Aborted', ds)								else									SwapReport('Completed', ds)}							end						else							begin								{SwapReport('Completed', 'no trees found');}								noundo := not wasnullson;								justundid := false;								FixLostByUndo := false;								if fullswapcount | fancySearch then									begin										godraw := true;										InvalidateWindow(treewindow, false);										if not swapisabove then											ShrinkTree										else											drawR := screenR;									end;							end;						TWMessage := ' ';						WriteTWMessageB;						FlushEvents(mdownmask, 0);						SetCursorToArrow;						count := true;						RearrangeTreeGoList;  {branch swapping may have rearranged tree; call for calculations}						ReleaseSearchCursors(searchSwap);						FixTreeShadingMenus;						if not wascount and count then							begin								ResetInfoWindow(charinfo);								InvalidateWindow(tlegwindow, false);							end;					end; {not nullson}				genericSetPort(tpmain);			end;{not ancon}		allowCursorChange := true;	end;end.