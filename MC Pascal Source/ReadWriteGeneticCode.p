unit ReadWriteGeneticCode;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  		MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, 		SymbolsNames, TypeUtil, CharUtil, TreeUtil, 		LinkUtil, Windows, ReadUtil, WriteUtil;	function CodeExtrasPresent: boolean;	procedure SetStandardCode (whichcode: integer);	procedure RemapBase (number: integer; var baseNumber: integer);	procedure ReadCustomGeneticCode;	procedure ReadCodeSet;	procedure WriteSetGeneticCode;	procedure WriteCustomGeneticCode;	var		tempgencode: GenCodePtr;		tempextraAAStates: extracodes;		{stores the amino acids that extra AA's 1,2,3,4 correspond to}		CustomCodeRead: boolean;	{еееееееееееееееееееееее}implementation {е$S WriteDataUtil}{----------------------------------------------------------------------------}	function CodeExtrasPresent: boolean;		var			extras: boolean;			j: integer;	begin		Extras := false;		for j := 1 to 4 do			if ExtraAAStates[j] <> -1 then				extras := true;		CodeExtrasPresent := extras;	end;{-----------------------------------------------------------------------------}	procedure setStandardCode (whichcode: integer);		const			Ala = 0;			Cys = 1;			Asp = 2;			Glu = 3;			Phe = 4;			Gly = 5;			His = 6;			Ileu = 7;			Lys = 8;			Leu = 9;			Met = 10;			Asn = 11;			Pro = 12;			Gln = 13;			Arg = 14;			Ser = 15;			Thr = 16;			Val = 17;			Trp = 18;			Tyr = 19;			Ter = 20;			extra1 = 21;			extra2 = 22;			extra3 = 23;			extra4 = 24;			A = 0;			C = 1;			G = 2;			T = 3;		var			j: integer;	begin{universalCode = 1;}{universalExtendedCode = 2;}{drosophilaMTDNACode = 3;}{drosophilaMTDNAExtendedCode = 4;}{mammalMTDNACode = 5;}{mammalMTDNAExtendedCode = 6; }{yeastMTDNACode = 7;}{neurosporaMTDNACode = 8;}{customCode = 9;}{4-fold degenerate}		for j := 0 to 3 do			begin				gencode^[C, C, j] := Pro;				gencode^[C, G, j] := Arg;				gencode^[G, C, j] := Ala;				gencode^[G, G, j] := Gly;				gencode^[G, T, j] := Val;				if (whichCode = universalExtendedCode) or (whichCode = drosophilaMTDNAExtendedCode) or (whichCode = mammalMTDNAExtendedCode) then					gencode^[T, C, j] := extra1				else					gencode^[T, C, j] := Ser;				gencode^[C, T, j] := Leu;				gencode^[A, C, j] := Thr;			end;		gencode^[A, A, T] := Asn;		gencode^[A, A, C] := Asn;		gencode^[A, A, A] := Lys;		gencode^[A, A, G] := Lys;		gencode^[C, A, T] := His;		gencode^[C, A, C] := His;		gencode^[C, A, G] := Gln;		gencode^[C, A, A] := Gln;		gencode^[G, A, T] := Asp;		gencode^[G, A, C] := Asp;		gencode^[G, A, A] := Glu;		gencode^[G, A, G] := Glu;		gencode^[T, T, T] := Phe;		gencode^[T, T, C] := Phe;		gencode^[T, T, A] := Leu;		gencode^[T, T, G] := Leu;		gencode^[T, G, T] := Cys;		gencode^[T, G, C] := Cys;		gencode^[T, G, G] := Trp;		gencode^[T, G, A] := Ter;		gencode^[T, A, T] := Tyr;		gencode^[T, A, C] := Tyr;		gencode^[T, A, A] := Ter;		gencode^[T, A, G] := Ter;{Davidv4.1: check this section as it is different from what I had: this warning is in 3.08 code}		gencode^[A, T, C] := Ileu;		gencode^[A, T, G] := Met;{if (whichCode = universalCode) or (whichCode = universalExtendedCode) then}		gencode^[A, T, T] := Ileu;		gencode^[A, T, A] := Ileu;		gencode^[A, G, T] := Ser;		gencode^[A, G, C] := Ser;		gencode^[A, G, A] := Arg;		gencode^[A, G, G] := Arg;		case whichcode of			universalExtendedCode: 				begin					gencode^[A, G, T] := Extra2;					gencode^[A, G, C] := Extra2;				end;			yeastmtDNACode: 				begin					gencode^[C, T, A] := Thr;					gencode^[C, T, C] := Thr;					gencode^[C, T, G] := Thr;					gencode^[C, T, T] := Thr;					gencode^[A,T,A] := Met;					gencode^[T,G,A] := Trp;				end;			drosophilamtDNACode: 				begin					gencode^[A, G, A] := Ser;					gencode^[A, G, G] := Ser;					gencode^[A,T,A] := Met;					gencode^[T,G,A] := Trp;				end;			drosophilamtDNAExtendedCode: 				begin					gencode^[A, G, T] := Extra2;					gencode^[A, G, C] := Extra2;					gencode^[A, G, A] := Extra2;					gencode^[A, G, G] := Extra2;					gencode^[A,T,A] := Met;					gencode^[T,G,A] := Trp;				end;			mammalmtDNACode: 				begin					gencode^[A, G, A] := Ter;					gencode^[A, G, G] := Ter;					gencode^[A, T, A] := Met;					gencode^[T, G, A] := Trp;				end;			mammalmtDNAExtendedCode: 				begin					gencode^[A, G, T] := Extra2;					gencode^[A, G, C] := Extra2;					gencode^[A, G, A] := Extra4;					gencode^[A, G, G] := Extra4;					gencode^[T, A, A] := extra3;					gencode^[T, A, G] := extra3;					gencode^[A, T, A] := Met;					gencode^[T, G, A] := Trp;				end;			protozoanMTDNACode: 				begin					gencode^[T,G,A] := Trp;				end;			ciliateNucCode: 				begin					gencode^[T,A,A] := Gln;					gencode^[T,A,G] := Gln;				end;			echinoMTDNACode: 				begin					gencode^[A, A, A] := Asn;					gencode^[A, G, A] := Ser;					gencode^[A, G, G] := Ser;					gencode^[T, G, A] := Trp;				end;			candidaCode: 				begin					gencode^[C, T, G] := Ser;				end;			flatwormMTDNACode:				begin					gencode^[A, A, A] := Asn;					gencode^[A, G, A] := Ser;					gencode^[A, G, G] := Ser;					gencode^[T, A,A] := Tyr;					gencode^[T,G,A] := Trp;				end;			otherwise				;		end;		if (whichcode = universalExtendedCode) or (whichcode = drosophilaMTDNAExtendedCode) then			begin				extraAAstates[1] := Ser;				extraAAstates[2] := Ser;				extraAAstates[3] := -1;				extraAAstates[4] := -1;			end		else if whichcode = mammalmtDNAExtendedCode then			begin				extraAAstates[1] := Ser;				extraAAstates[2] := Ser;				extraAAstates[3] := Ter;				extraAAstates[4] := Ter;			end		else			for j := 1 to 4 do				extraAAstates[j] := -1;	end;{----------------------------------------------------------------------------}	procedure RemapBase (number: integer; var baseNumber: integer);{This procedure takes a basenumber, and remaps it to a different basenumber.}	begin		baseNumber := number;		case number of			0: 				baseNumber := 3;   {0 is remapped to T}			1: 				baseNumber := 1;   {1 is remapped to C}			2: 				baseNumber := 0;   {2 is remapped to A}			3: 				baseNumber := 2;   {3 is remapped to G}			otherwise				;		end;	end;{----------------------------------------------------------------------------}	procedure ReadSetGeneticCode (ds: str255);		var			j, k, m: integer;			first, second, third: integer;			reSetCode: boolean;	begin		reSetCode := true;		if ds = 'UNIVERSAL' then			theGeneticCode := universalCode		else if ds = 'UNIVERSAL.EXT' then			theGeneticCode := universalextendedCode		else if ds = 'MTDNA.DROS' then			theGeneticCode := drosophilaMTDNACode		else if ds = 'MTDNA.DROS.EXT' then			theGeneticCode := drosophilaMTDNACode		else if ds = 'MTDNA.MAM' then			theGeneticCode := mammalMTDNACode		else if ds = 'MTDNA.MAM.EXT' then			theGeneticCode := mammalMTDNAExtendedCode		else if ds = 'MTDNA.YEAST' then			theGeneticCode := yeastMTDNACode		else if ds = 'MTDNA.MOLDPROT' then			theGeneticCode := protozoanMTDNACode		else if ds = 'MTDNA.ECHINODERM' then			theGeneticCode := echinoMTDNACode		else if ds = 'MTDNA.FLATWORM' then			theGeneticCode := flatwormMTDNACode		else if ds = 'NUCLEAR.CILIATE' then			theGeneticCode := ciliateNucCode		else if ds = 'NUCLEAR.CANDIDA' then			theGeneticCode := candidaCode{    else if ds = 'MTDNA.NEUR' then theGeneticCode := neurosporaMTDNACode}		else {NEXUS note: if anything else, presume it is custom: note this is supplement...  if ds = 'CUSTOM' then}			begin				reSetCode := false;				if CustomCodeRead then					begin						setStandardCode(universalCode);						theGeneticCode := customcode;						for j := 0 to 3 do							for k := 0 to 3 do								for m := 0 to 3 do									genCode^[j, k, m] := tempGenCode^[j, k, m];						for j := 1 to 4 do							extraAAstates[j] := tempExtraAAStates[j];					end;			end;		if reSetCode then			setStandardCode(theGeneticCode);		RenameAAs;	end;{----------------------------------------------------------------------------}	procedure ReadCodeSet;	var ds: str255;	begin		ds := MakeCaps(GetFileToken(maxtok));		if ds = '*' then  {it's the default CODESET, the only one MacClade will listen too}			begin				ds := MakeCaps(GetFileToken(maxtok));  {this is the name}				ds := MakeCaps(GetFileToken(maxtok));  {this is the = or format token}				if ds <> '=' then					begin						if ds = '(' then							repeat								ds := MakeCaps(GetFileToken(maxtok));  {these are format tokens}								if not ((ds = ')') or (ds = ';') or (fpos >= mcFileLength)) then									if (ds <> 'CHARACTERS') then										begin											NewError(430,0);											Exit(ReadCodeSet);										end;							until (ds = ')') or (ds = ';') or (fpos >= mcFileLength);						if (ds <> ';') and (fpos < mcFileLength) then							ds := MakeCaps(GetFileToken(maxtok));  {this is = token}					end;				ds := MakeCaps(GetFileToken(maxtok));  {this is the first code to be sent token}				ReadSetGeneticCode(ds);			end;	end;{----------------------------------------------------------------------------}	procedure ReadCustomGeneticCode;		var			j, k, m: integer;			first, second, third: integer;			subCommand, ds: str255;			readNames: boolean;			c: char;			tsts: largestSetChars;			inMultipleFormatTokens: boolean;	begin		SetStateSetBoundaries(false);{ok, we have just passed over the GENETICCODE command, and we are now about to proceed into the command}		for j := 1 to 4 do			tempExtraAAStates[j] := -1;		inMultipleFormatTokens := false;		readNames := false;		subCommand := MakeCaps(GetFileToken(maxtok));		repeat			if subCommand = '*' then {it's the default}			else if subCommand = '(' then				inMultipleFormatTokens := true			else if subCommand = ')' then				inMultipleFormatTokens := false			else if (subCommand = 'TOKENS') or (subCommand = 'TOKEN') then				begin					NewError(410, 0);					openasuntitled := true;					Skipper([';'], true);					Exit(ReadCustomGeneticCode);				end			else if (subCommand = 'NOTOKENS') or (subCommand = 'NOTOKEN') then				readNames := false			else if subCommand = 'NUCORDER' then				begin					SkipEqual;					ds := MakeCaps(GetFileToken(maxtok));					if (ds <> 'TCAG') and (ds <> 'UCAG') then						begin							NewError(410, 0);							openasuntitled := true;							Skipper([';'], true);							Exit(ReadCustomGeneticCode);						end;				end			else if subCommand = 'CODEORDER' then				begin					SkipEqual;					ds := MakeCaps(GetFileToken(maxtok));					if ds <> '231' then						begin							NewError(410, 0);							openasuntitled := true;							Skipper([';'], true);							Exit(ReadCustomGeneticCode);						end;				end			else if subCommand = 'EXTENSIONS' then				begin					SkipEqual;   {will be sitting on "}					next := nextdarkchar;					for j := 1 to 4 do						begin							ds := GetFileToken(maxtok);							if ds = ';' then								leave							else if ds = '_' then								tempextraAAstates[j] := -1							else								tempextraAAstates[j] := MinLg(ProteinSetOfChar(ds[1], true, 1, 0, 0));							if ErrorPosted(88) then								begin									badfile := true;									errorflag := true;									leave;								end;							;						end;					next := nextdarkchar;  {go past "}				end			else if (subCommand = '=') and not inMultipleFormatTokens then  {here is the code itself}				begin{if next <> '=' then next := nextdarkchar;	}					for j := 0 to 3 do						begin							RemapBase(j, first);							for k := 0 to 3 do								begin									RemapBase(k, third);									for m := 0 to 3 do										begin											RemapBase(m, second);{if reading names, then use alternate representations - e.g. STP or * or Ter?}											c:= nextdarkchar;											tsts := ProteinSetOfChar(c, true, 1, 0, 0);											if (MSl in tsts) then												tempGenCode^[first, second, third] := 20  {Ter}											else												tempGenCode^[first, second, third] := MinLg(tsts);											if ErrorPosted(88) then												begin													badfile := true;													errorflag := true;													Exit(ReadCustomGeneticCode);												end;										end;								end;						end;										end;			subCommand := MakeCaps(GetFileToken(maxtok));		until (subCommand = ';') or errorflag or (fpos >= mcFileLength);		CustomCodeRead := true;		SetStateSetBoundaries(nucleotides);	end;{-----------------------------------------------------------------------------}	procedure WriteSetGeneticCode;	begin		Puttoken(' * UNTITLED = ');		case theGeneticCode of			universalCode: 				puttoken('Universal');			universalExtendedCode: 				puttoken('Universal.ext');			drosophilaMTDNACode: 				puttoken('mtDNA.dros');			drosophilaMTDNAExtendedCode: 				puttoken('mtDNA.dros.ext');			mammalMTDNACode: 				puttoken('mtDNA.mam');			mammalMTDNAExtendedCode: 				puttoken('mtDNA.mam.ext');			yeastMTDNACode: 				puttoken('mtDNA.yeast');			protozoanMTDNACode: 				puttoken('mtDNA.moldProt');			echinoMTDNACode: 				puttoken('mtDNA.echinoderm');			flatwormMTDNACode: 				puttoken('mtDNA.flatworm');			ciliateNucCode: 				puttoken('Nuclear.ciliate');			candidaCode: 				puttoken('Nuclear.Candida');{neurosporaMTDNACode:  puttoken('mtDNA.neur');}			otherwise				puttoken('UNTITLED');		end;		puttoken(': all ');	end;{-----------------------------------------------------------------------------}	procedure WriteCustomGeneticCode;	{writes custom code, except for the command name}		var			j, k, m: integer;			first, second, third: integer;			ds: str255;			names: boolean;			xx: integer;	begin		SetStateSetBoundaries(false);		names := false;		PutToken(' * UNTITLED (');{    if names then PutToken('NAMES ') else PutToken('SYMBOLS ');}		if (datatype = RNA) then			PutToken('NUCORDER=UCAG CODEORDER=231')		else			PutToken('NUCORDER=TCAG CODEORDER=231');		if CodeExtrasPresent then			begin				putreturn;				puttoken(' EXTENSIONS = " ');				for j := 1 to 4 do					begin						if ExtraAAStates[j] = -1 then							putSingleChar('_')						else							puttoken(ProteinCharOfSet([extraAAstates[j]]));						putSpace;					end;				puttoken('" ');				puttab;			end;		PutTokenReturn(') = ');		for j := 0 to 3 do			begin				RemapBase(j, first);				for k := 0 to 3 do					begin						RemapBase(k, third);						puttab;						for m := 0 to 3 do							begin																	RemapBase(m, second);								if names then									begin										ds := AminoAcidName(gencode^[first, second, third]);										puttoken(ds);										for xx := 1 to (4 - length(ds)) do  {fill in padder so looks nice}											putSpace;									end								else									begin										puttoken(ProteinCharOfSet([gencode^[first, second, third]]));										putSpace;									end;							end;						putreturn;					end;				if j < 3 then					putreturn;			end;		puttab;		SetStateSetBoundaries(nucleotides);	end;end.