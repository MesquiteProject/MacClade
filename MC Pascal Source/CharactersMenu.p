unit CharactersMenu;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, ChangeAssumptions,		Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, 		GenUtil, StrUtil, BoxUtil, ChartWWrite, SymbolsNames, TaxonCHUtil, TypeUtil, Prohibitions, 		TypeDLOGUtil, CharUtil, MenuUtil, TreeUtil, PolyCalc, SetStates, SpreadUtil, LinkUtil, Legends, 		N7on, InfoWindows, Count, TraceControl, TreeMaker, Windows, Typeimport, 		TypeDLOG, ClickInInfoWindow, TreeRandomData, WriteData, Fill;	procedure DoCharacterSetsMenu (ItemNo: integer);	procedure DoDataFormatMenu (ItemNo: integer);		procedure DoInclusionSetMenu (ItemNo: integer);	procedure DoWeightSetMenu (ItemNo: integer);	procedure DoTypeSetMenu (ItemNo: integer);	procedure DoCharListOptionsMenu (ItemNo: integer);	procedure DoCharactersMenu (ItemNo: integer);	procedure DoCharPartListMenu (itemNo: integer);	const		searchinvarchar = 4;		searchexcchar = 5;	var		RemoveChains: boolean;		searchfor: integer;{еееееееееееееееееееееее}implementation {е$S CharactersMenu}	{-----------------------------------------------------------------------------}	procedure SaveMultiFile(writeNotes,writeTrees, writeForeign: boolean);	label		1,2,3;	var		theInfo: FInfo;		oldexists, db: BOOLEAN;		writename: str255;		oldname: str255;		oldState: SignedByte;		Freply: StandardFileReply;		UPP: UniversalProcPtr;		FSP,tempfs: FSSpec;		j: integer;   		newTaxStsCHUNKs,oldTaxStsCHUNKs: Handle; 	   		newchCHUNKs,oldchCHUNKs: Handle;		begin{$IFC NOT CARBON}		UPP := MyNewDlgHookYDUPP(nil);  {$ELSEC}		UPP := nil;{$ENDC}		oldexists := false;		LockHandle(filename, oldState);		PutCustomFile('Save simulation files as', filename^^, Freply,sfgetwhere,UPP);		ShowCursor;		if not Freply.sfGood then			Errorflag := true;		if errorflag then goto 1;		FSP := Freply.sffile;				oldTaxStsCHUNKS := taxStsCHUNKS;		oldchCHUNKS := chCHUNKS;		CreateTemporaryCHUNK(newTaxStsCHUNKs,taxStsCHUNKs,numtaxa);		if errorFlag then goto 1;   {Davidv4.1: but need to clean up old memory!}		taxStsCHUNKS := newTaxStsCHUNKs;		CreateTemporaryCHUNK(newchCHUNKs,chCHUNKs,numchars);		if errorFlag then goto 3;  {Davidv4.1: but need to clean up old memory!}		chCHUNKs := newchCHUNKs;		for j := 1 to 3 do 			begin				FSP.name := concat(FReply.sfFile.name,'.',StringFromNum(j));				FspCreateSaveFile(FSP, oldexists, 'CLAD', 'TEXT');				if errorflag then goto 2;				if oldexists then tempfs:= FSP;				if errorflag then goto 2;								FillBlockWithRandom (1,numtaxa,1,numchars,false,[],defaultFillFraction);				WriteFile(writeNotes,writeTrees, writeForeign);  				if not Errorflag then					begin						if oldexists then							FSpExchangeFilesDeleteTemp(tempfs)						else 							tempfs:= FDI^[writeFileFDI].fs; 						if errorflag then goto 2;						FSpSetFileCreatorType(tempfs, 'CLAD', 'TEXT');						if errorflag then goto 2;					end;				fileLastModified := FSpLastModified(tempfs);			end;2:		RemoveTemporaryCHUNK(newTaxStsCHUNKs,numtaxa);		TaxStsCHUNKS := oldtaxStsCHUNKS;3:		RemoveTemporaryCHUNK(newchCHUNKs,numchars);		chCHUNKS := oldchCHUNKS;1:{$IFC NOT CARBON}		MyDisposeDlgHookYDUPP(UPP);{$ENDC}		ResetHandle(filename, oldState);	end;{-----------------------------------------------------------------------------}	procedure DoAddCharacters;	var			theDialog: DialogPtr;			tempP: windowptr;			addic: longint;			localItemHit: integer;			addToEnd : boolean;	begin		addToEnd := true;		StartDLOG(162, theDialog, tempP);		myShowDialog(theDialog);		SetDLOGText(theDialog, 3, '1', false);		SelectDialogItemText(theDialog,3,0,32767);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);		until (localItemHit in [1, 2, 6]);		if (localItemHit = 1) | (localItemHit=6) then			addic := EditTextInt(TheDialog, 3,true);		if localItemHit = 6 then			begin				addToEnd := false;				localItemHit := 1;			end;					EndDLOG(thedialog, tempP);		if localItemHit = 1 then			if (addic > 0) then				begin					SetCursor(clockCursor);					if addic + numchars > mnchars then {v3.01}						begin							addic := mnchars - numchars-1;							NewError(398, 0);						end;					if addToEnd then						begin							AddNewCharacters(addic, molecular);							SetLastChangeInEditor(lastChangeAddCharacters);						end					else						begin							InsertNewCharacters(addic, 1, molecular);							SetLastChangeInEditor(lastChangeAddCharacters);						end;					genericSetPort(editorWindow);					EraseRect(WindowPortRect(editorWindow));					InvalidateWindowRect(editorWindow,WindowPortRect(editorWindow),false);					CalcEditorMatrixRect;				end			else				Beep;	end;{-----------------------------------------------------------------------------}	procedure FilterChar;		type			LP = ^longint;		var			CharHdl: chHdl;			ds: str255;			theDialog: DialogPtr;			tempP: windowptr;			outputH: Handle;			it, ic, numdest: integer;			dL, dLChar: longint;			anyCharChains: boolean;			outtofile: boolean;			taxstsHdlPtr: HdlPtr;			localItemHit: integer;{...........}		function InvariantChars (remove: boolean; var numdest: integer): boolean;			var				it, ic, oldic, oldnumchars, lastfeet: integer;				invariantfound: boolean;				TD: DialogPtr;				tempP: WindowPtr;				charsts: LargestSetChars;				dL: longint;		begin{=== determining lastfeet ====}			lastfeet := 0;			if remove then				begin					if AnyFeet(footText) or AnyFeet(footPict) then						begin							for ic := numchars downto 1 do								begin									charHdl := getchHdl(ic);									if charHdl^^.footPict or charHdl^^.footText then										begin											lastfeet := ic;											leave;										end;								end;							for it := 1 to numtaxa do								begin									TaxstsHdlPtr := HdlPtr(GetMaster(TaxstsCHUNKs) + HdlSize * (it - 1));									dL := GetMaster(TaxStsHdlPtr^);									for ic := numchars downto lastfeet + 1 do										if Bittst(Ptr(dL + longint(ic - 1) * tcb), FPo) or Bittst(Ptr(dL + longint(ic - 1) * tcb), FTo) then											begin												lastfeet := ic;												leave;											end;								end;						end;				end;{======}			invariantfound := false;			numdest := 0;			ic := 1;			oldnumchars := numchars;			oldic := 1;			DisableWindowUpdates(editorWindow);			DisableWindowUpdates(infoWindow[charinfo]);			StartThermo(TD, tempP, 0, numchars, 'Searching through characters', 'characters', false);			while ic <= numchars do				begin					UpdateThermo(TD, 0, oldic, oldnumchars,false);					if abortedThermo then						leave;					if searchfor = searchinvarchar then						charsts := CharStatesLargest(ic)					else						charsts := [];					if ((searchfor = searchinvarchar) & (charsts = []) | (MonomorphLG(charsts))) | ((searchfor = searchexcchar) & not CharIncluded(ic)) then						begin							if outtofile then								AppendToHandle(outputH, concat(StringFromNum(oldic), chr(13)));							invariantfound := true;							numdest := numdest + 1;							if remove then								if numchars > 1 then									begin										DestroyCharacters(ic, ic, not RemoveChains, (ic <= lastfeet),true, false);										ic := ic - 1;										lastfeet := lastfeet - 1;									end								else									begin										EmptyCharacters(1, 1);										NewError(327, 0);									end;						end;					ic := ic + 1;					oldic := oldic + 1;				end;			EndThermo(TD, tempP, true);			if invariantfound and remove then				begin					ZeroSelection;					InvalidateInfoWindow(charinfo);					InvalidateInfoWindow(taxinfo);				end;			InvariantChars := invariantfound;		end;{............}		procedure CheckFilterChar;		begin			ItemCheckMark(theDialog, 4, searchfor = searchinvarchar);			ItemCheckMark(theDialog, 5, searchfor = searchexcchar);			ItemCheckMark(theDialog, 6, RemoveChains);			ItemCheckMark(theDialog, 7, outtofile);			EnableDisableDLOGItem(theDialog, 6, anyCharChains, true);		end;{...........}	begin		anyCharChains := (UserLinks[CharPartitionchain] > 0) or(UserLinks[wtsetchain] > 0) or (UserLinks[typesetchain] > 0) or (UserLinks[exsetchain] > 0) or (UserLinks[charsetchain] > 0);		outtofile := false;		StartDLOG(422, theDialog, tempP);		myShowDialog(theDialog);		EnableDisableDLOGItem(theDialog, 5, numchars <> numcharin, false);		CheckFilterChar;		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			case localItemHit of				4, 5: 					searchfor := localItemHit;				6: 					RemoveChains := not RemoveChains;				7: 					outtofile := not outtofile;				otherwise					;			end;			CheckFilterChar;		until (localItemHit in [1, 2, 3]);		DisposeDialog(theDialog);		if localItemHit in [1, 3] then			begin				SetCursor(clockCursor);				if outtofile then					outputH := NewHandle(0);				if dirtymaxst then					ReCalcMaxstAndStates(1,numchars);				if outtofile then					begin						AppendToHandle(outputH, concat(MacCladeStamp, chr(13)));						AppendToHandle(outputH, concat(UserStamp(true, true, false), chr(13)));						AppendToHandle(outputH, concat(TimeStamp, chr(13), chr(13)));						AppendToHandle(outputH, concat(DataFileStamp, chr(13), chr(13)));					end;				if searchfor = searchinvarchar then					ds := ' invariant'				else					ds := ' excluded';				if outtofile then					AppendToHandle(outputH, concat(ds, ' characters: ', chr(13), chr(13)));				if InvariantChars(localItemHit = 3, numdest) then					begin						if localItemHit = 1 then							InstantInfo(concat('Number of characters in data matrix that are ', ds, ': ', StringFromNum(numdest)))						else							begin								InstantInfo(concat('Number of characters removed from data matrix that were ', ds, ': ', StringFromNum(numdest)));								if RemoveChains then									DestroyAllCharacterChains;								ZeroSelection;								genericSetPort(editorWindow);								EraseRect(WindowPortRect(editorWindow));								InvalidateWindowRect(editorWindow,WindowPortRect(editorWindow),false);							end;					end				else					begin						InstantInfo(concat('There are no characters in data matrix that are ', ds));						if outtofile then							AppendToHandle(outputH, 'None.');					end;				if outtofile then					begin						if (getHandleSize(outputH) > 0) then							SaveHandleAs(outputH,'Save Search Info as', 'Filtered Characters');						ZapHandle(outputH);					end;			end;		genericSetPort(tempP);	end;{-----------------------------------------------------------------------------}	function CharsSame (i1, i2: integer): boolean;{chars must be exactly the same}		var			same: boolean;			it: integer;	begin		same := TrueTypeOfChar(i1) = TrueTypeOfChar(i2);		if same then			begin				for it := 1 to numtaxa do					if gettaxonstsLargest(it, i1) <> gettaxonstsLargest(it, i2) then						begin							same := false;							leave;						end;			end;		CharsSame := same;	end;{$IFC FALSE}{-----------------------------------------------------------------------------}	procedure DestroyExtraCharacters;		var			ic: integer;			theDialog: dialogPtr;			tempP: WindowPtr;			icstart, icend: integer;	begin				DisableWindowUpdates(editorWindow);				DisableWindowUpdates(infoWindow[charinfo]);		StartThermo(theDialog, tempP, 1, numchars, 'Merging characters...', '', true);		ic := 1;		repeat			if IsCharExtra(ic) then				begin					DestroyCharacters(ic, ic, true, false,true, false,true);					ic := ic - 1;				end;			UpdateThermo(theDialog, 1, ic, numchars,true);			ic := ic + 1		until (ic > numchars) or abortedthermo;		EndThermo(theDialog, tempP, false);		InvalidateWindow(editorWindow, true);	end;{$ELSEC}{-----------------------------------------------------------------------------}	procedure DestroyExtraCharacters(sc,ec: integer);		var			ic: integer;			theDialog: dialogPtr;			tempP: WindowPtr;			icstart, icend: integer;			newec : integer;	begin		DisableWindowUpdates(editorWindow);		DisableWindowUpdates(infoWindow[charinfo]);		StartThermo(theDialog, tempP, 1, ec-sc+1, 'Merging characters...', '', true);		ic := sc;		newec := ec;		repeat			while (ic <= newec) & not IsCharExtra(ic) do  {skip to next IsCharExtra}				ic := ic + 1;			if ic > newec then				ic := newec;			if not IsCharExtra(ic) then  {must be at end, let's skip out}				leave;			icstart := ic;			while (ic <= newec) & IsCharExtra(ic) do   {we are on a stretch of good ones}				ic := ic + 1;			if ic > newec then				ic := newec;			if IsCharExtra(ic) then				icend := ic			else				icend := ic - 1;			DestroyCharacters(icstart, icend, true, false,true,false);			newec := newec - (icend-icstart+1);			ic := icstart - 1;			UpdateThermo(theDialog, 1, ic, ec-sc+1, true);{ic := ic + 1}		until (ic >= numchars) or abortedthermo;		InvalidateInfoWindow(charinfo);		InvalidateInfoWindow(taxinfo);		EndThermo(theDialog, tempP, false);		InvalidateWindow(editorWindow, true);	end;{$ENDC}{-----------------------------------------------------------------------------}	procedure MergeLikeChars(mergeNames,selectInList: boolean);  		var			numlike, ibase, icheck: integer;			ic: integer;			theDialog: dialogPtr;			tempP: WindowPtr;			icstart, icend,st,et,sc,ec: integer;			db: boolean;			totalMerged: integer;			numToMerge: integer;			FinalCharName, newCharName: str255;			newCharNameLength, maxCharNameLength: integer;	begin		totalMerged := 0;		CalcSelectedTaxaCharacters(st, et, sc, ec, true);		ZeroCharExtra;		if editorSelected and editorOpen and SingleCell then  {v3.07}			begin				ReturnValue(editorSelectionTopLeft,false);				if badcellentry then					if BadCellEntryQuery then						badcellentry := false					else						Exit(MergeLikeChars);				ZeroSelection;			end;		if selectInList then			begin				for ic := 1 to numchars do					SelectInfoCell(charinfo,ic,false,false);				ChangeInfoSelectMenuFix(charinfo);			end;		DisableWindowUpdates(editorWindow);		DisableWindowUpdates(infoWindow[charinfo]);		StartThermo(theDialog, tempP, 1, ec-sc+1, 'Searching for identical characters...', '', true);		for ibase := sc to ec - 1 do  {go through each character}			if not IsCharExtra(ibase) then				begin					numlike := TrueCharWeight(ibase);					if not CharIncluded(ibase) & ChangeIncExc(ibase, IncludeItem, nullson or ancon) then						db := true;					UpdateThermo(theDialog, 1, ibase-sc+1, ec-sc+1,true);					if abortedThermo then						leave;					numToMerge := 1;					for icheck := ibase + 1 to ec do  {3.07: check to see how many like characters there are}						if not IsCharExtra(icheck) then							if CharsSame(ibase, icheck) then								numToMerge := numToMerge + 1;					if numToMerge > 1 then						begin							maxCharNameLength := cnw div numToMerge; {v3.07}							if maxCharNameLength < 3 then								FinalCharName := concat(CopyString(CharName(ibase), 1, cnw - 4), '+...')							else								FinalCharName := CopyString(CharName(ibase), 1, maxCharNameLength);							for icheck := ibase + 1 to ec do{check all other characters to see if same}								if not IsCharExtra(icheck) then									begin										if CharsSame(ibase, icheck) then{if same then mark and add 1 to wt counter}											begin												numlike := numlike + TrueCharWeight(icheck);												SetCharExtraToTrue(icheck);												totalMerged := totalMerged + 1;												if maxCharNameLength >= 3 then   {v3.07}													begin														newCharName := CopyString(CharName(icheck), 1, maxCharNameLength - 1);														FinalCharName := concat(FinalCharName, '+', newCharName);														if length(FinalCharName) > cnw - 4 then															FinalCharName := concat(CopyString(FinalCharName, 1, cnw - 4), '+...');													end;											end;									end;							if mergeNames then								SetCharName(ibase, FinalCharName); {v3.07}							if selectInList then								SelectInfoCell(charinfo,ibase,true,false);						end;					if numlike > MaxWtInt then						begin							InstantInfo('Number of identical characters higher than maximum allowable weight: weight will be less than it should be.');							numlike := MaxWtInt;						end;					SetWeight(ibase, numlike);					UsetoWtStorage(ibase);				end;		if selectInList then			ChangeInfoSelectMenuFix(charinfo);		dirtyfile := true;		dirtylink[wtsetchain] := true;		dirtylink[typesetchain] := true;		InvalidateInfoWindow(wtsetinfo);		InvalidateInfoWindow(typesetinfo);		CheckWt1;{$IFC charpartitions}		dirtylink[charPartitionChain] := true;		InvalidateInfoWindow(charPartinfo);		CheckAllOnePartition;{$endc}		errorflag := abortedthermo;		EndThermo(theDialog, tempP, false);		if not errorflag then			begin				DestroyExtraCharacters(sc,ec);				InstantInfo(concat('Number of characters compressed into other characters: ', StringFromNum(totalMerged)));				if editorTransposed then					editorSelectionBotRight.v := editorSelectionBotRight.v-totalMerged				else					editorSelectionBotRight.h := editorSelectionBotRight.h-totalMerged;				CalcEditorSelectionRect(editorSelectionTopLeft,editorSelectionBotRight);				if selectInList & (totalMerged>0) then					begin						OpenOrSelectInfoWindow(charinfo);						ScrollInfoWindowToSelectedRow(charinfo);					end;			end;	end;{-----------------------------------------------------------------------------}	procedure CompressCharacters;		var			theDialog: DialogPtr;			tempP: windowptr;			localItemHit: integer;			mergeNames,selectInList: boolean;{............}		procedure CheckCompressCharacters;		begin			ItemCheckMark(theDialog, 4, selectInList);			ItemCheckMark(theDialog, 5, mergeNames);		end;{...........}	begin		mergeNames := false;		selectInList := true;		StartDLOG(178, theDialog, tempP);		myShowDialog(theDialog);		CheckCompressCharacters;		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			case localItemHit of				4:	selectInList := not selectInList;				5:	mergeNames := not mergeNames;				otherwise					;			end;			CheckCompressCharacters;		until (localItemHit =1) | (localItemHit =2);		EndDLOG(theDialog, tempP);				if localItemHit = 1 then			MergeLikeChars(mergeNames,selectInList);	end;{-----------------------------------------------------------------------------}	procedure DoChopData;		var			it, ic: integer;			tsts: LargestSetChars;	begin		SetCursor(clockCursor);		for it := 1 to numtaxa do			for ic := 1 to numchars do				begin					tsts := gettaxonstsLargest(it, ic);					tsts := tsts * [0..maxstate, UCl, MSl, GAl];   {to chopout any extras}					{if (it=6) & (ic=11) then						begin						 end;}					if (tsts = []) or (tsts = [UCl]) then						tsts := [MSl];					SetTaxonStsLargestFoot(it, ic, tsts);				end;		if MOS > maxstate then			ReCalcMaxstAndStates(1,numchars);		datachanged := true;	end;{-----------------------------------------------------------------------------}	var		unknownPos: boolean;		{true iff some bases have unknown pos}{-----------------------------------------------------------------------------}	procedure QueryConvertUser (theDialog: DialogPtr; itemNo: Integer);	begin		if unknownpos then			DimBox(GetDLOGItemBox(theDialog, 4));	end;{-----------------------------------------------------------------------------}	function QueryDNAProteinConvert: boolean;		var			useCodPos: boolean;			theDialog: DialogPtr;			tempP: WindowPtr;			ic: integer;			H: Handle;			oldState: SignedByte;			localItemHit: integer;UserItemUProcP: UniversalProcPtr;{.......}		procedure CheckQueryconvert;		begin			ItemCheckMark(theDialog, 3, useCodPos);			ItemCheckMark(theDialog, 5, not useCodPos);		end;{.......}	begin		unknownpos := false;		for ic := 1 to numchars do			if CharCodPos(ic) = codeNotSet then				begin					unknownpos := true;					leave;				end;		useCodPos := not unknownpos;		Beep;		Paramtext(GeneticCodeName(theGeneticCode), '', '', '');   {v3.05: had a series of if thens}		StartDLOG(593, theDialog, tempP);		EnableDisableDLOGItem(theDialog, 3, not unknownpos, false);UserItemUProcP := MyNewUserItemUPP(@QueryConvertUser);  H := Handle(UserItemUProcP);		SetDialogItem(theDialog, 8, UserItem, H, GetDLOGItemBox(theDialog, 4));		myShowDialog(theDialog);		FrameButton(theDialog, 1);		CheckQueryConvert;		repeat			ModalDialog(nil, localItemHit);			if ((localItemHit in [3, 4]) and not unknownpos) then				useCodPos := true			else if localItemHit in [5, 6] then				usecodPos := false;			CheckQueryConvert;		until localItemHit in [1, 2];MyDisposeUserItemUPP(UserItemUProcP);		EndDLOG(theDialog, tempP);{$IFC CALCSYNREP}		if OptionEvent(Event) then			begin				QueryDNAProteinConvert := false;				if localItemHit = 1 then					begin						CalcNumSynonymous;						CalcSynReplaceMatrix(useCodPos);					end;			end		else			begin				QueryDNAProteinConvert := localItemHit = 1;				if localItemHit = 1 then					begin{$IFC FALSE}						fileSaved := false;						LockHandle(filename, oldState);						filename^^ := concat(filename^^, '.prot');						SetWTitle(editorWindow, filename^^);						{SetMenuItemText(FileMHdl, AboutFileItem, concat('About ', filename^^, '...'));}						ResetHandle(filename, oldState);						newfile := true;{$ENDC}						infoTop[charinfo] := 1;						infoBottom[charinfo] := infoTop[charinfo] + infoRows[charinfo]-1;						ConvertDNAtoAA(useCodPos);					end;			end;{$ELSEC}		QueryDNAProteinConvert := localItemHit = 1;		if localItemHit = 1 then			begin				fileSaved := false;				LockHandle(filename, oldState);				filename^^ := concat(filename^^, '.prot');				SetWTitle(editorWindow, filename^^);				{SetMenuItemText(FileMHdl, AboutFileItem, concat('About ', filename^^, '...'));}				ResetHandle(filename, oldState);				infoTop[charinfo] := 1;				infoBottom[charinfo] := infoTop[charinfo] + infoRows[charinfo]-1;				ConvertDNAtoAA(useCodPos);				newfile := true;			end;{$ENDC}	end;{-----------------------------------------------------------------------------}	function NucleotidesToProteinPossible: boolean;		var			numCoding, ic: integer;			thePos, lastpos: integer;			badorder: boolean;	begin		NucleotidesToProteinPossible := false;		if (numchars >= 3) and nucleotides then			begin				badorder := false;				numCoding := 0;				lastpos := nonCoding;				for ic := 1 to numchars do					if CodPosSet(ic) then						begin							numCoding := numCoding + 1;							thePos := CharCodPos(ic);  {codon position for current character}							if (ic > 1) then 								if not (((lastPos = nonCoding) & (thePos = 1)) | (lastPos = thePos - 1) | ((lastPos = 3) & (thePos = 1))) then									begin										badorder := true;										leave;									end;							lastpos := thePos;						end					else if IsCoding(ic) then						begin							lastpos := nonCoding;   {not really non coding, but effectively so for purposes of testing order of bases}{    numCoding := numCoding + 1;}						end					else						lastpos := nonCoding;				if badorder then					begin						NucleotidesToProteinPossible := CWarning('Adjacent bases do not have adjacent codon positions, or non-coding position found in the midst of an apparent triplet; throw away partial triplets and proceed?','Proceed','Cancel');					end				else if numCoding < 3 then   {less than three coding positions - this is definitely fatal}					InstantError(293)				else					NucleotidesToProteinPossible := true;			end		else			InstantError(293);   {can't do it if less than 3 characters or not nucleotides}	end;{-----------------------------------------------------------------------------}	procedure TranslateToProtein;	begin	end;{-----------------------------------------------------------------------------}	procedure ExpandContractTypes (oldmaxstate, nexmaxstate, deltamaxstate: integer);		var			j, ifrom, ito: integer;			maxstar: integer;			deletecell: point;	begin		if oldmaxstate > nexmaxstate then {contraction}			begin				for j := usedef to numtypes do					if maxstatedefined(j) > nexmaxstate then						SubtractType(j, false, deletecell)			end		else if oldmaxstate < nexmaxstate then  {expansion}			for j := usedef to numtypes do				begin  {chop types if CST stars would get pushed up beyond maxCS by expansion}					TypeHdl := GetTypeHdl(j);					if (TypeHdl^^.root >= 0) & (TypeHdl^^.maxstar + deltamaxstate > maxCS) then						SubtractType(j, false, deletecell);				end;		ReBuildAssumpMenu;		if deltamaxstate <> 0 then			begin				for j := usedef to numtypes do					begin						TypeHdl := GetTypeHdl(j);						if (TypeHdl^^.root >= 0) then  {CSTREE}							begin								maxstar := TypeHdl^^.maxstar;								if deltamaxstate > 0 then  {moving up}									begin										for ifrom := maxstar downto oldmaxstate + 1 do											begin												TypeHdl^^.nbors[ifrom + deltamaxstate] := TypeHdl^^.nbors[ifrom]; {shifting sets up}												TypeHdl^^.nbors[ifrom] := []; {emptying set left behind}											end;										for ifrom := 0 to maxCS do											for ito := maxstar downto oldmaxstate + 1 do												if ito in (TypeHdl^^.nbors[ifrom]) then  {shifting neighbor set elements up}													TypeHdl^^.nbors[ifrom] := TypeHdl^^.nbors[ifrom] + [ito + deltamaxstate] - [ito];									end								else									begin {moving down}										for ifrom := oldmaxstate + 1 to maxstar do											begin												TypeHdl^^.nbors[ifrom + deltamaxstate] := TypeHdl^^.nbors[ifrom]; {shifting sets down}												TypeHdl^^.nbors[ifrom] := []; {emptying set left behind}											end;										for ifrom := 0 to maxCS do											for ito := oldmaxstate + 1 to maxstar do												if ito in (TypeHdl^^.nbors[ifrom]) then  {shifting neighbor set elements down}													TypeHdl^^.nbors[ifrom] := TypeHdl^^.nbors[ifrom] + [ito + deltamaxstate] - [ito];									end;								if TypeHdl^^.root > oldmaxstate then									TypeHdl^^.root := TypeHdl^^.root + deltamaxstate;								TypeHdl^^.maxstar := maxstar + deltamaxstate;							end;					end;			end;	end;{-----------------------------------------------------------------------------}	procedure RemoveAllSmallSymbolBits;	var it, ic: integer;	begin		for it := 1 to numtaxa do			for ic := 1 to numchars do				begin  					SetAlternativeSymbol(it,ic,false);				end;	end;{-----------------------------------------------------------------------------}	procedure DoDataFormatMenu(ItemNo: integer);		label			1;		var			expandmemory: boolean;			shrinkmemory, DNAtoprotein, chopdata, choptypes: boolean;			deltamaxstate, olddatatype, nexmaxstate, oldmaxstate, j: integer;			db: boolean;			doChopTypes: boolean;			typeHdl: typehandle;	begin		if editorOpen and dirtymaxst then			ReCalcMaxstAndStates(1,numchars);		olddatatype := datatype;		dnatoprotein := false;		expandmemory := (numbytes = 2) and (ItemNo in [stand32Item, proteinitem]);		shrinkmemory := (numbytes = 4) and (ItemNo in [DNAformItem, RNAformItem, standformITEM]);		if (ItemNo in [DNAformItem, RNAformItem]) then			nexmaxstate := maxDNAstate		else if ItemNo = standformItem then			nexmaxstate := 9		else if ItemNo = proteinitem then			nexmaxstate := maxproteinstate		else			nexmaxstate := 25;		oldmaxstate := maxstate;		deltamaxstate := nexmaxstate - oldmaxstate;		doChopTypes := false;		if oldmaxstate > nexmaxstate then {contraction}			begin				for j := usedef to numtypes do					if maxstatedefined(j) > nexmaxstate then						begin							doChopTypes := CWarning('Some user-defined types imply states beyond that allowed in the chosen format - these types will be deleted!', 'Continue', 'Cancel');							if not doChopTypes then								Exit(DoDataFormatMenu)							else								leave;						end;			end		else if oldmaxstate < nexmaxstate then  {expansion}			for j := usedef to numtypes do				begin  {chop types if CST stars would get pushed up beyond maxCS by expansion}					TypeHdl := GetTypeHdl(j);					if (TypeHdl^^.root >= 0) & (TypeHdl^^.maxstar + deltamaxstate > maxCS) then						begin							doChopTypes := CWarning('Some character state trees cannot be represented with chosen format - these types will be deleted!', 'Continue', 'Cancel');							if not doChopTypes then								Exit(DoDataFormatMenu)							else								leave;						end;				end;		chopdata := MOS > nexmaxstate;		if chopdata then			if not CWarning('Some taxa have states beyond that allowed in the chosen format - these data will be lost!', 'Continue', 'Cancel') then				Exit(DoDataFormatMenu);		if not newfile or dirtyfile then			if (datatype = protein) and ((ItemNo = DNAFormItem) or (ItemNo = RNAFormItem)) then   {v3.04: }				if not CWarning('Conversion to nucleotides will be arbitrary!  Are you sure you want to continue?', 'Continue', 'Cancel') then					Exit(DoDataFormatMenu);		if ((olddatatype = DNA) |(olddatatype=RNA)) & not ((ItemNo = DNAFormItem) | (ItemNo = RNAFormItem)) then			RemoveAllSmallSymbolBits;		case ItemNo of			StandFormItem: 				begin					if not (datatype in [standard, standard32]) then						begin							InvalidateWindow(editorWindow, true);							SetLastChangeInEditor(lastChangeCantUndo);						end;					SetDataFormat(standard, molecular & CWarning('Do you want to maintain molecular character state symbols, or set to factory defaults?', 'Defaults', 'Maintain'));					symbolson := false;					{RebuildSelectMenu(charinfo);  }					RebuildShadeCharSetMenu;					RebuildColorCodPosMenu;					CheckColorCharPartitionMenu;					CheckMismatchMenu;				end;			DNAFormItem: 				begin					if not newfile or dirtyfile then						if datatype = protein then							NewError(360, 0);					if datatype <> DNA then						begin							InvalidateWindow(editorWindow, true);							SetLastChangeInEditor(lastChangeCantUndo);						end;					SetDataFormat(DNA, false);{if not (olddatatype in [DNA, RNA]) then SetCodonPositions(1, numchars);}					{RebuildSelectMenu(charinfo);  }					RebuildShadeCharSetMenu;					RebuildColorCodPosMenu;					CheckColorCharPartitionMenu;					CheckMismatchMenu;				end;			RNAFormItem: 				begin					if not newfile or dirtyfile then						if datatype = protein then							NewError(360, 0);					if datatype <> RNA then						begin							InvalidateWindow(editorWindow, true);							SetLastChangeInEditor(lastChangeCantUndo);						end;					SetDataFormat(RNA, false);{    if not (olddatatype in [DNA, RNA]) then SetCodonPositions(1, numchars);}					{RebuildSelectMenu(charinfo);  }					RebuildShadeCharSetMenu;					RebuildColorCodPosMenu;					CheckColorCharPartitionMenu;					CheckMismatchMenu;				end;			proteinItem: 				begin					if nucleotides & (not newfile | dirtyfile) then   {v4: good to check not just for dirtyfile, but emptyfile!}						if (NucleotidesToProteinPossible & QueryDNAProteinConvert) then							expandmemory := false						else							goto 1;					if datatype <> protein then						begin							InvalidateWindow(editorWindow, true);							SetLastChangeInEditor(lastChangeCantUndo);						end;					SetDataFormat(protein, false);					{RebuildSelectMenu(charinfo);  }					RebuildShadeCharSetMenu;					RebuildColorCodPosMenu;					CheckColorCharPartitionMenu;					CheckMismatchMenu;				end;			Stand32Item: 				begin					if not (datatype in [standard, standard32]) then						begin							SetLastChangeInEditor(lastChangeCantUndo);							InvalidateWindow(editorWindow, true);						end;					SetDataFormat(standard32, molecular & CWarning('Do you want to maintain molecular character state symbols, or set to factory defaults?', 'Defaults', 'Maintain'));					{RebuildSelectMenu(charinfo);  }					RebuildShadeCharSetMenu;					RebuildColorCodPosMenu;					CheckColorCharPartitionMenu;					CheckMismatchMenu;				end;			otherwise				;		end;					if doChopTypes then			ExpandContractTypes(oldmaxstate, nexmaxstate, deltamaxstate);		if shrinkMemory then			begin				ContractData;				datachanged := true;			end		else if expandmemory then			begin				ExpandData;				datachanged := true;			end		else if chopdata then			DoChopData;		ReCalcMaxstAndStates(1,numchars);1:		if editorOpen then			if editorSelected and SingleCell then				FillsTE(editorCellTE, CellString);		CheckCurrentTypes;		FixEditMenu;		FixAssumpMenu;		CheckStateNamesSymbolsDanger(true, db);		if datatype <> olddatatype then			begin				CheckSymbolsConflictFinal;  {v3.04:}				dirtyfile := true;			end;	end;{-----------------------------------------------------------------------------}			{-----------------------------------------------------------------------------}	procedure ExcludeUninform;	begin		if not calcMinActive then			CalcMinMaxTreeLen(minlength);		if not calcMaxActive then			CalcMinMaxTreeLen(maxlength);		if infoSomeSelected[charinfo] then			DeSelectAllInfo(charinfo);		DoIncExcCharactersMenu( ExcUninform);	end;{-----------------------------------------------------------------------------}	procedure DoWeightSetMenu (ItemNo: integer);		var			whichRow: longint;	begin		case ItemNo of			WeightSetListItem: 				OpenOrSelectInfoWindow(wtSetinfo);			StoreWeightSetItem: 				{db := SaveLinkDLOG(wtSetCHain);}				MakeNewObject(wtSetinfo,'',true, false,true);			UseWeightSetItem:				if SingleInfoRowSelected(wtsetinfo,whichRow) then					UseSelectedObject(wtsetinfo,whichRow);			AllEqualItem:				begin					linknumber[wtSetChain] := 0;  					ChooseLink(wtSetChain, true);					InvalidateWindow(infoWindow[charinfo],false);					InvalidateWindow(infoWindow[taxinfo],false);					if treeopen then InvalidateWindow(tlegwindow,false);				end			otherwise				;		end;	end;{-----------------------------------------------------------------------------}	procedure DoInclusionSetMenu (ItemNo: integer);		var			whichRow: longint;	begin		case ItemNo of			InclusionSetListItem: 				OpenOrSelectInfoWindow(exSetinfo);			StoreInclusionSetItem: 				{db := SaveLinkDLOG(exSetChain);}				MakeNewObject(exsetinfo,'',true, false,true);			UseInclusionSetItem:				if SingleInfoRowSelected(exsetinfo,whichRow) then					UseSelectedObject(exsetinfo,whichRow);			AllIncludedItem:				begin					linknumber[exSetChain] := 0;  					ChooseLink(exSetChain, true);					InvalidateWindow(infoWindow[charinfo],false);					InvalidateWindow(infoWindow[taxinfo],false);					if treeopen then InvalidateWindow(tlegwindow,false);				end			AllExcludedItem:				;			xxxxExcludeUninformItem: 				if treeopen then					ExcludeUninform				else					InstantError(225);			otherwise				;		end;	end;{-----------------------------------------------------------------------------}	procedure DoTypeSetMenu (ItemNo: integer);	var whichRow: longint;	begin		case ItemNo of			TypeSetListItem: 				OpenOrSelectInfoWindow(typeSetinfo);			StoreTypeSetItem: 				{db := SaveLinkDLOG(typeSetChain);}				MakeNewObject(typeSetinfo,'',true, false,true);			UseTypeSetItem:				if SingleInfoRowSelected(typesetinfo,whichRow) then					UseSelectedObject(typesetinfo,whichRow);			AllUnorderedItem:				begin					linknumber[typeSetChain] := 0;  					ChooseLink(typesetchain, true);					InvalidateWindow(infoWindow[charinfo],false);					if treeopen then InvalidateWindow(tlegwindow,false);				end			AllOrderedItem:				begin					linknumber[typeSetChain] := 1;  					ChooseLink(typesetchain, true);					InvalidateWindow(infoWindow[charinfo],false);					if treeopen then InvalidateWindow(tlegwindow,false);				end			otherwise				;		end;	end;	{-----------------------------------------------------------------------------}	procedure DoCharacterSetsMenu (ItemNo: integer);	begin		case ItemNo of			CharacterSetsListItem :				if (fileopen) then					OpenOrSelectInfoWindow(charsetinfo);			StoreCharacterSetItem:				MakeNewObject(charsetinfo,'',true, false,true);			otherwise				;		end;	end;{-----------------------------------------------------------------------------}	procedure DoCharListOptionsMenu (ItemNo: integer);	begin		case ItemNo of			ShowMissingInCharListItem :				begin					charInfoShowMissing := not charInfoShowMissing;					myCheckMenuItem(CharListOptionsMHdl, ShowMissingInCharListItem, charInfoShowMissing);					SizeInfoWindow (charinfo,false,true);				end;			ShowGapsInCharListItem:				begin					charInfoShowGaps := not charInfoShowGaps;					myCheckMenuItem(CharListOptionsMHdl, ShowGapsInCharListItem, charInfoShowGaps);					SizeInfoWindow (charinfo,false,true);				end;			ShowPartitioninCharListItem:				begin					charInfoShowPartition := not charInfoShowPartition;					myCheckMenuItem(CharListOptionsMHdl, ShowPartitioninCharListItem, charInfoShowPartition);					SizeInfoWindow (charinfo,false,true);				end;			otherwise				;		end;	end;{-----------------------------------------------------------------------------}	procedure DoCharPartListMenu (itemNo: integer);	var whichRow: longint;	begin		case ItemNo of			CharacterPartitionListItem :				if (fileopen) then					OpenOrSelectInfoWindow(charpartinfo);			UseCharPartitionItem:				if SingleInfoRowSelected(charpartinfo,whichRow) then					UseSelectedObject(charpartinfo,whichRow);			StoreCharacterPartitionItem:				MakeNewObject(charpartinfo,'',true, false,true);			ShowCurrentPartitionItem:				if (fileopen) then					begin						if not charInfoShowPartition then							DoCharListOptionsMenu(ShowPartitioninCharListItem);						OpenOrSelectInfoWindow(charinfo);					end;			GroupLabelListItem:				if (fileopen) then					OpenOrSelectInfoWindow(charpartnameinfo);			NewGroupLabelItem:				MakeNewObject(charpartnameinfo,'',true, false,true);			SetSelectedAsGroupItem:				SetSelectedToNewPart(IsEditorWindow(frontWindow));			SetGroupColorItem:				UserChooseSelectedPartNameColor;			otherwise;		end;	end;{-----------------------------------------------------------------------------}	procedure DoCharactersMenu (ItemNo: integer);		var			showtype: integer;			db: boolean;			ic: longint;	begin		case ItemNo of			xxxxCharacterListItem: 				if (fileopen) then					OpenOrSelectInfoWindow(charinfo);								xxxxAddEmptyCharacterItem:				{If OptionEvent(Event) then					SaveMultiFile(false,false,false)				else }					DoAddCharacters;							xxxxEvolveCharacterItem:				if treeopen then 					TreeRandomData;							xxxxCompressCharactersItem: 				if editorOpen then					CompressCharacters;								{xxxxFilterCharactersItem:				if not treeopen then					FilterChar;}								xxxxStateNamesSymbolsItem:				if statesWindowOpen then					SelectWindow(statesWindow)				else					begin						if IsTreeWindow(frontWindow) then							begin								if traceshown=traceDiscrete then									statesWindowCharacter:=i;							end						else if IsEditorWindow(frontWindow)  then							begin								if editorSelected then									begin										statesWindowCharacter := CharOfCell(editorSelectionTopLeft);										if statesWindowCharacter < 1 then StatesWindowCharacter := 1;									end;							end						else if frontwindow = infoWindow[charinfo] then							begin								if infoSomeSelected[charinfo] then									if FirstInfoRowSelected (charinfo, ic) then										statesWindowCharacter := ic;							end;						OpenStatesWindow(false, 0, 0);					end;								xxxxGeneticCodeItem:				GeneticCodeDlog;			xxxxEditTypeItem: 				DefineType(curType);			xxxxImportTypeItem: 				LoadTypes;			otherwise				;		end;	end;{-----------------------------------------------------------------------------}end.