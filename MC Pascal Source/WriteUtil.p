unit WriteUtil;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap, {$IFC POWERPC}		Navigation,{$ENDC}		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil,		 EventUtil, GenUtil, StrUtil, BoxUtil, CharUtil, TreeUtil, ReadWriteUtil, SymbolsNames;	procedure StartWritingToHandle(H: Handle);	procedure EndWritingToHandle;	procedure StartWrite;	procedure EndWrite;	procedure WriteBuffer;	procedure putSingleChar (c: univ integer);	procedure PutTabToken (ds: str255);	procedure puttoken (ds: str255);	procedure putReturn;	procedure puttokenReturn (ds: str255);	procedure putEndofBlock;	procedure putTab;	procedure putBoolean (bool: boolean);	procedure putSimpleLongint (dL: longint);	procedure PutSpace;	procedure putLegalToken (token: str255);	function MCFlagString: str255;	procedure WriteTE (TE: TEHandle; checkForSquareBrackets: boolean);	procedure WriteHandle (H: Handle; delimiter: integer);	function FSpHToResource (FileSpec: FSSpec; ctype,ftype: OSType; rH: Handle; resid: integer; t: restype; resstr: str255): boolean;	procedure FSpStampCLAD (FileSpec: FSSpec);	procedure FSpCreateSaveFile (originalFileSpec: FSSpec; var oldexists: boolean; ctype, ftype: OSType);	function AppendSuffixToFileName (mainFileName, suffix: str255): str255;	function StartSimpleFile(var oldExists: boolean; fileSpec: FSSpec; theFDI: integer): boolean;	function PromptCreateSimpleFile(promptStr: str255; initialName: str255; var oldExists: boolean; theFDI: integer): boolean;	procedure EndSimpleFile(oldExists: boolean; theFDI: integer);	function StartWriteSimpleFile(fileSpec: FSSpec; creator: OSType): boolean;	procedure FSpExchangeFilesDeleteTemp(destinationFSpec: FSSpec);	procedure DrawWriteString (ds: str255);	procedure DrawWriteReturn;	procedure PrintWriteReturn (var currentline: longint);	procedure DrawWriteStringLn (ds: str255);	procedure WritePolySTS (tsts: largestsetchars; cmaxst: SignedByte);	procedure SaveHandleAs (H: Handle; prompt,defaultName: str255);	const		marg = 20;	var		DrawToFile: boolean;		pictResFileExists: boolean;{еееееееееееееееееееееее}implementation {е$S WriteBuffer}{-----------------------------------------------------------------------------}	procedure StartWritingToHandle(H: Handle);	begin		SetHandleSize(H,0);		writingToHandle:= true;		writingH := H;	end;{-----------------------------------------------------------------------------}	procedure EndWritingToHandle;	begin		writingToHandle:= false;		writingH := nil;	end;			var numWrites: integer;{-----------------------------------------------------------------------------}	procedure StartWrite;	begin		SetCursor(clockCursor);		numWrites := 0;		writeBufferCurrentPositionPtr := Ptr(ord4(writeBufferBasePtr) - 1);  {-1 is ok, as it increments one BEFORE it writes anything to current position}		if not IOSuccessful(FSpOpenDF(FDI^[writeFileFDI].fs, fsRdWrPerm, FDI^[writeFileFDI].dfFileNum)) then			errorFlag := true;	end;{-----------------------------------------------------------------------------}	procedure EndWrite;	var db: boolean;	begin		WriteBuffer;		if IOSuccessful(FSClose(FDI^[writeFileFDI].dfFileNum)) then			db := IOSuccessful(FlushVol(nil,FDI^[writeFileFDI].fs.vRefNum));		SetCursorToArrow;		writeBufferCurrentPositionPtr := writeBufferBasePtr;	end;{-----------------------------------------------------------------------------}	procedure WriteBuffer;	var		bytesToWrite, EOFpos: LONGINT;		db: boolean;	begin		numWrites := numWrites+1;		if not errorFlag then			begin				bytesToWrite := ord4(writeBufferCurrentPositionPtr) - ord4(writeBufferBasePtr) + 1;  				currentIOPosition := 8;   {v3.05}				if IOSuccessful(GetEOF(FDI^[writeFileFDI].dfFileNum, EOFpos)) then					if IOSuccessful(SetFPos(FDI^[writeFileFDI].dfFileNum, fsfromLEOF, 0)) then						if IOSuccessful(FSWrite(FDI^[writeFileFDI].dfFileNum, bytesToWrite, writeBufferBasePtr)) then							db := IOSuccessful(SetEOF(FDI^[writeFileFDI].dfFileNum, EOFpos + bytesToWrite));				currentIOPosition := 10;   {v3.05}				writeBufferCurrentPositionPtr :=writeBufferBasePtr;			end;	end;{-----------------------------------------------------------------------------}	procedure IncrementWritingCurrentPosition;	begin		if (ord4(writeBufferCurrentPositionPtr) >= ord4(writeBufferBasePtr) + readWriteBufferSize - 1) then			WriteBuffer  {this will restart it with writeBufferCurrentPositionPtr := writeBufferBasePtr}		else			writeBufferCurrentPositionPtr := Pointer(ord4(writeBufferCurrentPositionPtr) + 1);	end;{-----------------------------------------------------------------------------}	procedure putSingleChar (c: univ integer);	var writeC: integer;		size: longint;		oldState: SignedByte;		p: Ptr;	begin		if c >= 128 then			writeC := c - 256		else			writeC := c;		if writingToHandle then			begin				size := GetHandleSize(writingH);				SetHandleSize(writingH,size+1);				Lockhandle(writingH,oldstate);				p:= Pointer(ord4(GetMaster(writingH))+size);				p^:= writeC;				ResetHandle(writingH,oldstate);			end		else			begin				IncrementWritingCurrentPosition;  				writeBufferCurrentPositionPtr^ := writeC;			end;	end;{-----------------------------------------------------------------------------}	procedure putReturn;	begin		case NexusDelim of			expCR: 				putSingleChar(chr(13));			expLF: 				putSingleChar(chr(10));			expCRLF: 				begin					putSingleChar(chr(13));					putSingleChar(chr(10));				end;			otherwise				;		end;	end;{-----------------------------------------------------------------------------}	procedure putEndOfBlock;	begin{writeEndBlock was added in 3.03, and removed in 3.05}{    if writeEndBlock then  puttoken ( 'ENDBLOCK;' ) else }		puttoken('END;')	end;{-----------------------------------------------------------------------------}	procedure putTab;	begin		putSingleChar(chr(9));	end;{-----------------------------------------------------------------------------}	procedure puttoken (ds: str255);		var			j: integer;	begin		for j := 1 to length(ds) do			putSingleChar(ds[j]);	end;{-----------------------------------------------------------------------------}	procedure PutTabToken (ds: str255);		var			j: integer;	begin		putSingleChar(chr(9));		for j := 1 to length(ds) do			putSingleChar(ds[j]);	end;{-----------------------------------------------------------------------------}	procedure putTokenReturn (ds: str255);	begin		PutToken(ds);		PutReturn;	end;{-----------------------------------------------------------------------------}	procedure putBoolean (bool: boolean);	begin		if bool then			putSingleChar('1')		else			putSingleChar('0');	end;{-----------------------------------------------------------------------------}	procedure putSimpleLongint (dL: longint);	begin		putToken(StringFromNum(dL));	end;{-----------------------------------------------------------------------------}	procedure PutSpace;	begin		putSingleChar(' ');	end;{-----------------------------------------------------------------------------}	procedure putLegalToken (token: str255);		var			j: integer;	begin		StripBlanks(token);		if token = '' then			token := '_'		else			WhiteSpaceToUnderline(token);		if not legalchars(token) then			begin				putSingleChar('''');				for j := 1 to length(token) do					begin						if token[j] = '''' then							putSingleChar('''');						putSingleChar(token[j]);					end;				putSingleChar('''');			end		else			putToken(token);	end;{----------------------------------------------------------------------------}{-----------------------------------------------------------------------------}	function MCFlagString: str255;	begin		MCFlagString := concat('[', MCFlagChar, ']');	end;{-----------------------------------------------------------------------------}	procedure WriteTE (TE: TEHandle; checkForSquareBrackets: boolean);		var			j: longint;			chdl: CharsHandle;			c: char;			brackets: integer;	begin{Davidv4.1:  replace these procedures by ones that directly write whole buffer, eg. by doing}{if writeBufferBasePtr<> writeBufferCurrentPositionPtr then WriteBuffer;  then Write all contents of pointer}		brackets := 0;		chdl := TEGetText(TE);		for j := 0 to TE^^.telength - 1 do			begin				c := chdl^^[j];				if c = '[' then					brackets := brackets + 1				else if c = ']' then					if brackets > 0 then						brackets := brackets - 1;				putSingleChar(c);			end;		if brackets > 0 then   {v3.05: add this to make it so that brackets are balanced}			for j := 1 to brackets do				putSingleChar(']');	end;{-----------------------------------------------------------------------------}	procedure putPointer (p: Ptr; lp: longint; delimiter: integer);		var			j: longint;			dp: Ptr;			isEOL: boolean;	begin		dp := p;		for j := 1 to lp do			begin				IncrementWritingCurrentPosition;				isEOL := false;				if (ord4(dp^)=10) then					isEOL := true				else if (ord4(dp^)=13) then					begin						isEOL := true;						if (ord4(Ptr(ord4(dp) + 1)^)=10) then							dp := Ptr(ord4(dp) + 1);					end;				if isEOL then					begin						if delimiter = ExpCR then							writeBufferCurrentPositionPtr^ := 13						else if delimiter = ExpLF then							writeBufferCurrentPositionPtr^ := 10						else if delimiter = ExpCRLF then							begin								writeBufferCurrentPositionPtr^ := 13;								IncrementWritingCurrentPosition;								writeBufferCurrentPositionPtr^ := 10;							end 					end				else					writeBufferCurrentPositionPtr^ := dp^;				dp := Ptr(ord4(dp) + 1);			end;	end;{-----------------------------------------------------------------------------}	procedure putPointer2 (p: Ptr; lp: longint);		var			j: longint;			dp: CharPointer;	begin		dp := CharPointer(p);		for j := 1 to lp do			begin				putSingleChar(dp^);				{IncrementWritingCurrentPosition;				writeBufferCurrentPositionPtr^ := dp^;}				dp := CharPointer(ord4(dp) + 1);			end;	end;{-----------------------------------------------------------------------------}	procedure WriteHandle (H: Handle; delimiter: integer);		var			oldstate: SignedByte;	begin		LockHandle(H, oldstate);		putPointer(Pointer(GetMaster(H)), GetHandleSize(H), delimiter);		ResetHandle(H, oldstate);	end;{-----------------------------------------------------------------------------}	function FSpHToResource (FileSpec: FSSpec; ctype,ftype: OSType; rH: Handle; resid: integer; t: restype; resstr: str255): boolean;		var			fnum: integer;			db: BOOLEAN;			H: Handle;	begin		FSpHToResource := false;		currentioposition := 86;		if FSpCreateResourceFork(FileSpec,ctype,ftype) then			begin				fnum := FSpOpenResFile(FileSpec, fsRdWrPerm);{===== Remove Old Resource, if it exists ========}				if OSSuccessful(ResError) & (fnum <> -1) then					begin						H := Get1Resource(t, resid);						if H <> nil then							RemoveResource(H);						AddResource(rH, t, resid, resstr);						if OSSuccessful(ResError) then							begin								WriteResource(rH);								FSpHToResource := true;							end;						CloseResFile(fnum);						if IOSuccessful(ResError) then							db := IOSuccessful(FlushVol(nil,fileSpec.vRefNum));					end;			end;	end;{-----------------------------------------------------------------------------}	procedure FSpStampCLAD (FileSpec: FSSpec);		var			ds: str255;			sH: StringHandle;			db: boolean;	begin		currentioposition := 87;		ds := concat('MacClade ', VERSION);		sH := NewString(ds);		if not FSpHToResource(FileSpec, 'CLAD','TEXT', Handle(sH), -16396, 'STR ', 'name') then   {sH has not been attached to resource map}			ZapHandle(sH);	end;{-----------------------------------------------------------------------------}{	procedure CopyFile(fromfnum,tofnum: integer);	  var 	  	fromSize, currentPos, count: longint;	  	err: integer;	  	theBuf : array[1..512] of char;	  	db: boolean;	begin 	   if IOSuccessful(SetFPos(fromfnum,fsFromStart,0)) & IOSuccessful(GetEOF(fromfnum, fromSize)) & (fromSize <> 0) then	   		begin	   			repeat	   				if IOSuccessful(GetFPos(fromfnum, currentPos)) then 	   					if currentPos >= fromSize then	   						leave	   					else	   						begin	   							count := 512;	   							if fromSize-currentPos < count then count := fromSize-currentPos;	   							err := FSRead(fromfnum, count, @theBuf);	   							if (err = eofErr) or (err= NoErr) then	   								begin	   									if  IOSuccessful(FSWrite(tofnum,count,@theBuf)) then	   										FlushFile(fnum);	   								end;	   						end;	   			until false;	   		end;	end;	}{-----------------------------------------------------------------------------}	procedure FSpCreateSaveFile (originalFileSpec: FSSpec; var oldexists: boolean; ctype, ftype: OSType);{creates a new file, whose FSSpec is stored in FDI^[extraIOFileFDI].fs.}{This file is the one used for basic i/o}		var			fnum: integer;			EOFpos: LONGINT;			db: boolean;			writeName: str255;			theInfo: FInfo;			filePresentButLocked : boolean;	begin		filePresentButLocked := false;		errorflag := false;		oldexists := false;		resultCode := FSpGetFInfo(originalFileSpec, theInfo);  {check to see if old file exists}		if resultCode = FNFErr then			FDI^[extraIOFileFDI].fs := originalFileSpec  {if not then set the io specs to be this passes file specs}		else		 begin 		 	if IOSuccessful(resultcode) then				begin					currentIOPosition := 31;   {v3.05}					oldexists := not FileIsLocked(originalFileSpec); 					filePresentButLocked := not oldexists;					if filePresentButLocked then 						begin							InstantInfo('File is locked, and thus it could not be saved.');							errorflag := true;							Exit(FSpCreateSaveFile);						end;				end;			FDI^[extraIOFileFDI].fs := FSpTempFileSpec(originalFileSpec);   {otherwise, make a temp file}		 end;				currentIOPosition := 35;   {v3.05}	{now create either the temp file if the final file already exists.  or the final file }		if IOSuccessful(FSpCreate(FDI^[extraIOFileFDI].fs, ctype, ftype, scriptTag)) then			begin 				FDI^[writeFileFDI].fs := FDI^[extraIOFileFDI].fs;				ioFileFDI := writeFileFDI;			end;	end;	{-----------------------------------------------------------------------------}	function AppendSuffixToFileName (mainFileName, suffix: str255): str255;		var			ds: str255;	begin		if length(mainFileName) + length(suffix) > maxFileNameLength then			begin				ds := concat(Copystring(mainFileName, 1, maxFileNameLength - length(suffix)), suffix);				NewError(420, 0);			end		else			ds := concat(mainFileName, suffix);		AppendSuffixToFileName := ds;	end;{-----------------------------------------------------------------------------}	function StartSimpleFile(var oldExists: boolean; fileSpec: FSSpec; theFDI: integer): boolean;	begin		FSpCreateSaveFile(fileSpec, oldexists, 'ttxt', 'TEXT');		{if oldexists then   			FDI^[theFDI].fs:= fileSpec;}		StartSimpleFile:= not errorFlag;	end;{-----------------------------------------------------------------------------}	function PromptCreateSimpleFile(promptStr: str255; initialName: str255; var oldExists: boolean; theFDI: integer): boolean;	var 	Freply: StandardFileReply;		ds : str255;	begin		PromptCreateSimpleFile:= false;		ds := Copystring(initialName, 1, maxFileNameLength);		PutStandardFile(promptStr, ds, Freply);		if Freply.sfgood then			begin				{FSpCreateSaveFile(Freply.sffile, oldexists, 'ttxt', 'TEXT');				if oldexists then   					FDI^[theFDI].fs:= Freply.sffile;}				FDI^[theFDI].fs:= Freply.sffile;				PromptCreateSimpleFile:= not errorFlag;			end;	end;{-----------------------------------------------------------------------------}	procedure EndSimpleFile(oldExists: boolean; theFDI: integer);	begin		if oldexists then			FSpExchangeFilesDeleteTemp(FDI^[theFDI].fs)		else			FDI^[theFDI].fs := FDI^[writefileFDI].fs;	end;{-----------------------------------------------------------------------------}	function StartWriteSimpleFile(fileSpec: FSSpec; creator: OSType): boolean;	var os: OsErr;	begin		StartWriteSimpleFile:= false;		currentioposition := 3001;		os := FSpDelete(FileSpec);		if IOSuccessful(FSpCreate(FileSpec, creator,'TEXT',scriptTag)) then			begin 				FDI^[writeFileFDI].fs := fileSpec;				StartWrite;				StartWriteSimpleFile:= true;			end		else 			NewError(416,0);		currentioposition := 3002;	end;{-----------------------------------------------------------------------------}{	procedure FSpDeleteTemp; 		var			db: boolean;	begin		currentIOPosition := 361;   		if not errorflag then db := IOSuccessful(FSpDelete(FDI^[extraIOFileFDI].fs));	end;}{-----------------------------------------------------------------------------}	function FileIsAppleShareBusy(fileSpec: FSSpec): boolean;  {FSSpec}	var PB: HFileParam;	begin 		FileIsAppleShareBusy := false;		PB.ioCompletion := nil;		PB.ioVRefNum := FileSpec.vRefNum;		PB.ioFVersNum := 0;		PB.ioFDirIndex := 0;		PB.ioNamePtr := @FileSpec.Name;		PB.ioDirID := FileSpec.parID;		if IOSuccessful(PBHGetFInfoSync(@PB)) then			FileIsAppleShareBusy := BitTst(@PB.ioFlAttrib,1);	end;{-----------------------------------------------------------------------------}	procedure FSpExchangeFilesDeleteTemp(destinationFSpec: FSSpec);	{destinationFSpec must be the respository, the final home; note that it must not be the same as FDI^[extraIOFileFDI].fs}	{the temporary file is FDI^[extraIOFileFDI].fs}		{thus, the newly written, temporary file containing all the stuff is FDI^[extraIOFileFDI].fs}	{the old file or final file name, volume, etc. is destinationFSpec}			var			db: boolean;			temporaryNewSpec, finalSpec: FSSpec;			extraBusy, hasExchangeFilesWorked: boolean;			os: OSErr;	begin		hasExchangeFilesWorked := false;		currentIOPosition := 36;   {v3.05}//		if hasExchangeFiles then  		hasExchangeFiles := hasFSSpecCalls & HasFileIDFunctions(destinationFSpec.vRefNum);		if hasExchangeFiles then  			begin   {				if FileIsAppleShareBusy(FDI^[extraIOFileFDI].fs) then					begin		extraBusy := true;					end;				if FileIsAppleShareBusy(destinationFSpec) then					begin		currentIOPosition := 36;   					end;}				os := FSpExchangeFiles(FDI^[extraIOFileFDI].fs,destinationFSpec);				if os=noErr then 					begin						db := IOSuccessful(FSpDelete(FDI^[extraIOFileFDI].fs));						hasExchangeFilesWorked := true;					end;{was:				if IOSuccessful(FSpExchangeFiles(FDI^[extraIOFileFDI].fs,destinationFSpec)) then 					begin						db := IOSuccessful(FSpDelete(FDI^[extraIOFileFDI].fs));						hasExchangeFilesWorked := true;					end;}				{				if extraBusy then					begin		currentIOPosition := 36;  					end;}			end;		if not hasExchangeFiles | not hasExchangeFilesWorked then			begin				finalSpec := destinationFSpec;    {store the final destination file}				temporaryNewSpec := FSpTempFileSpec (destinationFSpec);   {make a temporary FSpec that will hold the old file}				if IOSuccessful(FSpRename(destinationFSpec,temporaryNewSpec.name)) then   {rename the old file to that temporary spec}					begin						destinationFSpec.name := temporaryNewSpec.name;						if IOSuccessful(FSpRename(FDI^[extraIOFileFDI].fs,finalSpec.name)) then  {rename the new file to the final spec}							db := IOSuccessful(FSpDelete(destinationFSpec));    {delete the old file}					end;			end;	end;{----------------------------------------------------------------------------}	procedure DrawWriteString (ds: str255);	begin		if DrawToFile then			puttoken(ds)		else			drawstring(ds);	end;{----------------------------------------------------------------------------}	procedure DrawWriteReturn;		var			pnstate: penstate;	begin		if DrawToFile then			putreturn		else			begin				GetPenState(pnstate);				moveto(marg, pnstate.pnloc.v + Fontheight);			end;		drawWriteStringLines := drawWriteStringLines + 1;  {v3.01 - for scroll bar on textview of chart}	end;{----------------------------------------------------------------------------}	procedure PrintWriteReturn (var currentline: longint);		var			pnstate: penstate;	begin		if DrawToFile then			putreturn		else			begin				GetPenState(pnstate);				if currentline <= 1 then					moveto(marg, marg + 2)				else					moveto(marg, pnstate.pnloc.v + Fontheight);			end;		currentline := currentline + 1;	end;{----------------------------------------------------------------------------}	procedure DrawWriteStringLn (ds: str255);	begin		DrawWriteString(ds);		DrawWriteReturn;	end;{-----------------------------------------------------------------------------}	procedure WritePolySTS (tsts: largestsetchars; cmaxst: SignedByte);		var			j: integer;	begin		if UCl in tsts then			putSingleChar('{')		else			putSingleChar('(');		for j := 0 to cmaxst do			if j in tsts then				putSingleChar(CharOfNum(j));		if UCl in tsts then			putSingleChar('}')		else			putSingleChar(')');	end;{----------------------------------------------------------------------------}	procedure SaveHandleAs (H: Handle; prompt,defaultName: str255);{this procedure writes the contents of the handle H to a file}		label			1;		var			theInfo: FInfo;			thefile: integer;			oldexists: BOOLEAN;			writename: str255;			Freply: StandardFileReply;	begin		oldexists := false;		PutStandardFile(prompt,defaultName, Freply);		ShowCursor;		if Freply.sfgood then			FSpCreateSaveFile(Freply.sfFile, oldexists, 'ttxt', 'TEXT')		else			Errorflag := true;		if errorflag then			goto 1;		StartWrite;		WriteHandle(H, NexusDelim);		EndWrite;		if errorflag then			goto 1;		if oldexists then			FSpExchangeFilesDeleteTemp(Freply.sfFile);1:	end;end.