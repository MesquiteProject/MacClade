unit ReadUtil;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, 		TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, 		SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil,		 GenUtil, StrUtil, Types, OSUtils, Dialogs, Files, StandardFile, 		 Navigation,		 ReadWriteUtil, ControlDefinitions, Controls;	function ShowIOThermo: Boolean;	function ReadingFromPointer: Boolean;		procedure LineToH (var H: Handle);	procedure StartReadingFromHandle(H: univ Handle; var oldFPos, oldFileLength, oldReadBufferP, oldreadBufLength: longint; var oldnext: char);	procedure EndReadingFromHandle(H: univ Handle; oldFPos, oldFileLength, oldReadBufferP, oldreadBufLength: longint; oldnext: char);	procedure LineToHandle (H: Handle; stopString: str255; requiresNewLineBeforeStop: boolean; nexusRules: boolean; var foundStop: boolean; var lineEmpty: boolean; minNumberLines: integer);	function FSpFileExists(FileSpec: FSSpec): Boolean;	procedure FilePiecetoP (startpos, endpos: LONGINT; P: Ptr);	procedure FilePiecetoTE (startpos, endpos: LONGINT; TE: TEHandle);	procedure FilePiecetoH (startpos, endpos: LONGINT; H: Handle);	procedure FilePiecetoCHUNK (startpos, endpos: LONGINT; CHUNKHandleBlock: Handle; CHUNKnumber: longint);	procedure ReadPointer (p: Ptr; lp: integer);	procedure SetFileLength(fs: FSSpec);	function firstFilechar: char;	function anynextchar: char;	function anynextdarkchar: char;	procedure SkipComment;	function nextchar: char;	function nextdarkchar: char;	function FindRawFileChar (findchar: char; wn: boolean): boolean;	procedure RawSkipToEndOfLine (past: boolean);	procedure Skipper (theSet: setchar; past: boolean);	procedure SkipEqual;	procedure SkipOption;	procedure SkipToEndOfLine (past: boolean);	function pickint (numplaces: integer): integer;	function FindBlock(blockName, blockNameAlternative: str255):boolean;	function FindCommand(commandName, commandNameAlternative: str255):boolean;	function GetFileToken (maxTokenLength: integer): str255;	function FindFileToken (findstr: str255; wn: boolean): boolean;	procedure NextTokenPastSemi (var ds: str255);	function GetSingleCharToken: char;	procedure GetBooleanFromFile(var bool: boolean);	procedure GetLongintFromFile(var dL: longint);	procedure GetIntegerFromFile(var j: univ integer);	procedure GetSignedByteFromFile(var j: signedbyte);	procedure GetStyleFromFile(var s: Style);	procedure GetSingleFromFile(var s: Single);	procedure GetFontNumberFromFile(var theFont: integer);	procedure GetWindowPositionFromFile(theWindow: WindowPtr);	function NewLineChar (c: char): boolean;	function EndofBlock (ds: str255): boolean;	procedure TreeFileOptions;	function ChooseFile (numtypes: integer; typeList: ConstSFTypeListPtr; UPP: UniversalProcPtr; var theFile: str255; var FileSpec: FSSpec; multipleFiles, haveNewButton, haveTreeOptionsButton: boolean): boolean;	var		taxmemorymade, charmemorymade, contmemorymade: boolean;		storeH: Handle;		initGetButtons: boolean;		quotedToken: boolean;		italicsIsOn: boolean;		tokenIsItalics: boolean;{$IFC POWERPC}		navReply: NavReplyRecord;{$ENDC}{еееееееееееееееееееееее}implementation{in reading, the character at the current fileposition is called next.  Note that}{some of the procedures, such as GetFileToken, expect that the current fileposition}{is one beyond the last token processed} {е$S ReadBuf}{-----------------------------------------------------------------------------}	function ShowIOThermo: Boolean;	begin		ShowIOThermo := not ReadingFromPointer;	end;{||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||  Reading Links from File ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}{----------------------------------------------------------------------------}	procedure LineToH (var H: Handle);{zips in a line from the file into the handle H}{used for foreign lines and also for trees}		label			1, 3;		type			BytePointer = ^SignedByte;		var			bufpos, Hlength: longint;			BP: BytePointer;{...............................}		procedure PutCharAtBytePointer (cc: char; bp: bytepointer);		begin			if cc > chr(127) then				BP^ := ord(cc) - 256			else				BP^ := ord(cc);		end;{...............................}		procedure MakeHandleBigger;			var				db: boolean;		begin			HUnLock(H);			SetHandleSize(H, GetHandleSize(H) + 512);			db := MemoryOK;			Hlength := GetHandleSize(H);			HLock(H);			BP := BytePointer(GetMaster(H) + bufpos - 1);		end;{...............................}		procedure Bumpalong;		begin			PutCharAtBytePointer(next, BP);			bufpos := bufpos + 1;			BP := BytePointer(longint(BP) + 1);			if bufpos > Hlength then				begin					MakeHandleBigger;					if badmemory then						goto 3;				end;		end;{...............................}	begin		bufpos := GetHandleSize(H) + 1;		HLock(H);		MakeHandleBigger;		if not badmemory then			repeat				next := nextchar;				if next = '''' then					begin						BumpAlong;1:						repeat							next := anynextchar;							BumpAlong;						until (next = '''') | (fpos >= mcFileLength);						next := anynextchar;						BumpAlong;						if (next = '''') then							goto 1;{    next := nextchar;}{David commented out previously line 12 Dec 1990 as, when it is there,}{tree read in bombs when you have part of the tree description like this:}{    'name-1','name-2'    as the second quoted token misread}					end;				BumpAlong;			until (next = ';') | (fpos >= mcFileLength);3:		if badmemory then  {have to skip over rest of line}			Skipper([';'], true);		HUnlock(H);		SetHandleSize(H, bufpos - 1);	end;{-----------------------------------------------------------------------------}	function ReadingFromPointer: Boolean;	begin		ReadingFromPointer := readMemoryBuffer <> nil;	end;{-----------------------------------------------------------------------------}	procedure StartReadingFromHandle(H: univ Handle; var oldFPos, oldFileLength, oldReadBufferP, oldreadBufLength: longint; var oldnext: char);	begin		oldFPos:= fpos;		oldFileLength := mcFileLength;		oldReadBufferP:= longint(readBufferCurrentPositionPtr);		oldreadBufLength := readBufferLength;		oldnext := next;				HLock(H);		readMemoryBuffer := pointer(GetMaster(H));		readMemoryBufferSize := GetHandleSize(H)-1;  {subtract 1 as fpos is 0-based}		mcFileLength := readMemoryBufferSize;		fpos := kInitialReadPos;		readBufferCurrentPositionPtr := readMemoryBuffer;		readBufferLength := mcFileLength;	end;{-----------------------------------------------------------------------------}	procedure EndReadingFromHandle(H: univ Handle; oldFPos, oldFileLength, oldReadBufferP, oldreadBufLength: longint; oldnext: char);	begin		HUnLock(H);				next := oldnext;		readMemoryBuffer := nil;		readMemoryBufferSize := 0;		readBufferCurrentPositionPtr := pointer(oldReadBufferP);		readBufferLength := oldreadBufLength;		fpos:= oldFPos;		mcFileLength := oldFileLength;	end;{-----------------------------------------------------------------------------}function FSpFileExists(FileSpec: FSSpec): Boolean;var	theInfo: FInfo;begin	FSpFileExists := FSpGetFInfo(FileSpec,theInfo) = NoErr;end;{-----------------------------------------------------------------------------}	function filepos (refNum: INTEGER): longint;		var			fp: longint;			OSEr: OSErr;	begin		OSer := GetFPos(refNum, fp);		filepos := fp;	end;{-----------------------------------------------------------------------------}	procedure FilePiecetoTE (startpos, endpos: LONGINT; TE: TEHandle);{this takes disk contents from startpos and endpos of the file readFileFDI and reads it into the text}{edit handle TE}		var			oldstate: SignedByte;	begin		if endpos - startpos > 32000 then    {text edit limits}			endpos := startpos + 32000;		LockHandle(TE, oldstate);		FilePieceToH(startPos, endpos, TE^^.htext);		ResetHandle(TE, oldstate);	end;{-----------------------------------------------------------------------------}	procedure FilePiecetoP (startpos, endpos: LONGINT; P: Ptr);		var			fnum: integer;			piecelength, maxlength: longint;			db: boolean;	begin		currentIOPosition := 1;   {v3.05}		if IOSuccessful(FSpOpenDF(FDI^[readfileFDI].fs, fsCurPerm, fnum)) then			begin				if IOSuccessful(GetEOF(fnum, maxlength)) then					if IOSuccessful(SetFPos(fnum, FSFromStart, startpos)) then						begin							if endpos > maxlength then								endpos := maxlength;							piecelength := endpos - startpos;							currentIOPosition := 2;   {v3.05}							db := IOSuccessful(FSRead(fnum, piecelength, P));						end;				if IOSuccessful(FSClose(fnum)) then					db := IOSuccessful(FlushVol(nil,FDI^[readfileFDI].fs.vRefNum));			end;	end;{-----------------------------------------------------------------------------}	procedure FilePiecetoH (startpos, endpos: LONGINT; H: Handle);		var			fnum: integer;			piecelength, maxlength: longint;			db: boolean;			oldstate1, oldstate2: SignedByte;	begin		if H = nil then Exit(FilePieceToH);  {also give warning?}		currentIOPosition := 3;   {v3.05}		if IOSuccessful(FSpOpenDF(FDI^[readfileFDI].fs, fsCurPerm, fnum)) then			begin				if IOSuccessful(GetEOF(fnum, maxlength)) then					if IOSuccessful(SetFPos(fnum, FSFromStart, startpos)) then						begin							if endpos > maxlength then								endpos := maxlength;							piecelength := endpos - startpos;							UnlockHandle(H, oldstate2);							if SetHandleSizeSuccessful(H,piecelength) then								begin									SetHandleSize(H, piecelength);									HLock(H);									currentIOPosition := 4;   {v3.05}									db := IOSuccessful(FSRead(fnum, piecelength, Ptr(GetMaster(H))));								end;							ResetHandle(H, oldstate2);						end;				if IOSuccessful(FSClose(fnum)) then					db := IOSuccessful(FlushVol(nil,FDI^[readfileFDI].fs.vRefNum));			end;	end;{-----------------------------------------------------------------------------}	procedure FilePiecetoCHUNK (startpos, endpos: LONGINT; CHUNKHandleBlock: Handle; CHUNKnumber: longint);		var			dhp: HdlPtr;			oldstate: SignedByte;	begin		LockHandle(CHUNKHandleBlock, oldstate);		dhp := HdlPtr(GetMaster(CHUNKHandleBlock) + HdlSize * ord4(CHUNKnumber - 1));		FilePieceToH(startpos, endpos, dhp^);		ResetHandle(CHUNKHandleBlock, oldstate);	end;{----------------------------------------------------------------------------}	procedure LineToHandle (H: Handle; stopString: str255; requiresNewLineBeforeStop: boolean; nexusRules: boolean; var foundStop: boolean; var lineEmpty: boolean; minNumberLines: integer);{zips in a line from the file into the handle H}{used only for foreign sequences}{if you want to abandon ship, set foundStop to false and return}		label			1, 2, 3;		type			BytePointer = ^SignedByte;		var			bufpos, Hlength: longint;			BP: BytePointer;			singleCharacterStop: boolean;			db,fullFile, someDarkFound: boolean;			numberLines: integer;			last, prevChar: char;{...............................}		procedure PutCharAtBytePointer (cc: char; bp: bytepointer);		begin			if cc > chr(127) then				BP^ := ord(cc) - 256			else				BP^ := ord(cc);		end;{...............................}		procedure MakeHandleBigger;			var				db: boolean;		begin			HUnLock(H);			SetHandleSize(H, GetHandleSize(H) + 512);			db := MemoryOK;			Hlength := GetHandleSize(H);			HLock(H);			BP := BytePointer(GetMaster(H) + bufpos - 1);		end;{...............................}		procedure Bumpalong;		begin			PutCharAtBytePointer(next, BP);			if (numberLines = 0) & not (next in whitespace) then				numberLines := 1;			if (numberLines > 0) then				if (next = char(13)) then					begin						numberLines := numberLines +1;					end				else if (next=char(10)) & (last<>char(13)) then					numberLines := numberLines +1;			bufpos := bufpos + 1;			BP := BytePointer(longint(BP) + 1);			if bufpos > Hlength then				begin					MakeHandleBigger;					if badmemory then						goto 3;				end;			last := next;		end;{...............................}	procedure CheckForPotentialStop;	var j: integer;		potentialStop: boolean;		newLineBeforePotentialStop: boolean;	begin		newLineBeforePotentialStop := (prevChar = char(10)) |  (prevChar = char(13));		if (length(stopString)>0) & (next = stopString[1]) & ((minNumberLines=0)|(numberLines>=minNumberLines)) then			if singleCharacterStop then				begin					foundStop := newLineBeforePotentialStop | not requiresNewLineBeforeStop;				end			else				begin					j := 1;					potentialStop := true;					while (j < length(stopString)) & (fpos < mcFileLength) do						begin							next := anynextchar;   {you only ever get in here if non-nexus}							if not (next in whitespace) then								lineEmpty := false;							j:= j + 1;							BumpAlong;							if stopString[j] <> next then								begin									potentialStop := false;									leave;								end;						end;					if potentialStop & (j=length(stopString)) & ((minNumberLines=0)|(numberLines>=minNumberLines)) then						foundStop := newLineBeforePotentialStop | not requiresNewLineBeforeStop;				end;	end;{...............................}	begin		numberLines := 0;		bufpos := GetHandleSize(H) + 1;		singleCharacterStop:= length(stopString)=1;		fullFile := length(stopString)=0;		foundStop:= false;		lineEmpty := true;		HLock(H);		MakeHandleBigger;		if not badmemory then			repeat				prevChar := next;				if nexusRules then 					begin						next := nextchar;						if  next = '''' then							begin								lineEmpty := false;								BumpAlong;1:								repeat									next := anynextchar;									BumpAlong;								until (next = '''') | (fpos >= mcFileLength);								prevChar := next;								next := anynextchar;								BumpAlong;								if (next = '''') then									goto 1;		{    next := nextchar;}		{David commented out previously line 12 Dec 1990 as, when it is there,}		{tree read in bombs when you have part of the tree description like this:}		{    'name-1','name-2'    as the second quoted token misread}							end;					end				else					next := anynextchar;				if not (next in whitespace) then					lineEmpty := false;				BumpAlong;				CheckForPotentialStop;			until foundStop | (fpos >= mcFileLength);3:		if badmemory & not fullFile & not foundStop & (fpos < mcFileLength)  then  {have to skip over rest of line}			repeat				prevChar := next;				if nexusRules then 					begin						next := nextchar;						if  next = '''' then							begin2:								repeat									next := anynextchar;								until (next = '''') | (fpos >= mcFileLength);								prevChar := next;								next := anynextchar;								if (next = '''') then									goto 2;							end;					end				else					next := anynextchar;				CheckForPotentialStop;			until foundStop | (fpos >= mcFileLength);{$IFC FALSE}				if nexusRules then					repeat						Skipper([stopString[1]], true);					until done (fpos >= mcFileLength);				else					db := FindRawFileChar(stopString[1], false);  {$ENDC}		HUnlock(H);		SetHandleSize(H, bufpos - 1);		if fullfile then foundStop := true;	end;{|||||||||||||||||||||||||||||||||||||     ||||||||||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	procedure SetFileLength(fs: FSSpec);		var			fnum: integer;			db: boolean;	begin		currentIOPosition := 5;   		if IOSuccessful(FSpOpenDF(fs, fsCurPerm, fnum)) then			begin				currentIOPosition := 6;   				if not IOSuccessful(GetEOF(fnum, mcFileLength)) then					mcFileLength := mcFileLength-1;				currentIOPosition := 7;   				if IOSuccessful(FSClose(fnum)) then					db := IOSuccessful(FlushVol(nil,fs.vRefNum));			end;	end;{-----------------------------------------------------------------------------}	procedure FillBuf;		var			fnum: integer;			db: boolean;	begin		if ReadingFromPointer then {we use this instead}			begin				mcFileLength := readMemoryBufferSize;				readBufferCurrentPositionPtr := readMemoryBuffer;				readBufferLength := mcFileLength;			end		else			begin				readBufferCurrentPositionPtr := readBufferBasePtr;				currentIOPosition := 5;   {v3.05}				if IOSuccessful(FSpOpenDF(FDI^[readfileFDI].fs, fsCurPerm, fnum)) then					begin						currentIOPosition := 6;   {v3.05}						if  IOSuccessful(GetEOF(fnum, readBufferLength)) then							begin								mcFileLength := readBufferLength - 1;								readBufferLength := readBufferLength - fpos;								if readBufferLength > readWriteBufferSize then									readBufferLength := readWriteBufferSize;								currentIOPosition := 7;   {v3.05}								if IOSuccessful(SetFPos(fnum, FSFromStart, fpos)) then									db := IOSuccessful(FSRead(fnum, readBufferLength, readBufferCurrentPositionPtr));							end;						if IOSuccessful(FSClose(fnum)) then							db := IOSuccessful(FlushVol(nil,FDI^[readfileFDI].fs.vRefNum));					end;			end;	end;{|||||||||||||||||||||||||||||||||||||   Reading Characters  ||||||||||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	function firstFilechar: char;	begin		fpos := 0;		FillBuf;		fpos := fpos - 1;    			{subtract 1 from these as they will be added on in nextchar}		readBufferCurrentPositionPtr := Pointer(ord4(readBufferCurrentPositionPtr) - 1);		firstFilechar := nextchar;	end;{-----------------------------------------------------------------------------}	function anyfirstchar: char;	begin		fpos := 0;		FillBuf;		fpos := fpos - 1;    			{subtract 1 from these as they will be added on in nextchar}		readBufferCurrentPositionPtr := Pointer(ord4(readBufferCurrentPositionPtr) - 1);		anyfirstchar := anynextchar;	end;{-----------------------------------------------------------------------------}	procedure IncrementReadingBufferCurrentPosition;	begin		readBufferCurrentPositionPtr := Pointer(ord4(readBufferCurrentPositionPtr) + 1);		if not ReadingFromPointer then			if (ord4(readBufferCurrentPositionPtr) >= ord4(readBufferEndPtr)) then				if (readWriteBufferSize >= readBufferLength) then  {if it is less then we must be on the last piece}					FillBuf;	end;{-----------------------------------------------------------------------------}	function anynextchar: char;	label 1;{gets next character, even if it is a [    }	begin		if fpos = kInitialReadPos then			begin				fpos := 0;				FillBuf;				fpos := fpos - 1;    			{subtract 1 from these as they will be added on in nextchar}				readBufferCurrentPositionPtr := Pointer(ord4(readBufferCurrentPositionPtr) - 1);			end;1:		fpos := fpos + 1;		IncrementReadingBufferCurrentPosition;		next := CharAtPointer(readBufferCurrentPositionPtr);		if next in vacuum then 			goto 1; 		anynextchar := next;	end;{-----------------------------------------------------------------------------}	function anynextdarkchar: char;	begin		repeat			next := anynextchar;		until not (next in whitespace);		anynextdarkchar := next;	end;{-----------------------------------------------------------------------------}	function nextchar: char;		label			1;		var			tc: char;	begin		if fpos = kInitialReadPos then			begin				fpos := 0;				FillBuf;				fpos := fpos - 1;    			{subtract 1 from these as they will be added on in nextchar}				readBufferCurrentPositionPtr := Pointer(ord4(readBufferCurrentPositionPtr) - 1);			end;1:		fpos := fpos + 1;		IncrementReadingBufferCurrentPosition;		tc := CharAtPointer(readBufferCurrentPositionPtr);		if tc in vacuum then 			goto 1		else if tc = '[' then			begin				SkipComment;				goto 1;			end;		nextchar := tc;	end;{-----------------------------------------------------------------------------}	procedure SkipComment;			{skip over comment}		var			db: boolean;			c: char;{.............}		function commentchar: char;		begin			fpos := fpos + 1;			if fpos >= mcFileLength then   {v3.05}				begin					commentchar := ']';				end			else				begin					IncrementReadingBufferCurrentPosition;					commentchar := CharAtPointer(readBufferCurrentPositionPtr);				end;		end;{.............}		procedure SkipCommentRec;			var				makepos: longint;		begin			c := commentchar;			if (c = '!') then {a comment for output}				startExclam := fpos + 1			else if (c = MCFlagChar) then   {needed for compatibility with files made by 3.0-3.04}				begin					MCFlag := true;					makepos := fpos;				end			else if (c = '\') then  {we have a font style}				begin					c := commentchar;					if (c = 'i') or (c = 'I') then						begin							italicsIsOn := true;						end					else if (c = 'p') or (c = 'P') then						italicsIsOn := false;				end;			if c <> ']' then				repeat					if c = '[' then						begin							SkipCommentRec;{c := commentchar; v3.05: commented out}						end;					c := commentchar;  {moved this 3.05}				until (c = ']') | (fpos = mcFileLength);			MCFlag := MCFlag and (fpos = makepos + 1);			if startExclam <> 0 then				endExclam := fpos;		end;{.............}	begin		startExclam := 0;		SkipCommentRec;		if (startExclam <> 0) then			if commreadon & not ReadingFromPointer then				begin	{should only add this if second time    AppendToHandle(curTextH, chr(13));}					if EndExclam > StartExclam + 1 then						FilePieceToH(startExclam, EndExclam, storeH);					currentIOPosition := 56;   {v3.05}					db := OSSuccessful(HandAndHand(storeH, curTextH));					startExclam := 0;				end;	end;{-----------------------------------------------------------------------------}	function nextdarkchar: char;	begin		repeat			next := nextchar;		until not (next in whitespace);		nextdarkchar := next;	end;{-----------------------------------------------------------------------------}	procedure RawSkipper (theSet: setchar; past: boolean);{skips until it finds a character in theSet, and skips beyond it if past is true}{note that it does care about quotes!!!}	begin		if not (next in theSet) then			repeat				next := anynextchar;			until (next in theSet) | (fpos >= mcFileLength);		previousChar := next;		if past &  (fpos < mcFileLength) then			next := anynextchar;	end;{-----------------------------------------------------------------------------}	procedure RawSkipToEndOfLine (past: boolean);	begin		RawSkipper([chr(10), chr(13)], past);		{we've found one end of line character.  Now, if this is a file that has CRLF line endings}		if past &  (previousChar=chr(13)) & (next = chr(10)) then			RawSkipper([chr(10)], past);	end;{-----------------------------------------------------------------------------}	procedure Skipper (theSet: setchar; past: boolean);{skips until it finds a character in theSet, and skips beyond it if past is true}{note that it doesn not consider anything inside of quotes}{{singlequote cannot be part of set!!!!)}		label			1;	begin		if not (next in theSet) then			repeat				next := nextchar;				if next = '''' then					begin1:						repeat							next := nextchar;						until (next = '''') | (fpos >= mcFileLength);						if  (fpos < mcFileLength) then							next := nextchar;						if next = '''' then							goto 1;					end;			until (next in theSet) | (fpos >= mcFileLength);		if past &  (fpos < mcFileLength) then			next := nextchar;	end;{-----------------------------------------------------------------------------}	procedure SkipEqual;{specialized procedure, to be called when expecting an equal sign}	begin		if (next <> '=') & (fpos < mcFileLength) then			next := nextdarkchar;		{=}		if  (fpos < mcFileLength) then			next := nextdarkchar;	end;{-----------------------------------------------------------------------------}	procedure SkipToEndOfLine (past: boolean);	begin		Skipper([chr(10), chr(13)], past);		if past and (next in [chr(10), chr(13)]) then			Skipper([chr(10), chr(13)], past);	end;{-----------------------------------------------------------------------------}	procedure SkipOption;	begin{next := nextdarkchar;}		if next = '"' then			begin				repeat					next := nextchar;				until (next = '"') | (fpos >= mcFileLength);				if  (fpos < mcFileLength) then					next := nextchar;			end		else if next = '=' then			begin				if  (fpos < mcFileLength) then next := nextchar;				if next = '"' then					begin						repeat							next := nextchar;						until (next = '"') | (fpos >= mcFileLength);						if  (fpos < mcFileLength) then next := nextchar;					end				else					repeat						next := nextchar;					until (next in (whitespace + punctuation)) | (fpos >= mcFileLength);			end;	end;{----------------------------------------------------------------------------}	procedure SkipCommand;		var			ds: str255;	begin		repeat			ds := GetFileToken(maxTok);		until (ds = ';') or (fpos >= mcFileLength);	end;{----------------------------------------------------------------------------}	function FindBlock(blockName, blockNameAlternative: str255):boolean;	var ds: str255;		blockFound : boolean;	begin		blockFound:= false;		repeat			ds := MakeCaps(GetFileToken(maxTok));			if ds = 'BEGIN' then				begin					ds := MakeCaps(GetFileToken(maxTok));					if (ds=blockName) |  (ds=blockNameAlternative) then						begin							blockFound := true;							Skipper([';'], true);							leave;						end					else						repeat							ds := MakeCaps(GetFileToken(maxtok));						until  EndOfBlock(ds) | (fpos >= mcFileLength) | errorflag;				end		until (fpos>=mcFileLength) | blockFound | errorFlag;		FindBlock := blockFound;	end;{----------------------------------------------------------------------------}	function FindCommand(commandName, commandNameAlternative: str255):boolean;	var ds: str255;		found : boolean;	begin		found:= false;		repeat			ds := MakeCaps(GetFileToken(maxTok));			if (ds=commandName) |  (ds=commandNameAlternative) then				begin					found := true;					leave;				end			else				Skipper([';'], true);		until (fpos>=mcFileLength) | found | errorFlag;		FindCommand := found;	end;{-----------------------------------------------------------------------------}	function FindRawFileChar (findchar: char; wn: boolean): boolean;	begin		repeat			next := anynextchar;		until (next = findchar) or (fpos >= mcFileLength);		if next = findchar then			FindRawFileChar := true		else if (fpos >= mcFileLength) then			begin				if wn then					InstantErrorPlus(244, findchar);				FindRawFileChar := false;			end;	end;{----------------------------------------------------------------------------}	function pickint (numplaces: integer): integer;{note that numplaces must be >0}		var			c: char;			ds: str255;			j: integer;	begin		ds := '';		for j := 1 to numplaces do			begin				c := nextchar;				concatstringChar(@ds, c);			end;		pickint := TokenToInteger(ds, true);	end;{||||||||||||||||||||||||||||  Reading Tokens  ||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	function GetFileToken (maxTokenLength: integer): str255;{maxTokenLength is the maximum length of the token that is returned by GetFileToken}		label			1, 2;		var			ds: str255;			longtoken, longquote: boolean;			keepgoing: boolean;	begin		tokenIsItalics := italicsIsOn;		quotedToken := false;		ds := ' ';		longtoken := false;		longquote := false;		starttokensearch := fpos;		if fpos = kInitialReadPos then			next := nextchar;		if errorFlag then			begin				GetFileToken := '';				Exit(GetFileToken);			end;							{find first non whitespace char}		while (next in whitespace) and (fpos < mcFileLength) do			next := nextchar;		if (fpos > mcFileLength) | ((fpos = mcFileLength) & (next in whitespace)) then   {v3.05: added =}			begin				GetFileToken := '';				Exit(GetFileToken);			end;		ds[1] := next;		if (next in punctuation) then			next := nextchar		else if next = '''' then    {a quoted token}			begin				ds := '';				quotedToken := true;1:				while not longquote and (fpos < mcFileLength) do					begin						next := anynextchar;						if next = '''' then							leave						else							begin								ConcatStringChar(@ds, next);								longquote := (length(ds) >= maxTokenLength);							end;					end;				if (fpos < mcFileLength) then					begin						next := anynextchar;						if not longquote then   {we have kicked out of above loop because of quote}							if next = '''' then								begin									ConcatStringChar(@ds, next);									longquote := (length(ds) >= maxTokenLength);									goto 1;								end							else if next = '[' then								begin									SkipComment;									next := nextchar;								end;					end;			end		else		    begin				Keepgoing:= not longtoken;				Keepgoing:= Keepgoing and not (next in whitespace);				Keepgoing:= Keepgoing and (fpos < mcFileLength);				while keepgoing do					begin						next := nextchar;						if next in punctuation then							leave						else if not (next in whitespace) then							begin								ConcatStringChar(@ds, next);								longtoken := (length(ds) >= maxTokenLength);							end;						Keepgoing:= not longtoken;						Keepgoing:= Keepgoing and not (next in whitespace);						Keepgoing:= Keepgoing and (fpos < mcFileLength);					end;			end;		if longtoken then			while not (next in whitespace) and not (next in punctuation) and (fpos < mcFileLength) do				next := nextchar;		if longquote then			begin2:				while not (next = '''') and (fpos < mcFileLength) do					next := anynextchar;				next := anynextchar;				if next = '''' then  {we have hit 2 quotes in a row, let's continue on the token}					begin						next := anynextchar;						goto 2;					end				else if next = '[' then					begin						SkipComment;						next := nextchar;					end;			end;		GetFileToken := ds;	end;{-----------------------------------------------------------------------------}	function GetSingleCharToken: char;		var			ds: str255;	begin		ds := GetFileToken(32);		StripBlanks(ds);		if length(ds) = 0 then			GetSingleCharToken := ' '		else			GetSingleCharToken := ds[1];	end;{-----------------------------------------------------------------------------}	procedure NextTokenPastSemi (var ds: str255);	begin		Skipper([';'], true);		ds := GetFileToken(maxtok);{$IFC FALSE}{was}		Skipper([';'], false)		ds := MakeCaps(GetFileToken(maxtok));		if ds = ';' then			ds := MakeCaps(GetFileToken(maxtok));{$ENDC}	end;{-----------------------------------------------------------------------------}	function FindFileToken (findstr: str255; wn: boolean): boolean;		var			ds: str255;			found: boolean;	begin		repeat			ds := GetFileToken(maxtok);			found := StringsEqual(@ds, @findstr, length(findstr));		until found or (fpos >= mcFileLength);		if wn & not found then			InstantErrorPlus(244, findstr);		FindFileToken := found;	end;{-----------------------------------------------------------------------------}	function NewLineChar (c: char): boolean;	begin		NewLineChar := (c = chr(13)) | (c = chr(10));	end;{-----------------------------------------------------------------------------}	function EndofBlock (ds: str255): boolean;{pass the current token ds, returns true if it is the end of the NEXUS block}{note ds is expected to be all Upper Case}	begin		EndofBlock := (ds = 'END') or (ds = 'ENDBLOCK');	end;{-----------------------------------------------------------------------------}	procedure GetBooleanFromFile(var bool: boolean);	var c: char;	begin		c := nextdarkchar;		if c = '1' then bool := true		else if c='0' then bool := false		else			NewError(17,0);	end;{-----------------------------------------------------------------------------}	procedure GetLongintFromFile(var dL: longint);	var ds: str255;	begin		ds := MakeCaps(GetFileToken(maxtok));		if ds <> ';' then dL := TokenToInteger(ds, true);	end;				{-----------------------------------------------------------------------------}	procedure GetIntegerFromFile(var j: univ integer);	var ds: str255;	begin		ds := MakeCaps(GetFileToken(maxtok));		if ds <> ';' then j := TokenToInteger(ds, true);	end;{-----------------------------------------------------------------------------}	procedure GetSignedByteFromFile(var j: signedbyte);	var ds: str255;	begin		ds := MakeCaps(GetFileToken(maxtok));		if ds <> ';' then j := TokenToInteger(ds, true);	end;{-----------------------------------------------------------------------------}	procedure GetStyleFromFile(var s: Style);	var ds: str255;		j : integer;	begin		s := [];		repeat			ds := MakeCaps(GetFileToken(maxtok));			if length(ds)>1 then				begin					if pos('(',ds)>0 then						delete(ds,pos('(',ds),1);					if pos(')',ds)>0 then						delete(ds,pos(')',ds),1);				end;			if ds ='BOLD' then				s := s+[bold]			else if ds ='ITALIC' then				s := s+[italic]			else if ds ='UNDERLINE' then				s := s+[underline]			else if ds ='SHADOW' then				s := s+[shadow]			else if ds ='OUTLINE' then				s := s+[outline]			else if ds ='CONDENSE' then				s := s+[condense]			else if ds ='EXTEND' then				s := s+[extend];		until (ds=')') | (ds=';') | (ds='') | (ds=' ') | (fpos>=mcFileLength);	end;{-----------------------------------------------------------------------------}	procedure GetSingleFromFile(var s: Single);	var ds: str255;	begin		ds := GetFileToken(maxtok);		if ds <> ';' then s := TokenToReal(ds);	end;{-----------------------------------------------------------------------------}	procedure GetWindowPositionFromFile(theWindow: WindowPtr);	begin		if (theWindow<> nil) then			begin				GetIntegerFromFile(WindowInfoP(GetWindowRefCon(theWindow))^.top);				GetIntegerFromFile(WindowInfoP(GetWindowRefCon(theWindow))^.left);				GetIntegerFromFile(WindowInfoP(GetWindowRefCon(theWindow))^.height);				GetIntegerFromFile(WindowInfoP(GetWindowRefCon(theWindow))^.width);			end;	end;{-----------------------------------------------------------------------------}	procedure GetFontNumberFromFile(var theFont: integer);	var ds: str255;		fontNumber: integer;	begin		ds := GetFileToken(maxtok);		UnderLineToBlanks(ds);		if (ds<> ';') & GetFontNumber(ds, fontNumber) then			theFont := fontNumber;	end;{----------------------------------------------------------------------------}	procedure TreeFileOptions;		label			1;		var			treeDialog: DialogPtr;			tempP: WindowPtr;			ds: str255;			alltrees: boolean;			localItemHit: integer;	begin		StartDLOG(597, treeDialog, tempP);		alltrees := true;		ItemCheckMark(treeDialog, 5, not alltrees);		ItemCheckMark(treeDialog, 6, alltrees);		myShowDialog(treeDialog);		FrameButton(treeDialog, 1);1:		repeat			ModalDialog(nil, localItemHit);			if localItemHit in [3, 4, 5] then				alltrees := false			else if localItemHit = 6 then				alltrees := true;			ItemCheckMark(treeDialog, 5, not alltrees);			ItemCheckMark(treeDialog, 6, alltrees);		until localItemHit in [1, 2];		if localItemHit = 1 then			if not alltrees then				begin					ds := GetEditText(treeDialog, 3);					startreadtree := TokenToInteger(ds, true);					if startreadtree = 0 then						begin							Beep;							goto 1;						end;					ds := GetEditText(treeDialog, 4);					if length(ds) = 0 then						endreadtree := -1					else						begin							endreadtree := TokenToInteger(ds, true);							if endreadtree < startreadtree then								begin									Beep;									goto 1;								end;						end;					if (endreadtree = 0) then						begin							Beep;							goto 1;						end;				end			else				begin					startreadtree := 1;					endreadtree := -1;				end;		EndDLOG(treeDialog, tempP);	end;{----------------------------------------------------------------------------}{$IFC POWERPC}{----------------------------------------------------------------------------}	function NavTypeListFromOldTypeList(numTypes: integer; typeList:ConstSFTypeListPtr): NavTypeListHandle;	var 	H: NavTypeListHandle;		oldstate: SignedByte;	begin		H := NavTypeListHandle(NewHandle(sizeof(NavTypeList) + numTypes * sizeof(OSType)));		LockHandle(H,oldstate);		if (H<> nil) then			begin				H^^.componentSignature := '????';				H^^.osTypeCount := numTypes;				BlockMoveData(typeList, @H^^.osType, numTypes * sizeof(OSType));			end;		ResetHandle(H,oldstate);		NavTypeListFromOldTypeList := H;	end;{----------------------------------------------------------------------------}	var		gtypeList: ConstSFTypeListPtr;		gNumTypes: integer; 		newButtonControl: ControlHandle; 		treeFileOptionsButtonControl: ControlHandle;       		showAllFilesCheckBoxControl: ControlHandle;       		includeShowAllFileTypesCheckBoxInNavDialog: boolean;       		showAllFileTypes: boolean;       		gHaveNewButton: boolean;       		gHaveTreeFileOptionsButton: boolean;{----------------------------------------------------------------------------}	procedure NavEventProc(callBackSelector: NavEventCallbackMessage;  callBackParms: NavCBRecPtr;   callBackUD: NavCallBackUserData);	const newButtonLength = 95;		newButtonHeight=25;        var navWindow: WindowPtr;        	os: OSStatus;        	wh: point;        	theItem: integer;        	partResult: SInt16;        	firstItem: UInt16;        	realItem: integer;        	box: rect;        	radioBox: rect;        	ds: str255;        	buttonLeft: integer;        		begin	    case callBackSelector of	    	kNavCBCustomize:	    		begin	    			If (callBackParms^.customRect.bottom = 0) | (callBackParms^.customRect.right = 0) then	    				begin	    					callBackParms^.customRect.bottom := callBackParms^.customRect.top+newButtonHeight+4;	    					callBackParms^.customRect.right := callBackParms^.customRect.left+100;	    				end;	    		end;	    	kNavCBAdjustRect:	    		begin	    			//setRect(box,callBackParms^.customRect.right-60,callBackParms^.customRect.bottom-newButtonHeight,callBackParms^.customRect.right-5,callBackParms^.customRect.bottom-5);	    			//OffSetRect(box, -callBackParms^.customRect.left,-callBackParms^.customRect.top);	    			buttonLeft := callBackParms^.customRect.right-newButtonLength -5;	    			if gHaveNewButton then	    				MoveControl(newButtonControl,buttonLeft,callBackParms^.customRect.bottom-newButtonHeight)	    			else if gHaveTreeFileOptionsButton then	    				MoveControl(treeFileOptionsButtonControl,buttonLeft,callBackParms^.customRect.bottom-newButtonHeight);	    			if includeShowAllFileTypesCheckBoxInNavDialog then	    				begin	    					MoveControl(showAllFilesCheckBoxControl,callBackParms^.customRect.left+15,callBackParms^.customRect.bottom-newButtonHeight);	    				end;	    		end;	    	kNavCBStart:	    		begin	    			//gDitlList := GetResource('DITL', 127);	    			//os := NavCustomControl(callBackParms^.context, kNavCtlAddControlList, gDitlList);	    			{box := callBackParms^.customRect;	    			box.bottom := box.top+20;	    			box.left := box.right-40;}	    			setRect(box,callBackParms^.customRect.right-newButtonLength - 5,callBackParms^.customRect.bottom-newButtonHeight,callBackParms^.customRect.right-5,callBackParms^.customRect.bottom-5);	    			OffSetRect(box, -callBackParms^.customRect.left,-callBackParms^.customRect.top);	    			if gHaveNewButton then	    				begin	    					newButtonControl := NewControl(callBackParms^.window, box, 'New File', true, 1,0,1,kControlPushButtonProc, 0);	    					if (newButtonControl <> nil) then	    						os := NavCustomControl(callBackParms^.context, kNavCtlAddControl, newButtonControl);	    				end	    			else if gHaveTreeFileOptionsButton then	    				begin	    					treeFileOptionsButtonControl := NewControl(callBackParms^.window, box, 'Options...', true, 1,0,1,kControlPushButtonProc, 0);	    					if (treeFileOptionsButtonControl <> nil) then	    						os := NavCustomControl(callBackParms^.context, kNavCtlAddControl, treeFileOptionsButtonControl);	    				end;	    			if includeShowAllFileTypesCheckBoxInNavDialog then	    				begin	    					setRect(box,callBackParms^.customRect.left+ 5,callBackParms^.customRect.bottom-newButtonHeight,callBackParms^.customRect.right-newButtonLength - 5,callBackParms^.customRect.bottom-5);	    					OffSetRect(box, -callBackParms^.customRect.left,-callBackParms^.customRect.top);	    					showAllFilesCheckBoxControl := NewControl(callBackParms^.window, box, 'show all files', true, 0,0,1,kControlCheckBoxProc, 0);	    					if (showAllFilesCheckBoxControl <> nil) then	    						begin	    							os := NavCustomControl(callBackParms^.context, kNavCtlAddControl, showAllFilesCheckBoxControl);					  			if showAllFileTypes then									SetControlValueLong(showAllFilesCheckBoxControl, 1) 								else									SetControlValueLong(showAllFilesCheckBoxControl, 0);							end;	    				end;	    			// os := ActivateControl(newButtonControl);	    		end;	    	kNavCBTerminate:	    		begin	    			//ReleaseResource(gDitlList);	    			if newButtonControl<>nil then	    				DisposeControl(newButtonControl);	    			if treeFileOptionsButtonControl<>nil then	    				DisposeControl(treeFileOptionsButtonControl);	    			DisposeControl(showAllFilesCheckBoxControl);	    		end;	    	kNavCBEvent:	    		begin	  			navWindow := callBackParms^.window;	  			case callBackParms^.eventData.eventDataParms.event^.what of	  				mouseDown:	  					begin	  						GetMouse(wh);	  						theItem := FindDialogItem(myGetDialogPtrForWindow(navWindow),wh);	  						whichControl := FindControlUnderMouse(wh,navWindow, partResult);	  						if (whichControl<>nil) & (partResult <> 0) then	  							begin	  								if (whichControl=newButtonControl) & (gHaveNewButton)  then  	  									begin	  										os := NavCustomControl(callBackParms^.context, kNavCtlCancel, nil);	  										if (os=noErr) then	  											makeNew := true;	  									end	  								else if (whichControl=treeFileOptionsButtonControl) & (gHaveTreeFileOptionsButton)  then  	  									begin	  										//os := NavCustomControl(callBackParms^.context, kNavCtlCancel, nil);	  										//if (os=noErr) then	  											treeFileOptionsButtonClicked := true;	  											TreeFileOptions;	  												  									end	  								else if includeShowAllFileTypesCheckBoxInNavDialog & (whichControl=showAllFilesCheckBoxControl)  then  	  									begin	  										showAllFileTypes := not showAllFileTypes;	  										if showAllFileTypes then	  											SetControlValueLong(showAllFilesCheckBoxControl, 1) 	  										else	  											SetControlValueLong(showAllFilesCheckBoxControl, 0);	  										os := NavCustomControl(callBackParms^.context, kNavCtlBrowserRedraw, nil);	  										//if (os=noErr) then	  												  									end;	  							end;	  					end;	  				otherwise;	  			end;	  					    		end;	    	otherwise;	    end;	end;{----------------------------------------------------------------------------}	function isEmptyFileType (fileType: OSType): boolean;	var emptyType: OSType;	begin		emptyType[1] := char(0);		emptyType[2] := char(0);		emptyType[3] := char(0);		emptyType[4] := char(0);		isEmptyFileType := fileType=emptyType;	end;{----------------------------------------------------------------------------}	function myFilterProc(VAR theItem: AEDesc; info: UNIV Ptr; callBackUD: UNIV Ptr; filterMode:  NavFilterModes) : boolean;	var theErr: OSErr;		display, properFileType: boolean;		theInfo: NavFileOrFolderInfoPtr;		j: integer;	begin	   theErr := noErr;	    display  := true;	   theInfo := NavFileOrFolderInfoPtr(info);	    	    if (theItem.descriptorType = typeFSS) then	        if (not theInfo^.isFolder) then	            if (theInfo^.finderInfo.fdType = 'APPL')then	                display := false	            else if not showAllFileTypes then{$IFC CARBON}	            	if isMacOSX & isEmptyFileType(theInfo^.finderInfo.fdType) then	            		display := true	            	else{$ENDC}	            		begin		            		properFileType := false;		            		for j := 0 to gNumTypes-1 do	            	 			if  (theInfo^.finderInfo.fdType =OSTypePtr(ord4(gtypeList) + (j*4))^)then	            	 				begin	            	 					properFileType := true;	            	 					leave;	            	 				end;		            		if not properFileType then		               	 		display := false;	            		end;	    myFilterProc := display;	end;{----------------------------------------------------------------------------}	function myNewNavObjectFilterUPP(theProc:Ptr): UniversalProcPtr;	begin{$IFC NOT CARBON}		myNewNavObjectFilterUPP :=  NewRoutineDescriptor(theProc,uppNavObjectFilterProcInfo, GetCurrentISA);{$ELSEC}		myNewNavObjectFilterUPP := UniversalProcPtr(NewNavObjectFilterUPP(theProc)); {$ENDC}	end;{----------------------------------------------------------------------------}	procedure myDisploseNavObjectFilterUPP(UPP:UniversalProcPtr);	begin{$IFC NOT CARBON}		DisposeRoutineDescriptor(UPP);{$ELSEC}		DisposeNavObjectFilterUPP(NavObjectFilterUPP(UPP));{$ENDC}	end;{----------------------------------------------------------------------------}	function NavChooseFileLocal (numtypes: integer; typeList: ConstSFTypeListPtr; UPP: UniversalProcPtr; var theFile: str255; var FileSpec: FSSpec; multipleFiles,haveNewButton, haveTreeOptionsButton: boolean): boolean;		var			os: OSErr;			osStat : OSStatus;			navTypes: NavTypeListHandle;			dialogOptions: NavDialogOptions;			gModalToApplicationNavDialogRef: NavDialogRef;			numItems : longint;			actualSize: Size;			returnedType: DescType;			keywd: AeKeyword;			navUPP: UniversalProcPtr;			filterProcUPP: UniversalProcPtr;	begin		gtypeList := typeList;		gNumTypes:= numTypes;		gHaveNewButton:= haveNewButton;       		gHaveTreeFileOptionsButton:= haveTreeOptionsButton;       		newButtonControl := nil;       		treeFileOptionsButtonControl := nil;		includeShowAllFileTypesCheckBoxInNavDialog := showTextOrAllinNav;		showAllFileTypes := false;		makenew := false;		NavChooseFileLocal := false;		if showTextOrAllinNav then			navTypes := nil		else			navTypes := NavTypeListFromOldTypeList(numTypes, typeList);		os := NavGetDefaultDialogOptions(dialogOptions);		dialogOptions.dialogOptionFlags := dialogOptions.dialogOptionFlags- kNavAllowPreviews-kNavAllowMultipleFiles;		if multipleFiles then			dialogOptions.dialogOptionFlags := dialogOptions.dialogOptionFlags+kNavAllowMultipleFiles;		//dialogOptions.message := prompt;				navUPP := MyNewNavEventUPP(@NavEventProc);		filterProcUPP := myNewNavObjectFilterUPP(@myFilterProc);		if (os=noErr) then			begin				{osStat := NavCreateGetFileDialog(NavDialogCreationOptionsPtr(@dialogOptions),navTypes, NavEventUPP(navUPP),nil,nil,nil,gModalToApplicationNavDialogRef);				if (osStat = noErr) & (gModalToApplicationNavDialogRef<> nil) then					begin						osStat := NavDialogRun(gModalToApplicationNavDialogRef);					      	if(osStat <> noErr) then						      begin						        NavDialogDispose(gModalToApplicationNavDialogRef);						        gModalToApplicationNavDialogRef := nil;						      end;			      		end;			     				}				osStat := NavGetFile(nil,navReply,@dialogOptions,NavEventUPP(navUPP),  nil,NavObjectFilterUPP(filterProcUPP), navTypes,nil);				if makeNew then					NavChooseFileLocal := true				else if (osStat=noErr) & navReply.validRecord then					begin						os := AECountItems(navReply.selection, numItems);						if (os=noErr) & (numItems>0) then							begin								os := AEGetNthPtr(navReply.selection, 1, typeFSS, keywd, returnedType, @FileSpec, SizeOf(FileSpec), actualSize);								if (os=noErr) then									begin										theFile := fileSpec.name;										NavChooseFileLocal := true;									end;							end;					end;				myDisposeNavEventUPP(navUPP);				myDisploseNavObjectFilterUPP(filterProcUPP);			end;					initGetButtons := false;	end;{$ENDC}{----------------------------------------------------------------------------}	function ChooseFile (numtypes: integer; typeList: ConstSFTypeListPtr; UPP: UniversalProcPtr; var theFile: str255; var FileSpec: FSSpec; multipleFiles, haveNewButton, haveTreeOptionsButton: boolean): boolean;		var			reply: StandardFileReply;			typeList2: OSType;	begin		makenew := false;		initGetButtons := false;{$IFC POWERPC}		if hasNavigationalServices then			ChooseFile := NavChooseFileLocal(numtypes,typeList,UPP,theFile, FileSpec, multipleFiles,haveNewButton, haveTreeOptionsButton)		else {$ENDC}{$IFC NOT CARBON}		if hasSys7StandFile then			begin				{if UPP=nil then					StandardGetFile(nil, numTypes, typeList, reply)				else}					CustomGetFile(nil, numTypes, typeList, reply, -6042, sfgetwhere, UPP, nil, nil, nil, nil);				if makenew then					ChooseFile := true				else					begin						fileSpec := reply.sfFile;						theFile := reply.sfFile.name;						ChooseFile := false;						if reply.sfGood then							 ChooseFile := true;					end;			end;{$ENDC}	end;end.