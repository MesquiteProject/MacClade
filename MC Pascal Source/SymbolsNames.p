unit SymbolsNames;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, 		EventUtil, GenUtil, StrUtil, CharUtil, TaxonCHUtil, UtilLibInterface, SetLibInterface;	function StandardSymbols: Boolean;	function StandardNumOfChar (c: char; it, ic: integer): integer;	function NumOfChar (c: char; it, ic: integer): integer;	function ProteinSetOfChar (c: char; douncertain: boolean; firsttaxon, it, ic: integer): largestsetchars;	function DNARNASetOfChar (c: char; douncertain: boolean; firsttaxon, it, ic: integer): largestsetchars;	function SetOfChar (c: char; douncertain: boolean; it, ic: integer): largestsetchars;	function StandardCharOfNum (num: integer): char;	function CharOfNum (num: integer): char;	function ProtCharOfNum (num: integer): char;	function ProteinCharOfSet (tsts: largestsetchars): char;	function DNARNACharOfSet (tsts: largestsetchars): char;	procedure CalcSolidIOSymbols(var iomissing,iogap,iomatchchar: char);	procedure StateSetToNexusStates(tsts: LargestSetChars; it,ic: integer; cmaxst:SignedByte; doMatchChar: boolean; writemissing,writegap,writematchchar: char; var c: char; var ds: str255);	procedure SingleNexusSymbolToStateSet(c: char; var tsts: LargestSetChars; firsttaxon, taxonNumber,ic: integer; cmaxst:SignedByte; wierdthings,doMatchChar,doEquates: boolean; readmissing,readgap,readmatchchar: char);	procedure PolymorphStringToStateSet(ds: str255; var tsts: LargestSetChars; taxonNumber,ic: integer; readMissing: char);	procedure CheckSymbolsConflictFinal;  {v3.04}	procedure CheckSymbolsConflictRead (fileSymbols: str255; missingdefined, gapdefined, formatset: boolean);	function SomeStateNamesInClipboard: boolean;	procedure InitStateNamesOfCharacter(ic: integer;backup: boolean);	function getNextStateName (ic: integer): str255;	function CharStateName (ic, is: integer): strCharStateName;	function AvailCharStateName (ic, is: integer): strCharStateName;	function LastStateName (ic: integer): integer;	function NumStateNames (ic: integer): integer;	function SomeStateNames (ic: integer): boolean;	procedure AddDotsToStateNames (ic: integer);	procedure SetCharStateName (ic, is: integer; var ds: str255);	function AminoAcidName (num: integer): str255;	procedure RenameAAs;	function StateNamesHaveSeparators: boolean;	procedure CheckStateNamesAreSymbols; {v3.05}	procedure PopUpStateNames (LocalSpot: point; ic: integer);	const		illegalSymbols = ['(', ')', '{', '}', '[', ']', '''', chr(9), chr(10), chr(13), ';', '`', '"', ',', '=', '*', '/', '\', '>', '<'];   {symbols not allowed for any symbols}		extraIllegalStateSymbols = [' ', ':'];    {symbols not allowed for state symbols}{    extraIllegalNonAlleleSepSymbols = ['/', '\'];    symbols allowed for ALLELESEP but no other symbols}{еееееееееееееееееееееее}implementation {е$S SymbolsNames}{|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}	function StandardSymbols: Boolean;	begin		StandardSymbols := (symbols = '') | (CopyString(defSymbols, 1, length(symbols)) = symbols);	end;{----------------------------------------------------------------------------}	function StandardNumOfChar (c: char; it, ic: integer): integer;{given a character c, representing a state, this converts it into the numerical value of the state}{note it is passed character number ic, for error purposes (ic=0 if not specific charactr, e.g. type matrix}		var			dc: char;			SNOC: integer;	begin		dc := CapChar(c);		SNOC := pos(dc, defSymbols) - 1;		if (SNOC < 0) or (SNOC > maxstate) then			begin				if not readon or (ic = 0) then					NewError(88, 0)				else if readon then					begin						badfile := true;						InstantErrorPlus(108, Concat(' Taxon: ', taxonName(it), ' (', StringFromNum(it), ') Character: ', Stringfromnum(ic), ' Offending Symbol: ''', c, ''''));					end;				SNOC := DefState;  {DefState = MSl}			end;		StandardNumOfChar := SNOC;	end;{v4: would be good to have a LegalStateSymbol(c: char): boolean function}{----------------------------------------------------------------------------}	function NumOfChar (c: char; it, ic: integer): integer;		var			ist: integer;	begin		ist := pos(c, symbols);		if ist > 0 then			NumOfChar := ist - 1		else			begin				if (c >= 'a') and (c <= 'z') then					c := chr(ord(c) - 32)				else if (c >= 'A') and (c <= 'Z') then					c := chr(ord(c) + 32);				ist := pos(c, symbols);				if ist > 0 then					NumOfChar := ist - 1				else					NumOfChar := StandardNumOfChar(c, it, ic);			end;	end;{----------------------------------------------------------------------------}	function ProteinSetOfChar (c: char; douncertain: boolean; firstTaxon, it, ic: integer): largestsetchars;	begin		c := CapChar(c);		case c of			'B': 				if douncertain then					ProteinSetOfChar := [2, 11, UCl]				else					ProteinSetOfChar := [2, 11];			'Z': 				if douncertain then					ProteinSetOfChar := [3, 13, UCl]				else					ProteinSetOfChar := [3, 13];			'X': 				ProteinSetOfChar := [MSl];			otherwise				if c = CapChar(missing) then  {v3.04: capchar added}					ProteinSetOfChar := [MSl]				else if c = CapChar(gap) then					ProteinSetOfChar := [MSl, GAl]				else if matchcharon & (it <> firsttaxon) & (c = CapChar(matchchar)) then					ProteinSetOfChar := gettaxonstsLargest(firsttaxon, ic)				else					ProteinSetOfChar := [NumOfChar(c, it, ic)];		end;	end;{----------------------------------------------------------------------------}	function DNARNASetOfChar (c: char; douncertain: boolean; firstTaxon, it, ic: integer): largestsetchars;	var capc: char;	begin		capc := CapChar(c);		case capc of			'A': 				begin					if c='a' then						DNARNASetOfChar := [0{,SSl}]					else						DNARNASetOfChar := [0];									end;			'B': 				begin					if douncertain then						DNARNASetOfChar := [1, 2, 3, UCl]					else						DNARNASetOfChar := [1, 2, 3];				end;			'C': 				begin					if c='c' then						DNARNASetOfChar := [1{, SSl}]					else						DNARNASetOfChar := [1];				end;			'D': 				begin					if douncertain then						DNARNASetOfChar := [0, 2, 3, UCl]					else						DNARNASetOfChar := [0, 2, 3];				end;			'G': 				begin					if c='g' then						DNARNASetOfChar := [2{, SSl}]					else						DNARNASetOfChar := [2];				end;			'H': 				begin					if douncertain then						DNARNASetOfChar := [0, 1, 3, UCl]					else						DNARNASetOfChar := [0, 1, 3];				end;			'K': 				begin					if douncertain then						DNARNASetOfChar := [2, 3, UCl]					else						DNARNASetOfChar := [2, 3];				end;			'M': 				begin					if douncertain then						DNARNASetOfChar := [0, 1, UCl]					else						DNARNASetOfChar := [0, 1];				end;			'N': 				DNARNASetOfChar := [MSl];			'R': 				begin					if douncertain then						DNARNASetOfChar := [0, 2, UCl]					else						DNARNASetOfChar := [0, 2];				end;			'S': 				begin					if douncertain then						DNARNASetOfChar := [1, 2, UCl]					else						DNARNASetOfChar := [1, 2];				end;			'T': 				begin					if c='t' then						DNARNASetOfChar := [3{, SSl}]					else						DNARNASetOfChar := [3];				end;			'U': 				DNARNASetOfChar := [3];			'V': 				begin					if douncertain then						DNARNASetOfChar := [0, 1, 2, UCl]					else						DNARNASetOfChar := [0, 1, 2];				end;			'W': 				begin					if douncertain then						DNARNASetOfChar := [0, 3, UCl]					else						DNARNASetOfChar := [0, 3];				end;			'X': 				DNARNASetOfChar := [MSl];			'Y': 				begin					if douncertain then						DNARNASetOfChar := [1, 3, UCl]					else						DNARNASetOfChar := [1, 3];				end;			otherwise				if c = CapChar(missing) then   {v3.04: capchar added}					DNARNASetOfChar := [MSl]				else if c = CapChar(gap) then					DNARNASetOfChar := [MSl, GAl]				else if matchcharon & (it <> firsttaxon) & (c = CapChar(matchchar)) then					DNARNASetOfChar := gettaxonstsLargest(firsttaxon, ic)				else					DNARNASetOfChar := [NumOfChar(c, it, ic)];		end;	end;{----------------------------------------------------------------------------}	function SetOfChar (c: char; douncertain: boolean; it, ic: integer): largestsetchars;		var			dsts: largestsetchars;	begin		if (matchcharon & (c = matchchar)) then			dsts := gettaxonstsLargest(1, ic)		else if molecular & ((c < '0') | (c > '9')) then{note that editorShowFullStateNames not requested - thus, will}{accept on entry IUPAC equivalents, but will not display them as such for protein, and will}{only display them as such for DNA,RNA if editorShowFullStateNames}			begin				if datatype = protein then					dsts := ProteinSetOfChar(c, true, 1, it, ic)				else					dsts := DNARNASetOfChar(c, true, 1, it, ic);			end		else			dsts := [NumOfChar(c, it, ic)];		SetOfChar := dsts;	end;{----------------------------------------------------------------------------}{----------------------------------------------------------------------------}	function StandardCharOfNum (num: integer): char;	begin		if (num + 1 <= length(defSymbols)) then			StandardCharOfNum := defSymbols[num + 1]		else			begin				Beep;				StandardCharOfNum := '0';			end;	end;{-----------------------------------------------------------------------------}	function CharOfNum (num: integer): char;	begin		if (num < length(symbols)) then			CharOfNum := symbols[num + 1]		else			CharOfNum := StandardCharOfNum(num);	end;{-----------------------------------------------------------------------------}	function ProtCharOfNum (num: integer): char;	begin		if (num < length(protSymbols)) then			ProtCharOfNum := protSymbols[num + 1]		else			ProtCharOfNum := StandardCharOfNum(num);	end;{-----------------------------------------------------------------------------}	function ProteinCharOfSet (tsts: largestsetchars): char;	begin		tsts := ZeroHighBitsLg(tsts);		if MonomorphLG(tsts) then			ProteinCharOfSet := ProtCharOfNum(MinLg(tsts))		else if tsts = [2, 11] then			ProteinCharOfSet := 'B'		else if tsts = [3, 13] then			ProteinCharOfSet := 'Z'{$IFC FALSE}		else if (tsts = [21, 22]) & ((theGeneticCode = nuclearcode) or (theGeneticCode = mtDNAcode)) then			ProteinCharOfSet := 'S'		else if (tsts = [23, 24]) & (theGeneticCode = mtDNAcode) then			ProteinCharOfSet := '*'{$ENDC}		else			ProteinCharOfSet := '?';	end;{-----------------------------------------------------------------------------}	function DNARNACharOfSet (tsts: largestsetchars): char;	var smallSymbol: boolean;	begin		smallSymbol := SSl in tsts;		tsts := ZeroHighBitsLg(tsts);		if tsts = [0] then			if smallSymbol then				DNARNACharOfSet := 'a'			else				DNARNACharOfSet := 'A'		else if tsts = [1] then			if smallSymbol then				DNARNACharOfSet := 'c'			else				DNARNACharOfSet := 'C'		else if tsts = [2] then			if smallSymbol then				DNARNACharOfSet := 'g'			else				DNARNACharOfSet := 'G'		else if tsts = [3] then			begin				if datatype = DNA then					if smallSymbol then						DNARNACharOfSet := 't'					else						DNARNACharOfSet := 'T'				else if datatype = RNA then					if smallSymbol then						DNARNACharOfSet := 'u'					else						DNARNACharOfSet := 'U'			end		else if tsts = [1, 2, 3] then			DNARNACharOfSet := 'B'		else if tsts = [0, 2, 3] then			DNARNACharOfSet := 'D'		else if tsts = [0, 1, 3] then			DNARNACharOfSet := 'H'		else if tsts = [2, 3] then			DNARNACharOfSet := 'K'		else if tsts = [0, 1] then			DNARNACharOfSet := 'M'		else if tsts = [0, 1, 2, 3] then			DNARNACharOfSet := 'N'		else if tsts = [0, 2] then			DNARNACharOfSet := 'R'		else if tsts = [1, 2] then			DNARNACharOfSet := 'S'		else if tsts = [0, 1, 2] then			DNARNACharOfSet := 'V'		else if tsts = [0, 3] then			DNARNACharOfSet := 'W'		else if tsts = [1, 3] then			DNARNACharOfSet := 'Y'		else if (tsts = []) & smallsymbol then			DNARNACharOfSet := 'N'		else 			DNARNACharOfSet := '?';	end;{-----------------------------------------------------------------------------}	procedure CalcSolidIOSymbols(var iomissing,iogap,iomatchchar: char);	begin		if missing = ' ' then			iomissing := '?'		else			iomissing := missing;		if gap = UndefinedGap then			iogap := '-'		else			iogap := gap;		if matchchar = ' ' then			iomatchchar := '.'		else			iomatchchar := matchchar;	end;{-----------------------------------------------------------------------------}	procedure StateSetToNexusStates(tsts: LargestSetChars; it,ic: integer; cmaxst:SignedByte; doMatchChar: boolean; writemissing,writegap,writematchchar: char; var c: char; var ds: str255);	var j: integer;{...................................}		procedure StateSetToNexusPolyStates (tsts: largestsetchars);			var				j: integer;		begin			c := chr(13); 			if UCl in tsts then				ds := '{'			else				ds := '(';			for j := 0 to cmaxst do				if j in tsts then					ds := concat(ds,CharOfNum(j));			if UCl in tsts then				ds := concat(ds,'}')			else				ds := concat(ds,')');		end;	begin		c := chr(13);		ds := '';		if tsts = [MSl] then			begin				if nucleotides & AlternativeSymbol(it,ic) then					c := 'N'				else					c := writemissing;			end		else if tsts = [msl, gal] then			c := writegap		else if doMatchChar & (it <> 1) & (tsts = gettaxonstsLargest(1, ic)) then			c := writematchchar		else if nucleotides then	{@@@@@  DNA RNA @@@@@}			begin				if not (UCl in tsts) & (mstaxa = mstVariable) & (MultipleStatesLg(tsts)) then					StateSetToNexusPolyStates(tsts)				else					c := DNARNACharOfSet(tsts);				if AlternativeSymbol(it,ic) then					if c ='A' then						c := 'a'					else if c ='C' then						c := 'c'					else if c ='G' then						c := 'g'					else if c ='T' then						c := 't';			end		else if datatype = protein then			{@@@@@  protein @@@@@}			begin				c := ProteinCharOfSet(tsts);				if c = '?' then					StateSetToNexusPolyStates(tsts);			end		else if MonomorphLg(tsts) then			{@@@@@  standard @@@@@}			begin				j := minLg(tsts);				c := CharOfNum(j);			end		else			StateSetToNexusPolyStates(tsts);	end;{-----------------------------------------------------------------------------}	procedure PolymorphStringToStateSet(ds: str255; var tsts: LargestSetChars; taxonNumber,ic: integer; readMissing: char);	{note that braces or parentheses MUST be the first character in the string}	var ist, endist: integer;		j: integer;	begin		tsts :=[];		if (length(ds)<2)  & not ((ds[1] = '{') | (ds[1] = '(')) then Exit(PolymorphStringToStateSet);				if ((ds[1] = '{') and (msTaxa = mstVariable)) or (msTaxa = mstUncertain) then					tsts := [UCl];		for j := 1 to length(ds) do			begin				if (ds[j] = '}') or (ds[j] = ')') then leave;				if ds[j] = '~' then					begin						endist := NumOfChar(ds[j], taxonNumber, ic);						if endist <> MSl then							tsts := tsts + [ist..endist];					end				else if not (ds[j] in [' ', chr(9), chr(13), chr(10), ',', '}', ')']) then					begin						if (ds[j] <> readmissing) then							begin								ist := NumOfChar(ds[j], taxonNumber, ic);								if ist <> MSl then									tsts := tsts + [ist];							end;					end;			end;	end;{-----------------------------------------------------------------------------}	procedure SingleNexusSymbolToStateSet(c: char; var tsts: LargestSetChars; firsttaxon, taxonNumber,ic: integer; cmaxst:SignedByte; wierdthings,doMatchChar,doEquates: boolean; readmissing,readgap,readmatchchar: char);	begin		tsts :=[];		if wierdthings then			begin				if doEquates & equateson & (equates^^[ord(c)] <> []) then					begin						tsts := equates^^[ord(c)];						if MultipleStatesLg(tsts) then							begin								if (msTaxa = mstUncertain) then									tsts := tsts + [UCl]								else if (msTaxa = mstPolymorph) then									tsts := tsts - [UCl];							end;					end				else if nucleotides then{======== DNA RNA ========}					tsts := DNARNASetOfChar(c, msTaxa <> mstPolymorph, firstTaxon, taxonNumber, ic){========= protein ============}				else if datatype = protein then					tsts := ProteinSetOfChar(c, msTaxa <> mstPolymorph, firstTaxon, taxonNumber, ic){========================}				else if matchcharon & (taxonNumber <> firstTaxon) & (c = readMatchchar) then					tsts := gettaxonstsLargest(firstTaxon, ic)				else if c = readMissing then					tsts := [MSl]				else if c = readGap then					tsts := [MSl, GAl]				else					tsts := [NumOfChar(c, taxonNumber, ic)];			end		else  {not wierd}			begin				if c = readMissing then					tsts := [MSl]				else if c = readGap then					tsts := [MSl, GAl]				else					tsts := [StandardNumOfChar(c, taxonNumber, ic)]			end;	end;{-----------------------------------------------------------------------------}	function LowerUpperSymbolsBad: boolean;{returns true if there are entries in the symbols list which differ only by being upper and lower case}		label			1;		var			s1, s2: integer;			c: char;	begin		LowerUpperSymbolsBad := false;		for s1 := 1 to length(symbols) do			for s2 := s1 + 1 to length(symbols) do				if CapChar(symbols[s1]) = CapChar(symbols[s2]) then					begin						LowerUpperSymbolsBad := true;						goto 1;					end;1:	end;{-----------------------------------------------------------------------------}	function CharInSymbols (c: char; isMissing: boolean): boolean;   {v3.04}{returns true if the character c is present in the symbols list}		var			db: boolean;	begin		db := pos(c, symbols) > 0;   {if db, then c is in symbols}		if not db & molecular then			if nucleotides & isMissing & ((c = 'n') | (c = 'N')) then   {v3.05: it's OK - this allows N to be missing symbol}			else				db := CharIsMolecularChar(c);		CharInSymbols := db;	end;{-----------------------------------------------------------------------------}	procedure SetSymbolToVacant (var c: char; illegal: wstype);	begin		c := chr(33);		repeat			c := char(ord(c) + 1);		until not CharInSymbols(c, false) and not (c in illegal) and not (c in punct305);   {want to pass false to CharInSymbols as don't want to use up N}{v3.06:  added not c in punct305 to above statement}	end;{-----------------------------------------------------------------------------}	procedure CheckSymbolsConflictFinal;  {v3.04}  {this is called after everything read in, or in switching data formats}		var			inSymbols, dupPunct: boolean;	begin{v3.04: changed way this is handled.  Now just reset everything to defaults}		inSymbols := (CharInSymbols(orsep, false) or CharInSymbols(andsep, false) or CharInSymbols(missing, true) or CharInSymbols(gap, false) or CharInSymbols(matchchar, false));		dupPunct := (missing in [gap, andsep, orsep, matchchar]) or (gap in [missing, andsep, orsep, matchchar]) or (andsep in [missing, gap, orsep, matchchar]) or (orsep in [missing, gap, andsep, matchchar]) or (matchchar in [missing, gap, andsep, orsep]);		if inSymbols or dupPunct then			begin				missing := missingDef;				gap := gapDef;				matchchar := matchcharDef;				andsep := andsepDef;				orsep := orSepDef;				if not molecular then					begin						symbols := '01';						FillRestSymbols;					end;				NewError(403, 0);			end;	end;{-----------------------------------------------------------------------------}	procedure CheckSymbolsConflictRead (fileSymbols: str255; missingdefined, gapdefined, formatset: boolean);		var			c: char;	begin{v 3.06:  added fileSymbols, which is the symbols list explicitly used in format statement.  }{the reason this is passed into here is to help resolve symbols conflicts.  In particular,}{the user may have defined a missing or gap that does not duplicate the fileSymbols, }{but does conflict with extra symbols added by the FillRestSymbols procedure}		if not missingdefined and (CharInSymbols(missing, true) or (missing in [matchchar, gap])) then 						{there is a conflict between default missing and others}			SetSymbolToVacant(missing, [matchchar, gap]);		if not gapdefined and (CharInSymbols(gap, false) or (gap in [missing, matchchar])) then						{there is a conflict between default gap and others}			SetSymbolToVacant(gap, [matchchar, missing]);		if not matchcharon and (CharInSymbols(matchchar, false) or (matchchar in [missing, gap])) then						{there is a conflict between default matchchar and others}			SetSymbolToVacant(matchchar, [missing, gap]);{=== this section is v3.06 ===}		if missingdefined & (pos(missing, symbols) > 0) & (pos(missing, filesymbols) = 0) then		{conflict between missing and extra symbols added during FillRestSymbols}			begin				delete(symbols, pos(missing, symbols), 1);				SetSymbolToVacant(c, [matchchar, missing, gap]);				symbols := concat(symbols, c);			end;		if gapdefined & (pos(gap, symbols) > 0) & (pos(gap, filesymbols) = 0) then		{conflict between gap and extra symbols added during FillRestSymbols}			begin				delete(symbols, pos(gap, symbols), 1);				SetSymbolToVacant(c, [matchchar, missing, gap]);				symbols := concat(symbols, c);			end;		if matchcharon & (pos(matchchar, symbols) > 0) & (pos(matchchar, filesymbols) = 0) then		{conflict between matchchar and extra symbols added during FillRestSymbols}			begin				delete(symbols, pos(matchchar, symbols), 1);				SetSymbolToVacant(c, [matchchar, missing, gap]);				symbols := concat(symbols, c);			end;{======}		if LowerUpperSymbolsBad then			begin				NewError(103, 0);				badfile := true;				errorflag := true;			end		else if (CharInSymbols(missing, true) or CharInSymbols(gap, false) or CharInSymbols(matchchar, false) or (missing in [matchchar, gap]) or (gap = matchchar)) then			begin				NewError(126, 0);				badfile := true;				errorflag := true;			end;	end;{||||||||||||||||||||||||||||||||||||||||||||  State Names  ||||||||||||||||||||||||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	function getNextStateName (ic: integer): str255;{gets next state name in the names handle beyond the position CHUNKpos}		var			ds: str255;			chunksize: longint;			c: char;			H: Handle;			oldState: SignedByte;	begin		if datatype = protein then			H := AminoAcidNamesHdl		else			H := HdlPtr(GetMaster(statenamesCHUNKs) + HdlSize * longint(ic - 1))^;		LockHandle(H, oldState);		chunksize := GetHandleSize(H);		StartHandleRead(H);		ds := '';							{find first non whitespace char}		while (curCHUNKchar in whitespace+vacuum-[EndNames,NoName]) and (CHUNKpos < chunksize) do			CHUNKpos := CHUNKpos + 1;		c := curCHUNKchar;		if (c = NoName) or (c = EndNames) then			begin				ds := c;				CHUNKpos := CHUNKpos + 1;			end		else			while (c <> ' ') and (CHUNKpos < chunksize) do				begin					concatstringChar(@ds, c);					CHUNKpos := CHUNKpos + 1;					c := curCHUNKchar;				end;		getNextStateName := ds;		ResetHandle(H, oldState);	end;{----------------------------------------------------------------------------}	function CharStateName (ic, is: integer): strCharStateName;		var			thisstate: integer;			ds255: str255;			chunksize: longint;	begin		if ic < 1 then			ds255 := ''		else			begin				CHUNKpos := 0;				thisstate := -1;				repeat					thisstate := thisstate + 1;					ds255 := GetNextStateName(ic);				until (thisstate >= is) or (ds255 = EndNames);				if (thisstate <> is) | (ds255 = NoName) | (ds255 = EndNames) | (ds255 = ' ') then					ds255 := ''				else					UnderLineToBlanks(ds255);{HUnLock(dhdl);}{HUnLock(statenamesCHUNKs);}{the historic bug}{April, 1990.  Symptom: when file read in with character traced, or sometimes not, would}{crash with id02, illgl error, or spontaneously quit to finder when branch was fixed, branch moved,}{etc.  It was clear that program counter was being sent into hyperspace, and that it occurred when}{program attempted to enter into either reconstructtraced or counttree.}{}{Diagnosis: in Charstatename, called by AvailCharstatename called by Drawchlegboxes called}{by Drawchleg, was an HUnlock(dhdl) which had two problems: dhdl is a global, and may have}{been undefined at this point, and the call was unbalanced by an Hlock.  It is apparently}{this statement which unlocked segment $030, that containing unit Counttree.  Unlocking a}{segment should only occur in the context of a segment loader call that can appropriately}{update the jump table.  Since it was unlocked, the segment got moved by the memory manager}{just before treeleg, to a bit lower in memory.  Later, when the segment loader was unloading}{the segment, it used the jump table's stated memory locations for the procedures and subtracted}{the segment's location to get the offsets for each procedure.  But since the segment had gotten}{moved down unbeknownst to the jump table, the offsets that were calculated where too high.  }{Then, the next time a call was made to one of these procedures in segment $030, the segment}{loader used these offsets to calculate pointers to each of the procedures, the pointers were}{too high by exactly the amount the segment had moved down.}			end;		CharStateName := CopyString(ds255, 1, stnw);	end;{----------------------------------------------------------------------------}	function AvailCharStateName (ic, is: integer): strCharStateName;		var			tds: strCharStateName;	begin		tds := CharStateName(ic, is);		if (tds = '') then			begin				tds := CharOfNum(is);			end;		AvailCharStateName := tds;	end;{-----------------------------------------------------------------------------}	function LastStateName (ic: integer): integer;{returns the number of the last named state in character ic; 0-based}{returns -1 if no names}		var			laststate, numstates: integer;			st: str255;	begin		CHUNKpos := 0;		laststate := -1;		numstates := 0;		while (numstates <= maxstate) do			begin				st := GetNextStateName(ic);				if (st = EndNames) or (st = '') then					leave				else					begin						numstates := numstates + 1;						if st <> NoName then			{in case of trailing NoNames}							laststate := numstates - 1;					end;			end;		LastStateName := laststate;	end;{-----------------------------------------------------------------------------}	function NumStateNames (ic: integer): integer;{returns the number of named states (NOT COUNTING NoName states!) for character ic}		var			numnames, ir: integer;			st: str255;	begin		CHUNKpos := 0;		numnames := 0;		while (numnames <= maxstate) do			begin				st := GetNextStateName(ic);				if (st = EndNames) or (st = '') then					leave				else if st <> NoName then					numnames := numnames + 1;			end;		NumStateNames := numnames;	end;{-----------------------------------------------------------------------------}	function SomeStateNames (ic: integer): boolean;{returns true if there exists at least one state name for character ic}		var			chunksize: longint;			oldState: SignedByte;	begin		statenamesHdl := HdlPtr(GetMaster(statenamesCHUNKs) + HdlSize * longint(ic - 1))^;		chunksize := GetHandleSize(statenamesHdl);		LockHandle(statenamesHdl, oldState);		StartHandleRead(statenamesHdl);		CHUNKpos := chunksize - 1;		while (curCHUNKchar in [' ', chr(13), chr(9), NoName, ',', EndNames, chr(10)]) and (CHUNKpos > 0) do			CHUNKpos := CHUNKpos - 1;			{go backwards}		ResetHandle(statenamesHdl, oldState);		SomeStateNames := (CHUNKpos > 0);	end;{-----------------------------------------------------------------------------}	procedure AddDotsToStateNames (ic: integer);{adds NoNames to StateNames buffer for character ic}		var			numstates, j: integer;			ds, st: str255;			chunksize: longint;	begin		statenamesHdl := HdlPtr(GetMaster(statenamesCHUNKs) + HdlSize * longint(ic - 1))^;		chunksize := GetHandleSize(statenamesHdl);		CHUNKpos := 0;	{======  loop to find out how many state names spots there are ======= }		numstates := -1;		while true do			begin				st := getNextStateName(ic);				if (st = '') or (st = EndNames) then					leave				else					numstates := numstates + 1;			end;		if numstates < maxstate then			begin				st := ''; 				ds := concat(' ', NoName);				for j := 1 to maxstate - numstates do					st := concat(st, ds);				st := concat(st, ' ', EndNames);				ds := EndNames;{replace old EndNames in statenamesHdl by new string with NoName filler and EndNames: }				chunksize := Munger(statenamesHdl, 0, Pointer(ord4(@ds) + 1), 1, Pointer(ord4(@st) + 1), length(st));			end;	end;{----------------------------------------------------------------------------}	procedure SetCharStateName (ic, is: integer; var ds: str255);{sets the name of state is of character ic to ds}{don't forget: if this procedure called, make sure that if not foottexton, then a procedure like}{InvalidateFootRect in Recode.p needs to be called}		var			selstart, selend, k: integer;			dL: longint;			st: str255;	begin		Stripblanks(ds);		if ds = '' then			ds := NoName		else			BlanksToUnderLine(ds);		statenamesHdl := HdlPtr(GetMaster(statenamesCHUNKs) + HdlSize * longint(ic - 1))^;		CHUNKpos := 0;		for k := 0 to is do			begin				selstart := CHUNKpos;				st := getNextStateName(ic);			end;		selstart := selstart + 1;		selend := CHUNKpos;		dL := Munger(statenamesHdl, selstart, nil, selend - selstart, Pointer(ord4(@ds) + 1), length(ds));	end;{----------------------------------------------------------------------------}	function SomeStateNamesInClipboard: boolean;	begin		SomeStateNamesInClipboard := (GetHandleSize(statesClipboardH)>2);	end;{----------------------------------------------------------------------------}	procedure InitStateNamesOfCharacter(ic: integer;backup: boolean);	var			H: Handle;			ds: str255;			dl: Longint;	begin		ds := concat(' ', NoName, ' ', EndNames);		if backup then			H := getCHUNKHdl(statenamesCHUNKsBU, ic)		else			H := getCHUNKHdl(statenamesCHUNKs, ic);		ReplaceHandleContentsWithString(H, ds);	end;{-----------------------------------------------------------------------------}	function AminoAcidName (num: integer): str255;	begin		case num of			0: 				AminoAcidName := 'Ala';			1: 				AminoAcidName := 'Cys';			2: 				AminoAcidName := 'Asp';			3: 				AminoAcidName := 'Glu';			4: 				AminoAcidName := 'Phe';			5: 				AminoAcidName := 'Gly';			6: 				AminoAcidName := 'His';			7: 				AminoAcidName := 'Ile';			8: 				AminoAcidName := 'Lys';			9: 				AminoAcidName := 'Leu';			10: 				AminoAcidName := 'Met';			11: 				AminoAcidName := 'Asn';			12: 				AminoAcidName := 'Pro';			13: 				AminoAcidName := 'Gln';			14: 				AminoAcidName := 'Arg';			15: 				AminoAcidName := 'Ser';			16: 				AminoAcidName := 'Thr';			17: 				AminoAcidName := 'Val';			18: 				AminoAcidName := 'Trp';			19: 				AminoAcidName := 'Tyr';			20: 				AminoAcidName := '*';			21: 				AminoAcidName := '1';			22: 				AminoAcidName := '2';			23: 				AminoAcidName := '3';			24: 				AminoAcidName := '4';			otherwise				AminoAcidName := ' ';		end;	end;{-----------------------------------------------------------------------------}	procedure RenameAAs;		var			ds: str255;			j: integer;	begin		ds := ' Ala Cys Asp Glu Phe Gly His Ileu Lys Leu Met Asn Pro Gln Arg Ser Thr Val Trp Tyr * ';		for j := 1 to 4 do			begin				if extraAAStates[j] >= 0 then					ds := concat(ds, StringFromNum(j), '.', AminoAcidName(extraAAStates[j]), ' ')				else					ds := concat(ds, StringFromNum(j), ' ');			end;		StringToH(ds, AminoAcidNamesHdl);		AppendToHandle(AminoAcidNamesHdl, EndNames);	end;{-----------------------------------------------------------------------------}	function StateNamesHaveSeparators: boolean;		label			1;		var			ic, numstates: integer;			st: str255;			hasAnd, hasOr: boolean;{this procedure goes through all state names, and checks to see if any contain andsep or}{orsep, if so fixes state name and gives warning}	begin		hasAnd := false;		hasOr := false;		StateNamesHaveSeparators := false;		if not molecular then  {v3.05}			for ic := 1 to numchars do				begin					CHUNKpos := 0;					numstates := 0;					while (numstates <= maxstate) do						begin							st := GetNextStateName(ic);							if (st = EndNames) or (st = '') then								leave							else if st <> NoName then								begin									numstates := numstates + 1;									if not hasAnd & (pos(andsep, st) > 0) then										begin											StateNamesHaveSeparators := true;											if CharName(ic) = '' then												InstantErrorPlus(357, concat(StringFromNum(ic), '   State: ', st))											else												InstantErrorPlus(357, concat(CharName(ic), '   State: ', st));											hasAnd := true;											if hasOr then												goto 1;										end;									if not hasOr & (pos(orsep, st) > 0) then										begin											StateNamesHaveSeparators := true;											if CharName(ic) = '' then												InstantErrorPlus(358, concat(StringFromNum(ic), '   State: ', st))											else												InstantErrorPlus(358, concat(CharName(ic), '   State: ', st));											hasOr := true;											if hasAnd then												goto 1;										end;								end;						end;				end;1:	end;{-----------------------------------------------------------------------------}	procedure CheckStateNamesAreSymbols; {v3.05}		label			1;		var			ic, numstates: integer;			st: str255;{this procedure goes through all state names, and checks to see if any contain any symbols}	begin		StateNamesAreSymbols := false;		CharWithStateNamesAsSymbols := 0;		if not molecular then			for ic := 1 to numchars do				begin					CHUNKpos := 0;					numstates := 0;					while (numstates <= maxstate) do						begin							st := GetNextStateName(ic);							if (st = EndNames) or (st = '') then								leave							else if st <> NoName then								begin									numstates := numstates + 1;									if (length(st) = 1) & (pos(st, symbols) > 0) then  {it is a single character long and is a symbol}										begin											StateNamesAreSymbols := true;											CharWithStateNamesAsSymbols := ic;											goto 1;										end;								end;						end;				end;1:	end;{-----------------------------------------------------------------------------}	procedure PopUpStateNames (LocalSpot: point; ic: integer);		var			StateNamesMHdl: MenuHandle;			globalspot: point;			menucode: longint;			j, numstates: integer;	begin		numstates := LastStateName(ic);		if numstates <0 then			numstates := NumStateNames(ic) - 1;		if numstates >= 0 then			begin				globalspot := localSpot;				LocalToGlobal(globalspot);				StateNamesMHdl := NewMenu(StateNamesMenu, ' ');				InsertMenu(StateNamesMHdl, -1);				for j := 0 to numstates do					begin						AppendMenu(StateNamesMHdl, ' ');{use SetMenuItemText to avoid menu metacharacters}						SetMenuItemText(StateNamesMHdl, j + 1, concat(CharOfNum(j), ': ', CharStateName(ic, j)));					end;				menucode := PopUpMenuSelect(StateNamesMHdl, globalspot.v + 5, globalspot.h + 5, 1);				DeleteMenu(StateNamesMenu);				DisposeMenu(StateNamesMHdl);			end;	end;end.