unit CalcUtil;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, UtilLibInterface, SetLibInterface,   TypeUtil, CharUtil, TreeUtil, Polycalc;{handle managers}	function SetPtrFromHandleLock (var ah: handle; ist: integer): Ptr;	procedure IncrSetPointer (var ap: Ptr);	procedure Incr3SetPointers (var ap, bp, cp: Ptr);	procedure Unlock3Handles (var ah, bh, ch: handle);	procedure ResetClenPtr (var clenP: LIP; ist: integer);	procedure ResetCtypPtr (var ctypP: IP; ist: integer);	procedure IncrementCtypPtr (var ctypP: IP);	procedure IncrementClenPtr (var cLenP: LIP);{general use State set Operation functions/procedures}	procedure stSetOpLargest (var rset: largestsetchars; Set1, set2: largestsetchars; ictype: INTEGER; var len: longint);	function OrdOpLargest (setL, setR: Largestsetchars; var len: longint): largestsetchars;	function TripleOrdOpLargest (set1, set2, set3: Largestsetchars): largestsetchars;	function ClosestInAtoB (earth, moon: largestsetchars; itype: integer): largestsetchars;{Distance Utilities}	procedure AddDistBetweenSets (Nanc, N: Largestsetchars; ic: integer; var len: longint);	procedure AddDistOneToTwo (N, Na, Nb: Largestsetchars; ic: integer; var len: longint);	procedure AddDistOneToMany (N: Nptr; ic: integer; var len: longint);{Special state set operators for specific contexts}	procedure TripleCombineCore (var Nfinalsts: largestsetchars; Nlfdown, Nrtdown, Nup, Nancfinal: largestsetchars; ictype: integer);	procedure TripleFixancedByUncertain (var Nfinalsts: largestsetchars; Notfixancdown, FixancDown, NancPref: largestsetchars; ictype: integer);	procedure CombineFixancedDown (var Ndown: largestsetchars; Nfixanceddown, NNotfixanceddown, Nfixtaxonsts: Largestsetchars; var chl: longint; ic: integer; N: Nptr; traced: boolean);	procedure TerminalFilterCore (var Nfinalsts: largestsetchars; PrefBelow, taxonsts: largestsetchars; ictype: integer);{еееееееееееееееееееееее}implementation {е$S CalcUtil}{-----------------------------------------------------------------------------}{######  UTILITIES FOR DISCRETE CHARACTER NODE CALCULATIONS  ########}{This unit contains various utilities used in the counting and reconstruction calculations}{both for the traced character and for the other characters (as for counting and trace all)}{-----------------------------------------------------------------------------}{==================================================================}{-----------HANDLE MANAGERS------------------}{These utilities lock and unlock handles, return pointers, and so on}	function SetPtrFromHandleLock (var ah: handle; ist: integer): Ptr;	begin		HLock(ah);		SetPtrFromHandleLock := Ptr(GetMaster(aH) + tcb * ord4(ist - 1));	end;	procedure IncrSetPointer (var ap: Ptr);{increments pointers to character storage}{v4:  put this in asm?}	begin		aP := Ptr(ord4(aP) + tcb);	end;{------------------------------------------}	procedure Open3SetHandles (var ah, bh, ch: handle; var ap, bp, cp: Ptr; ist: integer);{locks handles to character storage and gets pointers to location of character ist}{Must be balanced by later call to Unlock3Handles}		var			increm: longint;	begin		increm := tcb * ord4(ist - 1);		HLock(ah);		HLock(bH);		HLock(cH);		aP := Ptr(GetMaster(aH) + increm);		bP := Ptr(GetMaster(bH) + increm);		cP := Ptr(GetMaster(cH) + increm);	end;{------------------------------------------}	procedure Incr3SetPointers (var ap, bp, cp: Ptr);{increments pointers to character storage}{v4:  put this in asm?}	begin		aP := Ptr(ord4(aP) + tcb);		bP := Ptr(ord4(bP) + tcb);		cP := Ptr(ord4(cP) + tcb);	end;{------------------------------------------}	procedure Unlock3Handles (var ah, bh, ch: handle);{closes three handles to character storage.  Use only after Open3SetHandles}	begin		HUnLock(ah);		HUnLock(bH);		HUnLock(cH);	end;{------------------------------------------}	procedure ResetClenPtr (var clenP: LIP; ist: integer);{sets pointers to length storage to character ist}{caution: does not also lock handle}	begin		ClenP := LIP(GetMaster(chLenH) + chlb * ord4(ist - 1));	end;{------------------------------------------}	procedure ResetCtypPtr (var ctypP: IP; ist: integer);	begin		CtypP := IP(GetMaster(cHtypH) + chtb * ord4(ist - 1));	end;{------------------------------------------}	procedure IncrementCtypPtr (var ctypP: IP);	begin		CtypP := IP(ord4(ctypP) + chtb)	end;{------------------------------------------}	procedure IncrementClenPtr (var cLenP: LIP);	begin		ClenP := LIP(ord4(cLenP) + chlb);	end;{==================================================================}{------------ GENERAL State Set Operation FUNCTIONS/PROCEDURES----------------------}{These are used in various places in MacClade to do basic state set operations}{------------------------------------------------------}	function ClosestInAtoB (earth, moon: largestsetchars; itype: integer): largestsetchars;{FROZEN 3.0}{returns element in earth closest to moon , overlap if it exists }		var			minL, maxL: integer;			tempset, rset, earthG, moonG: lgsetchars;	begin		earthG := NewSetFromOld(earth);		moonG := NewSetFromOld(moon);		if itype = unordered then			begin				tempset := Intersect2(earthG, moonG);				if tempset = nil then					rset := earthG				else					rset := tempset;			end		else {ordered types}			begin				minL := minG(earthG);				maxL := maxG(earthG);				tempset := Intersect2(MakeSpan(minL, maxL), MakeSpan(minG(moonG), maxG(moonG)));				if tempset <> nil then					rset := tempset				else					begin						if minG(moonG) > minL then							rset := Makeset(maxL)						else							rset := Makeset(minL)					end;			end;		ClosestinAtoB := OldSetfromNew(rset);	end;{-----------------------------------------------------------------------------}	function OrdOpLargest (setL, setR: Largestsetchars; var len: longint): largestsetchars;{FROZEN 3.0}{state set op for ordered chars when st sets don't overlap, }{and increments len by the distance between sets}		var			mnL, mxL, mnR, mxR: integer;	begin		MaxMinLg(setL, mnL, mxL);		MaxMinLg(setR, mnR, mxR);		if mnR > mxL then     	        {I---L---I  I---R---I }			begin				OrdOpLargest := [mxL..mnR];                {result set is between left & right}				len := len + mnR - mxL;			end		else     			 	{I---R---I  I---L---I }			begin				OrdOpLargest := [mxR..mnL];    	        {result set is between right & left}				len := len + mnL - mxR;			end;	end;{-----------------------------------------------------------------------------}	procedure stSetOpLargest (var rset: largestsetchars; Set1, set2: largestsetchars; ictype: INTEGER; var len: longint);{FROZEN 3.0}{state set operation for ord,unord,irrev,fisher chars --}{Combines set1 and set2 and returns result in rset}{also increments length if char is not fisher}		var			minofmax: integer;	begin		rset := set1 * set2; 		        {if sets intersect then take intersection}		if rset = [] then			{otherwise do union/etc & add to length}			case ictype of				unordered: 					begin						len := len + 1; 		{increment length}						rset := set1 + set2; 		{take union of sets}					end;				ordered: 					rset := OrdOpLargest(set1, set2, len);				irreversible, fisher: 					begin			{For internal nodes, irrev state sets that span more than one state must represent uncertainty.}						minofmax := IntegerMin(maxLg(set1), maxLg(set2));			{Therefore result set must be smallest maximum}						rset := [minofmax];			{ and length added is from smallest maximum to minimum of higher set}						if ictype = irreversible then							len := len + IntegerMax(minLg(set1), minLg(set2)) - minofmax;			{note for fisher length added by missed strata added elsewhere}					end;				dollo: 					NewError(5, 0);  {dollo chars should not be processed here}				otherwise					;			end;	end;{------------------------------------------------------}	function TripleOrdOpLargest (set1, set2, set3: Largestsetchars): largestsetchars;{FROZEN 3.0}{Modified triple state set operator for ordered characters}{Takes three state sets (1,2,3) and combines into result}{Note this is not the same as the triple operator used by Swofford & Maddison}{This presumes triple intersection does not exist}		var			min1, min2, min3, max1, max2, max3: INTEGER;			set1G, set2G, set3G: lgsetchars;			TOOL: lgsetchars;		function TOOLcomb (ma, mb: integer; s: lgsetchars): lgsetchars;		begin			Toolcomb := Intersect2(MakeSpan(ma, mb), s);		end;	begin{find & store min's and max's of all 3 sets}		set1G := NewSetFromOld(set1);		set2G := NewSetFromOld(set2);		set3G := NewSetFromOld(set3);		min1 := minG(set1G);		max1 := maxG(set1G);		min2 := minG(set2G);		max2 := maxG(set2G);		min3 := minG(set3G);		max3 := maxG(set3G);{Two most distant sets found then between-space intersected with remaining set}		if (min1 > min2) and (min1 > min3) then			begin   {set1 minimum furthest right}				if max2 < max3 then  {most distant are 2 and 1}					TOOL := ToolComb(max2, min1, set3G)  {[--2-(-]--3--)  [--1--] }				else  {most distant are 3 and 1}					TOOL := ToolComb(max3, min1, set2G); {[--3-(-]--2--)  [--1--] }			end		else if min2 > min3 then			begin   {set2 minimum furthest right}				if max1 < max3 then  {most distant are 1 and 2}					TOOL := ToolComb(max1, min2, set3G)   {[--1-(-]--3--)  [--2--] }				else  {most distant are 3 and 2}					TOOL := ToolComb(max3, min2, set1G)   {[--3-(-]--1--)  [--2--] }			end		else			begin  {set3 furthest right}				if max1 < max2 then  {most distant are 1 and 3}					TOOL := ToolComb(max1, min3, set2G)   {[--1-(-]--2--)  [--3--] }				else  {most distant are 2 and 3}					TOOL := ToolComb(max2, min3, set1G); {[--2-(-]--1--)  [--3--] }			end;		TripleOrdOpLargest := OldSetFromNew(TOOL);	end;{------------------------------------------------------}	function TripleIrrevOpLargest (N1down, N2down, Nancfinal: Largestsetchars): largestsetchars;{FROZEN 3.0}{Triple state set operator for irreversible characters}{called only in this unit.}{Does NOT presume triple intersection does not exist, but presuming irreversibility is not violated,}{nancfinal must have its minimum below minima of N1down and N2down.}		var			Nfinal: largestsetchars;	begin		{For irrev/fisher characters, final state set includes:}		{(1). intersection of span from ancestor's smallest up to largest minimum of descendants}		{with second descendant's set.   Since the ancestor can be assigned its smallest value, }		{which must be less than or equal to smallest value in descendants, }		{we have something like tripleordop in which ancestor and largest descendant}		{are two most distant sets, and intersection with third is used. }		if minLg(N2down) > minLg(N1down) then			Nfinal := N1down * [minLg(Nancfinal)..minLg(N2down)]		else			Nfinal := N2down * [minLg(Nancfinal)..minLg(N1down)];		{(2). Anything in triple intersection.  This accounts for possibility of ancestor being assigned state}		{up to highest value in state set.  If largest minimum of descendants is less than this value,}		{then above calculations will miss such values.  Since any value in ancestor's state set which}		{is above largest minimum must overlap both descendant state sets (otherwise ancestor}		{would be violating irreversibility), such values can be obtained by triple intersection.}		Nfinal := Nfinal + N1down * Nancfinal * N2down;		TripleIrrevOpLargest := Nfinal;	end;{==================================================================}{------------ADD DISTANCE UTILITIES-------------------------------------------}{These are used to calculate lengths between branchs on tree}	procedure AddDistBetweenSets (Nanc, N: Largestsetchars; ic: integer; var len: longint);{FROZEN 3.0}{Adds to len the distance between sets Nanc and N}		var			ctype, ir, itor, minim, iidis: integer;			lenplus: longint;			ddist: distancetype;			tempset: LargestSetChars;	begin		ctype := TrueTypeOfChar(ic);		if ctype >= usedef then			begin 	{user-defined} 		{Note that no question asked re state overlap because must count if stasis counts > 0}		{Nanc is presumed to be ancestor and N descendant}		{initializing distance at infinity}				minim := infinity;				typeHdl := gettypehdl(ctype);				ddist := typeHdl^^.dist; 		{looking through all elements in sets above and below to find shortest path between them}				for ir := 0 to maxLg(Nanc) do					for itor := 0 to maxLg(N) do						begin							if (ir in Nanc) and (itor in N) then								begin									iidis := ddist[ir, itor];									if GenLessThan(iidis, minim) then										minim := iidis;								end;						end;				len := addGenDist(len, minim);			end		else if Nanc * N = [] then  {if overlap then no distance; otherwise calculate}			begin				if ctype = unordered then					len := len + 1  {if unordered and sets don't overlap, only one step}				else if ctype = fisher then					begin						NewError(384, ic);					end				else  {ordered & irreversible& dollo}					begin						tempset := OrdOpLargest(Nanc, N, len);						if (ctype = irreversible) then  {here if anc is entirely above desc then give error}							if minLg(Nanc) > maxLg(N) then								NewError(20, ic);					end;			end;	end;{-----------------------------------------------------------------------------}	procedure AddDistOneToTwo (N, Na, Nb: Largestsetchars; ic: integer; var len: longint);{FROZEN 3.0}{Adds to len the distance between set N and sets Na & Nb}	begin		AddDistBetweenSets(N, Na, ic, len);		AddDistBetweenSets(N, Nb, ic, len);	end;{-----------------------------------------------------------------------------}	procedure AddDistOneToMany (N: Nptr; ic: integer; var len: longint);{FROZEN 3.0}{Adds distance between current N^.down and downsets of all nodes above participating in}{polytomy.}{Used only in CalcTraced when N if fixed}		procedure AddDistToNode (pN: Nptr);		begin			if not pN^.null then				AddDistBetweenSets(N^.down, pn^.down, ic, len)			else if NodeIsInternal(pN) then				begin					AddDistToNode(pN^.rt);					AddDistToNode(PN^.lf);				end;		end;	begin		if NodeIsInternal(N) then			begin				AddDistToNode(N^.rt);				AddDistToNode(N^.lf);			end;	end;{==================================================================}{----------------- SPECIFIC-USE STATE SET OPERATIONS ----------------------}{These are used in CalcTraced and Calc to perform triple combinations, downpass with fixanced, and}{so on.  They were separated from those units so as to not duplicate their code in both CalcTraced and}{Calc.}	procedure TripleCombineCore (var Nfinalsts: largestsetchars; Nlfdown, Nrtdown, Nup, Nancfinal: largestsetchars; ictype: integer);{FROZEN 3.0}{Performs combination of left, right, and up states into final states }{for unordered, ordered, irreversible and fisher characters.}{Dollo characters are not deal with here.}{Assumed that node is NOT ROOT.}{Note: Nup is used for unordered and ordered; Nancfinal is used for irrev and fisher.}{Used in CalcUtil: TripleFixancedbyUncertain, CalcTraced: TripleInternalGutsTraced, and Calc:  TripleInternalNotSimple}		var			Nfinal: largestsetchars;	begin		if (ictype <= ordered) then			begin  {============================ UNORDERED & ORDERED=====}		{The final state set calculation for unord & ord characters}		{for dichotomous nodes.  First takes intersection of three surrounding nodes}		{(Nlfdown, Nrtdown for preference of descendants, and Nup for}		{preference of N's ancestor)}				Nfinal := Nlfdown * Nrtdown * Nup;  {intersect of 3 st sets}			{If intersection is non-empty use it; otherwise take unions etc.}				if Nfinal = [] then					begin						if ictype = unordered then							begin					{Use any states occurring in 2 of 3 sets}								Nfinal := Nrtdown * Nup + Nlfdown * Nup + Nlfdown * Nrtdown;					{if none then take union of all three}								if Nfinal = [] then									Nfinal := Nlfdown + Nrtdown + Nup;							end						else  	{for ordered chars use TripleOrdOp}							Nfinal := TripleOrdOpLargest(Nlfdown, Nrtdown, Nup);					end;			end  {ordered/unordered}		else	{============================ IRREVERSIBLE/Fisher=====}			begin				Nfinal := TripleIrrevOpLargest(Nlfdown, Nrtdown, NancFinal);				if Nfinal = [] then  {this happens only if irreversibility is violated}					Nfinal := [minlg(TripleOrdOpLargest(Nlfdown, Nrtdown, NancFinal))];			end;		Nfinalsts := Nfinal;	end;{------------------------------------------------------}	procedure TripleFixancedbyUncertain (var Nfinalsts: largestsetchars; Notfixancdown, FixancDown, NancPref: largestsetchars; ictype: integer);{FROZEN 3.0}{Used for final assignment of states to ancestral node fixanced upon by terminal}{with uncertain states.  The states above and below it are therefore allowed to influence the}{fixanced node's states.  Note: also used for Fisher FixancedByPolymorphic}{Unordered, ordered: The preference above and below is first estimated, then the state}{among the uncertain possibilities for the fixanced is chosen that deviates least from the }{above/below preference, i.e., those states in fixanced closest to preference }{Irreversible: The preference above and below may not contain}{Fisher:  recall that fisher are reconstructed as if not fixanced, i.e. the stratigraphic character}{is allowed to take states on fixanced node other than those observed if it allows shorter distance}{or avoids violating irreversiblity, but then on counting the fact that this is fixanced is considered}{in seeing if some strata could be accounted for by observed taxa}{Used in CalcTraced: TripleInternalGutsTraced and Calc:  TripleInternalNotSimple}		var			Nfinal: largestsetchars;			lenpl: longint;			tempset, oldFixancDown, useancstates: largestsetchars;			ir, highestbeforegap: integer;	begin		if ictype > unordered then {ordered, irreversible, fisher}			begin				oldfixancdown := fixancdown;				FixancDown := SpanLg(FixancDown); {span done because fixancdown is passed as original taxon states}			end;		Fixancdown := ZeroHighbitsLG(fixancdown);		case ictype of			unordered, ordered: 				begin		{find preference among 2 above & below}					lenpl := 0;{place in tempset what would be best from three sides, as if fixanced terminal were not actually terminal.}{Note that NancPref is Nupst}					TripleCombineCore(tempset, NotFixancdown, FixancDown, NancPref, NancPref, ictype);{Note: used to have just double stsetop of Notfixanc and NancPref and then see which of FixancDown were closest,}{but need to have Fixancdown itself involved so it can say its own prefs from the beginning, e.g. ladder}{1, 0, 1/2, 0 with 1/2 fixed as ancestor} {Then choose states in fixancdown best agreeing with preferences from all around}					Nfinal := ClosestinAtoB(FixancDown, tempset, ictype);				end;			irreversible: 				begin {finds preference among all 3 then for irreversible chars selects those allowed by fixanced}					Nfinal := TripleIrrevOpLargest(FixancDown, NotfixancDown, NancPref);					Nfinal := Nfinal * fixancdown; {enforce fact that fixanced!!!}					if Nfinal = [] then  {this happens only if irreversibility is violated}						Nfinal := [minlg(TripleOrdOpLargest(FixancDown, NotfixancDown, NancPref))];				end;			fisher: 				begin {finds preference among all 3 then  selects those allowed by fixanced}					useancstates := NancPref;					if UCL in Oldfixancdown then{if fisher had been uncertain, then could take values up to first gap in its states}						begin							for ir := minlg(Oldfixancdown) to maxlg(Oldfixancdown) do								begin									if ir in oldfixancdown then										highestbeforegap := ir									else										leave;								end;							if highestbeforegap > minLg(NancPref) then								useancstates := spanLg(NancPref + [IntegerMin(highestbeforegap, maxlg(Notfixancdown))])							else								useancstates := spanLg(NancPref);						end					else if MultipleStatesLg(oldfixancdown) then{if fisher had been polymorphic, need to allow it to take higher values by saying NancPref could go as high as Notfixancdown}						useancstates := spanLg(NancPref + [maxlg(Notfixancdown)]);					Nfinal := TripleIrrevOpLargest(FixancDown, NotfixancDown, useancstates);					if Nfinal = [] then  {this happens only if irreversibility is violated}						Nfinal := [minlg(TripleOrdOpLargest(FixancDown, NotfixancDown, NancPref))];				end;			otherwise				;		end;		Nfinalsts := Nfinal;	end;{------------------------------------------------------}	procedure TerminalFilterCore (var Nfinalsts: largestsetchars; PrefBelow, taxonsts: largestsetchars; ictype: integer);{FROZEN 3.0}{When terminal taxon has missing data or multiple states (polymorphic or uncertain) then}{its final state is adjusted using preferences from below}{NOTE: if PrefBelow is passed with bit FTl added, signifies Upst (used only if softpoly)}{ otherwise PrefBelow is notnullanc final sts}{ONLY for unordered, ordered, irreversible, fisher, and DOLLO is MISSING}{Used by CalcTraced: TripleTerminalGutsTraced and Calc: TripleTerminalNotSimple}{FOR CONSISTENCY need to change also TerminalTripleASM and TerminalOrdEquiv, TerminalUnordEquiv}		var			minL, maxL: integer;			Nfinal: largestsetchars;			lenpl: longint;			wasuncertain: boolean;			wasupst: boolean;	begin		Nfinal := Nfinalsts;		lenpl := 0;  {dummy variable to absorb length increase}		if FTl in PrefBelow then			begin				wasupst := true;				PrefBelow := Prefbelow - [FTl];			end		else			wasupst := false;		if MSL in taxonsts then	{if missing data, state assigned}			Nfinal := PrefBelow		else if ictype < dollo then {not missing; unordered, ordered, irrev, fisher}			begin				if MultipleStatesLg(taxonsts) then					begin  {Note that Nfinal gets adjusted for polymorphic and uncertain}						wasuncertain := ucl in taxonsts;						taxonsts := ZeroHighBitsLG(taxonsts);						if ictype = unordered then {===UNORDERED====}							begin								if wasupst then   {here upst passed, thus use normal combining}									begin										Nfinal := taxonsts * PrefBelow;										if Nfinal = [] then											Nfinal := taxonsts + PrefBelow;									end								else if (PrefBelow <= taxonsts) then 		{anc sts passed, thus use special combining}									Nfinal := PrefBelow  {use below if a subset}								else  {if there are any states below not in taxonsts, any in taxonsts allowed}									if wasuncertain then										Nfinal := taxonsts  {convention that UC unordered only allows observed states}									else										Nfinal := taxonsts + PrefBelow; {polymorphic clearly allows unobserved as equally parsimonious}							end						else {===ORDERED, IRREV, FISHER ====}							begin								MaxMinLg(taxonsts, minL, maxL);								if not wasuncertain & (ictype in [irreversible, fisher]) then									Nfinal := [minL] {if polymorphic irrev use minimum}								else {otherwise choose states closest to those below}									Nfinal := closestinAtoB([minL..maxL], PrefBelow, ictype);							end;					end; {uncertain; otherwise not touched}			end; {unord, ord, irrev, fisher}		Nfinalsts := Nfinal;	end;{------------------------------------------------------}	procedure CombineFixancedDown (var Ndown: largestsetchars; Nfixanceddown, NNotfixanceddown, Nfixtaxonsts: Largestsetchars; var chl: longint; ic: integer; N: Nptr; traced: boolean);{FROZEN 3.0}{Assigns downstates to internal node fixanced by terminal.  The states assigned are just the observed}{states in the terminal taxon, unless the taxon's state is missing, or uncertain.  Also irreversible must be adjusted}{and fisher is special case which avoids treatment as fixanced.}{Used in CalcTraced: DownFixancedTraced and Calc: DownFixanced }		var			minL, maxL: integer;			ictype: integer;			chlrecord: longint;			tempset: largestsetchars;	begin{Fixanced terminal with missing data is transparent, allowing states to pass through it;}{ fixanced terminal with uncertain data is translucent, choosing those states}{in the filter (Nfixanced^.down) which come from or are closest to those of the }{nonfixanced descendant;}{Fixanced terminal with polymorphic or monomorphic data are opaque}		ictype := typeofchar(ic);		if MSl in Nfixtaxonsts then  {states of terminal are missing, so just pull down sister's states}			Ndown := NNotFixanceddown		else if ictype = fisher then {fisher characters treated as if notfixanced for sake of reconstruction}			stSetOpLargest(Ndown, NNotFixanceddown, NFixanceddown, fisher, chl)		else			begin				if UCl in nfixtaxonsts then {fixanced terminal has uncertain state}					begin						case ictype of							unordered: 								begin					{use Nfixanced^.down as filter against NNotFixanced^.down}									Ndown := NFixanceddown * NNotFixanceddown;					{if filter catches nothing, go with Nfixanced^.down alone}									if Ndown = [] then										begin											Ndown := NFixanceddown;											chl := chl + 1;  {increment length for cost between fixanced set and set above}										end;								end;							dollo: 								begin									Ndown := NFixanceddown; {pull states down from terminal fixanced}									NewError(31, ic); {fixanc and dollo illegal}								end;							ordered, irreversible:   {fisher treated as notfixanc for reconstruction}								begin					{use Nfixanced^.down as filter against NNotFixanced^.down}					{if filter catches nothing, choose state in Nfixanced^.down closest to in notfixanced}									Ndown := ClosestInAtoB(Nfixanceddown, NNotFixanceddown, ordered);									AddDistBetweenSets(Ndown, NNotFixanceddown, ic, chL);								end;							otherwise								;						end;					end				else  {not uncertain, therefore polymorphic or monomorphic}					begin						if (ictype = irreversible) then							Ndown := SpanLg(Nfixtaxonsts)				{for irreversible characters need to reset states to full range}				{of those observed in terminal taxon (recall that if was polymorphic, }				{would have only placed minimum in terminal's downstate.}						else							Ndown := NFixanceddown; {other types just pull states down from terminal fixanced}						AddDistBetweenSets(Ndown, NNotFixanceddown, ic, chL);					end;			end;	end;end.