unit Recode;{ееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit,		 QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		 Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, 		 EventUtil, GenUtil, UtilLibInterface, SetLibInterface,   StrUtil, BoxUtil, TypeUtil, TaxonCHUtil, 		 SymbolsNames, CharUtil, SetStates, TreeUtil, LinkUtil, SpreadUtil, DrawSpread, StatesWindow, 		 ScrollSpread, EditControl, EditorUndo;	procedure DoRecode;{ееееееееееееееееееееее}implementation {е$S Recode}	type		recodetype = array[0..27] of integer; {Note: this is absmaxnumstates plus 1}	var		lnht, fttop, dotcomp, dotwhite, dotto: integer;		rcarray: recodetype;		{stores, for each state ir of the 26 possible states 0 through 25 and gap and missing}		{to what state ir will be recoded; thus rcarray[0] is the state to which 0 will be recoded.}		statesInChar: largestsetchars;  {states observed in character if single; or 0 to maxstate if multiple chars}		fromleft, toleft: integer;  {position of columns in dialog box}		istart, iend: integer;   {first and last characters to be recoded}		RecodeElements: integer;    {number of states/gap/missing to which things can be recoded;   equal to  maxstate+2}{-----------------------------------------------------------------------------}{#################  RECODING  ######################}{This unit deals with the Recode dialog box for recoding characters.  }{-----------------------------------------------------------------------------}	procedure ReDrawRecodeLines (notst: integer);		var			ir: integer;	begin		for ir := 0 to RecodeElements do			if (ir <> notst) and ((ir in StatesInChar) or (ir > maxstate)) then				begin					MoveTo(fromleft + lnht + 3 + dotwhite, fttop + ir * lnht + lnht div 2 + dotcomp);					LineTo(toleft + lnht div 2 + dotto, fttop + rcarray[ir] * lnht + lnht div 2 + dotcomp)				end;	end;{-----------------------------------------------------------------------------}	procedure DrawRecode (theDialog: DialogPtr; itemNo: INTEGER);		var			c: char;			ht, htname, vt, j: integer;			namesrect: rect;			oldClip: RgnHandle;	begin		oldClip := NewRgn;		FrameButton(theDialog, 1);		MoveTo(fromleft - 2, fttop - 7);		Textfont(1);		textsize(9);		DrawString('Old');		ht := fromleft + 5;		htname := 10;		setrect(namesrect, htname, fttop, ht - 10, 400);		vt := fttop + lnht - 3;		for j := 0 to maxstate do			begin				if j in StatesInChar then					begin						if istart = iend then							begin								moveto(htname, vt);								GetClip(oldclip);								ClipRect(namesrect);								Drawstring(charStatename(istart, j));								setclip(oldclip);							end;						moveto(ht, vt);						DrawChar(CharOfNum(j));						Drawchar('е');					end;				vt := vt + lnht;			end;		Moveto(ht, vt);		if missing = ' ' then			DrawChar('?')		else			DrawChar(missing);		DrawChar('е');		vt := vt + lnht;		Moveto(ht, vt);		if gap = UndefinedGap then			DrawChar('-')		else			DrawChar(gap);		DrawChar('е');		MoveTo(toleft + 2, fttop - 7);		DrawString('New');		ht := toleft + 4;		vt := fttop + lnht - 3;		moveto(ht, vt);		for j := 0 to maxstate do			begin				Drawstring(' е');				DrawChar(CharOfNum(j));				vt := vt + lnht;				Moveto(ht, vt);			end;		drawstring(' е');		if missing = ' ' then			DrawChar('?')		else			DrawChar(missing);		vt := vt + lnht;		Moveto(ht, vt);		drawstring(' е');		if gap = UndefinedGap then			DrawChar('-')		else			DrawChar(gap);		ReDrawRecodeLines(-1);		ZapRegion(oldClip);	end;{----------------------------------------------------------------------------}	function RecodeFilter (theDialog: DialogPtr; var Event: EventRecord; var localItemHit: INTEGER): BOOLEAN;{tracks mouse and draws line from moving mouse}		type			fromtotype = array[0..27] of rect; {Note: 27 is absmaxnumstatesplus 1}{already defined for staterects?}		var			MouseLoc: Point;			WindoLoc, MyControl, charcode, itemtype: integer;			okrect: rect;			tempH: handle;			theChar: char;			ir, fromst, tost: integer;			wh, m1, m2: point;			Anyfrom, anyto: rect;			fromrect, torect: fromtotype;	begin		Setrect(Anyfrom, fromleft, fttop, fromleft + lnht + 8, fttop + (maxstbit + 3) * lnht);		Setrect(Anyto, toleft, fttop, toleft + lnht + 8, fttop + (maxstbit + 3) * lnht);{    Framerect(Anyfrom);}{    Framerect(anyto);}		for ir := 0 to RecodeElements do			begin				Setrect(fromrect[ir], anyfrom.left, anyfrom.top + ir * lnht, anyfrom.right, anyfrom.top + ir * lnht + lnht);				Setrect(torect[ir], anyto.left, anyto.top + ir * lnht, anyto.right, anyto.top + ir * lnht + lnht);{    framerect(fromrect[ir]);}{    framerect(torect[ir]);}			end;		MouseLoc := Event.Where;		WindoLoc := FindWindow(MouseLoc, Whichwindow);		RecodeFilter := FALSE;		if (Event.what = keyDown) and HitReturn(Event) then			begin				RecodeFilter := true;				localItemHit := PressButton(theDialog, 1);			end;		if (Event.what = mouseDown) then			begin				GlobalToLocal(Event.where);				wh := Event.where;				if ptinrect(wh, anyfrom) then					begin						for ir := 0 to RecodeElements do							if ptinrect(wh, fromrect[ir]) then								fromst := ir;						if (fromst in StatesInChar) or (fromst > maxstate) then							begin								setcursH(diamond);								wh.h := fromrect[fromst].left + lnht + 3;								wh.v := fromrect[fromst].top + lnht div 2;								GetMouse(m2);								penpat(QDBlack);								penmode(patXOR);								moveto(torect[rcarray[fromst]].left + lnht div 2 + dotto, torect[rcarray[fromst]].top + lnht div 2 + dotcomp);								lineTO(wh.h + dotwhite, wh.v + dotcomp);								penmode(patcopy);								RedrawRecodelines(fromst);								penmode(patXOR);								moveTO(wh.h + dotwhite, wh.v + dotcomp);								LINETO(m2.h, m2.v);								repeat									repeat										GETMOUSE(m1);									until (m2.h <> m1.h) or (m2.v <> m1.v) or not BUTTON;									moveto(m2.h, m2.v);									LINETO(wh.h + dotwhite, wh.v + dotcomp);									if button then										LINETO(m1.h, m1.v);									m2 := m1;									CallWaitNextEventForDrawing;								until not BUTTON;								penmode(patcopy);								if ptinrect(m1, Anyto) then									begin										for ir := 0 to RecodeElements do											if ptinrect(m1, torect[ir]) then												tost := ir;										moveto(wh.h + dotwhite, wh.v + dotcomp);										lineto(torect[tost].left + lnht div 2 + dotto, torect[tost].top + lnht div 2 + dotcomp);										rcarray[fromst] := tost;									end								else									Lineto(torect[rcarray[fromst]].left + lnht div 2 + dotto, torect[rcarray[fromst]].top + lnht div 2 + dotcomp);							end;						SetCursorToArrow;					end;				RecodeFilter := false;				localItemHit := NotinDialog;				LocaltoGlobal(Event.where);			end;	end;{-----------------------------------------------------------------------------}	function RCSet (ir: integer): LargestSetChars;{FROZEN 3.0}{returns new set corresponding to recode element ir.  Usually just returns [ir], except if ir}{is greater then maxstate, returns either missing or gap set}	begin		if rcarray[ir] <= maxstate then			RCSet := [rcarray[ir]]		else if rcarray[ir] = maxstate + 1 then			RCSet := [MSl]		else if rcarray[ir] = maxstate + 2 then			RCSet := [MSl, GAl];	end;{-----------------------------------------------------------------------------}	procedure InvalidateFootRect; {v3.01:}		var			tport: WindowPtr;	begin		if editorOpen then			begin				genericGetPort(tport);				genericSetPort(editorWindow);				EraseRect(editorFootNoteRect);				InvalidateWindowRect(editorWindow,editorFootNoteRect,false);				genericSetPort(tport);			end;	end;{-----------------------------------------------------------------------------}	procedure DoRecode;{FROZEN 3.0 from Wayne's point of view}		type			strarray = array[0..31] of str255; {Note: 27 is absmaxnumstates plus 1}		var			theDialog: DialogPtr;			tempH: Handle;			box: RECT;			itemtype: integer;			tempP: WindowPtr;			it, ir, irr, ic: integer;			ds: str255;			SCTL, SCBR: point;			newset, oldset: largestsetchars;			goahead, remains: boolean;			newnames: strarray;			LegalSet, assignSet: LargestSetChars;			recodeictrouble: boolean;			localItemHit: integer;			UserItemUProcP: UniversalProcPtr;			DLOGFilterUPP: UniversalProcPtr;		procedure AddRecodedToSet (var newset: largestsetchars; ir: integer);		begin			if rcarray[ir] in LegalSet then				newset := newset + RCSet(ir)			else if not recodeictrouble then				begin					recodeictrouble := true;					NewError(85, ic);				end;		end;	begin		RecodeElements := maxstate + 2;		if maxbit = 15 then  {two byte data}			begin				lnht := 15;				fttop := 52;				dotcomp := 0;				dotwhite := 0;				dotto := -2;			end		else			begin  {four byte data}				lnht := 8;				fttop := 44;				dotcomp := -3;				dotwhite := 6;				dotto := 1;			end;		if dirtymaxst then			ReCalcMaxstAndStates(1,numchars);		for ir := 0 to RecodeElements do			rcarray[ir] := ir;		if (IsEditorWindow(frontwindow)) and editorSelected then			begin				istart := CharOfCell(editorSelectionTopLeft);				iend := CharOfCell(editorSelectionBotRight);			end		else if treeopen and (traceshown = traceDiscrete) then  {note: currently not allowed}			begin				istart := i;				iend := i;			end		else			begin				istart := 1;				iend := 1;			end;		if istart <= 0 then			begin				istart := 1;				iend := 1;			end;		fromleft := 55;		toleft := 154;		if istart = iend then			begin				for ir := 0 to maxstate do					begin						if CharStateName(istart, ir) <> '' then							begin								fromleft := 95;								toleft := 194;							end;					end;				StatesInChar := CharStatesLargest(istart);				ds := AvailCharName(istart);			end		else			begin				StatesInChar := [0..maxstate];				ds := concat('characters ', StringFromNum(istart), ' to ', StringFromNum(iend));			end;		Paramtext(ds, '', '', '');		if maxbit = 15 then			StartDLOG(330, theDialog, tempP)		else			StartDLOG(560, theDialog, tempP);		myShowDialog(theDialog);		SetRect(box, 1, 1, 2, 2);		UserItemUProcP := MyNewUserItemUPP(@DrawRecode);  		tempH := Handle(UserItemUProcP);		SetDialogItem(theDialog, 5, UserItem, tempH, box);		DLOGFilterUPP := MyNewModalFilterUPP(@RecodeFilter);  		repeat			myModalDialog(DLOGFilterUPP, localItemHit);			if localItemHit = 3 then				begin					penmode(patBIC);					RedrawRecodelines(-1);  {erase old}					for ir := 0 to RecodeElements do						rcarray[ir] := ir;					penmode(patcopy);					RedrawRecodelines(-1); {put new}				end;		until localItemHit in [1, 2];		MyDisposeUserItemUPP(UserItemUProcP);		MyDisposeModalFilterUPP(DLOGFilterUPP);		EndDLOG(theDialog, tempP);		if localItemHit = OK then			begin				goahead := false;				for ir := 0 to RecodeElements do					if rcarray[ir] <> ir then  {something has been changed}						goahead := true;				if goahead then					begin						if not StoreSelectedCellBlockForUndo(false,false,true) then Exit(DoRecode);						SetCursor(clockCursor);						for ic := istart to iend do							begin								LegalSet := GetTypeHdl(TrueTypeOfChar(ic))^^.setdefined * [0..RecodeElements] + [maxstate + 1, maxstate + 2];								recodeictrouble := false;								for it := 1 to numtaxa do  {cycle through the taxa recoding each's state in character ic}									begin										newset := [];										oldset := GetTaxonStsLargest(it, ic);										for ir := 0 to maxstate do											if ir in oldset then												AddRecodedToSet(newset, ir);  {Recode and add to state set}										if GAl in oldset then											AddRecodedToSet(newset, maxstate + 2)										else if MSl in oldset then											AddRecodedToSet(newset, maxstate + 1);										if not recodeictrouble then   {now assign new taxonsts; if recodeictrouble then do not make this assignment}											begin												if newset * [0..absmaxstate] <> [] then  {it has some lower elements}													newset := newset - [MSl, GAl]   {therefore clear out any higher elements}									{that may have arisen,eg, if there is a cell 0&1 and the user has choosen to set 1 to ?}												else if newset = [] then													newset := [MSl];												if nucleotides then													assignset := newset + ([25..31] - [MSl, GAl]) * oldset {use this to retain old high bits}												else													assignset := newset + ([26..31] - [MSl, GAl]) * oldset;  {use this to retain old high bits}												if (UCl in assignset) and (Cardlg(Zerohighbitslg(assignset)) <= 1) then													assignset := assignset - [ucl];												settaxonstsLargestFoot(it, ic, assignset);  {need Foot to preserve footnote bits}											end										else											recodeictrouble := false;									end;  {for i=1to numtaxa}								if not molecular then									begin										for ir := 0 to RecodeElements do{fix up names of character states}											newnames[ir] := '';										for ir := 0 to maxstate do											if rcarray[ir] <= maxstate then												begin													if CharStatename(ic, ir) <> '' then														if (length(newnames[rcarray[ir]]) > 0) then															newnames[rcarray[ir]] := concat(newnames[rcarray[ir]], '-', CharStateName(ic, ir))														else															newnames[rcarray[ir]] := CharStateName(ic, ir);												end;						{This section is responsible for setting the state names.  As one of its functions it also sets}						{any newly unnamed states to NoName (the empty name designator)}										for ir := 0 to maxstate do  {cycle through new states}											begin												remains := false;												for irr := 0 to maxstate do  {irr is old state}													if rcarray[irr] = ir then   {then irr will be recoded to ir}														remains := true;												if not remains then   {then the new state ir is not going to exist in the recoded form}													newnames[ir] := NoName;  {so empty state name}												AddDotsToStateNames(ic);												SetCharStateName(ic, ir, newnames[ir])											end;									end;								if not foottexton then   {v3.01:}									InvalidateFootRect;							end;  {ic }						datachanged := true;						ReCalcMaxstAndStates(1,numchars);  {do full recalc in case MOS changed etc.}						if editorOpen then							begin								genericSetPort(editorWindow);								if not editorTransposed then									SetEWClip(horscroll)								else									SetEWClip(vertscroll);								SetClip(EWClip);								EraseRect(editorSelectionRect);								InvalidateWindowRect(editorWindow,editorSelectionRect,false);								SetEWClip(noscroll);								SetClip(EWClip);								genericSetPort(tempP);							end;					end;			end;	end;end.