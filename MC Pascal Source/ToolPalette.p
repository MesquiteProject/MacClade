unit ToolPalette;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, 		Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, 		Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, 		EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, TreeUtil, FlashUtil;	function SplitMultiActive(whichTool: integer): boolean;	procedure WritePalMessageB (whichToolPalette: integer; str: str255);	function PaletteString (whichToolPalette, toolT: Integer; N: Nptr): str255;	function UseOptionTool (whichToolPalette, toolT: Integer; opt: boolean): boolean;	procedure SimpleDropTool (whichToolPalette, toolT: Integer; left, top: integer; mode: integer);	procedure CheckToolKit (whichToolPalette, toolT: Integer);	procedure DropTool (whichToolPalette, toolT: Integer);	procedure DimTool (whichToolPalette, toolT: Integer);	procedure InvalidateToolPaletteMessage (whichToolPalette: Integer);	procedure InvalidateTool (whichToolPalette, toolT: Integer);	procedure SetTool (whichToolPalette, toolT: Integer);	procedure CheckToolValidity(whichToolPalette:integer);		procedure DrawPaletteTitleBar(whichToolPalette: integer);	procedure DrawPalette(whichToolPalette: integer);	procedure AdjustToolBoxes(whichToolPalette: integer);	procedure CalculateNumPaletteMessageLines(whichToolPalette:integer);	procedure GetToolBoxArrangment(whichToolPalette: integer; height, width: integer; var horizBoxes, vertBoxes: integer);	procedure ReSizeToolPalette(whichToolPalette: integer; horizBoxes,vertBoxes: integer);{еееееееееееееееееееееее}implementation {е$S BoxUtil}	const	paletteEdge = 2;{-----------------------------------------------------------------------------}	function SplitMultiActive(whichTool: integer): boolean;	begin		SplitMultiActive := editorOpen & (splitTaxonEnd<>0) & (splitTaxonStart<>0) & (splitCharacter<>0) & (whichTool=splitBlockT) & UseOptionTool(editorTools,splitBlockT,OptionEvent(Event));	end;{-----------------------------------------------------------------------------}	procedure ErasePaletteBox(box: rect);	var	oldBack: RGBColor;	begin		SetGrayBackground(oldBack,grayPalest);		EraseRect(box);		SetRGBBackground(oldBack);	end;{-----------------------------------------------------------------------------}	procedure WritePalMessageB (whichToolPalette: integer; str: str255);{writes message into bottom of palette window}		var			B,B2: rect;			oldstate: penstate;			oldClip: RgnHandle;			tPort: WindowPtr;			oldBack: RGBColor;	begin		genericGetPort(tport);		genericSetPort(toolPaletteWindow[whichToolPalette]);		oldClip := newRgn;		GetClip(OldClip);		getpenstate(oldstate);		penNormal;		{Framerect(paletteMessageBox[whichToolPalette]);}		TextFont(TWFont);		TextSize(TWFontSize);		B := paletteMessageBox[whichToolPalette];		B2 := B;		B2.right := WindowPortRect(toolPaletteWindow[whichToolPalette]).right;		Insetrect(B2, 1, 1);		ClipRect(B2);		EraseRect(B2);{Framerect(B2);}		Insetrect(B, 1, 1);		ClipRect(B);		if horizontalTools[whichToolPalette] >= horizontalToolsTextMinimum then			begin				{SetGrayBackground(oldBack,grayPalest);}				if str = '.' then					str := ' ';				TETextBox(Pointer(ord4(@str) + 1), length(str), B, teJustCenter);				{MOVETO(B.left + ((B.right - B.left) - StringWidth(str)) div 2, B.bottom - 2 - ((B.bottom - B.top) - 9) div 2);				DrawString(str);}				{SetRGBBackground(oldBack);}			end;		Setpenstate(oldstate);		SetClip(OldClip);		ZapRegion(oldClip);		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	function UseOptionTool (whichToolPalette, toolT: Integer; opt: boolean): boolean;	var useOptTool: boolean;	begin		useOptTool := opt;		if whichToolPalette = treeTools then			case toolT of				rerootT: 					useOptTool :=  (opt = rerootToolRootsDrawR);				scissorsT: 					useOptTool := (opt = scissorsCutAbove);				collapseallT: 					useOptTool := opt = collapseAllCollapsesAbove;				swapT: 					useOptTool := opt = swapAbove;				ladderT: 					useOptTool := (opt = ladderizeRight);				paintT: 					useOptTool := (traceshown = traceDiscrete)  & (opt <> paintToolTriesAllStates);				{queryT:					useOptTool := (traceshown = traceAllChanges)  & (summaryView=asticks) & (opt <> queryToolTracesCharacter);				traceTickT:					useOptTool := (traceshown = traceAllChanges)  & (summaryView=asticks) & (opt <> traceTickToolTemporary);}				otherwise 					useOptTool := opt;			end 		else			case toolT of				editorScissorsT:					useOptTool := opt = editorScissorsShiftsToStart;				selectToEndT:					useOptTool := opt = ((selectToEndMode=selectToLastCharacterMode)| (selectToEndMode=selectToLastTaxonMode));				closeGapsT:					useOptTool := opt = closeGapsTowardEnd;				editorSortT:					useOptTool := opt = editorSortAscending;				popUpStatesT:					useOptTool := opt = popUpEnterStates;				splitBlockT:					useOptTool := opt = not splitBlockMultiSequence;				otherwise 					useOptTool := opt;			end;		UseOptionTool := useOptTool & tool^[whichToolPalette,toolT].hasOptionCurs;	end;{-----------------------------------------------------------------------------}	function PaletteString (whichToolPalette, toolT: Integer; N: Nptr): str255;{This is passed a tool name and a Nptr, and it returns the appropriate string for the Palette and Tool Menu}{N is the node associated with the cursor; if cursor is not over a branch, then N= nil}{notice that OptionIsDown is a global boolean that is updated before this is called}		var			ds: str255;	begin		ds := '';		if whichToolPalette = treeTools then			case toolT of				rerootT: 					if N <> screenR then						if OptionIsDown = rerootToolRootsDrawR then							ds := 'Reroot in Clade'						else if R = screenR then							ds := 'Reroot Tree'						else							ds := 'Reroot Clade';				ancT: 					if N = nil then						ds := 'Make Ancestral'					else if N^.fixanc then						ds := 'Make Terminal'					else if (NodeIsTerminal(N)) & not IsterminalFixanc(sis(N)) then						ds := 'Make Ancestral';				scissorsT: 					if (N <> nil) & (N = R) then						ds := ''					else if OptionIsDown = scissorsCutAbove then						if (N <> nil) & (NodeIsTerminal(N)) then							ds := 'Exclude Below Taxon'						else							ds := 'Exclude Below Clade'					else if (N <> nil) & (NodeIsTerminal(N)) then						ds := 'Exclude Taxon'					else						ds := 'Exclude Clade';				arrowT: 					if N <> R then						if (storedN <> subR) then							ds := 'Drop Stored Branch'						else if (N = nil) or (N = ScreenR) then							ds := 'Move Branch'						else if (N <> nil) & (NodeIsTerminal(N)) then							ds := 'Move Taxon'						else							ds := 'Move Clade';				collapseT: 					if N <> R then						ds := 'Collapse Branch';				collapseallT: 					if OptionIsDown = collapseAllCollapsesAbove then						ds := 'Collapse Below Clade'					else						ds := 'Collapse Clade';				polyflipT: 					ds := 'Polytomy Exchange';				expandT: 					if (N <> nil) & (N = screenR) & (R <> ScreenR) then						ds := 'Show All Clades'					else if (N <> R) then						ds := 'Expand Clade';				swapT: 					if OptionIsDown = swapAbove then						begin							if (N = nil) | (N <> R) then								ds := 'Search Below';						end					else if (N = nil) | (NodeIsInternal(N)) then						ds := 'Search Above';				evolveSegmentsT:					ds := 'Set Evolve Segments';									rotateT: 					if (N = nil) | (NodeIsInternal(N)) then						ds := 'Rotate Branches';				handT: 					ds := 'Move Tree';				ladderT: 					if (N = nil) | (NodeIsInternal(N)) then						if OptionIsDown = ladderizeRight then							ds := 'Rotate to Lean Left'						else							ds := 'Rotate to Lean Right';				paintT: 					if (traceshown = traceDiscrete) then {and (brushset <> [])}						begin							if OptionIsDown <> paintToolTriesAllStates then								ds := 'Try All Fixes'							else								ds := 'Fix States'						end					else						ds := '';				treePictureT: 					if AnyFeet(footpict) then						ds := 'Show Picture'					else						ds := '';				statsTestT: 					if (traceshown = traceDiscrete) & ((N = nil) | (NodeIsInternal(N))) then						ds := 'Test Correlation';				queryT: 					if (traceshown = traceAllStates) or (traceshown = traceDiscrete) then						ds := 'List States'					else if (traceshown = traceAllChanges) then						if (summaryview=asticks) then 							ds := 'Show Character Info.'						else							ds := 'List Changes';				treeWandT: 					ds := 'Select in List Window';				traceTickT: 					ds := 'Trace Character';				turpentineT: 					if fixon and (traceshown = traceDiscrete) then						ds := 'Remove Fix'					else						ds := '';				otherwise					ds := '';			end 		else			case toolT of				editorArrowT: 					ds := 'Standard';				magicWandT:					ds := 'Selection Wand';				blockMoveT:					ds := 'Block Mover';				splitBlockT:					ds := 'Block Splitter';				{splitMultiBlockT:					ds := 'MultiSequence Block Splitter';}				editorScissorsT:					if OptionIsDown = editorScissorsShiftsToStart then						ds := 'Excise, Shift Up'					else						ds := 'Excise';				autoAlignT:					ds := 'Pairwise Alignment';				splitBlockOtherT:					ds := 'Split Others';				selectedBlockMoveT:					ds := 'Selected Block Mover';				closeGapsT:					ds := 'Close Gaps by Moving Selected';				editorSelectionT:					ds := 'Block Selector';				selectToEndT:					case selectToEndMode of							selectToLastCharacterMode:								if OptionIsDown then									ds := 'Select To First Char'								else									ds := 'Select To Last Char';							selectToFirstCharacterMode:								if OptionIsDown then									ds := 'Select To Last Char'								else									ds := 'Select To First Char';							selectToLastTaxonMode:								if OptionIsDown then									ds := 'Select To First Taxon'								else									ds := 'Select To Last Taxon';							selectToFirstTaxonMode:								if OptionIsDown then									ds := 'Select To Last Taxon'								else									ds := 'Select To First Taxon';						otherwise;					end;				stampPasteT:					ds := 'Stamp Clipboard';				showPictureT:					if AnyFeet(footpict) then						ds := 'Show Picture'					else						ds := '';				editorSortT:					if OptionIsDown <> editorSortAscending then						ds := 'Sort Ascending'					else						ds := 'Sort Descending';				editorBucketT:					ds := 'Fill States';				editorPaintBrushT:					ds := 'Paint States';				eyedropperT:					ds := 'Choose State';				popUpStatesT:					if OptionIsDown <> popUpEnterStates then						ds := 'Pop-up Data Entry'					else						ds := 'Show Cell Info';				otherwise					ds := '';			end;		PaletteString := ds;	end;{-----------------------------------------------------------------------------}	procedure SimpleDropTool (whichToolPalette, toolT: Integer; left, top: integer; mode: integer);	begin		if (whichToolPalette = editorTools) & (toolT=editorBucketT) & (paintBucketFillCellsWithState<>[]) then			DropCursorID(723,left,top,mode)		{else if (whichToolPalette = editorTools) & (toolT=splitBlockT) & (splitBlockMultiSequence) then			DropCursorID(618,left,top,mode)}		else if UseOptionTool(whichToolPalette,toolT,OptionIsDown) then   {then there is an option cursor associated with tool, and option is down}			DropCursorID(tool^[whichToolPalette,toolT].optionCursID, left, top, mode)		else			DropCursorH(tool^[whichToolPalette,toolT].curs, left, top, mode);  {srcor}	end;{-----------------------------------------------------------------------------}	procedure DimTool (whichToolPalette, toolT: Integer);		var			B: rect;			tport: WindowPtr;	begin		genericGetPort(tport);		genericSetPort(toolPaletteWindow[whichToolPalette]);		B := tool^[whichToolPalette,toolT].R;		InsetRect(B, 2, 2);		DimBox(B);		tool^[whichToolPalette,toolT].enabled := false;		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	procedure InvertTool (whichToolPalette, toolT: Integer);	begin		InsetRect(tool^[whichToolPalette,toolT].R, 1, 1);		InvertRect(tool^[whichToolPalette,toolT].R);		InsetRect(tool^[whichToolPalette,toolT].R, -1, -1);	end;{-----------------------------------------------------------------------------}	procedure CheckToolKit (whichToolPalette, toolT: Integer);{checks to see if various tools should be enabled or disabled}	begin		if whichToolPalette = treeTools then			case toolT of				queryT: 					tool^[whichToolPalette,queryT].enabled := (traceshown = traceAllChanges) or (traceshown = traceAllStates) or (traceshown = traceDiscrete);				traceTickT: 					tool^[whichToolPalette,traceTickT].enabled := TickNamesVisible ;				paintT: 					tool^[whichToolPalette,paintT].enabled := (traceshown = traceDiscrete);				statsTestT: 					if (traceshown = traceDiscrete) then						tool^[whichToolPalette,statsTestT].enabled := (traceshown = traceDiscrete) & (CharMaxstOBS(i) = 1)					else						tool^[whichToolPalette,statsTestT].enabled := false;				handT: 					tool^[whichToolPalette,handT].enabled := (GetControlMaximumLong(hTWScroll) > GetControlMinimumLong(hTWScroll)) or (GetControlMaximumLong(vTWScroll) > GetControlMinimumLong(vTWScroll));				treePictureT: 					tool^[whichToolPalette,treePictureT].enabled := AnyFeet(footPict);				turpentineT: 					tool^[whichToolPalette,turpentineT].enabled := (traceshown = traceDiscrete) and fixon;				{unknownTreeT: 					tool^[whichToolPalette,unknownTreeT].enabled := false;}				otherwise					tool^[whichToolPalette,toolT].enabled := true;			end		else if whichToolPalette = editorTools then			case toolT of				autoAlignT:					tool^[whichToolPalette,toolT].enabled := molecular & not Locked(lockData);				showPictureT: 					tool^[whichToolPalette,showPictureT].enabled := AnyFeet(footPict);				editorArrowT:					tool^[whichToolPalette,toolT].enabled := true;				stampPasteT:					tool^[whichToolPalette,toolT].enabled := CellBlockHasDataOfLegalSize(EWScrapBlockP);				{splitMultiBlockT:					tool^[whichToolPalette,toolT].enabled := false;}			otherwise				tool^[whichToolPalette,toolT].enabled := not Locked(lockData);			end;	end;{-----------------------------------------------------------------------------}	procedure DropTool (whichToolPalette, toolT: Integer);		var			tport: WindowPtr;			pt: Point;	begin		CheckToolKit(whichToolPalette, toolT);		genericGetPort(tport);		genericSetPort(toolPaletteWindow[whichToolPalette]);		{ClipRect(WindowPortRect(toolPaletteWindow[whichToolPalette]));}		{ErasePaletteBox(tool^[whichToolPalette,toolT].R);		FrameRect(tool^[whichToolPalette,toolT].R);}		DrawToolBox(tool^[whichToolPalette,toolT].R,true);		SimpleDropTool(whichToolPalette, toolT, tool^[whichToolPalette,toolT].R.left + 5, tool^[whichToolPalette,toolT].R.top + 5, srcor);		if tool^[whichToolPalette,toolT].hasPopUpMenu then			begin				pt.h := tool^[whichToolPalette,toolT].R.right-9;				pt.v := tool^[whichToolPalette,toolT].R.bottom-6;				DrawSmallTriangle(pt,GrayScale(10,8));			end;		if toolT = currentTool[whichToolPalette] then			InvertTool(whichToolPalette, toolT);		if not tool^[whichToolPalette,toolT].enabled then			DimTool(whichToolPalette, toolT);		if  (toolT=splitBlockT) & not UseOptionTool(editorTools,splitBlockT,OptionEvent(Event)) then			begin				TurnOffFlash;				ZeroSplitFlash;			end;		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	procedure CheckToolValidity(whichToolPalette:integer);		var			oldcurtool: Integer;	begin		if (treeopen & (whichToolPalette = treetools)) | (editorOpen & (whichToolPalette=editorTools)) then			begin				oldCurTool := currentTool[whichToolPalette];				CheckToolKit(whichToolPalette,currentTool[whichToolPalette]);				if not tool^[whichToolPalette,currentTool[whichToolPalette]].enabled then					begin						SetTool(whichToolPalette,arrowT);						DropTool(whichToolPalette,oldcurtool);					end;			end;	end;{-----------------------------------------------------------------------------}	procedure InvalidateToolPaletteMessage (whichToolPalette: Integer);	begin		InvalidateWindowRect(toolPaletteWindow[whichToolPalette],paletteMessageBox[whichToolPalette],true);	end;{-----------------------------------------------------------------------------}	procedure InvalidateTool (whichToolPalette, toolT: Integer);	begin		InvalidateWindowRect(toolPaletteWindow[whichToolPalette],tool^[whichToolPalette,toolT].R,true);	end;{$IFC FALSE}{-----------------------------------------------------------------------------}	procedure HiliteTool (whichToolPalette, toolT: Integer; whichmessage: boolean; var B: rect);		var			tport: windowptr;	begin		if tool^[whichToolPalette,toolT].enabled then			begin				if whichmessage then					writepalmessageB(whichToolPalette,tool^[whichToolPalette,toolT].message[0])				else					writepalmessageB(whichToolPalette,tool^[whichToolPalette,toolT].message[1]);				B := tool^[whichToolPalette,toolT].R;			end;	end;{$ENDC}{-----------------------------------------------------------------------------}	procedure SetTool (whichToolPalette, toolT: Integer);{selects tool; sets currentTool[whichToolPalette] to toolT}		var			tport: windowptr;	begin		genericGetPort(tport);		genericSetPort(toolPaletteWindow[whichToolPalette]);		InvertTool(whichToolPalette,currentTool[whichToolPalette]);		if (brushset <> []) & (toolT <> currentTool[whichToolPalette]) & ((currentTool[whichToolPalette] = paintT) | (toolT = paintT)) then			InvalidateWindow(chlegwindow, false);		if currentTool[whichToolPalette]<> toolT then			lastTool[whichToolPalette] := currentTool[whichToolPalette];		currentTool[whichToolPalette] := toolT;		if (whichToolPalette=editorTools) then			if  (toolT=splitBlockT) & UseOptionTool(editorTools,splitBlockT,OptionEvent(Event)) then				TurnOnFlash			else				begin					TurnOffFlash;					ZeroSplitFlash;				end;		InvertTool(whichToolPalette,currentTool[whichToolPalette]);		WritepalMessageB(whichToolPalette,PaletteString(whichToolPalette, toolT, nil));		genericSetPort(tport);	end;{||||||||||||||||||||||||||||||||||||||||||||||||||||||||  Palette Window |||||||||||||||||||||||||||||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	procedure DrawPaletteTitleBar(whichToolPalette: integer);		var			j: integer;			tport: WindowPtr;			box: rect;	begin		genericGetPort(tport);		genericSetPort(toolPaletteWindow[whichToolPalette]);		if isforeground & (IsTreeWindow(frontwindow) | IsEditorWindow(frontWindow)) then			begin				PenPat(QDGray);				for j := 0 to 3 do					begin						moveto(paletteTitleLineWidth, j * 2 + 2);						Lineto(WindowPortRect(toolPaletteWindow[whichToolPalette]).right, j * 2 + 2);					end;				PenPat(QDBlack);			end		else			begin				SetRect(box, 11, 1, WindowPortRect(toolPaletteWindow[whichToolPalette]).right, 9);				EraseRect(box);			end;		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	procedure WriteExtraPaletteMessage (whichToolPalette: integer);		const 			boxSlop=4;		var			B, box: rect;			side, j: integer;			oldstate: penstate;			oldClip: RgnHandle;			ds : str255;	begin		oldClip := newRgn;		GetClip(OldClip);		getpenstate(oldstate);		penNormal;		ds := '';		{Framerect(paletteExtraMessageBox[whichToolPalette]);}		if whichToolPalette = editorTools then			begin				if paintBucketPaint = [] then					begin						ds := concat('Taxon ',StringFromNum(editorPaintReferenceTaxon));					end				else if nucleotides & (SSl in paintBucketPaint) then					begin						paintBucketPaint := paintBucketPaint - [SSl];						SetToCellString(missing, gap, orsep, andsep, @symbols, @ds, nil, paintBucketPaint);						if ds ='A' then							ds := 'a'						else if ds ='C' then							ds := 'c'						else if ds ='G' then							ds := 'g'						else if ds ='T' then							ds := 't';					end				else					begin						//SetToCellString(missing, gap, orsep, andsep, @symbols, @ds, nil, [0]);						SetToCellString(missing, gap, orsep, andsep, @symbols, @ds, nil, paintBucketPaint);					end;			end;		TextFont(TWFont);		TextSize(TWFontSize);		B := paletteExtraMessageBox[whichToolPalette];		Insetrect(B, 1, 1);		ClipRect(B);		EraseRect(B);		box := B;		{InsetRect(box,-1,-1);}		box.right := box.right;		box.left := box.right-StringWidth(ds)-boxSlop*2;		{box.left := box.left+side;		box.right := box.right-side;}		if (editorColorCellsMode=editorColorCellsState) & (paintBucketPaint<>[]) & not (MSl in paintBucketPaint) & ScreenInColor & (sameStateColorsForAllCharacters | molecular) then			begin				if CardLg(paintBucketPaint)>1 then					RGBForeColor(polyMorphColor)				else					RGBForeColor(GetStateSetColor(maxstate+1,paintBucketPaint));				FillBlackRect(box);				RGBForeColor(blackRGB);			end;		FrameRect(box);		MoveTo(box.left+boxSlop, B.bottom - 2 - ((B.bottom - B.top) - 9) div 2);		DrawString(ds);		MoveTo(box.left-StringWidth('Paint:')-2, B.bottom - 2 - ((B.bottom - B.top) - 9) div 2);		{MoveTo(B.left + ((B.right - B.left) - StringWidth(ds)) div 2, B.bottom - 2 - ((B.bottom - B.top) - 9) div 2);}		DrawString('Paint:');		Setpenstate(oldstate);		SetClip(OldClip);		ZapRegion(oldClip);	end;{-----------------------------------------------------------------------------}	function SingleToolBox(whichToolPalette,theToolNumber: integer):rect;	var box: rect;	begin		with box do			begin				if useOldFloatingWindows then					top := theToolNumber div horizontalTools[whichToolPalette] * (toolCellWidth - 1) - 1 + paletteTitleLineWidth				else					top := theToolNumber div horizontalTools[whichToolPalette] * (toolCellWidth - 1) - 1;				bottom := top + toolCellWidth;				left := (horizontalTools[whichToolPalette] - 1 - theToolNumber mod horizontalTools[whichToolPalette]) * (toolCellWidth - 1) - 1;				right := left + toolCellWidth;				if (theToolNumber) mod horizontalTools[whichToolPalette]=0 then right :=  (toolCellWidth -1)* horizontalTools[whichToolPalette];			end;		OffSetRect(box,paletteEdge,paletteEdge);		SingleToolBox := box;	end;{-----------------------------------------------------------------------------}	procedure DrawEmptyBoxes(whichToolPalette: integer);	var j: integer;		box: rect;	begin		for j := numTools[whichToolPalette]+1 to horizontalTools[whichToolPalette]*verticalTools[whichToolPalette]-1 do			begin				box := SingleToolBox(whichToolPalette,j);				DrawToolBox(box,false);			end;	end;{-----------------------------------------------------------------------------}	procedure DrawPalette(whichToolPalette: integer);		var			j: Integer;			tport: WindowPtr;			box: rect;	begin		genericGetPort(tport);						for j := 0 to numTools[whichToolPalette] do			DropTool(whichToolPalette,j);		genericSetPort(toolPaletteWindow[whichToolPalette]);		DrawEmptyBoxes(whichToolPalette);		if useOldFloatingWindows then			begin				SetRect(box, 3, 2, 10, 9);				FrameRect(box);				DrawPaletteTitleBar(whichToolPalette);				FrameRect(paletteGrowBox[whichToolPalette]);				box := PaletteGrowBox[whichToolPalette];				InsetRect(box,3,3);				OffSetRect(box,1,1);				FrameRect(box);				{InsetRect(box,1,1);}				box.right := box.right-1;				box.bottom := box.bottom-1;				OffSetRect(box,-2,-2);				EraseRect(box);				FrameRect(box);			end;		WritePalMessageB(whichToolPalette,PaletteString(whichToolPalette,currentTool[whichToolPalette], nil));		if toolPaletteHasExtraMessage[whichToolPalette] then			WriteExtraPaletteMessage(whichToolPalette);		genericSetPort(tport);		toolPaletteFirstAppearance[whichToolPalette] := false;		toolPaletteOpenOnce[whichToolPalette] := true;	end;	{-----------------------------------------------------------------------------}{-----------------------------------------------------------------------------}	procedure AdjustToolBoxes(whichToolPalette: integer);	var j: integer;	begin		for j := 0 to numTools[whichToolPalette] do			tool^[whichToolPalette,j].R := singleToolBox(whichToolPalette,j);	end;{-----------------------------------------------------------------------------}	procedure CalculateNumPaletteMessageLines(whichToolPalette:integer);	begin		if horizontalTools[whichToolPalette] > 3 then			numPaletteMessageLines[whichToolPalette] := 1		else			numPaletteMessageLines[whichToolPalette] := 2;	end;{-----------------------------------------------------------------------------}	procedure GetToolBoxArrangment(whichToolPalette: integer; height, width: integer; var horizBoxes, vertBoxes: integer);	var oldHorizBoxes, oldVertBoxes: integer;	begin		horizBoxes := 5;		vertBoxes := 4;		vertBoxes := (height - (paletteTitleLineWidth+ paletteMessageLineWidth*numPaletteMessageLines[whichToolPalette])) div (toolCellWidth-1);		if vertBoxes < 1 then vertBoxes := 1;		if vertBoxes > (numTools[whichToolPalette]+1) then vertBoxes :=  numTools[whichToolPalette]+1;		horizBoxes :=  width div (toolCellWidth-1);		if horizBoxes < 1 then horizBoxes := 1;				if horizBoxes > (numTools[whichToolPalette]+1) then 			horizboxes :=  numTools[whichToolPalette]+1;				repeat			oldHorizBoxes := horizboxes;			oldvertBoxes := vertboxes;			if (horizboxes - (numTools[whichToolPalette]+1) mod horizboxes) > vertboxes then				repeat					horizboxes := horizboxes-1;				until  (horizboxes - (numTools[whichToolPalette]+1) mod horizboxes) <= vertboxes;			if horizBoxes < 1 then horizBoxes := 1;			if horizBoxes * (vertBoxes-1) >= numTools[whichToolPalette]+1 then 				begin 					repeat 						vertBoxes := vertBoxes - 1;					until horizBoxes * vertBoxes < numTools[whichToolPalette];					vertBoxes := vertBoxes+1;				end;			if horizBoxes * vertBoxes < numTools[whichToolPalette]+1 then 				repeat 					horizBoxes := horizBoxes + 1;				until horizBoxes * vertBoxes >= numTools[whichToolPalette]+1;		until (oldHorizBoxes = horizBoxes) & (oldVertBoxes = vertBoxes);	end;{-----------------------------------------------------------------------------}	procedure ReSizeToolPalette(whichToolPalette: integer; horizBoxes,vertBoxes: integer);	const	growBoxWidth = 14;	var	box: rect;	begin		if horizBoxes<1 then horizBoxes := 1;		if vertBoxes<1 then vertBoxes := 1;		CalculateNumPaletteMessageLines(whichToolPalette);		if useOldFloatingWindows then			SetRect(Box, 0, 0,(toolCellWidth -1) * horizBoxes, (toolCellWidth -1) * vertBoxes  + paletteTitleLineWidth+ paletteMessageLineWidth*numPaletteMessageLines[whichToolPalette])		else			SetRect(Box, 0, 0, (toolCellWidth-1) * horizBoxes, (toolCellWidth -1) * vertBoxes + paletteMessageLineWidth*numPaletteMessageLines[whichToolPalette]);		if toolPaletteHasExtraMessage[whichToolPalette] then			box.bottom := box.bottom + paletteMessageExtraLineWidth;		SizeWindow(toolPaletteWindow[whichToolPalette],box.right+paletteEdge*2-1, box.bottom+paletteEdge*2, false);		InvalidateWindow(toolPaletteWindow[whichToolPalette],true);					paletteMessageBox[whichToolPalette]:= WindowPortRect(toolPaletteWindow[whichToolPalette]);		paletteMessageBox[whichToolPalette].top := paletteMessageBox[whichToolPalette].bottom - paletteMessageLineWidth*numPaletteMessageLines[whichToolPalette];		SetRect(paletteExtraMessageBox[whichToolPalette],0,0,0,0);		if toolPaletteHasExtraMessage[whichToolPalette] then			begin				paletteExtraMessageBox[whichToolPalette]:= paletteMessageBox[whichToolPalette];				paletteExtraMessageBox[whichToolPalette].bottom := paletteMessageBox[whichToolPalette].top;				paletteExtraMessageBox[whichToolPalette].top := paletteExtraMessageBox[whichToolPalette].bottom-paletteMessageExtraLineWidth;			end;		paletteMessageBox[whichToolPalette].right := paletteMessageBox[whichToolPalette].right - growBoxWidth;		paletteGrowBox[whichToolPalette]:= WindowPortRect(toolPaletteWindow[whichToolPalette]);		paletteGrowBox[whichToolPalette].left := paletteMessageBox[whichToolPalette].right;		paletteGrowBox[whichToolPalette].top := paletteGrowBox[whichToolPalette].bottom - growBoxWidth;				horizontalTools[whichToolPalette] := horizBoxes;		verticalTools[whichToolPalette] := vertBoxes;		AdjustToolBoxes(whichToolPalette);	end;	{-----------------------------------------------------------------------------}end.