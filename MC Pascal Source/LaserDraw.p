unit LaserDraw;{еееееееееееееееееееееее}interface	uses		Printing, QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, FixMath,		Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, 		EventUtil, GenUtil, BoxUtil, strutil, TypeUtil, Prohibitions, TaxonCHUtil, SymbolsNames, 		TraceAllChangesCalc, WriteUtil, CharUtil, Legends, TreeUtil, Coloring, TreeMaker, PrintingUtil, 		PrintingMisc, LaserTreeUtil;	procedure DrawTreePicture (boundary: rect; forscreen, forpict: boolean);{еееееееееееееееееееееее}implementation {е$S LaserDraw}//	procedure DrawTreePicture (boundary: rect; forscreen, forpict: boolean);  begin end;	var		imageBoundary: rect;{-----------------------------------------------------------------------------}{||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}	const		emptyRootSlices = 2;		{-----------------------------------------------------------------------------}	function NodeAngle (leftN, rightN: Nptr): single;		var			theAngle: single;	begin		if not fliptree | (((leftN^.angle < pi) & (rightN^.angle < pi) | (leftN^.angle > pi) & (rightN^.angle > pi))) then			theAngle := (leftN^.angle + rightN^.angle) / 2.0		else			begin				theAngle := leftN^.angle + (2 * pi - abs(leftN^.angle - rightN^.angle)) / 2.0;				if theAngle > 2 * pi then					theAngle := theAngle - 2 * pi;			end;		NodeAngle := theAngle;	end;{-----------------------------------------------------------------------------}	procedure GoUpLocDown (var N: Nptr);{assigns initial positions of nodes on tree}	begin		if NodeIsInternal(N) then			begin				GoUpLocDown(N^.lf);				GoUpLocDown(N^.rt);				if laser^.treeshape[circletree] then					begin						N^.angle := NodeAngle(N^.lf, N^.rt);						if (N^.lf^.polarLength > N^.rt^.polarLength) then							N^.polarLength := N^.rt^.polarLength - circleslice						else							N^.polarLength := N^.lf^.polarLength - circleslice;						if N^.polarLength < 0 then							N^.polarlength := 0;						NodePolarToSingleLoc(N^.polarlength, N^.angle, N^.sloc);						NodePolarToLoc(N^.polarlength, N^.angle, N^.loc);					end				else					if not laser^.square then						begin							if (N^.lf^.loc.h > N^.rt^.loc.h) then								begin									N^.loc.h := (N^.rt^.loc.h + N^.lf^.loc.h + N^.lf^.loc.v - N^.rt^.loc.v) div 2;									N^.loc.v := N^.rt^.loc.v + N^.loc.h - N^.rt^.loc.h;								end							else								begin									N^.loc.h := (N^.lf^.loc.h + N^.rt^.loc.h + N^.rt^.loc.v - N^.lf^.loc.v) div 2;									N^.loc.v := N^.lf^.loc.v + N^.loc.h - N^.lf^.loc.h;								end;						end					else						begin							N^.loc.h := (N^.lf^.loc.h + N^.rt^.loc.h) div 2;							if N^.lf^.loc.v > N^.rt^.loc.v then								N^.loc.v := N^.lf^.loc.v + laser^.versp							else								N^.loc.v := N^.rt^.loc.v + laser^.versp;						end;			end;	end;{-----------------------------------------------------------------------------}	procedure GoUpNullDown (var N: Nptr);{adjusts positions to take into account null nodes}		var			aN: Nptr;	begin		if NodeIsInternal(N) then			begin				GoUpNullDown(N^.lf);				GoUpNullDown(N^.rt);				 if N^.null & not (N = ScreenR) then					begin						aN := NotNullanc(N);						N^.loc := aN^.loc;						if laser^.treeshape[circletree] then							begin								N^.polarlength := aN^.polarlength;								N^.angle := aN^.angle;								NodePolarToSingleLoc(N^.polarlength, N^.angle, N^.sloc);								NodePolarToLoc(N^.polarlength, N^.angle, N^.loc);{    N^.loc2 := aN^.loc2;}{    N^.sloc2 := aN^.sloc2;}							end;					end;			end;	end;{-----------------------------------------------------------------------------}	procedure CondenseTree (N: Nptr);{adjusts positions to take into account null nodes}		var			aN: Nptr;			minNodes,maxNodes: longint;	begin		if NodeIsInternal(N) then			begin				CondenseTree(N^.lf);				CondenseTree(N^.rt);								if N^.null then					aN := NotNullAnc(N) 				else					aN := N;				NodesFromTop(aN, minnodes, maxnodes,false);				N^.loc.v := topmargin+laser^.versp*(maxnodes);			end;				end;{-----------------------------------------------------------------------------}	procedure GoUpHLocDown (var N: Nptr);{adjusts horizontal positions of nodes for square trees}	begin		if NodeIsInternal(N) then			begin				GoUpHLocDown(N^.lf);				GoUpHLocDown(N^.rt);				N^.loc.h := (farthestleft(N) + farthestright(N)) div 2;			end;	end;{-----------------------------------------------------------------------------}	procedure GoUpPhyloLocDown (var N: Nptr);{adjusts vertical positions of nodes if branch lengths shown}	begin		if NodeIsInternal(N) then			begin				if laser^.treeshape[circletree] then					begin{v4: not right - don't use polarlength}						N^.lf^.polarLength := N^.polarLength + RoundValue(N^.lf^.length1 * laser^.pixelperchg);						N^.rt^.polarLength := N^.polarLength + RoundValue(N^.rt^.length1 * laser^.pixelperchg);						NodePolarToLoc(N^.lf^.polarlength, N^.lf^.angle, N^.lf^.loc);						NodePolarToLoc(N^.rt^.polarlength, N^.rt^.angle, N^.rt^.loc);						NodePolarToSingleLoc(N^.lf^.polarlength, N^.lf^.angle, N^.lf^.sloc);						NodePolarToSingleLoc(N^.rt^.polarlength, N^.rt^.angle, N^.rt^.sloc);					end				else					begin{$IFC MINMAXIN}						if (branchlistmode = minmaxmode) then							begin								if laser^.mmEnd = mmMin then									begin										N^.lf^.loc.v := N^.loc.v - RoundValue(N^.lf^.length1 * laser^.pixelperchg);										N^.rt^.loc.v := N^.loc.v - RoundValue(N^.rt^.length1 * laser^.pixelperchg);									end								else if laser^.mmEnd = mmMean then									begin										N^.lf^.loc.v := N^.loc.v - RoundValue(N^.lf^.lengthMean * laser^.pixelperchg); {* lengthinflate}  {note lengthinflate}										N^.rt^.loc.v := N^.loc.v - RoundValue(N^.rt^.lengthMean * laser^.pixelperchg); {* lengthinflate}									end								else if laser^.mmEnd = mmMax then									begin										N^.lf^.loc.v := N^.loc.v - RoundValue(N^.lf^.length2 * laser^.pixelperchg);										N^.rt^.loc.v := N^.loc.v - RoundValue(N^.rt^.length2 * laser^.pixelperchg);									end;							end						else							begin								N^.lf^.loc.v := N^.loc.v - RoundValue(N^.lf^.length1 * laser^.pixelperchg);								N^.rt^.loc.v := N^.loc.v - RoundValue(N^.rt^.length1 * laser^.pixelperchg);							end;{$ELSEC}						N^.lf^.loc.v := N^.loc.v - RoundValue(N^.lf^.length1 * laser^.pixelperchg);						N^.rt^.loc.v := N^.loc.v - RoundValue(N^.rt^.length1 * laser^.pixelperchg);{$ENDC}					end;				GoUpPhyloLocDown(N^.lf);				GoUpPhyloLocDown(N^.rt);			end;	end;{-----------------------------------------------------------------------------}	function Angle360 (radians: single): integer;	begin		Angle360 := RoundValue((radians / pi) * 180.0);	end;{-----------------------------------------------------------------------------}	procedure AdjustAngle (N, desN: Nptr);		var			des: point;			adj: single;	begin		des.h := RoundValue(N^.polarlength * sin(desN^.angle));		des.v := RoundValue(N^.polarlength * cos(desN^.angle));		if des.v < 0 then			adj := pi		else if des.h < 0 then			adj := pi * 2.0		else			adj := 0;		if des.v <> 0 then			desN^.Angle := adj + arctan(1.0 * des.h / des.v);		NodePolarToLoc(N^.polarlength, desN^.angle, desN^.loc2);		NodePolarToSingleLoc(N^.polarlength, desN^.angle, desN^.sloc2);	end;{-----------------------------------------------------------------------------}	procedure GoUpAnglesDown (var N: Nptr);{assigns loc2 for circletrees}	begin		if NodeIsInternal(N) then			begin				AdjustAngle(N, N^.lf);				AdjustAngle(N, N^.rt);				GoUpAnglesDown(N^.lf);				GoUpAnglesDown(N^.rt);			end;	end;{-----------------------------------------------------------------------------}	procedure DrawBoxAngle (box: rect; startangle, endangle: single);	begin		FrameArc(box, Angle360(startangle), Angle360(endangle - startangle));	end;{----------------------------------------------------------------------------}	procedure TreeLineTo (hor, ver: integer; dogray: boolean);		var			oldRgn: RgnHandle;	begin		ClipRect(imageBoundary);		if (edw = 0) or dogray then			begin{PenNormal;}				PenSize(1, 1);				DoSetLineWidth(1, 4);				LineTo(hor, ver);				DoSetLineWidth(4, 1);				DoSetLineWidth(1, 1);			end		else			begin				LineTo(hor, ver);				MoveTo(hor, ver);			end;	end;{-----------------------------------------------------------------------------}	procedure PostScriptBranchArc (treecenter: LongPoint; radius: integer; toAngle, fromAngle: single);		var			fromAngleStr, toAngleStr: str255;	begin		RealtoString(fromAngle, fromAngleStr, 100.0, 4, false);		RealtoString(toAngle, toAngleStr, 100.0, 4, false);		if fliptree & ((toAngle > 90) & (fromAngle < 90)) then			begin				DrawString(concat(StringFromNum(treecenter.h), ' ', StringFromNum(treecenter.v), ' ', StringFromNum(radius), ' ', fromAngleStr, ' ', '-90', ' arcn'));				DrawString(concat(StringFromNum(treecenter.h), ' ', StringFromNum(treecenter.v), ' ', StringFromNum(radius), ' ', '270', ' ', toAngleStr, ' arcn'));			end		else if fliptree & ((toAngle < 90) & (fromAngle > 90)) then			begin				DrawString(concat(StringFromNum(treecenter.h), ' ', StringFromNum(treecenter.v), ' ', StringFromNum(radius), ' ', fromAngleStr, ' ', '270', ' arc'));				DrawString(concat(StringFromNum(treecenter.h), ' ', StringFromNum(treecenter.v), ' ', StringFromNum(radius), ' ', '-90', ' ', toAngleStr, ' arc'));			end		else if (fromAngle > toAngle) then			DrawString(concat(StringFromNum(treecenter.h), ' ', StringFromNum(treecenter.v), ' ', StringFromNum(radius), ' ', fromAngleStr, ' ', toAngleStr, ' arcn'))		else			DrawString(concat(StringFromNum(treecenter.h), ' ', StringFromNum(treecenter.v), ' ', StringFromNum(radius), ' ', fromAngleStr, ' ', toAngleStr, ' arc'));	end;{-----------------------------------------------------------------------------}	procedure QuickDrawBranchArc (treecenter: LongPoint; radius: integer; fromAngle, toAngle: single);		var			box: rect;	begin		SetRect(box, treecenter.h - radius, treecenter.v - radius, treecenter.h + radius, treecenter.v + radius);		if fliptree & ((fromAngle > pi) & (toAngle < pi)) then			begin				DrawBoxAngle(box, 0, toAngle);				DrawBoxAngle(box, fromAngle, 2 * pi);			end		else if fliptree & ((toAngle > pi) & (fromAngle < pi)) then			begin				DrawBoxAngle(box, 0, fromAngle);				DrawBoxAngle(box, toAngle, 2 * pi);			end		else			DrawBoxAngle(box, fromAngle, toAngle);	end;{-----------------------------------------------------------------------------}	procedure DrawCircleBranch (N, desN: Nptr; treecenter: LongPoint; dogray: boolean);		var			radius: integer;			fromAngle, toAngle: single;			box: rect;			oldClip: RgnHandle;			nilRect: rect;			fromStr, toStr, locHStr, locVStr: str255;			doarcn: boolean;	begin		radius := RoundValue(N^.polarlength);		fromAngle := ((desN^.angle - pi / 2) / pi * 180);		toAngle := ((N^.angle - pi / 2) / pi * 180);		RealtoString(fromAngle, fromStr, 100.0, 4, false);		RealtoString(toAngle, toStr, 100.0, 4, false);		RealtoString(desN^.sloc.h, locHStr, 1000.0, 4, false);		RealtoString(desN^.sloc.v, locVStr, 1000.0, 4, false);		SetRect(nilrect, 0, 0, 0, 0);		OldClip := newRgn;		GetClip(oldClip);		PicComment(PostScriptBegin, 0, nil);		PicComment(TextIsPostScript, 0, nil);		ClipRect(nilRect);		DrawString('newpath');		DrawString(concat(locHStr, ' ', locVStr, ' moveto'));		PostScriptBranchArc(treecenter, radius, toAngle, fromAngle);  {problem is not in here}{    DrawString(concat(StringFromNum(edw), ' setlinewidth'))}		if dogray then			DrawString('[1 4] 0 setdash');		if edw = 0 then			DrawString('0.5 setlinewidth')		else			DrawString(concat(StringFromNum(edw), ' setlinewidth'));   {hairlines}		DrawString('stroke');		if dogray then			DrawString('[] 0 setdash');		ClipRect(imageBoundary);		if edw = 0 then			PenSize(1, 1);		QuickDrawBranchArc(treecenter, radius, N^.angle, desN^.angle);		MoveTo(desN^.loc2.h, desN^.loc2.v);		LineTo(desN^.loc.h, desN^.loc.v);		PicComment(PostScriptEnd, 0, nil);		ZapRegion(oldClip);	end;{-----------------------------------------------------------------------------}{$IFC MINMAXIN}{-----------------------------------------------------------------------------}	procedure DrawMinMaxBars (N, desN: Nptr);		var			maxbox, meanbox: rect;			minmaxMiddle, minmaxwidth, meanend, maxend, minend: integer;			thePen: PenState;	begin		if laser^.mmShow <> mmDontShow then			begin				if edw = 0 then					minmaxwidth := 2				else if (edw > 6) & (laser^.mmShow = mmShowBars) then					minmaxwidth := edw div 2				else					minmaxwidth := edw div 2 + 2;				minMaxMiddle := desN^.loc.h + edw div 2;				minend := N^.loc.v - RoundValue(desN^.length1 * laser^.pixelperchg);				meanend := N^.loc.v - RoundValue(desN^.lengthMean * laser^.pixelperchg); {* lengthinflate}				maxend := N^.loc.v - RoundValue(desN^.length2 * laser^.pixelperchg);				if minend <> maxend then					begin						GetPenState(thePen);						PenSize(1, 1);						if (laser^.mmShow = mmShowBars) then							begin								SetRect(meanbox, minMaxMiddle - minmaxwidth, meanend, minMaxMiddle + minmaxwidth, minend);								SetRect(maxbox, minMaxMiddle - minmaxwidth, maxend, minMaxMiddle + minmaxwidth, meanend);								if maxend <> meanend then									begin										FillRect(maxbox, QDWhite);										FrameRect(maxbox);									end;								if minend <> meanend then									begin										FillRect(meanbox, QDGray);										FrameRect(meanbox);									end;							end						else							begin								MoveTo(minMaxMiddle - minmaxwidth, minend);								LineTo(minMaxMiddle + minmaxwidth, minend);								MoveTo(minMaxMiddle - minmaxwidth, meanend);								LineTo(minMaxMiddle + minmaxwidth, meanend);								MoveTo(minMaxMiddle - minmaxwidth, maxend);								LineTo(minMaxMiddle + minmaxwidth, maxend);								MoveTo(minMaxMiddle, minend);								GridLineTo(minMaxMiddle, maxend,false);							end;						SetPenState(thePen);					end;			end;	end;{$ENDC}{-----------------------------------------------------------------------------}	procedure LineBetweenNodes (N, desN: Nptr);{draws line between node N and one of its descendent nodes, desN}		var			dogray: boolean;	begin		if not desN^.null then			begin				moveto(N^.loc.h, N^.loc.v);				dogray := N^.fixanc and desN^.fixanc and (desN^.name > 0);				if dogray then					if edw = 0 then						PenPat(QDGray)					else						PenPat(QDltGray);				if laser^.treeshape[circletree] & ((N^.lf^.polarlength > N^.polarlength) | (N^.rt^.polarlength > N^.polarlength)) & laser^.square then					DrawCircleBranch(N, desN, treecenter, dogray)				else					begin						if laser^.treeshape[squaretree] then							begin								TreeLineTo(desN^.loc.h, N^.loc.v, dogray);    {draw horizontal line}							end						else if (laser^.treeshape[eurotree] and (desN^.loc.v < N^.loc.v)) then							TreeLineTo(desN^.loc.h, N^.loc.v - laser^.versp div 3, dogray);						if not (laser^.treeshape[eurotree] and (desN^.loc.v = N^.loc.v)) then							TreeLineTo(desN^.loc.h, desN^.loc.v, dogray);{$IFC MINMAXIN}						if laser^.printbranchlengths & (branchlistmode = minmaxmode) then							DrawMinMaxBars(N, desN);{$ENDC}											end;			end;	end;{-----------------------------------------------------------------------------}	procedure LinesToDescendents (N: Nptr);{draws lines between node N and ts descendent nodes}		var			pnst: penstate;	begin		getPenState(pnst);		LineBetweenNodes(N, N^.lf);		setPenState(pnst);		LineBetweenNodes(N, N^.rt);		setPenState(pnst);	end;{-----------------------------------------------------------------------------}	procedure GoUpLaserDown (var N: Nptr);{draws laser trees}{........}		procedure GoUpLaserDownRec (var N: Nptr);{v4: give users more control over eurotree shape; also, have better default eurotree angles when large polytomies}		begin			if NodeIsInternal(N) then				begin					GoUpLaserDown(N^.lf);					GoUpLaserDown(N^.rt);					LinesToDescendents(N);				end;		end;{........}	begin		if laser^.treeshape[circletree] & laser^.square then			GoUpAnglesDown(N);		GoUpLaserDownRec(N);	end;{||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	procedure DrawPagesAndPanels (boundary: rect);{draws vertical and horizontal QDGray lines on previewB indicating page and panel boundaries}{.......}		procedure DrawVertHorLine (toptobottom: boolean; numdivisions: integer);			var				j, inc: integer;		begin			with boundary do				if toptobottom then					begin						inc := ((right - left) div numdivisions);						for j := 1 to numdivisions - 1 do							begin								moveto(left + inc * j, top);								Lineto(left + inc * j, bottom);							end					end				else					begin						inc := (bottom - top) div numdivisions;						for j := 1 to numdivisions do							begin								moveto(left, top + inc * j);								Lineto(right, top + inc * j);							end;					end;		end;{.......}	begin		ClipRect(boundary);		PenNormal;		PenPat(QDGray);		with boundary do			begin				if (laser^.treesPerPage.h > 1) then					DrawVertHorLine(true, laser^.treesPerPage.h);				if (laser^.treesPerPage.v > 1) then					DrawVertHorLine(false, laser^.treesPerPage.v);				PenPat(QDBlack);				if (laser^.treepages.v > 1) then					DrawVertHorLine(false, laser^.treepages.v);				if (laser^.treepages.h > 1) then					DrawVertHorLine(true, laser^.treepages.h);			end;	end;{-----------------------------------------------------------------------------}	procedure DrawLaserTextBox (thebox: integer; forscreen, forpict: boolean);{draws text in a laserbox}		var			box: rect;			ds: str255;	begin		if ReallyShowLegend(thebox) then			begin				SetBoxFont(thebox);				with laser^.starts[thebox], laserboxes^[thebox].R do					if closeupon then						SetRect(box, h, v, h + right - left, v + bottom - top)					else						SetRect(box, h, v, h + RoundValue((right - left) / shrink), v + RoundValue((bottom - top) / shrink));				ClipRect(box);				case thebox of					treenamB: 						ds := treename^^;					treenumB: 						begin							if forscreen or forpict then								GetTreeNumber;							NumToString(printtreenumber, ds);						end;					commentB: 						ds := LaserCommentSH^^;					treestatsB:   {v4: use same code here as in Legends}						begin							ds := '';							if tlegStats[tlegTreeLength].show then								begin									if treelength < 0 then										ds := '░'									else										begin											ds := concat('Treelength: ', LengthString(treelength, true));											if TreeLengthPlus then												ds := concat(ds, '+');											if TreeLengthMinus then												ds := concat(ds, '-');											if FixancPolymorph then												ds := concat(ds, '*');										end;								end;							if tlegStats[tlegCI].show or tlegStats[tlegMin].show or tlegStats[tlegRI].show or tlegStats[tlegRC].show or tlegStats[tlegMax].show then								if MinMaxLenLegal(false, minlength) then									begin										if tlegStats[tlegCI].show then											ds := concat(ds, chr(13), TlegString(ci, 0, AnyType([usedef]), ' CI: ', tlegCI));										if MinMaxLenLegal(false, maxlength) then											begin												if tlegStats[tlegRI].show then													ds := concat(ds, chr(13), TlegString(ri, 0, AnyType([usedef]), ' RI: ', tlegRI));												if tlegStats[tlegRC].show then													ds := concat(ds, chr(13), TlegString(ci * ri, 0, AnyType([usedef]), ' RC: ', tlegRC));											end;										if tlegStats[tlegMin].show then											ds := concat(ds, chr(13), TlegString(0, mintreelength, AnyType([usedef]), ' Min: ', tlegMin));										if tlegStats[tlegMax].show & MinMaxLenLegal(false, maxlength) then											ds := concat(ds, chr(13), TlegString(0, maxtreelength, AnyType([usedef]), ' Max: ', tlegMax));									end;							if tlegStats[tlegchg].show then								begin									ds := concat(ds, chr(13), StringFromnum(treechangesMIN));									if treechangesMIN = treechangesMAX then										ds := concat(ds, ' changes')									else										ds := concat(ds, '-', StringFromnum(treechangesMAX), ' changes');									if TerminalPolymorphisms then										ds := concat(ds, '*');								end;						end;					otherwise						ds := '';				end;				if ds <> '' then					begin						TETextBox(Pointer(ord4(@ds) + 1), length(ds), box, teJustleft);						if forscreen and not closeupon then							GrayOutline(laserBoxes^[theBox].R, pator);					end;				ClipRect(CurrentDrawingPortRect);			end;	end;{||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	procedure DrawTreePicture (boundary: rect; forscreen, forpict: boolean);{what if picture is too big?}		var			ang, ii, maxname, treebot: Integer;			firstt, horLoc: integer;			aN: Nptr;			np: point;			oldpatternbox: rect;			ds: str255;			rooted: boolean;			place,oldScreenRLoc: longint;			minnodes, maxnodes: longint;			oldscreenloc: LongPoint;			box:rect;{....................}		procedure DrawScaleTicks (value: longint; width: integer; dothin: boolean);		begin			MoveTo(firstt - width, screenR^.loc.v - RoundValue(value * laser^.pixelperchg));			if doThin then				GridLineTo(firstt + width, screenR^.loc.v - RoundValue(value * laser^.pixelperchg), false)			else				LineTo(firstt + width, screenR^.loc.v - RoundValue(value * laser^.pixelperchg));			move(1, 0);			Drawstring(LengthString(value, true));   {don't want to deflate as already taken care of}{v3.02: changed so LengthString does return real value}		end;{....................}		procedure DrawScale;			var				tn: Nptr;				il, irl, ilnarrow: longint;				apen: penstate;				dosmallticks: boolean;				j: integer;		begin			GroupBegin;			GetPenstate(apen);			PenNormal;			TextFont(kFontIDGeneva);			TextFace([]);			TextSize(9);			tn := screenR;			repeat				tn := tn^.rt;			until tn^.rt^.name > 0;			firstt := tn^.rt^.loc.h + 20;			Moveto(firstt, screenR^.loc.v - RoundValue(changesheight * laser^.pixelperchg));			Gridlineto(firstt, screenR^.loc.v, false);			il := 1;			while il * 10 < changesheight do  {this cycles to find order of mag just below changesheight}				il := il * 10;			ilnarrow := il div 10;			dosmallticks := RoundValue(ilnarrow * laser^.pixelperchg) > 10;			irl := 0;			repeat				DrawScaleTicks(irl * il, 4, false);				if dosmallticks then					for j := 1 to 9 do						if irl * il + ilnarrow * j <= changesheight then							DrawScaleTicks(irl * il + ilnarrow * j, 2, true);				irl := irl + 1;			until irl * il > changesheight;			SetPenstate(apen);			GroupEnd;		end;{....................}	begin		imageBoundary := boundary;		rooted := true;		if PaintedBranches then			edw := laser^.tracewidth		else			edw := laser^.width;		boxedw := laser^.tracewidth;		CalcNodeTriangle;		if treepicture <> nil then			KillPicture(treepicture);		treepicture := nil;		ang := CalcAngle(laser^.nameanglept);		TTPR^^.tAngle := 270 + ang;		TTPR^^.tAngleFixed := Long2Fix(TTPR^^.tAngle);		{    verinc := laser^.txsp * sin(pi / 2 - ang * pi / 180.0);}{    horinc := laser^.txsp * cos(pi / 2 - ang * pi / 180.0);}		CalcLaserBoxes;		FixLaserTreeB;{    tax := 0.0;}		if ang < 45 then			np.h := firsttx + (90 - ang) div 20 + edw div 2		else			np.h := firsttx + edw div 2;		if (traceshown = traceDiscrete) then			np.v := topmargin - 10		else			np.v := topmargin - 3;		printLastTx := np.h - 2;{Penmode(pator);}{if tracing, then penheight := 1}		maxname := MaxNameHeight;{====== start drawing the tree ========}//		SetRect(box,firsttx-20,np.v-20,firsttx+laser^.txsp*numtaxain+20,np.v+laser^.txsp*numtaxain div 2 + 30);		box := boundary;		TreePicture := OpenNewPicture(box);		ClipRect(box);{еееееее}{$IFC TRUE}		lasttx := firsttx;		DrawTaxonNames(true, forscreen, true, not (laser^.printbranchlengths), forpict, (traceshown = traceDiscrete));{if do a    FillRect(boundary, QDltGray);   here, fills entire page on screen; therefore, full cliprect is set}{second time through firsttx and lasttx seem reasonable}		ClipRect(boundary);		lasttx := firsttx;{===== initial calcs =====}		PenNormal;		if laser^.treeshape[squaretree] or laser^.treeshape[eurotree] or laser^.treeshape[circletree] then			PenSize(edw, edw)		else			begin				ii := edw div 2;				if ii < 1 then					ii := 1;				if PaintedBranches then					ii := 1;				PenSize(edw, ii);			end;		ClipRect(boundary);		if laser^.treeshape[circletree] then			begin				NodesFromTop(screenR, minnodes, maxnodes,true);				circleslice := (ntscreen - 1) * laser^.txsp / 2.0 / (maxnodes + emptyRootSlices);  {v4: have it based upon an ellipse}			end;		GoUpLocDown(screenR);		if laser^.treeshape[circletree] then			begin				oldscreenloc := screenR^.loc;				calcTreeCenter;				screenR^.loc := treeCenter;			end;		if AnyNulls(ScreenR) then			begin				if laser^.square and not laser^.treeshape[circletree] then					GoUpHLocDown(screenR);				GoUpNullDown(screenR);				if laser^.condensedTree&(laser^.treeshape[squaretree] | laser^.treeshape[eurotree]) then					begin							CondenseTree(ScreenR);					{	repeat							oldScreenRLoc := ScreenR^.loc.v;							GoUpPolytomyBaseDown(ScreenR);							GoUpNullDown(screenR);						until oldScreenRLoc = ScreenR^.loc.v;}					end;			end;		if laser^.printbranchlengths then  {right here, before goupphylolocdown, calculate pixelperchg}			begin				changesheight := treechangeheight(0, 1);  {no extra length per branch, 1 unit for each change}				if laser^.LPPCconstant then					begin						laser^.pixelperchg := laser^.LPPCvalue;					end				else if laser^.treeshape[circletree] then					begin						laser^.pixelperchg := (1.0 * circleslice * (maxnodes + emptyRootSlices)) / (1.0 * changesheight); {picxelheight of tree}					end				else					begin						laser^.pixelperchg := (1.0 * (ScreenR^.loc.v - topmargin)) / (1.0 * changesheight); {pixelheight of tree}					end;				GoUpPhyloLocDown(screenR);				lasttx := firsttx;				DrawTaxonNames(true, forscreen, false, true, forpict, (traceshown = traceDiscrete));			end;{==== tree branches =====}		GroupBegin;{==== root ====}		GroupBegin;		if rooted then			if laser^.treeshape[circletree] then				begin					GoUpLaserDown(screenR);					PenSize(edw, edw);					MoveTo(treecenter.h, treecenter.v);					TreeLineTo(oldscreenloc.h, oldscreenloc.v, false);{    treebot := topmargin + laser^.txsp * (ntscreen - 1);}					aN := screenR^.lf;					while NodeIsInternal(aN) do						aN := aN^.lf;					treebot := aN^.loc.v;					PenNormal;				end			else				begin					GoUpLaserDown(screenR);					aN := NotNullAnc(screenR);					if laser^.printbranchlengths then						rootsize := RoundValue(screenR^.length1 * laser^.pixelperchg)					else						begin							if laser^.square then								rootsize := laser^.versp							else								rootsize := laser^.versp div 2;							if rootsize < 12 then								rootsize := 12;						end;					aN^.loc.v := ScreenR^.loc.v + rootsize;					if not laser^.square then						begin							if (NodeSlantsRight(ScreenR)) then								aN^.loc.h := ScreenR^.loc.h - rootsize							else								aN^.loc.h := ScreenR^.loc.h + rootsize;							moveto(ScreenR^.loc.h, ScreenR^.loc.v);						end					else						begin							horLoc := (farthestleft(ScreenR) + farthestright(ScreenR)) div 2;							aN^.loc.h := horLoc;							moveto(aN^.loc.h, ScreenR^.loc.v);						end;					TreeLineTo(aN^.loc.h, aN^.loc.v, false);					treebot := aN^.loc.v;				end;		GroupEnd;		PenSize(1, 1);		ClipRect(boundary);{===== character tracing, etc. =====}		if (traceshown = traceDiscrete) then			begin				PenMode(patCopy);				GroupBegin;				SetMaxGrayScale;				ColorTree(ScreenR,false);				GroupEnd;			end		else if (traceshown = traceAllChanges) and (summaryview <> asBlack) then			begin				GroupBegin;				SetBoxFont(treeB);				//setRect(box,0,0,2000,2000);				//ClipRect(box);				ColorChanges(myGetWindowFromPort(CurrentDrawingPort));{$IFC FALSE}				TextFont(TWFont);				TextSize(TWFontsize);				TextFace(TWStyle);{$ENDC}				GroupEnd;			end		else if (traceshown = traceContinuous) then			begin				GroupBegin;				ColorContinuous(true);				GroupEnd;			end;		if ((traceshown = traceDiscrete) & showtracelabels) | ((traceshown = traceContinuous) & showconttracelabels) | ((traceshown = traceProbability) & showProbtracelabels) then			begin				GroupBegin;				SetBoxFont(treeB);				ColorTraceLabels(myGetWindowFromPort(CurrentDrawingPort));				GroupEnd;			end;{=== node numbering ===}		if laser^.numbernodes then			begin				GroupBegin;				SetBoxFont(treeB);				LabelTheNodes(ScreenR, myGetWindowFromPort(CurrentDrawingPort), true, false,false);				GroupEnd;			end;{=== showEvolveSegments ===}		if laser^.showEvolveSegments then			begin				GroupBegin;				SetBoxFont(treeB);				LabelTheNodes(ScreenR, myGetWindowFromPort(CurrentDrawingPort), false, true, false);				GroupEnd;			end;{=== showEvolveRealLengths ===}		if laser^.showEvolveRealLengths then			begin				GroupBegin;				SetBoxFont(treeB);				LabelTheNodes(ScreenR, myGetWindowFromPort(CurrentDrawingPort), false, false, true);				GroupEnd;			end;{=== end tree branches ===}		GroupEnd;		ClipRect(boundary);{========draw scale===========}		if laser^.scaleon & laser^.printbranchlengths & (traceshown = traceAllChanges) then			DrawScale;{=== chlegend ===}		if ReallyShowLegend(legB) then			begin				GroupBegin;				SetBoxFont(legB);				if (traceshown = traceDiscrete) or (traceshown = traceContinuous) or (traceshown = traceAllChanges) or (traceshown = traceProbability) then					begin						place := laserLegLineW;						MoveTo(laser^.starts[legB].h, laser^.starts[legB].v + place);						if (traceshown = traceDiscrete) then							begin								DrawString(AvailCharName(i));								if fixon then									begin										place := place + laserLegLineW;										MoveTo(laser^.starts[legB].h, laser^.starts[legB].v + place);										drawstring('State(s) fixed at some nodes');									end;							end						else if (traceshown = traceProbability) then							begin								DrawString('Probability');								place := place + laserLegLineW;								MoveTo(laser^.starts[legB].h, laser^.starts[legB].v + place);								case probRecItem of									stateexact: 										begin											Drawstring('that state at node is');											place := place + laserLegLineW;											MoveTo(laser^.starts[legB].h, laser^.starts[legB].v + place);											Drawstring('reconstructed correctly,');											place := place + laserLegLineW;											MoveTo(laser^.starts[legB].h, laser^.starts[legB].v + place);											Drawstring('given model');										end;									statenotwrong: 										begin											Drawstring('that MPR set includes');											place := place + laserLegLineW;											MoveTo(laser^.starts[legB].h, laser^.starts[legB].v + place);											Drawstring('true state at node,');											place := place + laserLegLineW;											MoveTo(laser^.starts[legB].h, laser^.starts[legB].v + place);											Drawstring('given model');										end;									changecorrect: 										begin											Drawstring('that change along branch is');											place := place + laserLegLineW;											MoveTo(laser^.starts[legB].h, laser^.starts[legB].v + place);											Drawstring('reconstructed correctly,');											place := place + laserLegLineW;											MoveTo(laser^.starts[legB].h, laser^.starts[legB].v + place);											Drawstring('given model');										end;									numchangeUnamb: 										begin											Drawstring('that unambiguous change is');											place := place + laserLegLineW;											MoveTo(laser^.starts[legB].h, laser^.starts[legB].v + place);											Drawstring('is reconstructed along');											place := place + laserLegLineW;											MoveTo(laser^.starts[legB].h, laser^.starts[legB].v + place);											Drawstring('branch, given model');										end;									numchangeAllowed: 										begin											Drawstring('that allowed change is');											place := place + laserLegLineW;											MoveTo(laser^.starts[legB].h, laser^.starts[legB].v + place);											Drawstring('reconstructed along');											place := place + laserLegLineW;											MoveTo(laser^.starts[legB].h, laser^.starts[legB].v + place);											Drawstring('branch, given model:');										end;								end;								place := place + laserLegLineW;								MoveTo(laser^.starts[legB].h, laser^.starts[legB].v + place);								if seglistenProb then									DRAWstring('Prob. ╞/segment')								else									DRAWstring('Prob. ╞/branch');								place := place + laserLegLineW;								MoveTo(laser^.starts[legB].h, laser^.starts[legB].v + place);								RealToString(probChangeRec[0, 0], ds, 1000, 4, true);								Drawstring(concat('0->0:   ', ds));								place := place + laserLegLineW;								MoveTo(laser^.starts[legB].h, laser^.starts[legB].v + place);								RealToString(probChangeRec[0, 1], ds, 1000, 4, true);								Drawstring(concat('0->1:   ', ds));								place := place + laserLegLineW;								MoveTo(laser^.starts[legB].h, laser^.starts[legB].v + place);								RealToString(probChangeRec[1, 0], ds, 1000, 4, true);								Drawstring(concat('1->0:   ', ds));								place := place + laserLegLineW;								MoveTo(laser^.starts[legB].h, laser^.starts[legB].v + place);								RealToString(probChangeRec[1, 1], ds, 1000, 4, true);								Drawstring(concat('1->1:   ', ds));							end						else if (traceshown = traceContinuous) then							begin								Drawstring('Continuous ');								case icont of									1: 										Drawchar('1');									2: 										Drawchar('2');									3: 										Drawchar('3');									4: 										Drawchar('4');									otherwise										;								end;								place := place + laserLegLineW;								MoveTo(laser^.starts[legB].h, laser^.starts[legB].v + place);								case continuousmode of  {ввв}									manhattan: 										begin											DrawString('Linear parsimony');											place := place + laserLegLineW;											MoveTo(laser^.starts[legB].h, laser^.starts[legB].v + place);											DrawString('(full ranges)');										end;									manhatmin: 										begin											DrawString('Linear parsimony');											place := place + laserLegLineW;											MoveTo(laser^.starts[legB].h, laser^.starts[legB].v + place);											DrawString('(minimum)');										end;									manhatmax: 										begin											DrawString('Linear parsimony');											place := place + laserLegLineW;											MoveTo(laser^.starts[legB].h, laser^.starts[legB].v + place);											DrawString('(maximum)');										end;									sqrooted: 										begin											DrawString('Squared-change ');											place := place + laserLegLineW;											MoveTo(laser^.starts[legB].h, laser^.starts[legB].v + place);											DrawString('(rooted,');										end;									squnrooted: 										begin											DrawString('Squared-change ');											place := place + laserLegLineW;											MoveTo(laser^.starts[legB].h, laser^.starts[legB].v + place);											DrawString('(unrooted,');										end;									sqFelsX: 										begin											DrawString('Felsenstein''s X''s'); {ввв}											place := place + laserLegLineW;											MoveTo(laser^.starts[legB].h, laser^.starts[legB].v + place);											DrawString('(');										end;									sqFelsContrast: 										begin											DrawString('Felsenstein''s Contrasts'); {ввв}											place := place + laserLegLineW;											MoveTo(laser^.starts[legB].h, laser^.starts[legB].v + place);											DrawString('(');										end;									sqFelsContrastSTD: 										begin											DrawString('Felsenstein''s Contrasts'); {ввв}											place := place + laserLegLineW;											MoveTo(laser^.starts[legB].h, laser^.starts[legB].v + place);											DrawString('(Standardized,');										end;									otherwise										;								end;								if not ContinuousIsManhattan then  {ввв}									if contweighted then										DrawString(' weighted branches)')									else										DrawString(' unweighted branches)');							end						else if (traceshown = traceAllChanges) then							begin								MoveTo(laser^.starts[legB].h, laser^.starts[legB].v + place);								if branchlengthsweighted then									DrawString('Weighted amount of change')								else									begin										if laser^.printbranchlengths then											begin												DrawString('Branch lengths proportional to');												place := place + laserLegLineW;												MoveTo(laser^.starts[legB].h, laser^.starts[legB].v + place);											end;										if summaryview <> asticks then											Drawchar('#');										DrawString('Chars. that change');									end;								place := place + laserLegLineW;								MoveTo(laser^.starts[legB].h, laser^.starts[legB].v + place);								case branchlistmode of									unambigmode: 										if branchlengthsweighted then											Drawstring('(Minimum)')										else											Drawstring('Unambiguously on branch');									ambigmode: 										Drawstring('(Almost all Possible) on branch');									maxmode: 										if branchlengthsweighted then											DRAWSTRING('(Maximum)')										else											drawstring('(All Possible) on branch');{$IFC MINMAXIN}									minmaxmode: 										begin											if laser^.printBranchLengths then												if laser^.mmShow = mmDontShow then													begin														if laser^.mmEnd = mmMin then															DrawString('(Minimum)')														else if laser^.mmEnd = mmMean then															DrawString('(Average)')														else if laser^.mmEnd = mmMax then															DrawString('(Maximum)')													end												else													Drawstring('(Min.-Avg.-Max.)')											else if (summaryview = asticks) then   {it can show min max}												Drawstring('Min. (Max.)')											else if summaryview <> asBlack then  {it only shows average}												Drawstring('(Average)');											if not branchlengthsweighted then												drawstring(' on branch');										end;{$ENDC}									otherwise										;								end;								if (summaryview = asticks) & (colorTicksClass=colorTicksIndex) then									begin										place := place + laserLegLineW;										MoveTo(laser^.starts[legB].h, laser^.starts[legB].v + place);										if colorTicksIndexClass = colorTicksRI then											DrawString('Bar shading: RI')										else if colorTicksIndexClass = colorTicksCI then											DrawString('Bar shading: CI')										else											DrawString('Bar shading: RC');									end;							end;						if (traceshown = traceDiscrete) & (laser^.printequiv | equivcycle) then							begin								place := place + laserLegLineW;								MoveTo(laser^.starts[legB].h, laser^.starts[legB].v + place);								DrawString('Reconstruction ');								if equivcycle or not forscreen then									DrawString(StringFromNum(equivcyclenum))								else									DrawString('x');							end;						if ((traceshown = traceDiscrete) | (traceshown = traceContinuous)) & laser^.showstepslaser then							begin								place := place + laserLegLineW;								MoveTo(laser^.starts[legB].h, laser^.starts[legB].v + place);								if (traceshown = traceContinuous) then									begin										drawstring('Length: ');										if ContinuousIsManhattan then											RealToString(NYlength, ds, 10000, sigcontinuous, true)										else											RealToString(minSQLength, ds, 10000, sigcontinuous, true);										Drawstring(ds);									end								else if typeisreal(typeofchar(i)) then									DrawString(concat(RealToIntegerString(isteps, TypeInflate), ' steps'))								else									begin										Drawstring(concat(StringFromNum(isteps), ' step'));										if isteps <> 1 then											DrawChar('s');									end;							end;						if (traceshown = traceDiscrete) & laser^.showtype then							begin								place := place + laserLegLineW;								MoveTo(laser^.starts[legB].h, laser^.starts[legB].v + place);								DrawString(TypeName(TypeOfChar(i)))							end;					end;				oldpatternbox := patternbox;				place := place + laserLegLineW;				with laser^.starts[legB] do					SetRect(patternbox, h, v + place, h + laserLegBoxW * 3 div 2, v + place + laserLegBoxW - 6);				if (traceshown = traceAllChanges) then					offsetrect(patternbox, 0, -36 - laserLegLineW - 2 * laserLegBoxW){    offsetrect(patternbox, 0, -3 * laserLegLineW - 2 * laserLegBoxW)}				else if (traceshown = traceContinuous) then					offsetrect(patternbox, 0, -3 * laserLegLineW - 2 * laserLegBoxW)				else if (traceshown = traceDiscrete) then					offsetrect(patternbox, 0, 8 - laserLegBoxW);{     offsetrect(patternbox, 0, -40 - 2 * laserLegBoxW);}{else if (traceshown = traceContinuous) then offsetrect(patternbox, 0, -40)}{$IFC COLORTICKS}				if not (traceshown = traceAllChanges) | (summaryview = aspattern) | ((summaryview = asticks) & TicksHaveLegend) then{$ELSEC}					if not (traceshown = traceAllChanges) or (summaryview = aspattern) then{$ENDC}						begin							CalcChLegRects(laserLegBoxW);							DrawCHLegBoxes(laserLegBoxW);						end;				patternbox := oldpatternbox;				CalcChLegRects(legboxheight);				GroupEnd;			end;{=== treename box ===}		DrawLaserTextBox(treenamB, forscreen, forpict);{=== treenumber box ===}		DrawLaserTextBox(treenumB, forscreen, forpict);{=== comments box ===}		DrawLaserTextBox(commentB, forscreen, forpict);{=== treestats box ===}		DrawLaserTextBox(treestatsB, forscreen, forpict);{======== page breaks =========}		if forscreen then			DrawPagesAndPanels(boundary);{еееееее}{$ELSEC}		 PenSize(4,4);		 MoveTo(200,200);  //Move to original coordinates		 LineTo(100,200);   // draw a line to the left		 		 MoveTo(100,200);  //Move back to original coordinates		 LineTo(200,200);   // draw a line to the right		 		 treebot := 400;{$ENDC}		 		ClosePicture;		with LaserBoxes^[treeB].R do			begin				if not closeupon then					bottom := pictB.top + TruncateValue(shrink * treebot)				else					bottom := top + treebot;				if (laser^.printbranchlengths and (traceshown = traceAllChanges) and laser^.LPPCconstant) then					if not closeupon then						top := bottom - TruncateValue(shrink * (laser^.LPPCvalue * changesheight))					else						top := bottom - laser^.LPPCvalue * changesheight;				if closeupon then					OffsetRect(LaserBoxes^[treeB].R, pictB.left - closeuppt.h + (pictB.right - pictB.left) div 2, pictB.top - closeuppt.v + (pictB.bottom - pictB.top) div 2);				LaserBoxes^[taxanameB].R.right := right;				LaserBoxes^[taxanameB].R.left := left;				LaserBoxes^[taxanameB].R.bottom := top;			end;		LaserBoxes^[taxanameB].R.top := LaserBoxes^[taxanameB].R.bottom - maxname;		if LaserBoxes^[taxanameB].R.top < drawbox.top then			LaserBoxes^[taxanameB].R.top := drawbox.top;		RestoreSystemFonts;		firsttx := TSP.h;		topmargin := TSP.v;		printLastTx := np.h;	end;end.