unit GeneticCode;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, 		EventUtil, GenUtil, StrUtil, TaxonCHUtil, TypeUtil, BoxUtil, MenuUtil, SpreadUtil, 		SymbolsNames, Settings, CharUtil, CHUNK, RowColumn, FootNote,ReadWriteGeneticCode;	function GeneticCodeName (theCode: integer): str255;	procedure CreateProtParsType (namestr: str255);	procedure PrintDrawGenCode;	procedure GeneticCodeDLOG;	procedure ConvertDNAtoAA (useCodPos: boolean);{$SETC CALCSYNREP=FALSE}{$IFC CALCSYNREP}	procedure NumSynReplace (j, k, m: integer; var synon, replace: integer);	procedure CalcNumSynonymous;	procedure CalcSynReplaceMatrix (useCodPos: boolean);{$ENDC}{еееееееееееееееееееееее}implementation {е$S GeneticCode}	const		codetop = 30;		codeleft = 20;		codewidth = 60;		codeheight = 14;		aatop = 45;		aaleft = 280;		aawidth = 25;		aaheight = 12;		extratop = 55;		extraleft = 354;		term = 20;		GenCodeMenuItem = 5;  {v3.05}	type		gencodeboolarray = array[0..3, 0..3, 0..3] of boolean;		gencodeboolPtr = ^gencodeboolarray;		gencoderecarray = array[0..3, 0..3, 0..3] of RECT;		gencoderecPtr = ^gencoderecarray;		aarecArray = array[0..maxproteinstate] of rect;		aarecPtr = ^aarecarray;		extraAARect = array[1..4] of rect;		extraselarray = array[1..4] of boolean;	var		GenCodeB, aaB, extraRect: rect;		gencodeSel: gencodeboolPtr;   {stores what is selected and what is not}		gencodeR: gencoderecPtr;       {stores rectangles for each for selection}		extraAAR: extraAARect;		aaR: aarecPtr;		extraSel: extraSelArray;		GenCodeMHdl: MenuHandle;{----------------------------------------------------------------------------}	function GeneticCodeName (theCode: integer): str255;		var			ds: str255;			addedMenu: boolean;	begin		addedMenu := false;		if GenCodeMHdl = nil then			begin				GenCodeMHdl := GetMenu(GenCodeMenu); {v3.05}				InsertMenu(GenCodeMHdl, -1);				addedMenu := true;			end;		if GenCodeMHdl = nil then			ds := ''		else if theCode <= myCountMenuItems(GenCodeMHdl) then			GetMenuItemText(GenCodeMHdl, theCode, ds);		if addedMenu then			DeleteMenu(GenCodeMenu);		GeneticCodeName := ds;	end;{----------------------------------------------------------------------------}	procedure InvertInnerHiliteRect (box: rect);		var			box2: rect;	begin		box2 := box;		InsetRect(box2, 1, 1);		InvertHiliteRect(box2);	end;{-----------------------------------------------------------------------------}	procedure ResetSerineLikeAA (extraaapresent: aaset);	{BAD, as can't reset, as don't know what to reset too}{this converts serine-like disjunct aa's into the union of their disjunct elements;}{eg.  S -> 1/2}		var			j, it, ic: integer;			newset, tsts, extras: LargestSetChars;			extratranslates: extracodes;	begin		for it := 1 to numtaxa do			for ic := 1 to numchars do				begin					tsts := gettaxonstsLargest(it, ic);					extras := tsts * extraaapresent;   {extraaapresent are the aa's designated by the extra states}					if extras <> [] then   {there are S's or similar things}						begin							if MultipleStatesLg(tsts) & not (UCl in tsts) then  {was previously multistate, and polymorphic}								NewError(163, ic);  {some polymorphisms will be converted to uncertainties}							newset := tsts - extras + [UCl];							for j := 1 to 4 do								if (extraAAstates[j] > 0) & (extraAAstates[j] in extras) then									newset := newset + [maxAAstate + j];							settaxonstsLargestFoot(it, ic, newset);						end;				end;		ReCalcMaxstAndStates(1,numchars);	end;{-----------------------------------------------------------------------------}	function StsToStateList (tsts: largestSetChars; stateNames: boolean):str255;	var ds: str255;		ir, numElements, numElementsSoFar: integer;	begin		ds := '';		numElements := CardLg(tsts);		numElementsSoFar:= 0;		for ir := 0 to absmaxstate do			if ir in tsts then				begin					if (numElementsSoFar > 0) then						if (numElements=2)  then							ds := concat(ds,' and "',CharOfNum(ir),'"')						else if (numElementsSoFar = numElements-1) then							ds := concat(ds,', and "',CharOfNum(ir),'"')						else							ds := concat(ds,', "',CharOfNum(ir),'"')					else						ds := concat('"',CharOfNum(ir),'"');					numElementsSoFar := numElementsSoFar + 1;				end;		StsToStateList := ds;	end;{-----------------------------------------------------------------------------}	procedure CreateProtParsType (namestr: str255);		type			nearestaatype = array[0..maxproteinstate] of aaset;		var			tempdist: distancetype;			firstrow: integer;			cell: point;			tempP: WindowPtr;			j, k, m, thisaa, mut, oldItemHit: integer;			nearestaa: nearestaatype;			aapresent, pureaapresent: aaset;			extraaapresent: aaset;   {extraaapresent is the list of 1,2,3,4 present in the genetic code}			extraaaRawStatesNotpresent: aaset;   {extraaaRawStatesNotpresent is the list of maxAAState+1,2,3,4 Not present in the genetic code}			extraNotPresentFound: largestSetChars;			justpureAA: boolean;	begin		typeHdl := gettypeHdl(numtypes);		justpureAA := not OptionDown;{|||||||||| creation of type ||||||||||}{getting those aa's present in the code}		pureaapresent := [];		for j := 0 to 3 do			for k := 0 to 3 do				for m := 0 to 3 do					pureaapresent := pureaapresent + [gencode^[j, k, m]];		extraaapresent := [];		for j := 1 to 4 do			if extraAAstates[j] >= 0 then  {extra aa state j is designated as being a particular amino acid}				extraaapresent := extraaapresent + [extraAAstates[j]];    {the particular amino acid is stored in extraAAstates[j]}		aapresent := pureaapresent + extraaapresent;		extraaaRawStatesNotpresent := [];		for j := 1 to 4 do			if extraAAstates[j] < 0 then  {not present in genetic coe}				extraaaRawStatesNotpresent := extraaaRawStatesNotpresent + [maxAAstate + j];  {here is the state set}		for j := 0 to maxproteinstate do			nearestaa[j] := [];{==== getting aa that are one step away ====}		for j := 0 to 3 do			for k := 0 to 3 do				for m := 0 to 3 do					begin						thisaa := gencode^[j, k, m];						for mut := 0 to 3 do							nearestaa[thisaa] := nearestaa[thisaa] + [gencode^[mut, k, m]];						for mut := 0 to 3 do							nearestaa[thisaa] := nearestaa[thisaa] + [gencode^[j, mut, m]];						for mut := 0 to 3 do							nearestaa[thisaa] := nearestaa[thisaa] + [gencode^[j, k, mut]];					end;		for j := 0 to maxproteinstate do			nearestaa[j] := nearestaa[j] - [j];		for j := 0 to maxproteinstate do			for k := 0 to maxproteinstate do				if j in nearestaa[k] then			{j and k are just one step away}					tempdist[j][k] := 1				else if j = k then					tempdist[j][k] := 0				else if (nearestaa[j] * nearestaa[k] - [term] <> []) then{j and k are just one step away from the same aa and they are not nearest to only a termination aa}					tempdist[j][k] := 2				else if (j in pureaapresent) and (k in pureaapresent) then					tempdist[j][k] := 3		{j and k are 3 steps away}				else					tempdist[j, k] := infinity;{===== reseting serine-like aa's ====}		if extraaapresent <> [] then			begin				for j := 0 to maxAAstate do					if j in extraaapresent then						if justpureAA then							begin								for k := 0 to maxproteinstate do									if j <> k then										begin											tempdist[j][k] := infinity;											tempdist[k][j] := infinity;										end							end						else							begin								for k := 0 to maxproteinstate do									begin										tempdist[j][k] := 10000;   {note: infinity is -1; this is not infinity so IntegerMin, to follow, will work}										tempdist[k][j] := 10000;									end;								for m := 1 to 4 do									if extraAAstates[m] = j then										for k := 0 to maxproteinstate do											begin												tempdist[j][k] := IntegerMin(tempdist[j][k], tempdist[maxAAstate + m][k]);												tempdist[k][j] := IntegerMin(tempdist[k][j], tempdist[k][maxAAstate + m]);											end;							end;			end;		typeHdl^^.dist := tempdist;		if justPureAA then			begin				typeHdl^^.max := MaxLg(pureaapresent);				typeHdl^^.setdefined := pureaapresent;				if CheckAAInMatrix(extraaaRawStatesNotpresent, true,extraNotPresentFound) then  {check to see if extra states found in matrix that are NOT in the genetic code}					InstantErrorPlus(422,StsToStateList(extraNotPresentFound,editorShowFullStateNames));					{if CWarning('AAs not present in genetic code found in data matrix: do you wish to convert these to the appropriate AAs?', 'Convert', 'No') then						begin							ResetSerineLikeAA(extraaaRawStatesNotpresent);							if editorOpen then								InvalidateWindow(editorWindow, true);							dirtyfile := true;						end;}			end		else			begin				typeHdl^^.max := MaxLg(aapresent);				typeHdl^^.setdefined := aapresent;			end;	end;{----------------------------------------------------------------------------}	procedure DrawExtraAA (j: integer);	begin		TextFont(kFontIDGeneva);		TextSize(9);		FrameRect(extraAAR[j]);		if extraAAstates[j] >= 0 then			begin				with extraAAR[j] do					moveTo(left + 3, bottom - 3);				DrawString(AminoAcidName(extraAAstates[j]));			end;		TextFont(systemfont);		TextSize(12);	end;{----------------------------------------------------------------------------}	procedure DrawAAs;		var			j: integer;	begin		TextFont(kFontIDGeneva);		TextSize(9);		for j := 0 to MaxProteinState do			begin				FrameRoundRect(aaR^[j], 6, 6);				with aaR^[j] do					moveTo(left + 3, bottom - 3);				DrawString(AminoAcidName(j));			end;		for j := 1 to 4 do			if extraAAstates[j] < 0 then				DimBox(aaR^[maxAAstate + j]);{$IFC FALSE}		moveto(aaR^[maxAAstate + 1].left - 1, aaR^[maxAAstate + 1].top - 14);		DrawString('Extra');		moveto(aaR^[maxAAstate + 1].left, aaR^[maxAAstate + 1].top - 3);		DrawString('State     AA');{$ENDC}		moveto(extraleft, extratop - 12);		DrawString('Extra');		moveto(extraleft, extratop - 2);		DrawString('State     AA');		TextFont(systemfont);		TextSize(12);	end;{----------------------------------------------------------------------------}	procedure DrawCodonAA (j, k, m: integer);		var			box: rect;			value : integer;	begin		TextFont(kFontIDGeneva);		TextSize(9);		box := gencodeR^[j, k, m];		with box do			MoveTo(left + 32, bottom - 4);		value := gencode^[j, k, m] ;		if gencode^[j, k, m] > maxAAstate then			DrawString(concat(AminoAcidName(gencode^[j, k, m]), '.', AminoAcidName(extraAAstates[gencode^[j, k, m] - maxAAstate])))		else			DrawString(AminoAcidName(gencode^[j, k, m]));		TextFont(systemfont);		TextSize(12);	end;{----------------------------------------------------------------------------}	procedure DrawCodonString (j, k, m: integer);{............}		procedure DrawCodonChar (thestate: integer);		begin			case theState of				0: 					DrawChar('A');				1: 					DrawChar('C');				2: 					DrawChar('G');				3: 					if (datatype = RNA) then						DrawChar('U')					else						DrawChar('T');				otherwise					;			end;		end;{............}	begin		DrawCodonChar(j);		DrawCodonChar(k);		DrawCodonChar(m);	end;{----------------------------------------------------------------------------}	procedure PrintDrawGenCode;{draws the genetic code for printing}{v4: note that some of this code is duplicated elsewhere in this unit, but here it does not set fonts}		var			box: rect;			j, k, m: integer;			first, second, third: integer;			gctop, gcleft: integer;			boxw, boxH: integer;			bottom: integer;	begin		boxH := FontHeight + 8;		if printon then			boxW := 11 * StringWidth('G')		else			boxW := 9 * StringWidth('G');		gctop := 100 + fontheight;		gcleft := 100;		moveTo(100, 90 + fontheight);		DrawString('Genetic Code:');		gencodeR := gencoderecPtr(NewPtr(SizeOf(gencoderecarray)));		for j := 0 to 3 do			begin				RemapBase(j, second);  {this remapping implements the order TCAG}				for k := 0 to 3 do					begin						RemapBase(k, first);						for m := 0 to 3 do							begin								RemapBase(m, third);								SetRect(gencodeR^[first, second, third], gcleft + j * (boxW + 2), gctop + (k * 4 + m) * boxH + k * 2 - 1, gcleft + (j + 1) * boxW + j * 2, gctop + (k * 4 + m + 1) * boxH + k * 2);							end;					end;			end;		RemapBase(3, bottom);		bottom := gencodeR^[bottom, bottom, bottom].bottom;		for j := 1 to 4 do			SetRect(extraAAR[j], gcleft, bottom + (boxH + 1) * j, gcleft + boxW, bottom + (boxH + 1) * j + boxH);		for j := 0 to 3 do			begin				RemapBase(j, second);				for k := 0 to 3 do					begin						RemapBase(k, first);						for m := 0 to 3 do							begin								RemapBase(m, third);								box := gencodeR^[first, second, third];								FrameRect(box);								MoveTo(box.left + 3, box.bottom - 5);								DrawCodonString(first, second, third);								Move(15, 0);								if gencode^[first, second, third] > maxAAstate then									DrawString(concat(AminoAcidName(gencode^[first, second, third]), '.', AminoAcidName(extraAAstates[gencode^[first, second, third] - maxAAstate])))								else									DrawString(AminoAcidName(gencode^[first, second, third]));							end;					end;			end;		if not printon then			FrameShadowRect(gencodeB);		if CodeExtrasPresent then			for j := 1 to 4 do				begin					FrameRect(extraAAR[j]);					if extraAAstates[j] >= 0 then						begin							with extraAAR[j] do								moveTo(left + 3, bottom - 3);							DrawString(StringFromNum(j));							move(15, 0);							DrawString(AminoAcidName(extraAAstates[j]));						end;				end;		ZapPointer(gencodeR);	end;{----------------------------------------------------------------------------}	procedure DrawCodeName (theDialog: DialogPtr);		var			box: rect;	begin{$IFC FALSE}		if theGeneticCode = nuclearcode then			SetDLOGText(theDialog, 9, '(''universal'' nuclear code)', false)		else if theGeneticCode = mtDNAcode then			SetDLOGText(theDialog, 9, '(''universal'' mtDNA code)', false)		else if theGeneticCode = othercode then			SetDLOGText(theDialog, 9, '(custom code)', false);{$ENDC}		box := GetDLOGITemBox(theDialog, GenCodeMenuItem);		DrawPopUpRect(box, GeneticCodeName(theGeneticCode));	end;{----------------------------------------------------------------------------}	procedure GeneticCodeUser (theDialog: DialogPtr; itemNo: INTEGER);		var			box: rect;			j, k, m: integer;			first, second, third: integer;	begin		FrameButton(theDialog, 1);		for j := 0 to 3 do			begin				RemapBase(j, second);				for k := 0 to 3 do					begin						RemapBase(k, first);						for m := 0 to 3 do							begin								RemapBase(m, third);								box := gencodeR^[first, second, third];								FrameRect(box);								with box do									MoveTo(left + 3, bottom - 4);								if not printon then									begin										TextFace([bold]);										TextFont(kFontIDGeneva);										TextSize(9);									end;								DrawCodonString(first, second, third);								if not printon then									TextFace([]);								DrawCodonAA(first, second, third);								if not printon then									if gencodeSel^[first, second, third] then										InvertInnerHiliteRect(box);							end;					end;			end;		FrameShadowRect(gencodeB);		DrawAAs;		for j := 1 to 4 do			DrawExtraAA(j);		DrawCodeName(theDialog);	end;{----------------------------------------------------------------------------}	procedure FindCodon (wh: point; var first, second, third: integer);		var			j, k, m: integer;	begin		first := -1;		second := -1;		third := -1;		for j := 0 to 3 do			for k := 0 to 3 do				for m := 0 to 3 do					if PtInRect(wh, gencodeR^[j, k, m]) then						begin							first := j;							second := k;							third := m;							leave;						end;	end;{----------------------------------------------------------------------------}	procedure SetCodons (aa: integer; theDialog: DialogPtr);		var			j, k, m: integer;			box: rect;			changedcode: boolean;	begin		changedcode := false;		for j := 0 to 3 do			for k := 0 to 3 do				for m := 0 to 3 do					if gencodeSel^[j, k, m] then						begin							gencode^[j, k, m] := aa;{GenCodeSel^[j, k, m] := false;     add this line if want to have auto deselect}							box := gencodeR^[j, k, m];							InvertInnerHiliteRect(box);							InsetRect(box, 1, 1);							box.left := box.left + 30;							EraseRect(box);							DrawCodonAA(j, k, m);							box := gencodeR^[j, k, m];  { remove this line if want to have auto deselect}							InvertInnerHiliteRect(box);  { remove this line if want to have auto deselect}							changedCode := true;						end;		if changedcode then			begin				myCheckMenuItem(GenCodeMHdl, theGeneticCode, false);				theGeneticCode := customCode;				DrawCodeName(theDialog);			end;	end;{----------------------------------------------------------------------------}	procedure DeSelectExtras;		var			j: integer;	begin		for j := 1 to 4 do			if extraSel[j] then				begin					extraSel[j] := false;					InvertHiliteRect(extraAAR[j]);				end;	end;{----------------------------------------------------------------------------}	procedure DeSelectGenCode;		var			j, k, m: integer;	begin		for j := 0 to 3 do			for k := 0 to 3 do				for m := 0 to 3 do					if gencodeSel^[j, k, m] then						begin							GenCodeSel^[j, k, m] := false;							InvertInnerHiliteRect(gencodeR^[j, k, m]);						end;	end;{----------------------------------------------------------------------------}	procedure FindAA (wh: point; var aa: integer);		var			j: integer;	begin		aa := -1;		for j := 0 to maxproteinstate do			if PtInRect(wh, aaR^[j]) then				begin					FlashBox(aaR^[j]);					aa := j;					leave;				end;	end;{----------------------------------------------------------------------------}	function GeneticCodeFilter (theDialog: DialogPtr; var Event: EventRecord; var localItemHit: INTEGER): BOOLEAN;		var			MouseLoc: Point;			WindoLoc, MyControl: integer;			theChar: char;			B: rect;			j, first, second, third, aa: integer;			redrawAAs, changedCode: boolean;	begin		MouseLoc := Event.Where;		WindoLoc := FindWindow(MouseLoc, Whichwindow);		GeneticCodeFilter := FALSE;		if (Event.what = keyDown) then			if HitReturn(Event) then				begin					localItemHit := PressButton(theDialog, 1);					GeneticCodeFilter := true;				end;		if (Event.what = mouseDown) & not Locked(lockAssumptions) then			begin				GlobalToLocal(Event.where);				if PTINRECT(event.where, GenCodeB) then					begin						FindCodon(Event.where, first, second, third);						if first >= 0 then							begin								if ShiftEvent(Event) then									begin										gencodeSel^[first, second, third] := not gencodeSel^[first, second, third];										InvertInnerHiliteRect(gencodeR^[first, second, third]);									end								else									begin										DeSelectGenCode;										DeSelectExtras;										gencodeSel^[first, second, third] := true;										InvertInnerHiliteRect(gencodeR^[first, second, third]);									end;							end;						GeneticCodeFilter := TRUE;						localItemHit := NotInDialog;					end				else if PTINRECT(event.where, aaB) then					begin						Findaa(Event.where, aa);						if (aa >= 0) then							if (aa <= maxAAstate) | (extraAAstates[aa - maxAAstate] >= 0) then								begin									SetCodons(aa, theDialog);									redrawAAs := false;									changedCode := false;									if aa <= maxAAstate then										for j := 1 to 4 do											if extraSel[j] then												begin													extraAAstates[j] := aa;													InvertHiliteRect(extraAAR[j]);													EraseRect(extraAAR[j]);													DrawExtraAA(j);													extraSel[j] := false;													redrawAAs := true;													EraseRect(aaR^[j + maxAAstate]);													changedCode := true;												end;									if changedCode then										begin											myCheckMenuItem(GenCodeMHdl, theGeneticCode, false);											theGeneticCode := customCode;											DrawCodeName(theDialog);										end;									if redrawAAs then										begin											DrawAAs;											EraseRect(WindowPortRect(myGetWindowPtrForDialog(theDialog)));											InvalidateWindowRect(myGetWindowPtrForDialog(theDialog),WindowPortRect(myGetWindowPtrForDialog(theDialog)),false);										end;									GeneticCodeFilter := TRUE;									localItemHit := NotInDialog;								end;					end				else					begin						if PtInRect(Event.where, extraRect) then							begin								if not ShiftEvent(Event) then									begin										DeSelectGenCode;										DeSelectExtras;									end;								for j := 1 to 4 do									if Ptinrect(Event.where, extraAAR[j]) then										begin											extraSel[j] := not extraSel[j] or ShiftEvent(Event);											InvertHiliteRect(extraAAR[j]);											GeneticCodeFilter := TRUE;											localItemHit := NotInDialog;											leave;										end;							end;					end;				LocaltoGlobal(Event.where);			end;	end;{-----------------------------------------------------------------------------}	procedure CheckDisjunctAAs;		label			1, 2;		var			j, k, m, aa, a, mut: integer;			foundone, disjunctAA: boolean;			disjunctAAs: aaset;			ds: str255;{........}		procedure NearestSameAA (j, k, m: integer);			var				mut: integer;		begin			for mut := 0 to 3 do				if aa = gencode^[mut, k, m] then					gencodeSel^[mut, k, m] := true;			for mut := 0 to 3 do				if aa = gencode^[j, mut, m] then					gencodeSel^[j, mut, m] := true;			for mut := 0 to 3 do				if aa = gencode^[j, k, mut] then					gencodeSel^[j, k, mut] := true;		end;{........}	begin		DeSelectGenCode;		disjunctAAs := [];{==== getting aa that are one step away ====}		for aa := 0 to maxProteinstate do			begin				disjunctAA := false;				foundone := false;				for j := 0 to 3 do					for k := 0 to 3 do						for m := 0 to 3 do							if aa = gencode^[j, k, m] then								begin									foundone := true;									goto 1;								end;1:				if foundone then					begin						NearestSameAA(j, k, m);						for a := 1 to 2 do							for j := 0 to 3 do								for k := 0 to 3 do									for m := 0 to 3 do										if gencodeSel^[j, k, m] then											NearestSameAA(j, k, m);						for j := 0 to 3 do							for k := 0 to 3 do								for m := 0 to 3 do									if (aa = gencode^[j, k, m]) and not gencodeSel^[j, k, m] then										begin											disjunctAAs := disjunctAAs + [aa];											goto 2;										end;2:						for j := 0 to 3 do							for k := 0 to 3 do								for m := 0 to 3 do									gencodeSel^[j, k, m] := false;					end;			end;		if disjunctAAs <> [] then			begin				ds := ' ';				for aa := 0 to maxproteinstate do					if aa in disjunctAAs then						ds := concat(ds, AminoAcidName(aa), ' ');				InstantInfo(concat('The following amino acids have disjunct codons : ', ds));			end		else			InstantInfo('No disjunct amino acids');	end;{universalCode = 1;}{universalExtendedCode = 2;}{drosophilaMTDNACode = 3;}{drosophilaMTDNAExtendedCode = 4;}{mammalMTDNACode = 5;}{mammalMTDNAExtendedCode = 6; }{yeastMTDNACode = 7;}{neurosporaMTDNACode = 8;}{customCode = 9;}{----------------------------------------------------------------------------}	procedure PopUpGenCodeMenu (theDialog: DialogPtr);		var			box: rect;			spot: point;			menucode: longint;			ItemNo, Menu_No, theItem: integer;			ds: str255;			db: boolean;			oldCode: integer;	begin		oldCode := theGeneticCode;		myValidRect(myGetWindowPtrForDialog(theDialog),WindowPortRect(myGetWindowPtrForDialog(theDialog)));		box := GetDLOGITemBox(theDialog, GenCodeMenuItem);		spot.v := box.bottom + 2;		spot.h := box.left;		LocalToGlobal(spot);		EnableDisableItem(GenCodeMHdl, customCode, theGeneticCode = customCode);		menucode := PopUpMenuSelect(GenCodeMHdl, spot.v, spot.h, theGeneticCode + 1);		Menu_No := HighWord(menucode);		ItemNo := LowWord(menucode);		if ItemNo > 0 then			if ItemNo = customCode then			else				theGeneticCode := ItemNo;		if oldCode <> theGeneticCode then			begin				if theGeneticCode <> customCode then					SetStandardCode(theGeneticCode);				EraseRect(WindowPortRect(myGetWindowPtrForDialog(theDialog)));				InvalidateWindowRect(myGetWindowPtrForDialog(theDialog),WindowPortRect(myGetWindowPtrForDialog(theDialog)),false);				myCheckMenuItem(GenCodeMHdl, oldCode, false);				myCheckMenuItem(GenCodeMHdl, theGeneticCode, true);			end;	end;{-----------------------------------------------------------------------------}	procedure GeneticCodeDLOG;		var			theDialog: DialogPtr;			tempH, itemsH: Handle;			box: RECT;			itemtype: integer;			tempP: WindowPtr;			j, k, m: integer;			first, second, third: integer;			top, bottom: integer;			ds: str255;			oldgencode: GenCodePtr;			oldExtraAAstates: ExtraCodes;			oldGeneticCode: integer;			extrasChanged: boolean;			localItemHit: integer;UserItemUProcP: UniversalProcPtr;DLOGFilterUPP: UniversalProcPtr;	begin		GenCodeMHdl := nil;		oldgencode := gencodePtr(NewPtr(SizeOf(gencodeArray)));		gencodeSel := gencodeboolPtr(NewPtr(SizeOf(gencodeboolarray)));		gencodeR := gencoderecPtr(NewPtr(SizeOf(gencoderecarray)));		aaR := aarecPtr(NewPtr(SizeOf(aarecarray)));		oldGeneticCode := theGeneticCode;		for j := 0 to 3 do			for k := 0 to 3 do				for m := 0 to 3 do					oldgencode^[j, k, m] := gencode^[j, k, m];		for j := 1 to 4 do			oldextraAAstates[j] := extraAAstates[j];		for j := 0 to 3 do			begin				RemapBase(j, second);				for k := 0 to 3 do					begin						RemapBase(k, first);						for m := 0 to 3 do							begin								RemapBase(m, third);								SetRect(gencodeR^[first, second, third], codeleft + j * (codewidth + 2), codetop + (k * 4 + m) * codeheight + k * 2 - 1, codeleft + (j + 1) * codewidth + j * 2, codetop + (k * 4 + m + 1) * codeheight + k * 2);								gencodeSel^[first, second, third] := false;							end;					end;			end;		RemapBase(0, top);		RemapBase(3, bottom);		SetRect(gencodeB, gencodeR^[top, top, top].left - 2, gencodeR^[top, top, top].top - 2, gencodeR^[bottom, bottom, bottom].right + 3, gencodeR^[bottom, bottom, bottom].bottom + 3);		for j := 0 to maxAAstate div 2 do			begin				SetRect(aaR^[j], aaleft, aatop + j * aaheight - 1, aaleft + aawidth, aatop + (j + 1) * aaheight);			end;		for j := maxAAstate div 2 + 1 to maxAAstate do			begin				SetRect(aaR^[j], aaleft + aawidth + 2, aatop + (j - maxAAstate div 2) * aaheight - 1, aaleft + 2 * aawidth + 2, aatop + (j - maxAAstate div 2 + 1) * aaheight);			end;		for j := 1 to 4 do			begin				SetRect(aaR^[maxAAState + j], extraleft, aatop - 5 + j * (aaheight + 5), extraleft + aawidth, aatop - 5 + (j + 1) * aaheight + j * 5);				extraAAR[j] := aaR^[maxAAstate + j];				OffSetRect(extraAAR[j], 35, 0);				extraSel[j] := false;			end;		SetRect(aaB, aaR^[0].left, aaR^[0].top, aaR^[maxproteinstate].right, aaR^[maxAAstate].bottom);   {also extras}		extraRect := extraAAR[1];		extraRect.bottom := extraAAR[4].bottom;		GenCodeMHdl := GetMenu(GenCodeMenu); {v3.05}		InsertMenu(GenCodeMHdl, -1);		myCheckMenuItem(GenCodeMHdl, theGeneticCode, true);				StartDLOG(567, theDialog, tempP);		myShowDialog(theDialog);		if Locked(lockAssumptions) then			begin				HideDialogItem(theDialog,2);				HideDialogItem(theDialog,7);				HideDialogItem(theDialog,8);			end;		SetRect(box, 1, 1, 2, 2);UserItemUProcP := MyNewUserItemUPP(@GeneticCodeUser);  tempH := Handle(UserItemUProcP);		SetDialogItem(theDialog, 3, UserItem, tempH, box);DLOGFilterUPP := MyNewModalFilterUPP(@GeneticCodeFilter);  		repeat			myModalDialog(DLOGFilterUPP, localItemHit);			case localItemHit of				5: 					begin						if not Locked(lockAssumptions) then PopUpGenCodeMenu(theDialog);					end;{$IFC FALSE}				5: 					begin						theGeneticCode := nuclearCode;						SetStandardCode(nuclearcode);						EraseRect(WindowPortRect(myGetWindowPtrForDialog(theDialog)));						InvalidateWindowRect(myGetWindowPtrForDialog(theDialog),WindowPortRect(myGetWindowPtrForDialog(theDialog)),false);					end;				6: 					begin						theGeneticCode := mtDNAcode;						SetStandardCode(mtDNAcode);						EraseRect(WindowPortRect(myGetWindowPtrForDialog(theDialog)));						InvalidateWindowRect(myGetWindowPtrForDialog(theDialog),WindowPortRect(myGetWindowPtrForDialog(theDialog)),false);					end;{$ENDC}				7: 					CheckDisjunctAAs;				8: 					begin						SetDialogValuesAsDefaults(theDialog, gencodeid, gencodenameid, gencodeextraid);						prefGeneticCode := theGeneticCode;{v3.05}					end;				otherwise					;			end;		until localItemHit in [1, 2];MyDisposeUserItemUPP(UserItemUProcP);MyDisposeModalFilterUPP(DLOGFilterUPP);		EndDLOG(theDialog, tempP);		if not Locked(lockAssumptions) then			if (localItemHit = 1) then				begin					RenameAAs;					extrasChanged := false;					for j := 1 to 4 do						if extraAAstates[j] <> oldExtraAAStates[j] then							extrasChanged := true;					dirtyfile := true;					if editorOpen then						InvalidateWindow(editorWindow, true);					InvalidateInfoWindow(taxinfo);				end			else				begin					for j := 0 to 3 do						for k := 0 to 3 do							for m := 0 to 3 do								gencode^[j, k, m] := oldgencode^[j, k, m];					for j := 1 to 4 do						extraAAstates[j] := oldextraAAstates[j];					theGeneticCode := oldGeneticCode;				end;		ZapPointer(gencodeSel);		ZapPointer(gencodeR);		ZapPointer(aaR);		ZapPointer(oldgencode);		myCheckMenuItem(GenCodeMHdl, theGeneticCode, false);		DeleteMenu(GenCodeMenu);	end;{$IFC CALCSYNREP}{-----------------------------------------------------------------------------}	procedure NumSynReplace (j, k, m: integer; var synon, replace: integer);		var			thisaa, mut: integer;	begin		replace := 0;		synon := 0;		thisaa := gencode^[j, k, m];		for mut := 0 to 3 do			if mut <> j then				if (thisaa = gencode^[mut, k, m]) then					synon := synon + 1				else if (thisaa <> 20) & (gencode^[mut, k, m] <> 20) then  {Note: 20 is Ter}					replace := replace + 1;		for mut := 0 to 3 do			if mut <> k then				if (thisaa = gencode^[j, mut, m]) then					synon := synon + 1				else if (thisaa <> 20) & (gencode^[j, mut, m] <> 20) then  {Note: 20 is Ter}					replace := replace + 1;		for mut := 0 to 3 do			if mut <> m then				if (thisaa = gencode^[j, k, mut]) then					synon := synon + 1				else if (thisaa <> 20) & (gencode^[j, k, mut] <> 20) then  {Note: 20 is Ter}					replace := replace + 1;	end;{-----------------------------------------------------------------------------}	procedure CalcNumSynonymous;{calculates number of synonymous and non-synonymous mutations for current genetic code}		var			j, k, m, thisaa, mut: integer;			replace, synon: integer;			totreplace, totsynon: integer;	begin		totreplace := 0;		totsynon := 0;		for j := 0 to 3 do			for k := 0 to 3 do				for m := 0 to 3 do					begin						NumSynReplace(j, k, m, synon, replace);						totsynon := totsynon + synon;						totreplace := totreplace + replace;					end;		InstantInfo(concat('GenCode: Synonymous mutations: ', StringFromNum(totsynon), '  Replacement mutations: ', StringFromNum(totreplace)));	end;{-----------------------------------------------------------------------------}	procedure CalcSynReplaceMatrix (useCodPos: boolean);		type			codontype = array[0..2] of largestsetchars;		var			totsynon, totreplace: longint;			charHdl: chHdl;			c: char;			lastcodechar: integer;			it, codpos, ic, firstchar: integer;			codons: codontype;			tsts: largestsetchars;			oldState: SignedByte;			warnmstaxa: boolean;{..................}		procedure AAset (codons: codontype);			type				cardarray = array[0..2] of longint;			var				j, k, m: integer;				tsts: largestsetchars;				cards: cardarray;				ucpresent, polympresent, mstaxpres: boolean;				synon, replace: integer;		begin			if not ((codons[0] * codons[1] * codons[2] = [0, 1, 2, 3, UCl, GAl]) or (codons[0] * codons[1] * codons[2] = [0, 1, 2, 3, UCl])) then				begin					ucpresent := false;					polympresent := false;					mstaxpres := false;					for j := 0 to 2 do						begin							cards[j] := cardLg(codons[j]);							if (cards[j] > 1) then								begin									if UCl in codons[j] then										ucpresent := true									else										polympresent := true;									mstaxpres := true;								end;						end;					if not mstaxpres then						begin							NumSynReplace(minLg(codons[0]), minLg(codons[1]), minLg(codons[2]), synon, replace);							totsynon := totsynon + synon;							totreplace := totreplace + replace;						end					else						warnmstaxa := true;				end;			codpos := 0;		end;{..................}	begin		SetCursor(clockCursor);		totsynon := 0;		totreplace := 0;		warnmstaxa := false;		if CodPosSet(1) then			firstchar := CharCodPos(1)		else			firstchar := 1;		for it := 1 to numtaxa do			begin				codpos := 0;				lastCodeChar := 0;				for ic := firstchar to numchars do					if IsCoding(ic) then						begin							charHdl := getchHdl(ic);							tsts := gettaxonstsLargest(it, ic);							if tsts = [MSl] then								tsts := [0, 1, 2, 3, UCl]							else if tsts = [MSl, GAl] then								tsts := [0, 1, 2, 3, UCl, GAl];{if ignore gaps, and still in string of continuous coding characters}							if (not useCodPos and (lastCodeChar = ic - 1)) then								begin									if not (GAl in tsts) then										begin											codons[codpos] := tsts;											codpos := codpos + 1;										end;								end{if consider gaps, and still in string of continuous coding characters, and codpos is as expected}							else if useCodPos and (lastCodeChar = ic - 1) and (codpos = CharHdl^^.codpos - 1) then								begin									codons[codpos] := tsts;									codpos := codpos + 1;								end{if start after non-coding region}							else if lastcodechar <> ic - 1 then								begin									codons[0] := tsts;									codpos := 1;								end{have to reset}							else								codpos := 0;							if codpos = 3 then  			{we've accumulated 3 codpos values}								AAset(codons);							lastcodeChar := ic;						end;			end;		InstantInfo(concat('Matrix: Synonymous mutations: ', StringFromNum(totsynon), '  Replacement mutations: ', StringFromNum(totreplace)));	end;{$ENDC}{-----------------------------------------------------------------------------}	procedure ConvertDNAtoAA (useCodPos: boolean);		const			newtcb = 4;		var			charHdl: chHdl;			ds: str255;			c: char;			dL: longint;			H: Handle;			oldHp: HdlPtr;			lastcodechar, numcharcoding, withinExonNumber, thePos, lastPos: integer;			it, codpos, ic, newnumchars, newchars, maxnewchars, firstchar, exonNumber: integer;			nameIt, atBoundary, exon: boolean;			codons: codontype;			tsts: largestsetchars;			SP31: SetPointer31;			oldState: SignedByte;{..................}{..................}	procedure CalcAASet (codons: codontype);	begin		SP31^ := AAFromCodon(codons, true);		SP31 := SetPointer31(ord4(SP31) + newtcb);					{setpointer to new first char of taxon it}		codpos := 0;		newchars := newchars + 1;	end;{..................}	begin		UnSelectAll;		if badcellEntry then 			Exit(ConvertDNAtoAA);		firstchar := 1;		for ic := 1 to numchars do			if (CharCodPos(ic) = 1) then   {find first base of position 1}				begin					firstchar := ic;					leave;				end;		numcharcoding := 0;		for ic := firstchar to numchars do			if iscoding(ic) then				numcharcoding := numcharcoding + 1;   {this gives maximum estimate}		newnumchars := numcharcoding div 3;		SetCursID(memory32);		H := NewHandle(newtcb * ord4(newnumchars));		for ic := 1 to numchars do			SetUnused1(ic, false);		SetUnused1(1, true);{notice that end of handles may be empty if enough gaps}		LockHandle(TaxstsCHUNKs, oldstate);		HLock(H);		maxnewchars := 0;		exon := false;		for it := 1 to numtaxa do			begin				SP31 := SetPointer31(GetMaster(H));					{setpointer to new first char of taxon it}				codpos := 0;				newchars := 0;				lastCodeChar := 0;				lastpos := nonCoding;				for ic := firstchar to numchars do					begin						thePos := CharCodPos(ic); 						if (ic > 1) & not (((lastPos = nonCoding) & (thePos = 1)) | (lastPos = thePos - 1) | ((lastPos = 3) & (thePos = 1))) then							begin								{ignore this one}								codpos := 0;							end						else if IsCoding(ic) then							begin																charHdl := getchHdl(ic);								tsts := PrepareTSTSforCodons(gettaxonstsLargest(it, ic));	{if ignore gaps, and still in string of continuous coding characters}								if (not useCodPos and (lastCodeChar = ic - 1)) then									begin										if not (GAl in tsts) then											begin												codons[codpos] := tsts;												codpos := codpos + 1;											end;									end	{if consider gaps, and still in string of continuous coding characters, and codpos is as expected}								else if useCodPos and (lastCodeChar = ic - 1) and (codpos = CharHdl^^.codpos - 1) then									begin										codons[codpos] := tsts;										codpos := codpos + 1;									end	{if start after non-coding region}								else if lastcodechar <> ic - 1 then									begin										codons[0] := tsts;										codpos := 1;									end	{have to reset}								else									codpos := 0;			{start again}								if codpos = 3 then  			{we've accumulated 3 codpos values}									begin										CalcAASet(codons);										if (it = 1) & not exon then {we are at start of new exon boundary}											begin												SetUnused1(newchars, true);   {mark it}												exon := true;											end;									end;								lastcodeChar := ic;								lastpos := thePos;							end						else if (it = 1) & exon then   {at end of boundary}							begin								SetUnused1(newchars, true);   {mark it}								exon := false;								lastpos := thePos;							end;											end;{newchars is the actual number of chars made for taxon it}{newnumchars is the maximum value of newchars if no gaps are present}{maxnewchars is the actual maximum value of newchars}				if newchars < newnumchars then					for ic := newchars + 1 to newnumchars do		{fill in extras with missing bit}						begin							SP31^ := [MSl];							SP31 := SetPointer31(ord4(SP31) + newtcb);						end;				if newchars > maxnewchars then					maxnewchars := newchars;				oldHp := HdlPtr(GetMaster(TaxstsCHUNKs) + HdlSize * (it - 1));				CopyHandles(H, oldHp^);			end;		HUnLock(H);		ZapHandle(H);		ResetHandle(TaxstsCHUNKs, oldstate);		if maxnewchars = 0 then			begin				DestroyCharacterInfo(2, numchars, false, false);				EmptyCharacters(1, 1);				NewError(326, 0);			end		else			DestroyCharacterInfo(maxnewchars + 1, numchars, false, false);		DestroyAllCharacterChains;		DestroyFeet(footText, 1, numchars, true);		DestroyFeet(footPict, 1, numchars, true);		ReCalcMaxstAndStates(1,numchars);		for ic := 1 to numchars do			begin				charHdl := getchHdl(ic);				charHdl^^.name := ' ';				charHdl^^.namebackup := ' ';				charHdl^^.deleted := false;				charHdl^^.footText := false;				charHdl^^.footPict := false;				charHdl^^.constant := false;				charHdl^^.charSet := false;				charHdl^^.MSTTree := false;				charHdl^^.MSTData := false;				charHdl^^.infoSelected := false;				charHdl^^.otherSelected := false;				charHdl^^.extra := false;				SetType(ic, deftype);				UseToTypeStorage(ic);				SetWeight(ic, 1);				UseToWtStorage(ic);				SetPartition(ic,defaultPartition);				UseToPartStorage(ic);			end;{$IFC TRUE}		exonNumber := 0;		exon := false;		for ic := 1 to numchars do			begin				atBoundary := getchHdl(ic)^^.unused1;				nameIt := false;				if exon then					begin						nameIt := true;						withinExonNumber := withinExonNumber + 1;						if atBoundary then  {must be leaving it}							exon := false;					end				else if atBoundary then  {we are at a new exon}					begin						withinExonNumber := 1;						exonNumber := exonNumber + 1;						nameIt := true;						exon := true;					end;				if nameIt then					begin						ds := concat(StringFromNum(exonNumber), '.', StringFromNum(withinExonNumber));						SetCharName(ic, ds);					end;			end;		for ic := 1 to numchars do			SetUnused1(ic, false);{$ENDC}		infoSomeSelected[charinfo] := false;		numcharin := numchars;		AdjustStuff(true);	end;end.