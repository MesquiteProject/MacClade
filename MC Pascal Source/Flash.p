unit Flash;{본본본본본본본본본본본볗interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, 		GenUtil, StrUtil, BoxUtil, CharUtil, TaxonCHUtil, TreeUtil,SpreadUtil,FlashUtil, EditorUndo;	procedure FlashSplitMultiActive;	procedure FlashSimilarSequence;	procedure CalcEditorFlashRegion;{본본본본본본본본본본본볗implementation{-----------------------------------------------------------------------------}	procedure FlashRegion3(flashRgn: RgnHandle; resid: integer);	const delaylength = 2;	var		 thePat: pattern;	begin		PenMode(patXor);		GetIndPattern(thePat, resid, 1);		PenPat(thePat);		PaintRgn(flashRgn);		delay(delaylength,ticks);		PaintRgn(flashRgn);		//delay(delaylength,ticks);		GetIndPattern(thePat, resid, 2);		PenPat(thePat);		PaintRgn(flashRgn);		delay(delaylength,ticks);		PaintRgn(flashRgn);		PenNormal;		{InvertRgn(flashRgn);		Delay(8,ticks);		InvertRgn(flashRgn);}	end;{-----------------------------------------------------------------------------}	procedure FlashRegion(flashRgn: RgnHandle; resid: integer);	const delaylength = 1;	var		 thePat: pattern;		 iPat: integer;	begin		PenMode(patXor);		for iPat := 1 to 9 do			begin				GetIndPattern(thePat, 129, iPat);				PenPat(thePat);				PaintRgn(flashRgn);				delay(delaylength,ticks);				//PaintRgn(flashRgn);				//delay(delaylength,ticks);			end;		PenNormal;	end;{-----------------------------------------------------------------------------}	procedure FlashRegion2(flashRgn: RgnHandle; resid: integer);	const delaylength = 2;	var		 thePat: pattern;	begin		PenMode(patXor);		GetIndPattern(thePat, resid, 1);		PenPat(thePat);		PaintRgn(flashRgn);		delay(delaylength,ticks);		PaintRgn(flashRgn);		PenNormal;		{InvertRgn(flashRgn);		Delay(8,ticks);		InvertRgn(flashRgn);}	end;{-----------------------------------------------------------------------------}	function GetFlashRect(itstart,itend,icstart,icend: integer): rect;	var TL, BR: point;		d, top, bottom, right, left: integer;		box: rect;	begin		if icstart< firstVisibleCharacter then			icstart := firstVisibleCharacter;		if icend> lastVisibleCharacter then			icend := lastVisibleCharacter;		RowColumnFromTaxonCharacter(itstart,icstart,TL.v,TL.h);		RowColumnFromTaxonCharacter(itend,icend,BR.v,BR.h);		CellVer(TL.v,top,d,false);		CellVer(BR.v,d,bottom,false);		CellHor(TL.h,left,d,false);		CellHor(BR.h,d,right,false);		SetRect(box,left,top,right,bottom);		GetFlashRect:= box;	end;{-----------------------------------------------------------------------------}	procedure FlashSplitMultiActive;	var tport: WindowPtr;	begin		CalcSplitMultiFlashRegion;							if not EmptyRgn(theflashRgn) then			begin				genericGetPort(tport);				genericSetPort(editorWindow);			{	tempRgnOuter:= NewRgn;				tempRgnInner:= NewRgn;				RectRgn(tempRgnOuter,box);				InsetRect(box,3,3);				RectRgn(tempRgnInner,box);				DiffRgn(tempRgnOuter,tempRgnInner,theFlashRgn);				ZapRegion(tempRgnOuter);				ZapRegion(tempRgnInner);}				FlashRegionNew;				ClipRect(WindowPortRect(editorWindow));				genericSetPort(tport);			end;	end;{-----------------------------------------------------------------------------}	function SetUpCompactBlockP(compactCellPtr: CellBlockPtr; it: integer): boolean;	var 	BR, TL: point;	begin		if editorTransposed then			begin				SetPt(BR,it, numchars);				SetPt(TL,it, 1);			end		else			begin 				SetPt(BR,numchars, it);				SetPt(TL,1, it);			end;		SetUpCompactBlockP := StoreDataIntoCellBlock(compactCellPtr,BR,TL, true, true, true,false, true,false);	end;{-----------------------------------------------------------------------------}	function SetUpRNARCBlockP(it: integer; compact: boolean): boolean;	var 	BR, TL: point;	begin		if editorTransposed then			begin				SetPt(BR,it, flashRNARCLastChar);				SetPt(TL,it, flashRNARCFirstChar);			end		else			begin 				SetPt(BR,flashRNARCLastChar, it);				SetPt(TL,flashRNARCFirstChar, it);			end;		SetUpRNARCBlockP := StoreDataIntoCellBlock(EWFindRNARCBlockP,BR,TL, true, true, true,true, compact,false);	end;	procedure cycleCellBlock(compactCellPtr: CellBlockPtr);	var ic: integer;		tsts: largestSetChars;		db: boolean;	begin		db:= false;		for ic := 1 to compactCellPtr^.nChar do			begin				tsts := CellBlockStates(compactCellPtr,1,ic,1, db);				db:= false;			end;	end;{-----------------------------------------------------------------------------}	procedure FlashSimilarSequence;	var ic, icstart, icend: integer;		 it: integer;		 itStart, itEnd, endFlashChar,startFlashChar: integer;		 similarP, originalP: Ptr;		 oldstate1,oldstate2, oldState3: SignedByte;		 taxStsH: Handle;		 tPort: WindowPtr;		 flashRgn, flashRgn2: RgnHandle;		 numFlashChars: integer;		 tempRgnOuter, tempRgnInner: RgnHandle;		 box: rect;		 compactCellPtr: CellBlockPtr;	begin		if editorOpen  & isforeground & (IsEditorWindow(frontwindow))  & (FlashNonCodonsInEditor | ((editorFlashMode=flashFindSequence) & (EWFindSequenceBlockP^.ntax+EWFindSequenceBlockP^.nchar>0)) | ((editorFlashMode=flashRNAReverseComplement) & flashRNARCHasLegalOriginalBlock & nucleotides)) then			begin				CreateCellBlock(compactCellPtr);				genericGetPort(tport);				genericSetPort(editorWindow);				flashRgn:= NewRgn;				flashRgn2 := NewRgn;				tempRgnOuter:= NewRgn;				tempRgnInner:= NewRgn;								case editorFlashMode of					flashFindSequence:						begin							numFlashChars := EWFindSequenceBlockP^.nchar;							LockHandle(EWFindSequenceBlockP^.H, oldstate1);							similarP := Ptr(GetMaster(EWFindSequenceBlockP^.H));							itStart := FirstVisibleTaxon;							itEnd := LastVisibleTaxon;						end;					flashNonCodons:						begin							numFlashChars := 3;							itStart := FirstVisibleTaxon;							itEnd := LastVisibleTaxon;						end;					flashRNAReverseComplement:						begin							numFlashChars := (flashRNARCLastChar-flashRNARCFirstChar+1);							itStart := flashRNARCFirstTax;							itEnd := flashRNARCLastTax;							box := GetFlashRect(flashRNARCFirstTax,flashRNARCLastTax,flashRNARCFirstChar,flashRNARCLastChar);							if not EmptyRect(box) then								begin									RectRgn(tempRgnOuter,box);									InsetRect(box,5,5);									RectRgn(tempRgnInner,box);									DiffRgn(tempRgnOuter,tempRgnInner,tempRgnOuter);									UnionRgn(tempRgnOuter,flashRgn2,flashRgn2);								end;						end;					otherwise;				end;				icstart := FirstVisibleCharacter - numFlashChars +1;				if icstart < 1 then icstart := 1;				icend := LastVisibleCharacter;				if icend + numFlashChars - 1 > numchars then					icend := numchars - numFlashChars+1;				for it := itStart to itEnd do					begin						taxStsH:= GetTaxStsHdl(it);						LockHandle(taxStsH, oldstate2);						case editorFlashMode of							flashFindSequence:								begin									if flashFindIgnoreGaps then										begin											if not SetUpCompactBlockP(compactCellPtr,it) then												begin													ResetHandle(taxStsH, oldstate2);													leave;												end;											icStart := 1;											icEnd := compactCellPtr^.nchar - numFlashChars+1;											if icEnd<=2 then leave;											LockHandle(compactCellPtr^.H, oldstate3);											originalP := Ptr(GetMaster(compactCellPtr^.H));										end;								end;							flashRNAReverseComplement:								begin									if CheckIfAllGaps(it, it, flashRNARCFirstChar, flashRNARCLastChar,true) then										begin											ResetHandle(taxStsH, oldstate2);											cycle;										end;									if not SetUpRNARCBlockP(it,flashRNARevCompIgnoreGaps) then 										begin											ResetHandle(taxStsH, oldstate2);											leave;										end;									LockHandle(EWFindRNARCBlockP^.H, oldstate1);									similarP := Ptr(GetMaster(EWFindRNARCBlockP^.H));									if flashRNARevCompIgnoreGaps then										begin											if not SetUpCompactBlockP(compactCellPtr,it) then												begin													ResetHandle(taxStsH, oldstate2);													leave;												end;											icStart := 1;											icEnd := compactCellPtr^.nchar - numFlashChars+1;											LockHandle(compactCellPtr^.H, oldstate3);											originalP := Ptr(GetMaster(compactCellPtr^.H));										end;								end;							otherwise;						end;						ic := icStart;						repeat							SetRect(box,0,0,0,0);							case editorFlashMode of 								flashFindSequence:									begin										if flashFindIgnoreGaps then											begin												if ComparePointers (nil, findSequenceMatchMustBeExact, findSequenceRespectCase,false, EWFindSequenceBlockP^.blockNumBytes,similarP,originalP,EWFindSequenceBlockP^.nchar,findNumMismatches) then													begin														startFlashChar := CharacterNumberOfDataCellNumber(it, ic);														endFlashChar := CharacterNumberOfDataCellNumber(it, ic+EWFindSequenceBlockP^.nchar-1);														box := GetFlashRect(it,it,startFlashChar,endFlashChar);													end;												originalP := Ptr(ord4(originalP)+compactCellPtr^.blocktcb);											end										else 											begin												originalP:=GetSetPtr(it,ic);												if ComparePointers (nil, findSequenceMatchMustBeExact, findSequenceRespectCase,false, EWFindSequenceBlockP^.blockNumBytes,similarP,originalP,EWFindSequenceBlockP^.nchar,findNumMismatches) then													box := GetFlashRect(it,it,ic,ic+EWFindSequenceBlockP^.nchar-1);											end;										ic := ic+1;									end;								flashRNAReverseComplement:									begin										if flashRNARevCompIgnoreGaps then											begin												if ComparePointers (nil, false, false,false, EWFindRNARCBlockP^.blockNumBytes,similarP,originalP,EWFindRNARCBlockP^.nchar,flashRNARevCompNumMismatches) then													begin														startFlashChar := CharacterNumberOfDataCellNumber(it, ic);														endFlashChar := CharacterNumberOfDataCellNumber(it, ic+numFlashChars-1);														box := GetFlashRect(it,it,startFlashChar,endFlashChar);													end;												originalP := Ptr(ord4(originalP)+compactCellPtr^.blocktcb);											end										else 											begin												originalP:=GetSetPtr(it,ic);												if ComparePointers (nil, false, false,false, EWFindRNARCBlockP^.blockNumBytes,similarP,originalP,EWFindRNARCBlockP^.nchar,flashRNARevCompNumMismatches) then													box := GetFlashRect(it,it,ic,ic+numFlashChars-1);											end;										ic := ic+1;									end;								flashNonCodons:									begin										if (CharCodPos(ic) = 1) & (CharCodPos(ic+1)=2) & (CharCodPos(ic+2)=3) then 											begin												if not CheckIfAllGaps(it,it,ic,ic+2, editorToolsTreatMissingAsGaps) then {some non-gaps}													if IsGapLike(it,ic,editorToolsTreatMissingAsGaps) | IsGapLike(it,ic+1,editorToolsTreatMissingAsGaps) | IsGapLike(it,ic+2,editorToolsTreatMissingAsGaps) then														box := GetFlashRect(it,it,ic,ic+2);												ic := ic+3;											end										else											ic := ic+1;									end;								otherwise;							end;							if not EmptyRect(box) then								begin									RectRgn(tempRgnOuter,box);									InsetRect(box,3,3);									RectRgn(tempRgnInner,box);									DiffRgn(tempRgnOuter,tempRgnInner,tempRgnOuter);									UnionRgn(tempRgnOuter,flashRgn,flashRgn);								end;						until ic>icend;						if editorFlashMode=flashRNAReverseComplement then							begin								ResetHandle(EWFindRNARCBlockP^.H, oldstate1);								EmptyCellBlock(EWFindRNARCBlockP);							end;						if compactCellPtr<>nil then							begin								ResetHandle(compactCellPtr^.H, oldstate3);								EmptyCellBlock(compactCellPtr);							end;						ResetHandle(taxStsH, oldstate2);					end;									case editorFlashMode of					flashFindSequence:						ResetHandle(EWFindSequenceBlockP^.H, oldstate1);					otherwise;				end;				if not EmptyRgn(flashRgn) then					begin						SetEWClip(justData);						SetClip(EWClip);						FlashRegion(flashRgn,128);						if editorFlashMode=flashRNAReverseComplement then							begin								ForeColor(blueColor);								FlashRegion2(flashRgn2,130);								ForeColor(blackColor);							end;						SetEWClip(noscroll);					end;				ClipRect(WindowPortRect(editorWindow));				genericSetPort(tport);				ZapRegion(flashRgn);				ZapRegion(flashRgn2);				ZapRegion(tempRgnOuter);				ZapRegion(tempRgnInner);				DestroyCellBlock(compactCellPtr);			end;	end;end.