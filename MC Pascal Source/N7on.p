unit N7on;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  ControlDefinitions,		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, 		EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, CharUtil, TreeUtil, MenuUtil, Legends, TrackThumb;	function N7Height (ic: integer): integer;	procedure Nex7Line (ic, itstart, itend: integer; N: Nptr; height: integer; fromtree: boolean);	procedure NextSevenChars;	procedure ScrollN7UpDown (whichcontrol: ControlRef; theCode: INTEGER);	procedure DoDataBoxScroll (wh: point);	procedure InitNumBoxes;{еееееееееееееееееееееее}implementation {е$S N7on}{-----------------------------------------------------------------------------}	procedure N7BoundaryLine;		var			oldRgn: RgnHandle;	begin		oldRgn := NewRgn;		GetClip(oldRgn);		ClipRect(WindowPortRect(treeWindow));		movetoOrient(0, dataBoxB.bottom - n7splitW);		LinetoOrient(WindowPortRect(treeWindow).right, dataBoxB.bottom - n7splitW);		PenPat(QDGray);		PenSizeOrient(n7splitW - 1, n7splitW - 1);		movetoOrient(0, dataBoxB.bottom - (n7splitW - 1));		LinetoOrient(WindowPortRect(treeWindow).right, dataBoxB.bottom - (n7splitW - 1));		PenNormal;		movetoOrient(0, dataBoxB.bottom);		LinetoOrient(WindowPortRect(treeWindow).right, dataBoxB.bottom);		PenNormal;		SetClip(oldRgn);		ZapRegion(oldRgn);	end;{-----------------------------------------------------------------------------}	function N7Height (ic: integer): integer;{gives the vertical position of the bottom of the N7Height line}	begin{$IFC FLIPTREE}		if treeflipped then			N7Height := dataBoxb.bottom + 1 - (ic - i7 + 1) * n7LW		else{$ENDC}			N7Height := dataBoxb.top - 1 + (ic - i7 + 1) * n7LW;	end;{---------------------------------------------------------------------}	procedure offsetRectTreeToTrueOrient (var r: rect; h, v: integer);  {Davidv4.1: just adjust others???}{offsets rectangle in window coordinates to correspond to  h,v in tree coordinates}	begin{$IFC FLIPTREE}		if Treeflipped then			offSetRect(r, visTWR.right + v, h)		else{$ENDC}			offSetRect(r, h, v);	end;{-----------------------------------------------------------------------------}	procedure Nex7Line (ic, itstart, itend: integer; N: Nptr; height: integer; fromtree: boolean);		var			TaxonHdl: thdl;			box: rect;			j: integer;			ds: str255;			patsize, localtxsp: integer;			usepat: PATTERN;			UseColor: RGBColor;{------------}		procedure N7Box (it: integer);		begin			TaxonHdl := gettaxonhdl(it);			box := taxonHdl^^.B;			offsetRect(box, 0, height + 2 - taxonHdl^^.B.top-n7LW);{TreeToTrueOrient}  {was -topmargin}			FindPat(usepat, usecolor, gettaxonstslargest(it, ic), ic, traceDiscrete);			if printon then				begin					if printDataBoxesInColor then						RGBForeColor(usecolor);				end			else if ((branchShades[traceDiscrete] <> branchPatterns) & ColorPort) then				RGBForeColor(usecolor);			FillRectOrient(box, usepat);  {don't need orient as already flipped}			if printon then				begin					if printDataBoxesInColor then						RGBForeColor(blackRGB);				end			else if (branchShades[traceDiscrete] <> branchPatterns) & ColorPort then				RGBForeColor(blackRGB);			FrameRectOrient(box);   {Don't need Orient as already flipped}{$IFC SHADOWTREE}			if shadowTree then				shadowBox(box);{$ENDC}		end;{...................}		procedure N7Boxes (N: Nptr);		begin			if NodeIsInternal(N) then				begin					N7Boxes(N^.lf);					N7Boxes(N^.rt);				end			else if not Qtaxon(N, ic) then				begin					N7Box(N^.name);					HiliteDataBox(box, N^.name, ic);				end;		end;{...................}	begin		if ic <= numchars then			begin{GrayScaleStates := [];}				GrayScaleStates := CalcLegendStates(ic);				if not printon then					begin						movetoOrient(18, height - 4);						LinetoOrient(dataBoxB.right, height - 4);					end				else					begin						if fromtree then							begin{GrayScaleStates := CalcLegendStates(ic);}								localtxsp := laser^.txsp;								movetoOrient(firsttx, height - 4);								LinetoOrient(firsttx + (ntscreen - 1) * laser^.txsp, height - 4);							end						else							begin								localtxsp := txsp;								movetoOrient(firsttx, height - 4);								LinetoOrient(firsttx + (itend - itstart + 1) * txsp, height - 4);							end;					end;  {v4: make these thin lines!}{ClipRect(databoxB);}				if fromtree then					N7Boxes(N)				else					for j := itstart to itend do						if not (msl in gettaxonstslargest(j, ic)) then							N7Box(j);{======= writing number at left hand edge =======}				NumToString(ic, ds);				if printon then					movetoOrient(firsttx - StringWidth(StringFromNum(numchars)) - 3, height - 1)				else					begin						SetRect(box, 0, height + 2 - n7LW, StringWidth(ds) + 2, height);						EraseRectOrient(box);						if ic < 100 then							movetoOrient(2, height - 1)						else							movetoOrient(0, height - 1);					end;				DrawStringOrient(ds);			end;	end;{-----------------------------------------------------------------------------}	procedure NextSevenChars;        {shows boxes for next 7 chars}		var			ic, j: INTEGER;			claderect, box: rect;			trgn: RgnHandle;	begin		textFace([]);		tRgn := NewRgn;		GetClip(tRgn);		RecalcBoxes;		if i7 + numboxes > numchars then			begin				i7 := IntegerMax(numchars - numboxes + 1, 1);				SetControlValueLong(databoxScroll, i7);			end;		if (drawR <> screenR) then			begin				Setrect(claderect, LeftEdgeOfClade(DrawR,false, false) - 1, databoxB.top, RightEdgeOfClade(DrawR,false,false) + 2, databoxB.bottom);				ClipRectOrient(claderect);				EraseRectOrient(claderect);			end		else if not TWScrolling then			begin				box := dataBoxB;				box.left := 0;				box.top := 0;				ClipRectOrient(box);				EraseRectOrient(box);				box := dataBoxB;				box.bottom := box.bottom + 1;				ClipRectOrient(box);			end;		ic := i7;		N7BoundaryLine;		for j := 1 to numboxes do			begin				Nex7Line(ic, 1, numtaxa, ScreenR, N7Height(ic), true);				ic := ic + 1;				if ic > numchars then					leave;			end;		textfont(TWFont);		textFace(TWstyle);		SetClip(tRgn);		ZapRegion(tRgn);	end;{-----------------------------------------------------------------------------}	function WindowRectFullyVisible (whichwindow: WindowPtr; box: rect): boolean;{returns true if the rectangle box (in whichwindow) is fully visible (that is, has no windows in front of it)}		var			boxRgn, boxVisRgn, windowVisRgn: RgnHandle;	begin		boxRgn := NewRgn;		boxVisRgn := NewRgn;		windowVisRgn := NewRgn;		CopyRgn(myGetVisRgn(treeWindow), windowVisRgn);		RectRgn(boxRgn, box);		SectRgn(boxRgn, windowVisRgn, boxVisRgn);		WindowRectFullyVisible := EqualRgn(boxRgn, boxVisRgn);		ZapRegion(boxRgn);		ZapRegion(boxVisRgn);		ZapRegion(windowVisRgn);	end;{-----------------------------------------------------------------------------}	procedure Scrollnex7;		var			dv: integer;			oldClip: RgnHandle;			box: rect;	begin		oldClip := NewRgn;		GetClip(oldClip);		ClipRectOrient(dataBoxB);		dv := GetControlValueLong(databoxScroll) - i7;		i7 := i7 + dv;		databoxB.bottom := dataBoxB.bottom - n7splitW - 1;{$IFC FLIPTREE}		if treeflipped then			ScrollRect(OrientRect(dataBoxB), -dv * n7LW, 0, updateRgn)		else{$ENDC}			ScrollRect(OrientRect(dataBoxB), 0, -dv * n7LW, updateRgn);		databoxB.bottom := dataBoxB.bottom + n7splitW + 1;		SetClip(updateRgn);		box := databoxB;		if twfullscreen then			box.top := box.top + 1;{(locklegends & (numboxes < 11) & twfullscreen & not toolPaletteOpen[treeTools] & (not (traceshown = traceDiscrete) or (numbytes < 4))))}{$IFC FLIPTREE}		if (dv = 1) & (treeflipped | WindowBotRightOnScreen(treewindow, true, databoxB.bottom)) & (WindowRectFullyVisible(treewindow, OrientRect(box))) then   {scrolling boxes up}{$ELSEC}			if (dv = 1) & WindowBotRightOnScreen(treewindow, true, databoxB.bottom) & (WindowRectFullyVisible(treewindow, OrientRect(box))) then   {scrolling boxes up}{$ENDC}				begin					Nex7Line(i7 + numboxes - 1, 1, numtaxa, ScreenR, N7Height(i7 + numboxes - 1), true);				end			else if (dv = -1) & WindowRectFullyVisible(treewindow, OrientRect(box)) then				Nex7Line(i7, 1, numtaxa, ScreenR, N7Height(i7), true)			else if dv <> 0 then				NextSevenChars;		SetClip(OldClip);		ZapRegion(oldClip);		textfont(TWFont);	end;{----------------------------------------------------------------------------}	procedure ScrollN7UpDown (whichcontrol: ControlRef; theCode: INTEGER);	begin		if scrollup then			begin				if theCode = kControlUpButtonPart then					begin						SetControlValueLong(whichControl, GetControlValueLong(whichControl) - 1);						Scrollnex7					end			end		else if theCode = kControlDownButtonPart then			begin				SetControlValueLong(whichControl, GetControlValueLong(whichControl) + 1);				Scrollnex7			end	end;{-----------------------------------------------------------------------------}	procedure DoDataBoxScroll (wh: point);		var			MyControl, t: integer;			mypt: point;	begin		MyControl := FindControl(wh, treeWindow, databoxScroll);		if whichControl= nil then Exit(DoDataBoxScroll);		ClipRect(WindowPortRect(treeWindow));		case MyControl of			kControlUpButtonPart: 				begin					scrollup := true;					t := myTrackControl(databoxScroll, wh, ScrollN7UpDownUPP);				end;			kControlDownButtonPart: 				begin					scrollup := false;					t := myTrackControl(databoxScroll, wh, ScrollN7UpDownUPP);				end;			kControlPageUpPart: 				repeat					GetMouse(myPt);					if TestControl(databoxScroll, myPt) = mycontrol then						begin							SetControlValueLong(databoxScroll, GetControlValueLong(databoxScroll) - numboxes);							Scrollnex7						end				until not StillDown;			kControlPageDownPart: 				repeat					GetMouse(myPt);					if TestControl(databoxScroll, myPt) = mycontrol then						begin							SetControlValueLong(databoxScroll, GetControlValueLong(databoxScroll) + numboxes);							Scrollnex7						end				until not StillDown;			kControlIndicatorPart: 				begin{$IFC TRACKPAGENUMBERS}					TrackFeedbackThumb(databoxScroll,wh, treeWindow);{$ELSEC}												t := myTrackControl(databoxScroll, wh, nil);{$ENDC}					Scrollnex7;				end;			otherwise				;		end;	end;{-----------------------------------------------------------------------------}	procedure InitNumBoxes;	begin		numboxes := defaultNumBoxes;{    if numchars < numboxes then numboxes := numchars;}{    displace7 := dataBoxB.top + numboxes * n7LW - nattop + 10;orient:}	end;end.