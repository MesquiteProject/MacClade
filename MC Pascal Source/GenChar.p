unit GenChar;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, CharUtil, TreeUtil, Polycalc, Calc, TypeUtil, UtilLibInterface, SetLibInterface;	function GNabove (ND: Nptr; iq: integer): integer;	function GNbelow (ND: Nptr; iq: integer): integer;	procedure GenDownPass (qN: Nptr; ic: integer; traced: boolean);	procedure GenUpCalcNode (N: Nptr; maxdef: integer; traced: boolean);	procedure GenUpPass (qN: Nptr; ic: integer; traced: boolean);	procedure GenTriplePass (qN: Nptr; ic: integer; traced: boolean);{еееееееееееееееееееееее}implementation {е$S GenChar}	var		error16, error25: boolean;{##############  GENERAL STEPMATRIX PARSIMONY ALGORITHMS  #########################}{User-defined characters store how good is each state in a longinteger array, one element for }{each state.  There is a downstate array (gndst), saying for each state s how many steps are required in the }{clade above the node given s is placed at the node, and an upstate array (gupst), saying for each state}{s how many steps are required below and beside the node given s is placed at the node.}{Because each gdnst and gupst arrays are so large (up to 26 longintegers each), MacClade does}{not made such storage for every character at every node.  Thus each node has only one}{gdnst and only one gupst array, which must be reused for each character.}{----------------------------------------------------------------}	function GNabove (ND: Nptr; iq: integer): integer;{FROZEN 3.0}{Given "iq" at node below ND, calculates number of states ND^anc to ND & above}{  е---е }{   \ /  }{    ND  }{   /    }{  е     }		var			ir: integer;			min, num: longint;	begin		min := infinity;{Checks all possible assignments to ND for one minimizing length ND^anc and above,}{given that state iq is at ND^.anc}		for ir := 0 to maxdefgen do			begin				num := AddGenDist(ddist[iq, ir], ND^.gdnst[ir]);				if GenLessThan(num, min) then  {better ir is found to place at ND, record total length}					min := num;			end;		GNabove := min;	end;{-----------------------------------------------------------------------------}	function GNbelow (ND: Nptr; iq: integer): integer;{FROZEN 3.0}{Given "iq" at node ND, calculates number of steps ND to ND^anc & below.}{Remember that ND^.gupst[ir] is the number of steps below and beside ND}{given that ir is placed at ND's ancestor, not at ND.  Thus number of steps}{ND to ND^.anc and below is calculated from sum of steps ND to ND^.anc and}{ND^.gupst}{     е   ND}{      | \ / }{      |   е  }{      | /   }{     е    }		var			ir: integer;			min, num: longint;	begin		min := infinity;{Checks all possible assignments to ND for one minimizing length ND^anc and below}		for ir := 0 to maxdefgen do			begin				num := AddGenDist(ND^.gupst[ir], ddist[ir, iq]);				if GenLessThan(num, min) then {better ir is found to place at ND, record total length}					min := num;			end;		GNbelow := min;	end;{========================================================================}	procedure GenSetTaxDnst (N: Nptr; ic: integer; traced: boolean);{FROZEN 3.0}{Sets downpass states for terminal node N, for character ic.}{traced is true if the character is the traced character (thus fixing of states allowed)}		var			minL, maxL: integer;			ir, ib: integer;			tsts: lgsetchars;			terror: boolean;			cardtsts: integer;			cab, cba, cbca, smalles, tcost, wasdnstfix: longint;			tempgdnst: gentype;	begin		tsts := NewSetFromOld(gettaxonstslargest(N^.name, ic));		cardtsts := cardg(tsts);  {find out how many states in taxon states}		N^.gdnst := genInf;  {initialize cost of any state to infinity; adjust later}		if cardtsts <= 1 then			begin				if not Enset(MSl, tsts) then {monomorphic: set cost of state to infinity except for observed states, set to 0}					N^.gdnst[minG(tsts)] := 0				else					N^.gdnst := genzero;  {missing: set cost of state to 0 for all states}			end		else if Enset(Ucl, tsts) then			begin  {uncertain: set cost of state to infinity except for observed states, set to 0}				for ir := 0 to maxdefgen do					if Enset(ir, tsts) then						N^.gdnst[ir] := 0;			end		else if (cardtsts > 2) then  {polymorphic 3 or more }			begin  {remember, costs already initialized to infinity}				terror := true;				for ir := 0 to maxdefgen do		{For all possible states ir, set cost to smallest distance to any other state ib.  }		{This is done as a guess.  Best would be to set the cost to the smallest spanning tree starting}		{with state ir and going to every other state observed in the terminal taxon.  This would tell us how much}		{it would cost to evolve all other state observed in the terminal taxon, given state ir were put at the base}		{of the terminal taxon.  This calculation would be much more involved and probably very slow, }		{so it is not done.  Some alternatives are (1) to ignore the distances within terminal taxa polymorphic}		{for more than three states (this used to be done in version 2.1 I believe), (2) to get only part}		{of the spanning tree, namely the first branch from ir to the next state, and use the closest}		{other state.  The latter would be done because it is clear that the spanning tree must be at least }		{as long as the distance to the nearest state.  However, it is only a crude approximation.  For this}		{reason, whenever MacClade has to use this alternative, it gives a warning (error 25)}					begin						if Enset(ir, tsts) then							begin								tcost := infinity;								for ib := 0 to maxdefgen do									if Enset(ib, tsts) & (ib <> ir) then  {note: here looking to change to other state}										if GenLessThan(ddist[ir, ib], tcost) then  {found closer state; use its distance}											tcost := ddist[ir, ib];								N^.gdnst[ir] := tcost;							end;						if N^.gdnst[ir] <> infinity then							terror := false;					end;		{check to see if at least one states does not have infinity to all other states; otherwise post error 16.}				if terror then					error16 := true;		{regardless, error 25 is posted that polymorphic with 3 or more states dealt with}				error25 := true;			end		else if cardtsts = 2 then {polymorphic with exactly 2 states}			begin {remember, costs already initialized to infinity}				minL := MinG(tsts);{find two observed states}				maxL := maxG(tsts);				terror := true;				for ir := 0 to maxdefgen do					begin			{for each state ir, the two states minL and maxL can be arrived at in three ways}			{here we check to see which of the three ways, ir->minL->maxL, ir->maxL->minL, }			{or minL<-ir->maxL is shortest.  This most parsimonious within-taxon pathway will be}			{chosen. Note however that if ir is either minL or maxL, there is only one pathway and}			{its length is directly used.}			{NOTE: if triangle inequality is violated by ddist, then we can have problems here.}			{If matrix is taken to indicate cost of change per branch, then triangle inequality violation}			{is not self-inconsistent, but within a terminal taxon how do we then count changes since}			{it is not divided into branches?  If we say that matrix indicates cost of each change, without}			{limitations on the time span, then the matrix is self-inconsistent when it violates the triangle inequality.}			{As MacClade now stands, it does not look for shortcuts through extra states here, and thus either assumes that}			{the terminal taxon contains as many branches as it has states (minus one) or that the triangle inequality}			{is not violated.}						if ir = minL then							smalles := ddist[minL, maxL]  {ir,minL -> maxL}						else if ir = maxL then							smalles := ddist[maxL, minL]  {ir,maxL -> minL}						else							begin			{find which is smallest of three, cab, cba or cbca (c=ir; a=minL; b=maxL)}								cab := AddGenDist(ddist[ir, minL], ddist[minL, maxL]); {cab is distance from ir to minL to maxL}								cba := AddGenDist(ddist[ir, maxL], ddist[maxL, minL]); {cba is distance from ir to maxL to minL}								cbca := AddGenDist(ddist[ir, maxL], ddist[ir, minL]); {cbca is distance from ir to minL and ir to maxL}								if GenLessThan(cab, cba) then									begin										if GenLessThan(cba, cbca) | GenLessThan(cab, cbca) then											smalles := cab										else											smalles := cbca;									end								else									begin										if GenLessThan(cab, cbca) | GenLessThan(cba, cbca) then											smalles := cba										else											smalles := cbca;									end;							end;						N^.gdnst[ir] := smalles;  {cost for ir is just the smallest distance to get to the other two}			{This is like spanning tree mentioned above.  With two observed states it is simple enough to }			{calculate, so we do it}						if smalles <> infinity then							terror := false;					end;				if terror then					error16 := true;			end;{above we have calculated cost of placing different states at most recent common ancestor of}{terminal taxon clade (i.e. "ingroup node" within terminal taxon)}{If the terminal branch is in fact fixed, we will now treat downstate as just below terminal clade}{(ie, at  "outgroup node"), effectivley adding a new node}{::: at this point add extra node}		if traced & N^.fix then			begin				ir := minLg(N^.fixsts); {find fixed state; NOTE only one fixed state allowed here}				wasdnstfix := GNabove(N, ir);				N^.gdnst := geninf;   {fixed: set cost of state to infinity except for fixed states}				N^.gdnst[ir] := wasdnstfix;  {reset old cost}			end;	end;{---------------------------------------------------------------------------------}	procedure FillGenDnstASM (NgdnstP, NlfgdnstP, NrtgdnstP, ddistP: Ptr; mdef: integer);{FROZEN 3.0}	begin	{Wayne: v3.5 DELETE}	end;{---------------------------------------------------------------------------------}	procedure GenDownPass (qN: Nptr; ic: integer; traced: boolean);{FROZEN 3.0}{Downpass for user defined types}{  Nlf Nrt}{    \ /  }{     N   }{Uses gdnst arrays from two descendant nodes of N to calculate gdnst array for node N.}{N^.gdnst[iq]= # steps at and above N if "iq" put at N.}{ic is the character number, traced is whether or not the character is traced (and thus}{subject to fixing).}{.....}		procedure InGenDownPass (N: Nptr);			var				fixst: integer;				iq: integer;		begin			if NodeIsInternal(N) then {internal node}				begin					InGenDownPass(N^.lf);					InGenDownPass(N^.rt);					if traced & N^.fix then	{Node has fixed state }						begin							N^.gdnst := genInf; {all states other than fixed have infinite cost; thus init whole matrix}							fixst := minLg(N^.fixsts); {find fixed state; NOTE only one fixed state allowed here}							{even though node N must have fixed state, its required number of steps is not 0;}							{we need to preserve number of steps for fixed state as is, for counting purposes:}							N^.gdnst[fixst] := AddGenDist(GNabove(N^.lf, fixst), GNabove(N^.rt, fixst));						end					else 	{not fixed}						{In 3.0X, When not fixed used an assembly language procedure, namely:}						{FillGenDnstASM(@N^.gdnst, @N^.lf^.gdnst, @N^.rt^.gdnst, @ddist, maxdefgen);}						{here revert to old Pascal equivalent}						for iq := 0 to maxdefgen do 							N^.gdnst[iq] := AddGenDist(GNabove(N^.lf, iq), GNabove(N^.rt, iq));				end			else  {terminal node, set downstates}				GenSetTaxDnst(N, ic, traced);		end;{.....}	begin		if allowCursorChange then 			SetCursID(20712);		error16 := false;		error25 := false;		maxdefgen := MaxStateDefined(TypeOfChar(ic));		typehdl := getTypeHdl(TypeOfChar(ic));		ddist := TypeHdl^^.dist; {getting type matrix}		InGenDownPass(qN);		if error16 then			NewError(16, ic);		if error25 then			NewError(25, ic);	end;{-----------------------------------------------------------------------------}	procedure GenUpCalcNode (N: Nptr; maxdef: integer; traced: boolean);{FROZEN 3.0}{Calculates uppass info for N; see description under GenUpPass}		var			iq: integer;			sisN, Nanc: Nptr;			wasgupstfix: longint;	begin		sisN := sis(N);		Nanc := N^.anc;  {remember polytomies not allowed}		if Nanc = R then    {N just above R; pull down gdnst from sister only}			for iq := 0 to maxdef do				N^.gupst[iq] := GNabove(sisN, iq) {number of steps below N if iq put at R}		else if (N <> R) then  	{N higher above R; pull from sister & anc}			for iq := 0 to maxdef do				N^.gupst[iq] := AddGenDist(GNabove(sisN, iq), GNbelow(Nanc, iq))		else     {N is R; make it allow everything}			N^.gupst := genzero;		if traced & Nanc^.fix then		{if ancestor is fixed prohibit non-fixed states}			begin				iq := minLg(Nanc^.fixsts); {find fixed state; NOTE only one fixed state allowed here}				wasgupstfix := N^.gupst[iq];  {find what cost was}				N^.gupst := geninf;  {setting all states to infinite cost}				N^.gupst[iq] := wasgupstfix; {except state fixed: could be set to 0 cost, but better set to actual cost}			end;	end;{-----------------------------------------------------------------------------}	procedure GenUpPass (qN: Nptr; ic: integer; traced: boolean);{FROZEN 3.0}{Uppass for user defined types}{ sisN   N }{   \   /  }{    Nanc  }{Uses gupst array from N^.anc and dnst array from N's sister to calculate gupst array for node N.}{REMEMBER: N^.gupst[iq]= # steps below N if state "iq" put at N^.anc.}{ic is the character number, traced is whether or not the character is traced (and thus}{subject to fixing).}		procedure InGenUpPass (N: Nptr);		begin			if NodeIsInternal(N) then				begin					GenUpCalcNode(N, maxdefgen, traced);					InGenUpPass(N^.lf);					InGenUpPass(N^.rt);				end;		end;	begin		if allowCursorChange then 			SetCursID(21918);		maxdefgen := MaxStateDefined(TypeOfChar(ic));		typehdl := getTypeHdl(TypeOfChar(ic));		ddist := TypeHdl^^.dist; {getting type matrix}		InGenUpPass(qN);	end;{-----------------------------------------------------------------------------}	procedure AdjustResultIfLowest (var rset: lgsetchars; iq: integer; var mint: longint; stepsforstate: longint);{FROZEN 3.0}{adds iq to set if as good as before; replaces set with [iq] if better than before}	begin		if stepsforstate <> infinity then {if not infinite cost, see if it is lowest}			begin				if (mint = infinity) | (stepsforstate < mint) then					begin						rset := MakeSet(iq);  {lowest cost so far found; store state in result set}						mint := stepsforstate;					end				else if stepsforstate = mint then					rset := AddToSet(rset, iq);  {as low as best cost so far found; add state to result set}			end;	end;{-----------------------------------------------------------------------------}	procedure GenTriplePass (qN: Nptr; ic: integer; traced: boolean);{FROZEN 3.0}{Final pass for user defined types}{                    Nlf Nrt }{                      \ /   }{             sisN    N    }{                \   /     }{                 Nanc     }{Uses gupst array from N and gdnst array from N's two descendants}{to calculate final states for node N.  Note that there is not a final states array}{stored, which would say number of steps cost for each state at node.  Instead,}{only the final state set is stored in N^.stsH or N^.final}{ic is the character number, traced is whether or not the character is traced (and thus}{subject to fixing).}		var			stepsforstate, mint: longint;			taxsts, rset: lgsetchars;			sisN: Nptr;{.....}		procedure InGenTriplePass (N: Nptr);			var				iq: integer;		begin			if (NodeIsInternal(N)) then   {====== Internal nodes ======}				begin					if (traced & N^.fix) then     	{Node's state is fixed}						N^.final := N^.fixsts					else						begin  {node's state is not fixed}							mint := infinity;							rset := nil;							for iq := 0 to maxdefgen do  {cycle through all states, seeing which is best at N}								begin				{stepsforstate stores how good is state iq; }				{that is, the number of steps over all tree for state iq at N}									if N <> R then       {not root: combine states from above & below}										stepsforstate := AddGenDist(GNabove(N^.lf, iq), AddGenDist(GNabove(N^.rt, iq), GNbelow(N, iq)))									else										stepsforstate := N^.gdnst[iq]; {Root: just use down costs calculated}									AdjustResultIfLowest(rset, iq, mint, stepsforstate);								end;							if rset = nil then								NewError(14, ic);							if traced then								N^.final := OldSetFromNew(rset)							else								setstsLargest(N, ic, OldSetFromNew(rset));						end;  {not fixed}					InGenTriplePass(N^.lf);					InGenTriplePass(N^.rt);				end			else                  		{====== Terminal nodes ======}				begin					if traced & N^.fix then  {node's state is fixed; assign it fixed state}						N^.final := N^.fixsts					else						begin							taxsts := NewsetFromOld(gettaxonstsLargest(N^.name, ic));							if Enset(MSL, taxsts) then								begin 	{missing data;  pull up from ancestor}									if traced then										N^.final := N^.anc^.final									else										setstsLargest(N, ic, getstsLargest(N^.anc, ic))								end							else if MultipleStatesG(taxsts) then				{polymorphic or uncertain; choose the best state as ancestral for the}				{terminal taxon, by trying all possibilities iq and measuring their cost}								begin				{Note that N^.upstates not calculated in uppass therefore calculate here}									GenUpCalcNode(N, maxdefgen, traced);									rset := nil;									mint := infinity;									for iq := 0 to maxdefgen do{ Note that here we allow non-observed states in terminal nodes}{if iq in taxsts then}										begin						{ Treats terminal node as if it represented the most recent common ancestor}						{of the terminal taxon's components; thus as its "ingroup node".  }						{ Thus we add the length from terminal node up to states of taxon, as well as from}						{ terminal node down to its ancestor and the rest of the tree below, given}						{ that the terminal node had state iq.}{note problems with triangle inequality here.  In general triangle inequality will}{cause problems with polymorphic tt and states fixed at terminal nodes}											stepsforstate := AddGenDist(N^.gdnst[iq], GNBelow(N, iq));											AdjustResultIfLowest(rset, iq, mint, stepsforstate);										end;									if rset = nil then										NewError(14, ic);									if traced then										N^.final := OldSetFromNew(rset)									else										setstsLargest(N, ic, OldSetFromNew(rset));								end							else   {monomorphic: assign obs. state}								begin									if traced then										N^.final := OldSetFromNew(taxsts)									else										setstsLargest(N, ic, OldSetFromNew(taxsts))								end;						end;				end;		end;  {InGenTriplePass}{....main of gentriple....}	begin		if allowCursorChange then 			SetCursID(21950);		maxdefgen := MaxStateDefined(TypeOfChar(ic));		typehdl := getTypeHdl(TypeOfChar(ic));		ddist := TypeHdl^^.dist; {getting type matrix}		InGenTriplePass(qN);	end;end.