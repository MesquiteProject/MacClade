unit AlignmentUtil;{ееееееееееееееееееееее}interface	uses		QuickDraw,  		Types, Events, QuickDrawText, OSUtils, TextUtils,Controls, Menus, Files,  Windows, 		Sound, Dialogs, TextEdit, Lists, ToolUtils, Memory, Fonts, Resources, Scrap, 		Globals, WindowUtil, GenUtil, StrUtil, BoxUtil, SetLibInterface, TaxonCHUtil,		CharUtil, MenuUtil, SymbolsNames, TreeUtil, Fill, SpreadUtil, Footnote, DrawSpread, 		RowColumn, StatesWindow, ScrollSpread, CopyPaste, ToolPalette;	procedure DiffRect(oldBox, newBox: rect; var exposedBox,hiddenBox: rect);	procedure DrawAndCopyCellBlockImage (box: rect; itstart,itend,icstart,icend: integer; cellWritingMode: integer);	procedure UpdateMovedTaxa(itstart,itend: integer; useSelected, hideSelectionShading: boolean);			procedure StoreStateFrequencies(itstart,itend: integer);	function CheckStateFrequencies(itstart,itend: integer; var itchanged: integer): boolean;		{ееееееееееееееееееееее}implementation {е$S Alignment}{----------------------------------------------------------------------------}	procedure CalcStateFrequenciesOfTaxon(var freq: stateFreqType; it: integer);	begin		CalcStateFreq(freq,it,it,1,numchars);	end;{----------------------------------------------------------------------------}	procedure StoreStateFrequencies(itstart,itend: integer);	var ic,j : integer;		it: integer;		tsts: LargestSetChars;		taxonHdl : THdl; 	begin		for it := itstart to itend do			begin				taxonHdl := getTaxonHdl(it);				ZapPointer(taxonHdl^^.freqP);				taxonHdl^^.freqP := stateFreqPtr(NewPtr(SizeOf(stateFreqType)));				CalcStateFrequenciesOfTaxon(taxonHdl^^.freqP^,it);			end;	end;{----------------------------------------------------------------------------}	function CheckStateFrequencies(itstart,itend: integer; var itchanged: integer): boolean;	label 1;	var j , it: integer;		same: boolean;		taxonHdl : THdl; 		currentFreq, oldFreq: stateFreqType;	begin		same:= true;		for it := itstart to itend do			begin				CalcStateFrequenciesOfTaxon(currentFreq,it);   {get current freq}				taxonHdl := getTaxonHdl(it);				if taxonHdl^^.freqP = nil then					begin						itchanged := it;						same := false;						goto 1;					end				else					oldFreq := taxonHdl^^.freqP^;				for j := 0 to absmaxstate do					if oldFreq[j] <> currentFreq[j] then  {compare to previously stored freq}						begin							itChanged := it;							same := false;							goto 1;						end;			end;1:		CheckStateFrequencies:= same;		for it := 1 to numtaxa do			ZapPointer(getTaxonHdl(it)^^.freqP);	end;{----------------------------------------------------------------------------}	function StateFreqSame(freq1,freq2: stateFreqType): boolean;	var j : integer;		same: boolean;	begin		same:= true;		for j := 0 to absmaxstate do			if freq1[j] <> freq2[j] then				begin					same := false;					leave;				end;		StateFreqSame:= same;	end;{----------------------------------------------------------------------------}	procedure DiffRect(oldBox, newBox: rect; var exposedBox,hiddenBox: rect);	{this requires that oldbox and NewBox are shifted ONLY vertically or ONLY horizontally, not both}	{in exposedBox is returned the part of oldBox that is not present in newBox	in hiddenBox, returns the part of oldBox that is present in newBox}	begin		SetRect(hiddenBox,0,0,0,0);		SetRect(exposedBox,0,0,0,0);				if (oldBox.left<> newBox.left) | (oldBox.right<> newBox.right)  then  {right-left shift}			begin				exposedBox.top := oldBox.top;				exposedBox.bottom := oldBox.bottom;				hiddenBox.top := oldBox.top;				hiddenBox.bottom := oldBox.bottom;				if oldBox.left> newBox.left then  {shift to left, hiddenBox on left}					begin						hiddenBox.left := newBox.left;						hiddenBox.right := oldBox.left;					end				else if oldBox.left < newBox.left then {shift to right, exposedBox on left}					begin						exposedBox.left := oldBox.left;						exposedBox.right := newBox.left;					end;									if oldBox.right < newBox.right then {shift to right, hiddenBox on right}					begin						hiddenBox.left := oldBox.right;						hiddenBox.right := newBox.right;					end				else if oldBox.right > newBox.right then {shift to left, exposedBox on right}					begin						exposedBox.left := newBox.right;						exposedBox.right := oldBox.right;					end;			end;					if (oldBox.top<> newBox.top) | (oldBox.bottom<> newBox.bottom)  then  {up-down shift}			begin				exposedBox.left := oldBox.left;				exposedBox.right := oldBox.right;				hiddenBox.left := oldBox.left;				hiddenBox.right := oldBox.right;				{hiddenBox.right := hiddenBox.left;				exposedBox.right := exposedBox.left;				hiddenBox.bottom := hiddenBox.top;				exposedBox.bottom := exposedBox.top;}				if oldBox.top> newBox.top then  {shift to top, hiddenBox on top}					begin						hiddenBox.top := newBox.top;						hiddenBox.bottom := oldBox.top;					end				else if oldBox.top < newBox.top then {shift to bottom, exposedBox on top}					begin						exposedBox.top := oldBox.top;						exposedBox.bottom := newBox.top;					end;									if oldBox.bottom < newBox.bottom then {shift to bottom, hiddenBox on bottom}					begin						hiddenBox.top := oldBox.bottom;						hiddenBox.bottom := newBox.bottom;					end				else if oldBox.bottom > newBox.bottom then {shift to top, exposedBox on bottom}					begin						exposedBox.top := newBox.bottom;						exposedBox.bottom := oldBox.bottom;					end;			end;	end;{----------------------------------------------------------------------------}	procedure DrawCellBlock(offScreenBox: rect; itstart, itend, icstart,icend: integer; cellWritingMode: integer);	var oldFore: RGBColor;		cellBox: rect;		it,ic: integer;		st,et,sc,ec, pasteIC, firstPasteIC: integer;		wh: point;		cellWritingModeLocal : integer;	begin		wh.h:= offScreenBox.left+2;		wh.v := offScreenBox.top+2;		FindTaxonCharacterInEditor(wh, it, firstPasteIC);		OffSetRect(offScreenBox,-offScreenBox.left,-offScreenBox.top);		cellWritingModeLocal := cellWritingMode;				case cellWritingMode of			writeStandardCells:				begin					st := itstart;					et := itend;					sc := icstart;					ec := icend;				end;			writeCellsUnderMovingBlock:				begin					st := it;					sc := firstPasteIC;					if editorTransposed then						begin							et := (offScreenBox.right-offScreenBox.left+ editorColumnWidth div 2) div editorColumnWidth + st - 1;							ec := (offScreenBox.bottom-offScreenBox.top+ editorLineWidth div 2) div editorLineWidth + sc - 1;						end					else						begin							ec := (offScreenBox.right-offScreenBox.left+ editorColumnWidth div 2) div editorColumnWidth + sc - 1;							et := (offScreenBox.bottom-offScreenBox.top+ editorLineWidth div 2) div editorLineWidth + st - 1;						end;					cellWritingModeLocal := writeStandardCells;				end;			writeClipboard:				begin					st := 1;					et := EWScrapBlockP^.ntax;					sc := 1;					ec := EWScrapBlockP^.nchar;				end;			writeCellBlock:				begin					st := itstart;					et := itend;					sc := icstart;					ec := icend;					{st := 1;					et := EWCurrentDrawBlockP^.ntax;					sc := 1;					ec := EWCurrentDrawBlockP^.nchar;}									end;			otherwise				if editorTransposed then					begin						st := 1;						et := (offScreenBox.right-offScreenBox.left+ editorColumnWidth div 2) div editorColumnWidth;						sc := 1;						ec := (offScreenBox.bottom-offScreenBox.top+ editorLineWidth div 2) div editorLineWidth;					end				else					begin						sc := 1;						ec := (offScreenBox.right-offScreenBox.left+ editorColumnWidth div 2) div editorColumnWidth;						st := 1;						et := (offScreenBox.bottom-offScreenBox.top+ editorLineWidth div 2) div editorLineWidth;					end;		end;		GetForeColor(oldFore);		cellbox:= offScreenbox;		cellbox.right := cellbox.left+editorColumnWidth{+2};		cellbox.bottom := cellbox.top + editorLineWidth;		TextFont(editorFont);		TextSize(editorFontSize);		TextFace([]);		pasteIC := 1;				if editorTransposed then			for it := st to et do				begin					for ic := sc to ec do						begin							WriteCell(cellBox, ic, it, firstPasteIC+(ic-sc), cellWritingModeLocal = writeClipboard, true, false,cellWritingModeLocal);							OffSetRect(cellbox,0,editorLineWidth);						end;					OffSetRect(cellbox,editorColumnWidth,-editorLineWidth*ord4(ec-sc+1));				end		else			for it := st to et do				begin					for ic := sc to ec do						begin							WriteCell(cellBox, it, ic,  firstPasteIC+(ic-sc), cellWritingModeLocal = writeClipboard, true, false, cellWritingModeLocal);							OffSetRect(cellbox,editorColumnWidth,0);						end;					OffSetRect(cellbox,-editorColumnWidth*ord4(ec-sc+1),editorLineWidth);				end;		ResetForeground(oldFore);	end;{----------------------------------------------------------------------------}	procedure DrawAndCopyCellBlockImage (box: rect; itstart,itend,icstart,icend: integer; cellWritingMode: integer);	 var		origPort: CGrafPtr;		origDevice:GDHandle;		myErr: QDErr;		myOffScreenWorld: GWorldPtr;		offPixMapHandle:  PixMapHandle;		good:  Boolean;		offScreenbox: Rect;		weightColor: RGBColor;	 begin		if EmptyRect(box) then			Exit(DrawAndCopyCellBlockImage);		offScreenBox := box;		OffSetRect(offScreenBox,-box.left,-box.top);		GetGWorld(origPort, origDevice); {save onscreen graphics port}		myErr := NewGWorld(myOffScreenWorld, 0, offScreenBox, NIL, NIL, 0); {create offscreen graphics world}		if (myOffScreenWorld = NIL) or (myErr <> noErr) then			Exit(DrawAndCopyCellBlockImage); {handle errors here}		SetGWorld(myOffScreenWorld, NIL); {set current graphics port to offscreen}		offPixMapHandle := GetGWorldPixMap(myOffScreenWorld);		good := LockPixels(offPixMapHandle);{lock offscreen pixel map}		if not good then			Exit(DrawAndCopyCellBlockImage); {handle errors here}		ClipRect(offScreenBox);		EraseRect(offScreenBox); {clear offscreen pixel map}				DrawCellBlock(box, itstart, itend, icstart,icend, cellWritingMode);		SetGWorld(origPort, origDevice); {restore onscreen graphics port}		{if cellWritingMode=writeClipBoard then			begin							weightColor.red := 30000;				weightColor.blue := 30000;				weightColor.green := 30000;				OpColor(weightColor);				CopyBits(GrafPtr(myOffScreenWorld),GrafPtr(origPort), myOffScreenWorld^.portRect, box, blend, NIL);			end		else}					//CopyBits(BitMapPtr(GetGWorldPixMap(myOffScreenWorld))^, GetPortBitMapForCopyBits(origPort)^, WindowPortRect(myGetWindowFromPort(myOffScreenWorld)), box, patcopy, NIL);		//CopyBits(BitMapPtr(GetGWorldPixMap(myOffScreenWorld)), GetPortBitMapForCopyBits(origPort), WindowPortRect(myGetWindowFromPort(myOffScreenWorld)), box, patcopy, NIL);		myPortCopyBits(cGrafPtr(myOffScreenWorld),cGrafPtr(origPort), offscreenbox, box, patcopy, NIL);		UnlockPixels(offPixMapHandle);		DisposeGWorld(myOffScreenWorld); end;{----------------------------------------------------------------------------}	procedure UpdateMovedTaxa(itstart,itend: integer; useSelected, hideSelectionShading: boolean);	var			st, et, sc, ec, ic,it: integer;			row, column: integer;			box: rect;			selectionModeToUse : integer;	begin		if hideSelectionShading then			selectionModeToUse := selectionModeOff		else			selectionModeToUse := selectionModeAsIs;		if useSelected then			CalcSelectedTaxaCharacters(st, et, sc, ec,true)		else			begin				st := itstart;				et := itend;			end;		sc := FirstVisibleCharacter;		ec := LastVisibleCharacter;		for it := st to et do			for ic := sc to ec do				begin					RowColumnFromTaxonCharacter(it,ic,row,column);					box := CellRect(column, row);					WriteTaxonCharacterCell (it,ic, false,writeStandardCells,selectionModeToUse);				end;	end;end.