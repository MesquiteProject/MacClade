unit StartupUtil;{¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, 		TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Palettes,		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, Traps, Balloons, StrUtil, TaxonCHUtil, 		BoxUtil, MenuUtil, TypeUtil, Equivocal, EditUtilMenu, TypeDLOGUtil, Settings, ProcessMenu, 		Thermos, TreeUtil, LaserTreeUtil, SpreadUtil, CHUNK, DrawSpread, Windows, GenCloseFile, GenOpenFile, 		EditMenu, ChartWUtil, ReadWriteUtil, ReadUtil, WriteUtil, GeneticCode,		TreeRandomData, TextWindows, NexusBlocks, ToolPalette, FixMath, CharPartitions;	var		earlyquit: boolean;	procedure ReportStartUpStatus (theDialog: DialogPtr; report: str255);	procedure SetupStuff (theDialog: DialogPtr);{¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥}implementation {¥$S StartupUtil}{----------------------------------------------------------------------------}	procedure CallWaitNextEventForDrawing2;	var db: boolean;		tev: EventRecord;	begin{$IFC CARBON}		db := WaitNextEvent(0, tev, 4, nil);{$ENDC}	end;{-----------------------------------------------------------------------------}	procedure ReportStartUpStatus (theDialog: DialogPtr; report: str255);		var			box: rect;			oldfont, oldsize: integer;			tempP: WindowPtr;	begin{$IFC WRITETEMPFILE}	writeln(tempFile,report);{$ENDC}		if theDialog <> nil then			begin				genericGetPort(tempP);				genericSetPort(myGetWindowPtrForDialog(theDialog));				oldfont := QDThePortTextFont;				oldsize := QDThePortTextSize;				box := GetDLOGItemBox(theDialog, 7);				EraseRect(box);								textfont(kFontIDGeneva);				textsize(9);				ForeColor(greenColor);				TETextbox(Pointer(ord4(@report) + 1), length(report), box, teJustLeft);				ForeColor(blackColor);				textfont(0);				textsize(12);				genericSetPort(tempP);				CallWaitNextEventForDrawing;			end;	end;{-----------------------------------------------------------------------------}	procedure DrawMCIconSlice(h, v: integer; var box: rect; oldClipRect: rect);	var 		dropBox: rect; 		err:OSErr;	begin		{ClipRect(box);		OffsetRect(box,0,-4);		setrect(dropBox, h, v, h+128, v+128);		err:= plotIconID(dropBox, 0, ttnone, 200);		ClipRect(oldClipRect);}	end;{-----------------------------------------------------------------------------}	procedure StartBooleansEtc;		var			j, ic: integer; {v3.02:}	begin		{$IFC CARBON}		legendTitleIsWindowTitle := false;{$ELSEC}		legendTitleIsWindowTitle := true;{$ENDC}      		showMultiAlignmentCost:= false;      		ShadeExcludedItem := ShadeNoneItem;      		lastImpSequenceFileType := impNBRF;      		multiAlignmentCost:=0;		showTextOrAllinNav := true;		treeFileOptionsButtonClicked:= false;		treewasopen := false;		editWasOpen := false;		editorWindowTop := 40;		windowEdgeThickness := 4;		scrollWidth := 15;		dragSoundActive := false;		SetStateSetBoundaries(false);		codonPositionsChanged := false;		charPartitionsChanged := false;		justReadANexusFile := false;		windowOrderRead := false;		printerColorGrayScale := true;		allowImportMoleculeIntoStandard := false;		queriedAboutImportedSequenceType := false;		importedDataType := DNA;		lastselN := nil;		subR := nil;		R := nil;		subSubR := nil;		screenR := nil;		drawR := nil;		paletteTitleLineWidth := 12;		printDataBoxesInColor := false;				numCharLegendBoxes := 0;		ZeroTickFlash;				userCanceledRead := false;		maxedw := 9;		updateFontChangedWindows := true;		oneswap := false;		allowCursorChange := true;		warnedAboutMovedSequenceSites := false;		extraOverHang := 0;		pageSetupChanged := false;		cancelCheckFreq := 30;				flashHidden:= true;		allowReturnAsCancel:= false;		lastChangeIsEither := false;						editorMinRowNameEnd:= 75;		editorCursorTaxon:=0;		editorCursorCharacter:=0;		{useOldFloatingWindows := false;}		editorLineSensitivity:= defaultEditorLineSensitivity;		SetRect(legMessageBox,0,0,0,0);				equivocalCycleCalculation:= false;				editorFlashOn := false;		autoIncreaseChartIntervals:= false;		{$IFC DEBUG}		xSignedByte1 := 0;		xBoolean1 := false;		dodoublecheck := true;{$ENDC}		{editorMode := edNormal;}				editorFirstRowTop:= 1;		editorFirstColumnLeft:= 1;				onOpenFileSetAsPlainMolecularStyle := false;		italicsIsOn := false;		blockMoveOn := false;		editorPaintReferenceTaxon := 1;		drawBlockMoveMode := drawBlockMoveOff;		oldOption := false;		MustBeIdentical := true;		ExamineExcluded := true;		RemoveChains := false;		searchfor := searchinvarchar;		autoCharNumberRefSequence := 1;		autoCharNumberByRef := false;		notificationPosted:= false;		polytomiesWereBlasted := false;{$IFC SETBRANCHLENGTHS}		setBranchLengths := false;		editingBranchLengths := false;{$ENDC}		CheckScreenRectangle;		blackpattern := QDBlack;		whitepattern := QDWhite;		graypattern := QDGray;		ltgraypattern := QDltGray;		probchangeRec[0, 0] := 0.9;		probchangeRec[0, 1] := 0.1;		probchangeRec[1, 0] := 0.1;		probchangeRec[1, 1] := 0.9;		ShowProbTraceLabels := true;		probrecitem := stateexact;		probTreeitem := numsteps;		seglistenProb := false;		NoNewErrorStopped := true;		undoCellStates := [];		calcRestChanges := false;		ChartCalcToText := false;		PleaseOffMinAll := false;		PleaseOffMaxAll := false;		pleaseofftrace:= false;		updateHasPriority := false;		ScreenInColor := false;		StepCellHeight := 16;		StepCellWidth := 20;		globalItemHit := 1;		emptychart := false;		CategoryInflation := 1;		backgroundable := true;		defaultCatWid := 1;		goNex7on := false;		KCHRPtr := nil;		quotedToken := false;		saveRndTreesReport := false;		doCodPosQuery := false;		pleaseoffequivocal := false;		cancelChar := chr(0);		laserTreeInit := false;		selectMode := selectReplace;		ladderDir := 1;		writeScatterStates := false;		treemakingfailed := false;		goUpdateWindows := false;		showtaxname := true;		maxChartIntervals := 1000;		userMaxChartIntervals := 1000;		n7LW := 10;		polytomiesBlasted := false;		treesblock := treesDataBlock;		allwt1 := true;		onePartition := true;		justredo := false;		wholeword := true;		{^&* theWindow := nil;}		legboxheight := 11;		legLineHeight := 10;		writeRootStates := false;		PleaseOffChart := false;		PleaseOffCI := false;		PleaseOffRIRC := false;		goTWHome := false;		savepicton := false;		saveCanvas := false;		Stopaftertree := false;		chartbeingcalculated := false;		blastpolytomies := false;		abortedThermo := false;		numbytes := 2;		maxstate := 9;		DrawToFile := false;		OptionIsDown := false;		CommandIsDown := false;		ControlIsDown := false;		CapsLockIsDown := false;		ShiftIsDown := false;				noteson := false;		ourRandSeed := 1;		NewRandomSeed;		oldTreeSeed := OurRandSeed;		oldrandseed := OurRandSeed;		DoBitSet;{ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃ}{$IFC PROBRECONSTRUCT}		fullgotree := [settaxdnall..GOcontinuous, goProbability];   {golist items concerned with single tree on screen}{$ELSEC}		fullgotree := [settaxdnall..GOcontinuous];   {golist items concerned with single tree on screen}{$ENDC}{$IFC PROBSTEPCHART}		fullgochartone := [stepschart..statesallchart, goProbStepsChart];	{golist items concerned with chart concerning tree on screen}{$ELSEC}		fullgochartone := [stepschart..statesallchart];	{golist items concerned with chart concerning tree on screen}{$ENDC}		fullgochartmult := [stepsichartmult..TwoTreefiles];	{golist items concerned with chart concerning multiple trees}		gomask := [resetlengthall..reconstructi2] + [settaxdnall];	{default gomask}		igos := [reconstructi, statesichart, stepsichartmult, stepsChgsichartmult, ciriichartmult, Changesichart, Changesichartmult];	{golist items concerning traced char}		taxaonlygos := [settaxdnall, statesichart, statesallchart, calcminlenall, calcmaxlenall];	{golist items that change when taxa included/excluded}{FROZEN 3.0}		golist := [];		count := false;{golist,gomask,count,calcCI, etc., are all re-initialized in Gen Open File}{ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃ}		SetPtr31 := SetPointer31(NewPtr(4));		SetPtr15 := SetPointer15(NewPtr(2));		locSetPtr31 := SetPointer31(NewPtr(4));   {used locally within RowColumn}		legtitleW := 16;		tlegline := 12;		TWmessW := 0;		SetRect(patternBox, 3, 0, 23, legboxheight - 2);		flashchar := ' ';		thermo1 := false;		thermo2 := false;		dirtymaxst := false;		ignoregaps := true;		prefGeneticCode := universalCode;  {v3.05: was nuclearCode}		textsep := chr(9);		footpictson := false;		footSoundOn := false;						splitTaxonStart := 0;		splitTaxonEnd:=0;		splitCharacter:= 0;		flashbranchon := true;		CWChart := CWCSteps;		CMshow := [CMminmin, CMmaxmax];{what about compare 2 trees, compare 2 treefiles}		charton := false;		TWfont := kFontIDGeneva;		TWstyle := [];		TWfontsize := 9;		maxerrors := 5;		picton := false;		statesWindowLineWidth := 12;		statesWindowTitleWidth := 12;		statesWindowRows := statesWindowDefaultRows;		statesWindowTop := 1;		statesWindowOpen := false;		statesSymbolWidth := 22;		statesNameStart := 2 * statesSymbolWidth;		for j := 1 to numInfoWindows do			begin				infoFont[j] := kFontIDGeneva;				infoStyle[j] := [];				infoFontSize[j] := 9;				infoRows[j] := 22;				infoTop[j] := 1;				infoBottom[j] := infoTop[j] + infoRows[j]-1;				infoLW[j] := 12;				infoOpen[j] := false;				infoWasOpen[j] := false;			end;		statesWindowWasOpen := false;		{ === Chartwindow === }{    cumview := nocum;}				usercatwid := 1;		biggraph := false;		lasttime := 0;		badmemory := false;		MCFlag := false;		for j := 0 to absmaxstate do			begin				genzero[j] := 0;				genInf[j] := infinity;			end;		SelCellChanged := false;		legscrollW := 15;		whitespace := [' ', chr(0)..chr(6), chr(9), chr(10), chr(13)];		vacuum := [chr(0)..chr(32)] - whitespace;{    whitespace := [chr(0)..chr(32)];}{  punctuation := [',', ';', '=', '*'];   - this is 3.04 list}		punctuation := punct305;		 {v3.05: added parentheses and everything after this as punctuation}{( ) [] ' / , ; -=: \ * " }		scrollup := true;		readhelp := false;		tearpt.h := 100;		tearpt.v := 200;		cursormap.rowBytes := 2;		setrect(cursormap.bounds, 0, 0, 16, 16);		cyclecursnum := 0;		realwt := false;		lengthinflate := 1;		ChartJustCalc := false;		comingback := false;		equivcycle := false;		fileopen := false;		newfile := false;		commreadon := false;		datachanged := false;		dirtyfile := false;		dirtytreefile := false;		mintxsp := 6;		txsp := 12;		CWTableTop := 0;		CWLW := 12;		ThermoAbortable := true;		readon := false;		printon := false;		noundo := true;		fixlostbyundo := false;		justundid := false;		ancon := false;		nullson := false;		expd := false;{traceon := false;}		traceshown := tracenothing;		dblclick := false;		editorOpen := false;		treeopen := false;		justchanc := false;		nodes := false;		nex7on := false;		quit := False;		errorflag := false;{    memshowing := false;}		undotoNull := 0;		nomove := false;		editorSelected := false;		editorSelectionTopLeft.v := 0;		editorSelectionTopLeft.h := 0;		editorSelectionBotRight := editorSelectionTopLeft;		for j := 0 to maxtlegstats do			begin				tlegStats[j].show := false;				tlegStats[j].lines := 1;			end;		tlegStats[tlegTAXCHAR].show := true;		tlegSTats[tlegTAXCHAR].lines := 2;		for j := 0 to maxTWmessIcons do			begin				TWMessIcon[j].left := 0;				TWMessIcon[j].right := 0;				TWMessIcon[j].show := false;{set curs[0],curs[1]}			end;		TWMessIcon[TWmessExpd].cursid[0] := 6259;		TWMessIcon[TWmessRoot].cursid[0] := 31351;		TWMessIcon[TWmessTaxExc].cursid[0] := 12740;		TWMessIcon[TWmessCharExc].cursid[0] := 28263;		TWMessIcon[TWmessEquiv].cursid[0] := 14714;		TWMessIcon[TWmessEquiv].cursid[1] := 27234;		TWMessIcon[TWmessFix].cursid[0] := 14715;		TWMessIcon[TWmessPolyT].cursid[0] := 12523;		TWMessIcon[TWmessPolyT].cursid[1] := 4786;		maxTWR := ScreenBoundsRect;		maxTWR.right := maxTWR.right + scrollwidth;		maxTWR.bottom := maxTWR.bottom + scrollwidth;		drawTWR.top := maxTWR.top;		drawTWR.bottom := maxTWR.bottom;		drawTWR.left := maxTWR.left;		drawTWR.right := maxTWR.right;		next := ' ';		previousChar := ' ';		TWScrolling := false;		CHUNKpos := 0;		SETRECT(dataBoxB, 0, TWorigV, (drawTWR.right - drawTWR.left) - 10, TWorigV);		InitProbChange;	end;{-----------------------------------------------------------------------------}	procedure StartNexusBlocks;	begin		NexusBlocks := NexusBlockPtr(NewPtrClear(SizeOf(NexusBlockRecord)));		NexusBlocks^.H := NewHandle(0);			InitNexusBlockPtr(NexusBlocks);		NexusBlocks^.blockName := 'MacCladeStart';		NexusBlocks^.nativeBlock := true;		NexusBlocks^.willWriteBlock := false;		NexusBlocks^.blocktype := maccladeStartBlock;		numNexusBlocks:=1;		{$IFC NOT NEWNEXUSBLOCK}		AddNewNexusBlock('Taxa',taxaBlock,true);		AddNewNexusBlock('Characters',charactersBlock,true);		AddNewNexusBlock('Data',dataBlock,true);		AddNewNexusBlock('Continuous',continuousBlock,true);		AddNewNexusBlock('Codons',codonsBlock,true);		AddNewNexusBlock('Labels',labelsBlock,true);		AddNewNexusBlock('Sets',setsBlock,true);		AddNewNexusBlock('Assumptions',assumptionsBlock,true);		AddNewNexusBlock('Trees',treesDataBlock,true);		AddNewNexusBlock('Notes',notesBlock,true);		AddNewNexusBlock('MacClade',MacCladeBlock,true);{$ENDC}{		maccladeStartBlock = 1;		taxaBlock = 2;		charactersBlock = 3;		dataBlock = 4;		continuousBlock = 5;				codonsBlock = 6;		setsBlock = 7;		assumptionsBlock = 8;				treesDataBlock = 9;		treefileblock = 10;		notesBlock = 11;		MacCladeBlock = 12;}	end;{-----------------------------------------------------------------------------}	procedure StartCharPartNames;	begin		CharPartNames := CharPartNamePtr(NewPtrClear(SizeOf(CharPartNameRecord)));		InitCharPartNamesPtr(CharPartNames);		CharPartNames^.name := 'Default';		numCharPartNames:=1;	end;{-----------------------------------------------------------------------------}	procedure StartHandles(theDialog: DialogPtr);		var			c: char;			dL: longint;			j: integer;			box: rect;			k: integer;	begin		statesClipboardH := nil;		statesUndoH := nil;		symbolsUndoSH := nil;		copySpecialCustomH1 :=nil;		copySpecialCustomH2 := nil;		for j := 1 to numSettingLinkedLists do			baseSettings[j] := nil;		TTC := TTCHdl(NewHandle(sizeof(TTxtCenter)));		TTC^^.x := 0;		TTC^^.y := 0;		TTPR := TTPRHdl(NewHandle(sizeof(TTxtPicRec)));		TTPR^^.tJus := tJusNone;		TTPR^^.tFlip := tFlipNone;		TTPR^^.tLine := 0;		TTPR^^.tCmnt := 0;		TTPR^^.tAngle := 0;		TTPR^^.tAngleFixed := Long2Fix(TTPR^^.tAngle);		laser := LaserPtr(NewPtr(SizeOf(LaserType)));		newlaser := NewLaserPtr(NewPtr(SizeOf(newLaserType)));		laserBoxes := LaserBoxesArrayPtr(NewPtr(SizeOf(LaserBoxesArray)));		colorkey := ColorKeyPtr(NewPtr(SizeOf(colorkeytype)));		patkey := PatKeyPtr(NewPtr(SizeOf(patkeytype)));		summarycolors := sumColorPtr(NewPtr(SizeOf(sumcolortype)));		summarypat := sumPatPtr(NewPtr(SizeOf(sumpattype)));		nucleotideColorKey := nucleotideColorKeyPtr(NewPtr(SizeOf(nucleotideColorKeyType)));		proteinColorKey := proteinColorKeyPtr(NewPtr(SizeOf(proteinColorKeyRecord)));		sameStateColorsForAllCharacters := false;		useMOSForSameColorsForAll := false;		clippicture := PicHandle(NewHandle(0));		changesSel := changesSelPtr(NewPtr(SizeOf(changesSelarray)));		for j := 0 to absmaxstate do			for k := 0 to absmaxstate do				changesSel^[j, k] := true;		changesRestricted := false;		tool := ToolArrayPtr(NewPtr(SizeOf(toolarray)));		infoTools := infoToolPtr(NewPtr(SizeOf(infoToolArray)));		CreateCellBlock(EWMoveBlockP);		CreateCellBlock(EWScrapBlockP);		CreateCellBlock(EWFindSequenceBlockP);		CreateCellBlock(EWFindRNARCBlockP);		EWCurrentDrawBlockP:= nil;				FootPictures:= FootPicturesPtr(NewPtrClear(SizeOf(FootPicturesRecord)));		numFootPicts := 1;		InitFootPicturesPtr(footPictures);				editorConsensus := ConsensusPtr(NewPtrClear(SizeOf(consensusRecord)));		InitConsensusPtr(editorConsensus);		editorNumConsensusSequences:=1;		editorShowConsensusSequences:= false;		StartNexusBlocks;		statesClipboardH := NewHandle(2);		statesUndoH := NewHandle(2);		symbolsUndoSH := StringHandle(NewHandle(2));		copySpecialCustomH1 := StringHandle(NewHandle(SizeOf(str255)));		copySpecialCustomH1^^ := '';		copySpecialCustomH2 := StringHandle(NewHandle(SizeOf(str255)));		copySpecialCustomH2^^ := '';		SetPreferenceValues(nil,paupCommandsID, preferencesFactory,true);		findSequenceMatchMustBeExact:= true;		findSequenceRespectCase := false;		treedataH := NewHandle(2);		StringToH('0', treedataH);		oldtreeH := NewHandle(2);		fixdataH := NewHandle(0);		StringToH('0', fixdataH);		segdataH := NewHandle(0);  {Segments:}		StringToH('0', segdataH);		realBranchLengthsDataH := NewHandle(0);		StringToH('0', realBranchLengthsDataH);		for j := 0 to maxfoottype do			begin				footH[j] := NewHandle(0);				footBytes[j] := 4;			end;		footBytes[footText] := variableFeet;		footResType[footPict] := 'PICT';		footResType[footText] := 'TEXT';{$IFC FOOTSOUNDS}		footResType[footSound] := 'snd ';{$ENDC}		GrowH := NewHandle(growsize);		treefilename := StringHandle(NewHandle(SizeOf(Str255)));		filename := StringHandle(NewHandle(SizeOf(Str255)));		treename := StringHandle(NewHandle(SizeOf(Str255)));		CWClassName := StringHandle(NewHandle(SizeOf(Str255)));		ChartToTypeName := StringHandle(NewHandle(SizeOf(Str255)));		ChartToWtName := StringHandle(NewHandle(SizeOf(Str255)));		undoNameCellStringH := StringHandle(NewHandle(SizeOf(Str255)));		filename^^ := 'Untitled';		treename^^ := ' ';		CWClassName^^ := 'all events';		ChartToTypeName^^ := 'type';		ChartToWtName^^ := 'wts';		undoNameCellStringH^^ := '';		AminoAcidNamesHdl := NewHandle(0);		StringToH(' Ala Cys Asp Glu Phe Gly His Ileu Lys Leu Met Asn Pro Gln Arg Ser Thr Val Trp Tyr * 1.Ser 2.Ser 3 4 ', AminoAcidNamesHdl);		AppendToHandle(AminoAcidNamesHdl, EndNames);		gencode := gencodePtr(NewPtr(SizeOf(gencodearray)));		SetStandardCode(universalCode);   {v3.05: was nuclearCode}		storeH := NewHandle(0);		randomMax := 1;		RandomFillH := RandomArrayHandle(NewHandle(SizeOf(RandomArray)));		randomFillmax := 1;		for j := 0 to randomMax do			RandomFillH^^[j] := 100 div (randomMax + 1);		RandomObservedFillH := RandomArrayHandle(NewHandle(SizeOf(RandomArray)));		randomObservedFillmax := 1;		for j := 0 to randomMax do			RandomObservedFillH^^[j] := 100 div (randomMax + 1);		RandomAncH := RandomArrayHandle(NewHandle(SizeOf(RandomArray)));		randomAncmax := 1;		for j := 0 to randomMax do			RandomAncH^^[j] := 100 div (randomMax + 1);		readBufferBasePtr := NewPtr(readWriteBufferSize);		readBufferCurrentPositionPtr := readBufferBasePtr;		readBufferEndPtr := Ptr(ord4(readBufferBasePtr) + readWriteBufferSize);		writeBufferBasePtr := NewPtr(readWriteBufferSize);		writeBufferCurrentPositionPtr := writeBufferBasePtr;		writeBufferEndPtr := Ptr(ord4(writeBufferBasePtr) + readWriteBufferSize);		readMemoryBuffer:= nil;		readMemoryBufferSize := 0;		for j := 1 to 2 do			extratreefilename[j] := StringHandle(NewHandle(SizeOf(Str255)));		CLkind := CLstandard;		for j := 0 to numCLkinds do			ChartLinearData[j] := NewHandle(0);		CMkind := CMstandard;		for j := 0 to numCMkinds do			ChartMatrixData[j] := CMDPtr(NewPtr(SizeOf(CMDArray)));		equates := EquatesHandle(newhandle(sizeof(equatestype)));		grabpicture := nil;	end;{-----------------------------------------------------------------------------}	procedure StartRgns;	begin		NodeClip := NewRgn;		EWClip := NewRgn;		TWClip := NewRgn;		oldGlobalClip := NewRgn;		updateRgn := NewRgn;		Nodetriangle := OpenPoly;		moveTo(0, 5);		lineto(5, 5);		lineto(5, 0);		lineto(0, 5);		ClosePoly;						lastFlashTime := TickCount;		curFlashPattern := 0;		theflashRgn := NewRgn;	end;{----------------------------------------------------------------------------}	procedure StartCHUNKs;		type			bp = ^Signedbyte;		var			j, k: integer;			ladderstring, bushstring: str255;			bbp: bp;			iip: ip;			dp: Ptr;			dhp: HdlPtr;	begin		PreDefLinks[datafilechain] := 2;		PreDefLinks[treefilechain] := 2;		PreDefLinks[typeSetChain] := 2;		PreDefLinks[wtSetChain] := 1;		PreDefLinks[CharPartitionChain] := 1;		PreDefLinks[exSetChain] := 2;		PreDefLinks[charSetChain] := 0;		PreDefLinks[taxSetChain] := 0;		LinkBytes[typeSetChain] := chtb;		LinkBytes[CharPartitionChain] := chpartb;		LinkBytes[wtSetChain] := chwb;		LinkBytes[taxSetChain] := exb;		LinkBytes[exSetChain] := exb;		LinkBytes[charSetChain] := exb;		for j := 0 to stringchains do			begin				strCHUNKs[j] := NewHandle(PreDefLinks[j] * HdlSize);				HLock(strCHUNKs[j]);   {don't need LockHandle/ResetHandle as just created}				dp := strCHUNKs[j]^;				for k := 1 to PreDefLinks[j] do					begin						dhp := HdlPtr(dp);						dhp^ := NewHandle(2);						dp := Pointer(ord4(dp) + HdlSize);					end;				HUnlock(strCHUNKs[j]);			end;		ladderstring := '      Default_ladder                 LADDER ;';		ladderstring[1] := chr(0);		ladderstring[2] := chr(24);		ladderstring[3] := chr(0);		ladderstring[4] := chr(0);		ladderstring[5] := chr(0);		ladderstring[6] := chr(0);{bbp := bp(ord4(@ladderstring) + 25);}{bbp^ := -128;}{bbp := bp(ord4(@ladderstring) + 26);}{bbp^ := 0;}		ladderstring[25] := chr(-128);		ladderstring[26] := chr(0);		ladderstring[27] := chr(0);		ladderstring[28] := chr(44);		bushstring := '      Default_bush             BUSH ;';		bushstring[1] := chr(0);		bushstring[2] := chr(22);		bushstring[3] := chr(0);		Bitset(@bushstring, 16 + 8);		bushstring[4] := chr(0);		bushstring[5] := chr(0);		bushstring[6] := chr(0);{bbp := bp(ord4(@bushstring) + 23);}{bbp^ := -128;}{    bbp := bp(ord4(@bushstring) + 24);}{bbp^ := 0;}		bushstring[23] := chr(-128);		bushstring[24] := chr(0);		bushstring[25] := chr(0);		bushstring[26] := chr(55);		StringToCHUNK(ladderstring, strCHUNKs[datafilechain], 1);		StringToCHUNK(bushstring, strCHUNKs[datafilechain], 2);		StringToCHUNK(ladderstring, strCHUNKs[treefilechain], 1);		StringToCHUNK(bushstring, strCHUNKs[treefilechain], 2);{$IFC FALSE}		StringToCHUNK('       All_unordered = unord: all;', strCHUNKs[typeSetChain], 1);		StringToCHUNK('       All_ordered  =   ord: all;', strCHUNKs[typeSetChain], 2);		StringToCHUNK('       Equal_weights = 1: all;', strCHUNKs[wtSetChain], 1);		StringToCHUNK('       All_Included = ;', strCHUNKs[exSetChain], 1);		StringToCHUNK('       All_Excluded = all;', strCHUNKs[exSetChain], 2);{$ENDC}		for j := 0 to maxchain do			begin				ChainNames[j] := StringHandle(NewHandle(SizeOf(Str255)));				curLinkNames[j] := StringHandle(NewHandle(SizeOf(Str255)));				curLinkNames[j]^^ := '';			end;		ChainNames[typesetChain]^^ := 'type set';		ChainNames[wtsetChain]^^ := 'weight set';		ChainNames[charPartitionChain]^^ := 'character partition';		ChainNames[treefileChain]^^ := 'tree';		ChainNames[datafileChain]^^ := 'tree';		ChainNames[exsetChain]^^ := 'character inclusion set';		ChainNames[charsetChain]^^ := 'character set';		ChainNames[taxsetChain]^^ := 'taxon set';		taxonCHUNKs := NewHandle(2);		taxstsCHUNKs := NewHandle(2);		chCHUNKs := NewHandle(2);		statenamesCHUNKs := NewHandle(2);		statenamesCHUNKsBU := NewHandle(2);	end;{-----------------------------------------------------------------------------}	procedure StartTypes;		var			k, isfrom, isto: integer;			thp: typeHdlPtr;	begin		curType := unordered;		typeCHUNKs := NewHandle((usedef - 1) * HdlSize);		for k := 1 to usedef - 1 do			begin				thp := typeHdlPtr(GetMaster(typeCHUNKs) + (k - 1) * HdlSize);				thp^ := typeHandle(NewHandle(Sizeof(typeRecord)));			end;		HLock(typeCHUNKs);		thp := typeHdlPtr(GetMaster(typeCHUNKs) + (unordered - 1) * HdlSize);		typeHdl := thp^;		for isfrom := 0 to absmaxstate do			for isto := 0 to absmaxstate do				if isfrom = isto then					typeHdl^^.dist[isfrom, isto] := 0				else					typeHdl^^.dist[isfrom, isto] := 1;		typeHdl^^.max := maxstbit;		typeHdl^^.setdefined := [0..absmaxstate];		typeHdl^^.name := 'unordered';		typeHdl^^.polar := false;		typeHdl^^.isreal := false;		typeHdl^^.root := -1;		thp := typeHdlPtr(GetMaster(typeCHUNKs) + (ordered - 1) * HdlSize);		typeHdl := thp^;		for isfrom := 0 to absmaxstate do			for isto := 0 to absmaxstate do				if isfrom > isto then					typeHdl^^.dist[isfrom, isto] := isfrom - isto				else					typeHdl^^.dist[isfrom, isto] := isto - isfrom;		typeHdl^^.max := maxstbit;		typeHdl^^.setdefined := [0..absmaxstate];		typeHdl^^.name := 'ordered';		typeHdl^^.isreal := false;		typeHdl^^.polar := false;		typeHdl^^.root := 0;		typeHdl^^.maxstar := absmaxstate;		typeHdl^^.nbors[0] := [1];		for isfrom := 1 to absmaxstate - 1 do			typeHdl^^.nbors[isfrom] := [isfrom - 1, isfrom + 1];		typeHdl^^.nbors[absmaxstate] := [absmaxstate - 1];		for isfrom := absmaxstate + 1 to maxCS do			typeHdl^^.nbors[isfrom] := [];		thp := typeHdlPtr(GetMaster(typeCHUNKs) + (irreversible - 1) * HdlSize);		typeHdl := thp^;		for isfrom := 0 to absmaxstate do			for isto := 0 to absmaxstate do				if isfrom > isto then					typeHdl^^.dist[isfrom, isto] := infinity				else					typeHdl^^.dist[isfrom, isto] := isto - isfrom;		typeHdl^^.max := absmaxstate;		typeHdl^^.setdefined := [0..absmaxstate];		typeHdl^^.name := 'irreversible';		typeHdl^^.isreal := false;		typeHdl^^.polar := true;		typeHdl^^.root := -1;		typeHdl := typeHdlPtr(GetMaster(typeCHUNKs) + HdlSize * (Fisher - 1))^;		ResetFisher;		typeHdl^^.max := absmaxstate;		typeHdl^^.setdefined := [0..absmaxstate];		typeHdl^^.name := 'stratigraphic';		typeHdl^^.polar := true;		typeHdl^^.root := -1;		thp := typeHdlPtr(GetMaster(typeCHUNKs) + (Dollo - 1) * HdlSize);		typeHdl := thp^;		typeHdl^^.max := 2;		typeHdl^^.setdefined := [0..2];		typeHdl^^.name := 'Dollo';		typeHdl^^.polar := false;		typeHdl^^.root := -1;		typeHdl^^.isreal := false;		numtypes := usedef - 1;		HUnlock(typeCHUNKs);	end;{-----------------------------------------------------------------------------}	procedure StartThermoWindows;	begin	{	ThermoP := NewPtrClear(SizeOf(ThermoPtropen: boolean;		asPercent: boolean;		allowUpdates: boolean;		backGroundable: boolean;		timeStart: longint;}	end;{-----------------------------------------------------------------------------}	procedure StartCursorsAndTools;  {called BEFORE StartWindows}		var			CursorHdl: CursHandle;			j, k, toolNumber: integer;			ds: str255;	begin		for j := 1 to numToolPalettes do			begin				numTools[j] := 0;				toolPaletteOpen[j] := true;				toolPaletteWasOpen[j] := false;				toolPalettePositionRead[j] := false;				toolPaletteHasExtraMessage[j] := false;				toolPaletteFirstAppearance[j] := true;				numPaletteMessageLines[j] := 1;				toolPaletteOpenOnce[j] := false;			end;					numTools[treeTools] := numTreeTools;		numTools[editorTools] := numEditorTools;		toolPaletteHasExtraMessage[editorTools] := true;		CursorHdl := GetCursor(iBeamCursor);		ibeam := CursorHdl^^;		CursorHdl := GetCursor(watchCursor);		clockCursor := CursorHdl^^;		LoadCursor(clasper, 259);		LoadCursor(oldtreecurs, 500);		LoadCursor(newcolcurs, 270);		LoadCursor(newrowcurs, 271);		LoadCursor(DnstsCurs, 5438);		LoadCursor(MinLenCurs, 25986);		LoadCursor(StatesCurs, 29854);		LoadCursor(downpassCurs, 29285);		LoadCursor(upPassCurs, 16445);		LoadCursor(TriplePassCurs, 9213);		LoadCursor(linkcurs, 286);		LoadCursor(closedscissors, 284);		LoadCursor(downscissors, 25220);		LoadCursor(closeddownscissors, 1305);		LoadCursor(downcollapse, 4041);		handcurs.H := GetCursor(handcursID);		fullbrush.H := GetCursor(fullbrushID);		emptybrush.H := GetCursor(emptybrushID);		diamond.H := GetCursor(diamondID);		arrowcurs.H := nil;		handcurs.colorH := nil;		fullbrush.colorH := nil;		emptybrush.colorH := nil;		diamond.colorH := nil;		arrowcurs.colorH := nil;		if colorQDExists then			begin				fullbrush.colorH := GetCCursor(fullbrushID);				emptybrush.colorH := GetCCursor(emptybrushID);				handcurs.colorH := GetCCursor(handCursID);				diamond.colorH := GetCCursor(diamondID);			end;		for j := 0 to 5 do			LoadCursor(cyclecurs[j], 350 + j);		tool^[treeTools,rerootT].cursID := 128;		tool^[treeTools,scissorsT].cursID := 129;		tool^[treeTools,SwapT].cursID := 131;		tool^[treeTools,collapseT].cursID := 132;		tool^[treeTools,collapseallT].cursID := 133;		tool^[treeTools,ancT].cursID := 134;		tool^[treeTools,expandT].cursID := 135;		tool^[treeTools,handT].cursID := 139;		tool^[treeTools,polyflipT].cursID := 137;		tool^[treeTools,rotateT].cursID := 138;		tool^[treeTools,ladderT].cursID := 136;		tool^[treeTools,queryT].cursID := 140;		tool^[treeTools,traceTickT].cursID := 130;		tool^[treeTools,treeWandT].cursID := 157;		tool^[treeTools,paintT].cursID := 143;		tool^[treeTools,turpentineT].cursID := 142;		tool^[treeTools,evolveSegmentsT].cursID := 141;		tool^[treeTools,statsTestT].cursID := 144;		tool^[treeTools,treePictureT].cursID := 145;				for j := 0 to numTools[treeTools] do			begin				if j <> arrowT then					tool^[treeTools,j].curs.H := GetCursor(tool^[treeTools,j].cursID);				tool^[treeTools,j].curs.colorH := nil;				if colorQDExists then					if j <> arrowT then						tool^[treeTools,j].curs.colorH := GetCCursor(tool^[treeTools,j].cursID);				tool^[treeTools,j].hasOptionCurs := false;				tool^[treeTools,j].behaveAsArrowOnRCNumbers := false;				tool^[treeTools,j].behaveAsArrowOnTaxonNumbers := false;				tool^[treeTools,j].behaveAsArrowOnCharacterNumbers := false;				tool^[treeTools,j].worksInNameCells := true;				tool^[treeTools,j].hasTransposedCursor := false;				tool^[treeTools,j].hasPopUpMenu := false;				tool^[treeTools,j].worksOnTicks := false;{$IFC FALSE}				for k := 0 to 2 do					begin						GetIndString(ds, 257, j * 3 + k + 1);						tool^[treeTools,j].message[k] := CopyString(ds, 1, 31);					end;{$ENDC}			end;		AdjustToolBoxes(treeTools);		tool^[editorTools,magicWandT].cursID := 600;		tool^[editorTools,editorSelectionT].cursID := 601;	{	tool^[editorTools,editorArrowT].cursID := 602;}				tool^[editorTools,selectToEndT].cursID := 603;		tool^[editorTools,stampPasteT].cursID := 604;		tool^[editorTools,editorScissorsT].cursID := 605;				tool^[editorTools,closeGapsT].cursID := 606;		tool^[editorTools,selectedBlockMoveT].cursID := 607;		tool^[editorTools,blockMoveT].cursID := 608;		tool^[editorTools,splitBlockOtherT].cursID := 609;		tool^[editorTools,splitBlockT].cursID := 610;		tool^[editorTools,splitBlockT].optionCursID := 618;		{tool^[editorTools,splitMultiBlockT].cursID := 618;}		tool^[editorTools,autoAlignT].cursID := 611;		tool^[editorTools,showPictureT].cursID := 613;		tool^[editorTools,popUpStatesT].cursID := 614;		tool^[editorTools,popUpStatesT].optionCursID := 726;				tool^[editorTools,editorSortT].cursID := 147;		tool^[editorTools,editorSortT].optionCursID := 158;				tool^[editorTools,editorBucketT].cursID := 615;		tool^[editorTools,editorPaintBrushT].cursID := 616;		tool^[editorTools,eyedropperT].cursID := 617;		for j := 0 to numTools[editorTools] do			begin				if j <> editorArrowT then					tool^[editorTools,j].curs.H := GetCursor(tool^[editorTools,j].cursID);				tool^[editorTools,j].curs.colorH := nil;				if colorQDExists then					if j <> editorArrowT then						tool^[editorTools,j].curs.colorH := GetCCursor(tool^[editorTools,j].cursID);				tool^[editorTools,j].hasOptionCurs := false;				tool^[editorTools,j].enabled := true;				tool^[editorTools,j].behaveAsArrowOnRCNumbers := false;				tool^[editorTools,j].behaveAsArrowOnTaxonNumbers := false;				tool^[editorTools,j].behaveAsArrowOnCharacterNumbers := false;				tool^[editorTools,j].worksInNameCells := true;				tool^[editorTools,j].hasTransposedCursor := false;				tool^[editorTools,j].hasPopUpMenu := false;				tool^[editorTools,j].worksInDataCells := true;				tool^[editorTools,j].worksOnTicks := false;{$IFC FALSE}				for k := 0 to 2 do					begin						GetIndString(ds, 257, j * 3 + k + 1);						tool^[editorTools,j].message[k] := CopyString(ds, 1, 31);					end;{$ENDC}			end;		AdjustToolBoxes(editorTools);		{tool^[editorTools,popUpStatesT].worksInNameCells := false;}		tool^[editorTools,editorSortT].hasOptionCurs := true;		tool^[editorTools,editorSortT].hasPopUpMenu := true;		tool^[editorTools,editorSortT].worksInDataCells := false;		tool^[editorTools,popupStatesT].hasPopUpMenu := true;		tool^[editorTools,popupStatesT].hasOptionCurs := true;		tool^[editorTools,magicWandT].behaveAsArrowOnRCNumbers := true;		tool^[editorTools,magicWandT].hasPopUpMenu := true;		tool^[editorTools,editorArrowT].behaveAsArrowOnRCNumbers := true;		tool^[editorTools,selectedBlockMoveT].behaveAsArrowOnRCNumbers := true;		tool^[editorTools,SelectedBlockMoveT].hasPopUpMenu := true;		tool^[editorTools,splitBlockOtherT].worksInNameCells := false;		tool^[editorTools,splitBlockOtherT].behaveAsArrowOnRCNumbers := true;		tool^[editorTools,splitBlockT].behaveAsArrowOnRCNumbers := true;		tool^[editorTools,splitBlockT].hasOptionCurs := true;		tool^[editorTools,splitBlockT].hasOptionCurs := true;				tool^[editorTools,editorPaintBrushT].behaveAsArrowOnRCNumbers := true;		tool^[editorTools,editorPaintBrushT].worksInNameCells := false;				{tool^[editorTools,splitMultiBlockT].behaveAsArrowOnRCNumbers := true;}		tool^[editorTools,showPictureT].behaveAsArrowOnRCNumbers := true;		tool^[editorTools,showPictureT].hasPopUpMenu := true;		tool^[editorTools,selectToEndT].hasPopUpMenu := true;				tool^[editorTools,blockMoveT].behaveAsArrowOnRCNumbers := true;		tool^[editorTools,blockMoveT].hasPopUpMenu := true;		tool^[editorTools,eyedropperT].behaveAsArrowOnCharacterNumbers := true;		{tool^[editorTools,eyedropperT].worksInNameCells := false;}				tool^[editorTools,editorBucketT].behaveAsArrowOnRCNumbers := true;		tool^[editorTools,editorBucketT].hasPopUpMenu := true;		tool^[editorTools,editorBucketT].worksInNameCells := false;				tool^[editorTools,editorScissorsT].hasPopUpMenu := true;		tool^[editorTools,editorScissorsT].worksInNameCells := false;		tool^[editorTools,editorScissorsT].hasOptionCurs := true;		tool^[editorTools,editorScissorsT].optionCursID := 722;		tool^[editorTools,autoAlignT].behaveAsArrowOnRCNumbers := true;		tool^[editorTools,autoAlignT].hasPopUpMenu := true;		tool^[editorTools,closeGapsT].behaveAsArrowOnRCNumbers := true;		tool^[editorTools,closeGapsT].worksInNameCells := false;		tool^[editorTools,closeGapsT].hasPopUpMenu := true;		tool^[editorTools,closeGapsT].hasOptionCurs := true;		tool^[editorTools,closeGapsT].optionCursID := 707;		tool^[editorTools,stampPasteT].behaveAsArrowOnRCNumbers := true;		tool^[editorTools,stampPasteT].worksInNameCells := false;		tool^[editorTools,splitBlockT].hasPopUpMenu := true;								tool^[treeTools,ancT].hasPopUpMenu := true;		tool^[treeTools,paintT].hasPopUpMenu := true;		tool^[treeTools,rerootT].hasPopUpMenu := true;		tool^[treeTools,scissorsT].hasPopUpMenu := true;		tool^[treeTools,ladderT].hasPopUpMenu := true;		tool^[treeTools,evolveSegmentsT].hasPopUpMenu := true;		tool^[treeTools,treePictureT].hasPopUpMenu := true;		tool^[treeTools,collapseallT].hasPopUpMenu := true;		tool^[treeTools,SwapT].hasPopUpMenu := true;		tool^[treeTools,queryT].hasPopUpMenu := true;		tool^[treeTools,traceTickT].hasPopUpMenu := true;				tool^[treeTools,scissorsT].worksOnTicks := true;		tool^[treeTools,queryT].worksOnTicks := true;		tool^[treeTools,traceTickT].worksOnTicks := true;		tool^[treeTools,treeWandT].worksOnTicks := true;		tool^[treeTools,arrowT].curs.H := nil;		tool^[treeTools,arrowT].curs.colorH := nil;		tool^[editorTools,editorArrowT].curs.H := nil;		tool^[editorTools,editorArrowT].curs.colorH := nil;	{	tool^[editorTools,magicWandT].hasOptionCurs := true;		tool^[editorTools,magicWandT].optionCursID := 701;}		tool^[editorTools,selectToEndT].hasOptionCurs := true;		tool^[editorTools,selectToEndT].optionCursID := 720;{		tool^[treeTools,queryT].hasOptionCurs := true;		tool^[treeTools,queryT].optionCursID := 130;}		tool^[treeTools,paintT].curs := emptybrush;		tool^[treeTools,rerootT].hasOptionCurs := true;		tool^[treeTools,paintT].hasOptionCurs := true;		tool^[treeTools,ladderT].hasOptioncurs := true;		tool^[treeTools,scissorsT].hasOptionCurs := true;		tool^[treeTools,collapseallT].hasOptionCurs := true;		{tool^[treeTools,rotateT].hasOptionCurs := true;}		tool^[treeTools,swapT].hasOptionCurs := true;		tool^[treeTools,ladderT].optionCursID := 154;		tool^[treeTools,paintT].optionCursID := 152;		tool^[treeTools,rerootT].optionCursID := 150;		tool^[treeTools,scissorsT].optionCursID := 25220;		tool^[treeTools,collapseallT].optionCursID := 4041;		{tool^[treeTools,rotateT].optionCursID := 23847;}		tool^[treeTools,SwapT].optionCursID := 240;		for k := 1 to numInfoWindows do			begin				for j:= 0 to numInfoTools do					begin						SetRect(infoTools^[k,j].R,0,0,0,0);						infoTools^[k,j].enabled := true;						infoTools^[k,j].cursorID := 0;						infoTools^[k,j].hasOptionCursor:= false;						infoTools^[k,j].optionCursorID:= 0;						infoTools^[k,j].hasControlCursor := false;						infoTools^[k,j].controlCursorID := 0;					end;				infoTools^[k,infoScissorsT].cursorID := 800;				infoTools^[k,infoWandT].cursorID := 801;				infoTools^[k,infoWandT].hasOptionCursor := true;				infoTools^[k,infoWandT].optionCursorID := 804;				infoTools^[k,infoWandT].hasControlCursor := true;				infoTools^[k,infoWandT].controlCursorID := 805;				infoTools^[k,infoSortAscendingT].cursorID := 802;				infoTools^[k,infoSortAscendingT].hasOptionCursor := true;				infoTools^[k,infoSortAscendingT].optionCursorID := 803;				infoTools^[k,infoSortDescendingT].cursorID := 803;				infoTools^[k,infoSortDescendingT].hasOptionCursor := true;				infoTools^[k,infoSortDescendingT].optionCursorID := 802;				currentInfoTool[k] := infoArrowT;			end;				maxSearchCursors[searchSwap] := maxSearchSwapCurs;		maxSearchCursors[searchAncestor] := maxSearchAncestorCurs;		searchCursorBaseID[searchSwap] := 500;		searchCursorBaseID[searchAncestor] := 900;		searchCursorNumber[searchSwap] := -1;		searchCursorNumber[searchAncestor] := -1;				//	InitCursor;		//InitCursorCtl(nil);	end;{-----------------------------------------------------------------------------}	procedure DeleteQuitItem;	begin{$IFC CARBON}		if isMacOSX then			begin				DeleteMenuItem(FileMHdl,QuitItem);				DeleteMenuItem(FileMHdl,QuitItem-1);			end;{$ENDC}	end;{-----------------------------------------------------------------------------}	procedure StartMenus;		var			rc, j: integer;			os: OSStatus;{$IFC CARBON}			outHierMenuCount: ItemCount;{$ENDC}	begin		AppleMHdl := GetMenuHandle(AppleMenu);		EditMHdl := GetMenuHandle(EditMenu);		FileMHdl := GetMenuHandle(FileMenu);		WindowsMHdl := GetMenuHandle(WindowsMenu);		EWDisplayMHdl := GetMenuHandle(EWDisplayMenu);		EdUtilitiesMHdl := GetMenuHandle(EdUtilitiesMenu);		CharactersMHdl := GetMenuHandle(CharactersMenu);		TaxaMHdl := GetMenuHandle(TaxaMenu);		ChartViewsMHdl := GetMenu(ChartViewsMenu);		FindMHdl := GetMenu(FindMenu);		TypeMHdl := GetMenu(TypeMenu);		WeightMHdl := GetMenu(WeightMenu);		CharPartMHdl := GetMenu(CharPartMenu);		CharPartListMHdl := GetMenu(CharPartListMenu);		ShowMHdl := GetMenu(ShowMenu);		ColorCellsMHdl := GetMenu(ColorCellsMenu);		IncExcMHdl := GetMenu(IncExcMenu);		IncExcTaxaMHdl := GetMenu(IncExcTaxaMenu);		CodingMHdl := GetMenu(CodingMenu);		SimpleSelectMHdl := GetMenu(SimpleSelectMenu);		InfoSelectMHdl := GetMenu(InfoSelectMenu);		InfoMoveMHdl := GetMenu(InfoMoveMenu);		ShadeCharSetMHdl := GetMenu(ShadeCharSetMenu);		NexusBlocksMHdl := GetMenu(NexusBlocksMenu);		DataMatrixStyleMHdl := GetMenu(DataMatrixStyleMenu);		TextMHdl := GetMenu(TextMenu);		ColumnWidthMHdl := GetMenu(ColumnWidthMenu);		SaveOtherMHdl := GetMenu(SaveOtherMenu);		PrintOtherMHdl := GetMenu(PrintOtherMenu);		SaveOptionsMHdl := GetMenu(SaveOptionsMenu);		CopySpecialMHdl := GetMenu(CopySpecialMenu);		ConsensusTaxSetMHdl := GetMenu(ConsensusTaxSetMenu);		TaxonListOptionsMHdl := GetMenu(TaxonListOptionsMenu);		CharListOptionsMHdl := GetMenu(CharListOptionsMenu);		GoToMHdl := GetMenu(GoToMenu);		xxCreateCharactersMHdl := GetMenu(xxCreateCharactersMenu);		xxCharacterSetsMHdl := GetMenu(xxCharacterSetsMenu);		xxDataFormatMHdl := GetMenu(xxDataFormatMenu);				xxCreateTaxaMHdl := GetMenu(xxCreateTaxaMenu);		xxImportTaxaMHdl := GetMenu(xxImportTaxaMenu);		xxTaxonSetsMHdl := GetMenu(xxTaxonSetsMenu);		xxCreateTreesMHdl := GetMenu(xxCreateTreesMenu);		xxTypeSetsMHdl := GetMenu(xxTypeSetsMenu);		xxWeightSetsMHdl := GetMenu(xxWeightSetsMenu);		xxInclusionSetsMHdl := GetMenu(xxInclusionSetsMenu);				AATranslateMHdl := GetMenu(AATranslateMenu);		ColorCodPosMHdl := GetMenu(ColorCodPosMenu);		ColorCharPartitionMHdl := GetMenu(ColorCharPartitionMenu);		ReplaceAllMHdl := GetMenu(ReplaceAllMenu);		MismatchMHdl := GetMenu(MismatchMenu);		FontMHdl := GetMenu(FontMenu);		SizeMHdl := GetMenu(SizeMenu);		StyleMHdl := GetMenu(StyleMenu);				dlogFontMHdl := GetMenu(dlogFontMenu);		dlogSizeMHdl := GetMenu(dlogSizeMenu);		dlogStyleMHdl := GetMenu(dlogStyleMenu);		dlogImportTaxaMHdl:= GetMenu(dlogImportTaxaMenu);				ExpFileMHdl := GetMenu(ExpFileMenu);		ExpTreeMHdl := GetMenu(ExpTreeMenu);		{DataFormMHdl := GetMenu(DataFormMenu);}		{curMCTable := GetMCInfo;}		tearpt.h := 0;		tearpt.v := GetMBarHeight+10;		for j := 1 to numToolPalettes do			begin				toolPalettePoint[j].h := 0;				toolPalettePoint[j].v := GetMBarHeight+10;			end;		Setrect(tearrect, 0, 0, 0, 0);		EWMBar := GetNewMBar(258);		SetEWMBar;		DeleteQuitItem;				TWMBar := GetNewMBar(256);		SetTWMBar;		DeleteQuitItem;		CloseFileMBar := GetNewMBar(259);		SetCloseFileMBar;		DeleteQuitItem;		NoWMBar := GetNewMBar(260);		SetNoWMBar;		DeleteQuitItem;				EquivMBar := GetNewMBar(262);		SetEquivMBar;		DeleteQuitItem;		ChartMBar := GetNewMBar(261);		SetChartMBar;		DeleteQuitItem;		{SetMCInfo(curMCTable);}		InsertSubMenus(EquivMBar); 		InsertSubMenus(NoWMBar);		InsertSubMenus(EWMBar);		InsertSubMenus(ChartMBar);		InsertSubMenus(TWMBar);	{$IFC NOT CARBON}		AppendResMenu(AppleMHdl, 'DRVR');		AppendResMenu(FontMHdl, 'FONT');		AppendResMenu(dlogFontMHdl, 'FONT');{$ELSEC}		os := CreateStandardFontMenu (FontMHdl, 0,100,kNilOptions,outHierMenuCount);		os := CreateStandardFontMenu (dlogFontMHdl, 0,100,kNilOptions,outHierMenuCount);{$ENDC}		SetCloseFileMBar;{$IFC HELPMENU}		if hasBalloonHelp then			begin				rc := HMGetHelpMenuHandle(hHelpMHdl);				if (rc = 0) & (hHelpMHdl <> nil) then					begin						AppendMenu(hHelpMHdl, 'MacClade Help');						myHelpMenuItem := myCountMenuItems(hHelpMHdl);					end;			end;{$ENDC}	end;{-----------------------------------------------------------------------------}	procedure StartPatternsColors;		var			j: integer;			orangeRGB: RGBColor;			brownRGB, purpleRGB: RGBColor;			paletteH: PaletteHandle;			theColor: RGBColor;	begin{=====Patterns & Colours =====}		blackRGB.red := $0000;		blackRGB.green := $0000;		blackRGB.blue := $0000;				defaultPartitionRGB.red := $BBBB;		defaultPartitionRGB.green := $BBBB;		defaultPartitionRGB.blue := $BBBB;				whiteRGB.red := $FFFF;		whiteRGB.green := $FFFF;		whiteRGB.blue := $FFFF;		polyMorphColor.red := $CCCC;		polyMorphColor.green := $CCCC;		polyMorphColor.blue := $8888;{*** remember, if you change the redRGB, greenRGB, or blueRGB, change the resources for the coding menu!!!}{color used for 3rd positions}		redRGB.red := $DD6B;    {56683}		redRGB.green := $08C2;  {2242}		redRGB.blue := $06A2;   {1698}		  {color used for 2nd positions}		greenRGB.red := $1018;    {4120}		greenRGB.green := $FFFF;  {65535}		greenRGB.blue := $60FB;   {24827}{color used for 1st positions}		blueRGB.red := $0241;    {577}		blueRGB.green := $AB54;  {43860}		blueRGB.blue := $EAFF;   {60159}		purRGB:= redRGB;		pyrRGB:= blueRGB;		faintTextRGB.red := $0000;		faintTextRGB.green := $9999;		faintTextRGB.blue := $3333;{$IFC TRUE}		gridColor.red := $9078;		gridColor.green := $C4C4;		gridColor.blue := $FFFF;{$ELSEC}		gridColor.red := $AFFF;		gridColor.green := $AFFF;		gridColor.blue := $AFFF;{$ENDC}				editorEdgeColor.red := $9791;		editorEdgeColor.green := $EC4F;		editorEdgeColor.blue := $FFFF;				codeNotSetRGB.red := $9FFF;		codeNotSetRGB.green := $8FFF;		codeNotSetRGB.blue := $5555;						defColor := blackRGB;				STUFFHEX(@dashpat, '55AA55AA55AA55AA');  {specifying patterns}{STUFFHEX(@dashpat, 'CCCCCCCCCCCCCCCC');  old dash pat}		GetIndPattern(equivocalPattern, 200, 1);		//equivocalPPH := GetPixPat(128);		GetIndPattern(stratpat, 200, 5);		GetIndPattern(polym, 200, 2);		GetIndPattern(upterm, 200, 3);		GetIndPattern(uncert, 200, 4);				equivocalPPH := nil;		polymPPH := nil;		uncertPPH := nil; 		dashpatPPH := nil;		stratpatPPH := nil;		uptermPPH := nil;		//equivocalPPH := GetPixPat(128);		for j := 0 to 15 do			GetIndPattern(pat[j], 201, j + 1);		for j := 16 to 31 do			GetIndPattern(pat[j], 202, j - 15);		{for j := 0 to absmaxnumstates do			colorCellkey^[j] := colorKey^[absmaxnumstates, j];}		{		nonpolarAA = [0, 4, 7, 9, 10, 12, 17, 18];		polarAA = [1, 5, 11, 13, 15, 16, 19];		negativeAA = [2, 3];		positiveAA = [8, 6, 14];}		{		protSymbols = 'ACDEF GHIKL MNPQR STVWY *1234';}				end;{-----------------------------------------------------------------------------}	procedure StartTextEdits;		var			box: rect;			tempP: WindowPtr;			j: integer;	begin		genericGetPort(tempP);		genericSetPort(editorWindow);		SetRect(box, 100, 100, 200, 200);		editorCellTE := TENew(box, box);		editorCellTE^^.crOnly := -1;		noteTE := TENew(box, box);{ noteTE^^.crOnly := -1;   - we don't need this if we have multiple-line footnotes}{		genericSetPort(commWindow);		box := WindowPortRect(commWindow);		box.right := box.right - scrollwidth - 1;		box.left := box.left + 5;		for j := 0 to numcoms do			begin				commentsTE[j] := TENew(box, box);				TEAutoView(true, commentsTE[j]);			end;}		SetRect(box, 100, 100, 200, 200);		genericSetPort(statesWindow);		statesTE := TENew(box, box);		statesTE^^.crOnly := -1;		for j := 1 to numInfoWindows do			begin				genericSetPort(infoWindow[j]);				SetRect(box, 100, 100, 200, 200);				infoTE[j] := TENew(box, box);				infoTE[j]^^.crOnly := -1;			end;		{genericSetPort(treewindow);		SetRect(box, 5, 0, 5 + MaxMenuWidth, 400);		TextFont(kFontIDGeneva);		TextSize(9);		stringTE := TENew(box, box);   		genericSetPort(tempP);}	end;{-----------------------------------------------------------------------------}	function MakeWindow (wStorage: Ptr; box: rect; title: str255; ioName: str15; visible: boolean; procID: integer; behind: WindowPtr; goAwayFlag: boolean; windowType: longint): WindowPtr;	var wP: windowInfoP;	begin		wP := WindowInfoP(NewPtrClear(SizeOf(windowInfo)));		wP^.windowType := windowType;		wP^.updatesAllowed := true;		wP^.order := 0;		wP^.name := ioName;				if colorQDExists then			MakeWindow := WindowPtr(NewCWindow(nil, box, title, visible, procID, behind, goAwayFlag, longint(wP)))		else			MakeWindow := NewWindow(nil, box, title, visible, procID, behind, goAwayFlag, longint(wP));	end;{-----------------------------------------------------------------------------}	function MakeCarbonWindow (wStorage: Ptr; box: rect; title: str255; ioName: str15; visible: boolean; class: WindowClass; attributes: WindowAttributes; behind: WindowPtr; goAwayFlag: boolean; windowType: longint): WindowPtr;	var wP: windowInfoP;		os : OSStatus;		windowReference: WindowRef;	begin		wP := WindowInfoP(NewPtrClear(SizeOf(windowInfo)));		wP^.windowType := windowType;		wP^.updatesAllowed := true;		wP^.order := 0;		wP^.name := ioName;				os := CreateNewWindow (class, attributes, box, windowReference);		if (os=NoErr) then			begin				SetWRefCon(windowReference, sInt32(wP));				SetWTitle(windowReference, title);				MakeCarbonWindow := windowReference;			end		else			MakeCarbonWindow := nil;	end;{-----------------------------------------------------------------------------}	procedure StartInfoColumns;		const			incExcWidth = 18;			infoExpandWidth = 12;		var			j, k: integer;	begin				for j := 1 to numinfoWindows do			begin				InfoCol[j] := nil;				infoWithButtons[j] := false;				infoWithToolRow[j] := true;				SetRect(infoDrawRect[j],0,0,0,0);			end;{    CreateInfoColumn(whichInfo, colID,width, '',  isstring, show, menu);}		CreateInfoColumn(typeinfo, 0, 140, 'Type', true, true, true,false,columnIsString); 		CreateInfoColumn(typeinfo, TypeInfoExpand, infoExpandWidth, '', false, true, false,true,columnIsString);		CreateInfoColumn(typeinfo, TypeInfoCategory, 110, 'Category', true, true, false,true,columnIsString);		CreateInfoColumn(treeinfo, 0, 140, 'Tree', true, true, true,false,columnIsString);  		{CreateInfoColumn(treeinfo, TreeInfoExpand, infoExpandWidth, '', false, true, false,true,columnIsString);}		{CreateInfoColumn(treeinfo, TreeInfoIncExc, incExcWidth, '', false, true, true,true,columnIsString);}		CreateInfoColumn(treeinfo, TreeInfoNumTaxa, 36, 'Taxa', true, true, false,true,columnIsLongint);  {number of taxa}		CreateInfoColumn(treeinfo, TreeInfoPoly, 86, 'Polytomies', true, true, false,true,columnIsBoolean);		CreateInfoColumn(treeinfo, TreeInfoFixAnc,116, 'Fixed Ancestors', true, true, false,true,columnIsBoolean);		infoWithButtons[treeinfo] := true;		CreateInfoColumn(nexusBlockinfo, 0, 140, 'Block', true, true, false,false,columnIsString);  		CreateInfoColumn(nexusBlockinfo, NexusBlockInfoForeign, 72, 'MacClade', true, true, false,true,columnIsString);		CreateInfoColumn(nexusBlockinfo, NexusBlockInfoWithForeignLines, 82, 'Foreign Lines', true, true, false,true,columnIsString);		CreateInfoColumn(nexusBlockinfo, NexusBlockInfoWillWrite, 76, 'Will Write', true, true, false,true,columnIsString);		CreateInfoColumn(nexusBlockinfo, NexusBlockInfoTitle, 106, 'Title', true, true, false,true,columnIsString);		CreateInfoColumn(nexusBlockinfo, NexusBlockInfoLinkText, 136, 'Link', true, true, false,true,columnIsString);		CreateInfoColumn(taxinfo, 0, 140, 'Taxon', true, true, true,false,columnIsString);  		CreateInfoColumn(taxinfo, TaxInfoIncExc, incExcWidth, '', false, true, true,true,columnIsBoolean);		CreateInfoColumn(taxinfo, TaxInfoSeqLength, 75, 'Seq Length', true, true, false,true,columnIsLongint);		CreateInfoColumn(taxinfo, TaxInfoMissing, 70, '% Missing', true, true, false,true,columnIsLongint);		CreateInfoColumn(taxinfo, TaxInfoGaps, 60, '% Gaps', true, true, false,true,columnIsLongint);		CreateInfoColumn(taxinfo, TaxInfoA, 40, '%A', true, true, false,true,columnIsDouble);		CreateInfoColumn(taxinfo, TaxInfoC, 40, '%C', true, true, false,true,columnIsDouble);		CreateInfoColumn(taxinfo, TaxInfoG, 40, '%G', true, true, false,true,columnIsDouble);		CreateInfoColumn(taxinfo, TaxInfoT, 40, '%T', true, true, false,true,columnIsDouble);		CreateInfoColumn(taxinfo, TaxInfoAT, 40, '%A+T', true, true, false,true,columnIsDouble);		CreateInfoColumn(taxinfo, TaxInfoStopCodons, 70, 'Stop Codons', true, false, false,true,columnIsLongint);		CreateInfoColumn(taxinfo, TaxInfoPartTriplets, 76, 'Part Triplets', true, false, false,true,columnIsLongint);		CreateInfoColumn(taxinfo, TaxInfoFirstBase, 70, 'First Data', true, false, false,true,columnIsLongint);		CreateInfoColumn(taxinfo, TaxInfoLastBase, 70, 'Last Data', true, false, false,true,columnIsLongint);		CreateInfoColumn(taxinfo, TaxInfoLowerCase, 76, '% Lower Case', true, true, false,true,columnIsDouble);		CreateInfoColumn(taxinfo, TaxInfoUncertainty, 84, 'Uncertainties', true, false, false,true,columnIsLongint);		CreateInfoColumn(taxinfo, TaxInfoPolymorphism, 92, 'Polymorphisms', true, false, false,true,columnIsLongint);		{CreateInfoColumn(taxinfo, TaxInfoRank, 52, 'Rank', true, true, true,true);		CreateInfoColumn(taxinfo, TaxInfoNetLinks, 70, 'ToL Links', true, true, true,true);		CreateInfoColumn(taxinfo, TaxInfoTOLItems, 56, 'ToL Items', false, true, true,true);}		CreateInfoColumn(charinfo, 0, 140, 'Character', true, true, true,false,columnIsString);  		{CreateInfoColumn(charinfo, CharInfoExpand, infoExpandWidth, '', false, true, false,true,columnIsString);}		CreateInfoColumn(charinfo, CharInfoIncExc, incExcWidth, '', false, true, true,true,columnIsBoolean);		CreateInfoColumn(charinfo, CharInfoCodPos, 36, 'Pos', true, false, true,true,columnIsString);		CreateInfoColumn(charinfo, CharInfoPartition, 80, 'Group', true, true, true,true,columnIsLongint);		CreateInfoColumn(charinfo, CharInfoTypes, 80, 'Type', true, true, true,true,columnIsString);		CreateInfoColumn(charinfo, CharInfoWeights, 54, 'Weight', true, true, true,true,columnIsLongint);		CreateInfoColumn(charinfo, CharInfoStates, 46, 'States', true, true, false,true,columnIsLongint);		CreateInfoColumn(charinfo, CharInfoMissing, 70, '% Missing', true, false, false,true,columnIsLongint);		CreateInfoColumn(charinfo, CharInfoGaps, 60, '% Gaps', true, false, false,true,columnIsLongint);		CreateInfoColumn(charinfo, CharInfoSteps, 46, 'Steps', true, false, false,true,columnIsLongint);		CreateInfoColumn(charinfo, CharInfoChgs, 54, 'Changes', true, false, false,true,columnIsString);		CreateInfoColumn(charinfo, CharInfoCI, 36, 'CI', true, false, false,true,columnIsDouble);		CreateInfoColumn(charinfo, CharInfoRI, 36, 'RI', true, false, false,true,columnIsDouble);		CreateInfoColumn(charinfo, CharInfoMin, 36, 'Min', true, false, false,true,columnIsLongint);		CreateInfoColumn(charinfo, CharInfoMax, 36, 'Max', true, false, false,true,columnIsLongint);		CreateInfoColumn(charinfo, CharInfoRC, 36, 'RC', true, false, false,true,columnIsDouble);		CreateInfoColumn(charinfo, CharInfoPolymorphisms, 86, 'Polymorphisms', true, false, false,true,columnIsBoolean);		CreateInfoColumn(charinfo, CharInfoMPRs, 60, 'MPRs', true, false, false,true,columnIsDouble);		infoWithButtons[charinfo] := true;		CreateInfoColumn(charpartinfo, 0, 140, 'Char Partitions', true, true, true,false,columnIsString);  		CreateInfoColumn(charpartinfo, CharPartInfoNumParts, 54, 'Groups', true, true, false,true,columnIsLongint);		infoWithButtons[charpartinfo] := true;		CreateInfoColumn(charpartnameinfo, 0, 140, 'Group Labels', true, true, true,false,columnIsString);  		CreateInfoColumn(charpartnameinfo, CharPartNameInfoColor, 50, 'Color', false, true, false,false,columnIsColor);		infoWithButtons[charpartnameinfo] := false;		CreateInfoColumn(wtsetinfo, 0, 140, 'Weight Sets', true, true, true,false,columnIsString);  		CreateInfoColumn(wtsetinfo, WtSetInfoMinWt, 46, 'Min', true, true, false,true,columnIsString);		CreateInfoColumn(wtsetinfo, WtSetInfoMaxWt, 46, 'Max', true, true, false,true,columnIsString);		{CreateInfoColumn(wtsetinfo, WtSetInfoReal, 70, 'Real-values', true, true, false,true,columnIsString);}		infoWithButtons[wtsetinfo] := true;		CreateInfoColumn(charsetinfo, 0, 140, 'Character Sets', true, true, true,false,columnIsString);  		CreateInfoColumn(charsetinfo, CharSetInfoNumberChars, 36, 'Chars', true, true, false,true,columnIsString);				CreateInfoColumn(taxsetinfo, 0, 140, 'Taxon Sets', true, true, true,false,columnIsString);  		CreateInfoColumn(taxsetinfo, TaxSetInfoNumberTaxa, 36, 'Taxa', true, true, false,true,columnIsString);				CreateInfoColumn(typesetinfo, 0, 140, 'Type Sets', true, true, true,false,columnIsString);  		CreateInfoColumn(typesetinfo, TypeSetInfoDirected, 60, 'Directed', true, true, false,true,columnIsBoolean);		CreateInfoColumn(typesetinfo, TypeSetInfoUserDefined, 76, 'User-defined', true, true, false,true,columnIsBoolean);		infoWithButtons[typesetinfo] := true;		CreateInfoColumn(exsetinfo, 0, 140, 'Inclusion Sets', true, true, true,false,columnIsString);  		CreateInfoColumn(exsetinfo, ExSetInfoNumberChars, 36, 'Chars', true, true, false,true,columnIsString);		infoWithButtons[exsetinfo] := true;		for j := 1 to maxSelectObjects do			begin				RenameDeleteSetMenuItem[j] := -1;				SaveSetItem[j] := -1;			end;		for j := 1 to numinfoWindows do			begin				infoNameStart[j] := 0;				infoNameEnd[j] := 10;				infoEditing[j] := false;				infoEditRow[j] := 0;				infoLocked[j] := false;				InfoObjectName[j] := '';			end;		InfoObjectName[charinfo] := 'Characters';		InfoObjectName[taxinfo] := 'Taxa';		InfoObjectName[treeinfo] := 'Trees';		InfoObjectName[typeinfo] := 'Types';		InfoObjectName[charsetinfo] := 'Character Sets';		InfoObjectName[taxsetinfo] := 'Taxon Sets';		InfoObjectName[wtsetinfo] := 'Weight Sets';		InfoObjectName[charpartinfo] := 'Character Partitions';		InfoObjectName[charpartnameinfo] := 'Group Labels';		InfoObjectName[typesetinfo] := 'Type Sets';		InfoObjectName[exsetinfo] := 'Inclusion Sets';		InfoObjectName[nexusblockinfo] := 'Nexus Blocks';	end;{-----------------------------------------------------------------------------}	procedure SetBranchShades;		var			j: integer;	begin		curTrace := tracenothing;		for j := 0 to maxTraceKinds do			branchShades[j] := branchPatterns;		branchShades[traceCellColors] := branchColors;		if colorQDexists then			begin				for j := 0 to maxTraceKinds do					defBranchShades[j] := branchColors;				defBranchShades[traceContinuous] := branchGrayScale;				CheckPixelDepth(editorWindow);				if ColorPort then					for j := 0 to maxTraceKinds do						branchShades[j] := defBranchShades[j];			end		else			for j := 0 to maxTraceKinds do				defBranchShades[j] := branchPatterns;		for j := 0 to maxTraceKinds do			userBranchShades[j] := noBranchShades;	end;{----------------------------------------------------------------------------}	procedure CreateTextWindow (name: str255; ioName: str15; whichText: integer; hasCommentLine: boolean);		var			box: rect;			tempP: WindowPtr;	begin		textWindowInfo[whichText] := textWindowInfoPtr(NewPtr(SizeOf(textWindowInfoRecord)));		textWindowInfo[whichText]^.open := false;		textWindowInfo[whichText]^.wasOpen := false;		textWindowInfo[whichText]^.HasBeenOpen := false;		textWindowInfo[whichText]^.H := NewHandle(0);		textWindowInfo[whichText]^.origin := 0;		textWindowInfo[whichText]^.rows := 10;		textWindowInfo[whichText]^.hasCommentLine := hasCommentLine;		textWindowInfo[whichText]^.name := name;		textWindowInfo[whichText]^.font := kFontIDMonaco;		textWindowInfo[whichText]^.size := 9;		textWindowInfo[whichText]^.face := [];		SetRect(Box, 5, 30, 450, 320);		textWindow[whichText] := MakeWindow(nil, box, '', ioName, false, documentproc, POINTER(-1), true, notTWWindow); 		box := WindowPortRect(textWindow[whichText]);		box.top := box.top - 1;		box.right := box.right + 1;		box.left := box.right - scrollwidth - 1;		box.bottom := box.bottom - scrollwidth + 1;		textWindowInfo[whichText]^.scroll := NewControl(textWindow[whichText], box, '', true, 0, 0, 0, scrollBarProc, 1);		genericGetPort(tempP);		genericSetPort(textWindow[whichText]);		box := WindowPortRect(textWindow[whichText]);		box.right := box.right - scrollwidth - 1;		box.left := box.left + 5;		textWindowInfo[whichText]^.TE := TENew(box, box);		TEAutoView(true, textWindowInfo[whichText]^.TE);		genericSetPort(tempP);	end;{----------------------------------------------------------------------------}	procedure InitShadingPixMap;	 var		origPort: CGrafPtr;		origDevice:GDHandle;		good:  Boolean;		myErr: QDErr;	 begin		SetRect(selectOffScreenWorldBox,0,0,1,1);		myErr := NewGWorld(selectOffScreenWorld, 0, selectOffScreenWorldBox, NIL, NIL, 0); {create offscreen graphics world}		selectPixMapH := GetGWorldPixMap(selectOffScreenWorld);		if selectPixMapH <> nil then			begin				good := LockPixels(selectPixMapH);{lock offscreen pixel map}				if not good then					InstantInfo('Lock Pixels failed'); {handle errors here}				GetGWorld(origPort, origDevice); {save onscreen graphics port}				if (selectOffScreenWorld = NIL) then					; {handle errors here}				SetGWorld(selectOffScreenWorld, NIL); {set current graphics port to offscreen}				ClipRect(selectOffScreenWorldBox);				SetGWorld(origPort, origDevice); {restore onscreen graphics port}			end;		SwitchShade(selectionShade); end;{-----------------------------------------------------------------------------}	procedure StartTextWindows;	var j: integer;	begin{==== Text Windows ====}		for j := 1 to numTextWindows do			textWindow[j] := nil;		numTextWindowsThatHaveBeenOpen := 0;		numTextWindowsG := 0;		CreateTextWindow('About...', 'AboutFile', AboutFileText, false);		CreateTextWindow('About trees...', 'AboutTrees', AboutTreesText, true);		CreateTextWindow('About trees...', 'AboutTreeFile', AboutTreeFileText, true);		CreateTextWindow('PAUP Block', 'NexusBlock', NexusBlockText, true);	end;{-----------------------------------------------------------------------------}	procedure StartWindows;		var			widthwind, heightwind, j: integer;			vscrollR, hscrollR, box: rect;			tempP: WindowPtr;			oldBack: RGBColor;			whichText: integer;	begin		UniversalDLOGFilterUPP := MyNewModalFilterUPP(@UniversalDLOGFilter);  		InitShadingPixMap;				genericGetPort(tempP);		GetBackColor(oldBack); 			pictwindow := nil;		ChartWindow := nil;		editorWindow := nil;		BranchListwindow := nil;		for j := 1 to numinfowindows do			begin				infoWindow[j] := nil;				infoHasBeenOpen[j] := false;			end;		treewindow := nil;		for j := 1 to numToolPalettes do			toolPaletteWindow[j] := nil;		tlegwindow := nil;		chlegwindow := nil;		twmesswindow := nil;		searchThermo := nil;		thermo1Window:= nil;		thermo2Window:= nil;				numInfoWindowsThatHaveBeenOpen := 0;		InitWindowRects;{======== editorWindow =======}		editorWindow := MakeWindow(nil, maxEWR, ' ', 'Data', false, documentproc + 8, POINTER(-1), true, notTWWindow);		widthwind := maxEWR.right - maxEWR.left;		heightwind := maxEWR.bottom - maxEWR.top;		SetRect(vscrollR, widthwind - scrollwidth, editorTitlesWidth + 1, widthwind + 1, heightwind - scrollwidth - notewidth + 1);		SetRect(hscrollR, editorRowNameEnd + 1, heightwind - scrollwidth - notewidth, widthwind - scrollwidth + 1, heightwind + 1 - notewidth);		editorVScroll := NewControl(editorWindow, vscrollR, '', false, 0, 0, 0, scrollBarProc, 1);		editorHScroll := NewControl(editorWindow, hscrollR, '', false, 0, 0, 0, scrollBarProc, 2);		genericSetPort(editorWindow);		editorWindowTop := GetWindowTitleBarHeight(editorWindow)+GetMBarHeight+1;		SetBranchShades;{==== tree window ====}		TreeWindow := MakeWindow(nil, maxTWR, ' ', 'Tree', false, documentproc + 8, POINTER(-1), true, TWLock);		genericSetPort(TreeWindow);		SetOrigin(0, TWorigV);		widthwind := maxTWR.right - maxTWR.left;		heightwind := maxTWR.bottom - maxTWR.top;		SetRect(vscrollR, widthwind - scrollwidth, 0, widthwind + 1, heightwind - scrollwidth + 1);		SetRect(hscrollR, 0, heightwind - scrollwidth, widthwind - scrollwidth + 1, heightwind + 1);		vTWScroll := NewControl(TreeWindow, vscrollR, '', true, 0, 0, 0, scrollBarProc, 1);		hTWScroll := NewControl(TreeWindow, hscrollR, '', true, 0, 0, 0, scrollBarProc, 2);		box := vscrollR;		box.bottom := box.top;		databoxScroll := NewControl(TreeWindow, box, '', true, 0, 0, 0, scrollBarProc, 3);		ReadjustWindows;	{==== tleg window ====}		SetRect(Box, 0, 0, standtlegW, 75);{$IFC CARBON}		tLegWindow := MakeCarbonWindow(nil, box, '', '',false, kDocumentWindowClass, kWindowNoAttributes,POINTER(-1), false, TWLock);  																				{might do instead kSheetWindowClass; would lose go-away box}//		tLegWindow := MakeWindow(nil, box, ' ', '',false, floatProc, POINTER(-1), false, TWLock);{$ELSEC}		tLegWindow := MakeWindow(nil, box, ' ', '',false, altDBoxProc, POINTER(-1), false, TWLock);{$ENDC}		MoveWindow(tlegwindow, tlegpt.h, tlegpt.v, false);		OffsetRect(box, -box.left, -box.top);		box.top := box.bottom - scrollwidth - 1;		box.right := box.right - 22;		tLegScroll := NewControl(tLegWindow, box, '', false, 1, 1, 1, scrollBarProc, 1);{==== chlegWindow ====}		SetRect(Box, 0, 0, standchlegW, 70);  {was 0,0,85,130}{$IFC CARBON}		chlegWindow := MakeCarbonWindow(nil, box, '', '',false, kDocumentWindowClass, kWindowNoAttributes+kWindowCloseBoxAttribute,POINTER(-1), true, TWLock);//		chlegWindow := MakeWindow(nil, box, ' ', '',false, floatProc, POINTER(-1), true, TWLock);{$ELSEC}		chlegWindow := MakeWindow(nil, box, ' ', '',false, altDBoxProc, POINTER(-1), true, TWLock);{$ENDC}		MoveWindow(chlegwindow, chlegpt.h, chlegpt.v, false);		OffsetRect(box, -box.left, -box.top);		box.top := box.bottom - scrollwidth - 1;		box.right := box.right - 22;		chLegScroll := NewControl(chLegWindow, box, '', false, 1, 1, 1, scrollBarProc, 1);{==== palette Window ====}		for j := 1 to numToolPalettes do			begin				{if useOldFloatingWindows then					SetRect(Box, 0, 0,(toolCellWidth -1) * horizontalTools[j], (toolCellWidth -1) * verticalTools[j]  + paletteTitleLineWidth+ paletteMessageLineWidth*numPaletteMessageLines[j])				else					SetRect(Box, 0, 0, (toolCellWidth-1) * horizontalTools[j], (toolCellWidth -1) * verticalTools[j] + paletteMessageLineWidth*numPaletteMessageLines[j]);				if toolPaletteHasExtraMessage[j] then					box.bottom := box.bottom + paletteMessageExtraLineWidth;}									SetRect(box,0,0,100,100);				if useOldFloatingWindows then					if j = treeTools then						toolPaletteWindow[j] := MakeWindow(nil, box, '', '',false, altDBoxProc, POINTER(-1), true, TWLock)					else						toolPaletteWindow[j] := MakeWindow(nil, box, '', '',false, altDBoxProc, POINTER(-1), true, notTWWindow)				else{$IFC CARBON}					if j = treeTools then						toolPaletteWindow[j] := MakeCarbonWindow(nil, box, '', '',false, kDocumentWindowClass, kWindowNoAttributes+kWindowCloseBoxAttribute+kWindowResizableAttribute, POINTER(-1), true, TWLock)//						toolPaletteWindow[j] := MakeWindow(nil, box, '', '',false, {altDBoxProc} floatGrowProc, POINTER(-1), true, TWLock)					else						toolPaletteWindow[j] := MakeCarbonWindow(nil, box, '', '',false, kDocumentWindowClass, kWindowNoAttributes+kWindowCloseBoxAttribute+kWindowResizableAttribute,POINTER(-1), true, notTWWindow);//						toolPaletteWindow[j] := MakeWindow(nil, box, '', '',false, {altDBoxProc} floatGrowProc, POINTER(-1), true, notTWWindow);{$ELSEC}					if j = treeTools then						toolPaletteWindow[j] := MakeWindow(nil, box, '', '',false, {altDBoxProc} floatGrowProc, POINTER(-1), true, TWLock)					else						toolPaletteWindow[j] := MakeWindow(nil, box, '', '',false, {altDBoxProc} floatGrowProc, POINTER(-1), true, notTWWindow);{$ENDC}				mySetPortTextFont(toolPaletteWindow[j],kFontIDGeneva);				mySetPortTextSize(toolPaletteWindow[j],9);								ReSizeToolPalette(j,horizontalTools[j],verticalTools[j]);				showToolPaletteMessageLine[j] := true;									{			paletteMessageBox[j]:= toolPaletteWindow[j]^.portrect;				paletteMessageBox[j].top := paletteMessageBox[j].bottom - paletteMessageLineWidth*numPaletteMessageLines[j];	}			{SetRect(paletteMessageBox[j], 0, toolCellWidth * verticalTools[j] + paletteTitleLineWidth-5, toolCellWidth * horizontalTools[j] + 1, toolCellWidth * verticalTools[j] + paletteTitleLineWidth+paletteMessageLineWidth+1);				paletteExtraMessageBox[j]:= paletteMessageBox[j];				paletteExtraMessageBox[j].top := paletteMessageBox[j].bottom;				paletteExtraMessageBox[j].bottom := toolPaletteWindow[j]^.portRect.bottom;}			{	SetRect(paletteExtraMessageBox[j],0,0,0,0);				if toolPaletteHasExtraMessage[j] then					begin						paletteExtraMessageBox[j]:= paletteMessageBox[j];						paletteExtraMessageBox[j].bottom := paletteMessageBox[j].top;						paletteExtraMessageBox[j].top := paletteExtraMessageBox[j].bottom-paletteMessageExtraLineWidth;					end;}			end;{==== TWmessage window ====}		twmesswidth := 120;		SetRect(Box, 0, 0, twmesswidth, 14);		twmessWindow := MakeWindow(nil, box, ' ', '',false, plainDBox, POINTER(-1), true, TWLock);		TWMessageB := WindowPortRect(twMessWindow);{==== BranchList window ====}		SetRect(Box, 0, 0, 160, 80);		branchListWindow := MakeWindow(nil, box, ' ', '', false, documentproc, POINTER(-1), true, TWLoose);		{listWindow := ListWindowRecordArrayPtr(NewPtr(SizeOf(ListWindowRecordArray)));		listWindowPublic := ListWindowPublicRecordArrayPtr(NewPtr(SizeOf(ListWindowPublicRecordArray)));}{==== infowindows ====}		for j := 1 to numInfoWindows do			begin				infoWindow[j] := nil;				SetRect(Box, 10, 50, 500, 50 + infoLW[j] * (infoTitleLines + infoRows[j]));				infoWindow[j] := MakeWindow(nil, box, InfoObjectName[j], '',false, documentproc + 8, POINTER(-1), true, notTWWindow);				mySetPortTextFont(infoWindow[j],infoFont[j]);				mySetPortTextSize(infoWindow[j],infoFontSize[j]);				widthwind := box.right - box.left;				heightwind := box.bottom - box.top;				SetRect(vscrollR, widthwind - scrollwidth, infoLW[j] * infoTitleLines, widthwind + 1, heightwind - scrollwidth + 1);				infoScroll[j] := NewControl(infoWindow[j], vscrollR, '', false, 1, 1, 1, scrollBarProc, 1);				infoHScroll[j] := NewControl(infoWindow[j], vscrollR, '', false, 1, 1, 1, scrollBarProc, 1);				SetRect(Box, 0,0,80,20);				infoWindowbutton[j] := NewControl(infoWindow[j], box, 'Use', true, 1, 1, 1, pushButProc, 1);			end;		SetControlTitle(infoWindowbutton[charinfo], 'Trace');		SetControlTitle(infoWindowbutton[treeinfo], 'Display');					SetWindowName(infoWindow[charinfo],'Characters');		SetWindowName(infoWindow[charpartinfo],'CharPartitions');		SetWindowName(infoWindow[charpartnameinfo],'GroupLabels');		SetWindowName(infoWindow[taxinfo],'Taxa');		SetWindowName(infoWindow[treeinfo],'Trees');		SetWindowName(infoWindow[typesetinfo],'TypeSets');		SetWindowName(infoWindow[wtsetinfo],'WtSets');		SetWindowName(infoWindow[exsetinfo],'ExSets');		SetWindowName(infoWindow[charsetinfo],'CharSets');		SetWindowName(infoWindow[taxsetinfo],'TaxSets');		SetWindowName(infoWindow[nexusblockinfo],'NexusBlocks');{==== stateswindow ====}		SetRect(Box, 30, 50, 250, 50 + CalcStatesWindowHeight);		statesWindow := MakeWindow(nil, box, 'State Names & Symbols', 'States', false, documentproc + 8, POINTER(-1), true, notTWWindow);		mySetPortTextFont(statesWindow,statesFont);		mySetPortTextSize(statesWindow,statesFontSize);		widthwind := box.right - box.left;		heightwind := box.bottom - box.top;		SetRect(box, widthwind - scrollwidth, statesWindowTitleWidth, widthwind + 1, heightwind - scrollwidth + 1);		statesWindowVScroll := NewControl(statesWindow, box, '', false, 1, 1, 1, scrollBarProc, 1);		SetRect(box, statesNameStart, heightwind - scrollwidth + 1, widthwind - scrollwidth + 1, heightwind + 1);		statesWindowHScroll := NewControl(statesWindow, box, '', false, 1, 1, 1, scrollBarProc, 1);{==== ChartWindow window ====}		SetRect(Box, 50, 50, 380, 340);		Box := ScreenBoundsRect;		Box.top := GetMBarHeight;		InsetRect(Box, 30, 30);		ChartWindow := MakeWindow(nil, box, 'Chart', '', false, documentproc + 8, POINTER(-1), true, 2);		box := WindowPortRect(chartWindow);		box.bottom := box.bottom - scrollwidth - 1;		box.top := box.bottom - 40;		box.left := box.right - scrollwidth - 1;		CWScroll := NewControl(ChartWindow, box, '', false, 0, 0, 0, scrollBarProc, 1);{==== comm window ====}{		SetRect(Box, 25, 50, 450, 320);		commWindow := MakeWindow(nil, box, '', false, documentproc, POINTER(-1), true, 4);		commWindow^.txFont := kFontIDGeneva;		commWindow^.txSize := 9;		commOrigin := 0;		box := WindowPortRect(commWindow);		box.top := box.top - 1;		box.right := box.right + 1;		box.left := box.right - scrollwidth - 1;		box.bottom := box.bottom - scrollwidth + 1;		commScroll := NewControl(commWindow, box, '', true, 0, 0, 0, scrollBarProc, 1);}{==== pict window ====}		SetRect(Box, 50, 50, 440, 320);		pictWindow := MakeWindow(nil, box, 'Pictures', 'Picture', false, documentProc + 8, POINTER(-1), true, notTWWindow);		if ScreenBoundsRect.bottom > 400 then			WindowPop(true,true);		genericSetPort(tempP);		SetRGBBackground(oldBack);				for j := 1 to numMacCladeWindows do			MacCladeWindowList[j] := nil;	end;{-----------------------------------------------------------------------------}	procedure StartScrap;{$IFC NOT CARBON}  		var			Scrap: ScrapStuffPtr;{$ENDC}	begin		scraptextdirty := False;		scrappictdirty := False;		scrapispict := False;{$IFC NOT CARBON}		Scrap := InfoScrap;		ScrapCompare := Scrap^.scrapcount + 1;{$ENDC}		ReadDeskScrap;	end;{-----------------------------------------------------------------------------}	procedure StartStandardFile;		var			H: DialogTHndl;	begin		if hasSys7StandFile then			begin				sfgetwhere.h := -1;				sfgetwhere.v := -1;				sfputwhere.h := -1;				sfputwhere.v := -1;			end		else if not hasNavigationalServices then			begin				H := DialogTHndl(GetResource('DLOG', getDlgID));				with H^^.boundsRect do					begin						sfgetwhere.h := (ScreenBoundsRect.right - (right - left)) div 2;						sfgetwhere.v := (ScreenBoundsRect.bottom - (bottom - top) - GetMBarHeight) div 3 + GetMBarHeight;					end;				H := DialogTHndl(GetResource('DLOG', putDlgID));   {v4: do these need to be released?}				with H^^.boundsRect do					begin						sfputwhere.h := (ScreenBoundsRect.right - (right - left)) div 2;						sfputwhere.v := (ScreenBoundsRect.bottom - (bottom - top) - GetMBarHeight) div 3 + GetMBarHeight;					end;			end;	end;{-----------------------------------------------------------------------------} procedure StartUPPs; begin	ScrollContinuousUpDownUPP := MyNewControlActionUPP(@ContinuousSBar);	{ScrollHelpUpDownUPP := MyNewControlActionUPP(@ScrollDlgUpDown);}	ScrollTypeUpDownUPP := MyNewControlActionUPP(@doTypeScroll);	ScrollStatesUpDownUPP := MyNewControlActionUPP(@ScrollStatesUpDown);  	ScrollInfoUpDownUPP := MyNewControlActionUPP(@ScrollInfoUpDown);	ScrollCWUpDownUPP := MyNewControlActionUPP(@ScrollCWUpDown);  		{in ChartWindow}	ScrollSpreadUpDownUPP := MyNewControlActionUPP(@ScrollSpreadUpDown);  		{in EditControl}	ScrollLegUpDownUPP := MyNewControlActionUPP(@ScrollLegUpDown);  		{in MouseInTree}	ScrollN7UpDownUPP := MyNewControlActionUPP(@ScrollN7UpDown);  		{in N7On}	ScrollTreeUpDownUPP := MyNewControlActionUPP(@ScrollTreeUpDown);  		{in ScrollTree}	ScrollTextUpDownUPP := MyNewControlActionUPP(@ScrollTextUpDown);  		{in TextWindows}{check to see if any of these are nil} end; {-----------------------------------------------------------------------------}procedure StartUndoEditor;begin	CreateCellBlock(EWUndoBlockP);	undoSelectionTopLeft.h := 0;	undoSelectionTopLeft.v := 0;	undoSelectionBotRight.h := 0;	undoSelectionBotRight.v := 0;	undoSelectionValid := false;	lastChangeInEditor := lastChangeCantUndo;	undoCellTaxon:= 0;	undoCellCharacter := 0;	undoNameRow := 0;	undoWhichInfo := noinfo;end;{-----------------------------------------------------------------------------}	procedure SetupStuff (theDialog: DialogPtr);		var			curHeapMem, decreaseHeapMem, amountAvail, oldApplLimit: longint;			left,top: integer;			splashBox: rect;			ds: str255;			db: boolean;	begin		ds := '';		splashBox := GetDLOGItemBox(theDialog, 2);		left:= splashBox.left;		top := splashBox.top;		splashBox.top := splashBox.bottom-4;			DrawMCIconSlice(left,top, splashBox, WindowPortRect(myGetWindowPtrForDialog(theDialog)));			DrawMCIconSlice(left,top, splashBox, WindowPortRect(myGetWindowPtrForDialog(theDialog)));			DrawMCIconSlice(left,top, splashBox, WindowPortRect(myGetWindowPtrForDialog(theDialog)));				curHeapMem := MaxMem(amountAvail); {compact the heap, and return largest continuous block in curHeapMem;}												{in amountAvail, return how much the heap zone can grow}		decreaseHeapMem := (curHeapMem + amountAvail) div 100 * 3 + 32768;   {calculate the amount to decrease heap size, 3% + 32K of original}		if odd(decreaseHeapMem) then			decreaseHeapMem := decreaseHeapMem + 1;    {avoid odd addresses!!!}{$IFC NOT CARBON}		oldApplLimit := longint(GetApplLimit);    {get current application limit}		SetApplLimit(Ptr(oldApplLimit - decreaseHeapMem));   {decrease application limit}		MaxApplZone;{$ENDC}			DrawMCIconSlice(left,top, splashBox, WindowPortRect(myGetWindowPtrForDialog(theDialog)));			DrawMCIconSlice(left,top, splashBox, WindowPortRect(myGetWindowPtrForDialog(theDialog)));					ReportStartUpStatus(theDialog, 'Allocating memory...');		StartHandles(theDialog);			ReportStartUpStatus(theDialog, 'Initializing values...');		StartBooleansEtc;			DrawMCIconSlice(left,top, splashBox, WindowPortRect(myGetWindowPtrForDialog(theDialog)));		StartPatternsColors;			DrawMCIconSlice(left,top, splashBox, WindowPortRect(myGetWindowPtrForDialog(theDialog)));			ReportStartUpStatus(theDialog, 'Initializing preference system...');		StartSettings;			ReportStartUpStatus(theDialog, 'Setting factory defaults...');		StartTextWindows;		InitProgramPreferences;		InitFilePreferences;		InitJustProgram;		InitProgramAndFile;		LoadTaxonCHUtil;				StartUndoEditor;			DrawMCIconSlice(left,top, splashBox, WindowPortRect(myGetWindowPtrForDialog(theDialog)));			DrawMCIconSlice(left,top, splashBox, WindowPortRect(myGetWindowPtrForDialog(theDialog)));			DrawMCIconSlice(left,top, splashBox, WindowPortRect(myGetWindowPtrForDialog(theDialog)));		curHeapMem := MaxMem(amountAvail);		if curHeapMem < 200000 then			begin				InstantError(295);				earlyquit := true;				ZapPointer(SetPtr31);				ZapPointer(locSetPtr31);				ZapPointer(SetPtr15);				ZapPointer(errorsposted);				{ZapPointer(memoryErrors);}				ZapPointer(errorsturnedoff);				Exit(SetUpStuff);			end;			DrawMCIconSlice(left,top, splashBox, WindowPortRect(myGetWindowPtrForDialog(theDialog)));			ReportStartUpStatus(theDialog, 'Initializing menus...');			DrawMCIconSlice(left,top, splashBox, WindowPortRect(myGetWindowPtrForDialog(theDialog)));		StartMenus;					DrawMCIconSlice(left,top, splashBox, WindowPortRect(myGetWindowPtrForDialog(theDialog)));			DrawMCIconSlice(left,top, splashBox, WindowPortRect(myGetWindowPtrForDialog(theDialog)));			ReportStartUpStatus(theDialog, 'Initializing list windows...');		StartCharPartNames;		StartInfoColumns;			DrawMCIconSlice(left,top, splashBox, WindowPortRect(myGetWindowPtrForDialog(theDialog)));			DrawMCIconSlice(left,top, splashBox, WindowPortRect(myGetWindowPtrForDialog(theDialog)));			ReportStartUpStatus(theDialog, 'Initializing tools...');			DrawMCIconSlice(left,top, splashBox, WindowPortRect(myGetWindowPtrForDialog(theDialog)));		StartCursorsAndTools;   {this must be called before StartWindows!}			DrawMCIconSlice(left,top, splashBox, WindowPortRect(myGetWindowPtrForDialog(theDialog)));			DrawMCIconSlice(left,top, splashBox, WindowPortRect(myGetWindowPtrForDialog(theDialog))); 		StartUPPs;			DrawMCIconSlice(left,top, splashBox, WindowPortRect(myGetWindowPtrForDialog(theDialog)));		StartCHUNKs;			DrawMCIconSlice(left,top, splashBox, WindowPortRect(myGetWindowPtrForDialog(theDialog)));		StartTypes;			DrawMCIconSlice(left,top, splashBox, WindowPortRect(myGetWindowPtrForDialog(theDialog)));		StartRgns;					ReportStartUpStatus(theDialog, 'Initializing windows...');			DrawMCIconSlice(left,top, splashBox, WindowPortRect(myGetWindowPtrForDialog(theDialog)));		StartWindows;			DrawMCIconSlice(left,top, splashBox, WindowPortRect(myGetWindowPtrForDialog(theDialog)));			ReportStartUpStatus(theDialog, 'Initializing text...');		StartTextEdits;			DrawMCIconSlice(left,top, splashBox, WindowPortRect(myGetWindowPtrForDialog(theDialog)));			DrawMCIconSlice(left,top, splashBox, WindowPortRect(myGetWindowPtrForDialog(theDialog)));		ClosedFileMenus;		StartScrap;		GetDateTime(oldtime);		FlushEvents(everyEvent, 0);		StartStandardFile;	end;{-----------------------------------------------------------------------------}end.