unit TreeMover;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, CharUtil, TreeUtil, MenuUtil, Thermos, LinkUtil, TreeMaker, TreeMakerUtil, TreeDrawer, TreeCycle;	procedure RotateNode (N: Nptr);	procedure FlipNode (N: Nptr);	procedure Ladderize (N: Nptr);	procedure MoveEdge;	procedure ReRoot (N, enclosingN: Nptr);	function MoveNodeToFrom (N: Nptr): Boolean;{$SETC RANDOMMOVE=FALSE}{$IFC RANDOMMOVE}	procedure RandomBranchMove (fN: Nptr);{$ENDC}{$SETC ALLREROOTS=TRUE}{$IFC ALLREROOTS}	procedure AllReRoots (cladeN: NPtr);{$ENDC}{еееееееееееееееееееееее}implementation {е$S TreeMover}{-----------------------------------------------------------------------------}	procedure RotateNode (N: Nptr);		var			sideN: Nptr;	begin		sideN := N^.lf;		N^.lf := N^.rt;		N^.rt := sideN;		N^.lf^.slant := -N^.lf^.slant;		N^.rt^.slant := -N^.rt^.slant;		setDirtyTree;{    dirtytree := true;}		dirtyfile := true;	end;{-----------------------------------------------------------------------------}	procedure FlipNode (N: Nptr);	begin		if not NodeIsPolytomous(N) then			begin				godraw := true;				RotateNode(N);				DrawR := N;				DrawRloc := N^.loc;			end		else			Beep;	end;{$SETC LADPOLY=false}{$IFC LADPOLY}{-----------------------------------------------------------------------------}	function DegreeOfNode (N: Nptr): integer;   {v3.03}{returns the number of descendants of node N}	begin		DegreeOfNode := 0;	end;{$ENDC}{-----------------------------------------------------------------------------}	procedure Ladderize (N: Nptr);		var			j: integer;	begin		if NodeIsInternal(N) then			begin				if (((ladderDir = slantright) & FirstCladeIsBigger(N^.lf, N^.rt)) | ((ladderDir = slantleft) & not FirstCladeIsBigger(N^.lf, N^.rt))) & not (N^.null | N^.rt^.null | N^.lf^.null) then					{    if (ladderDir * N^.lf^.loc.v > ladderDir * N^.rt^.loc.v) and not (N^.null or N^.rt^.null or N^.lf^.null) then}					Rotatenode(N){$IFC LADPOLY}				else if not N^.null and NodeIsPolytomous(N) then   {v3.03:  take care of case of polytomous node}					begin						for j := 1 to DegreeOfNode(N) do							begin							end;					end;{$ELSEC}				;{$ENDC}				Ladderize(N^.lf);				Ladderize(N^.rt);			end;	end;{-----------------------------------------------------------------------------}	procedure FindNC (N: Nptr);	begin		if NodeIsInternal(N) then			begin				if (IsAnc(N^.rt, toN) and IsAnc(N^.lf, fromN)) or (IsAnc(N^.lf, toN) and IsAnc(N^.rt, fromN)) then					DrawR := N;				if (toN = N) and IsAnc(N, fromN) then					DrawR := N;				FindNC(N^.lf);				FindNC(N^.rt);			end;	end;{-----------------------------------------------------------------------------}	procedure MoveEdge;{disconnects fromN & its ancestor and attaches them to toN}		var			sideN: Nptr;			ir: integer;			fromancslantRight, fromslantRight, toslantRight, NCslantRight: boolean;			C, G, F, H, NCAnc: Nptr;			NCreset, docheckfix, wasfixancRoot: boolean;			drawRAnc: Nptr;			drawRRight: boolean;	begin{treechanged := true;}		FindNC(R);		if DrawR^.null then			DrawR := NotNullAnc(DrawR^.rt);		if (DrawR <> ScreenR) then			begin				NCReset := false;				DrawRloc := DrawR^.loc;				NCanc := DrawR^.anc;				NCslantRight := NodeSlantsRight(DrawR);			end		else			NCReset := true;		wasfixancRoot := R^.fixanc;		undotoNull := 0;		if toN^.fix or fromN^.fix or fromN^.anc^.fix then			begin				NewError(132, 0);  {NEEDS FULLUNDO; see above}{fixchanged := true;}				toN^.fix := false;				dirtyfix := true;				fromN^.fix := false;				fromN^.anc^.fix := false;				docheckFix := true;			end;		if R^.fixanc and ((toN = R) or (fromN^.anc = R)) then  {NEEDS FULLUNDO; see above}			begin				R^.fixanc := false;				if NodeIsInternal(R) then					begin						if NodeIsTerminal(R^.lf) then							R^.lf^.fixanc := false;						if NodeIsTerminal(R^.rt) then							R^.rt^.fixanc := false;					end;				NewError(133, 0);			end;		if (fromN^.anc^.anc = toN) and (toN = R) then  {NEEDS FULLUNDO; see above}			begin				fromN := Sis(fromN);				toN := Sis(fromN^.anc);				if fromN^.null then					begin						undotype := justRootNullmove;						undotoNull := up;					end;				fromN^.null := false;			end;		if (fromN^.anc = R) and (toN^.anc^.anc = R) then			begin				sideN := fromN;				fromN := toN;				toN := sideN;			end;		if toN^.fix or fromN^.fix or fromN^.anc^.fix then			begin				NewError(132, 0);  {NEEDS FULLUNDO; see above}{fixchanged := true;}				toN^.fix := false;				fromN^.fix := false;				fromN^.anc^.fix := false;				dirtyfix := true;				docheckFix := true;			end;		if toN^.fixanc and (toN^.name > 0) then  {NEEDS FULLUNDO; see above}			begin				NewError(134, 0);				toN^.fixanc := false;				toN^.anc^.fixanc := false;			end;		fromroot := false;		toroot := false;		fromslantRight := NodeSlantsRight(fromN);		fromancslantRight := NodeSlantsRight(fromN^.anc);		toslantRight := NodeSlantsRight(toN);		G := sis(fromN);		H := fromN^.anc^.anc;		C := toN^.anc;		F := fromN^.anc;		if F^.null then			undotoNull := down		else if G^.null then			undotoNull := up;		if not F^.null then			G^.null := false;		F^.null := false;		if F^.fixanc then			begin				G^.fixanc := false;				F^.fixanc := false;			end;		if toN = ScreenR then			ScreenR := F		else if F = ScreenR then			ScreenR := G;		undofromN := fromN;		undotoN := G;		if F = R then			fromroot := true		else if toN = R then			toroot := true;		if fromslantRight = toslantRight then			begin				sideN := F^.lf;				F^.lf := F^.rt;				F^.rt := sideN;			end;		G^.anc := H;		F^.anc := C;		toN^.anc := F;		if fromancslantRight then			H^.rt := G		else			H^.lf := G;		if toslantRight then			begin				F^.rt := toN;				C^.rt := F;			end		else			begin				F^.lf := toN;				C^.lf := F;			end;		sideN := sis(G);		F^.slant := toN^.slant;		fromN^.slant := -toN^.slant;		G^.slant := -sideN^.slant;		if fromroot then			begin				sideN := R;				R := G;				G := sideN;			end;		if toroot then			begin				sideN := R;				R := F;				F := sideN;			end;		if R^.fixanc and not wasfixancRoot then			begin				NCReset := true;				R^.fixanc := false;				if NodeIsInternal(R) then					begin						if NodeIsTerminal(R^.rt) then							R^.rt^.fixanc := false						else							R^.lf^.fixanc := false;					end;			end;		R^.slant := 1;		if not NodeSlantsRight(R) then			begin				subRlf := SubR^.lf;				subR^.lf := subRlf;				subR^.rt := R;			end;		if NodeIsInternal(R) then			R^.lf^.slant := -1;		R^.anc^.slant := 1;		noundo := false;		nomove := false;		myEnableItem(EditMHdl, UndoItem);		setDirtyTree;		dirtyfile := true;		undotype := justmove;		if NCReset then			DrawR := ScreenR		else			begin				if NCslantRight then					DrawR := NCanc^.rt				else					DrawR := NCanc^.lf;			end;		R^.null := false;		if docheckfix then			begin				SetFixon;				if currentTool[treeTools] = turpentineT then					currentTool[treeTools] := arrowT;				DimTool(treeTools,turpentineT);			end;		SetNullson;		SetAncOn;		FixTreeShadingMenus;	end;{-----------------------------------------------------------------------------}	procedure ReRoot (N, enclosingN: Nptr);		var			sideN: Nptr;			tempreN, tempreNR, frN: Nptr;			savenull, oldsideNull, allowpolyroot: boolean;	begin		if N = enclosingN then  {v3.02: crashed before if they were equal}			Exit(ReRoot);		fullundo := false;		FixLostByUndo := false;		if ancon then			begin				if AnyFixanc(enclosingN) then					begin						fullundo := true;						StoreOldTreeForUndo;						FixLostByUndo := fixon;						InstantError(179);						OffAnc(enclosingN); {note setancon now done within offanc}						godraw := true;					end;			end;		if IsAnc(enclosingN^.lf, N) then			tempreN := enclosingN^.rt		else			tempreN := enclosingN^.lf;		if NodeIsPolytomous(enclosingN) then			begin				fullundo := true;				StoreOldTreeForUndo;				FixLostByUndo := fixon;			end;		if (N^.anc = enclosingN) and NodeIsPolytomous(enclosingN) then			begin				sis(N)^.null := false;				noundo := false;			end		else			begin				tempreNR := enclosingN;				allowpolyroot := N^.null;				repeat					if IsAnc(enclosingN^.lf, N) then						begin							toN := enclosingN^.rt;							if (NodeIsInternal(enclosingN^.lf)) & IsAnc(enclosingN^.lf^.lf, N) then								fromN := enclosingN^.lf^.rt							else								fromN := enclosingN^.lf^.lf;						end					else						begin							toN := enclosingN^.lf;							if NodeIsInternal(enclosingN^.rt) & IsAnc(enclosingN^.rt^.lf, N) then								fromN := enclosingN^.rt^.rt							else								fromN := enclosingN^.rt^.lf;						end;					frN := fromN^.anc;					sideN := sis(fromN);{a node looses its nullness if a nonnull moved onto it}					if not frN^.null then						toN^.null := false;					savenull := sideN^.null or frN^.null;{sideN: a node gains nullness when moved across root if its other descendant was null, so as to maintain polytomy}{frN: a null node preserves its nullness when moved across root except if it is last one, it loses nullness so as to place root along edge}					oldsideNull := sideN^.null;					sideN^.null := false;					MoveEdge;					frN^.null := savenull;					sideN^.null := oldsideNull;				until N^.anc = enclosingN;{check to see that rerooted node not participating in polytomy}			end;		if not allowpolyroot then			begin				Sis(N)^.null := false;				N^.anc^.null := false;			end;		undotype := justreroot;		reNR := tempreNR;		reN := tempreN;		setNullson;		FixTreeShadingMenus;		RearrangeTreeGoList;	end;{-----------------------------------------------------------------------------}	function MoveNodeToFrom (N: Nptr): Boolean;{this moves the node fromN (a global var) to the node N}		var			moved: boolean;			sideN: Nptr;	begin		moved := false;		toN := N;		sideN := sis(N);		godraw := true;		if (sideN = fromN) or (IsTerminalFixanc(N)) or (fromN^.anc = N) or IsAnc(fromN, toN) then			godraw := false;		if godraw then			begin				justundid := false;				Penmode(patXOR);				Penpat(dashpat);				OutlinePoly(N);				OutlinePoly(N);				Penpat(QDBlack);				Penmode(patcopy);				undotype := justmove;				moved := true;				if (R^.fixanc and ((toN = R) or (fromN^.anc = R))) or ((fromN^.anc^.anc = toN) and (toN = R)) or (toN^.fixanc and (toN^.name > 0)) then					begin						fullundo := true;						SToreOldTreeForUndo;						FixLostByUndo := fixon;					end				else					begin						fullundo := false;						FixLostByUndo := false;					end;				MoveEdge;			end;		if (sideN = fromN) and fromN^.anc^.null then			begin				fromN^.anc^.null := false;				noundo := false;				myEnableItem(EditMHdl, UndoItem);				undotoN := fromN^.anc;				undotonull := down;				DrawR := NotNullAnc(fromN^.anc);				DrawRloc := DrawR^.loc;				setDirtyTree;				dirtyfile := true;				justundid := false;				undotype := justmove;				FixLostByUndo := false;				nomove := true;				godraw := true;				moved := true;				Setnullson;			end		else			begin				sideN := sis(fromN);				if SideN^.null and (fromN^.anc = N) then					begin						noundo := false;						myEnableItem(EditMHdl, UndoItem);						undotoN := SideN;						SideN^.null := false;						undotonull := down;						DrawR := N;						DrawRloc := DrawR^.loc;						SetDirtyTree;						dirtyfile := true;						undotype := justmove;						justundid := false;						Fixlostbyundo := false;						nomove := true;						godraw := true;						moved := true;						Setnullson;					end;			end;		if godraw then			RearrangeTreeGoList;{    if moved and not count then DrawTreeLeg;}		InvalidateWindow(tlegwindow, false);		MoveNodeToFrom := moved;		FixTreeShadingMenus;	end;{-----------------------------------------------------------------------------}	function MaximumNodeNumber (N: Nptr): integer;		var			nodecount: integer;{..............}		procedure NumberRealNodes (pN: Nptr);		begin			if BranchExists(pN) then				nodecount := nodecount + 1;			if NodeIsInternal(pn) then				begin					NumberRealNodes(pN^.lf);					NumberRealNodes(pN^.rt);				end;		end;{..............}	begin		if nullson then			begin				nodecount := 0;				NumberRealNodes(N);			end		else if N = R then			nodecount := 2 * numtaxain - 1		else			nodecount := 2 * ntscreen - 1;		MaximumNodeNumber := nodecount;	end;{$IFC ALLREROOTS}{-----------------------------------------------------------------------------}	procedure ReRootNodeInClade (polyclade: boolean; cladeN: NPtr; reRootNodeNumber: integer; var success: boolean);{reroots cladeN at the node numbered reRootNodeNumber }		var			newrootN: Nptr;	begin		newrootN := NodeOfNumber(reRootNodeNumber);		success := BranchExists(newrootN) & (newrootN <> cladeN) & ((newrootN^.anc <> cladeN) & (newrootN <> cladeN^.lf) & (newrootN <> cladeN^.rt) | polyclade) & IsAnc(cladeN, newrootN);		if success then			ReRoot(newRootN, cladeN);	end;{-----------------------------------------------------------------------------}	procedure AllReRoots (cladeN: NPtr);  {THIS VERSION JUST GENERATES TREES}{cladeN is selected node}{saves to the current tree chain all trees in which clade N is rerooted,}{NOT COUNTING the current rooting configuration}		var			H: Handle;			k, maxnode, numRerootNodes, cladeNumber: integer;			ds: str255;			success: boolean;			theDialog: DialogPtr;			tempP: WindowPtr;			olddirtytree, polyclade: boolean;			amountNeeded: longint;	begin		if (cladeN^.name <> 0) or ancon then			Exit(AllReRoots);		if dirtytree then			ds := UnstoredLink		else			ds := treename^^;		polyclade := (cladeN^.lf^.null) or (cladeN^.rt^.null);   {cladeN is the base of a polytomy}		if polyclade then			numRerootNodes := MaximumNodeNumber(cladeN)		else			numRerootNodes := MaximumNodeNumber(cladeN) - 2;		maxnode := MaximumNodeNumber(R);		if not EnoughMemory(ord4(numRerootNodes) * (5 * numtaxain + length(ds) + 1) + 6, amountneeded) then			InstantErrorPlus(178, concat(StringFromNum(amountneeded div 1024), 'K'))		else if numReRootNodes > 1 then			if CWarning(concat('Do you want MacClade to save all ', StringFromNum(numRerootNodes), ' rootings of the clade on the screen?'), 'All Rootings', 'No') then				begin					olddirtytree := dirtytree;					cladeNumber := NumberOfNode(cladeN);					SaveLinkToChain(treeChain, concat(ds, '.original'), false,false);					ChangeStoredTreesGoList;					StoreCurrentTree(H);					RestoreCurrentTree(H, false);					cladeN := NodeOfNumber(cladeNumber);  {need to reset as pointer will have changed}					DisableWindowUpdates(infowindow[treeinfo]);					DisableWindowUpdates(treewindow);										StartThermo(theDialog, tempP, 1, maxnode, 'Rerooting Clade', 'branches', true);					for k := 1 to maxnode do						begin							UpdateThermo(theDialog, 1, k, maxnode, true);							if abortedThermo then								begin									RestoreCurrentTree(H, false);									leave;								end;							ReRootNodeInClade(polyclade, cladeN, k, success);							if success then								begin									SaveLinkToChain(treeChain, concat(ds, '.', StringFromNum(k)), false,false);									RestoreCurrentTree(H, false);									cladeN := NodeOfNumber(cladeNumber);  {need to reset as pointer will have changed}								end;						end;					EndThermo(theDialog, tempP, true);					treename^^ := ds;					dirtytree := olddirtytree;					ZapHandle(H);					infoDirtyNames[treeinfo] := true;					InvalidateWindow(tlegwindow,true);					InvalidateInfoWindow(treeinfo);				end;	end;{$IFC FALSE}{-----------------------------------------------------------------------------}	procedure AllReRoots (cladeN: NPtr); {THIS VERSION GENERATES ALL REROOTS and RECORDS LENGTHS}		label			1;{cladeN is selected node}{saves to the current tree chain all trees in which clade N is rerooted,}{NOT COUNTING the current rooting configuration}		var			tempN, localCladeN: Nptr;			H: Handle;			k, maxnode, oldright, oldleft, cladeNumber: integer;			maxLen, minLen, oldtreelength: longint;			ds: str255;			success: boolean;			theDialog: DialogPtr;			tempP: WindowPtr;			olddirtytree, savetrees: boolean;			lengthP: Ptr;			curLengthP: LIP;	begin		savetrees := ControlDown;		olddirtytree := dirtytree;		if dirtytree then			begin				ds := UnstoredLink;				SaveLinkToChain(treeChain, ds, false,false);			end		else			ds := treename^^;		StoreCurrentTree(H);		maxnode := MaximumNodeNumber(R);		cladeNumber := NumberOfNode(cladeN);		oldleft := NumberOfNode(cladeN^.lf);		oldright := NumberOfNode(cladeN^.rt);		oldtreelength := treelength;		lengthP := NewPtr(maxnode * 4);		DisableWindowUpdates(infowindow[treeinfo]);		DisableWindowUpdates(treewindow);				StartThermo(theDialog, tempP, 1, maxnode, 'Rerooting Clade', 'branches', true);		for k := 1 to maxnode do			begin				UpdateThermo(theDialog, 1, k, maxnode, true);				if abortedThermo then					begin						RestoreCurrentTree(H, false);						goto 1;					end;				localCladeN := NodeOfNumber(cladeNumber);				ReRootNodeInClade(localCladeN, k, success);				if success then					begin						SetTaxaDnSts(1, numchars);						if not CountTree then							begin								NewError(310, 0);								treelength := 0;							end;						if savetrees then							SaveLinkToChain(treeChain, concat(ds, '.', StringFromNum(k)), false,false);						RestoreCurrentTree(H, false);					end				else if (k = oldleft) | (k = oldright) then					treelength := oldtreelength				else					treelength := 0;				curLengthP := LIP(ord4(lengthP) + 4 * (k - 1));     {pointer in length storage for current node}				curLengthP^ := treelength;			end;		minLen := -1;		maxLen := 0;		for k := 1 to maxnode do			begin				curLengthP := LIP(ord4(lengthP) + 4 * (k - 1));     {pointer in length storage for current node}				if ((curLengthP^ < minLen) | (minLen = -1)) & (curLengthP^ > 0) then					minLen := curLengthP^;				if (curLengthP^ > maxLen) then					maxLen := curLengthP^;			end;		if maxLen - minLen > 10 then {####}			maxLen := minLen + 10;		for k := 1 to maxnode do			begin				tempN := NodeOfNumber(k);				curLengthP := LIP(ord4(lengthP) + 4 * (k - 1));     {pointer in length storage for current node}				if curLengthP^ = 0 then					curLengthP^ := maxLen;				tempN^.length1 := maxLen - curLengthP^;				if tempN^.length1 < 0 then					tempN^.length1 := 0;  {####}			end;		showchangeson := true;		curTrace := TraceAllChanges;1:		EndThermo(theDialog, tempP, true);		ZapPointer(lengthP);		treename^^ := ds;		dirtytree := olddirtytree;		ZapHandle(H);	end;{$ENDC}{$ENDC}{-----------------------------------------------------------------------------}{$SETC ALLMOVE=FALSE}{$IFC ALLMOVE}	procedure AllBranchMoves (fN: Nptr);{DRM - all SPR branch moves }		var			N: Nptr;			H: Handle;			j, k: integer;			ds: str255;	begin		ds := treename^^;		StoreCurrentTree(H);		for k := 1 to MaximumNodeNumber(R) do			begin				fromN := NodeOfNumber(k);				if BranchExists(fromN) & (fromN <> R) & (not ((fromN = R^.lf) or (fromN = R^.rt)) | (SizeOfClade(fromN, false) < ntscreen - 1)) then					for j := 1 to MaximumNodeNumber(R) do						begin							N := NodeOfNumber(j);							if (fromN <> N) and BranchExists(N) then								if MoveNodeToFrom(N) then									SaveLinkToChain(treeChain, concat(ds, '.', StringFromNum(k), '->', StringFromNum(j)), false,false);							RestoreCurrentTree(H, false);						end;			end;		treename^^ := ds;		ZapHandle(H);	end;{$ENDC}{-----------------------------------------------------------------------------}{$IFC RANDOMMOVE}	procedure RandomBranchMove (fN: Nptr);		{move fN to another node, chosen randomly}		{note if fN = R, then it randomly chooses the node to move in the tree}		var			N: Nptr;			moved: boolean;	begin		fromN := fN;		if fromN = R then  {choose a random node}			repeat				fromN := NodeOfNumber(RandomBetween(1, 2 * ntscreen - 1)); {v4: 2*ntscreen-1 is number of nodes in tree only if fully dichotomous}			until (fromN <> R) & (not ((fromN = R^.lf) or (fromN = R^.rt)) | (SizeOfClade(fromN, false) < ntscreen - 1));{check for possibility of branch move before we attempt it}		if (not ((fromN = R^.lf) or (fromN = R^.rt)) | (SizeOfClade(fromN, false) < ntscreen - 1)) then			repeat				repeat					N := NodeOfNumber(RandomBetween(1, 2 * ntscreen - 1));  {v4: 2*ntscreen-1 is number of nodes in tree only if fully dichotomous}				until (fromN <> N) and not (N^.null);				moved := MoveNodeToFrom(N);			until moved		else			Beep;	end;{$ENDC}end.