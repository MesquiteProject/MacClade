unit ImpForeignFiles;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, 		Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, 		EventUtil, GenUtil, StrUtil, TaxonCHUtil, MenuUtil, SymbolsNames, Footnote, Thermos, 		CharUtil, InfoWindows, TypeUtil, ReadWriteUtil, ReadUtil, CHUNK, ReadTreeFile, LinkUtil, 		Windows, RowColumn;	procedure ReadSequences (fileformat, nextTaxonNumber, currentCharacterNumber: integer; addAsNewSequences,nameAsFile: boolean);	procedure ReadForeignSequenceFile (fileformat: integer; nameAsFile: boolean);		procedure ReadNBRF (firsttoken: str255);	procedure ReadTaxonNamesOnly;	procedure ReadTabText (firsttoken: str255);	procedure ReadPhylipData (firsttoken: str255);	procedure ReadHennigNonaData (firsttoken: str255; isNona: boolean);	procedure ReadClustal;	procedure ReadGCG(firsttoken: str255);{еееееееееееееееееееееее}implementation {е$S ImpForeignFiles}{-----------------------------------------------------------------------------}	function StringMatchesTaxonName(ds: str255; var theTaxon: integer): boolean;	var 	it: integer;		tname: str255;	begin		theTaxon := 0;		for it := 1 to numtaxa do			begin				tname := TaxonName(it);				if StringsEqual(@tname, @ds,tnw) then					begin						theTaxon := it;						leave;					end;			end;		StringMatchesTaxonName:= theTaxon<>0;	end;{-----------------------------------------------------------------------------}	procedure CheckImportedSequenceType;	var isNucleotides: boolean;	begin		if not queriedAboutImportedSequenceType then 			begin				isNucleotides := CWarning('Are these data to be imported in the form of nucleotides or amino acids?', 'Nucleotides', 'Amino Acids');				if isNucleotides then					importedDataType := DNA				else					begin						importedDataType := protein;						if (datatype=standard) then							begin								NewError(456,0);								errorFlag := true;							end;					end;								queriedAboutImportedSequenceType := true;			end;	end;{-----------------------------------------------------------------------------}	function importedSetChars(c: char; it,ic: integer): LargestSetChars;		var tsts: LargestSetChars;	begin			tsts := [MSl];			if nucleotides then				if (c='N') | (c='n') then					tsts := [MSl,SSl]				else					begin						tsts := DNARNASetOfChar(c, true, 1, it, ic);						if IsAlternativeSymbolChar(c) then							tsts := tsts + [SSl];					end			else if datatype = protein then				tsts := ProteinSetOfChar(c, true, 1, it, ic)			else if allowImportMoleculeIntoStandard then				begin					CheckImportedSequenceType;				 	if (importedDataType=DNA) then						if (c='N') | (c='n') then							tsts := [MSl,SSl]						else							begin								tsts := DNARNASetOfChar(c, true, 1, it, ic);								if IsAlternativeSymbolChar(c) then									tsts := tsts + [SSl];							end					else if importedDataType = protein then							tsts := ProteinSetOfChar(c, true, 1, it, ic)				end;			importedSetChars := tsts;	end;{-----------------------------------------------------------------------------}	function SimpleTextStateSet(c: char; it,ic: integer; filetype: integer): largestsetchars;	var tsts: largestsetchars;	begin		tsts := [];		if nucleotides then			if (c='N') | (c='n') then				tsts := [MSl,SSl]			else				begin					tsts := DNARNASetOfChar(c, true, 1, it, ic);					if IsAlternativeSymbolChar(c) then						tsts := tsts + [SSl];				end		else if datatype = protein then			tsts := ProteinSetOfChar(c, true, 1, it, ic)		else			begin				if (filetype <> hennig) & (c = '-') then					tsts := [MSl, GAl]				else if (c = '?') or (c = '-') then					tsts := [MSl]				else					tsts := SetOfChar(c, true, it, ic);			end;		SimpleTextStateSet := tsts;	end;{-----------------------------------------------------------------------------}	procedure ReadTextMatrix (semiatend: boolean; filetype: integer);		var			command: Str255;			it, ic, k: integer;			thecommand: integer;			num: integer;			db: boolean;			c: char;			SetP: ptr;			ist, halftaxa: integer;			tsts: largestsetchars;			ds: str255;			taxstsHdlPtr: HdlPtr;			taxstsHdl: Handle;			oldState1, oldState2: SignedByte;	begin		halftaxa := numtaxa div 2;		badfile := false;		SetCursID(carabid);		it := 0;		LockHandle(TaxstsCHUNKs, oldState1);		TaxstsHdlPtr := HdlPtr(GetMaster(TaxstsCHUNKs));		while (it < numtaxa) and not badfile and not errorflag do			begin				UpdateThermo(iothermo, 0, fpos, mcFileLength,true);				if abortedthermo then					begin						errorFlag := true;						Exit(ReadTextMatrix);					end;				if it = halftaxa then					SetCursID(salticid);				TaxStsHdl := TaxstsHdlPtr^;				LockHandle(TaxstsHdl, oldState2);				SetP := Ptr(GetMaster(TaxStsHdl));				it := it + 1;				ic := 0;				ds := GetFileToken(maxtok);		{getting taxon name}				if (semiatend & (ds = ';')) | (fpos > mcFileLength) then					begin						InstantError(258);						badfile := true;						leave;					end;				UnderLineToBlanks(ds);				delete(ds, 33, length(ds));				SetTaxonName(it, ds);				ic := 0;				c := anynextdarkchar;				while (ic < numchars) & not badfile & not errorflag do					begin						if (semiatend & (c = ';')) | (fpos > mcFileLength) then							begin								InstantError(258);								badfile := true;								leave;							end;						if not (c in [' ', chr(9), chr(13), chr(10), ',']+vacuum) then							begin								ic := ic + 1;								num := ord(c);								if c='[' then									begin										tsts := [];										repeat											c := anynextdarkchar;											if c <> ']' then tsts := tsts+SimpleTextStateSet(c,it,ic,filetype);										until (c=']') | badfile | errorflag | (fpos > mcFileLength);										if tsts = [] then tsts := [MSl];									end								else									tsts := SimpleTextStateSet(c,it,ic,filetype);								TransferStatesFromLargest(SetP, tsts);								SetP := Ptr(ord4(SetP) + tcb);							end;						c := anynextdarkchar;					end;  {numchars loop}				ResetHandle(TaxstsHdl, oldState2);				TaxstsHdlPtr := HdlPtr(ord4(TaxstsHdlPtr) + HdlSize);			end;   {numtaxa loop}		ResetHandle(TaxstsCHUNKs, oldState1);		if badfile | (numchars=0) then			errorflag := true		else			begin				SetCursID(flower);				ReCalcMaxstAndStates(1,numchars);				if semiatend then					Skipper(punctuation, true);			end;	end;{-----------------------------------------------------------------------------}	function genBankLineToProcess(lineStart: str255): boolean;	var ds: str255;	begin		ds := MakeCaps(lineStart);		genBankLineToProcess := (ds = 'DEFINITION') | (ds = 'LOCUS') | (ds = 'ACCESSION') | (ds = 'ORGANISM') | (ds = 'ORIGIN');	end;{-----------------------------------------------------------------------------}	procedure ReadGenBankFromHandle (H: Handle; it: integer; var maxic: integer; originalNumChars: integer; addAsNewSequences,nameAsFile: boolean; var success: boolean);		label			1;		var			c: char;			ds, accession, taxname, definition, locusString, sourceString, organismString: str255;			ic,  furtheric, theTaxon: integer;			tsts: largestsetchars;			finishedsequence: boolean;	begin		definition := '';		sourceString := '';		locusString := '';		organismString :='';		success := true;		accession := '';		finishedsequence := false;		theTaxon := it;		ic := 0;				repeat			repeat				ds := GetFileToken(32);				if (not genBankLineToProcess(ds)) then 					RawSkipToEndOfLine(true);			until ((length(ds) >= 5) & (genBankLineToProcess(ds))) | (fpos >= mcFileLength);{5 is the minimal length of the keywords recognized by MacClade}{			if (fpos < mcFileLength) & (theTaxon > 1) & (ds = 'LOCUS') then				AddNewTaxa(1, false);}			if badmemory then				begin					errorflag := true;					goto 1;				end;			if ds = 'DEFINITION' then				begin					while not (next in [chr(10), chr(13)]) and (length(ds) < 255) do						begin							next := anynextchar;							if not (next in [chr(10), chr(13)]) then								definition := concat(definition, next);						end;				end			else if ds = 'LOCUS' then				begin					c := nextDarkChar;					locusString := '';					repeat						locusString := concat(locusString,c);						c := anyNextChar;					until (c=chr(10)) | (c=chr(13));					if length(locusString) > tnw then						locusString := copy(locusString,1,tnw);				end			else if ds = 'ORGANISM' then				begin					c := nextDarkChar;					organismString := '';					repeat						organismString := concat(organismString,c);						c := anyNextChar;					until (c=chr(10)) | (c=chr(13));					if length(organismString) > tnw then						organismString := copy(organismString,1,tnw);				end			else if ds = 'SOURCE' then				begin					c := nextDarkChar;					sourceString := '';					repeat						sourceString := concat(sourceString,c);						c := anyNextChar;					until (c=chr(10)) | (c=chr(13));					if length(sourceString) > tnw then						sourceString := copy(sourceString,1,tnw);				end			else if ds = 'ACCESSION' then				accession := GetFileToken(32)			else if ds = 'ORIGIN' then				begin					if (organismString<>'') then						taxName := organismString					else if (sourceString<>'') then						taxName := sourceString					else if (locusString<>'') then						taxName := locusString;					theTaxon := it;					if addASNewSequences then						begin							if nameAsFile then								SetTaxonName(it,FDI^[readFileFDI].fs.name)							else								SetTaxonName(theTaxon,taxname);							ic := 0;						end					else 						begin							if not StringMatchesTaxonName(taxname, theTaxon) then								begin									AddNewTaxa(1, true);									SetTaxonName(numtaxa, taxname);  {store old numchars}									theTaxon := numtaxa;								end;							ic := originalNumChars;						end;					c := nextDarkChar;					repeat						if not ((c = '/') | ((c >= '0') & (c <= '9'))) then							begin								ic := ic + 1;								if ic > numchars then									AddNewCharacters(25, true);								if badmemory then									begin										errorflag := true;										goto 1;									end;								if (c in ['?']) then									tsts := [MSl]								else if (c = '-') then									tsts := [MSl, GAl]								else 									tsts := importedSetChars(c,theTaxon,ic);								if errorflag then goto 1;								SettaxonStsLargest(theTaxon, ic, tsts);							end;						c := nextDarkChar;						if ic mod 10 = 0 then							begin								if ShowIOThermo then UpdateThermo(iothermo, 0, fpos, mcFileLength,true);								if abortedthermo then									begin										errorFlag := true;										Exit(ReadGenBankFromHandle);									end;							end;					until (c = '/') or (fpos >= mcFileLength);					if ic > maxic then						maxic := ic;					for furtheric := ic + 1 to numchars do						SettaxonStsLargest(theTaxon, furtheric, [MSl, GAl]);					c := nextDarkChar;      {'>'}					finishedsequence := true;				end;		until finishedsequence | (fpos >= mcFileLength) | errorflag | badfile;		if finishedsequence & ((length(accession) > 0) | (length(definition) > 0)) then			SetFootString(footText, theTaxon, 0, concat(accession, '. ', definition));		if ic > maxic then			maxic := ic;		for furtheric := ic + 1 to numchars do			SettaxonStsLargest(theTaxon, furtheric, [MSl, GAl]);1:	end;{-----------------------------------------------------------------------------}	procedure ReadNBRFFromHandle (H: Handle; it: integer; var maxic: integer; originalNumChars: integer; addAsNewSequences,nameAsFile: boolean; var success: boolean);		var			c: char;			ds: str255;			ic, furtheric, theTaxon: integer;			tsts: largestsetchars;			db: boolean;			oldFPos, dL, oldFileLength: longint;			oldPunct: set of char;	begin		success := true;		db := FindRawFileChar(';',false);		if not db then Exit(ReadNBRFFromHandle);		next := anynextchar;		oldPunct:= punctuation;		punctuation := [];   {v4.04}		ds := GetFileToken(tnw+1);		punctuation := oldPunct;		UnderLineToBlanks(ds);		theTaxon := it;		if addASNewSequences then			begin				if nameAsFile then					SetTaxonName(it,FDI^[readFileFDI].fs.name)				else					SetTaxonName(theTaxon,ds);{				SetTaxonName(theTaxon,ds);}				ic := 0;			end		else 			begin				if not StringMatchesTaxonName(ds, theTaxon) then					begin						AddNewTaxa(1, true);						SetTaxonName(numtaxa, ds);  {store old numchars}						theTaxon := numtaxa;					end;				ic := originalNumChars;			end;		RawSkipToEndOfLine(true);//		if not NewLineChar(next) then  {we need to get to the end of this line}//			repeat//			until NewLineChar(anynextchar) or (fpos >= mcFileLength);   {skipping to end of line}//		next := anynextchar;					{skipping to new line}		RawSkipToEndOfLine(true);  {skipping comment line}		c := next;//		if not NewLineChar(next) then//			repeat//				c := anynextchar;//			until NewLineChar(c) or (fpos >= mcFileLength);   {skipping comment line}		if  (fpos < mcFileLength) & (NewLineChar(next)| (next in whitespace)) then			c := nextDarkChar;		if (fpos >= mcFileLength) then			success := false		else		repeat			ic := ic + 1;			if ic>= mnchars then				begin					errorFlag := true;					Exit(ReadNBRFFromHandle);				end			else if ic > numchars then				begin					if ic > mnchars-25 then						AddNewCharacters(mnchars-ic,true)					else												AddNewCharacters(25, true);				end;							if badmemory then				begin					errorflag := true;					Exit(ReadNBRFFromHandle);				end;			if (c in ['?']) then				tsts := [MSl]			else if (c = '-') or  (c = '~') then				tsts := [MSl, GAl]			else 				tsts := importedSetChars(c,theTaxon,ic);			if errorflag then Exit(ReadNBRFFromHandle);			SettaxonStsLargest(theTaxon, ic, tsts);			c := nextDarkChar;			if ic mod 10 = 0 then				begin					if ShowIOThermo then UpdateThermo(iothermo, 0, fpos, mcFileLength,true);					if abortedthermo then						begin							errorFlag := true;							Exit(ReadNBRFFromHandle);						end;				end;		until (fpos >= mcFileLength) | (c = '*') | errorflag | badfile;		if ic > maxic then			maxic := ic;		for furtheric := ic + 1 to numchars do			SettaxonStsLargest(theTaxon, furtheric, [MSl, GAl]);	end;{-----------------------------------------------------------------------------}	procedure ReadFastAFromHandle (H: Handle; it: integer; var maxic: integer; originalNumChars: integer; addAsNewSequences,nameAsFile: boolean; var success: boolean);		var			c: char;			ds: str255;			ic, furtheric, theTaxon: integer;			tsts: largestsetchars;			db: boolean;			oldFPos, dL, oldFileLength: longint;	begin		success := true;		ds := '';		repeat			next := anyNextChar;			if next = '|' then				ds := ''			else if not NewLineChar(next) then				ds := concat(ds,next);		until NewLineChar(next);		RawSkipToEndOfLine(false);				UnderLineToBlanks(ds);		theTaxon := it;		if addASNewSequences then			begin				if nameAsFile then					SetTaxonName(it,FDI^[readFileFDI].fs.name)				else					SetTaxonName(theTaxon,ds);{				SetTaxonName(theTaxon,ds);}				ic := 0;			end		else 			begin				if not StringMatchesTaxonName(ds, theTaxon) then					begin						AddNewTaxa(1, true);						SetTaxonName(numtaxa, ds);  {store old numchars}						theTaxon := numtaxa;					end;				ic := originalNumChars;			end;		if  (fpos < mcFileLength) then			c := nextDarkChar;		if (fpos <  mcFileLength) then			repeat				ic := ic + 1;				if ic>= mnchars then					begin						errorFlag := true;						Exit(ReadFastAFromHandle);					end				else if ic > numchars then					begin						if ic > mnchars-25 then							AddNewCharacters(mnchars-ic,true)						else													AddNewCharacters(25, true);					end;									if badmemory then					begin						errorflag := true;						Exit(ReadFastAFromHandle);					end;				if (c in ['?']) then					tsts := [MSl]				else if (c = '-') or  (c = '~') then					tsts := [MSl, GAl]				else 					tsts := importedSetChars(c,theTaxon,ic);				if errorflag then Exit(ReadFastAFromHandle);				SettaxonStsLargest(theTaxon, ic, tsts);				c := nextDarkChar;				if ic mod 10 = 0 then					begin						if ShowIOThermo then UpdateThermo(iothermo, 0, fpos, mcFileLength,true);						if abortedthermo then							begin								errorFlag := true;								Exit(ReadFastAFromHandle);							end;					end;			until (fpos >= mcFileLength) | (c = '*') | errorflag | badfile;		if ic > maxic then			maxic := ic;		for furtheric := ic + 1 to numchars do			SettaxonStsLargest(theTaxon, furtheric, [MSl, GAl]);	end;{-----------------------------------------------------------------------------}	procedure ReadSimpleTextFromHandle (H: Handle; it: integer; var maxic: integer; originalNumChars: integer; addAsNewSequences, taxonNamePresent,nameAsFile: boolean; var success: boolean);		var			c: char;			ds: str255;			ic, furtheric, theTaxon: integer;			tsts: largestsetchars;			db: boolean;			oldFPos, dL, oldFileLength: longint;	begin		success := true;		if taxonNamePresent then			begin				next := anynextchar;				ds := GetFileToken(tnw+1);				if ds= '#NEXUS' then					begin						badfile := true;						errorflag := true;						NewError(416,0);						success := false;						Exit(ReadSimpleTextFromHandle);					end;				UnderLineToBlanks(ds);				theTaxon := it;				if addASNewSequences then					begin						if nameAsFile then							SetTaxonName(it,FDI^[readFileFDI].fs.name)						else							SetTaxonName(theTaxon,ds);						ic := 0;					end				else 					begin						if not StringMatchesTaxonName(ds, theTaxon) then							begin								AddNewTaxa(1, true);								SetTaxonName(numtaxa, ds);  {store old numchars}								theTaxon := numtaxa;							end;						ic := originalNumChars;					end;			end		else			begin				theTaxon := it;				ic := 0;				SetTaxonName(theTaxon,FDI^[readFileFDI].fs.name);			end;		if  (fpos < mcFileLength) then			begin				c := nextDarkChar;				if (c = '#') & not taxonNamePresent  then					begin						badfile := true;						errorflag := true;						success := false;						NewError(416,0);						Exit(ReadSimpleTextFromHandle);					end;			end;		repeat			ic := ic + 1;			if ic>= mnchars then				begin					errorFlag := true;					Exit(ReadSimpleTextFromHandle);				end			else if ic > numchars then				begin					if ic > mnchars-25 then						AddNewCharacters(mnchars-ic,true)					else												AddNewCharacters(25, true);				end;			if badmemory then				begin					errorflag := true;					Exit(ReadSimpleTextFromHandle);				end;			if (c in ['?']) then				tsts := [MSl]			else if (c = '-') or  (c = '~') then				tsts := [MSl, GAl]			else 				tsts := importedSetChars(c,theTaxon,ic);			if errorflag then Exit(ReadSimpleTextFromHandle);			SettaxonStsLargest(theTaxon, ic, tsts);			c := nextDarkChar;			if ic mod 10 = 0 then				begin					if ShowIOThermo then UpdateThermo(iothermo, 0, fpos, mcFileLength,true);					if abortedthermo then						begin							errorFlag := true;							Exit(ReadSimpleTextFromHandle);						end;				end;		until (fpos >= mcFileLength) | errorflag | badfile;		if ic > maxic then			maxic := ic;		for furtheric := ic + 1 to numchars do			SettaxonStsLargest(theTaxon, furtheric, [MSl, GAl]);	end;{-----------------------------------------------------------------------------}	procedure ReadSequences (fileformat, nextTaxonNumber, currentCharacterNumber: integer; addAsNewSequences,nameAsFile: boolean);			label			1;		var			c: char;			ds: str255;			it,maxic,ic, furtheric: integer;			originalNumChars: integer;			tsts: largestsetchars;			H: Handle;			db,foundStop, success: boolean;			oldFPos, dL, oldFileLength, oldReadBufferP, oldreadBufLength: longint;			oldnext: char;			firstSequence : boolean;			lineEmpty: boolean;	begin		it := nextTaxonNumber;		maxic := currentCharacterNumber;		originalNumChars:= numchars;		firstSequence := true;		lineEmpty := false;		if addAsNewSequences then			SetLastChangeInEditor(lastChangeInsertTaxaAndCellBlock);		repeat			badfile := false;			if ShowIOThermo then UpdateThermo(iothermo, 0, fpos, mcFileLength,true);			H:= NewHandle(0);			case fileFormat of 				nbrf: 					LineToHandle(H,'*',false,false,foundStop, lineEmpty,3);				genbank:					LineToHandle(H,'//',true,false,foundStop, lineEmpty,0);				simpletext:					LineToHandle(H,'',false,false,foundStop, lineEmpty,0);				sequenceOnly:					LineToHandle(H,'',false,false,foundStop, lineEmpty,0);				fastA:					begin						if it = nextTaxonNumber then  {we are on first one; need to skip over leading stop character}							Skipper(['>'],false);						LineToHandle(H,'>',true,false,foundStop, lineEmpty,0);						if fpos >= mcFileLength then foundStop := true;  {since it doesn't end with a stop character...}					end;				otherwise;			end;			if lineEmpty then				begin					ZapHandle(H);					 if not firstSequence then						goto 1;				end			else if not foundStop then				begin					ZapHandle(H);					if firstSequence then						begin							NewError(454,0);							errorflag := true;							Exit(ReadSequences);						end					else goto 1;				end			else if (it > 1) & addAsNewSequences then				begin					AddNewTaxa(1, true);				end;			if badmemory then				begin					errorflag := true;					ZapHandle(H);					if firstSequence then						Exit(ReadSequences)					else goto 1;				end;			StartReadingFromHandle(H,oldFPos, oldFileLength, oldReadBufferP, oldreadBufLength,oldnext);						success := true;			case fileFormat of 				nbrf: 					ReadNBRFFromHandle(H,it,maxic, originalNumChars,addAsNewSequences,nameAsFile, success);				genbank:					ReadGenBankFromHandle(H,it,maxic, originalNumChars, addAsNewSequences,nameAsFile, success);				fastA:					ReadFASTAFromHandle(H,it,maxic, originalNumChars, addAsNewSequences,nameAsFile, success);				simpletext:					ReadSimpleTextFromHandle(H,it,maxic, originalNumChars, addAsNewSequences, true,nameAsFile, success);				sequenceOnly:					ReadSimpleTextFromHandle(H,it,maxic, originalNumChars, addAsNewSequences, false,true, success);				otherwise;			end;						if not success then				begin					DestroyTaxa(numtaxa, numtaxa, true,false);					badfile := true;				end;			EndReadingFromHandle(H,oldFPos, oldFileLength, oldReadBufferP, oldreadBufLength,oldnext);			it := it + 1;			ZapHandle(H);			firstSequence := false;		until (fpos >= mcFileLength) or badfile or errorflag;		if badfile then			errorflag := true;1:		if numchars > maxic then  {need to destroy extras at end}			DestroyCharacters(maxic + 1, numchars, false, false,true,true);					end;{-----------------------------------------------------------------------------}	procedure ReadNBRF (firsttoken: str255);		label			1;		var			c: char;			ds: str255;			it, ic, maxic, furtheric: integer;			tsts: largestsetchars;	begin		numchars := 1;		numtaxa := 1;		if not CreateTaxonCharMemory then			begin				CleanUpFailedTaxonCharacterMemory;				Exit(ReadNBRF);			end;		SetCursID(amoeba);		it := 1;		maxic := 0;		repeat			if it > 1 then				AddNewTaxa(1, false);			if badmemory then				begin					errorflag := true;					goto 1;				end;			Skipper([';'], true);			ds := GetFileToken(tnw+1);			UnderLineToBlanks(ds);			SetTaxonName(it, ds);			RawSkipToEndOfLine(true);	//		if not NewLineChar(next) then  {we need to get to the end of this line}	//			repeat	//			until NewLineChar(anynextchar) or (fpos >= mcFileLength);   {skipping to end of line}	//		next := anynextchar;					{skipping to new line}			RawSkipToEndOfLine(true);  {skipping comment line}			c := next;	//		if not NewLineChar(next) then	//			repeat	//				c := anynextchar;	//			until NewLineChar(c) or (fpos >= mcFileLength);   {skipping comment line}			ic := 0;			c := nextDarkChar;			repeat				ic := ic + 1;				if ic > numchars then					AddNewCharacters(25, true);				if badmemory then					begin						errorflag := true;						goto 1;					end;				if (c in ['?']) then					tsts := [MSl]				else if (c = '-') or (c = '~') then			{3.06:  added tilde}					tsts := [MSl, GAl]				else if nucleotides then					if (c='N') | (c='n') then						tsts := [MSl,SSl]					else						begin							tsts := DNARNASetOfChar(c, true, 1, it, ic);							if IsAlternativeSymbolChar(c) then								tsts := tsts + [SSl];						end				else if datatype = protein then					tsts := ProteinSetOfChar(c, true, 1, it, ic);				SettaxonStsLargest(it, ic, tsts);				c := nextDarkChar;				if ic mod 10 = 0 then					begin						UpdateThermo(iothermo, 0, fpos, mcFileLength,true);						if abortedthermo then							begin								errorFlag := true;								Exit(ReadNBRF);							end;					end;			until (c = '*') or errorflag or badfile;			if ic > maxic then				maxic := ic;			for furtheric := ic + 1 to numchars do				SettaxonStsLargest(it, furtheric, [MSl, GAl]);			c := nextDarkChar;      {'>'}			it := it + 1;		until (fpos >= mcFileLength) or badfile or errorflag;		if badfile then			errorflag := true;		if numchars > maxic then  {need to destroy extras at end}			DestroyCharacters(maxic + 1, numchars, false, false,true,true);1:	end;{-----------------------------------------------------------------------------}	procedure ReadForeignSequenceFile (fileformat: integer; nameAsFile: boolean);	begin		numchars := 1;		numtaxa := 1;		fpos := kInitialReadPos;		if not CreateTaxonCharMemory then			CleanUpFailedTaxonCharacterMemory		else			begin				ReadSequences(fileformat,numtaxa+1,numchars,true,nameAsFile);				if not errorflag then					DestroyTaxa(1,1,true,true);			end;	end;{-----------------------------------------------------------------------------}	procedure ReadTabText;		var			c: char;			ds: str255;			amountneeded: longint;	begin		SetCursID(amoeba);{v4: have it accept [! ] comments}{ can have leading and trailing comments, but none}{in matrix itself, have to have each taxon on one line, non tranposed,}{can have blank lines}{===== calculating numchars =====}		numchars := 0;		repeat			c := nextchar;			if not (c in whitespace) then				numchars := numchars + 1;		until NewLineChar(c);		next := nextchar;		if (NewLineChar(next)) then			next := nextChar;{===== calculating numtaxa =====}		numtaxa := 1;		while fpos < mcFileLength do			begin				ds := GetFileToken(maxtok); 		{taxon name}				if (ds <> '') and (ds <> ' ') then					begin						if numtaxa = 63 then							begin							end;						numtaxa := numtaxa + 1;					end;				repeat					c := nextchar;				until (fpos >= mcFileLength) or NewLineChar(c);				if fpos < mcFileLength then					begin						next := nextchar;						if (NewLineChar(next)) then							next := nextChar;					end;			end;		if not errorflag then			begin				if not EnoughMemory(FullMemoryNeeded(numtaxa, numchars), amountneeded) then					begin						InstantErrorPlus(268, concat(StringFromNum(amountneeded div 1024), 'K'));						errorflag := true;						Exit(ReadTabText);					end;				if not CreateTaxonCharMemory then					begin						CleanUpFailedTaxonCharacterMemory;						Exit(ReadTabText);					end;				fpos := kInitialReadPos;  {was 0}{===== rereading file =====}				ReadTextMatrix(false, simpletext);			end;	end;{-----------------------------------------------------------------------------}	procedure ReadTaxonNamesOnly;	var			c: char;			ds: str255;			it, ic, maxic, furtheric: integer;			tsts: largestsetchars;	begin		numchars := 1;		numtaxa := 1;		fpos := kInitialReadPos;		if not CreateTaxonCharMemory then			begin				CleanUpFailedTaxonCharacterMemory;				Exit(ReadTaxonNamesOnly);			end;		SetCursID(amoeba);		it := 1;		next := anynextchar;		repeat			if badmemory then				begin					errorflag := true;					Exit(ReadTaxonNamesOnly);				end;			ds := '';			if not NewLineChar(next) then				begin					ds := next;					repeat						c := anyNextChar;						if not NewLineChar(c) then							ds := concat(ds,c);					until (NewLineChar(c)) | (length(ds)=tnw);   				end;			if not NewLineChar(c) then  {we dropped out of previous because we hit a name that is too long}				repeat				until NewLineChar(anynextchar);						if length(ds)>0 then				begin					if it > 1 then						AddNewTaxa(1, false);					UnderLineToBlanks(ds);					SetTaxonName(it, ds);					it := it + 1;				end;			if NewLineChar(next) then  {if we happen to be sitting now on another newline then skip to next non newline}				repeat				until not NewLineChar(anynextchar);								until (fpos >= mcFileLength) or badfile or errorflag;		if badfile then			errorflag := true;	end;{-----------------------------------------------------------------------------}	procedure ReadGCG(firsttoken: str255);		label			1;		var			c: char;			ds: str255;			it, ic, maxic, furtheric: integer;			tsts: largestsetchars;			firstblock: boolean;			startchars: integer;			typeNotSet: boolean;			nameOfFile, firstTaxonName: str255;			oldPunct: set of char;	begin		ds := MakeCaps(copy(firsttoken,1,4));		TypeNotSet := false;		if ds='!!NA' then			SetDataFormat(DNA, false)		else if ds='!!AA' then			SetDataFormat(protein, false)		else			begin				SetDataFormat(DNA, false);				typeNotSet := true;			end;		numchars := 1;		numtaxa := 1;		if not CreateTaxonCharMemory then			begin				CleanUpFailedTaxonCharacterMemory;				Exit(ReadGCG);			end;		SetCursID(amoeba);	{	nameOfFile := filename^^;		StripBlanks(nameOfFile);		if not FindFileToken(nameOfFile, true) then 			begin				badfile := true;				errorflag := true;				Exit(ReadGCG);			end;}		if TypeNotSet then			if not FindFileToken('Type', true) then 				begin					badfile := true;					errorflag := true;					Exit(ReadGCG);				end			else 				begin					if next<>':' then						c := anyNextDarkChar;  //should be ':'					c := anyNextDarkChar;					if (c='p')|(c='P') then						SetDataFormat(protein, false);					SkipToEndOfLine(true);				end;{		repeat			c := anynextchar;		until NewLineChar(c);     		next := anynextchar;}		{now find the collection of taxon names}		it := 0;		firstTaxonName := '';		repeat			ds := MakeCaps(GetFileToken(tnw+1));			if (ds='NAME') then  {this is a taxon name}				begin					it := it+1;					if it > 1 then						AddNewTaxa(1, false);					if badmemory then						begin							errorflag := true;							goto 1;						end;					c := anyNextDarkChar;  //should be ':'					oldPunct:= punctuation;					punctuation := [];					ds := GetFileToken(tnw+1);   {here's the taxon name}					if (it=1) then						firstTaxonName := ds;					punctuation := oldPunct;					UnderLineToBlanks(ds);					SetTaxonName(it, ds);  {set this as the taxon name}				end			else if ds = '/' then   {this tells us it is the //}				begin					if next = '/' then						leave;					{next := anyNextChar;}				end;			SkipToEndOfLine(true);		until (fpos>= mcFileLength);		if (fpos>= mcFileLength) then 			begin				badfile := true;				errorflag := true;				Exit(ReadGCG);			end;		startchars := 0;		it := 0;		maxic := 0;				firstblock := true;				repeat			oldPunct:= punctuation;			punctuation := [];			it := 0;			repeat   {let's look for a taxon name}				ds := GetFileToken(tnw+1);  {check for taxon name}				it := GetTaxonNumber(ds);				if it=0 then  {it's not a taxon name, skip to end of line and look more}					SkipToEndOfLine(true);			until (it>0) |(fpos>= mcFileLength);			punctuation := oldPunct;			if it = 1 then   {we've found the start of a block}				startchars := maxic;			{it := it+1;}			if it = 0 then				leave;			ic := startchars;							c := nextDarkChar;			repeat				if c<>' ' then					begin						ic := ic + 1;						if ic > numchars then							AddNewCharacters(25, true);						if badmemory then							begin								errorflag := true;								goto 1;							end;						if (c in ['?']) then							tsts := [MSl]						else if (c = '.') or (c = '~') then										tsts := [MSl, GAl]						else if nucleotides then							if (c='N') | (c='n') then								tsts := [MSl,SSl]							else								begin									tsts := DNARNASetOfChar(c, true, 1, it, ic);									if IsAlternativeSymbolChar(c) then										tsts := tsts + [SSl];								end						else if datatype = protein then							tsts := ProteinSetOfChar(c, true, 1, it, ic);						SettaxonStsLargest(it, ic, tsts);					end;				c := anynextchar;				if ic mod 10 = 0 then					begin						UpdateThermo(iothermo, 0, fpos, mcFileLength,true);						if abortedthermo then							begin								errorFlag := true;								Exit(ReadGCG);							end;					end;			until  (c=chr(13)) | (c=chr(10)) | errorflag | badfile | (fpos>=mcFileLength);			next := c;			if ic > maxic then				maxic := ic;			for furtheric := ic + 1 to numchars do				SettaxonStsLargest(it, furtheric, [MSl, GAl]);		until (fpos >= mcFileLength) or badfile or errorflag;		if badfile then			errorflag := true;		if numchars > maxic then  {need to destroy extras at end}			DestroyCharacters(maxic + 1, numchars, false, false,true,true);1:	end;{-----------------------------------------------------------------------------}	procedure ReadClustal;		label			1;		var			c: char;			ds: str255;			it, ic, maxic, furtheric: integer;			tsts: largestsetchars;			firstblock: boolean;			startchars: integer;			oldpunct: set of char;	begin		oldpunct := punctuation;		punctuation := [];   {v4.04}		numchars := 1;		numtaxa := 1;		if not CreateTaxonCharMemory then			begin				CleanUpFailedTaxonCharacterMemory;				goto 1;			end;		SetCursID(amoeba);		repeat			c := anynextchar;		until NewLineChar(c);     {skip initial Clustal line}		next := anynextchar;		if (NewLineChar(next)) then			next := anyNextChar;				startchars := 0;		it := 0;		maxic := 0;				firstblock := true;				repeat			it := it+1;			if firstblock then				begin					if it > 1 then						AddNewTaxa(1, false);					if badmemory then						begin							errorflag := true;							goto 1;						end;				end;			ds := GetFileToken(tnw+1);			UnderLineToBlanks(ds);			if firstblock then				SetTaxonName(it, ds);			ic := startchars;							c := nextDarkChar;			repeat				ic := ic + 1;				if ic > numchars then					AddNewCharacters(25, true);				if badmemory then					begin						errorflag := true;						goto 1;					end;				if (c>='0') & (c <= '9') then					repeat						c := anynextchar;					until  (c<'0') | (c > '9') | (fpos>=mcFileLength);				if (c in ['?']) then					tsts := [MSl]				else if (c = '-') or (c = '~') then			{3.06:  added tilde}					tsts := [MSl, GAl]				else if nucleotides then					if (c='N') | (c='n') then						tsts := [MSl,SSl]					else						begin							tsts := DNARNASetOfChar(c, true, 1, it, ic);							if IsAlternativeSymbolChar(c) then								tsts := tsts + [SSl];						end				else if datatype = protein then					tsts := ProteinSetOfChar(c, true, 1, it, ic);				SettaxonStsLargest(it, ic, tsts);				c := anynextchar;				if ic mod 10 = 0 then					begin						UpdateThermo(iothermo, 0, fpos, mcFileLength,true);						if abortedthermo then							begin								errorFlag := true;								goto 1;							end;					end;			until  (c=chr(13)) | (c=chr(10)) | errorflag | badfile | (fpos>=mcFileLength);			next := c;			if ic > maxic then				maxic := ic;			for furtheric := ic + 1 to numchars do				SettaxonStsLargest(it, furtheric, [MSl, GAl]);			if (c=chr(13)) | (c=chr(10)) then  {we are at end of line}				begin					 next := anynextchar;					if next in [chr(10), chr(13)] then  {we must be at end of block}						begin							next := anynextchar;  {first char of new line}							firstblock := false;							it := 0;							startchars := maxic;						end;					if (next=' ') then  {we are on a *** line}						begin							repeat								c := anynextchar;							until NewLineChar(c);     {skip *** line}							next := anynextdarkchar;							firstblock := false;							it := 0;							startchars := maxic;						end;				end;		until (fpos >= mcFileLength) or badfile or errorflag;		if badfile then			errorflag := true;		if numchars > maxic then  {need to destroy extras at end}			DestroyCharacters(maxic + 1, numchars, false, false,true,true);1:		punctuation := oldpunct;	end;{-----------------------------------------------------------------------------}	procedure ReadPhylipData;		label			1, 2;		var			ctypP, cwtP: IP;			it, ic, k, j: integer;			thecommand: integer;			db: boolean;			c: char;			isC: boolean;			ist, halftaxa, linestoskip: integer;			tsts: largestsetchars;			ds: str255;			SetP: Ptr;			ancstates, factors, mixedmethods, outgroups, allirrevers, alldollo, usertrees, weights: BOOLEAN;			firstblock: BOOLEAN;			blockstart: integer;			taxstsHdlPtr: HdlPtr;			taxstsHdl: Handle;			oldState1, oldState2: SignedByte;			interleavelengthMeasured: boolean;			amountneeded: longint;	begin		SetCursID(amoeba);		interleavelengthMeasured := false;		numtaxa := TokenToInteger(firsttoken, true);		numchars := TokenToInteger(GetFileToken(maxtok), true);		if errorflag then			Exit(ReadPhylipData);		if not EnoughMemory(FullMemoryNeeded(numtaxa, numchars), amountneeded) then			begin				InstantErrorPlus(268, concat(StringFromNum(amountneeded div 1024), 'K'));				errorflag := true;				Exit(ReadPhylipData);			end;		if not CreateTaxonCharMemory then			begin				CleanUpFailedTaxonCharacterMemory;				Exit(ReadPhylipData);			end;{SkipToEndOfLine(false);}		ancstates := false;		allirrevers := false;		alldollo := false;		factors := false;		mixedmethods := false;		allirrevers := false;		usertrees := false;		weights := false;		linestoskip := 0;{|||||||| processing options lines |||||||||}		while not NewLineChar(next) and not errorflag do			begin				next := CapChar(nextchar);				if (next in ['T', 'O', 'D', 'S', 'U']) and (phylipversion >= 34) then					errorflag := CWarning(concat('Option ', next, ' not allowed!'), 'Cancel', 'Continue')				else if (next in ['A', 'T', 'O']) | ((next = 'F') & not molecular) then  {or other options with extra lines}					linestoskip := linestoskip + 1				else if next in ['J'] then					errorflag := CWarning(concat('Option ', next, ' not allowed!'), 'Cancel', 'Continue')				else					case next of						'C':   {categories, not CAMIN, not CLIQUE}							if phylipversion = 33 then								linestoskip := linestoskip + 1							else								linestoskip := linestoskip + 2;						'D':   {DOLLO}							for j := 1 to numchars do								begin									ctypP := IP(GetMaster(chtypH) + chtb * ord4(j - 1));									ctypP^ := dollo;								end;						'M': 							begin								mixedmethods := true;								linestoskip := linestoskip + 1;							end;						'S': 							for j := 1 to numchars do								begin									ctypP := IP(GetMaster(chtypH) + chtb * ord4(j - 1));									ctypP^ := irreversible;								end;						'U': 							usertrees := true;						'W': 							begin								weights := true;								linestoskip := linestoskip + 1;							end;						otherwise							;{G, H, P,Y,L ,R,ignored}					end;			end;		if errorflag then			goto 1;{|||||||||| processing extra options lines ||||||||}		for j := 1 to linestoskip do			begin				c := CapChar(nextchar);				isC := c = 'C';				if (c = 'T') or ((c = 'C') and (phylipversion < 34)) then  {just have to skip to end of line}					begin						next := nextchar;						k := 0;						if isC and (next = 'A') then   {it is THE categories line}							repeat								next := nextchar;								if not NewLineChar(next) then									k := k + 1;							until k = numchars + 8  {+8 as still have to go through "ATEGORIES"}						else							while not NewLineChar(next) do								begin									next := nextchar;								end					end				else					begin						for k := 2 to 10 do							next := nextchar;						k := 0;						case c of							'C', 'A', 'F', 'O':   {Factors, outgroups - here we just skip over them}								repeat									next := nextchar;									if not NewLineChar(next) then										k := k + 1;								until k = numchars;							'M': 								begin									repeat										next := nextchar;										if not NewLineChar(next) then											begin												k := k + 1;												ctypP := IP(GetMaster(chtypH) + chtb * ord4(k - 1));												if next in ['C', 'S'] then													ctypP^ := irreversible;											end;									until k = numchars;									SaveLinkToChain(typesetchain, 'from_phylip', false,false);									linknumber[TypeSetChain] := EndUserLink(typesetchain);									DefaultLink[typeSetChain] := linknumber[typeSetChain];								end;							'W': 								begin									repeat										next := nextchar;										if not NewLineChar(next) then											begin												k := k + 1;												cwtP := IP(GetMaster(chwtH) + chwb * ord4(k - 1));												if next in ['0'..'9'] then													cwtP^ := ord(next) - 48												else if next in ['A'..'Z'] then													cwtP^ := ord(next) - 65 + 10												else if next in ['a'..'z'] then													cwtP^ := ord(next) - 97 + 10;											end;									until k = numchars;									SaveLinkToChain(wtsetchain, 'from_phylip', false,false);									linknumber[wtSetChain] := EndUserLink(wtSetChain);									DefaultLink[wtSetChain] := linknumber[wtSetChain];								end;							otherwise								;						end;						while NewLineChar(next) do							next := nextchar;					end;			end;{now, to copy the wt and type values into storage}		CopyHandles(chtypH, chstoretypH);		CopyHandles(chwtH, chstorewtH);		mstaxa := Mstvariable;{||||||||||||||| reading the matrix |||||||||||||||||}		halftaxa := numtaxa div 2;		interleave := molecular & CWarning('Are the data in this file separated into several sections (interleaved)?', 'Interleaved', 'Not Interleaved');		LockHandle(TaxstsCHUNKs, oldState1);		firstblock := true;		ic := 0;		SkipToEndOfLine(false);  {3.07}		c := nextchar; {we are now seeking the first character of the first taxon name}		if NewLineChar(c) then			c := nextchar;		repeat			SetCursID(carabid);			it := 0;			TaxstsHdlPtr := HdlPtr(GetMaster(TaxstsCHUNKs));			blockstart := ic;			while it < numtaxa do				begin					UpdateThermo(iothermo, 0, fpos, mcFileLength,true);					if abortedthermo then						begin							errorFlag := true;							Exit(ReadPhylipData);						end;					if it = halftaxa then						SetCursID(salticid);					TaxStsHdl := TaxstsHdlPtr^;					LockHandle(TaxstsHdl, oldState2);					ic := blockstart;					if firstblock then						SetP := Ptr(GetMaster(TaxStsHdl) + tcb * ord4(ic))					else						SetP := Ptr(GetMaster(TaxStsHdl) + tcb * ord4(ic));					it := it + 1;					if firstblock then 		{ need to read in taxon names}						begin							ds := '          ';							ds[1] := c;							for j := 2 to 10 do								begin									c := nextchar;									ds[j] := c;								end;							StripBlanks(ds);							while length(ds) > 0 do								if ds[1] = ' ' then									delete(ds, 1, 1)								else									leave;							UnderLineToBlanks(ds);							SetTaxonName(it, ds);							repeat								c := nextchar;							until not (c in whitespace) or (fpos > mcFileLength);						end;{repeat c := nextchar; until (c = char(13)) or not (c in whitespace);}					while (ic < numchars) do						begin							ic := ic + 1;							if not matchcharon & (c = '.') & molecular then								begin									matchcharon := true;									matchchar := '.';								end;							if (datatype = DNA) & ((c = 'u') | (c = 'U')) then   {convert to RNA file}								begin									datatype := RNA;									symbols[4] := 'U';								end;							if (c in ['?']) then								tsts := [MSl]							else if (c = '-') then								tsts := [MSl, GAl]							else if datatype = standard then								if c in ['B', 'P', 'b', 'p'] then									tsts := [0, 1]								else									begin										ist := ord(c) - 48;										if (ist < 0) or (ist > maxstbit) then											begin												errorflag := true;												goto 1;											end										else											tsts := [ist];									end							else if nucleotides then								if (c='N') | (c='n') then									tsts := [MSl,SSl]								else									begin										tsts := DNARNASetOfChar(c, true, 1, it, ic);										if IsAlternativeSymbolChar(c) then											tsts := tsts + [SSl];									end							else if datatype = protein then								tsts := ProteinSetOfChar(c, true, 1, it, ic);							TransferStatesFromLargest(SetP, tsts);							SetP := Ptr(ord4(SetP) + tcb);{if ic = numchars then c := nextchar else }							repeat								c := nextchar;							until (fpos >= mcFileLength) | NewLineChar(c) | not (c in whitespace);							if NewLineChar(c) then								begin									if interleave and (not firstblock or (it = numtaxa)) then										repeat											c := nextchar;										until (fpos >= mcFileLength) | not (c in whitespace)									else										begin											c := nextchar;											if NewLineChar(c) then												c := nextchar;										end;									if (ic < numchars) and not interleavelengthMeasured then										begin											interleavelengthMeasured := true;											interleavelength := ic;										end;									leave;		{leave the numchars loop and go to the next taxon}								end;						end;  {numchars loop}2:					ResetHandle(TaxstsHdl, oldState2);					TaxstsHdlPtr := HdlPtr(ord4(TaxstsHdlPtr) + HdlSize);				end;   {numtaxa loop}			firstblock := false;		until (fpos >= mcFileLength) | (ic >= numchars);		ResetHandle(TaxstsCHUNKs, oldState1);		SetCursID(flower);		ReCalcMaxstAndStates(1,numchars);		if usertrees or (phylipversion = 34) then			begin				SetCursID(tree);				next := c;				if fpos >= mcFileLength then					goto 1;				if next in whitespace then					next := nextdarkchar;				if fpos >= mcFileLength then					goto 1;				if next <> '(' then					begin						ds := GetFileToken(maxtok);  {skip over number of trees token}						next := nextdarkchar;						if next = '(' then							ds := '(';					end				else					ds := '(';				if (ds = '(') then					usertrees := true;				if usertrees then					begin						startreadtree := 1;						endreadtree := -1;						ReadForeignTrees(phylip, ds);					end;			end;1:		SetCursorToArrow;		if errorflag then			InstantError(208);	end;{-----------------------------------------------------------------------------}	procedure ReadHennigNonaData (firsttoken: str255; isNona: boolean);		const			unknown = 0;			ccode = 1;			cget = 2;			ckeep = 3;			proced = 4;			quote = 5;			tread = 6;			tchoose = 7;			xread = 8;			dread=9;			cnames=10;		var			command: Str255;			it, ic, k, wt,is: integer;			thecommand: integer;			db: boolean;			c: char;			startpos, endpos: longint;			ist, halftaxa: integer;			tsts: largestsetchars;			ds: str255;			ccodepunct, oldpunct: set of char;			makeactive, makeadditive, makeinactive, makenonadditive, dosetwt: boolean;			setwt, startic, endic, dotpos: integer;			os: OSErr;			amountneeded: longint;			oldState: SignedByte;{...........}		procedure ResetSpecifiers (c: char);		begin			case c of				'*': 					begin						makeactive := false;						makeinactive := false;						makenonadditive := false;						makeadditive := false;						setwt := 1;						dosetwt := false;					end;				'[': 					begin						makeinactive := false;						makeactive := true;					end;				']': 					begin						makeinactive := true;						makeactive := false;					end;				'+': 					begin						makeadditive := true;						makenonadditive := false;					end;				'-': 					begin						makeadditive := false;						makenonadditive := true;					end;				'/': 					begin						dosetwt := true;					end;				otherwise					;			end;		end;{...........}		procedure SetCCodeValues (startic, endic: integer);			var				ic: integer;		begin			for ic := startic to endic do				if (ic >= 1) and (ic <= numchars) then					begin						if dosetwt then							begin								SetWeight(ic, setwt);								UseToWtStorage(ic);							end;						if (makeactive and not CharIncluded(ic)) or (makeinactive and CharIncluded(ic)) then							SwitchIncExc(ic);						if makeadditive then							begin								SetType(ic, ordered);								UseToTypeStorage(ic);							end						else if makenonadditive then							begin								SetType(ic, unordered);								UseToTypeStorage(ic);							end;					end;		end;{...........}	begin		SetCursor(clockCursor);		oldpunct := punctuation;		ccodepunct := ['[', ']', '/', '-', '+', '*', ';'];		punctuation := [';'];		deftype := ordered;		if (firsttoken <> 'XREAD') & (firsttoken <> 'DREAD') then  			begin				repeat					command := MakeCaps(GetFileToken(maxtok));				until (command = 'XREAD')| (command='DREAD')|(fpos >= mcFileLength);				db := fpos < mcFileLength;			end		else			db := true;		if db then	{file with DATA block}			begin				fpos := kInitialReadPos;				repeat					repeat						command := MakeCaps(GetFileToken(maxtok));						theCommand := unknown;						if (command='') then							thecommand := unknown						else if command[1] = 'P' then							thecommand := proced						else if command[1] = 'Q' then							thecommand := quote						else if command[1] = 'C' then							begin								if command[2] = 'C' then									thecommand := ccode								else if command[2] = 'G' then									thecommand := cget								else if command[2] = 'K' then									thecommand := ckeep								else if (command[2] = 'N')  then									thecommand := cnames							end						else if (command[1] = 'T') then							begin								if command[2] = 'R' then									thecommand := tread								else if command[2] = 'C' then									thecommand := tchoose							end						else if (command[1] = 'X') & (command[2] = 'R') then							thecommand := xread						else if (command[1] = 'D') & (command[2] = 'R') then							thecommand := dread;						if theCommand=unknown then							Skipper([';'], true);					until (thecommand <> unknown) or (fpos >= mcFileLength);{v4: pay attention to ckeep, cget, tchoose, etc.}					case thecommand of						ccode: 							begin								punctuation := ccodepunct + [','];								ResetSpecifiers('*');								repeat									ds := GetFileToken(maxtok);									if ds[1] = ';' then										leave									else if ds[1] in ccodepunct then										begin											if ds[1] = '/' then												begin													if next in ['0'..'9'] then														begin															setwt := TokenToInteger(GetFileToken(maxtok), true);															if setwt > MaxWtInt then																begin																	setwt := MaxWtInt;																	NewError(21, 0);																end;														end													else														setwt := 1;													ResetSpecifiers('/')												end											else												ResetSpecifiers(ds[1])										end									else if ds <> ',' then										begin		{we've presumably got the start of a scope}											dotpos := pos('.', ds);											if dotpos = 0 then												begin													startic := TokenToInteger(ds, true);													endic := startic;												end											else if dotpos = 1 then												begin													startic := 0;													if length(ds) = 1 then														endic := numchars - 1													else														begin															delete(ds, 1, 1);															endic := TokenToInteger(ds, true);														end;												end											else if dotpos = length(ds) then												begin													endic := numchars - 1;													delete(ds, length(ds), 1);													startic := TokenToInteger(ds, true);												end											else		{ . is in middle}												begin													startic := TokenToInteger(CopyString(ds, 1, dotpos - 1), true);													endic := TokenToInteger(CopyString(ds, dotpos + 1, length(ds) - dotpos), true);												end;											startic := startic + 1;											endic := endic + 1;											SetCCodeValues(startic, endic);										end;								until (ds = ';') | (fpos >= mcFileLength) | errorflag;								punctuation := [';'];							end;						proced: 							begin								if command[length(command)] = '/' then									fpos := mcFileLength;							end;						quote: 							begin								startpos := fpos;								Skipper([';'], false);								endpos := fpos;								if startpos <> endpos then									begin										AppendToHandle(textWindowInfo[AboutFileText]^.H, chr(13));										FilePieceToH(startpos, endpos, storeH);										os := HandAndHand(storeH, textWindowInfo[AboutFileText]^.H);									end;								next := nextchar;							end;						tread: 							begin								SetCursID(tree);								startreadtree := 1;								endreadtree := -1;								ReadForeignTrees(hennig, 'TREAD');							end;													cnames:							begin								punctuation := ['{',';'];								ic := 0;								repeat									ds := GetFileToken(maxtok);									if ds[1] = ';' then										leave									else if ds[1] = '{' then										begin											ds := MakeCaps(GetFileToken(maxtok));											if ds ='+' then ic := ic+1											else ic := TokenToInteger(ds, true)+1;											if (ic>0) & (ic<=numchars) then												begin													ds := GetFileToken(maxtok);													if ds <> '_' then SetCharName(ic,ds);													AddDotsToStateNames(ic);													is := 0;													repeat														ds := GetFileToken(maxtok);														if (ds <> ';') & (ds <> '_') then SetCharStateName(ic,is,ds);														is := is+1;													until (ds=';')| (fpos>= mcFileLength);												end;										end;								until (fpos>= mcFileLength);								punctuation := [';'];							end;						xread, dread: 							begin								SetCursID(amoeba);								if theCommand=dread then {need to get gap and missing}									begin										ds := MakeCaps(GetFileToken(maxtok));										if ds <> 'GAP' then											begin												errorflag := true;												NewError(418,0);												Exit(ReadHennigNonaData);											end;										next := anynextdarkchar;  {? if treat gap as missing, or ; if treat as fifth base}										gap := '-';										next := anynextdarkchar;										ds := MakeCaps(GetFileToken(maxtok));										if ds <> 'MATCH' then											begin												errorflag := true;												NewError(418,0);												Exit(ReadHennigNonaData);											end;										next := anynextdarkchar;  {matchchar}										matchchar := next;										matchcharon := true;									end;																next := anynextdarkchar;								if next = '''' then									begin										startpos := fpos + 1;										if FindRawFileChar('''', true) then											begin												endpos := fpos;												if startpos <> endpos then													begin														AppendToHandle(textWindowInfo[AboutFileText]^.H, chr(13));														FilePieceToH(startpos, endpos, storeH);														os := HandAndHand(storeH, textWindowInfo[AboutFileText]^.H);													end;												next := anynextdarkchar;											end;									end;								ds := GetFileToken(maxtok);								numchars := TokenToInteger(ds, true);								numtaxa := TokenToInteger(GetFileToken(maxtok), true);								if (numchars < 1) | (numtaxa < 1) then									errorflag := true;								if errorflag then									begin										NewError(418,0);										Exit(ReadHennigNonaData);									end;								if not EnoughMemory(FullMemoryNeeded(numtaxa, numchars), amountneeded) then									begin										InstantErrorPlus(268, concat(StringFromNum(amountneeded div 1024), 'K'));										errorflag := true;										Exit(ReadHennigNonaData);									end;								if not CreateTaxonCharMemory then									begin										CleanUpFailedTaxonCharacterMemory;										Exit(ReadHennigNonaData);									end;								if not errorflag then									begin										if thecommand=dread then											SetDataFormat(DNA, false)										else											SetDataFormat(standard, false);										if isNona then											ReadTextMatrix(true, nona)										else											ReadTextMatrix(true, hennig);										if not errorflag & nucleotides then											onOpenFileSetAsPlainMolecularStyle := true;									end;							end;						otherwise							Skipper([';'], true);					end;				until (fpos >= mcFileLength) or errorflag;			end  {file with DATA block}		else	{this file has no DATA block}			begin				fpos := kInitialReadPos;  {was 0}				if FindFileToken('TREAD', false) then {this is a treefile}					begin {mark as treefile}						InstantError(209);					end				else					begin						InstantError(301);					end;				errorflag := true;			end;		punctuation := oldpunct;		SetCursorToArrow;		if GetHandleSize(textWindowInfo[AboutFileText]^.H) > 0 then			begin				LockHandle(textWindowInfo[AboutFileText]^.H,oldState);				TESetText(textWindowInfo[AboutFileText]^.H^, GetHandleSize(textWindowInfo[AboutFileText]^.H), textWindowInfo[aboutFileText]^.TE);				ResetHandle(textWindowInfo[AboutFileText]^.H,oldState);				TECalText(textWindowInfo[aboutFileText]^.TE);			end;	end;end.