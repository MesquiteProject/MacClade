unit Equivocal;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  UtilLibInterface, SetLibInterface,   		MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, 		BoxUtil, TaxonCHUtil, CharUtil, TreeUtil, TypeUtil, Dollo, Prohibitions, 		MenuUtil, Legends, Coloring,Count, Polycalc, CalcUtil, Calc, 		Genchar, TraceControl,Thermos,fp,MPR;	procedure StartEquivCycle;	procedure NextResolutionInCycle;	procedure GoToResolutionNumber (resno: longint);	procedure StopEquivCycle;	procedure Equiv_MakeFirstResolution (baseR: Nptr; ic: integer; traced: boolean);	function Equiv_NextResInClade (N, baseR: Nptr; ic: integer; ctype: integer; traced: boolean): boolean;	procedure Equiv_RestoreSts (N: Nptr; ic: integer; traced: boolean);	procedure Equiv_TransferRestoSts (N: Nptr; ic: integer; traced: boolean);	function checkifcontinueaBit: boolean;		procedure NChangesInCharOld (var minch, maxch, minRestch, maxRestch: integer; ic: integer; traced: boolean; var aborted: boolean);	procedure NChangesInChar (var minch, maxch, minRestch, maxRestch: integer; ic: integer; traced: boolean; var aborted: boolean);	procedure NChangesInCharDual (var minch, maxch, minRestch, maxRestch: integer; ic: integer; traced: boolean; var aborted: boolean);	procedure CountTotalTreeChanges;	function NumberofResolutionsOld (N: Nptr; ic: integer; traced,storeEquivocal: boolean): longint;	function NumberOfResolutionsDual (N: Nptr; ic: integer; traced,storeEquivocal: boolean; var useDouble: boolean; var res: double): longint;{еееееееееееееееееееееее}implementation {е$S Equivocal}	const		highest = true;		lowest = false;{-----------------------------------------------------------------------------}	function GetOriginal (it: integer): lgsetchars;	begin		GetOriginal := gettaxonHdl(it)^^.N^.original;	end;{-----------------------------------------------------------------------------}{######  EQUIVOCAL CYCLING FOR ALL POSSIBLE RESOLUTIONS OF TRACE  ###########}{This unit deals with procedures which resolve equivocal character tracings, giving}{one resolution after another in sequence.  These procedures are used in user-demanded}{equivocal cycling on the traced character (for the user to see all possible resolutions),}{and for various procedures in which fully resolved traces are needed and variation}{among the resolutions examined.  Thus they are used in the Trace All changes: in certain}{cases for the maximum number of changes on a branch, all resolutions are examined to find}{which allows most change; in the charts: in min/max or mean for Changes and stasis chart }{all resolutions are examined to see for each numbers of particular sorts of changes; in }{changes option of Char. Steps etc. chart to show numbers of changes; in Other Calc. show}{numbers of changes in tree.}{-----------------------------------------------------------------------------}{Fields of node record:}{in original is stored final sts naturally calculated}{in resolved is stored current sts resolved}{in dnequiv is stored downstates naturally calculated}{NOTE: storage of state sets in equivocal cycling is not largestsetchars, as in the}{rest of MacClade.  Here we avoid Pascal sets and use type lgsetchars, which is just a 4-byte}{pointer (a pointer was used instead of longint only to generate compiler errors if any +-*/ were found).  These}{lgsetchars cannot be operated on as other sets, thus special procedures Union2, Intersect2,}{Union3, etc. are designed for unions and intersection.  EnSet returns true if the given integer}{is an element of the given set.}{NewSetFromOld and OldSetFromNew convert between lgsetchars and largestsetchars,}{NOTE that there is duplication in code between here and the Calc units, because of the use of the lgsetchars}{type for speed here.  When the entire program is converted to lgsetchars, then duplication will not be needed}{PROHIBITIONS: equivocal cycling is not allowed when the clade has fixanced taxa or polytomies,}{or when acctran or deltran are active, or with fisher (stratigraphic characters)}{ Equivocal cycling is R based for:}{NumChangesInChar, TraceAllChangesCalc, ChartWchangesCalc, ConsistencyCheck}{but is ScreenR based for:}{StartEquivCycle, GoToResolutionNumber, NumberofResolutions, LaserPrint all in cycle}{-----------------------------------------------------------------------------}	procedure FirstResInClade (pN, baseR: Nptr; ic: integer; traced: boolean);{FROZEN 3.0}{Finds the first resolution in the clade and places it in the resolved's of the nodes.}{The first resolution is defined basically that which has the lowest states}{at each node, but remember that this is the lowest state that is parsimonious given}{what has already been chosen at its ancestor. Thus you start at pN and recurse up}{the tree, at each node recalculating the final state set according to the ancestor's}{chosen state and the downstate sets of the two descendants, then choosing the}{lowest state in the new final state set.}{This procedure contains a recursive procedure, inFirstRes, which goes up the tree}{using the old final states (original), the old downstates (dnequiv), and the current resolved states (resolved)}{to set the new resolved state set (resolved).}		var			olduniqueresolution: boolean;			ctype: integer;{.....................}		procedure inFirstRes (N: Nptr);		begin			if NodeIsInternal(N) then {internal node}				begin					if (MonomorphG(N^.original)) then {state fixed or only one, so just assign state}						N^.resolved := N^.original {assumes fixsts will only have one state - this may change}					else						begin							uniqueresolution := false; {recording that at least one equivocal area}							if N = baseR then  {at the root - ignore below, so just take minimum in original final set}								N^.resolved := SetfromMin(N^.original)			{recalculate best set at N given N^.anc^.resolved, and choose minimum value in it for resolved state}							else if ctype < dollo then  {type is unord, ord, irrev}								N^.resolved := SetfromMin(TripleCombEquiv(N^.lf^.dnequiv, N^.rt^.dnequiv, N^.anc^.resolved, ctype))							else if ctype = dollo then  {type is dollo}								N^.resolved := SetfromMin(NewSetFromOld(FinalCombineDollo(OldSetFromNew(N^.lf^.dnequiv), OldSetFromNew(N^.rt^.dnequiv), OldSetFromNew(N^.dnequiv), OldSetFromNew(N^.anc^.resolved), N = R, ic)))							else  {user-defined type}								N^.resolved := SetfromMin(GenTripleCombEquiv(N^.gdnst, N^.original, MinG(N^.anc^.resolved), ctype));						end;					inFirstRes(N^.lf);					inFirstRes(N^.rt);				end			else  {terminal node}				begin{for terminal nodes, node in equivocal cycling treated just like most recent common ancestor of}{components of terminal taxa.}					if (MonomorphG(N^.original)) then {node has just one state (possibly fixed), just assign state}						N^.resolved := N^.original					else						begin			{terminal taxon with equivocal states}							uniqueresolution := false; {recording that at least one equivocal area}							if ctype = unordered then {recalc best states based on ancestral resolved, then take minimum}								N^.resolved := SetFromMIN(TerminalUnordEquiv(N, ic,N^.anc^.resolved))							else if ctype < usedef then  {if ord/irrev/fisher/dollo assign closest to resolved below; will be single state}								N^.resolved := TerminalOrdEquiv(N^.original, N^.anc^.resolved)							else   {user defined character}				{First readjust state set of N using current ancstates using GenTripleCombEquiv}				{then take the lowest value in resulting set.}								N^.resolved := SetFromMin(GenTripleCombEquiv(N^.gdnst, N^.original, MinG(N^.anc^.resolved), ctype));						end;				end;			if ctype = fisher then				begin					N^.resolved := nil;					uniqueresolution := true;					NewError(370, ic);  {posting error that calcs not done for fisher chars}				end;		end;{.....................}	begin  {main part of FirstResInClade}		ctype := typeofchar(ic);		if ctype >= usedef then			begin				typehdl := getTypeHdl(ctype);				ddist := TypeHdl^^.dist; {getting type matrix}			end;{uniqueresolution stores whether all states at nodes are singletons; if so then cycling need not}{go through second cycling, i.e. cycling aborts after inFirstRes}		olduniqueresolution := uniqueresolution;		uniqueresolution := true;		inFirstRes(pN);{The following is asked because only want uniqueresolution calculated for the first time FirstResInClade is called, for whole tree.}		if pN <> baseR then			uniqueresolution := olduniqueresolution;		if not traced & (pN = baseR) & ((traceshown = traceAllChanges) & ((branchlistmode = minmaxmode) | (branchlistmode = maxmode))) then{FROZEN 3.0}			golist := golist + [brchangesall];  {put here just in case wipes out FTl bit indicating max changes}	end;{-----------------------------------------------------------------------------}	function Equiv_NextResInClade (N, baseR: Nptr; ic: integer; ctype: integer; traced: boolean): boolean;{FROZEN 3.0}{Finds the next resolution and places the reconstruction in the resolved's of the nodes}{final, sts are not modified here but in Equiv_TransferRestoSts}		var			IsitHighest: boolean;			curstate: integer;			ststemp: lgsetchars;{.......................}		procedure bumpUpNsState (source: lgsetchars);{FROZEN 3.0}{This procedure examines the current state at N (N^.resolved) and compares it}{to the source set.  If the current state is already the highest value in the source,}{it cannot be bumped up any higher and IsitHighest is set to highest.  If the current}{state can be bumped up, it is bumped up to next higher value in source. }			label				123;			var				ir: integer;		begin			curstate := MinG(N^.resolved);			if curstate >= MaxG(source) then				IsitHighest := highest			else				begin					for ir := curstate + 1 to MaxG(source) do						begin							if Enset(ir, source) then								begin									N^.resolved := MakeSet(ir);									goto 123;								end;						end;123:{ Now that the state has been bumped up, }{the resolution above N must be reset to its first given given the new state at N}					if NodeIsInternal(N) then						begin							FirstResInClade(N^.lf, baseR, ic, traced);							FirstResInClade(N^.rt, baseR, ic, traced);						end;				end;		end;{.......................}	begin		IsitHighest := lowest;		if NodeIsInternal(N) then  {internal node}			begin{check if all above on left are at highest values; this function bumps up to next if not yet at highest; }				if Equiv_NextResInClade(N^.lf, baseR, ic, ctype, traced) = highest then					begin{check if all above on right are at highest values; this function bumps up to next if not yet at highest}						if Equiv_NextResInClade(N^.rt, baseR, ic, ctype, traced) = highest then{if so then both left and right at highest given assignment to N; thus bump up}{assignment to N.  If successfully bumped then take first res. above this bumped N}{and leave isitHighest at false; else if can't bump higher then return that clade is at highest}							begin								if MonomorphG(N^.original) then									begin										IsitHighest := highest;										N^.resolved := N^.original;									end								else if (N = baseR) then  {if root of cycling,then bump up using original as source}{Note: could condense code with FirstResInClade here}									BumpUpNsState(N^.original)								else if ctype < dollo then {otherwise reconsider based on N^.anc^.resolved}									BumpUpNsState(TripleCombEquiv(N^.lf^.dnequiv, N^.rt^.dnequiv, N^.anc^.resolved, ctype))								else if ctype = dollo then									BumpUpNsState(NewSetFromOld(FinalCombineDollo(OldSetFromNew(N^.lf^.dnequiv), OldSetFromNew(N^.rt^.dnequiv), OldSetFromNew(N^.dnequiv), OldSetFromNew(N^.anc^.resolved), N = R, ic)))								else									BumpUpNsState(GenTripleCombEquiv(N^.gdnst, N^.original, MinG(N^.anc^.resolved), ctype));							end						else{else if right wasn't at highest value it would have been bumped up by one within the}{Equiv_NextResInClade(N^.rt) call, so reset left back to lowest}							begin								IsitHighest := lowest;								FirstResInClade(N^.lf, baseR, ic, traced);							end;					end;{else if left wasn't at highest value it would have been bumped up by one within the}{Equiv_NextResInClade(N^.lf) call}			end		else		  {terminal node}			begin				if MonomorphG(N^.original) then {terminal has only one possible state; thus no need to bump up}					begin						isithighest := highest;						N^.resolved := N^.original					end				else if Qtaxon(N, ic) then {terminal missing; use ancestor's state directly}					begin						isithighest := highest;						N^.resolved := N^.anc^.resolved					end				else if cardG(N^.original) > 1 then {terminal polymorphic or uncertain; assign best state}					begin						if ctype = unordered then							begin				{ bump up state to next highest; if already highest bumpupnsstate will set isithighest to highest}								bumpUpNsState(TerminalUnordEquiv(N, ic,N^.anc^.resolved));							end						else if ctype < usedef then  {ordered, irrev, fisher, dollo}							begin								isithighest := highest;  {with ordered types it's guaranteed that only one state will be best with ancestor}								N^.resolved := TerminalOrdEquiv(N^.original, N^.anc^.resolved);							end						else							begin {user-defined type - first find best states given ancestor}								ststemp := GenTripleCombEquiv(N^.gdnst, N^.original, MinG(N^.anc^.resolved), ctype);								if MonomorphG(ststemp) then {only one best state; thus use it}									begin										isithighest := highest;										N^.resolved := ststemp;									end								else {more than one best state; bump up to next higher}									bumpUpNsState(ststemp);							end;					end;			end;		Equiv_NextResInClade := isithighest;	end;{-----------------------------------------------------------------------------}	procedure Equiv_TransferRestoSts (N: Nptr; ic: integer; traced: boolean);{FROZEN 3.0}{transfers the result of resolution from resolved to the sts for painting on branches}	begin		if traced then			N^.final := OldSetFromNew(N^.resolved)		else			SetStsLargest(N, ic, OldSetFromNew(N^.resolved));		if NodeIsInternal(N) then			begin				Equiv_TransferRestoSts(N^.lf, ic, traced);				Equiv_TransferRestoSts(N^.rt, ic, traced);			end;	end;{-----------------------------------------------------------------------------}	procedure Equiv_MakeFirstResolution (baseR: Nptr; ic: integer; traced: boolean);{FROZEN 3.0}{this makes the first resolution given that a character is already reconstructed}{Used in various places}	begin		if typeofchar(ic) >= usedef then  {need to call downpass to restore gdnsts needed for equiv cycling}			GenDownPass(baseR, ic, traced);		Savests(baseR, ic, traced); {save original and dnequiv}		FirstResInClade(baseR, baseR, ic, traced);{do error check; remember equivocal cycling not allowed with polytomies or fixanced}		if BaseR = R then			begin				if nullson then					NewError(8, 0)				else if ancon then					NewError(7, 0);			end		else if AnyFixanc(baseR) then {Note that equivocal cycling can be done if polytomies below screenR}			NewError(7, 0);		if Anynulls(baseR) then			NewError(8, 0);	end;{-----------------------------------------------------------------------------}	procedure StartEquivCycle;{begins user-visible equivocal cycling (not called for automatic equivocal cycling in, e.g., charts)}		var			doequiv: boolean;	begin		doequiv := true;{equiv cycling prohibited if nulls, fixed ancestors, or acctran/deltran}		if anynulls(screenR) then			begin				InstantError(146);				equivcycle := false;				doequiv := false;			end		else if AnyFixanc(screenR) then			begin				InstantError(147);				equivcycle := false;				doequiv := false;			end		else if (resolveoption <> allpossible) then			begin				InstantError(148);				equivcycle := false;				doequiv := false;			end;{$IFC FALSE}		if doequiv & charton then			if CWarning('Chart will be forced closed.  Do you want to continue with Equivocal Cycling?', 'Continue', 'Cancel') then				PleaseOffChart := true			else				begin					equivcycle := false;					doequiv := false;				end;{$ENDC}		if doequiv then			begin				equivcycle := true;				SetEquivMBar;				DrawMenuBar;				myDisableItem(FileMHdl, PrintOtherItem);				myDisableItem(EditMHdl, ContinuousEditItem);				{myDisableItem(CharactersMHdl, xxxxEvolveCharacterItem);}				myDisableItem(EditMHdl, UndoItem);				genericSetPort(tlegwindow);{v4:  this does not do a getportsetport; is this ok because equiv cycling is modal?}{what about other programs doing background processing to update their windows?}				DoDeactivateControl(tlegScroll);				DrawControls(tlegwindow);				if toolPaletteOpen[treeTools] then					begin						myHideWindow(toolPaletteWindow[treeTools]);						toolPaletteWasOpen[treeTools] := true;						toolPaletteOpen[treeTools] := false;					end;				genericSetPort(treewindow);				Equiv_MakeFirstResolution(screenR, i, tracedtrue);				Equiv_TransferRestoSts(screenR, i, tracedtrue);				equivcyclenum := 1;				TWMessage := concat('MPR number 1.');				WriteTWMessageB;			end;	end;{-----------------------------------------------------------------------------}	procedure StopEquivCycle;{Frozen 3.0}{stops on-screen equivocal cycling}		var			tport: windowptr;	begin		genericGetPort(Tport);		equivcycle := false;		SetTWMBar;		InsertMenu(TypeMHdl, -1);		ReBuildAssumpMenu;		DrawMenuBar;		myEnableItem(FileMHdl, PrintOtherItem);		myEnableItem(EditMHdl, ContinuousEditItem);		EnableDisableItem(CharactersMHdl, xxxxEvolveCharacterItem, nodes & fileopen & not equivcycle & treeopen & not nullson & not ancon & not Locked(lockData));		myEnableItem(EditMHdl, UndoItem);		genericSetPort(tlegwindow);		DoActivateControl(tlegScroll);		DrawControls(tlegwindow);		twmessage := '';		WriteTWMessageB;		if toolPaletteWasOpen[treeTools] then			begin				toolPaletteOpen[treeTools] := true;				toolPaletteWasOpen[treeTools] := false;				myShowWindow(toolPaletteWindow[treeTools]);			end;		Equiv_RestoreSts(screenR, i, true);{FROZEN 3.0}		golist := golist + [reconstructi];  {after equivocal cycling, call to recalculate i based things;}		{charts based on i not updated since their memory not changed by equivcycling}		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	procedure NextResolutionInCycle;{FROZEN 3.0}{{For On-screen equivocal cycling, this goes to next resolution}		var			tport: WindowPtr;	begin		if (uniqueresolution) | (Equiv_NextResInClade(screenR, screenR, i, typeofchar(i), true) = highest) then			StopEquivCycle		else			begin {note that Equiv_NextResInClade above not only checks if already highest, but bumps to highest if it is not}				Equiv_TransferRestoSts(screenR, i, true);				genericGetPort(tport);				genericSetPort(treewindow);				SetClip(TWClip);				SetMaxGrayScale;				if showtracelabels | (fixon & showfix) then					godraw := true				else					ColorTree(ScreenR,false);				if not WindowVisible(chlegwindow) then					DrawCHLeg;				genericSetPort(tport);				equivcycleNum := equivcyclenum + 1;				TWMessage := concat('MPR number ', StringFromNum(equivcyclenum), '.');				WriteTWMessageB;			end;	end;{-----------------------------------------------------------------------------}	procedure Equiv_RestoreSts (N: Nptr; ic: integer; traced: boolean);{FROZEN 3.0}{This restores N^.final or N^.stsH if they have been altered by equivocal cycling}{In fact the only one that currently could be altered would be N^.final and then only}{for on-screen equivocal cycling or for print all equivocal resolutions}	begin		if traced then			N^.final := OldSetFromNew(N^.original)		else			SetStsLargest(N, ic, OldSetFromNew(N^.original));		if NodeIsInternal(N) then			begin				Equiv_RestoreSts(N^.lf, ic, traced);				Equiv_RestoreSts(N^.rt, ic, traced);			end;	end;{-----------------------------------------------------------------------------}	procedure NChangesInCharOld (var minch, maxch, minRestch, maxRestch: integer; ic: integer; traced: boolean; var aborted: boolean);{FROZEN 3.0}{Calculates the number of changes, from minimum to maximum, in character.}{Uses equivocal cycling to check all resolutions}{assumes already reconstructed}		label			1;		var			ctyp: integer;			 nthis, nRestThis: integer;			numRes: longint;{.............}		procedure CountNumChanges (N: Nptr);		begin			if (N^.resolved <> N^.anc^.resolved) then				begin					nthis := nthis + 1;					if calcRestChanges & (not changesRestricted | (changesSel^[MinG(N^.anc^.resolved), MinG(N^.resolved)])) then						nRestthis := nRestthis + 1;				end;			if NodeIsInternal(N) then				begin					CountNumChanges(N^.lf);					CountNumChanges(N^.rt);				end;		end;{.............}	begin		numRes := 0;		aborted := false;		minch := maxint;		maxch := 0;		if calcRestChanges then			begin				minRestch := maxint;				maxRestch := 0;			end		else			begin				minRestch := 0;				maxRestch := 0;			end;		ctyp := typeofchar(ic);		if charConstant(ic) then			begin				minch := 0;				maxch := 0;				if calcRestChanges then					begin						minRestch := 0;						maxRestch := 0;					end;			end		else if (ctyp = unordered) & not MSTaxaInCharTree(ic) & (not calcRestChanges | not changesRestricted) then			begin				nthis := CharSteps(ic);				maxch := nthis;				minch := nthis;				if calcRestChanges then					begin						minRestch := nthis;						maxRestch := nthis;					end;			end		else			begin				Equiv_MakeFirstResolution(R, ic, traced); {make first resolution}				if ErrorPosted(8) or ErrorPosted(7) then					begin						aborted := true;						goto 1;					end;				equivocalCycleCalculation := true;				repeat					if numRes = maxLongint then						begin							NewError(443,ic);							leave;						end;					numRes := numRes + 1;					if (numRes mod cancelCheckFreq = 0) & CommandPeriod then						begin							aborted := not chartbeingcalculated | (not checkifcontinueabit);							if aborted then								goto 1							else								abortedThermo := false;						end;(*					if (numRes mod cancelCheckFreq = 0) & ThermoWasAborted(theDialog) then						begin							aborted := not chartbeingcalculated | (not checkifcontinueabit);							if aborted then								goto 1							else								abortedThermo := false;						end;*)											if numRes mod 10 = 0 then						EquivocalCursor(True);					nthis := 0;					nRestThis := 0;					if NodeIsInternal(R) then {count how many changes}						begin							CountNumChanges(R^.lf);							CountNumChanges(R^.rt);						end;					if nthis > maxch then {see if number of changes more or less than max or min so far found}						maxch := nthis;					if nthis < minch then						minch := nthis;					if calcRestChanges then						begin							if nRestthis > maxRestch then {see if number of changes more or less than max or min so far found}								maxRestch := nRestthis;							if nRestthis < minRestch then								minRestch := nRestthis;						end;				until (uniqueresolution) | (Equiv_NextResInClade(R, R, ic, ctyp, traced) = highest); {go to nextresolution unless unique}1:				equivocalCycleCalculation := false;			end;	end;{-----------------------------------------------------------------------------}	procedure FullNumberChangesFast (var minch, maxch, minRestch, maxRestch: integer; ic: integer; traced: boolean);{DRM method:  uses the same principle as user-defined types}		var			ir, ij, cardTstsOld: longint;			ctyp: integer;			{hiddenDLOG: DialogPtr;}			tempP: WindowPtr;			tstsLeft, tstsRight,tsts: lgsetchars;			tstsOld : largestsetchars;			leftRes, rightRes: longint;			minleft,maxLeft,minRight,maxRight: longint;{...............................}		procedure NumberChangesAbove (N: Nptr); 			var				iUp, ik: integer;		begin			if NodeIsInternal(N) then				begin					NumberChangesAbove(N^.lf);					NumberChangesAbove(N^.rt);					for ik := 0 to maxstate do						begin							{N^.MPR1[ik] := 0;							N^.MPR2[ik] := 0;							N^.MPR3[ik] := 0;							N^.MPR4[ik] := 0;}							if EnSet(ik, N^.original) then  {ik is in the MPR set of N}								begin									if MonomorphG(N^.original) then										begin											tstsLeft := OriginalNodeAssignment(N^.lf,ik,ic);											tstsRight := OriginalNodeAssignment(N^.rt,ik,ic);										end									else										begin											tstsLeft := CalcDescendentPolymStates(N^.lf, ik, ic, ctyp);											tstsRight := CalcDescendentPolymStates(N^.rt, ik, ic, ctyp);										end;{we now know that if ik is the state at node N, then the left and right descendent states are tstsLeft & tstsRight}									CalcMinMaxMPRStorage(ik,N^.lf^.MPR1,N^.lf^.MPR2,tstsLeft,minLeft,maxLeft,false);  {left descendent}									CalcMinMaxMPRStorage(ik,N^.rt^.MPR1,N^.rt^.MPR2,tstsRight,minRight,maxRight,false);  {right descendent}									N^.MPR1[ik] := minRight + minLeft;									N^.MPR2[ik] := maxRight + maxLeft;									if calcRestChanges then										begin											CalcMinMaxMPRStorage(ik,N^.lf^.MPR3,N^.lf^.MPR4,tstsLeft,minLeft,maxLeft,true);  {left descendent}											CalcMinMaxMPRStorage(ik,N^.rt^.MPR3,N^.rt^.MPR4,tstsRight,minRight,maxRight,true);  {right descendent}											N^.MPR3[ik] := minRight + minLeft;											N^.MPR4[ik] := maxRight + maxLeft;										end;								end;						end;				end			else				begin					 for ik := 0 to maxstate do					 				(*						if EnSet(ik, N^.original) then  {then it is in the MPR set of the node}							begin								tstsOld := GetTaxonStsLargest(N^.name, ic);								cardTstsOld :=  CardLg(tstsOld);								if (ik in tstsOld) then   {the state is in the terminal node's states}									begin										N^.MPR1[ik] := cardTstsOld-1;										N^.MPR2[ik] := cardTstsOld-1;									end								else			{ik is not in the terminal nodes actual states, but it is the reconstructed state - therefore ALL actual states must involve a change}									begin										N^.MPR1[ik] := cardTstsOld;										N^.MPR2[ik] := cardTstsOld;									end							end						else				*)							begin								N^.MPR1[ik] := 0;								N^.MPR2[ik] := 0;								N^.MPR3[ik] := 0;								N^.MPR4[ik] := 0;							end;				end;		end;{...............................}	begin		PrepareForMPRRecursion(ic,traced, ctyp);		NumberChangesAbove(R);		minch := maxint;		maxch := 0;		for ij := 0 to maxstate do			if EnSet(ij, R^.original) then				begin					if minch >R^.MPR1[ij] then 						minch := R^.MPR1[ij];					if maxch <R^.MPR2[ij] then 						maxch := R^.MPR2[ij];				end;		if calcRestChanges then			begin				minRestch := maxint;				maxRestch := 0;				for ij := 0 to maxstate do					if EnSet(ij, R^.original) then						begin							if minRestch >R^.MPR3[ij] then 								minRestch := R^.MPR3[ij];							if maxRestch <R^.MPR4[ij] then 								maxRestch := R^.MPR4[ij];						end;			end;	end;{-----------------------------------------------------------------------------}	procedure NChangesInChar (var minch, maxch, minRestch, maxRestch: integer; ic: integer; traced: boolean; var aborted: boolean);{FROZEN 3.0}{Calculates the number of changes, from minimum to maximum, in character.}{Uses equivocal cycling to check all resolutions}{assumes already reconstructed}		var			ctyp: integer;			 nthis, nRestThis: integer;			numRes: longint;	begin		numRes := 0;		aborted := false;		minch := maxint;		maxch := 0;		if calcRestChanges then			begin				minRestch := maxint;				maxRestch := 0;			end		else			begin				minRestch := 0;				maxRestch := 0;			end;		ctyp := typeofchar(ic);		if charConstant(ic) then			begin				minch := 0;				maxch := 0;				if calcRestChanges then					begin						minRestch := 0;						maxRestch := 0;					end;			end		else if (ctyp = unordered) & not MSTaxaInCharTree(ic) & (not calcRestChanges | not changesRestricted) then			begin				nthis := CharSteps(ic);				maxch := nthis;				minch := nthis;				if calcRestChanges then					begin						minRestch := nthis;						maxRestch := nthis;					end;			end		else			begin				FullNumberChangesFast (minch, maxch, minRestch, maxRestch, ic,traced);			end;	end;{-----------------------------------------------------------------------------}	procedure NChangesInCharDual (var minch, maxch, minRestch, maxRestch: integer; ic: integer; traced: boolean; var aborted: boolean);	var minchOld, maxchOld, minRestchOld, maxRestchOld: integer;	begin		case MPRCalculationsMode of 			MPRDualMode:				begin					NChangesInCharOld(minchOld, maxchOld, minRestchOld, maxRestchOld,ic,tracedfalse,aborted);					if not aborted then NChangesInChar(minch, maxch, minRestch, maxRestch, ic, tracedfalse, aborted);					if (minchOld<>minch) | (maxchOld<>maxch) then						NewError(445,ic)					else if (minRestchOld<>minRestch) | (maxRestchOld<>maxRestch) then						NewError(446,ic);				end;			MPROldMode:				NChangesInCharOld(minch, maxch, minRestch, maxRestch,ic,tracedfalse,aborted);			MPRNewMode:				NChangesInChar(minch, maxch, minRestch, maxRestch, ic, tracedfalse, aborted);			otherwise;		end;	end;{-----------------------------------------------------------------------------}	procedure CountTotalTreeChanges; { this assumes fully reconstructed}{FROZEN 3.0}{Calculates the number of changes, from minimum to maximum, in all characters summed.}{Uses equivocal cycling to check all resolutions}{assumes already reconstructed}		label			1;		var			ic, ctype, minch, maxch, minRestch, maxRestch: integer;			charHdl: chHdl;			aborted: boolean;			theDialog: DialogPtr;			tempP: WindowPtr;			doOld: boolean;	begin		aborted := false;		treechangesMIN := 0;		treechangesMAX := 0;//		theDialog := nil;//		StartThermo(theDialog, tempP, 0, numchars, 'Counting changes in tree', 'characters', false);		for ic := 1 to numchars do			begin				CharHdl := GetChHdl(ic);				charHdl^^.minRestchg := 0;				charHdl^^.maxRestchg := 0;				charHdl^^.minchg := 0;				charHdl^^.maxchg := 0;				ctype := typeofchar(ic);				if ctype = fisher then					NewError(368, ic)				else if ctype <> excluded then					begin//						UpdateThermo(theDialog, 0, ic - 1, numchars,false);						if abortedThermo & (not chartbeingcalculated | (not checkifcontinueabit)) then {v3.01: checking for chart added}							aborted := true						else							NChangesInCharDual(minch, maxch, minRestch, maxRestch,ic,tracedfalse,aborted);						if aborted then							begin								calctreechanges := false;								NewError(365, 0);								ResetGoMask;{v4: use PleaseOffChanges:=true; or design better pleaseoff system}								if charton & (CWChart = CWCSteps) & (CWStepsShow = CWStepsChanges) then									begin										NewError(72, 0);										PleaseOffChart := true;									end;								ResetInfoWindow(charinfo);								CheckCalcMenu;								treechangesMIN := 0;								treechangesMAX := 0;								goto 1;							end;						if calcRestChanges then							begin								charHdl^^.minRestchg := minRestch;								charHdl^^.maxRestchg := maxRestch;							end;						charHdl^^.minchg := minch;						charHdl^^.maxchg := maxch;						treechangesMIN := treechangesmin + minch;						treechangesMAX := treechangesMAX + maxch;					end;			end;//		UpdateThermo(theDialog, 0, numchars, numchars, false);1://		EndThermo(theDialog, tempP, true);		TWmessage := ' ';		writeTWmessageB;	end;{-----------------------------------------------------------------------------}	procedure StoreEquivocalSts(var oldequivNum: longint);	begin		oldequivnum := equivcyclenum;		equivcyclenum := 1;		Equiv_RestoreSts(screenR, i, true);	end;{-----------------------------------------------------------------------------}	procedure RestoreEquivocalSts(oldequivNum: longint);	begin		Equiv_MakeFirstResolution(screenR, i, tracedtrue);		Equiv_TransferRestoSts(screenR, i, tracedtrue);		equivcyclenum := 1;		if oldequivnum <> equivcyclenum then			GoToResolutionNumber(oldequivnum);	end;{-----------------------------------------------------------------------------}	function NumberofResolutionsOld (N: Nptr; ic: integer; traced,storeEquivocal: boolean): longint;{FROZEN 3.0}{Returns number of resolutions of character ic}{Before this char must be reconstructed}		var			ir: longint;			ctyp: integer;			theDialog: DialogPtr;			tempP: WindowPtr;		oldequivnum: longint;	begin		SetCursor(clockCursor);		ctyp := typeofchar(ic);		Equiv_MakeFirstResolution(N, ic, traced);		ir := 0;		StartThermo (theDialog,tempP,0,-1,'Number of MPRs','',false);		if not (ErrorPosted(8) or ErrorPosted(7)) then			repeat				if ir = maxLongint then					begin						NewError(443,ic);						leave;					end;				if (ir mod 50 = 0) then					begin						UpdateThermo (TheDialog,0,ir,-1,false);						if abortedThermo then							begin 								ir := -ir;  {this sends message that calculations incomplete}								leave;							end;					end;				ir := ir + 1;				{if ir < 500 then					begin						if (ir mod 10 = 0) then							begin								TWMessage := StringFromNum(ir);								WriteTWMessageB;							end;					end				else if (ir mod 100 = 0) then					begin						TWMessage := StringFromNum(ir);						WriteTWMessageB;					end;}			until (uniqueresolution) | (Equiv_NextResInClade(N, N, ic, ctyp, traced) = highest);		EndThermo(theDialog,tempP,false);		NumberofResolutionsOld := ir;			end;{-----------------------------------------------------------------------------}	function NumberOfResolutionsDual (N: Nptr; ic: integer; traced,storeEquivocal: boolean; var useDouble: boolean; var res: double): longint;	var dL, dLOld: longint;		oldequivNum: longint;	begin		if storeEquivocal then			StoreEquivocalSts(oldequivNum);		case MPRCalculationsMode of			MPRDualMode:				begin					dLOld := NumberOfResolutionsOld (N,ic,traced,storeEquivocal);					dL := NumberOfResolutions (N,ic,traced,useDouble,res);					if not useDouble & (dLOld<>dL) then						InstantInfo(concat('Number MPRs Unequal: report to David at clade@arizona.edu!; character ',StringFromNum(ic)));					NumberOfResolutionsDual := dL;				end;			MPRNewMode:				NumberOfResolutionsDual := NumberOfResolutions (N,ic,traced,useDouble,res);			MPROldMode:				begin					NumberOfResolutionsDual := NumberOfResolutionsOld (N,ic,traced,storeEquivocal);					useDouble := false;					res := 0.0;				end;			otherwise ;		end;		if storeEquivocal then			RestoreEquivocalSts(oldequivNum);	end;{-----------------------------------------------------------------------------}	procedure GoToResolutionNumber (resno: longint);{FROZEN 3.0}{Places into sts the resno'th resolution}{Only used in equivcyle mode}		var			ir, ctyp: integer;			tport: WindowPtr;	begin		ctyp := typeofchar(i);		if (resno = equivcyclenum) or uniqueresolution then			Exit(GoToResolutionNumber)		else if resno < equivcyclenum then			begin				Equiv_RestoreSts(screenR, i, tracedtrue); {backing up to resolution 1}				FirstResInClade(screenR, screenR, i, tracedtrue);				equivcyclenum := 1;			end;		SetCursor(clockCursor);		if not uniqueresolution then			while (EquivCyclenum < resno) & (not (Equiv_NextResInClade(screenR, screenR, i, ctyp, tracedtrue) = highest)) do				equivcycleNum := equivcyclenum + 1;		Equiv_TransferRestoSts(screenR, i, tracedtrue);		if equivcyclenum <> resno then			NewError(13, 0);		genericGetPort(tport);		genericSetPort(treewindow);		SetClip(TWClip);		SetMaxGrayScale;		if showtracelabels | (fixon & showfix) then			godraw := true		else			ColorTree(ScreenR,false);		if not WindowVisible(chlegwindow) then			DrawCHLeg;		genericSetPort(tport);		TWMessage := concat('MPR number ', StringFromNum(equivcyclenum), '.');		WriteTWMessageB;	end;{-----------------------------------------------------------------------------}	function checkifcontinueaBit: boolean; { used in response to abort of calculations}	begin		checkifcontinueabit := true;		if (CWTRees[CWChart] <> CWCurrentTree) then			checkifcontinueabit := not CheckChartStop(3)		else {if not CWTraced then}			checkifcontinueabit := not CheckChartStop(2)	end;end.