program MacClade;{본본본본본본본본본본본볗{MacClade Source Code}{Copyright David R. Maddison & Wayne P. Maddison 1986-2001}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{David or Wayne Maddison}{본본본본본본본본본본본볗{DRM: 520 621 9781 or 520 327 9274}{WPM: 520 621 1889 or 520 325 5586}{$I-}{본본본본본본본본본본본볗	uses		QuickDraw, AppleTalk, PPCToolBox, Processes, Notification, EPPC, AppleEvents, HandleAppleEvents,  Types, Events, QuickDrawText, 		OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, CharUtil, 		BoxUtil, TaxonChUtil, DoPrint, TypeNewDLOG, ChartToType, Fonts, ChartWWrite, ReadAssumpBlock, 		LaserDLOGDraw, ScrollTree, StartUpUtil, ChartMenu, TreeMakerUtil, Thermos, StatusNotes, EditUtilMenu, 		GeneticCode, GenCloseFile, TypeImport, IncExcTaxa, Recode, LaserDraw, LaserPrint, ReadMatrix, Export, Printing, ChartWUtil, 		ChartWScatter, ChartWHisto, ChartWText, TreeMaker, BranchListWindow, TreeRandomData, RandomTree, Continuous, 		ProbReconstruct, Fill, CalcTraced, MenuUtil, Prohibitions, 		CHUNK, SetStates, ReadTreeFile, LinkUtil, Legends, DrawSpread, RowColumn, StatesWindow, copyPaste, EditControl, Activates, 		PolyCalc, Calc, Coloring, TraceControl, Equivocal, GenChar, N7on, TreeDrawer, Footnote, Count, UndoTree, Swap, TraceAllChangesCalc, 		MCWindows, CharCorrelation, ChartWCalc, ChartWindow, TreeGet, PrintSpreadsheet, LaserTree, Settings, ReadData, ImpOldMacClade, 		WriteData, GenOpenFile, CharStateTree, TypeDLOG, TreeUtil, ReadWriteUtil, ReadUtil, ReadMisc,WriteUtil, Shading, ClickInInfoWindow, 		InfoWindows, Statsmenu, MouseInTree, Speak, TreeMenu, ProcessMenu, Startup, MCEvents, Cursor, Quit,Flash;		{본본본본본본본본본본본볗	label		86, 345, 87;			var    		theGrowZoneUPP: UniversalProcPtr;		recalcChartwindow, aborted, db: boolean;		d1, d2: longint;		oldrealtypes, oldrealwts: boolean;		oldtaxonHeight: integer;		eventMask: integer;		oldControl:boolean;		moreWindowsToOpen: boolean;		os: OSStatus;						{-----------------------------------------------------------------------------}	function myGrowZone (cbNeeded: Size): longint;		var			H: Handle;			curgrowsize: longint;	begin		H := GZSaveHnd;		HLock(H);		curgrowsize := GetHandleSize(growH);		if curgrowsize = 0 then			begin				InstantInfo('Not enough memory. Bye!');				myGrowZone := 0;			end		else if curgrowsize > growsize div 4 then			begin				InstantError(297);				SetHandleSize(growH, curgrowsize - growsize div 4);				myGrowZone := 1;			end		else			begin				InstantError(298);				SetHandleSize(growH, 0);				myGrowZone := 1;			end;		HUnLock(H);	end;{-----------------------------------------------------------------------------}	procedure OpenPreviouslyOpenedTextWindows;		var			j: integer;			blockNumber: integer;	begin	if fileopen then		begin			if textWindowInfo[nexusBlockText]^.wasOpen then				begin					 blockNumber := NexusBlockNumberFromBlockName(nexusBlockNameBeingEdited);					 OpenEditNexusBlockNumber(blockNumber);				end;			for j := 1 to numTextWindows do				begin					if textWindowInfo[j]^.wasOpen & (j<>nexusBlockText) then						OpenTextWindow(j);					textWindowInfo[j]^.wasOpen := false;				end;		end	end;{-----------------------------------------------------------------------------}	procedure OpenPreviouslyOpenedInfoWindows;		var			j: integer;	begin	if fileopen then		for j := 1 to numInfoWindows do			begin				if infoWasOpen[j] & not ((j=treeinfo) & not treeopen) then					OpenInfoWindow(j);				infoWasOpen[j] := false;			end;	end;	{-----------------------------------------------------------------------------}	procedure CheckWindowForOrder(theWindow: WindowPtr; var highestOrder: integer; var highestOrderWindow: WindowPtr);	var currentOrder: integer;	begin		currentOrder:= GetWindowOrder(theWindow);		if (currentOrder > 0) & (currentOrder > highestOrder) then			begin				highestOrder := currentOrder;				highestOrderWindow := theWindow;			end;	end;{-----------------------------------------------------------------------------}	function GetWindowWithHighestOrder: WindowPtr;	var highestOrder: integer;		highestOrderWindow: WindowPtr;		j: integer;	begin		highestOrder := 0;		highestOrderWindow := nil;		CheckWindowForOrder(treeWindow,highestOrder, highestOrderWindow);		CheckWindowForOrder(editorWindow,highestOrder, highestOrderWindow);		CheckWindowForOrder(statesWindow,highestOrder, highestOrderWindow);		for j := 1 to numinfowindows do 			CheckWindowForOrder(infoWindow[j],highestOrder, highestOrderWindow);		for j := 1 to numTextWindows do 			CheckWindowForOrder(textWindow[j],highestOrder, highestOrderWindow);		GetWindowWithHighestOrder := highestOrderWindow;	end;{-----------------------------------------------------------------------------}	procedure CheckWindowsWereOpen;	var j: integer;	begin		if not treeOpen then			SetWindowOrder(treeWindow,0);		if not editorOpen then			SetWindowOrder(editorWindow,0);		if not statesWindowOpen then   {v4.04: was statesWindowWasOpen}			SetWindowOrder(statesWindow,0);		for j := 1 to numinfowindows do 			if not infoOpen[j] then   {v4.04: was infoWasOpen}				SetWindowOrder(infoWindow[j],0);		for j := 1 to numTextWindows do 			if not textWindowInfo[j]^.open then   {v4.04: was .wasOpen}				SetWindowOrder(textWindow[j],0);	end;{-----------------------------------------------------------------------------}	procedure ReorderWindowsByWindowOrder;		var			theWindow, previousWindow: WindowPtr;	begin		CheckWindowsWereOpen;		previousWindow := nil;		theWindow := GetWindowWithHighestOrder;		while theWindow <> nil do			begin				if previousWindow <> nil then					DoDeActivates(previousWindow,false);				if (theWindow=treeWindow) then					begin						if treeopen then							begin								SelectTreeWindows;								DoActivates(theWindow);							end;					end				else if (theWindow=editorWindow) then					begin						if editorOpen then							begin								SelectEditorWindows;								DoActivates(theWindow);							end;					end				else					begin						SelectWindow(theWindow);						DoActivates(theWindow);					end;				SetWindowOrder(theWindow,0);				previousWindow := theWindow;				theWindow := GetWindowWithHighestOrder;			end;	end;{-----------------------------------------------------------------------------}	procedure InvalidateInfoWindowButtons;		var			tport: WindowPtr;			j: integer;	begin		genericGetPort(tport);		for j := 1 to numinfoWindows do			if infoOpen[j] then				begin					genericSetPort(infoWindow[j]);					DrawButtonRow(j);				end;		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	procedure InvalidateOptionPalette;		var			tport: WindowPtr;			j, whichToolPalette: integer;	begin		genericGetPort(tport);		if treeopen then whichToolPalette := treeTools 		else whichToolPalette := editorTools;		genericSetPort(toolPaletteWindow[whichToolPalette]);		for j := 0 to numTools[whichToolPalette] do			if tool^[whichToolPalette,j].hasOptionCurs then				DropTool(whichToolPalette,j);		InvalidateWindowRect(toolPaletteWindow[whichToolPalette],paletteMessageBox[whichToolPalette],false);		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	procedure ResetPartitionElements;	begin		if fileopen then			begin				if ScreenInColor & SomePartitionPartToColor then					InvalidateWindow(editorWindow, true);				if charton then					InvalidateWindow(chartwindow, true);				if treeopen & TicksVisible & (colorTicksClass = colorTicksPartition) then					godraw := true;			end;		charPartitionsChanged:= false;	end;	{-----------------------------------------------------------------------------}	function CheckControlDown(Event: EventRecord):boolean;	var modifiers : UInt32;	begin{$IFC CARBON}		modifiers := GetCurrentKeyModifiers;		CheckControlDown := BitAnd(modifiers, ControlKey) <> 0;{$ELSEC}		CheckControlDown := ControlEvent(Event);{$ENDC}	end;{-----------------------------------------------------------------------------}	procedure CheckOptionDown(Event: EventRecord;  var optionDownBoolean: boolean);	var modifiers : UInt32;	begin{$IFC CARBON}		modifiers := GetCurrentKeyModifiers;		optionDownBoolean := BitAnd(modifiers, optionKey) <> 0;{$ELSEC}		optionDownBoolean := OptionEvent(Event);{$ENDC}	end;{-----------------------------------------------------------------------------}	procedure ResetCodPosElements;	begin		InvalidateWindow(infoWindow[charinfo], false);		if ScreenInColor & SomeCodePosPartToColor & nucleotides then			InvalidateWindow(editorWindow, true);		if charton then			if ColorCodPosLegal then				InvalidateWindow(chartwindow, true)			else if positionchart and (CWChart = CWCSteps) then{FROZEN 3.0}				ChangeCodonsGoList;		CheckForCodPos(true);		if editorShowAAwithDNA & not someCoding then			SwitchEditorShowAAWithDNA;		if taxinfoShowStopCodons | taxInfoShowPartTriplets then			SizeInfoWindow(taxinfo,false,true);		FixEditMenu;		if treeopen & TicksVisible & (colorTicksClass = colorTicksCodPos) then			godraw := true;		codonPositionsChanged := false;	end;{$IFC UNDEFINED GENERATING68K}	{$SETC GENERATING68K = FALSE}{$ENDC}{$IFC GENERATING68K }{-----------------------------------------------------------------------------}	procedure UnloadSegments;	begin		UnloadSeg(@SetTaxaDnSts);		{Unloading SetStates segment}{    UnloadSeg(@FixEditMenu);			Unloading MenuUtil segment}{    UnloadSeg(@DisposeNODEs);		       Unloading TreeUtil segment}		UnloadSeg(@AddCHUNKs);			{Unloading CHUNK segment}		UnloadSeg(@CollapseProhibited);	{Unloading Prohibitions segment}		UnloadSeg(@nextchar);				{Unloading ReadUtil segment}		UnloadSeg(@WriteBuffer);				{Unloading WriteBuffer segment}		UnloadSeg(@FillSelectedWithRandom);			{Unloading Fill segment}		UnloadSeg(@DownPassTraced);		{Unloading CalcTraced segment}		UnloadSeg(@ColorTree);				{Unloading Coloring segment}		UnloadSeg(@ContinuousEdit);		{Unloading Continuous segment}		UnloadSeg(@MakeRandomTree);		{Unloading RandomTree segment}		UnloadSeg(@DrawBranchListWindow);	{Unloading BranchListWindow segment}		UnloadSeg(@StatusNotes);			{Unloading StatusNotes segment}		UnloadSeg(@MakeTree);				{Unloading TreeMaker segment}		UnloadSeg(@TreeRandomData);		{Unloading TreeRandomData segment}		UnloadSeg(@ReadTreeBlock);		{Unloading ReadTreeFile segment}		UnloadSeg(@SaveLinkToChain);		{Unloading StringSave segment}		{UnloadSeg(@ShowHelp);				Unloading Help segment}		if not editorOpen then			UnloadSeg(@DrawRCNumbers);			{Unloading DrawSpread segment}		UnloadSeg(@CreateTaxonCharMemory);			{Unloading RowColumn segment}		UnloadSeg(@DrawStatesWindow);			{Unloading StatesWindow segment}		UnloadSeg(@MouseInEdit);			{Unloading Editcontrol segment}		UnloadSeg(@PolyCalcs);				{Unloading PolyCalc segment}		UnloadSeg(@GenTriplePass);		{Unloading GenChar segment}		UnloadSeg(@NextSevenChars);		{Unloading N7On segment}		if not treeopen then			begin				UnloadSeg(@DrawTreeLeg);		{Unloading Legends segment}				UnloadSeg(@DrawTreeWindow); {Unloading TreeDrawer segment}				UnloadSeg(@TriplePass);		{Unloading Calc segment}			end;		UnloadSeg(@AddFootText);		{Unloading Footnote segment}		UnloadSeg(@CountTree);				{Unloading Count segment}		UnloadSeg(@BranchSwap);			{Unloading UndoSwap segment}		UnloadSeg(@OpenEdit);				{Unloading Windows segment}		UnloadSeg(@DoCharCorrel);			{Unloading CharCorrelation segment}		UnloadSeg(@DrawChartWindow);	{Unloading ChartWindow segment}		UnloadSeg(@DrawScatter);			{Unloading ChartWScatter segment}		UnloadSeg(@DrawHistogram);		{Unloading ChartWHisto segment}		UnloadSeg(@DrawChartText);		{Unloading ChartWText segment}		UnloadSeg(@GoToTree);				{Unloading TreeGet segment}		UnloadSeg(@PrintData);				{Unloading PrintSpreadSheet segment}		UnloadSeg(@LaserTree);				{Unloading LaserTree segment}		UnloadSeg(@DrawTreePicture);		{Unloading LaserDraw segment}		UnloadSeg(@PrintLaserTree);		{Unloading LaserPrint segment}		UnloadSeg(@SetPreferenceValues);		{Unloading Settings segment}		UnloadSeg(@FileMatrixToMem);	{Unloading ReadMatrix segment}		UnloadSeg(@WriteExportData);		{Unloading Export segment}		UnloadSeg(@ReadFile);			{Unloading ReadData segment}		UnloadSeg(@ReadOldFile);			{Unloading Import segment}		UnloadSeg(@WriteFile);				{Unloading WriteData segment}		UnloadSeg(@GeneticCodeDLOG);		{Unloading GeneticCode segment}		UnloadSeg(@CloseFile);				{Unloading GenClose segment}		UnloadSeg(@LoadTypes);			{Unloading TypeImport segment}		{UnloadSeg(@IncExcTaxa);}			{Unloading IncExcTaxa segment}		UnloadSeg(@GetCSTree);			{Unloading CharStateTree segment}		UnloadSeg(@DefineType);			{Unloading Type segment}		UnloadSeg(@DoPatternsAndColors);			{Unloading Shading segment}		UnloadSeg(@ClickInInfoWindow);		{Unloading ClickInInfoWindow segment}		UnloadSeg(@DoRecode);				{Unloading Recode segment}		UnloadSeg(@MouseInTree);			{Unloading MouseInTree segment}{$IFC SPEECH}		UnloadSeg(@SpeakMatrix);			{Unloading Speak segment}{$ENDC}		UnloadSeg(@DoChartMenu);			{Unloading ChartMenu segment}		UnloadSeg(@DoEdUtilitiesMenu);	{Unloading EditUtilMenu segment}		{UnloadSeg(@DoAssumpMenu);	 }	{Unloading AssumpMenu segment}		UnloadSeg(@DoTreeMenu);			{Unloading Menus segment}		UnloadSeg(@ScrollTree);			{Unloading ScrollTree segment}		UnloadSeg(@ProcessMenu);			{Unloading ProcessMenu segment}		UnloadSeg(@DoPrint);				{Unloading DoPrint segment}		UnloadSeg(@LaserUser);				{Unloading LaserDLOGDraw segment}		UnloadSeg(@CalcChartData);		{Unloading ChartWCalc segment}		UnloadSeg(@UndoMove);				{Unloading UndoTree segment}		UnloadSeg(@ReadAssumptions);		{Unloading ReadAssumpBlock segment}		UnloadSeg(@StartEquivCycle);		{Unloading Equivocal segment}		UnloadSeg(@ChartToText);			{Unloading ChartWWrite segment}		UnloadSeg(@DoFontMenu);			{Unloading Fonts segment}		UnloadSeg(@CreateType);			{Unloading TypeNewDLOG segment}		UnloadSeg(@ChartToWeightsDLOG);		{Unloading ChartToType segment}	end;{$ENDC}{||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}{||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| MAIN ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}{||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}begin	isforeground := true;	noCommandToolOverride := false;	AEEventUPPsCreated := false;	dirtyTreeTaxNames := false;		{$IFC WRITETEMPFILE}	rewrite(tempFile, 'temporaryFile');	writeln(tempFile,'before InitMacClade');{$ENDC}	InitMacClade;	if earlyquit then		goto 87;	if hasAppleEventMgr then		begin 					CreateAEEventHandlersUPPs;			InstallAEEventHandlers;   {system 7 way}		end 	else 		quit := true;	if quit then		goto 86;	timechange := false;		//os := SetApplicationDockTileMenu(nil);	theGrowZoneUPP := MyNewGrowZoneUPP(@myGrowZone);  {$IFC CARBON}	SetGrowZone(GrowZoneUPP(theGrowZoneUPP));   {$ELSEC}	SetGrowZone(theGrowZoneUPP);   {$ENDC}{$IFC GENERATING68K }	UnloadSeg(@InitMacClade);			{Unloading StartUp segment}	UnloadSeg(@Bye);					{Unloading Quit segment}{$ENDC}	oldScreenInColor := ScreenInColor;   {determined in InitThings on start up}{||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}	repeat{$IFC GENERATING68K }		UnloadSegments;{$ENDC}		if not isMacOSX & (myFreeMem < 20480) then  {20K buffer}			NewError(378, 0);		oldrealtypes := realtypes;		oldrealwts := realwt;		CheckOptionDown(Event, oldOption);		oldControl := CheckControlDown(Event);		{====== process MacClade's own "events" ======}{    if doCodPosQuery and fileopen then QuerySetCodPos;}		if onOpenFileSetAsPlainMolecularStyle then			begin				DoDataMatrixStyleMenu(styleMolecularItem);				onOpenFileSetAsPlainMolecularStyle := false;			end;		if codonPositionsChanged then			ResetCodPosElements;					if charPartitionsChanged then			ResetPartitionElements;		if treeopen then			begin				if not isMacOSX & (myFreeMem < 1024) then  {if very low on memory, tree window is closed}					begin						CloseTreeWindow(false);						treemakingfailed := false;						NewError(383, 0);						goto 345;					end				else if treemakingfailed then					begin						CloseTreeWindow(false);						treemakingfailed := false;						NewError(379, 0);						goto 345;					end;				if pleaseoffequivocal then					begin						StopEquivCycle;						NewError(333, 0);						pleaseoffequivocal := false;					end;				if (traceshown = traceDiscrete) then					begin						if not charincluded(i) | pleaseofftrace then							begin								InstantError(168);								TurnOffTrace(i, true, false, true);								pleaseofftrace := false;							end					end				else if (traceshown = traceContinuous) & not Continuouslegal(true) then					TurnOffContinuous(true);				if PleaseOffMinAll or PleaseOffMaxAll or PleaseOffCi or PleaseOffRIRC then					begin						if PleaseOffMinAll then							begin								showminsteps := false;								SetInfoColumnIDShow(charinfo, CharInfoMin,false);								PleaseOffMinAll := false;							end;						if PleaseOffMaxAll then							begin								showmaxsteps := false;								SetInfoColumnIDShow(charinfo, CharInfoMax,false);								PleaseOffMaxAll := false;							end;						if PleaseOffCI or PleaseOffRIRC then							begin								if PleaseOffCI then									begin										CalcCI := false;										SetInfoColumnIDShow(charinfo, CharInfoCI,false);										if charton and (CWChart = CWCSTeps) and (CWStepsShow = CWStepsCI) then											PleaseoffChart := true;									end;								PleaseOffCI := false;								PleaseOffRIRC := false;								calcRI := false;								calcRC := false;								if charton and (CWChart = CWCSTeps) and (CWStepsShow in [CWStepsRI, CWStepsRC]) then									PleaseoffChart := true;								SetInfoColumnIDShow(charinfo, CharInfoRI,false);								SetInfoColumnIDShow(charinfo, CharInfoRC,false);							end;						ResetInfoWindow(charinfo);						resetGoMask;						if infoOpen[charinfo] then							SizeInfoWindow(charinfo, true, true);						SizeTreeLeg(true);						InvalidateWindow(tlegwindow, true);						CheckCalcMenu;					end;				if PleaseOffChart then					begin						if charton then							CloseChartWindow;						PleaseOffChart := false;					end;				if branchliston & (BranchListN = subR) then					CloseBranchListWindow;				if charton & (igos * (fullgochartone + fullgochartmult) * gomask <> []) then					begin						if (not (traceshown = traceDiscrete)) then							begin								InstantError(233);								CloseChartWindow;							end						else if (not charincluded(i)) then							begin								InstantError(235);								CloseChartWindow;							end;					end;				if allexcluded then					begin						if count then							begin								InstantErrorPlus(303, 'Treelength count');								SetOnOffCount(false);								ResetInfoWindow(charinfo);							end;						if Showminsteps or showmaxsteps then							begin								showminsteps := false;								showmaxsteps := false;								CheckCalcMenu;								ResetGoMask;								ResetInfoWindow(charinfo);							end;						if (traceshown = traceAllChanges) then							begin								InstantErrorPlus(303, 'Trace All Changes');								TurnoffShowChg(true)							end						else if (traceshown = traceAllStates) then							begin								InstantErrorPlus(303, 'Trace All States');								TurnoffAllStates;							end;						if charton then							begin								InstantErrorPlus(303, 'Chart');								CloseChartWindow;							end;						ResetGomask;					end;{SetTaxaDnsts prepares the terminal downstates and calculates the chstatesH storing what states }{	are in each char in the tree.  This is needed for all subsequent calculations but is generally done}{	once for each new tree.  It does not need to be redone unless taxa are added, types are changed,}{	or a new tree is read}{CalcMinTreeLen (all chars) and ResetCharMinLen calculate then minimum conceivable length for characters.}{	It is needed only if CI's are being calculated, and only needs to be called in the same circumstances}{	when SetTaxaDnsts is called.  Needs: SetTaxaDnsts.  Note: needs to be readjusted but not entirely recalculated}{	when weights are changed.  ResetMinTreeLength does this}{CountTree (all chars) and CountChar perform down pass and count the length of the tree.  They need to be}{	recalculated in many circumstances, including whenever SetTaxaDnsts is called, and as well when }{	a branch is moved, etc.  Needs: SetTaxaDnsts.  Note: needs to be readjusted but not entirely recalculated}{	when weights are changed.  ResetTreeLength does this.}{CalculateCI (All chars) and CalculateCIChar calculate CI.  Needs to be recalculated whenever Count is redone, as well as}{	if weights change.  Needs: SetTaxaDnsts, CalcMinTreelen/Resetcharminlen, CountTree/CountChar.  }{	Note: needs to be readjusted but not entirely recalculated when weights are changed. Currently CalculateCI is done anyway}{ReconstructChars does a full reconstruction of the ancestral states.  Needs: SetTaxaDnsts, CountTree/CountChar}{CountChanges calculates the number of changes on a branch, for use in ShowChanges etc.  }{	Needs: SetTaxaDnsts, CountTree/CountChar, ReconstructChars}{golist contains all the things which might be needed.}{gomask indicates what things are turned on.}				golist := golist * gomask;{golist elements:}{  statesall,statesi2 are not used and are obsolete; cii2 I think is obsolete}{The following elements are placed in golist whenever they might be needed}{	and are ignored if gomask does not contain them also:}{	볍ettaxdnall ,calcminlenall, countall, ciall,reconstructall,changesall,brchangesall,reconstructi,changesi,counttreesall,counttreesi}{	All of these concern calculations for all characters except those ending in i}{The following elements are placed in golist only when it is know that they are needed (with few exceptions),}{ 	because gomask always contains them and thus will let them pass.}{	볍ettaxdni2,calcminleni2,counti2,cii2,reconstructi2,resetlengthall,resetminlengthall,changesi2 }{	Those ending in i2 are designed to update the information for one character whose number is stored in i2.}{Rules for chart recalculation: }{- for the most part, if anything is changed that would change the outcome of the chart, then the chart is updated.}{This includes changing types, weights, rearranging the current tree, fixing a state at a branch when the chart is a single-}{tree chart for character i.}{There is at least one exception, namely if a chart was based on a tree file and that tree file was}{modified by deleting or storing trees, the chart is not recalculated.}{There may be other apparent exceptions, but they are not really exceptions, e.g.: change current tree does not}{affect multiple trees chart even if current tree had been read from a treefile, since you are not actually changing}{the tree file; e.g., fix state of traced character affects changes and stasis chart for current tree, but does not}{affect chart for multiple trees, since this chart is not based on current tree or its fixing.}				if golist <> [] then					begin{Redoing CHART Window Calculations demanded by golist when there are MULTIPLE TREES==================}{these have to come first before the calculations on current tree, because the tree cycling destroys the }{calculations on the current tree.  On the other hand, chart window stuff dealing only with current tree needs}{to come after the calculations on the current tree, because it needs to know the results of the calculations.}{I think we cannot allow the current tree to be part of the cycling!!!!!!!!! }						RecalcChartWindow := false;						if charton and not ChartJustCalc then							begin								case CWChart of									CWCSteps: 										case CWStepsShow of											CWStepsSteps: 												RecalcChartWindow := ([stepsIchartmult, stepsAllChartMult] * golist <> []);											CWStepsChanges: 												RecalcChartWindow := ([stepsChgsIchartmult, stepsChgsAllChartMult] * golist <> []);											CWStepsCI, CWStepsRI, CWStepsRC: 												RecalcChartWindow := ([CIRIIchartmult, CIRIAllChartMult] * golist <> []);											otherwise												;										end;									CWCChanges: 										RecalcChartWindow := (golist * [ChangesIchartmult, changesAllChartMult] <> []);									CWCCTall: 										RecalcChartWindow := (Treelengthschart in golist);									CWCC2T: 										RecalcChartWindow := (TwoTreeschart in golist);									CWCC2TF: 										RecalcChartWindow := (TwoTreefiles in golist);{$IFC PROBSTEPCHART}									CWCProbSteps: 										RecalcChartWindow := (goProbStepsChart in golist);{$ENDC}									otherwise										;								end;								if RecalcChartWindow & not chartQuietRecalc & not Cwarning('Do you want to recalculate Chart?', 'Recalculate', 'Close Chart') then									begin										PleaseOffChart := true;										RecalcChartWindow := false;									end;							end;						if RecalcChartWindow then							begin								if ChartCalcToText then									CalcToTextfile(true)								else									CalcChartData(true);								InvalidateWindow(ChartWindow, true);							end;						if treemakingfailed then							begin								CloseTreeWindow(false);								treemakingfailed := false;								NewError(379, 0);								goto 345;							end;						golist := golist * gomask;{golist needs resetting because RestoreCurrentTree has unleashed full golist for tree and chartone}{Redoing TREE WINDOW Calculations demanded by golist on CURRENT TREE ==================}						if settaxdnall in golist then							SetTaxaDnsts(1, numchars)						else if settaxdni2 in golist then							SetTaxaDnsts(i2, i2);						if calcminlenall in golist then							CalcMinMaxTreeLen(minlength)						else if calcminleni2 in golist then							CalcCharMinMaxLen(i2, minlength);						if calcmaxlenall in golist then							CalcMinMaxTreeLen(maxlength)						else if calcmaxleni2 in golist then							CalcCharMinMaxLen(i2, maxlength);{$IFC PROBRECONSTRUCT}						if Goprobability in golist then							CalcProbReconstruct;{$ENDC}						if ((ResetMinLengthAll in golist) & not (calcminlenall in golist)) then							ResetMinMaxTreeLength(minlength);						if ((ResetMaxLengthAll in golist) & not (calcmaxlenall in golist)) then							ResetMinMaxTreeLength(maxlength);						if countall in golist then							begin								if not CountTree then									NewError(110, 0)							end						else if counti2 in golist then  {counti2 is only set in TypeDLOG}							begin								Countchar(i2);								if calcCI or calcRC then									CalculateCIRiChar(i2, true);								if calcRI or calcRC then									CalculateCIRiChar(i2, false);							end;						if count & ((ResetLengthall in golist) & not (countall in golist)) then							resetTreeLength;						if (ciall in golist) then							CalculateCIAll;						if (riall in golist) then							CalculateRIAll;						if reconstructall in golist then							reconstructChars(1, numchars, true)						else if reconstructi2 in golist then							ReconstructChars(i2, i2, true);						if changesall in golist then							CountTotalTreeChanges;						if reconstructi in golist then							begin								ReconstructTraced;								if showtracelabels | (fixon & showfix) then									godraw := true;							end;						if GOcontinuous in golist then							begin								ReconstructContinuous;								if showconttracelabels then									godraw := true;							end;{Redoing CHART Calculations demanded by golist which deal only with CURRENT TREE ==================}						recalcChartWindow := false;						if charton and not ChartJustCalc then							case CWChart of								CWCSteps: 									case CWStepsShow of										CWStepsSteps: 											RecalcChartWindow := (stepschart in golist);										CWStepsChanges: 											RecalcChartWindow := (stepsChgschart in golist);										CWStepsCI, CWStepsRI, CWStepsRC: 											RecalcChartWindow := (CIRIchart in golist);									end;								CWCChanges: 									RecalcChartWindow := ([ChangesIChart, ChangesAllChart] * golist <> []);								CWCstates: 									RecalcChartWindow := ([statesichart, statesallchart] * golist <> []);								otherwise									;							end;						if RecalcChartWindow then							begin								if ChartCalcToText then									CalcToTextfile(true)								else									CalcChartData(true);								InvalidateWindow(ChartWindow, true);							end;						if brchangesall in golist then							begin								aborted := false;								CountBranchLengths(1, numchars, branchlistmode, branchlengthsweighted, aborted);								if treedrawn and (traceshown = traceAllChanges) then									godraw := true;								if aborted then									begin										if (traceshown = traceAllChanges) then											TurnOffShowChg(true);									end;							end;						if branchliston & ([brchangesall, reconstructall, reconstructi2] * golist <> []) then							begin								MakeBranchList(BranchListN, d1, d2, 0, 0, listToWindow);								InvalidateWindow(branchlistwindow, true);							end;{Asking for updates for calculations just done ==================}						if infoOpen[charinfo] then							begin								if settaxdnall in golist then									begin										InvalidateInfoColumn(charinfo, CharInfoStates, 1, numchars);										if ShowInfoColumnFromID(charinfo, CharInfoMax) then											InvalidateInfoColumn(charinfo, CharInfoMax, 1, numchars);										if ShowInfoColumnFromID(charinfo, CharInfoMin) then											InvalidateInfoColumn(charinfo, CharInfoMin, 1, numchars);									end								else if settaxdni2 in golist then									begin										InvalidateInfoColumn(charinfo, CharInfoStates, i2, i2);										if ShowInfoColumnFromID(charinfo, CharInfoMax) then											InvalidateInfoColumn(charinfo, CharInfoMax, i2, i2);										if ShowInfoColumnFromID(charinfo, CharInfoMin) then											InvalidateInfoColumn(charinfo, CharInfoMin, i2, i2);									end;								if countall in golist then									InvalidateInfoColumn(charinfo, CharInfoSteps, 1, numchars)								else if counti2 in golist then									begin										InvalidateInfoColumn(charinfo, CharInfoSteps, i2, i2);										if calcCI then											InvalidateInfoColumn(charinfo, CharInfoCI, i2, i2);										if calcRI then											InvalidateInfoColumn(charinfo, CharInfoRI, i2, i2);										if calcRC then											InvalidateInfoColumn(charinfo, CharInfoRC, i2, i2);										if showminsteps then											InvalidateInfoColumn(charinfo, CharInfoMin, i2, i2);										if showmaxsteps then											InvalidateInfoColumn(charinfo, CharInfoMax, i2, i2);									end;								if changesall in golist then									InvalidateInfoColumn(charinfo, CharInfoChgs, 1, numchars);								if calcminlenall in golist then									InvalidateInfoColumn(charinfo, CharInfoMin, 1, numchars);								if calcmaxlenall in golist then									InvalidateInfoColumn(charinfo, CharInfoMax, 1, numchars);								if ciall in golist then									begin										InvalidateInfoColumn(charinfo, CharInfoCI, 1, numchars);										InvalidateInfoColumn(charinfo, CharInfoMin, 1, numchars);									end;								if riall in golist then									begin										InvalidateInfoColumn(charinfo, CharInfoRC, 1, numchars);										InvalidateInfoColumn(charinfo, CharInfoRI, 1, numchars);										InvalidateInfoColumn(charinfo, CharInfoMin, 1, numchars);										InvalidateInfoColumn(charinfo, CharInfoMax, 1, numchars);									end;							end;						if not printon then							begin								if (count & ([countall, ciall, riall, resetlengthall] * golist <> [])) | (calctreechanges & (reconstructall in golist)) | (showminsteps & ([resetminlengthall, calcminlenall] * golist <> [])) | (showmaxsteps & ([resetmaxlengthall, calcmaxlenall] * golist <> [])) then									InvalidateWindow(tlegwindow, false);							end;{$IFC PROBRECONSTRUCT}						if ((reconstructi in golist) and (traceshown = traceDiscrete)) or ((GOcontinuous in golist) and (traceshown = traceContinuous)) or ((goProbability in golist) and (traceshown = traceProbability)) then							begin								if not printon then									InvalidateWindow(chlegwindow, false);								if not godraw and treedrawn then									ReshadeTree;							end;{$ELSEC}						if ((reconstructi in golist) and (traceshown = traceDiscrete)) or ((GOcontinuous in golist) and (traceshown = traceContinuous)) then							begin								if not printon then									InvalidateWindow(chlegwindow, false);								if not godraw and treedrawn then									ReshadeTree;							end;{$ENDC}						golist := [];					end; {golist<>[]}				if dirtyTreeTaxNames then					begin						dirtyTreeTaxNames := false;						if treeopen & nodes then							begin								oldTaxonHeight := taxonHeight;								CalcTaxonHeight;								if taxonHeight <> oldTaxonHeight then									begin										SetDrawTWRControls;										godraw := true;									end;							end;					end;				if goTWHome then					begin						SetDrawTWRControls;						goTWHome := false;					end;				if treemakingfailed then					begin						CloseTreeWindow(false);						treemakingfailed := false;						NewError(379, 0);						goto 345;					end;				if gonex7on then					begin						InvalidateBox(treewindow, databoxB);						VertTWScrollPosition;						goNex7on := false;					end;				if godraw then					begin						DrawTreeWindow;						genericSetPort(treewindow);						if not dontCancelUpdate then {or (drawR = screenR)}							myValidRect(treeWindow,WindowPortRect(treeWindow));						godraw := false;					end;			end;345:		if goerror then{$IFC CARBON}			if not isMacOSX | not UpdatePendingOnAnyMacCladeWindow then{$ENDC}				showerrors('');		ChartJustCalc := false;		{====== bookkeeping ======}		if fileopen then			CheckDirty;		badCellEntry := false;		errorFlag := FALSE;		KCHRPtr := nil;		badmemory := false;		dontCancelUpdate := false;		allowImportMoleculeIntoStandard := false;		queriedAboutImportedSequenceType := false;		if treeopen then 			CheckToolValidity(treeTools);		if frontWindow<>nil then			if IsEditableTextWindow(frontWindow) & (frontWindow <> nil) then				TEIdle(textWindowInfo[WhichTextWindow(frontWindow)]^.TE)			else if (IsInfoWindow(frontWindow)) and (frontWindow <> nil) then				TEIdle(infoTE[WhichInfoWindow(frontWindow)])			else if (frontwindow=stateswindow) & statesEditing  then				TEIdle(statesTE)			else if editorOpen and editorSelected and SingleCell then				begin					if not footediting and CellVisible(editorSelectionTopLeft, editorSelectionBotRight) then						TEIdle(editorCellTE)					else if (frontWindow = statesWindow) and (frontWindow <> nil) then						TEIdle(statesTE)					else if footTexton and footediting then						TEIdle(noteTE);				end;		if SplitMultiActive(currentTool[editorTools]) & isforeground then			FlashSplitMultiActive{		else if editorFlashOn & not flashHidden then			TurnOffFlash};{====== get the next event ======}		if updateHasPriority then			eventMask := updateMask		else			eventMask := everyEvent;		if haswaitnextevent then			db := WaitNextEvent(eventMask, event, GetSleep, nil)		else			begin{$IFC NOT CARBON}				SystemTask;{$ENDC}				db := GetNextEvent(eventMask, Event);			end;		updateHasPriority := false;			CheckOptionDown(Event,OptionIsDown);		if OptionIsDown then			begin				allowImportMoleculeIntoStandard := true;			end;		if oldOption <> OptionIsDown then			begin				InvalidateOptionPalette;				InvalidateInfoWindowButtons;			end		else if oldControl <> CheckControlDown(Event) then			InvalidateInfoWindowButtons;								case Event.what of			nullEvent: 				if isforeground then					begin												if justReadANexusFile then							begin								moreWindowsToOpen := AnyInfoWindowWasOpen | AnyTextWindowWasOpen | statesWindowWasOpen | (aboutwasopen & fileopen);								if AnyInfoWindowWasOpen then   {messages sent only on reading a new file}									OpenPreviouslyOpenedInfoWindows;								if AnyTextWindowWasOpen then									OpenPreviouslyOpenedTextWindows;								if statesWindowWasOpen then									OpenStatesWindow(false,0,0);								if aboutwasopen & fileopen then   {messages sent only on reading a new file}									begin										if aboutwasopen then											OpenTextWindow(aboutFileText);										aboutwasopen := false;									end;								if moreWindowsToOpen then									begin										if treeopen then											DoDeActivates(treewindow,false)										else if editorOpen then											DoDeActivates(editorWindow,false);									end;								if windowOrderRead then									ReorderWindowsByWindowOrder;								justReadANexusFile := false;																windowOrderRead := false;							end;						CursorAdjust(Event);						comingback := false;					end;			mouseDown: 				begin					DealwthMouseDowns(Event);				end;			KeyDown, AutoKey: 				begin					DealwthKeyDowns(Event);				end;			ActivateEvt: 				begin					CheckScreenRectangle;					DealwthActivates;				end;			osEvent: 				begin					DoSuspendResume(Event);				end;			UpDateEvt: 				begin					DealwithUpdates(Event,true);				end; {$IFC REQAPPLEEVENTS}			kHighLevelEvent: 				begin					DoHighLevelEvent(Event);				end;{$ENDC}			otherwise				;		end;		if ((oldrealtypes <> realtypes) | (oldrealwts <> realwt)) & (((CWChart = CWCSteps) & not (sequencechart | positionchart) & (CWStepsShow = CWStepsSteps)) | (CWChart = CWCCtall)) then			defaultcatWid := -1;	until quit;{||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}			MyDisposeGrowZoneUPP(theGrowZoneUPP);86:	Bye;	DestroyAEEventHandlersUPPs;87:	ZapHandle(printRecordH);{$IFC WRITETEMPFILE}	close(tempFile);{$ENDC}{$IFC NOT CARBON}	ExitToShell;{$ENDC}end.