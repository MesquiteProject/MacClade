unit WindowUtil;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}interface	uses		Quickdraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, 		Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap, 		 Globals, SetLibInterface, UtilLibInterface, MemoryUtil, CarbonUtil, SimpleUtil, CarbonUtil, SimpleUtil, EventUtil, Script;	function GetWindowFullWidth (theWindow: WindowPtr): integer;	function GetWindowFullHeight (theWindow: WindowPtr): integer;	function GetWindowTitleBarHeight (theWindow: WindowPtr): integer;	function GetWindowEdgeWidth (theWindow: WindowPtr): integer;	function GetWindowBottomEdgeWidth (theWindow: WindowPtr): integer;	function GetWindowFullRect (theWindow: WindowPtr): Rect;	function GetWindowTopPadding (theWindow: WindowPtr): integer;	function GetWindowBottomPadding (theWindow: WindowPtr): integer;	function GetWindowLeftPadding (theWindow: WindowPtr): integer;	function GetWindowRightPadding (theWindow: WindowPtr): integer;	function GetWindowMaxContentHeight (theWindow: WindowPtr): integer;	function GetWindowMaxContentWidth (theWindow: WindowPtr): integer;	function GetWindowDefaultLeft (theWindow: WindowPtr): integer;	function GetWindowDefaultTop (theWindow: WindowPtr): integer;	procedure StartDLOG (ID: integer; var theDialog: DialogPtr; var tempP: WindowPtr);	procedure EndDLOG (theDialog: DialogPtr; tempP: WindowPtr);	procedure TwoRadioDialog (ID: integer; var theBoolean: boolean; isupper: boolean);	procedure DrawResourceTEXT (theDialog: DialogPtr; itemNum: integer; resID: integer);	function GetDLOGItemHandle (theDialog: DialogPtr; num: integer): Handle;	procedure EnableDisableDLOGItem (theDialog: DialogPtr; theItem: integer; turnon, uncheck: boolean);	function GetDLOGItemBox (theDialog: DialogPtr; num: integer): rect;	procedure CenterDLOG (theDialog: DialogPtr);	procedure HideButton (theDialog: DialogPtr; itemNum: integer);	procedure InvertDLOGItem (theDialog: DialogPtr; num: integer);	procedure FrameButton (theDialog: DialogPtr; ItemNo: integer);	function PressButton (theDialog: DialogPtr; theButton: integer): integer;	procedure ItemCheckMark (theDialog: DialogPtr; ItemNo: integer; turnon: boolean);	function DoAlert (ID: integer; Atype: integer): Integer;	procedure DrawThermos;	procedure InvalidateInfoWindow (whichinfo: integer);	function LockedToTreeWindow(theWindow: WindowPtr): boolean;		procedure DisableWindowUpdates(theWindow: WindowPtr);	procedure SetUpdatesAllowed(theWindow: WindowPtr; on: boolean);	function CanUpdateWindow(theWindow: WindowPtr): boolean;	procedure InvalidateWindowMarkedUnUpdatable(theWindow: WindowPtr);	procedure  InvalidateAllWindowsMarkedUnupdatable;	procedure  InvalidateAllWindows;	procedure SetWindowType(theWindow: WindowPtr; windowType: integer);	function GetWindowType(theWindow: WindowPtr): integer;	function TextWindowLocked(whichText:integer): boolean;	function IsEditableTextWindow(windP: WindowPtr): boolean;	function IsTextWindow (windP: WindowPtr): boolean;	function WhichTextWindow (windP: WindowPtr): integer;	function IsInfoWindow (windP: WindowPtr): boolean;	function WhichInfoWindow (windP: WindowPtr): integer;	function IsPaletteWindow (windP: WindowPtr): boolean;	function WhichPaletteWindow (windP: WindowPtr): integer;	function IsEditorWindow (windP: WindowPtr): boolean;	function MacCladeWindow (WindP: WindowPtr): boolean;	function IsTreeWindow (windP: WindowPtr): boolean;	procedure InvalTaxonNames;	function UpdatePending (WindP: WindowPtr): boolean;	function  UpdatePendingOnAnyMacCladeWindow: boolean;	function WindowInView (WindP: WindowPtr): boolean;	function WindowBotRightOnScreen (windowP: WindowPtr; vertscroll: boolean; drawinglimit: integer): boolean;	procedure StoreFrontWindows;	procedure RestoreFrontWindows;	procedure HugTwoScrolls (theWindow: WindowPtr; Hleft, Vtop, Vgap: integer; HScroll, VScroll: ControlRef);	function WarnCantUndo: boolean;	function WarnCantUndoLowMemory: boolean;	function PixelDepth: integer;	procedure CheckPixelDepth (windowP: WindowPtr);	function WindowInColor (windowP: WindowPtr): boolean;	procedure SetEWClip (themode: signedbyte);	function WindowVisible(theWindow: WindowPtr): boolean;	function GetWindowOrder (windP: WindowPtr): integer;	procedure SetWindowOrder (windP: WindowPtr; theOrder: integer);	function GetWindowName (windP: WindowPtr): str15;	procedure SetWindowName (windP: WindowPtr; name: str15);	function WindowOffScreen(theWindow: WindowPtr):boolean;	function SizeWindowByBoxStorage(theWindow: WindowPtr): boolean;	procedure SetBasicDLOGFilterHandling (theDialog: DialogPtr; okButton,cancelButton: integer; hasEditable: boolean);{еееееееееееееееееееееее}implementation {е$S WindowUtil}{-----------------------------------------------------------------------------}	function GetWindowRects (theWindow: WindowPtr; whichRegion: integer): Rect;	var os: OSStatus;		ioWinRgn: RgnHandle;		myRectPtr: RectPtr;		myRect: Rect;	begin		SetRect(myRect,0,0,0,0);{$IFC CARBON}		ioWinRgn:= NewRgn;		os := GetWindowRegion(theWindow, whichRegion, ioWinRgn);		if os=NoErr then			myRectPtr := GetRegionBounds(ioWinRgn, myRect);  // check coersion		ZapRegion(ioWinRgn);{$ELSEC}		if whichRegion = kWindowStructureRgn then			myRect := WindowPeek(theWindow)^.strucRgn^^.rgnBBox		else			myRect := WindowPeek(theWindow)^.contRgn^^.rgnBBox;		{$ENDC}		GetWindowRects := myRect;	end;{-----------------------------------------------------------------------------}	function GetWindowFullRect (theWindow: WindowPtr): Rect;	begin		GetWindowFullRect := GetWindowRects(theWindow,kWindowStructureRgn);	end;{-----------------------------------------------------------------------------}	function GetWindowContentRect (theWindow: WindowPtr): Rect;	begin		GetWindowContentRect := GetWindowRects(theWindow,kWindowContentRgn);	end;{-----------------------------------------------------------------------------}	function GetWindowFullWidth (theWindow: WindowPtr): integer;	var box: rect;	begin		box := GetWindowFullRect(theWindow);		GetWindowFullWidth := box.right-box.left;	end;{-----------------------------------------------------------------------------}	function GetWindowFullHeight (theWindow: WindowPtr): integer;	var box: rect;	begin		box := GetWindowFullRect(theWindow);		GetWindowFullHeight := box.bottom-box.top;	end;{-----------------------------------------------------------------------------}	function GetWindowTitleBarHeight (theWindow: WindowPtr): integer;	var boxFull, boxContent: rect;		height: integer;	begin		boxFull := GetWindowFullRect(theWindow);		boxContent := GetWindowContentRect(theWindow);		height := boxContent.top-boxFull.top;		if height= 0 then			GetWindowTitleBarHeight := 20		else			GetWindowTitleBarHeight := height;	end;{-----------------------------------------------------------------------------}	function GetWindowEdgeWidth (theWindow: WindowPtr): integer;	var boxFull, boxContent: rect;		width: integer;	begin		boxFull := GetWindowFullRect(theWindow);		boxContent := GetWindowContentRect(theWindow);		width := boxContent.left-boxFull.left;		if width= 0 then			GetWindowEdgeWidth := 4		else			GetWindowEdgeWidth := width;	end;{-----------------------------------------------------------------------------}	function GetWindowBottomEdgeWidth (theWindow: WindowPtr): integer;	var boxFull, boxContent: rect;		width: integer;	begin		boxFull := GetWindowFullRect(theWindow);		boxContent := GetWindowContentRect(theWindow);		width := boxFull.bottom-boxContent.bottom;		if width= 0 then			GetWindowBottomEdgeWidth := 4		else			GetWindowBottomEdgeWidth := width;	end;{-----------------------------------------------------------------------------}	function GetWindowTopPadding (theWindow: WindowPtr): integer;	begin		GetWindowTopPadding := 2;	end;{-----------------------------------------------------------------------------}	function GetWindowBottomPadding (theWindow: WindowPtr): integer;	begin		GetWindowBottomPadding := 45;	end;{-----------------------------------------------------------------------------}	function GetWindowLeftPadding (theWindow: WindowPtr): integer;	begin		GetWindowLeftPadding := 2;	end;{-----------------------------------------------------------------------------}	function GetWindowRightPadding (theWindow: WindowPtr): integer;	begin		GetWindowRightPadding := 40;	end;{-----------------------------------------------------------------------------}	function GetWindowMaxContentHeight (theWindow: WindowPtr): integer;	begin		GetWindowMaxContentHeight := ScreenBoundsRect.bottom - ScreenBoundsRect.top - GetWindowTitleBarHeight(theWindow) - GetWindowBottomEdgeWidth(theWindow) - GetWindowTopPadding(theWindow) - GetWindowBottomPadding(theWindow);	end;{-----------------------------------------------------------------------------}	function GetWindowMaxContentWidth (theWindow: WindowPtr): integer;	begin		GetWindowMaxContentWidth := ScreenBoundsRect.right - ScreenBoundsRect.left - 2*GetWindowEdgeWidth(theWindow) - GetWindowLeftPadding(theWindow) - GetWindowRightPadding(theWindow);	end;{-----------------------------------------------------------------------------}	function GetWindowDefaultLeft (theWindow: WindowPtr): integer;	begin		GetWindowDefaultLeft := GetWindowEdgeWidth(theWindow) + GetWindowLeftPadding(theWindow);	end;{-----------------------------------------------------------------------------}	function GetWindowDefaultTop (theWindow: WindowPtr): integer;	begin		GetWindowDefaultTop :=GetWindowTitleBarHeight(theWindow) + GetWindowTopPadding(theWindow) + GetMBarHeight;	end;{|||||||||||||||||||||||||||||||||||||| DLOG Utilities |||||||||||||||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	procedure CenterDLOG (theDialog: DialogPtr);{centers DLOG on screen horizontally, one-third of the way down vertically}		var			hor, ver: integer;			menubarheight : integer;	begin		menubarheight := GetMBarHeight;		hor := (ScreenBoundsRect.right - (WindowPortRect(myGetWindowPtrForDialog(theDialog)).right - WindowPortRect(myGetWindowPtrForDialog(theDialog)).left)) div 2;		ver := (ScreenBoundsRect.bottom - (WindowPortRect(myGetWindowPtrForDialog(theDialog)).bottom - WindowPortRect(myGetWindowPtrForDialog(theDialog)).top) - menubarheight) div 3 + menubarheight;		MoveWindow(myGetWindowPtrForDialog(theDialog), hor, ver, false);	end;{-----------------------------------------------------------------------------}	procedure StartDLOG (ID: integer; var theDialog: DialogPtr; var tempP: WindowPtr);	var os: OSStatus;	begin		SetCursorToArrow;		theDialog := GetNewDialog(ID, nil, Pointer(-1));		if theDialog<> nil then			begin				CenterDLOG(theDialog);				genericGetPort(tempP);				genericSetPort(myGetWindowPtrForDialog(theDialog));			end;	end;{-----------------------------------------------------------------------------}	procedure EndDLOG (theDialog: DialogPtr; tempP: WindowPtr);	begin		if theDialog<>nil then			DisposeDialog(theDialog);		if tempP<> nil then			genericSetPort(tempP);		ShowCursor;		updateHasPriority := editorOpen;		//updateHasPriority := true;	end;{----------------------------------------------------------------------------}	procedure SetBasicDLOGFilterHandling (theDialog: DialogPtr; okButton,cancelButton: integer; hasEditable: boolean);	var os: OSStatus;	begin 		if okButton > 0 then 			os := SetDialogDefaultItem (theDialog, okButton);		if cancelButton > 0 then			os := SetDialogCancelItem (theDialog, cancelButton);		if hasEditable then			os := SetDialogTracksCursor (theDialog, true);    	end;{-----------------------------------------------------------------------------}	procedure TwoRadioDialog (ID: integer; var theBoolean: boolean; isupper: boolean);{not actually used yet}{a generic procedure to handle dialog boxes with two radio buttons: }{receives in theBoolean the boolean that is controlled by the radiobuttons}{if isupper is true, then the upper (item 3) radiobutton is on when theBoolean is true}{if isupper is false, then the lower (item 4) radiobutton is on when theBoolean is true}		var			localItemHit: integer;			theDialog: DialogPtr;			oldboolean: boolean;			tempP: WindowPtr;{............}		procedure CheckTwoRadOptions;		begin			ItemCheckMark(theDialog, 3, (theBoolean and isupper) or (not theBoolean and not isupper));			ItemCheckMark(theDialog, 4, (theBoolean and not isupper) or (not theBoolean and isupper));		end;{............}	begin		oldBoolean := theBoolean;		StartDLOG(ID, theDialog, tempP);		CheckTwoRadOptions;		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			if localItemHit = 3 then				theBoolean := isupper			else if localItemHit = 4 then				theBoolean := not isupper;			CheckTwoRadOptions;		until localItemHit in [1, 2];		if localItemHit = 2 then			theBoolean := oldboolean;		EndDLOG(theDialog, tempP);	end;{$IFC FALSE}{-----------------------------------------------------------------------------}	procedure StartHiddenDLOG (var theDialog: DialogPtr);		var			tempP: WindowPtr;			box: rect;	begin		SetRect(box, -10010, -10010, -10000, -10000);		genericGetPort(tempP);		theDialog := NewDialog(nil, box, '', true, dBoxProc, Pointer(-1), false, 0, nil);		genericSetPort(tempP);	end;{-----------------------------------------------------------------------------}	procedure EndHiddenDLOG (theDialog: DialogPtr);		var			tempP: WindowPtr;	begin		genericGetPort(tempP);		DisposeDialog(theDialog);		genericSetPort(tempP);	end;{$ENDC}{----------------------------------------------------------------------------}	function GetDLOGItemBox (theDialog: DialogPtr; num: integer): rect;		var			H: Handle;			itemtype: integer;			box: rect;	begin		if theDialog=nil then			SetRect(box,0,0,10,10)		else			GetDialogItem(theDialog, num, itemtype, H, box);		GetDLOGItemBox := box;	end;{-----------------------------------------------------------------------------}	procedure EnableDisableDLOGItem (theDialog: DialogPtr; theItem: integer; turnon, uncheck: boolean);{Enables or Disables Items in DLOG - enables if turnon is true, disables if turnon is false}{if uncheck is true, will uncheck the item too (obviously should only be used for radio and check buttons)}		var			box: rect;			itype: integer;			H: Handle;	begin		GetDialogItem(thedialog, theitem, itype, H, box);{$IFC NOT ALWAYSENABLED}		if not turnon then			begin				HiliteControl(controlhandle(H), off);				if uncheck then					ItemCheckMark(theDialog, theItem, false);			end		else{$ENDC}			HiliteControl(controlhandle(H), on);	end;{----------------------------------------------------------------------------}	function GetDLOGItemHandle (theDialog: DialogPtr; num: integer): Handle;		var			H: Handle;			itemtype: integer;			box: rect;	begin		GetDialogItem(theDialog, num, itemtype, H, box);		GetDLOGItemHandle := H;	end;{-----------------------------------------------------------------------------}	procedure HideButton (theDialog: DialogPtr; itemNum: integer);	begin		HideControl(controlHandle(GetDLOGItemHandle(theDialog, itemNum)));	end;{----------------------------------------------------------------------------}	procedure InvertDLOGItem (theDialog: DialogPtr; num: integer);		var			H: Handle;			itemtype: integer;			box: rect;	begin		GetDialogItem(theDialog, num, itemtype, H, box);		InvertRect(box);	end;{-----------------------------------------------------------------------------}	procedure FrameButton (theDialog: DialogPtr; ItemNo: integer);{frames a button so that it has the thick line around it indicating that it is the default button}		var			itemtype: integer;			H: Handle;			box: rect;			os: OSErr;	begin		{GetDialogItem(theDialog, ItemNo, itemtype, H, box);		InsetRect(box, -4, -4);		PenSize(3, 3);		FrameRoundRect(box, 16, 16);		PenNormal;}		os := SetDialogDefaultItem(theDialog,itemNo);	end;{-----------------------------------------------------------------------------}	function PressButton (theDialog: DialogPtr; theButton: integer): integer;		var			itemtype: integer;			H: Handle;			box: rect;	begin		GetDialogItem(theDialog, theButton, itemtype, H, box);		InvertRoundRect(box, 10, 10);		Delay(10, ticks);		InvertRoundRect(box, 10, 10);		PressButton := theButton;	end;{-----------------------------------------------------------------------------}	procedure DrawResourceTEXT (theDialog: DialogPtr; itemNum: integer; resID: integer);{draws text from TEXT resource ID into the box of itemNum in theDialog}		var			H: Handle;			box: rect;			oldfont, oldsize: integer;	begin		oldfont := QDThePortTextFont;		oldsize := QDThePortTextSize;		textfont(kFontIDGeneva);		textsize(9);		box := GetDLOGItemBox(theDialog, itemNum);		H := GetResource('TEXT', resID);		HLock(H);		TETextBox(Pointer(GetMaster(H)), GetHandleSize(H), box, teJustLeft);		HUnlock(H);		ReleaseResource(H);		textfont(oldfont);		textsize(oldsize);	end;{-----------------------------------------------------------------------------}	procedure ItemCheckMark (theDialog: DialogPtr; ItemNo: integer; turnon: boolean);		var			ItemType: Integer;			ItemBox: Rect;			ItemHdl: Handle;	begin		GetDialogItem(theDialog, ItemNo, ItemType, ItemHdl, ItemBox);		if turnon then			SetControlValueLong(ControlRef(ItemHdl), 1)		else			SetControlValueLong(ControlRef(ItemHdl), 0);	end;{|||||||||||||||||||||||||||||||||||||| ALRT Utilities |||||||||||||||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	function DoAlert (ID: integer; Atype: integer): Integer;{general procedure to handle alerts}		var			tempP: WindowPtr;			ver, hor: integer;			H: AlertTHndl;			trect: rect;	begin{===== centering Alert =====}		SetCursorToArrow;		H := AlertTHndl(GetResource('ALRT', ID));		if H = nil then Exit(DoAlert);		HNoPurge(Handle(H));		trect := H^^.boundsrect;		with trect do			begin				hor := (ScreenBoundsRect.right - (right - left)) div 2;				ver := (ScreenBoundsRect.bottom - (bottom - top) - GetMBarHeight) div 3 + GetMBarHeight;			end;		OffsetRect(tRect, hor - tRect.left, ver - tRect.top);		H^^.boundsrect := trect;{===== doing Alert =====}		genericGetPort(tempP);		case Atype of			CautionA: 				DoAlert := CautionAlert(ID, nil);			StopA: 				DoAlert := StopAlert(ID, nil);			NoteA: 				DoAlert := NoteAlert(ID, nil);			GenericA: 				DoAlert := Alert(ID, nil);			otherwise				;		end;		HPurge(Handle(H));		genericSetPort(tempP);		updateHasPriority := editorOpen;	end;{--------------------------------------------------------------------------------}	procedure DrawThermos;		var			awindow: WindowPtr;	begin		if (frontwindow <> nil) & (myGetWindowKind(frontwindow) = dialogKind) then			begin				DrawDialog(myGetDialogPtrForWindow(frontwindow));				aWindow := myGetNextWindow(frontWindow);				if (aWindow <> nil) & (myGetWindowKind(aWindow) = dialogKind) then					DrawDialog(myGetDialogPtrForWindow(aWindow));			end;	end;{----------------------------------------------------------------------------}	function IsTextWindow (windP: WindowPtr): boolean;		var			db: boolean;			j: integer;	begin		db := false;		if windP<> nil then			for j := 1 to numTextWindows do				if windP = textWindow[j] then					begin						db := true;						leave;					end;		IsTextWindow := db;	end;{----------------------------------------------------------------------------}	function TextWindowLocked(whichText:integer): boolean;	begin		TextWindowLocked := (whichText = NexusBlockText) & Locked(lockNexusBlocks);	end;{----------------------------------------------------------------------------}	function IsEditableTextWindow(windP: WindowPtr): boolean;		var			db: boolean;			j: integer;	begin		db := false;		if windP<> nil then			for j := 1 to numTextWindows do				if windP = textWindow[j] then					begin						db := true;						if  (j = NexusBlockText) & Locked(lockNexusBlocks) then							db := false;						leave;					end;		IsEditableTextWindow := db;	end;{----------------------------------------------------------------------------}	function WhichTextWindow (windP: WindowPtr): integer;		var			whichText: integer;			j: integer;	begin		whichText := -1;		if windP<> nil then			for j := 1 to numTextWindows do				if windP = textWindow[j] then					begin						whichText := j;						leave;					end;		WhichTextWindow := whichText;	end;{----------------------------------------------------------------------------}	function IsPaletteWindow (windP: WindowPtr): boolean;		var			db: boolean;			j: integer;	begin		db := false;		if windP<> nil then			for j := 1 to numToolPalettes do				if windP = toolPaletteWindow[j] then					begin						db := true;						leave;					end;		IsPaletteWindow := db;	end;{----------------------------------------------------------------------------}	function WhichPaletteWindow (windP: WindowPtr): integer;		var			whichToolPalette: integer;			j: integer;	begin		whichToolPalette := -1;		if windP<> nil then			for j := 1 to numToolPalettes do				if windP = toolPaletteWindow[j] then					begin						whichToolPalette := j;						leave;					end;		WhichPaletteWindow := whichToolPalette;	end;{----------------------------------------------------------------------------}	function IsInfoWindow (windP: WindowPtr): boolean;		var			db: boolean;			j: integer;	begin		db := false;		if windP<> nil then			for j := 1 to numInfoWindows do				if windP = infowindow[j] then					begin						db := true;						leave;					end;		IsInfoWIndow := db;	end;{----------------------------------------------------------------------------}	function WhichInfoWindow (windP: WindowPtr): integer;		var			whichinfo: integer;			j: integer;	begin		whichinfo := -1;		if windP<> nil then			for j := 1 to numInfoWindows do				if windP = infowindow[j] then					begin						whichinfo := j;						leave;					end;		WhichInfoWindow := whichinfo;	end;{-----------------------------------------------------------------------------}	function IsEditorWindow (windP: WindowPtr): boolean;	begin		IsEditorWindow := (windP <> nil) & ((windP = editorWindow)  | (windP = toolPaletteWindow[editorTools]));	end;{-----------------------------------------------------------------------------}	function MacCladeWindow (WindP: WindowPtr): boolean;		begin		MacCladeWindow := (windP<> nil) & ((windP = editorWindow) | (windP = twmesswindow) |  (windP = stateswindow) | (windP = tlegwindow) | (windP = chlegwindow) | (IsInfoWindow(windP)) | IsPaletteWindow(windP) | (windP = pictwindow) | (windP = ChartWindow) | (windP = BranchListwindow) | (windP = treewindow) | (windP = myGetWindowPtrForDialog(searchThermo)) | (windP = myGetWindowPtrForDialog(ioThermo)) |(windP = myGetWindowPtrForDialog(thermo1Window)) |(windP = myGetWindowPtrForDialog(thermo2Window)) |IsTextWindow(windP));	end;{----------------------------------------------------------------------------}	function LockedToTreeWindow(theWindow: WindowPtr): boolean;	begin 	   IF theWindow <> NIL then	   	LockedToTreeWindow := GetWindowType(theWindow) = TWLock	   else	   	LockedToTreeWindow := false;	end;{----------------------------------------------------------------------------}	procedure SetUpdatesAllowed(theWindow: WindowPtr; on: boolean);	begin 	   	if MacCladeWindow(theWindow) then	   		 windowInfoP(GetWindowRefCon(theWindow))^.updatesAllowed := on;	end;{----------------------------------------------------------------------------}	procedure DisableWindowUpdates(theWindow: WindowPtr);	begin 	   	SetUpdatesAllowed(theWindow,false);		end;{----------------------------------------------------------------------------}	function CanUpdateWindow(theWindow: WindowPtr): boolean;	begin 	   	CanUpdateWindow := MacCladeWindow(theWindow) & (windowInfoP(GetWindowRefCon(theWindow))^.updatesAllowed);	end;{----------------------------------------------------------------------------}	procedure InvalidateWindowMarkedUnUpdatable(theWindow: WindowPtr);	begin		if not CanUpdateWindow(theWindow) then			begin				SetUpdatesAllowed(theWindow,true);				InvalidateWindow(theWindow,true);			end	end;{----------------------------------------------------------------------------}	procedure  InvalidateAllWindowsMarkedUnupdatable;	var j: integer;	begin 		InvalidateWindowMarkedUnUpdatable(editorWindow);		InvalidateWindowMarkedUnUpdatable(twmesswindow);		InvalidateWindowMarkedUnUpdatable(stateswindow);		InvalidateWindowMarkedUnUpdatable(tlegwindow);		InvalidateWindowMarkedUnUpdatable(chlegwindow);		InvalidateWindowMarkedUnUpdatable(ChartWindow);		InvalidateWindowMarkedUnUpdatable(BranchListwindow);		InvalidateWindowMarkedUnUpdatable(treewindow);		InvalidateWindowMarkedUnUpdatable(pictwindow);		for j := 1 to numInfoWindows do			InvalidateWindowMarkedUnUpdatable(infoWindow[j]);		for j := 1 to numToolPalettes do			InvalidateWindowMarkedUnUpdatable(toolPaletteWindow[j]);		for j := 1 to numTextWindows do			InvalidateWindowMarkedUnUpdatable(textWindow[j]);	end;{----------------------------------------------------------------------------}	procedure  InvalidateAllWindows;	var j: integer;	begin 		InvalidateWindow(editorWindow,true);		InvalidateWindow(twmesswindow,true);		InvalidateWindow(stateswindow,true);		InvalidateWindow(tlegwindow,true);		InvalidateWindow(chlegwindow,true);		InvalidateWindow(ChartWindow,true);		InvalidateWindow(BranchListwindow,true);		InvalidateWindow(treewindow,true);		InvalidateWindow(pictwindow,true);		for j := 1 to numInfoWindows do			InvalidateWindow(infoWindow[j],true);		for j := 1 to numToolPalettes do			InvalidateWindow(toolPaletteWindow[j],true);		for j := 1 to numTextWindows do			InvalidateWindow(textWindow[j],true);	end;{----------------------------------------------------------------------------}	function  UpdatePendingOnAnyMacCladeWindow: boolean;	var pending: boolean;		j: integer;	begin 		pending := UpdatePending(editorWindow) | UpdatePending(twmesswindow) | UpdatePending(stateswindow);		pending := pending | UpdatePending(tlegwindow) | UpdatePending(chlegwindow) | UpdatePending(chartwindow);		pending := pending | UpdatePending(branchlistwindow) | UpdatePending(treewindow) | UpdatePending(pictwindow);		if not pending then			for j := 1 to numInfoWindows do				pending := pending | UpdatePending(infoWindow[j]);		if not pending then			for j := 1 to numToolPalettes do				pending := pending | UpdatePending(toolPaletteWindow[j]);		if not pending then			for j := 1 to numTextWindows do				pending := pending | UpdatePending(textWindow[j]);		UpdatePendingOnAnyMacCladeWindow := pending;	end;{----------------------------------------------------------------------------}	procedure SetWindowType(theWindow: WindowPtr; windowType: integer);	begin 	   	if MacCladeWindow(theWindow) then	   		 windowInfoP(GetWindowRefCon(theWindow))^.windowType := windowType;	end;{----------------------------------------------------------------------------}	function GetWindowType(theWindow: WindowPtr): integer;	var wip: windowInfoP;	begin 	   	if theWindow  = nil then	   		GetWindowType := notTWWindow	   	else if MacCladeWindow(theWindow) then	   		begin	   			wip:= windowInfoP(GetWindowRefCon(theWindow));	   			if (wip<> nil) then	   				GetWindowType := windowInfoP(GetWindowRefCon(theWindow))^.windowType	   			else	   				GetWindowType := notTWWindow;	   		end	   	else	   		GetWindowType := notTWWindow;	end;{-----------------------------------------------------------------------------}	function IsTreeWindow (windP: WindowPtr): boolean;	begin		IsTreeWindow := ((windP = treewindow) | (windP = tlegwindow) | (windP = chlegwindow) | (windP = twmesswindow) | (windP = branchlistwindow) | (windP = toolPaletteWindow[treeTools]));	end;{-----------------------------------------------------------------------------}	function WindowInView (WindP: WindowPtr): boolean;		var			box: rect;	begin		box := myGetVisRgnBounds(windP);		WindowInView := WindowVisible(windP) & ((box.right - box.left) > 25) & ((box.bottom - box.top) > 25);	end;{-----------------------------------------------------------------------------}	procedure InvalidateInfoWindow (whichinfo: integer);	begin		if infoOpen[whichinfo] then			InvalidateWindow(infowindow[whichinfo], false);	end;{-----------------------------------------------------------------------------}	function WindowBotRightOnScreen (windowP: WindowPtr; vertscroll: boolean; drawinglimit: integer): boolean;{tests to see if bottom right corner of drawing region of window is off screen;  used for}{scrolling - if corner is off screen, do full redraw, otherwise do just row or column}		var			screenEdge: integer;			pt: point;			tport: windowptr;	begin		if vertscroll then			begin				pt.v := drawinglimit;				pt.h := 0;			end		else			begin				pt.v := 0;				pt.h := drawinglimit;			end;		genericGetPort(tport);		genericSetPort(windowP);		LocalToGlobal(pt);		genericSetPort(tport);		if vertscroll then			drawinglimit := pt.v		else			drawinglimit := pt.h;{v4: use GetGrayRgn^^.rgnBBox}		if vertScroll then			screenEdge := ScreenBoundsRect.bottom		else			screenEdge := ScreenBoundsRect.right;		WindowBotRightOnScreen := drawingLimit <= screenEdge;	end;{----------------------------------------------------------------------------}	function UpdatePending (WindP: WindowPtr): boolean;	begin		UpdatePending := not EmptyRgn(myGetUpdateRgn(WindP));	end;{-----------------------------------------------------------------------------}	procedure HugTwoScrolls (theWindow: WindowPtr; Hleft, Vtop, Vgap: integer; HScroll, VScroll: ControlRef);{this procedure moves two scrollbars so that they hug the right and bottom of the window}		var			tport: windowptr;	begin		genericGetPort(tport);		genericSetPort(theWindow);		ClipRect(WindowPortRect(theWindow));		if VScroll <> nil then			begin				SizeControl(VScroll, scrollwidth + 1, WindowPortRect(theWindow).bottom - Vtop - scrollwidth-Vgap);				MoveControl(VScroll, WindowPortRect(theWindow).right - scrollwidth, Vtop);				ShowControl(VScroll);			end;		if HScroll <> nil then			begin				SizeControl(HScroll, WindowPortRect(theWindow).right - scrollwidth - Hleft, scrollwidth + 1);				MoveControl(HScroll, HLeft, WindowPortRect(theWindow).bottom - scrollwidth-Vgap);				ShowControl(HScroll);			end;		genericSetPort(tport);	end;{----------------------------------------------------------------------------}	procedure StoreFrontWindows;		var			j: integer;	begin		oldfrontW[0] := frontwindow;		j := 0;		while (j < numfrontW) & (oldfrontW[j] <> nil) & (GetWindowType(oldfrontW[j]) > TWLock) do			begin				j := j + 1;				oldfrontW[j] := myGetNextWindow(oldfrontW[j - 1]);			end;		numFW := j - 1;	end;{----------------------------------------------------------------------------}	procedure RestoreFrontWindows;		var			j: integer;	begin		j := numFW;		while (j >= 0) & (oldfrontW[j] <> nil) do			if (oldfrontW[j] <> nil) & (GetWindowType(oldfrontW[j]) > TWLock) then				begin					SelectWindow(oldfrontW[j]);					j := j - 1;				end			else				leave;	end;{----------------------------------------------------------------------------}	function PixelDepth: integer;	 var		GDH:GDHandle;	 begin		GDH:= GetGDevice;		PixelDepth := GDH^^.gdPMap^^.pixelSize;	end;{-----------------------------------------------------------------------------}	function WindowInColor (windowP: WindowPtr): boolean;	begin		if colorQDexists then			begin{see IM V p. V-52  -first two bytes of this field = 1 if color grafport}{				if BitTst(@windowP^.portBits.rowBytes, 0) and BitTst(@windowP^.portBits.rowBytes, 1) then					WindowInColor := CGrafPtr(windowP)^.portPixMap^^.pixelSize >= 3				else}					WindowInColor := PixelDepth>=8;			end		else			WindowInColor := false;	end;{-----------------------------------------------------------------------------}	procedure CheckPixelDepth (windowP: WindowPtr);	begin		ScreenInColor := WindowInColor(windowP);		if not ColorPort then			begin				branchShades[curTrace] := branchPatterns;				if nex7on & not (traceshown = traceDiscrete) then					branchShades[traceDiscrete] := branchPatterns;			end		else if userBranchShades[curTrace] <> noBranchShades then			branchShades[curTrace] := userBranchShades[curTrace]		else			branchShades[curTrace] := defBranchShades[curTrace];		BackColor(whitecolor);	end;{-----------------------------------------------------------------------------}	function WarnCantUndo: boolean;	var result: integer;	begin		WarnCantUndo := true;		if warnIfCantUndo then			begin				result := DoAlert(150, cautionA);				case result of					1:  WarnCantUndo := true;					2 : WarnCantUndo := false;					3 : 	begin								warnIfCantUndo := false;							WarnCantUndo := true;						end;				otherwise					WarnCantUndo := false;				end;			end;	end;{-----------------------------------------------------------------------------}	function WarnCantUndoLowMemory: boolean;	var result: integer;	begin		if warnIfCantUndo then			begin				result := DoAlert(149, cautionA);				case result of					1:  WarnCantUndoLowMemory := true;					2 : WarnCantUndoLowMemory := false;					3 : 	begin								warnIfCantUndo := false;							WarnCantUndoLowMemory := true;						end;				otherwise					WarnCantUndoLowMemory := false;				end;			end;	end;{----------------------------------------------------------------------------}	procedure SetEWClip (themode: signedbyte);	const rowNameEndAdd = 0;  {in 4.0b10, was -1}		titleWidthAdd = 0; {sets the clipping region to be used for various scrolling and non-scrolling editor operations}{v4: check this whole business to make sure it is OK}	begin		case themode of			noscroll: 				begin					OpenRgn;					Moveto(0, editorTitlesWidth + titleWidthAdd);					LineTo(editorRowNameEnd + rowNameEndAdd, editorTitlesWidth + titleWidthAdd);					LineTo(editorRowNameEnd + rowNameEndAdd, 0);					LineTo(editorBoundaryRect.right, 0);					LineTo(editorBoundaryRect.right, editorBoundaryRect.bottom);					LineTo(0, editorBoundaryRect.bottom);					LineTo(0, editorTitlesWidth + titleWidthAdd);					CloseRgn(EWClip);				end;			vertscroll: 				begin					OpenRgn;					Moveto(0, editorFirstRowTop);					LineTo(editorBoundaryRect.right, editorFirstRowTop);					LineTo(editorBoundaryRect.right, editorBoundaryRect.bottom);					LineTo(0, editorBoundaryRect.bottom);					LineTo(0, editorFirstRowTop);					CloseRgn(EWClip);				end;			horscroll: 				begin					OpenRgn;					MoveTo(editorFirstColumnLeft, 0);					LineTo(editorBoundaryRect.right, 0);					LineTo(editorBoundaryRect.right, editorBoundaryRect.bottom);					LineTo(editorFirstColumnLeft, editorBoundaryRect.bottom);					LineTo(editorFirstColumnLeft, 0);					CloseRgn(EWClip);				end;			justdata: 				begin					OpenRgn;					MoveTo(editorFirstColumnLeft + rowNameEndAdd, editorFirstRowTop + titleWidthAdd);					LineTo(editorMatrixRect.right, editorFirstRowTop + titleWidthAdd); {- 1}					LineTo(editorMatrixRect.right, editorMatrixRect.bottom);{ - 1}{ - 1}					LineTo(editorFirstColumnLeft + rowNameEndAdd, editorMatrixRect.bottom); {- 1}					LineTo(editorFirstColumnLeft + rowNameEndAdd, editorFirstRowTop + titleWidthAdd);					CloseRgn(EWClip);				end;			justdataAndConsenses: 				begin					OpenRgn;					MoveTo(editorRowNameEnd + rowNameEndAdd, editorTitlesWidth + titleWidthAdd);					LineTo(editorMatrixRect.right, editorTitlesWidth + titleWidthAdd); {- 1}					LineTo(editorMatrixRect.right, editorMatrixRect.bottom);{ - 1}{ - 1}					LineTo(editorRowNameEnd + rowNameEndAdd, editorMatrixRect.bottom); {- 1}					LineTo(editorRowNameEnd + rowNameEndAdd, editorTitlesWidth + titleWidthAdd);					CloseRgn(EWClip);				end;			justdataAndCharacters: 				begin					OpenRgn;					MoveTo(editorFirstColumnLeft, 0);					LineTo(editorMatrixRect.right, 0); {- 1}					LineTo(editorMatrixRect.right, editorMatrixRect.bottom);{ - 1}{ - 1}					LineTo(editorFirstColumnLeft, editorMatrixRect.bottom); {- 1}					LineTo(editorFirstColumnLeft, 0);					CloseRgn(EWClip);				end;			otherwise				;		end;	end;{-----------------------------------------------------------------------------}	function WindowOffScreen(theWindow: WindowPtr):boolean;	begin	end;{----------------------------------------------------------------------------}	function GetWindowOrder (windP: WindowPtr): integer;	var windowInfo : windowInfoP;	begin		GetWindowOrder := 0;		if windP<> nil then			begin				windowInfo := WindowInfoP(GetWindowRefCon(windP));				if windowInfo<> nil then					GetWindowOrder := windowInfo^.order;			end;	end;{----------------------------------------------------------------------------}	function WindowVisible(theWindow: WindowPtr): boolean;	begin		if (theWindow=nil) then			WindowVisible := false		else{$IFC NOT CARBON}			WindowVisible := WindowPeek(theWindow)^.visible;{$ELSEC}			WindowVisible := IsWindowVisible(theWindow);{$ENDC}	end;{----------------------------------------------------------------------------}	procedure SetWindowOrder (windP: WindowPtr; theOrder: integer);	var windowInfo : windowInfoP;	begin		if windP<> nil then			begin				windowInfo := WindowInfoP(GetWindowRefCon(windP));				if windowInfo<> nil then					windowInfo^.order := theOrder;			end;	end;{----------------------------------------------------------------------------}	function GetWindowName (windP: WindowPtr): str15;	var windowInfo : windowInfoP;	begin		GetWindowName := '';		if windP <> nil then			begin				windowInfo := WindowInfoP(GetWindowRefCon(windP));				if windowInfo<> nil then					GetWindowName := windowInfo^.name;			end;	end;{----------------------------------------------------------------------------}	procedure SetWindowName (windP: WindowPtr; name: str15);	var windowInfo : windowInfoP;	begin		if windP<> nil then			begin				windowInfo := WindowInfoP(GetWindowRefCon(windP));				if windowInfo<> nil then					windowInfo^.name := name;			end;	end;{-----------------------------------------------------------------------------}	function WindowBoxStorageSizingAllowed(windowInfo: windowInfoP): boolean;	var topLeftVisibleEnough,windowReasonableSize : boolean;		box: rect;		mb: integer;	begin		mb := GetMBarHeight;		box := ScreenBoundsRect;		topLeftVisibleEnough := (windowInfo^.left> 2) &(windowInfo^.left< ScreenBoundsRect.right-50) & (windowInfo^.top> GetMBarHeight+2)& (windowInfo^.top< ScreenBoundsRect.bottom-50);		windowReasonableSize :=(windowInfo^.left+windowInfo^.width< ScreenBoundsRect.right-ScreenBoundsRect.left) & (windowInfo^.top+windowInfo^.height< ScreenBoundsRect.bottom -ScreenBoundsRect.top);  //-GetMBarHeight) ;  removed in v4.06		WindowBoxStorageSizingAllowed := topLeftVisibleEnough & windowReasonableSize;	end;{-----------------------------------------------------------------------------}	function SizeWindowByBoxStorage(theWindow: WindowPtr): boolean;	var windowInfo : windowInfoP;	begin		SizeWindowByBoxStorage := false;		if theWindow<> nil then			begin				windowInfo := WindowInfoP(GetWindowRefCon(theWindow));				if WindowBoxStorageSizingAllowed(windowinfo) then					begin						MoveWindow(theWindow,windowInfo^.left, windowInfo^.top, false);						if theWindow=editorWindow then							begin								maxEWR.right := maxEWR.left + windowInfo^.width;								maxEWR.bottom := maxEWR.top + windowInfo^.height;							end						else if theWindow=treeWindow then							begin								maxTWR.right := maxTWR.left + windowInfo^.width;								maxTWR.bottom := maxTWR.top + windowInfo^.height;								treeWindowPositionRead := true;							end						else							SizeWindow(theWindow, windowInfo^.width, windowInfo^.height, false);						SizeWindowByBoxStorage := true;					end;			end;	end;{-----------------------------------------------------------------------------}end.