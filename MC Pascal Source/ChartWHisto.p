unit ChartWHisto;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, 		Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, 		EventUtil, GenUtil, BoxUtil, CharUtil, StrUtil, MenuUtil, TreeUtil, SymbolsNames, 		TypeUtil, TaxonCHUtil, PrintingUtil, ChartWUtil, ChartWTable, ChartWScatter, CharPartitions;	procedure DrawHistogram (boundary: rect);{еееееееееееееееееееееее}implementation {е$S ChartWHisto}{-----------------------------------------------------------------------------}	function MaxNumberWidth (maxnum: longint): integer;		var			ds: str255;			j: integer;	begin		ds := StringFromNum(maxnum);		for j := 1 to length(ds) do			ds[j] := '0';		MaxNumberWidth := StringWidth(ds);	end;{-----------------------------------------------------------------------------}	function Nearest50 (tempticks: longint): longint;		var			near: longint;			j: integer;	begin		near := 1;		if tempticks > 1 then			begin				for j := 1 to 9 do  {v4: note that 4 e9 is the largest longint}					begin						near := near * 10;						if tempticks < near then							leave;					end;				if tempticks < near div 2 then					near := near div 2;			end;		Nearest50 := near;	end;{-----------------------------------------------------------------------------}	function TicksInterval (labelsize: integer; unitwidth: double): longint;	begin		TicksInterval := RoundValue(labelsize / unitwidth);	end;{-----------------------------------------------------------------------------}	var		maxcatvalue, mincatvalue, absmincatvalue: longint;{-----------------------------------------------------------------------------}	procedure DrawHistogram (boundary: rect);		label			1, 2;		const			vertaxisgap = 5;			adj = 5;		var			implicitZeroChartOrigin: boolean;			info: FontInfo;			boxLong: longRect;			catbox,boxSmall: rect;			j, catint, freqint, baseline: longint;			catwidth, catheight, LS, RS, maxright, SHA, rightLong: longint;			longChartLinear, minaxisvalue, maxaxisvalue: longint;			freqheight, cicat: double;			ds: str255;			tport: WindowPtr;			tclip: RgnHandle;			numtoshow, theBar: integer;			settoshow: set15;			firstint, lastint: longint;			firstcatlabel: boolean;			vertCatString: boolean;			CatNameHeight, CatStringLength: integer;			firstlabelstart: longint;			showLegend: boolean;			oldCWPercent, ticksOnLeft: boolean;			oldstate: SignedByte;{............}		function ValueHeight (theValue: longint): integer;		begin			ValueHeight := boxLong.bottom - RoundValue((thevalue + minaxisvalue) * freqheight);		end;{............}		function leftside (theinterval: longint): longint;		begin			leftside := (theinterval - chartorigin) * pixwid + boxLong.left;		end;{............}		function rightside (theinterval: longint): longint;		begin			rightside := (theinterval - chartorigin + 1) * pixwid + boxLong.left;		end;{............}		function drawtickhere (theinterval: longint): boolean;		begin{SHA means shift horizontal axis - it records the origin of the chart}			drawtickhere := ((theinterval + SHA) mod catint = 0) or (CWChart = CWCStates);		end;{............}		procedure VertAxisLabel (onleft: boolean);			var				shift, horspot: longint;		begin			with boxLong do				begin					shift := IntegerMax(MaxNumberWidth(-minaxisvalue), MaxNumberWidth(maxaxisvalue)) + adj + vertaxisgap;					if datainflation > 1 then						shift := shift + CharWidth('.') + 4;					if CIRIData then						shift := shift + StringWidth('0.');					if onleft then						begin{$IFC CUMUL}							if (cumview in [cumup, cumdown]) and CWLinear then								shift := shift + fontheight;{$ENDC}							horspot := left - shift - info.descent;						end					else						horspot := right + shift + info.ascent;				end;			with boxLong do				if CWChart in [CWCC2T, CWCC2TF] then					begin						if maxaxisvalue > 0 then							begin								if C2TsayShorter then									begin										if CWChart = CWCC2T then											ds := concat(LinkNameFromChain(treechain, twotrees[1]), ' shorter ')										else											ds := concat(extratreefilename[2]^^, ' shorter ');									end								else									begin										if CWChart = CWCC2T then											ds := concat(LinkNameFromChain(treechain, twotrees[0]), ' longer ')										else											ds := concat(extratreefilename[1]^^, ' longer ');									end;								GetClip(tclip);								DualVerticalString(ds, tclip, horspot, baseline - (baseline - top - StringWidth(ds)) div 2);							end;						if minaxisvalue > 0 then							begin								if C2TsayShorter then									begin										if CWChart = CWCC2T then											ds := concat(LinkNameFromChain(treechain, twotrees[0]), ' shorter ')										else											ds := concat(extratreefilename[1]^^, ' shorter ');									end								else									begin										if CWChart = CWCC2T then											ds := concat(LinkNameFromChain(treechain, twotrees[1]), ' longer ')										else											ds := concat(extratreefilename[2]^^, ' longer ');									end;								GetClip(tclip);								DualVerticalString(ds, tclip, horspot, baseline + StringWidth(ds) + (bottom - baseline - StringWidth(ds)) div 2);							end;					end				else if CWChart = CWCProbSteps then					begin						ds := 'Probability';						GetClip(tclip);						DualVerticalString(ds, tclip, horspot, top + (bottom - top + StringWidth(ds)) div 2);					end				else  {not in in [CWCC2T, CWCC2TF]}					begin						if CWPercent then							ds := 'Percent of '						else							ds := 'Number of ';						if (CWChart = CWCCTall) then							begin								ds := concat(ds, 'Trees');							end						else if CWChart = CWCStates then							ds := concat(ds, 'Occurrences')						else							begin								if (CWChart = CWCSteps) and (sequencechart or positionchart) then									if not CWPercent then										ds := StepsChartUnits(CWStepsShow, true)									else										ds := concat(ds, StepsChartUnits(CWStepsShow, true))   {add 'percent'}								else if (CWChart = CWCSteps) and (CWTrees[CWCSteps] <> CWCurrentTree) then									ds := concat(ds, 'Trees')								else if CWChart = CWCcst then									ds := concat(ds, 'CSTs') {DRM CST}								else									ds := concat(ds, 'Characters');							end;						GetClip(tclip);						DualVerticalString(ds, tclip, horspot, top + (bottom - top + StringWidth(ds)) div 2);{$IFC CUMUL}						if (cumview in [cumup, cumdown]) and CWLinear then							DualVerticalString('(cumulative)', tclip, horspot + fontheight, top + (bottom - top + StringWidth(ds) - StringWidth('(cumulative)')) div 2);{$ENDC}					end;		end;{............}		procedure DrawBar (j, theCLkind, theBar: integer);			var				charHdl: chHdl;				divvalue: double;		begin			with boxLong do				begin					LS := leftside(j);					RS := LS + pixwid;					if not IntervalLegal(j) then						begin							SetRect(catbox, LS, baseline - 2, RS + 1, baseline + 3);							FillRect(catbox, QDBlack);							DimBox(catbox);						end					else						begin							if MeanSpotBar(theCLKind) then								divvalue := MeanInflate * catwid  {for thicker intervals, need to divide by more for mean}							else								divvalue := 1.0;							longChartLinear := GetChartLinearData(theCLkind, j); 				{store it in a longint so doesn't overflow on next line}							if longChartLinear = 0 then								catheight := 0							else if CWPercent and CW100Axis then								if maxcatvalue = 0 then									catheight := RoundValue(((100 * longChartLinear) div TotalChartLinear * 1.0 * (bottom - top)) / absMinCatValue / divvalue)								else									catheight := RoundValue(((100 * longChartLinear) div TotalChartLinear * 1.0 * (bottom - top)) / maxcatvalue / divvalue)							else								catheight := RoundValue((longChartLinear * 1.0 * (bottom - top)) / (maxcatvalue + absMinCatValue) / divvalue);							if catheight < 0 then								SetRect(catbox, LS, baseline, RS + 1, baseline - catheight)							else								SetRect(catbox, LS, baseline - catheight, RS + 1, baseline + 1);							if (chartColorMode=chartColorPartitions) & not onePartition & (sequenceChart) then								begin									RGBForeColor(GetPartNameColor(CharPartition(j+1)));								end							else if (chartColorMode=chartColorCodPos) & colorCodPosLegal then								begin									catbox.left := catbox.left + 1; {shrink left side just a bit so colors don't overlap}									charHdl := GetchHdl(j + 1);									case CharHdl^^.codpos of										nonCoding:											ForeColor(blackcolor);										codeNotSet:   											RGBForeColor(codeNotSetRGB);										1: 											RGBForeColor(blueRGB);										2: 											RGBForeColor(greenRGB);										3: 											RGBForeColor(redRGB);										otherwise											;									end;								end							else if ColorPort then								RGBForeColor(histocolor);							if MinMaxIrregular then								begin									PenMode(patOr);									PenPat(SpotBarPattern(numtoshow, theBar));									if theCLKind = CLmin then										RGBForeColor(blueRGB)									else										RGBForeColor(redRGB);									PaintRect(catbox);									PenNormal;								end							else								FillRect(catbox, SpotBarPattern(numtoshow, theBar));							PenNormal;							GetClip(tclip);							ClipRect(catbox);							FrameRect(catbox);							if ColorPort then								RGBForeColor(blackRGB);							PenNormal;							ForeColor(blackcolor);							SetClip(tclip);						end;				end;		end;{............}		function vertAxisTickLabel (j: longint): str255;			var				ds: str255;				divvalue: Longint;		begin			if DataInflation > 1 then				ds := RealToIntegerstring(j, DataInflation)			else				NumToString(j, ds);			VertAxisTickLabel := ds;		end;{.............}		function GetCatLabelStart (j: integer; ds: str255): longint;		begin			RS := rightside(j);			LS := leftside(j);			GetCatLabelStart := LS + (RS - LS - StringWidth(ds)) div 2;{$IFC FALSE}			if (CWChart = CWCStates) or ((CWChart = CWCSteps) and positionchart) or (catwid = 1) then {or (catwid = 1)} {}				GetCatLabelStart := LS + (RS - LS - StringWidth(ds)) div 2			else if catwid > 1 then				GetCatLabelStart := RS - StringWidth(ds) div 2			else				GetCatLabelStart := LS;{$ENDC}		end;{.............}		procedure DrawCatLabel (j: integer);			var				L: integer;				partds: str255;		begin			ds := CategoryString(j, 3, catint = 1, false);   {only do range if catint = 1}			if vertCatString then				begin					GetClip(tclip);					RS := rightside(j);					LS := leftside(j);					L := LS + (RS - LS - fontheight) div 2 + fontheight;					DualVerticalString(ds, tclip, L, boxLong.bottom + StringWidth(ds) + 4);				end			else				begin					L := GetCatLabelStart(j, ds);					moveto(L, boxLong.bottom + fontheight);					DrawString(ds);				end;			if not firstcatlabel then				firstlabelstart := L;			firstcatlabel := true;		end;{|||||||||||||||||||||||||||||||||||||||||||||||||||||||||}	begin		firstcatlabel := false;		vertCatString := false;		tclip := NewRgn;		emptychart := false;		if numIntervals[MaxSpotBarKind] > 0 then			begin				implicitZeroChartOrigin := (CWChart = CWCStates) | (CWChart = CWCCTall) | (not sequencechart & not positionchart & (CWChart = CWCSteps));				useLowCats := implicitZeroChartOrigin | (catwid = 1);				settoshow := SpotBarSetToShow;				numtoshow := NumSpotBar(settoshow);				GetFontInfo(info);				SetMenuItemText(FileMHdl, PrintingItem, 'Print Chart...');				if not chartAlreadyDrawn then					CalcMinMaxCatValues(mincatvalue, maxcatvalue);				if mincatvalue = maxcatvalue then					begin						case CWChart of							CWCStates: 								Chartmessage('All states uncertain or missing');							CWCSteps: 								if positionchart and (numCWChars = 0) then									Chartmessage('No appropriate coding regions')								else									case CWStepsShow of										CWStepsSteps: 											Chartmessage('No steps in characters');										CWStepsChanges: 											Chartmessage('No changes in characters');										CWStepsCI: 											Chartmessage('All CI''s zero or undefined');										CWStepsRI: 											Chartmessage('All RI''s zero or undefined');										CWStepsRC: 											Chartmessage('All RC''s zero or undefined');										otherwise											;									end;							CWCCTall: 								Chartmessage('All trees of length 0');							CWCC2T, CWCC2TF: 								Chartmessage('No consistent differences');							otherwise								;						end;						goto 2;					end;				absMinCatValue := abs(mincatvalue);				boxSmall := boundary;				InsetRect(boxSmall, IntegerMax(MaxNumberWidth(MinCatValue), MaxNumberWidth(MaxCatValue)) + 2 * fontheight + 15, 15);				boxSmall.top := boxSmall.top + fontheight div 2 + ChartImageTitleHeight;				if (chartColorMode=chartColorCodPos) & (numtoshow < 3) & colorCodPosLegal then					begin						boxSmall.bottom := boxSmall.bottom - scrollwidth - 3 * fontheight;						showlegend := true;					end				else					begin						boxSmall.bottom := boxSmall.bottom - scrollwidth - numtoshow * fontheight;						showlegend := numtoshow > 1;					end;{providing room for horizontal axis labelling and legend}				boxSmall.right := boxSmall.right - chartRightMargin;				maxright := boxSmall.right;				boxLong.top := boxSmall.top;				boxLong.bottom := boxSmall.bottom;				boxLong.left := boxSmall.left;				boxLong.right := boxSmall.right;				with boxLong do					begin{====== calculating width of bars =======}						if AutoPixWid or (pixwid > boxLong.right - boxLong.left - 2) then							pixwid := (right - left) div numIntervals[CLkind];						if pixwid < 1 then							pixwid := 1;						if (numtoshow > 1) and AutoPixWid then							if pixwid < 3 then								pixwid := 3;1:						if (right - left) > longint(pixwid) * numIntervals[CLkind] then							left := left + ((right - left) -  longint(pixwid) * numIntervals[CLkind]) div 2;						rightLong := left +  longint(pixwid) * longint(numIntervals[CLkind]);						if rightLong > maxright then							begin								right := maxright;								if savepicton then									chartintervals := numIntervals[CLkind]								else									chartintervals := (right - left) div pixwid;								right := left + Longint(pixwid) * chartintervals;								biggraph := true;							end						else							begin								right := rightLong;								biggraph := false;								chartintervals := numIntervals[CLkind];							end;						if (pixwid > 15) and (left < 40) and AutoPixWid then							begin								pixwid := pixwid * 3 div 4;								goto 1;							end;						if biggraph then							bottom := bottom - scrollwidth;{==== fixing scrolls=====}						ClipRect(boundary);						if not printon and not savepicton then							begin								if numIntervals[CLkind] - chartintervals < 0 then									SetControlMaximumLong(CWScroll, 0)								else									SetControlMaximumLong(CWScroll, numIntervals[CLkind] - chartintervals);								if GetControlValueLong(CWScroll) > GetControlMaximumLong(CWScroll) then									SetControlValueLong(CWScroll, GetControlMaximumLong(CWScroll));								if biggraph and isforeground then									ShowControl(CWScroll)								else									HideControl(CWScroll);								if chartorigin > GetControlMaximumLong(CWScroll) then									begin										chartorigin := GetControlMaximumLong(CWScroll);										SetControlValueLong(CWScroll, chartorigin);									end;							end;						if CIRICategory then							begin								catint := Nearest50(TicksInterval(StringWidth('0.0') + 4, 1.0 * pixwid));								if catint < 10 then									catint := 10;							end						else							begin								NumToString(maxChartLinearcat, ds);								for j := 1 to length(ds) do									ds[j] := '0';								catint := Nearest50(TicksInterval(StringWidth(ds) + StringWidth('01'), 1.0 * pixwid));							end;						if CWPercent and not CW100Axis then							if TotalChartLinear = 0 then								maxaxisvalue := 0							else								maxaxisvalue := RoundValue((maxcatvalue * 100.0) / TotalChartLinear)						else							maxaxisvalue := maxcatvalue;						minaxisvalue := absmincatvalue;						ticksOnLeft := (useLowCats) or CIRICategory;{(catwid > 1) and}{if catwid > 1, then put ticksonleft if useLowCats, as want tick nearest value reported}{minChartlinearCat is the lower category value of the first interval in the chart.}{SHA is the value by which the horizontal axis is "shifted", in terms of where ticks should}{be drawn.  Ticks are drawn ever catint intervals, but with the first of these intervals being}{interval  (catint -SHA). }						if useLowCats then							SHA := (minChartlinearcat div catwid) mod catint		{shift horizontal axis}						else							SHA := (minChartlinearcat div catwid) mod catint + 1;  {implicit origin is at 1,}{===== Calculating Height of category names =======}						if ((CWChart = CWCStates) and (datatype = protein)) or ((catwid > 1) and (catint = 1)) then{it is protein data states chart OR it has interval width >=2 AND each interval is labelled}							begin								CatNameHeight := 0;								for j := chartorigin + 1 to chartorigin + chartintervals - 1 do									if j <= numIntervals[CLkind] - 1 then										if drawtickhere(j) then											begin												CatStringLength := StringWidth(CategoryString(j, 3, true, false));												if CatStringLength > CatNameHeight then													CatNameHeight := CatStringLength;											end;								vertCatString := CatNameHeight > pixwid - 4;								if not vertCatString then									CatNameHeight := fontheight * 2;							end						else							CatNameHeight := fontheight * 2;						bottom := bottom - CatNameHeight;						freqheight := 1.0 * (bottom - top) / (maxaxisvalue + minaxisvalue);						freqint := Nearest50(TicksInterval(fontheight + 4, freqheight));						firstint := minaxisvalue - abs(minaxisvalue) mod freqint;						if (CWChart in [CWCC2T, CWCC2TF]) and (firstint > 0) then							firstint := -firstint;						lastint := maxaxisvalue - abs(maxaxisvalue) mod freqint;						chartbox.bottom := boxLong.bottom;						chartbox.top := boxLong.top - 1;  {v3.04: this seems to fix the scrolling CWCC2TF bug}						chartbox.left := boxLong.left + 1;						chartbox.right := boxLong.right + 1;						baseline := bottom - RoundValue(minaxisvalue * freqheight);{====== writing  grid ======}						if Chartgrid then							begin								GroupBegin;								GroupBegin;								PenMode(pator);								if Chartgrid then									begin										j := firstint;										repeat											moveto(left, ValueHeight(j));											GridLineTo(right, ValueHeight(j), false);											j := j + freqint;										until j > lastint;									end;								GroupEnd;								GroupBegin;								for j := chartorigin to chartorigin + chartintervals - 1 do									if drawtickhere(j) then										begin											if ticksOnLeft then												RS := leftside(j)											else												RS := rightside(j);											moveto(RS, bottom);											GridLineTo(RS, top, false);										end;								GroupEnd;								GroupEnd;								PenNormal;							end;{====== drawing the bars ======}						for theBar := numtoshow downto 1 do							begin								GroupBegin;								for j := chartorigin to chartorigin + chartintervals - 1 do									if j <= numIntervals[CLkind] - 1 then										DrawBar(j, GetSpotBarKind(settoshow, theBar), theBar);								GroupEnd;							end;{====== writing left vertical axes ticks and labels ======}						if axisleft then							begin								moveto(left, top);								lineto(left, bottom);{    moveto(IntegerMax(10, left - StringWidth('00000')), top + (bottom - top) div 2);}								VertAxisLabel(true);								GroupBegin;								j := firstint;								repeat									moveto(left, ValueHeight(j));									line(-2, 0);									j := j + freqint;								until j > lastint;								GroupEnd;								GroupBegin;								j := firstint;								repeat									ds := vertAxisTickLabel(j);									moveto(left - vertaxisgap - StringWidth(ds), ValueHeight(j));									DrawString(ds);									j := j + freqint;								until j > lastint;								GroupEnd;							end;{====== writing right vertical axes ticks and labels ======}						if axisright then							begin								moveto(right + 1, top);								lineto(right + 1, bottom);								VertAxisLabel(false);								GroupBegin;								j := firstint;								repeat									moveto(right + 1, ValueHeight(j));									line(2, 0);									j := j + freqint;								until j > lastint;								GroupEnd;								GroupBegin;								j := firstint;								repeat									moveto(right + vertaxisgap - 1, ValueHeight(j));									ds := vertAxisTickLabel(j);									DrawString(ds);									j := j + freqint;								until j > lastint;								GroupEnd;							end;						GroupBegin;{===== drawing bottom =======}						moveto(left, bottom);						lineto(right, bottom);{==== drawing zero line ====}						moveto(left, baseline);						lineto(right, baseline);{====== horizontal axis ticks ======}						GroupBegin;						moveto(leftSide(chartorigin), bottom);						Line(0, 2);						for j := chartorigin to chartorigin + chartintervals - 1 do							if j <= numIntervals[CLkind] - 1 then								if drawtickhere(j) then									begin										if ticksOnLeft then											RS := leftside(j)										else											RS := rightside(j);										moveto(RS, bottom);										Line(0, 2);									end;						GroupEnd;						GroupEnd;{====== Legend ======}						if showLegend then							begin								GroupBegin;								DrawChartLegend(boundary);								GroupEnd;							end;{====== horizontal axis category labels ======}						GroupBegin;						firstlabelstart := WindowPortRect(chartWindow).right;						for j := chartorigin + 1 to chartorigin + chartintervals - 1 do							if j <= numIntervals[CLkind] - 1 then								if drawtickhere(j) then									DrawCatLabel(j);{now draw first category label, if it fits}						ds := CategoryString(chartorigin, 3, false, false);						if firstlabelstart > GetCatLabelStart(chartorigin, ds) + StringWidth(ds) + 3 then							DrawCatLabel(chartOrigin);						GroupEnd;{====== horizontal axis label ======}						case CWChart of							CWCcst: {DRM CST}								ds := 'Number of steps ';							CWCProbSteps: 								ds := 'Number of steps';							CWCStates: 								if nucleotides then									ds := 'Bases'								else if datatype = protein then									ds := 'Amino Acids'								else									ds := 'States';							CWCSteps: 								if sequencechart then									begin										if molecular then											ds := 'Site'										else											ds := 'Character';									end								else if positionchart then									ds := 'Codon Position'								else									begin										case CWStepsShow of											CWStepsSteps: 												if allwt1 or CWTraced then													ds := 'Number of steps '												else													ds := 'Number of weighted steps ';											CWStepschanges: 												if not changesRestricted then													ds := 'Number of changes '												else													begin														LockHandle(CWClassName, oldstate);														ds := concat('Number of ', CWClassName^^, ' ');														ResetHandle(CWClassName, oldstate);													end;											CWStepsCI: 												ds := 'Consistency index ';											CWStepsRI: 												ds := 'Retention index ';											CWStepsRC: 												ds := 'Rescaled Consistency ';											otherwise												;										end;										if CWTrees[CWCsteps] <> CWCurrenttree then											ds := concat(ds, 'in ', AvailCharName(i));{else ds := concat(ds, 'per character');}									end;							CWCCTall: 								ds := 'Treelength';							CWCC2T, CWCC2TF: 								if molecular then									ds := 'Site'								else									ds := 'Character';							otherwise								;						end;						moveto(left + (right - left - Stringwidth(ds)) div 2, bottom + CatNameHeight + fontheight + 5);						DrawString(ds);					end;				if Chartgrid then					begin						InsetRect(chartbox, -1, -1);						FrameRect(chartbox);						InsetRect(chartbox, 1, 1);					end;			end		else			begin				Chartmessage('nothing to show');				emptychart := true;			end;2:		ZapRegion(tclip);	end;end.