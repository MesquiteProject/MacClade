unit ReadMisc;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, 		Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, 		ErrorUtil, EventUtil, GenUtil, StrUtil, TaxonCHUtil, TypeUtil, Windows, InfoWindows, 		StatesWindow, SymbolsNames, Settings, BoxUtil, CharUtil, ReadWriteUtil,		 ReadUtil, CHUNK, FootNote, LinkUtil, RowColumn, GeneticCode, N7on,		 ReadWriteMacCladeBlock,ReadWriteGeneticCode, PrintingUtil;	procedure CompactToExtendedLink (compactH: Handle; var extendH: Handle; numbits, defaultvalue: integer; theChain: Integer; var theName: str255; isSetCodPos: boolean; var success: boolean);	procedure ReadDecimalRGB (var theColor: RGBColor);	procedure ReadGeneticCode(theNexusBlock: NexusBlockPtr; firstCommand: str255);	procedure FixSymbols (c: char);	procedure ReadNotesBlock(theNexusBlock: NexusBlockPtr; firstCommand: str255);	procedure ReadFileSettings (var readok: BOOLEAN; firstCommand: str255);	procedure ReadMacCladeStartBlock(firstCommand: str255);  {v3.05}	const		MacCladeBlockVersion = '3.05';		MacCladeBlockVersion35 = '3.5';{$SETC SAVEWINDOWPOS=FALSE}{$IFC SAVEWINDOWPOS}		editwindowPosID = 128;		treewindowPosID = 129;		tlegwindowPosID = 130;		chlegwindowPosID = 131;		palwindowPosID = 132;		pictwindowPosID = 133;		charinfowindowPosID = 134;		branchlistwindowPosID = 135;		commwindowPosID = 136;		chartwindowPosID = 137;{$ENDC}	var		blocksread: blockSet;		preDataBlocks: integer;		isExtended: boolean;{еееееееееееееееееееееее}implementation {е$S ReadMisc}{----------------------------------------------------------------------------}	procedure TokenToObjectNumber (token: str255; var ir: integer; characterChain: boolean);	begin		if characterChain then			if token = '.' then				ir := numchars			else				ir := TokenToCharNum(token)		else if token = '.' then			ir := numtaxa		else			ir := TokenToTaxNum(token);	end;{----------------------------------------------------------------------------}	procedure NextRange (var irstart, irend, domod: integer; compactH: Handle; var token: str255; characterChain: boolean);{given a token, representing the first character in a range, returns range in icstart, icend}{also returns if do every domod TH character}		var			numElements: integer;	begin		if characterChain then			numElements := numchars		else			numElements := numTaxa;		domod := 1;		TokenToObjectNumber(token, irstart, characterChain);		token := GetHToken(compactH);		irend := irstart;		if token = '-' then			begin				token := GetHToken(compactH);				TokenToObjectNumber(token, irend, characterChain);				if irend > numElements then					begin						irend := numElements;						NewError(329, 0);					end;				token := GetHToken(compactH);				if token = '\' then					begin						token := GetHToken(compactH);						domod := TokenToInteger(token, true);						token := GetHToken(compactH);					end;			end;	end;{----------------------------------------------------------------------------}	procedure InitializeExtendH (extendH: Handle; numbits, defaultvalue: integer; theChain: Integer; numElements: integer);		var			ir: integer;			intP: IP;			offset: longint;	begin		offset := LinkOffSet(extendH);		intP := IP(GetMaster(extendH) + offset);   {extendH is locked, so don't need to worry about it}		for ir := 1 to numElements do			begin				if realwt and (thechain = wtsetchain) then					intP^ := WtInflate				else					intP^ := defaultvalue;				intP := IP(ord4(intP) + numbits);			end;	end;{----------------------------------------------------------------------------}	procedure InflateWtSet (extendH: Handle);		var			ir: integer;			intP: IP;			offset: longint;	begin		offset := LinkOffSet(extendH);		intP := IP(GetMaster(extendH) + offset);   {extendH is locked, so don't need to worry about it}		for ir := 1 to numchars do			begin				intP^ := intP^ * WtInflate;				intP := IP(ord4(intP) + chwb);			end;	end;{----------------------------------------------------------------------------}	procedure GetSetValue (theChain: Integer; extendH, compactH: Handle; var token: str255; var firstwt: boolean; var setvalue: integer; vector, isSetCodPos: boolean);		var			ds: str255;			twtreal: double;	begin		case theChain of			typesetchain: 				begin					ds := makesmall(token);					setvalue := ConvertToType(ds);					if not vector then						token := GetHToken(compactH);			{first character in list}				end;			codPosChain: 				begin					if isSetCodPos then {v3.05: we are dealing with the new format, in which 1,2,3 -> 1,2,3, but ?-> 0, N-> }						begin							if (token = '?') | (token = 'c') |(token = 'C')  then								setvalue := codeNotSet {31March99 codonPos change: was codeNotSet}							else if (token = 'n') or (token = 'N') then								setvalue := nonCoding							else if (token = '1') then								setvalue := 1							else if (token = '2') then								setvalue := 2							else if (token = '3') then								setvalue := 3							else								setvalue := nonCoding;{31March99 codonPos change: was codeNotSet}						end					else						begin							if (token = '1') then								setvalue := 1							else if (token = '2') then								setvalue := 2							else if (token = '3') then								setvalue := 3							else								setvalue := nonCoding;{31March99 codonPos change: was codeNotSet}						end;					if not vector then						token := GetHToken(compactH);			{first character in list}				end;			wtsetchain: 				begin					if (pos('.', token) > 0) then   {it's a realwt}						begin							if not realwt then								InflateWtSet(extendH);							twtreal := TokenToReal(token);							if (twtreal >= 0.00) and (twtreal <= (1.0 * MaxWtReal / WtInflate)) then								setvalue := RoundValue(WtInflate * twtreal)							else								begin									NewError(21, 0);									twtreal := 0;								end;{if not firstwt & not realwt then  NewError(22, 0);}							firstwt := false;							realwt := true;						end					else						begin							setvalue := TokenToInteger(token, true);							if realwt then								setvalue := setvalue * wtInflate;							if ((setvalue < 0) or (setvalue > MaxWtInt)) then								begin									NewError(21, 0);									setvalue := 0;								end;{if not firstwt & realwt then NewError(22, 0);}{firstwt := false;}{realwt := false;}						end;					if not vector then						token := GetHToken(compactH);			{first character in list}				end;			CharPartitionchain: 				begin					setvalue := GetCharPartNameNumberFromString(token);					if setvalue <= 0 then						begin							AddNewCharPartName(token);							setvalue := numCharPartNames;						end;					if not vector then						token := GetHToken(compactH);			{first character in list}				end;			exsetchain, charsetchain: 				if vector then					if token = '1' then						setvalue := 0					else						setvalue := 1				else					setvalue := 0;			taxsetchain: 				if vector then					if token = '1' then						setvalue := 0					else						setvalue := 1				else					setvalue := 0;			otherwise				;		end;	end;{----------------------------------------------------------------------------}	procedure GetCharListPiece (compactH: Handle; var token: str255; var icstart, icend, domod: integer; var ischarset: boolean; theChain: Integer);		var			linkH: Handle;			theSet: integer;	begin		domod := 1;		token := MakeCaps(token);		if token = 'ALL' then			begin				icstart := 1;				icend := numchars;				ischarset := false;				token := GetHToken(compactH);				if token = '\' then					begin						token := GetHToken(compactH);						domod := TokenToInteger(token, true);						token := GetHToken(compactH);					end;			end		else			begin				theSet := SetNumber(token, theChain <> charsetchain, charsetchain);				if theSet = notASet then   {it's not a charset name}					begin						NextRange(icstart, icend, domod, compactH, token, true);						ischarset := false;					end				else					begin						if theSet < 0 then  {it is a pre-defined character set}							CharSetLinkToBools(nil, theSet, setReplace, false)						else							begin								linkH := NewHandle(2);								GetLink(charsetchain, theSet, linkH, false);								CharSetLinkToBools(linkH, theSet, setReplace, false);								ZapHandle(linkH);							end;						ischarset := true;						icstart := 1;						icend := numchars;						token := GetHToken(compactH);			{first character in list}					end;			end;	end;{----------------------------------------------------------------------------}	procedure GetTaxListPiece (compactH: Handle; var token: str255; var itstart, itend, domod: integer; var istaxset: boolean; theChain: Integer);		var			linkH: Handle;			theSet: integer;	begin		domod := 1;		token := MakeCaps(token);		if token = 'ALL' then			begin				itstart := 1;				itend := numtaxa;				istaxset := false;				token := GetHToken(compactH);				if token = '\' then					begin						token := GetHToken(compactH);						domod := TokenToInteger(token, true);						token := GetHToken(compactH);					end;			end		else			begin				theSet := SetNumber(token, theChain <> taxsetchain, taxsetchain);				if theSet = notASet then   {it's not a taxset name}					begin						NextRange(itstart, itend, domod, compactH, token, false);						istaxset := false;					end				else					begin						if theSet < 0 then  {it is a pre-defined character set}							TaxSetLinkToBools(nil, theSet, setReplace)						else							begin								linkH := NewHandle(2);								GetLink(taxsetchain, theSet, linkH, false);								TaxSetLinkToBools(linkH, theSet, setReplace);								ZapHandle(linkH);							end;						istaxset := true;						itstart := 1;						itend := numtaxa;						token := GetHToken(compactH);			{first taxon in list}					end;			end;	end;{----------------------------------------------------------------------------}	procedure DoSetValue (theChain: Integer; extendH: Handle; numbits, irstart, irend, domod: integer; isSet: boolean; setvalue: integer; characterChain: boolean);{domod - for character lists that are of the form \3, that is, indicating every third.}{	In this case domod would be 3}{isSet indicates if the currently invoked character set is to be invoked.  If so, the info is obtained straight}{	from the character or taxon records}		var			intP: IP;			ir: integer;			offset: integer;	begin		offset := LinkOffset(extendH);		intP := IP(GetMaster(extendH) + offset + numbits * longint(irstart - 1));		for ir := irstart to irend do			if (characterChain & (ir <= numchars)) | (not characterChain & (ir <= numtaxa)) then				begin					if (isSet & ((characterChain & InCharSet(ir)) | (not characterChain & InTaxSet(ir)))) or (((ir - irstart) mod domod = 0) and not isSet) then {}							intP^ := setvalue;					intP := IP(ord4(intP) + numbits);				end;	end;{----------------------------------------------------------------------------}	function nextDarkHChar (H: Handle): char;		var			c: char;	begin		repeat			chunkpos := chunkpos + 1;			c := HChar(H, chunkpos);		until not (c in whitespace+vacuum);		nextDarkHChar := c;	end;{----------------------------------------------------------------------------}	procedure ProcessFormatToken (token: str255; theChain: Integer; var vector, notokens: boolean);	begin		if (token = 'REAL') and (theChain = wtsetchain) then			realwt := true		else if (token = 'INTEGER') and (theChain = wtsetchain) then			begin			end		else if (token = 'VECTOR') then  {v3.05}			vector := true		else if (token = 'NOTOKENS') then  {v3.05}			notokens := true		else			NewError(23, 0);	end;{----------------------------------------------------------------------------}	procedure CompactToExtendedLink (compactH: Handle; var extendH: Handle; numbits, defaultvalue: integer; theChain: Integer; var theName: str255; isSetCodPos: boolean; var success: boolean);		var			irstart, irend, ir, numElements: INTEGER;			Token: str255;			CHUNKsize: longint;			intP: IP;			setvalue, domod: integer;			oldwhite, oldpunct: set of char;			firstwt, isSet: boolean;			offset: integer;			oldState: SignedByte;			vector,notokens: boolean;			numSetElements, it: integer; 			exP: IP;	begin		vector := false;		notokens:=false;		success := false;		UnLockHandle(extendH, oldState);		SetHandleSize(extendH, 0);{    CHUNKpos := SLB;}		CHUNKpos := 0;		chunksize := GetHandleSize(compactH);   {v3.05}		if thechain = wtsetchain then			realwt := false;		isSet := false;		theName := GetHToken(compactH);		UnderlineToBlanks(theName);		ClearLinkBytes(extendH);		SetLinkName(extendH, theName);		offset := LinkOffSet(extendH);		if theChain = taxsetchain then			numElements := numtaxa		else			numElements := numchars;		SetHandleSize(extendH, ord4(numElements) * numbits + offset);		HLock(extendH);		token := MakeCaps(GetHToken(compactH));  {v3.05: makecaps added}		if (token = 'STANDARD') then			repeat			until GetHToken(compactH) = '='		else if token <> '=' then  {there are nonstandard formatting tokens}			begin				if token = '(' then   {there is more than one token}					repeat						token := MakeCaps(GetHToken(compactH));						if token <> ')' then							ProcessFormatToken(token, theChain, vector, notokens);					until (token = ')') or (CHUNKpos >= CHUNKsize)				else					ProcessFormatToken(token, theChain, vector, notokens);				token := GetHToken(compactH);  {this should be =}				if (token <> '=') then					NewError(23, 0);			end;		if ErrorPosted(23) then   			begin 				Exit(CompactToExtendedLink);			end;		InitializeExtendH(extendH, numbits, defaultvalue, theChain, numElements);		token := '.';		firstwt := true;		oldwhite := whitespace;		oldpunct := punctuation;{here is the code that was here in 3.0-3.04}{    whitespace := [' ', ':', '=', chr(13), chr(10), chr(9)]; }{    punctuation := [';', ',', '-', '\'];  }		whitespace := whitespace + [':', '='];   {v3.05}		punctuation := punctuation - [':', '='] + ['-'];		if vector then {v3.05}			begin   {Davidv4.1: does this take care of exset, charset? - this warning was in the 3.08 code}				ir := 1;				domod := 1;				while (CHUNKpos < CHUNKsize - 1) and (token <> ';') and (ir <= numElements) do  {v3.05}					begin						if ((theChain = taxsetchain) or (theChain = charsetchain) or (theChain = exsetchain)  or ((theChain = charpartitionchain) and notokens)) then								begin									token := nextDarkHChar(compactH);								end							else								token := GetHToken(compactH);						if token <> ';' then							begin								isSet := false;								GetSetValue(theChain, extendH, compactH, token, firstwt, setvalue, vector, isSetCodPos);								DoSetValue(theChain, extendH, numbits, ir, ir, domod, isSet, setvalue, (theChain <> taxsetchain));							end;						ir := ir + 1;					end			end		else			while (CHUNKpos < CHUNKsize - 1) and (token <> ';') do				begin					token := GetHToken(compactH);					if token <> ';' then						begin							GetSetValue(theChain, extendH, compactH, token, firstwt, setvalue, vector, isSetCodPos);							while (token <> ';') and (token <> ',') do								begin									if theChain = taxsetchain then										GetTaxListPiece(compactH, token, irstart, irend, domod, isSet, theChain)									else										GetCharListPiece(compactH, token, irstart, irend, domod, isSet, theChain);									DoSetValue(theChain, extendH, numbits, irstart, irend, domod, isSet, setvalue, (theChain <> taxsetchain));								end;						end;				end;		case theChain of			wtSetChain:				SetWtLinkBits(extendH, realwt);			exSetChain:				begin					HLock(extendH);					numSetElements := 0;					for ir := 1 to numchars do						begin							exP := IP(GetMaster(extendH) + offset + exb * longint(ir - 1));							if exP^ = 1 then								numSetElements := numSetElements + 1;						end;					SetNumberElementsInLink(0,0,extendH,numSetElements);				end;			taxSetChain:				begin					HLock(extendH);					numSetElements := 0;					for ir := 1 to numtaxa do						begin							exP := IP(GetMaster(extendH) + offset + exb * longint(ir - 1));							if exP^ = 0 then								numSetElements := numSetElements + 1;						end;					SetNumberElementsInLink(0,0,extendH,numSetElements);				end;			charSetChain:				begin					HLock(extendH);					numSetElements := 0;					for ir := 1 to numchars do						begin							exP := IP(GetMaster(extendH) + offset + exb * longint(ir - 1));							if exP^ = 0 then								numSetElements := numSetElements + 1;						end;					SetNumberElementsInLink(0,0,extendH,numSetElements);				end;			otherwise;		end;		ResetHandle(extendH, oldState);		CheckInflate;		punctuation := oldpunct;		whitespace := oldwhite;		success := true;	end;{----------------------------------------------------------------------------}{----------------------------------------------------------------------------}	procedure ReadGenCodeCore300 (ds: str255);		var			j, k, m: integer;			c: char;	begin		if ds = 'UNIVNUC' then			begin				theGeneticCode := universalExtendedCode;				setStandardCode(theGeneticCode);			end		else if ds = 'UNIVMTDNA' then			begin				theGeneticCode := mammalmtDNAExtendedCode;				setStandardCode(theGeneticCode);			end		else if ds = 'OTHERCODE' then			begin				SetStateSetBoundaries(false);				theGeneticCode := customCode;				setStandardCode(theGeneticCode);				for j := 0 to 3 do					for k := 0 to 3 do						for m := 0 to 3 do							begin								c := nextDarkChar;								genCode^[j, k, m] := MinLg(ProteinSetOfChar(c, true, 1, 0, 0));								if ErrorPosted(88) then									begin										badfile := true;										errorflag := true;										Exit(ReadGenCodeCore300);									end;							end;				next := nextdarkchar;				for j := 1 to 4 do					begin						ds := GetFileToken(maxtok);						if ds = '-1' then							extraAAstates[j] := -1						else							extraAAstates[j] := MinLg(ProteinSetOfChar(ds[1], true, 1, 0, 0));						if ErrorPosted(88) then							begin								badfile := true;								errorflag := true;								leave;							end;						;					end;				SetStateSetBoundaries(nucleotides);			end;		RenameAAs;	end;{----------------------------------------------------------------------------}	procedure ReadGeneticCode(theNexusBlock: NexusBlockPtr; firstCommand: str255);		var			ds, section, command, upperCaseCommand: str255;			theName: str255;			db,compactToExtendedSuccess: boolean;			H, extendH: Handle;			isAsterisk: boolean;			ic: integer;			charHdl: chHdl;			exP: IP;			offset: integer;			oldState: SignedByte;	begin		tempgencode := gencodePtr(NewPtr(SizeOf(gencodearray)));		CustomCodeRead := false;		someCodPosSet := false;		someCoding := false;		if nucleotides then			symbols := 'ACDEFGHIKLMNPQRSTVWY*1234';		command := firstCommand;		upperCaseCommand := MakeCaps(command);		if not EndofBlock(upperCaseCommand) then			repeat				if (upperCaseCommand = 'CODPOSSET') or (upperCaseCommand = 'CODONPOSSET') then   {v3.05 CODONPOSSET}					begin{doCodPosQuery := false;}						H := NewHandle(0);						LineToH(H);						isAsterisk := AsteriskPresent(H);  {v3.05:  check for asterisk and delete}						if  isAsterisk then  {4.01: only read in this one if it is default}							begin								extendH := NewHandle(0);								compactToExtendedSuccess := false;								if upperCaseCommand = 'CODONPOSSET' then									CompactToExtendedLink(H, extendH, chwb, nonCoding, codPosChain, theName, true,compactToExtendedSuccess)  {v3.05: default changed to codeNotSet}																									{31March99 codonPos change: default changed to nonCoding}								else									CompactToExtendedLink(H, extendH, chwb, nonCoding, codPosChain, theName, false,compactToExtendedSuccess);								offset := LinkOffset(extendH);								if compactToExtendedSuccess then									begin										HLock(extendH);										for ic := 1 to numchars do											begin												charHdl := chHdlPtr(GetMaster(chCHUNKs) + HdlSize * longint(ic - 1))^;												LockHandle(charHdl, oldState);												exP := IP(GetMaster(extendH) + offset + chwb * longint(ic - 1));												if (exp^ = nonCoding) then													charHdl^^.coding := false												else													begin														charHdl^^.coding := true;														someCoding := true;													end;												if (exp^ <> nonCoding) & (exp^ <> codeNotSet) then													someCodPosSet := true;												charHdl^^.codpos := exp^;												ResetHandle(charHdl, oldState);											end;										HUnLock(extendH);									end;								ZapHandle(extendH);							end;						Skipper([';'], true);						ZapHandle(H);					end				else if upperCaseCommand = 'GENCODE' then  {pre-version 3.05}					begin						ds := MakeCaps(GetFileToken(maxtok));						ReadGenCodeCore300(ds);						Skipper([';'], true);					end				else if upperCaseCommand = 'GENETICCODE' then   {v3.05}					begin						if CustomCodeRead then							begin								openasuntitled := true;								InstantInfo('Two genetic code descriptions encountered; MacClade will accept only the last one.');							end;						ReadCustomGeneticCode;					end				else if upperCaseCommand = 'CODESET' then   {v3.05}					begin						ReadCodeSet;						Skipper([';'], true);					end				else if upperCaseCommand <> ';' then					ReadForeignLine(codonsBlock, command);				if next in whitespace then					next := nextdarkchar;				command := GetFileToken(maxtok);				upperCaseCommand := MakeCaps(command);			until EndOfBlock(upperCaseCommand) or errorflag or (fpos >= mcFileLength);		Skipper(punctuation, true);		if datatype = DNA then			symbols := 'ACGT'		else if datatype = RNA then			symbols := 'ACGU';		ZapPointer(tempgencode);	end;{-----------------------------------------------------------------------------}	procedure FixSymbols (c: char);{if  the character c is present in the symbols list, then this replaces that character with another}{note: don't use this for molecular data with pre-defined symbols}		var			thepos: integer;			replaced: boolean;{.......}		procedure tryreplacesymbol (startc, endc: char);			var				c: char;		begin			for c := startc to endc do				if (pos(c, symbols) = 0) & not (c in [missing, gap, orsep, andsep, matchchar]) then					begin						symbols[thepos] := c;						replaced := true;						leave;					end				else					replaced := false;		end;{....}	begin		thepos := pos(c, symbols);		if thepos > 0 then			begin				tryreplacesymbol('0', '9');				if not replaced then					tryreplacesymbol('A', 'Z');			end;	end;{----------------------------------------------------------------------------}	procedure DecimalStringToRGBComponent(token: str255; var RGBValue: univ integer);	var 	colorValue: double;		RGBValueLong: longint;		ds: str255;	begin		colorValue:= TokenToReal(token);		if colorValue < 0.0 then			RGBValue := 0		else if colorValue >= 1.0 then			RGBValue := $FFFF		else			begin				RGBValueLong :=TruncateValue(colorValue*65535);				if RGBValueLong>32767 then					RGBValue := RGBValueLong - 65535				else					RGBValue := RGBValueLong;			end;	end;{----------------------------------------------------------------------------}	procedure ReadDecimalRGB (var theColor: RGBColor);	var 	token: str255;	begin		token := GetFileToken(maxtok);		DecimalStringToRGBComponent(token, theColor.red);		token := GetFileToken(maxtok);		DecimalStringToRGBComponent(token, theColor.green);		token := GetFileToken(maxtok);		DecimalStringToRGBComponent(token, theColor.blue);	end;{-----------------------------------------------------------------------------}{fff	procedure StoreForeignBlock (startpos, endpos: longint);		var			dhp: HdlPtr;	begin		if GetHandleSize(ForeignCHUNKs) < HdlSize then			begin				HUnlock(foreignCHUNKs);				SetHandleSize(foreignCHUNKs, HdlSize);				if not MemoryOK then					Exit(StoreForeignBlock);				dhp := HdlPtr(GetMaster(ForeignCHUNKs));				dhp^ := NewHandle(2);			end		else			AddCHUNKs(foreignCHUNKs, 1, 2);		if not badmemory then			FilePiecetoCHUNK(startpos, endpos, foreignCHUNKs, GetHandleSize(foreignCHUNKs) div Hdlsize);	end;} {$IFC FOOTSOUNDS}{----------------------------------------------------------------------------}	procedure ReadPartColor;	var 	ds: str255;		partNumber: integer;		theColor: RGBColor;	begin		partNumber := 0;		repeat			ds := MakeCaps(GetFileToken(maxtok));			if (ds = 'CHARPARTNAME') then				begin					SkipEqual;					partNumber := TokenToInteger(GetFileToken(maxtok), true);				end			else if (ds = 'FORMAT')  then				begin					SkipEqual;					ds := MakeCaps(GetFileToken(maxtok));					if ds <> 'RGB' then						begin							NewError(139, 0);							Skipper([';'], false);						end;				end			else if (ds = 'VALUE') then				begin					SkipEqual;					ReadDecimalRGB(theColor);					if (partNumber >=1) & (partNumber<= numCharPartNames) then						SetPartNameColor(partNumber,theColor);				end			else if ds = ';' then				leave			else if CWarning(concat('MacClade does not support ', ds, '.'), 'Cancel', 'Continue') then				begin					SkipOption;					Skipper([';'], false);					leave;				end;		until errorflag | (fpos>= mcFileLength);	end;{----------------------------------------------------------------------------}	procedure ReadNotesBlock;		label			1;		var			ds, section,command,upperCaseCommand: str255;			db: boolean;			dL: longint;			nt, nc: integer;			ic: integer;			theFoot: integer;			olddirtyfile: boolean;	begin		olddirtyfile := dirtyfile;		command := GetFileToken(maxtok);		upperCaseCommand := MakeCaps(command);		for theFoot := 0 to maxFootType do			begin				HUnlock(footH[theFoot]);				SetHandleSize(footH[theFoot], 0);			end;		if not EndofBlock(upperCaseCommand) then			repeat				if (upperCaseCommand = 'TEXT') or (upperCaseCommand = 'PICTURE') or (upperCaseCommand = 'SOUND') then					begin						nt := 0;						nc := 0;						if upperCaseCommand = 'TEXT' then							theFoot := footText						else if upperCaseCommand = 'PICTURE' then							theFoot := footPict						else if upperCaseCommand = 'SOUND' then							theFoot := footSound						else if CWarning(concat('MacClade does not support ', ds, '.'), 'Cancel', 'Continue') then							begin								SkipOption;								Skipper([';'], false);								leave;							end;						repeat							ds := MakeCaps(GetFileToken(maxtok));							if (ds = 'TAXON') then								begin									SkipEqual;									nt := TokenToInteger(GetFileToken(maxtok), true);								end							else if (ds = 'CHARACTER') then								begin									SkipEqual;									nc := TokenToInteger(GetFileToken(maxtok), true);								end							else if (ds = 'STATE') then								begin									SkipEqual;									ds := GetFileToken(maxtok);									NewError(421,0);								end							else if (ds = 'FORMAT') and ((theFoot = footpict) or (theFoot = footsound)) then								begin									SkipEqual;									ds := MakeCaps(GetFileToken(maxtok));									if (theFoot = footsound) then										begin											if ds <> 'MACSND' then												begin													NewError(139, 0);													Skipper([';'], false);												end;										end									else if theFoot = footpict then										begin											if ds <> 'PICT' then												begin													NewError(139, 0);													Skipper([';'], false);												end;										end;								end							else if (ds = 'SOURCE') and ((theFoot = footpict) or (theFoot = footsound)) then								begin									SkipEqual;									if MakeCaps(GetFileToken(maxtok)) <> 'RESOURCE' then										begin											NewError(140, 0);											Skipper([';'], false);										end;								end							else if (ds = 'TEXT') or (ds = 'PICTURE') or (ds = 'SOUND') then								begin									SkipEqual;									if ((ds = 'TEXT') and (theFoot = foottext)) or ((ds = 'PICTURE') and (theFoot = footpict)) or ((ds = 'SOUND') and (theFoot = footsound)) then										begin											ds := GetFileToken(255);   {note length of allowed token}											UnderlineToBlanks(ds);											if ((nc <> 0) or (nt <> 0)) and ((nc >= 0) and (nc <= numchars) and (nt >= 0) and (nt <= numtaxa)) then												begin													if theFoot = footText then														SetFootString(theFoot, nt, nc, ds)													else 														begin															dL := TokenToInteger(ds,true);															if (ErrorPosted(17)) then																begin																	RemoveError(17);																	NewError(140,0);																																		Skipper([';'], false);																end															else																SetFootLongint(theFoot, nt, nc, dL);														end;												end;										end									else										Skipper([';'], false);								end							else if ds = ';' then								goto 1							else if CWarning(concat('MacClade does not support ', ds, '.'), 'Cancel', 'Continue') then								begin									SkipOption;									Skipper([';'], false);									leave;								end;						until errorflag;1:					end				else if (upperCaseCommand = 'COLOR') | (upperCaseCommand = 'COLOUR') then					ReadPartColor				else if upperCaseCommand <> ';' then					ReadForeignLine(notesBlock, command);				if next in whitespace then					next := nextdarkchar;				command := GetFileToken(maxtok);				upperCaseCommand := MakeCaps(command);			until EndOfBlock(upperCaseCommand) or errorflag or (fpos >= mcFileLength);		Skipper(punctuation, true);		dirtyfile := olddirtyfile;	end;{$ELSEC}{----------------------------------------------------------------------------}	procedure ReadPartColor;	var 	ds: str255;		partNumber: integer;		theColor: RGBColor;	begin		partNumber := 0;		repeat			ds := MakeCaps(GetFileToken(maxtok));			if (ds = 'CHARPARTNAME') then				begin					SkipEqual;					partNumber := TokenToInteger(GetFileToken(maxtok), true);				end			else if (ds = 'FORMAT')  then				begin					SkipEqual;					ds := MakeCaps(GetFileToken(maxtok));					if ds <> 'RGB' then						begin							NewError(139, 0);							Skipper([';'], false);						end;				end			else if (ds = 'VALUE') then				begin					SkipEqual;					ReadDecimalRGB(theColor);					if (partNumber >=1) & (partNumber<= numCharPartNames) then						SetPartNameColor(partNumber,theColor);				end			else if ds = ';' then				leave			else if CWarning(concat('MacClade does not support ', ds, '.'), 'Cancel', 'Continue') then				begin					SkipOption;					Skipper([';'], false);					leave;				end;		until errorflag | (fpos>= mcFileLength);	end;{----------------------------------------------------------------------------}	procedure ReadNotesBlock(theNexusBlock: NexusBlockPtr; firstCommand: str255);		label			1;		var			ds, section, command, upperCaseCommand: str255;			db: boolean;			nt, nc: integer;			dL: longint;			ic: integer;			theFoot: integer;			olddirtyfile: boolean;	begin		olddirtyfile := dirtyfile;		command := firstCommand;		upperCaseCommand := MakeCaps(command);		for theFoot := 0 to maxFootType do			begin				HUnlock(footH[theFoot]);				SetHandleSize(footH[theFoot], 0);			end;		if not EndofBlock(upperCaseCommand) then			repeat				if (upperCaseCommand = 'TEXT') or (upperCaseCommand = 'PICTURE') then					begin						nt := 0;						nc := 0;						if upperCaseCommand = 'TEXT' then							theFoot := footText						else							theFoot := footPict;						repeat							ds := MakeCaps(GetFileToken(maxtok));							if (ds = 'TAXON') then								begin									SkipEqual;									nt := TokenToInteger(GetFileToken(maxtok), true);								end							else if (ds = 'CHARACTER') then								begin									SkipEqual;									nc := TokenToInteger(GetFileToken(maxtok), true);								end							else if (ds = 'STATE') then								begin									SkipEqual;									ds := GetFileToken(maxtok);									NewError(421,0);								end							else if (ds = 'FORMAT') and (theFoot = footPict) then								begin									SkipEqual;									if MakeCaps(GetFileToken(maxtok)) <> 'PICT' then										begin											NewError(139, 0);											Skipper([';'], false);										end;								end							else if (ds = 'SOURCE') and (theFoot = footPict) then								begin									SkipEqual;									if MakeCaps(GetFileToken(maxtok)) <> 'RESOURCE' then										begin											NewError(140, 0);											openasuntitled := true;											Skipper([';'], false);										end;								end							else if (ds = 'TEXT') or (ds = 'PICTURE') then								begin									SkipEqual;									if ((ds = 'TEXT') and (theFoot = footText)) or ((ds = 'PICTURE') and (theFoot = footPict)) then										begin											ds := GetFileToken(255);   {note length of allowed token}											UnderlineToBlanks(ds);											if ((nc <> 0) or (nt <> 0)) and ((nc >= 0) and (nc <= numchars) and (nt >= 0) and (nt <= numtaxa)) then												begin													if theFoot = footText then														SetFootString(theFoot, nt, nc, ds)													else														begin															dL := TokenToInteger(ds,true);															if (ErrorPosted(17)) then																begin																	RemoveError(17);																	NewError(140,0);																	Skipper([';'], false);																	openasuntitled := true;																end															else																LoadAndAttachPicResourceToFoot(theFoot, nt, nc, TokenToInteger(ds, true));														end;																										end;										end									else										Skipper([';'], false);								end							else if (ds = 'TAXA') then								begin									SkipEqual;									ds := GetFileToken(255);   									if not (MatchesActiveNexusBlock(ds,taxaBlock) | MatchesActiveNexusBlock(ds,dataBlock)) then										begin											Skipper([';'], false);											if CWarning(concat('The TAXA or DATA block entitled "', ds, '" is not available, and thus a  ', upperCaseCommand, ' note of the Notes block will be lost.'), 'Cancel', 'Continue') then												begin													errorflag := true;													badfile := true;													leave;												end;										end;								end							else if (ds = 'CHARACTERS') then								begin									SkipEqual;									ds := GetFileToken(255);   									if not (MatchesActiveNexusBlock(ds,charactersBlock) | MatchesActiveNexusBlock(ds,dataBlock)) then										begin											Skipper([';'], false);											if CWarning(concat('The CHARACTERS or DATA block entitled "', ds, '" is not available, and thus a  ', upperCaseCommand, ' note of the Notes block will be lost.'), 'Cancel', 'Continue') then												begin													errorflag := true;													badfile := true;													leave;												end;										end;								end							else if (ds = 'FILE') then								ReadForeignLine(notesBlock, concat(command, ' ', ds))							else if ds = ';' then								goto 1														else if (fpos < mcFileLength) then								begin									if not CWarning(concat('MacClade does not support ', ds, ' in the ', upperCaseCommand, ' command of the Notes block.'), 'Continue', 'Cancel') then										begin											SkipOption;											Skipper([';'], false);											errorflag := true;											badfile := true;											leave;										end									else										ReadForeignLine(notesBlock, concat(command, ' ', ds));								end;						until errorflag or (fpos >= mcFileLength);1:					end				else if (upperCaseCommand = 'COLOR') | (upperCaseCommand = 'COLOUR') then					ReadPartColor				else if upperCaseCommand <> ';' then					ReadForeignLine(notesBlock, command);				if next in whitespace then					next := nextdarkchar;				command := GetFileToken(maxtok);				upperCaseCommand := MakeCaps(command);			until EndOfBlock(upperCaseCommand) or errorflag or (fpos >= mcFileLength);		Skipper(punctuation, true);		dirtyfile := olddirtyfile;	end;{$ENDC}{----------------------------------------------------------------------------}	procedure MacCladeBlockProcessing (var readok: BOOLEAN);		var			oldState: SignedByte;			dhp: HdlPtr;	begin{====  processing =====}		if nex7on then			begin				InitNumBoxes;{topmargin := -1;}				i7 := 1;			end;		if (traceshown = traceDiscrete) then			begin{FROZEN 3.0}				gomask := gomask + [reconstructi]; {add reconstructi to golist}				golist := golist + [reconstructi]; {don't have to call TurnOnTrace because most of its fiddlings}					{set automatically on starting up of file, windows, etc.?}				brushset := [];				tool^[treeTools,paintT].curs := emptybrush;			end;		if (i < 1) or (i > numchars) then			i := 1;		oldtracei := i;{FROZEN 3.0}		if (traceshown = traceAllChanges) then			golist := golist + [countall, reconstructall, brchangesall];		if (traceshown = traceAllStates) then			golist := golist + [countall, reconstructall];		if GetHandleSize(fixdataH) > 1 then			begin				if DefaultLink[datafilechain] > -1 then					begin						LockHandle(strCHUNKs[datafilechain], oldState);						dhp := HdlPtr(GetMaster(strCHUNKs[datafilechain]) + HdlSize * ord4(DefaultLink[datafilechain]));						BitSet(ptr(GetMaster(dhp^)), 18);						ResetHandle(strCHUNKs[datafilechain], oldState);					end				else					begin						HUnlock(fixdataH);						SetHandleSize(fixdataH, 0);					end;			end;		CheckToolKit(treeTools,paintT);		CheckToolKit(treeTools,statsTestT);		tool^[treeTools,turpentineT].enabled := GetHandleSize(fixdataH) > 1;		if editorCharacterSetToShade <> defaultCharSetToShade then			begin				RebuildShadeCharSetMenu;				if (editorCharacterSetToShade>= FirstUserShadeCharSet) & (editorCharacterSetToShade <= LastUserShadeCharSet) then					SetShadeCharSetBooleans(editorCharacterSetToShade - FirstUserShadeCharSet);			end;		{if then			RebuildConsensusTaxSetMenu;}		readok := true;	end;{----------------------------------------------------------------------------}	procedure ReadSingles (unmodified: boolean);	begin		dirtytaxnames := (nextdarkchar = '1') or not unmodified;		dirtytree := (nextchar = '1');		if (nextchar = '1') then			missing := ' ';		if (nextchar = '1') then			matchchar := ' ';		andsep := nextchar;		orsep := nextchar;		resolveOption := TokenToInteger(nextchar, true);	end;{$IFC FALSE}{----------------------------------------------------------------------------}	procedure ReadItalics (unmodified: boolean);{note: if user modifies file in certain way, itlics will be all shifted...}		var			TaxonHdl: thdl;			it: integer;	begin		it := 1;		repeat			next := nextdarkchar;			if next = '1' then				begin					TaxonHdl := GetTaxonHdl(it);					TaxonHdl^^.isItalic := true;				end;			it := it + 1;		until (next = ';') or (fpos >= mcFileLength) or (it > numtaxa);	end;{$ENDC}{----------------------------------------------------------------------------}	procedure ProcessFixDataH;		var			oldState: SignedByte;			dhp: HdlPtr;	begin		if GetHandleSize(fixdataH) > 1 then			begin				if DefaultLink[datafilechain] > -1 then					begin						LockHandle(strCHUNKs[datafilechain], oldState);						dhp := HdlPtr(GetMaster(strCHUNKs[datafilechain]) + HdlSize * ord4(DefaultLink[datafilechain]));						BitSet(ptr(GetMaster(dhp^)), charfixedbit);						ResetHandle(strCHUNKs[datafilechain], oldState);					end				else					begin						HUnlock(fixdataH);						SetHandleSize(fixdataH, 0);					end;			end;	end;{----------------------------------------------------------------------------}	procedure ProcessRealBranchLengthsDataH;		var			oldState: SignedByte;			dhp: HdlPtr;	begin		if GetHandleSize(realBranchLengthsDataH) > 1 then			begin				if DefaultLink[datafilechain] > -1 then					begin						LockHandle(strCHUNKs[datafilechain], oldState);						dhp := HdlPtr(GetMaster(strCHUNKs[datafilechain]) + HdlSize * ord4(DefaultLink[datafilechain]));						BitSet(ptr(GetMaster(dhp^)), branchLengthStoredBit);						ResetHandle(strCHUNKs[datafilechain], oldState);					end				else					begin						HUnlock(realBranchLengthsDataH);						SetHandleSize(realBranchLengthsDataH, 0);					end;			end;	end;{----------------------------------------------------------------------------}	procedure ProcessSegDataH;		var			oldState: SignedByte;			dhp: HdlPtr;	begin		if GetHandleSize(segdataH) > 1 then			begin				if DefaultLink[datafilechain] > -1 then					begin						LockHandle(strCHUNKs[datafilechain], oldState);						dhp := HdlPtr(GetMaster(strCHUNKs[datafilechain]) + HdlSize * ord4(DefaultLink[datafilechain]));						BitSet(ptr(GetMaster(dhp^)), segstoredbit);						ResetHandle(strCHUNKs[datafilechain], oldState);					end				else					begin						HUnlock(segdataH);						SetHandleSize(segdataH, 0);					end;			end;	end;{----------------------------------------------------------------------------}	procedure ReadMacCladeBlock4(var readOK: boolean);	var 		db: boolean;			secs, startpos, endpos: longint;			os: oserr;			unmodified: boolean;			ds,capds: str255;			c: char;			whichinfo: integer;			subVersionNumber : integer;			oldpunct: set of char;	begin		oldpunct := punctuation;		punctuation := punct305;		ds := GetFileToken(maxtok); {get subversion number}		subVersionNumber:= TokenToInteger(ds,false);		Skipper([';'], true);  {skip past semicolon}		ds := MakeCaps(GetFileToken(maxtok));		if (ds = 'LASTMODIFIED') then			begin				StringToNum(GetFileToken(maxtok), secs);				if fileLastModified <> 0 then					unmodified := abs(fileLastModified - secs) <= 1				else					unmodified := false;				Skipper([';'], true);  {skip past semicolon}				repeat					ds := GetFileToken(maxtok);					capDS := MakeCaps(ds);					if capDS = 'CONSENSUS' then						ReadWriteConsensusSettings(true, 1, subVersionNumber)					else if (capds = 'FIXED') then						begin							c := nextdarkchar;							startpos := fpos;							Skipper([';'], true);							endpos := fpos;							FilePieceToH(startpos, endpos, fixdataH);							ProcessFixDataH;						end					else if (capds = 'SEGMENTS') then						begin							c := nextdarkchar;							startpos := fpos;							Skipper([';'], true);							endpos := fpos;							FilePieceToH(startpos, endpos, segdataH);							ProcessSegDataH;						end					else if (capds = 'BRANCHLENGTHS') then						begin							c := nextdarkchar;							startpos := fpos;							Skipper([';'], true);							endpos := fpos;							FilePieceToH(startpos, endpos, realBranchLengthsDataH);							ProcessRealBranchLengthsDataH;						end					else if not EndOfBlock(capds) then						ReadSettingsCommandIntoH(fileSettings,unmodified,subVersionNumber,ds);									until EndOfBlock(capds) or errorflag or (fpos >= mcFileLength);				MacCladeBlockProcessing(readOK);			end;		punctuation:= oldpunct;		if subVersionNumber >= subVersionForPrintRecord then			ReadPrintRecordFromFileResource (FDI^[readFileFDI].fs);	end;{----------------------------------------------------------------------------}	procedure ReadMacCladeBlock305 (var readok: BOOLEAN);  {v3.05}		var			db: boolean;			secs, startpos, endpos: longint;			os: oserr;			unmodified: boolean;			ds: str255;			c: char;			whichinfo: integer;			versionNumber : integer;	begin		Skipper([';'], true);  {skip past semicolon}{==== checking if file has been modified since last MacClade saving ====}		ds := MakeCaps(GetFileToken(maxtok));		if (ds = 'LASTMODIFIED') then			begin				StringToNum(GetFileToken(maxtok), secs);				if fileLastModified <> 0 then					unmodified := abs(fileLastModified - secs) <= 1				else					unmodified := false;				Skipper([';'], true);  {skip past semicolon}{==== =====}				repeat					ds := MakeCaps(GetFileToken(maxtok));					if (ds = 'SINGLES') then						begin							ReadSingles(unmodified);							Skipper([';'], true);  {skip past semicolon}						end					else if (ds = 'FIXED') then						begin							c := nextdarkchar;							startpos := fpos;{SkipToEndOfLine(false);}							Skipper([';'], true);							endpos := fpos;							FilePieceToH(startpos, endpos, fixdataH);							ProcessFixDataH;{skip past semicolon}						end{else if (ds = 'ITALICS') then begin ReadItalics(unmodified); end}{$IFC FALSE}					else if (ds = 'EXTENDED') then						begin							if datatype = standard then								begin									SetDataFormat(standard32, false);									ExpandData;									CheckStateNamesSymbolsDanger(true, db);									CheckSymbolsConflictFinal;								end;						end{$ENDC}					else if (ds = 'SEGMENTS') then						begin							c := nextdarkchar;							startpos := fpos;{SkipToEndOfLine(false);}							Skipper([';'], true);							endpos := fpos;							FilePieceToH(startpos, endpos, segdataH);							ProcessSegDataH;{Skipper([';'], true); }{skip past semicolon}						end;				until EndOfBlock(ds) or errorflag or (fpos >= mcFileLength);				MacCladeBlockProcessing(readOK);			end;	end;{----------------------------------------------------------------------------}	procedure ReadFileSettings3 (var readok: BOOLEAN);		var			db: boolean;			secs, startpos, endpos: longint;			oldState: SignedByte;			dhp: HdlPtr;			os: oserr;			unmodified: boolean;			ds: str255;	begin		ds := GetFileToken(maxtok);		if (ds = '3.0') then			begin{==== checking if file has been modified since last MacClade saving ====}				StringToNum(GetFileToken(maxtok), secs);				if fileLastModified <> 0 then					unmodified := abs(fileLastModified - secs) <= 1				else					unmodified := false;{==== =====}				ReadSingles(unmodified);				SkipToEndOfLine(true);				startpos := fpos;				SkipToEndOfLine(false);				endpos := fpos;				FilePieceToH(startpos, endpos, fixdataH);				ProcessFixDataH;{ Segments:}				SkipToEndOfLine(true);				startpos := fpos;				SkipToEndOfLine(false);				endpos := fpos;				FilePieceToH(startpos, endpos, segdataH);				ProcessSegDataH;				MacCladeBlockProcessing(readOK);			end		else if ds[1] = '2' then   {this is to protect against any pre-version 3.0 file}			InstantError(260);	end;{----------------------------------------------------------------------------}	procedure ReadFileSettings (var readok: BOOLEAN; firstCommand: str255);		var			db: boolean;			ds: str255;			oldPunct: set of char;	begin		oldpunct := punctuation;		punctuation := punctuation - ['-'];		readok := false;		ds := MakeCaps(firstCommand);		if (ds = 'V') then  {version 3.0-3.04}			begin				ReadFileSettings3(readok);				db := FindEndOfBlock(0,false);			end		else if ds = 'VERSION' then			begin				ds := GetFileToken(maxtok);				if (ds = MacCladeBlockVersion) then					ReadMacCladeBlock305(readOK)				else if (ds= MacCladeBlockVersionString) | (ds = '3.5') then  {establishes it as 3.5+}					ReadMacCladeBlock4(readOK)				else					begin						db := FindEndofBlock(0,false);						Skipper([';'], true);					end;			end;		Skipper(punctuation, true);{do any processing in ReadData}		punctuation := oldpunct;	end;{----------------------------------------------------------------------------}	procedure ReadMacCladeStartBlock(firstCommand: str255);  {v3.05}		var			ds: str255;	begin		ds := MakeCaps(firstCommand);		while not EndOfBlock(ds) & not errorflag & (fpos < mcFileLength) do			begin				if (ds = 'EXTENDED') then					begin						IsExtended := true;						Skipper([';'], true);  {skip past semicolon}					end				else if (ds = 'USEOLDPUNCT') then					begin						punctuation := punct304;						Skipper([';'], true);  {skip past semicolon}					end;				ds := MakeCaps(GetFileToken(maxtok));			end;	end;end.