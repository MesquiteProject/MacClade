unit MCWindows;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, 		Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap, 		 Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, 		 ErrorUtil, EventUtil, GenUtil, TaxonCHUtil, CharUtil, BoxUtil,		  Printing, Equivocal, TypeUtil, WriteUtil, LinkUtil, StrUtil, TreeUtil, MenuUtil, 		  Prohibitions, InfoWindows, Activates, BranchListWindow, ChartWUtil, ChartWCalc, 		  ChartWWrite, ChartWindow, SpreadUtil, TraceControl, N7on, Legends, FootNote,		  TextWindows, ConsensusSequences, StatesWindowUtil;	procedure OpenStatesWindow (hug: boolean; leftToHug, topToHug: integer);	procedure CloseStatesWindow;		procedure OpenPaletteWindow(whichToolPalette: integer);	procedure ClosePaletteWindow(whichToolPalette: integer);	procedure ChangeInfoSelectMenuFix(whichinfo: integer);	procedure OpenInfoWindow (whichinfo: integer);	procedure OpenOrSelectInfoWindow (whichinfo: integer);	procedure AddOpenEditLastInfoRowName (whichInfo: integer; prepareToEdit: boolean);  {/// \\\WH}	procedure CloseInfoWindow (whichinfo: integer);	procedure SetPaletteAndLegendPositions (setpalette, setTreeLegend, setCharLegend: boolean);	procedure SetDrawTWRControls;	procedure SizeTreeWindow;	procedure OpenTreeWindow;	procedure CloseTreeWindow (savethetree: boolean);	procedure OpenEdit;	procedure CloseEdit (docellcheck: boolean);	function AnyTextWindowWasOpen: boolean;	procedure ReSizeTextWindow (whichText, height, width: integer; showhidescroll: boolean);	procedure OpenTextWindow (whichText: integer);	{procedure ReSizeCommWindow (height, width: integer; showhidescroll: boolean);	procedure OpenCommWindow;	procedure CloseCommWindow;}	procedure OpenChartWindow;	procedure CloseChartWindow;	procedure CalcToTextfile (isrecalc: boolean);	procedure Zoom (whichwindow: windowPtr; whichway: integer);	procedure WindowPop (shrinkit: boolean; allowChangeMaxTWR:boolean);	procedure MoveWindowHome (theWindow: WindowPtr);{еееееееееееееееееееееее}implementation {е$S Windows}{#################=== StatesWindow ===###########################}	procedure OpenStatesWindow (hug: boolean; leftToHug, topToHug: integer);		var			topH, leftH: integer;	begin		statesWindowTop := 1;		SetControlValueLong(statesWindowHScroll,stateswindowCharacter);		setStatesLW;		maxStateRows := maxstate + 1;{		if (statesWindowRows < maxStateRows) then			if (maxStateRows < 20) then				begin					statesWindowRows := maxStateRows;					WindowPortRect(stateswindow).bottom := CalcStatesWindowHeight;				end			else if statesWindowRows < 10 then				begin					statesWindowRows := 10;					WindowPortRect(stateswindow).bottom := CalcStatesWindowHeight;				end;}		if (statesWindowRows > maxStateRows) then			begin				statesWindowRows := maxStateRows;				WindowPortRect(stateswindow).bottom := CalcStatesWindowHeight;			end;		if not statesWindowWasOpen & (statesWindowRows > 10) then				begin					statesWindowRows := 10;					WindowPortRect(stateswindow).bottom := CalcStatesWindowHeight;				end;		SizeWindow(statesWindow, WindowPortRect(stateswindow).right, CalcStatesWindowHeight, false);		SizeStatesWindow;		if hug then			begin				if ScreenRectangle.right - leftToHug < 50 then					leftH := leftToHug - 50				else					leftH := leftToHug;				if ScreenRectangle.bottom - topToHug < 50 then					topH := topToHug - 50				else					topH := topToHug;				MoveWindow(statesWindow, leftH, topH, true);			end;		ShowWindow(statesWindow);		SelectWindow(statesWindow);		{^&* theWindow := statesWindow;}		genericSetPort(statesWindow);		statesWindowOpen := true;		InvalidateInfoColumn(charinfo, CharInfoExpand, statesWindowCharacter, statesWindowCharacter);		statesWindowWasOpen := false;	end;{----------------------------------------------------------------------------}	procedure CloseStatesWindow;	begin		if statesEditing then			TurnOffStatesEditing;		if statesSymbolisSelected then			TurnOffSymbolsEditing;		HideWindow(statesWindow);		statesWindowOpen := false;		InvalidateInfoColumn(charinfo, CharInfoExpand, statesWindowCharacter, statesWindowCharacter);		FixCopyPasteMenuItems;		ReturnComplexDisplayMenu;	end;	{----------------------------------------------------------------------------}	procedure OpenPaletteWindow(whichToolPalette: integer);	begin		toolPaletteOpen[whichToolPalette] := true;		myShowWindow(toolPaletteWindow[whichToolPalette]);		SelectWindow(toolPaletteWindow[whichToolPalette]);		myCheckMenuItem(WindowsMHdl, ToolPaletteItem, true);	end;{----------------------------------------------------------------------------}	procedure ClosePaletteWindow(whichToolPalette: integer);	begin		toolPaletteOpen[whichToolPalette] := false;		myHideWindow(toolPaletteWindow[whichToolPalette]);		myCheckMenuItem(WindowsMHdl, ToolPaletteItem, false);		{if whichToolPalette=editorTools then			genericSetPort(editorWindow);}	end;{-------------------------------------------------------------------------}	procedure ChangeInfoSelectMenuFix(whichinfo: integer);	begin		case whichinfo  of			charinfo:				begin					FixAssumpMenu;				end			treeinfo:				begin					if frontWindow=infoWindow[treeinfo] then						begin							if infoSomeSelected[whichinfo] & treeopen then								myEnableItem(FileMHdl,PrintExtraItem)							else								EnableDisableItem(FileMHdl,PrintExtraItem,infoOpen[treeinfo] & AnyInfoRowSelected(treeinfo) & treeopen);							EnableDisableItem(TreeMHdl,ShowTreeItem, infoSomeSelected[treeinfo]);						end;									end;			taxinfo:				begin					EnableDisableItem(CopySpecialMHdl, CopyOutgroupItem, fileopen & infoOpen[taxinfo] & infoSomeSelected[taxinfo]);					if frontWindow=infoWindow[taxinfo] then						EnableDisableItem(xxTaxonSetsMHdl, StoreTaxonSetItem,infoSomeSelected[taxinfo]);				end;			charpartnameinfo:				EnableDisableItem(CharPartListMHdl, SetGroupColorItem, infoSomeSelected[charpartnameinfo]);			otherwise			;		end;		SetInfoWindowButtonActivate(whichinfo);		FixEditMenu;	end;{----------------------------------------------------------------------------}{#################=== InfoWindows ===###########################}	procedure OpenInfoWindow (whichinfo: integer);		var			maxRows: integer;			db: boolean;	begin		if whichinfo=nexusblockinfo then			AdjustAllNexusBlockWillWrites;		infoTop[whichinfo] := 1;		infoBottom[whichinfo] := infoTop[whichinfo] + infoRows[whichinfo]-1;		infoLeft[whichinfo] := 1;		SetInfoLW(whichinfo);		maxRows := MaximumInfoRows(whichInfo);		if (infoRows[whichinfo] < maxrows) then			if (maxrows < 20) then				begin					infoRows[whichinfo] := maxrows;					WindowPortRect(infowindow[whichInfo]).bottom := CalcInfoWindowHeight(whichinfo);				end			else if infoRows[whichinfo] < 10 then				begin					infoRows[whichinfo] := 10;					WindowPortRect(infowindow[whichInfo]).bottom := CalcInfoWindowHeight(whichinfo);				end;		SizeInfoWindow(whichinfo, false, true);		if not infoHasBeenOpen[whichinfo] then			begin				numInfoWindowsThatHaveBeenOpen := numInfoWindowsThatHaveBeenOpen + 1;				MoveWindow(infoWindow[whichinfo], 5 + numInfoWindowsThatHaveBeenOpen * 20, 30 + numInfoWindowsThatHaveBeenOpen * 20, false);			end;		infoHasBeenOpen[whichinfo]:= true;				myEnableItem(FileMHdl, PrintingItem);		myEnableItem(SaveOtherMHdl, svTxtWindowItem);		//HideWindow(infoWindow[whichinfo]);		ShowWindow(infoWindow[whichinfo]);		SelectWindow(infoWindow[whichinfo]);		{^&* theWindow := infoWindow[whichinfo];}		genericSetPort(infoWindow[whichinfo]);		SetControlValueLong(infoScroll[whichinfo], infoTop[whichinfo]);		SetControlValueLong(infoHScroll[whichinfo], infoLeft[whichinfo]);		infoOpen[whichinfo] := true;		ChangeInfoSelectMenuFix(whichinfo);		FixAssumpMenu;		SetMenuItemText(FileMHdl, PrintingItem, 'Print List...');	end; {-----------------------------------------------------------------------------}	procedure OpenOrSelectInfoWindow (whichinfo: integer);	begin		if whichinfo <> noinfo then			if infoOpen[whichinfo] then				SelectWindow(infoWindow[whichinfo])			else				OpenInfoWindow(whichinfo);			end;{-----------------------------------------------------------------------------}	procedure AddOpenEditLastInfoRowName (whichInfo: integer; prepareToEdit: boolean);  	{this procedure adds a new line to the info row.  	the actual object has ALREADY been created, thus MaximumInfoRows is accurate}	var tPort: WindowPtr;	begin		genericGetPort(tPort);		if prepareToEdit then			if infoOpen[whichInfo] then				SelectWindow(infoWindow[whichInfo])			else				OpenInfoWindow(whichInfo);		if infoOpen[whichinfo] then			begin				genericSetPort(infoWindow[whichinfo]);				if prepareToEdit & infoEditing[whichInfo] then					TurnOffInfoEditing(whichInfo);			end;		ResetVerticalInfoScrollControlMax(whichinfo);{  }	{	if not InfoRowsLessThanPreferredMinimum(infoRows[whichinfo]) then}  {the window won't be enlarged}		{ }{we know the last row shown is the last row of all, so need to scrollup one}{normally the above would do infotop+inforows-1 to get the number of the last row,}{in this case it does not as maxinforows has already been adjusted, but the rest have not}		{	if infoTop[whichinfo] + infoRows[whichinfo] = MaximumInfoRows(whichInfo) then				begin					infoTop[whichInfo] := infoTop[whichInfo] + 1;					infoBottom[whichinfo] := infoTop[whichinfo] + infoRows[whichinfo]-1;					SetControlValueLong(infoScroll[whichInfo], GetControlValueLong(infoScroll[whichInfo]) + 1);				end;}			if MaximumInfoRows(whichInfo) > infoBottom[whichinfo] then				begin					infoBottom[whichinfo] := MaximumInfoRows(whichInfo);					infoTop[whichInfo] := infoBottom[whichInfo] -infoRows[whichinfo]+ 1;					SetControlValueLong(infoScroll[whichInfo], GetControlMaximumLong(infoScroll[whichInfo]));				end;		if infoOpen[whichinfo] then			InvalidateWindow(infowindow[whichInfo], true);		if prepareToEdit then			TurnOnInfoEditing(whichInfo, MaximumInfoRows(whichInfo));		genericSetPort(tPort);	end;{----------------------------------------------------------------------------}	procedure CloseInfoWindow (whichinfo: integer);	begin		if infoediting[whichinfo] then			TurnOffInfoEditing(whichinfo);		SetAllInfoDeSelected(whichinfo);		InfoWindowDeActivate(whichinfo,false);		HideWindow(infoWindow[whichinfo]);		infoOpen[whichinfo] := false;		{if not editorOpen then			begin				myDisableItem(EditMHdl, SelectItem);				SetMenuItemText(EditMHdl, SelectItem, 'Select');			end		else			SetMenuItemText(EditMHdl, SelectItem, 'Select All');		SetMenuItemText(FileMHdl, PrintingItem, 'Print...');}{$IFC NOT ALWAYSENABLED}		myDisableItem(SaveOtherMHdl, svTxtWindowItem);		myDisableItem(FileMHdl, PrintingItem);{$ENDC}		ReturnComplexDisplayMenu;			end;{#################=== TREEWINDOW ===###########################}{----------------------------------------------------------------------------}	procedure SetPaletteAndLegendPositions (setpalette, setTreeLegend, setCharLegend: boolean);	begin		SetLockLegPts(toolPaletteWindow[treeTools], -1);		if setpalette then			begin				MoveWindow(toolPaletteWindow[treeTools], toolPalettePoint[treeTools].h, toolPalettePoint[treeTools].v, false);			end;		SetLockLegPts(tlegwindow, -1);		if setTreeLegend then			begin				MoveWindow(tlegwindow, tlegpt.h, tlegpt.v, false);			end;		SetLockLegPts(chlegwindow, -1);		if setCharLegend then			MoveWindow(chlegwindow, chlegpt.h, chlegpt.v, false);	end;{-----------------------------------------------------------------------------}	procedure SetTreeWindowExpMenu;	begin		if treeopen then			if TWFullScreen then				SetMenuItemText(TWDisplayMHdl, ZoomTWItem, 'Reduce Window')			else				SetMenuItemText(TWDisplayMHdl, ZoomTWItem, 'Expand Window');	end;{----------------------------------------------------------------------------}	procedure SetDrawTWRControls;		const			databtop = 5;		var			k: integer;			zmaxTWR: rect;	begin		zmaxTWR := maxTWR;		OffsetREct(zmaxTWR, -maxTWR.left, -maxTWR.top);		drawTWR.top := zmaxTWR.top;		drawTWR.left := zmaxTWR.left;		drawTWR.right := zmaxTWR.right - scrollwidth;		drawTWR.bottom := zmaxTWR.bottom - scrollwidth;{$IFC FLIPTREE}		if treeflipped then			drawTWR.right := drawTWR.right + 4 - TWmessW		else			drawTWR.bottom := drawTWR.bottom + 4 - TWmessW;{$ELSEC}		drawTWR.bottom := drawTWR.bottom + 4 - TWmessW;{$ENDC}		if treeopen then			CalcEdw(ntscreen);		databoxB.top := databtop;		RecalcBoxes;		databoxBHeight := databoxB.bottom - databtop;		SETRECT(dataBoxB, 0, databtop, (drawTWR.right - drawTWR.left) - 10, databtop + databoxBHeight);{$IFC FLIPTREE}		if treeflipped then			begin				SetControlValueLong(vTWScroll, TWOrigin.h);				SetControlValueLong(hTWScroll, TWOrigin.v);			end		else			begin				SetControlValueLong(vTWScroll, TWOrigin.v);				SetControlValueLong(hTWScroll, TWOrigin.h);			end;{$ELSEC}		if (GetControlMaximumLong(hTWScroll) < TWOrigin.h) then			TWOrigin.h := GetControlMaximumLong(hTWScroll)		else if  (TWOrigin.h < GetControlMinimumLong(hTWScroll)) then			TWOrigin.h := GetControlMinimumLong(hTWScroll);		if (GetControlMaximumLong(vTWScroll) < TWOrigin.v) then			TWOrigin.v := GetControlMaximumLong(vTWScroll)		else if  (TWOrigin.v < GetControlMinimumLong(vTWScroll)) then			TWOrigin.v := GetControlMinimumLong(vTWScroll);				SetControlValueLong(vTWScroll, TWOrigin.v);		SetControlValueLong(hTWScroll, TWOrigin.h);{$ENDC}		SetTWScrollMax;		treeonscreen := false;		CheckToolKit(treeTools,handT);		DropTool(treeTools,handT);	end;{----------------------------------------------------------------------------}	procedure SizeTreeWindow;		var			zmaxTWR: rect;	begin		CheckScreenRectangle;		zmaxTWR := maxTWR;		OffsetREct(zmaxTWR, -maxTWR.left, -maxTWR.top);		visTWR := zmaxTWR;				visTWR.right := visTWR.right - scrollwidth;		visTWR.bottom := visTWR.bottom - scrollwidth;{$IFC FLIPTREE}		if treeflipped then			visTWR.right := visTWR.right + 4 - TWmessW		else			visTWR.bottom := visTWR.bottom + 4 - TWmessW;{$ELSEC}		visTWR.bottom := visTWR.bottom + 4 - TWmessW;{$ENDC}		treerect := visTWR;		HideControl(vTWScroll);		HideControl(hTWScroll);		MoveControl(hTWscroll, -1, (maxTWR.bottom - maxTWR.top) - scrollwidth + 4);		SizeControl(hTWscroll, (maxTWR.right - maxTWR.left) - scrollwidth + 2, scrollwidth + 1);		SetDrawTWRControls;		twfullscreen := maxTWR.right - maxTWR.left > ScreenBoundsRect.right - ScreenBoundsRect.left;		SetTreeWindowExpMenu;		VertTWScrollPosition;		ShowControl(vTWScroll);		ShowControl(hTWScroll);		genericSetPort(treewindow);		SetLockLegPts(twmesswindow, -1);		MoveWindow(twmesswindow, messspot.h, messspot.v, false);		if locklegends then			SetPaletteAndLegendPositions(false,true,true);	end;{----------------------------------------------------------------------------}	procedure OpenTreeWindow;		var			j: integer;				begin		CheckScreenRectangle;		TWOrigin.h := 0;		TWOrigin.v := 0;		treemakingfailed := false;		treelength := 0;		if DuplicateNames then			InstantError(251);		comingback := true;		lastselN := subR;		if not expd then			ntscreen := numtaxain;{v3.02: removed:    CalcTaxonHeight;}		treeopen := true;		SizeTreeWindow;		HLock(Handle(filename));		SetWTitle(TreeWindow, filename^^);		HUnLock(Handle(filename));		ShowWindow(TreeWindow);		SelectWindow(TreeWindow);		{^&* theWindow := TreeWindow;}{========= Menus ==========}		SetTWMBar;		ReBuildAssumpMenu;		{AppendMenu(EditMHdl, '(-');		AppendMenu(EditMHdl, 'Evolve Characters...');}		DrawMenuBar;{$IFC NOT ALWAYSENABLED}		myEnableItem(FileMHdl, PrintingItem);		myDisableItem(EditMHdl, UndoItem);		myDisableItem(ShowMHdl, ShrinkItem);		myDisableItem(TreeMHdl, AllTermItem);{    myDisableItem(EdUtilitiesMHdl, SpeakItem);}{$ENDC}		myEnableItem(TreeMHdl, TreeListItem);		myEnableItem(TreeMHdl, SaveAsTreeFileItem);		myEnableItem(TreeMHdl, ExTreeFileItem);		myEnableItem(TreeMHdl, IncExcTaxaItem);		myEnableItem(CalcMHdl, LengthItem);{$IFC NOT ALWAYSENABLED}		myDisableItem(NewChartMHdl, ChartOptionsItem);		myDisableItem(NewChartMHdl, ChartPrintItem);		myDisableItem(NewChartMHdl, ChartquietRecalcItem);		myDisableItem(NewChartMHdl, ChartWtTypeItem);{$ENDC}		OpenTreeMenus;		myCheckMenuItem(ShowMHdl, Nex7OnItem, nex7on);		myEnableItem(TraceMHdl, TraceOnOffItem);		myEnableItem(TraceMHdl, TraceCharItem);		EnableDisableItem(TraceMHdl, TraceLastItem, (traceshown = traceDiscrete) and (i <> oldtracei));		FixTreeShadingMenus;		myEnableItem(ShowMHdl, Nex7onItem);		EnableDisableItem(TraceMHdl, UnfixAllItem, fixon);		myCheckMenuItem(TWDisplayMHdl, LockLegendsItem, locklegends);		myCheckMenuItem(ShowMHdl, BranchNumbersItem, showNodeNumbers);		myCheckMenuItem(ShowMHdl, EvolveSegsItem, showEvolveSegments);{$IFC REALLENGTHS}		myCheckMenuItem(ShowMHdl, EvolveRealLengthsItem, showEvolveRealLengths);{$ENDC}		{========= ===== ==========}		SizeInfoWindow(charinfo,true, true);		SizeInfoWindow(taxinfo,true, true);		genericSetPort(TreeWindow);		ClipRect(WindowPortRect(treeWindow));		SetOrigin(0, TWorigV);		ShowWindow(twmessWindow);		SelectWindow(twmessWindow);		if toolPaletteFirstAppearance[treeTools] then			MoveWindow(toolPaletteWindow[treeTools], toolPalettePoint[treeTools].h, toolPalettePoint[treeTools].v, toolPaletteOpen[treeTools]);					if toolPaletteOpen[treeTools] then			myShowWindow(toolPaletteWindow[treeTools]);		CheckCurrentTypes;		for j := 0 to numTools[treeTools] do			CheckToolKit(treeTools,j);		SizeTreeLeg(false);   {this is here so it comes up the right size first time}		myShowWindow(tlegWindow);		{$IFC FALSE}		SelectWindow(tlegwindow); {$ENDC}		genericSetPort(tlegwindow);		InvalidateWindowRect(tlegWindow, WindowPortRect(tlegwindow), false);		SetControlMaximumLong(tlegScroll, UserLinks[treechain]);		ShowControl(tlegScroll);		genericSetPort(treewindow);		godraw := false;		FullTreeOnScreenGoList; {sending all golists}		if infoOpen[taxinfo] then			InvalidateWindow(infoWindow[taxinfo], false);{    FlushEvents(mdownmask + keydownmask, 0);}		updateHasPriority := true;		CheckPixelDepth(treewindow);		ReBuildShowMenu(treeWindow);			end;{----------------------------------------------------------------------------}	procedure CloseTreeWindow (savethetree: boolean);	begin		if savethetree then			begin				if expd then					ShrinkTree;				HLock(Handle(treename));				if not dirtytree then					StoreTree(treedataH, treename^^)				else					StoreTree(treedataH, UnStoredLink);				HUnLock(Handle(treename));				SaveFixdataForTree(treedataH, fixdataH);				SaveSegmentsForTree(treedataH, segdataH); {Segments:}				SaveRealLengthsForTree(treedataH, realBranchLengthsDataH);			end;		goTWHome := false;   {cancel as don't need to do it!}		if equivcycle then			StopEquivCycle;		ClosePictWindow;		if charton then			CloseChartWindow;		if BranchListon then			CloseBranchListWindow;		if textWindowInfo[aboutTreesText]^.open then			CloseTextWindow(aboutTreesText,true);		if textWindowInfo[aboutTreeFileText]^.open then			CloseTextWindow(aboutTreeFileText,true);		if infoOpen[treeinfo] then			CloseInfoWindow(treeinfo);		myHideWindow(toolPaletteWindow[treeTools]);		myHideWindow(tlegWindow);		HideWindow(twmesswindow);		myHideWindow(chlegWindow);		HideWindow(TreeWindow);				treeopen := false;		treeonscreen := false;{========= Menus ==========}		SetNoWMBar;		if not quit then			ReBuildAssumpMenu;		DrawMenuBar;		{DeleteMenuItem(EditMHdl, TreeRandomDataItem);		DeleteMenuItem(EditMHdl, TreeRandomDataItem - 1);}		SetMenuItemText(FileMHdl, PrintingItem, 'Print...');		myEnableItem(TreeMHdl, TreeListItem);		myEnableItem(TreeMHdl, OpenTreeFileItem);{$IFC NOT ALWAYSENABLED}		myDisableItem(EditMHdl, UndoItem);		myDisableItem(TreeMHdl, StoreTreeItem);		myDisableItem(TreeMHdl, SaveTreeFileItem);		myDisableItem(TreeMHdl, SaveAsTreeFileItem);		myDisableItem(TreeMHdl, ExTreeFileItem);		myDisableItem(CalcMHdl, LengthItem);		myDisableItem(TreeMHdl, IncExcTaxaItem);		myDisableItem(TreeMHdl, AllTermItem);{		myDisableItem(TreeMHdl, SearchOptionsItem);}		myDisableItem(TreeMHdl, PolyRealItem);		myDisableItem(SaveOtherMHdl, SvTxtNodeListItem);		myDisableItem(FileMHdl, PrintingItem);{$ENDC}{========= ===== ==========}		DisposeNODEs;{$IFC FALSE}		while GetNextEvent(ActivateEvt, Event) do			DealWthActivates;{$ENDC}		SizeInfoWindow(charinfo,true, true);		SizeInfoWindow(taxinfo,true, true);	end;{----------------------------------------------------------------------------}{#################=== editorWindow ===###########################}{----------------------------------------------------------------------------}	procedure OpenEditEWDisplayMenu;	begin		myDisableItem(EWDisplayMHdl, EWStyleItem);		SetMenuItemText(EWDisplayMHdl, EWStyleItem, 'Italic');		SetItemCmd(EWDisplayMHdl, EWStyleItem, char(0));		SetItemMark(EWDisplayMHdl, EWStyleItem, char(noMark));		myCheckMenuItem(EWDisplayMHdl, EWStyleItem, false);		FixSizeMenu(SizeMHdl,editorFontSize);		FixStyleMenu(StyleMHdl,spreadstyle);		FixFontMenu(FontMHdl,editorFont, true);		myCheckMenuItem(EWDisplayMHdl, footTextItem, foottexton);		myCheckMenuItem(EWDisplayMHdl, FootstatesItem, not foottexton);		ReBuildShowMenu(editorWindow);	end;{----------------------------------------------------------------------------}	procedure OpenEdit;	var j: integer;	begin		editorOpen := true;{========= Menus ==========}		SetEWMBar;		ReBuildAssumpMenu;		AppendMenu(EditMHdl, '(-');		AppendMenu(EditMHdl, 'Entry Interpretation...');		AppendMenu(EditMHdl, 'Track Cell');		AppendMenu(EditMHdl, 'Editor Tools Treat Missing as Gap');		DrawMenuBar;		SetMenuItemText(FileMHdl, PrintingItem, 'Print Matrix...');		SetPrintExtraItem(editorWindow);		SetMenuItemText(EditMHdl, UndoItem, 'Undo');				OpenEditEWDisplayMenu;		{    myEnableItem(EdUtilitiesMHdl, SpeakItem);}		myEnableItem(TaxaMHdl, AddEmptyTaxaItem);		myEnableItem(CharactersMHdl, xxxxAddEmptyCharacterItem);		myEnableItem(EditMHdl, TrackCellItem);		myEnableItem(EditMHdl, TreatMissingAsGapItem);		{myEnableItem(EditMHdl, BlockMoveItem);}{    myEnableItem(EdUtilitiesMHdl, SpeakSetItem);}		{myEnableItem(EditMHdl, SelectItem);}		myEnableItem(FileMHdl, PrintingItem);		{SetMenuItemText(EditMHdl, SelectItem, 'Select All');}				SetStateNamesItem;		myCheckMenuItem(ShowMHdl, EWStateNamesItem, editorShowFullStateNames);		myCheckMenuItem(ShowMHdl, EWUseIUPACItem, editorShowIUPACSymbols);		myCheckMenuItem(EditMHdl, TrackCellItem, trackcell);		myCheckMenuItem(EditMHdl, TreatMissingAsGapItem, editorToolsTreatMissingAsGaps);		{myCheckMenuItem(EditMHdl, BlockMoveItem, moveCellBlocks);}				RebuildShadeCharSetMenu;		RebuildColorCodPosMenu;		RebuildConsensusTaxSetMenu;		CheckColorCharPartitionMenu;		CheckMismatchMenu;{$IFC NOT ALWAYSENABLED}		myDisableItem(EditMHdl, PasteItem);{$ENDC}{========= ===== ==========}		footediting := false;		footdirty := false;		SizeEditWindow;		HLock(Handle(filename));		SetWTitle(editorWindow, filename^^);		HUnLock(Handle(filename));		HideControl(editorVScroll);		Hidecontrol(editorHScroll);		SizeInfoWindow(charinfo,true, true);		ShowWindow(editorWindow);		SelectWindow(editorWindow);		{^&* theWindow := editorWindow;}		genericSetPort(editorWindow);		CalcEditorBoundaryRect;		CalcEditorMatrixRect;		SetScrollMax;		SetControlValueLong(editorVScroll, editorOrigin.v - 1);		SetControlValueLong(editorHScroll, editorOrigin.h - 1);		SetLockLegPts(toolPaletteWindow[editorTools], -1);		if toolPaletteFirstAppearance[editorTools] then			MoveWindow(toolPaletteWindow[editorTools], toolPalettePoint[editorTools].h, toolPalettePoint[editorTools].v, toolPaletteOpen[editorTools]);		if toolPaletteOpen[editorTools]  then			myShowWindow(toolPaletteWindow[editorTools]);		for j := 0 to numTools[editorTools] do			CheckToolKit(editorTools,j);		SetRect(editorShimmerRect,0,0,0,0);		updateHasPriority := true;		myCheckMenuItem(WindowsMHdl, ToolPaletteItem, toolPaletteOpen[editorTools]);		FixTextMenus;		FixAssumpMenu;	end;{----------------------------------------------------------------------------}	procedure CloseEditEWDisplayMenu;	begin		myEnableItem(EWDisplayMHdl, EWStyleItem);		myCheckMenuItem(EWDisplayMHdl, EWStyleItem, false);{this section reattaches the hierachical menu which was stripped in going to the editor}		SetItemCmd(EWDisplayMHdl, EWStyleItem, char(27));		SetItemMark(EWDisplayMHdl, EWStyleItem, char(StyleMenu));		InsertMenu(StyleMHdl, -1);		SetMenuItemText(EWDisplayMHdl, EWStyleItem, 'Style');		myEnableItem(StyleMHdl, 0);	end;{----------------------------------------------------------------------------}	procedure CloseEdit;	begin		if docellcheck and editorSelected and editorOpen and SingleCell then			begin				ReturnValue(editorSelectionTopLeft,false);				if badcellentry then					if BadCellEntryQuery then						badcellentry := false					else						Exit(CloseEdit);			end;		SetLastChangeInEditor(lastChangeCantUndo);		if not quit then  {v4: don't do this if closing file}			begin				if dirtymaxst then					ReCalcMaxstAndStates(1,numchars);			end;		editorSelected := false;		SelCellChanged := false;		SetLastChangeInEditor(lastChangeCantUndo);		editorSelectionTopLeft.v := 0;		editorSelectionTopLeft.h := 0;		editorSelectionBotRight := editorSelectionTopLeft;		myHideWindow(toolPaletteWindow[editorTools]);		HideWindow(editorWindow);{========= Menus ==========}		CloseEditEWDisplayMenu;				{DeleteMenuItem(EditMHdl, BlockMoveItem);}		DeleteMenuItem(EditMHdl, TreatMissingAsGapItem);		DeleteMenuItem(EditMHdl, TrackCellItem);		DeleteMenuItem(EditMHdl, EntryInterpretItem);		DeleteMenuItem(EditMHdl, EntryInterpretItem - 1);		{DeleteMenuItem(EditMHdl, PICTRemoveItem);		DeleteMenuItem(EditMHdl, PICTAddItem);		DeleteMenuItem(EditMHdl, PICTAddItem - 1);}		SetNoWMBar;		ReBuildAssumpMenu;		DrawMenuBar;		{SetMenuItemText(EditMHdl, SelectItem, 'Select');}		SetMenuItemText(FileMHdl, PrintingItem, 'Print...');		ClosedEditMenus;		myDisableItem(FileMHdl, PrintingItem);{========= ===== ==========}		editorOpen := false;		grow1 := MaxMem(grow2);	end;{----------------------------------------------------------------------------}	procedure ReSizeTextWindow (whichText, height, width: integer; showhidescroll: boolean);		var			newHeight: integer;	begin		if showHideScroll then			HideControl(textWindowInfo[whichText]^.scroll);		newHeight := height;		ShrinkTextWindowHeight(whichText, newHeight);		SizeWindow(textWindow[whichText], width, newHeight, true);		MoveControl(textWindowInfo[whichText]^.scroll, width - scrollwidth, -1);		SizeControl(textWindowInfo[whichText]^.scroll, scrollwidth + 1, newHeight - scrollwidth + 2);		if showHideScroll then			begin				ClipRect(WindowPortRect(textWindow[whichText]));				ShowControl(textWindowInfo[whichText]^.scroll);			end;	end;{-----------------------------------------------------------------------------}	function AnyTextWindowWasOpen: boolean;		var			j: integer;	begin		AnyTextWindowWasOpen := false;		for j := 1 to numTextWindows do			if textWindowInfo[j]^.wasOpen then				begin					AnyTextWindowWasOpen := true;					leave;				end;	end;{----------------------------------------------------------------------------}	procedure OpenTextWindow (whichText: integer);		var			tport: WindowPtr;			height: integer;			textWindowPtr: textWindowInfoPtr;	begin		textWindowPtr := textWindowInfo[whichText];		if (textWindowPtr <> nil) & (textWindow[whichText]<>nil) then			begin								genericGetPort(tport);				genericSetPort(textWindow[whichText]);				{if not textWindowInfo[whichText]^.open then					begin						textWindowInfo[whichText]^.TE^^.txFont := kFontIDCourier;						textWindowInfo[whichText]^.TE^^.txSize := 10;					end;}				TextFont(textWindowInfo[whichText]^.font);				TextSize(textWindowInfo[whichText]^.size);						textWindowInfo[whichText]^.TE^^.txFont := textWindowInfo[whichText]^.font;						textWindowInfo[whichText]^.TE^^.txSize := textWindowInfo[whichText]^.size;				ReSizeTextWindow(whichText, WindowPortRect(textWindow[whichText]).bottom, WindowPortRect(textWindow[whichText]).right, textWindowInfo[whichText]^.open);				if not textWindowInfo[whichText]^.open then					begin						textWindowInfo[whichText]^.origin := 0;						SetControlValueLong(textWindowInfo[whichText]^.scroll, 0);						SizeTextWindowText(whichText, false, true, false);						if not textWindowInfo[whichText]^.hasbeenopen then							begin								numTextWindowsThatHaveBeenOpen := numTextWindowsThatHaveBeenOpen + 1;								MoveWindow(textWindow[whichText], 5 + numTextWindowsThatHaveBeenOpen * 20, 30 + numTextWindowsThatHaveBeenOpen * 20, false);							end;					end;				textWindowInfo[whichText]^.open := true;{    SetCommWindowTitle;}				ShowWindow(textWindow[whichText]);				SetMenuItemText(FileMHdl, PrintingItem, 'Print Notes...');				myEnableItem(FileMHdl, PrintingItem);				{^&* theWindow := textWindow[whichText];}				ClipRect(WindowPortRect(textWindow[whichText]));				EraseRect(WindowPortRect(textWindow[whichText]));				SelectWindow(textWindow[whichText]);				TESetSelect(0, 0, textWindowInfo[whichText]^.TE);				TEActivate(textWindowInfo[whichText]^.TE);				DrawTextWindow(whichText);				DrawGrowBox(textWindow[whichText]);				genericSetPort(tport);				textWindowInfo[whichText]^.hasbeenOpen := true;			end;	end;		{$IFC FALSE}{----------------------------------------------------------------------------}	procedure CloseCommWindow;	begin		HideWindow(commwindow);		aboutopen := false;		SetMenuItemText(FileMHdl, PrintingItem, 'Print...');		myDisableItem(FileMHdl, PrintingItem);	end;{----------------------------------------------------------------------------}	procedure ReSizeCommWindow (height, width: integer; showhidescroll: boolean);		var			newHeight: integer;	begin		if showHideScroll then			HideControl(commScroll);		newHeight := height;		ShrinkCommWindowHeight(newHeight);		SizeWindow(commWindow, width, newHeight, true);		MoveControl(commScroll, width - scrollwidth, -1);		SizeControl(commScroll, scrollwidth + 1, newHeight - scrollwidth + 2);		if showHideScroll then			begin				ClipRect(WindowPortRect(commWindow));				ShowControl(commScroll);			end;	end;{----------------------------------------------------------------------------}	procedure OpenCommWindow;		var			tport: WindowPtr;			height: integer;	begin		if not aboutOpen then			begin				commentsTE[curcom]^^.txFont := kFontIDGeneva;				commentsTE[curcom]^^.txSize := 9;			end;		ReSizeCommWindow(WindowPortRect(commWindow).bottom, WindowPortRect(commWindow).right, aboutOpen);		if not aboutOpen then			begin				commOrigin := 0;				SetControlValueLong(commScroll, 0);				SizeCommWindowText(false, true, false);			end;		genericGetPort(tport);		aboutopen := true;{    SetCommWindowTitle;}		ShowWindow(commWindow);		SetMenuItemText(FileMHdl, PrintingItem, 'Print Notes...');		myEnableItem(FileMHdl, PrintingItem);		theWindow := commWindow;		genericSetPort(commWindow);		ClipRect(WindowPortRect(commWindow));		EraseRect(WindowPortRect(commWindow));		SelectWindow(commWindow);		TESetSelect(0, 0, commentsTE[curcom]);		TEActivate(commentsTE[curcom]);		DrawCommWindow;		DrawGrowBox(commwindow);		genericSetPort(tport);	end;	{$ENDC}{----------------------------------------------------------------------------}	procedure CalcToTextfile (isrecalc: boolean);		var			Freply: SFReply;			oldExists: boolean;	begin		if PromptCreateSimpleFile('Save calculations file as', 'Chart Log', oldExists,chartCalcFileFDI) then			begin				ShowCursor;				currentIOPosition := 70;   {v3.05}				CalcChartData(isrecalc);			end		else			begin				ChartCalcToText := false;				CalcChartData(isrecalc);			end;	end;{-----------------------------------------------------------------------------}	procedure OpenChartWindow;		var			tempP: WindowPtr;	begin		genericGetPort(tempP);		chartintervals := 0;		CWLinear := (CWChart in [CWCSteps, CWCStates, CWCCTAll, CWCC2T, CWCC2TF, CWCcst, CWCProbSteps]);		if ((CWView = histoview) and not CWLinear) then			CWView := scatterview		else if ((CWView = scatterview) and CWLinear) then			CWView := histoview;		SetCursor(clockCursor);		ChartWindowTitle;		genericSetPort(ChartWindow);		if ChartCalcToText then			begin				CalcToTextfile(false);				if errorflag then					begin{charton := false;}						if charton then							PleaseOffChart := true;						genericSetPort(tempP);						Exit(OpenChartWindow);					end;			end		else			CalcChartData(false);		charton := true;		ShowWindow(ChartWindow);		{^&* theWindow := ChartWindow;}		SelectWindow(ChartWindow);		InvalidateWindow(ChartWindow, true);		CWTableTop := 0;		chartorigin := 0;		if CWLinear then			begin				SetControlMinimumLong(CWScroll, 0);				SetControlValueLong(CWScroll, 0);			end		else			Hidecontrol(CWScroll);		myEnableItem(NewChartMHdl, ChartOptionsItem);		myEnableItem(NewChartMHdl, ChartPrintItem);		myEnableItem(NewChartMHdl, ChartquietRecalcItem);{    EnableDisableItem(NewChartMHdl, ChartWtTypeItem, (CWView <> infoview) and not emptychart and (((CWChart = CWCSteps) and (sequencechart or positionchart)) or (CWChart = CWCChanges)));}		if CWChart = CWCSteps then			SetMenuItemText(NewChartMHdl, ChartWtTypeItem, 'Chart To Weight Set...')		else if CWChart = CWCChanges then			SetMenuItemText(NewChartMHdl, ChartWtTypeItem, 'Chart To Type...');		myEnableItem(SaveOtherMHdl, svTxtWindowItem);		myEnableItem(FileMHdl, PrintingItem);		Textsize(CWfontsize);		TextFont(CWfont);		TextFace(CWstyle);		CalcCWBoxes(WindowPortRect(chartWindow));		SetCursorToArrow;	end;{-----------------------------------------------------------------------------}	procedure CloseChartWindow;		var			j: integer;	begin		calcRestChanges := false;		charton := false;		ResetGoMask;		HideWindow(ChartWindow);		for j := 0 to numCLkinds do			begin				HUnlock(ChartLinearData[j]);				SetHandleSize(ChartLinearData[j], 0);			end;{$IFC NOT ALWAYSENABLED}		myDisableItem(NewChartMHdl, ChartOptionsItem);		myDisableItem(NewChartMHdl, ChartPrintItem);		myDisableItem(NewChartMHdl, ChartquietRecalcItem);		myDisableItem(NewChartMHdl, ChartWtTypeItem);		myDisableItem(SaveOtherMHdl, svTxtWindowItem);		myDisableItem(FileMHdl, PrintingItem);{$ENDC}		SetTWMBar;		ReBuildShowMenu(treeWindow);	end;{----------------------------------------------------------------------------}	procedure ZoomInfoWindowCalcs (whichinfo: integer; var width, height: integer;  userStateRect: rect; var standardStateRect: Rect);	begin		width := GetWindowMaxContentWidth(infoWindow[whichinfo]);		if width > InfoColumnRight(whichinfo, MaximumInfoColumns(whichinfo)) + scrollwidth + 1 then			width := InfoColumnRight(whichinfo, MaximumInfoColumns(whichinfo)) + scrollwidth + 1;		if userStateRect.left + width < ScreenBoundsRect.right then			standardStateRect.left := userStateRect.left    {stay where you are}		else			standardStateRect.left := 2;   {bounce to left of screen}		standardStateRect.right := standardStateRect.left + width;		height := GetWindowMaxContentHeight(infoWindow[whichinfo]);		ShrinkWrapInfoWindow(whichinfo, height,width);		if userStateRect.top + height < ScreenBoundsRect.bottom then			standardStateRect.top := userStateRect.top    {stay where you are}		else			standardStateRect.top := GetWindowDefaultTop(infoWindow[whichinfo]);   {bounce to top of screen}		standardStateRect.bottom := standardStateRect.top + height;	end;{----------------------------------------------------------------------------}	procedure ZoomInfoWindowCleanUp (whichinfo: integer);	begin		ClipRect(WindowPortRect(whichWindow));		ShrinkWrapInfoWindow(whichinfo, WindowPortRect(infowindow[whichInfo]).bottom,WindowPortRect(infowindow[whichInfo]).right);		ResetInfoScroll(whichinfo);		CalcInfoButtonRowBoxes(whichinfo);		AdjustInfoScrolls(whichinfo);{SizeControl(infoScroll[whichinfo], scrollwidth + 1, height - scrollwidth - infoLW[whichinfo] + 1); ShowControl(infoScroll[whichinfo]);}	end;{----------------------------------------------------------------------------}	function GetWindowStandardSize(whichWindow: WindowPtr): Point;		var			width, height, whichinfo: integer;			idealSize: Point;			box: rect;	begin		if whichwindow = editorWindow then			begin				height := GetWindowMaxContentHeight(editorWindow);				width := GetWindowMaxContentWidth(editorWindow);				ShrinkWrapEditWindow(height, width);			end		else if IsInfoWindow(whichwindow) then			begin				whichinfo := WhichInfoWindow(whichWindow);				width := GetWindowMaxContentWidth(infoWindow[whichinfo]);				if width > InfoColumnRight(whichinfo, MaximumInfoColumns(whichinfo)) + scrollwidth + 1 then					width := InfoColumnRight(whichinfo, MaximumInfoColumns(whichinfo)) + scrollwidth + 1;				height := GetWindowMaxContentHeight(infoWindow[whichinfo]);				ShrinkWrapInfoWindow(whichinfo, height,width);			end		else if whichwindow = pictwindow then			begin				box := PictBox;				width := box.right - box.left;				height := box.bottom - box.top;			end		else if whichwindow=stateswindow then			begin				height := ScreenBoundsRect.bottom - 12;				width := StringWidth('M')*characterNameLength;				if width > ScreenBoundsRect.right-12 then					width := ScreenBoundsRect.right-12;				ShrinkWrapStatesWindow(height);			end		else if whichwindow=treewindow then			begin				height := GetWindowMaxContentHeight(treeWindow);				width := GetWindowMaxContentWidth(treeWindow);			end;		idealSize.h := width;		idealSize.v := height;		GetWindowStandardSize := idealSize;	end;{----------------------------------------------------------------------------}	procedure Zoom; {whichwindow: windowPtr; whichway: integer}{this procedure handles clicks on the zoom boxes of windows}	{	type			WstateDataHandle = ^WstateDataPtr;			WstateDataPtr = ^WstateData;}		var			pos: point;			WSDH: WstateDataHandle;			width, height: integer;			box: rect;			tl: point;			tport: WindowPtr;			userStateRect, standardStateRect: Rect;			os: OSStatus;			idealSize: Point;	begin		genericGetPort(tport);		genericSetPort(whichwindow);		tl := WindowPortRect(whichWindow).topleft;		LocalToGlobal(tl);		ClipRect(WindowPortRect(whichWindow));		EraseREct(WindowPortRect(whichWindow));{$IFC CARBON}		os := GetWindowIdealUserState(whichWindow,userStateRect);		idealSize := GetWindowStandardSize(whichWindow);		box:= standardStateRect;		if IsWindowInStandardState(whichWindow, PointPtr(@idealSize), RectPtr(@box)) then			os := ZoomWindowIdeal(whichWindow,inZoomIn,idealSize)		else			os := ZoomWindowIdeal(whichWindow,inZoomOut,idealSize);{$ELSEC}		WSDH := WstateDataHandle(WindowPeek(whichwindow)^.dataHandle);		standardStateRect := WSDH^^.stdState;		userStateRect := WSDH^^.userState;		if whichwindow = editorWindow then			begin				height := GetWindowMaxContentHeight(editorWindow);				width := GetWindowMaxContentWidth(editorWindow);				ShrinkWrapEditWindow(height, width);				standardStateRect.right := standardStateRect.left + width;				standardStateRect.bottom := standardStateRect.top + height;			end		else if IsInfoWindow(whichwindow) then			ZoomInfoWindowCalcs(WhichInfoWindow(whichwindow), width, height, userStateRect, standardStateRect)		else if whichwindow = pictwindow then			begin				box := PictBox;				width := box.right - box.left;				height := box.bottom - box.top;				if (userStateRect.left + width < ScreenBoundsRect.right) then					standardStateRect.left := userStateRect.left;				standardStateRect.left := userStateRect.left;				standardStateRect.right := userStateRect.left + width;				if (userStateRect.top + height < ScreenBoundsRect.bottom) then					standardStateRect.top := userStateRect.top;				standardStateRect.bottom := standardStateRect.top + height;			end		else if whichwindow=stateswindow then			begin				height := ScreenBoundsRect.bottom - 12;				width := StringWidth('M')*characterNameLength;				if width > ScreenBoundsRect.right-12 then					width := ScreenBoundsRect.right-12;				ShrinkWrapStatesWindow(height);				standardStateRect.right := standardStateRect.left + width;				standardStateRect.bottom := standardStateRect.top + height;			end		else if whichwindow=treewindow then			begin			end;		WSDH^^.stdState := standardStateRect;		if whichwindow = treewindow then			ZoomWindow(whichWindow, whichway, false)		else			ZoomWindow(whichWindow, whichway, true);{$ENDC}		InvalidateWindow(whichwindow, true);		ClipRect(WindowPortRect(whichWindow));		if whichwindow = editorWindow then			begin				pos.h := maxEWR.left;				pos.v := maxEWR.top;				maxEWR := WindowPortRect(whichWindow);				OffSetRect(maxEWR, pos.h, pos.v);				ReSizeEditorWindow;			end		else if whichwindow = treewindow then			begin				pos.h := maxTWR.left;				pos.v := maxTWR.top;				maxTWR := WindowPortRect(whichWindow);				OffSetRect(maxTWR, pos.h, pos.v);				SizeTreeWindow;			end		else if isInfoWindow(whichwindow) then			ZoomInfoWindowCleanUp(WhichInfoWindow(whichwindow))		else if (Whichwindow = Chartwindow) and CWLinear then			CalcCWBoxes(WindowPortRect(chartWindow))		else if whichwindow=statesWindow then			begin				SizeStatesWindow;			end;		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	procedure WindowPop (shrinkit: boolean; allowChangeMaxTWR:boolean);{if shrinkit is true, then this procedure will shrink the treewindow so that it }{just fits inside desktop, with title bar, scroll bars, etc. visible; }{if shrinkit is false, then this procedure will expand the treewindow so that it}{fills the whole screen}		var			width, height: integer;			pos: point;			tport: windowptr;			oldClip: RgnHandle;	begin		oldClip := NewRgn;		genericGetPort(tport);		genericSetPort(treewindow);		GetClip(OldClip);		twfullscreen := not shrinkit;		ClipRect(WindowPortRect(treeWindow));		EraseRect(WindowPortRect(treeWindow));		if allowChangeMaxTWR then			begin				if shrinkit then					begin						MoveWindow(treewindow, GetWindowDefaultLeft(treeWindow), GetWindowDefaultTop(treeWindow), false);						width := GetWindowMaxContentWidth(treeWindow);						height := GetWindowMaxContentHeight(treeWindow);						//width := ScreenBoundsRect.right - ScreenBoundsRect.left - 6;						//height := ScreenBoundsRect.bottom - ScreenBoundsRect.top - editorWindowTop - 4;					end				else					begin						MoveWindow(treewindow, 0, GetMBarHeight, false);						width := ScreenBoundsRect.right - ScreenBoundsRect.left + 15;						height := ScreenBoundsRect.bottom - ScreenBoundsRect.top - 3;					end;			end		else			begin				width := maxTWR.right-maxTWR.left;				height := maxTWR.bottom-maxTWR.top;			end;		SetTreeWindowExpMenu;		SizeWindow(treewindow, Width, Height, false);		pos.h := maxTWR.left;		pos.v := maxTWR.top;		maxTWR := WindowPortRect(treeWindow);		OffSetRect(maxTWR, pos.h, pos.v);		if treeopen then			begin				SizeTreeWindow;				InvalidateWindowRect(treewindow,WindowPortRect(treeWindow),false);			end;		SetClip(OldClip);		genericSetPort(tport);		ZapRegion(oldClip);	end;{-----------------------------------------------------------------------------}	procedure MoveWindowHome (theWindow: WindowPtr);	begin	end;{-----------------------------------------------------------------------------}end.