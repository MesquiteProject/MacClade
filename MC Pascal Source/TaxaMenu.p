unit TaxaMenu;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, ChangeAssumptions,		Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, 		GenUtil, StrUtil, BoxUtil, ChartWWrite, SymbolsNames, TaxonCHUtil, TypeUtil, Prohibitions, 		TypeDLOGUtil, CharUtil, MenuUtil, TreeUtil, PolyCalc, SetStates, SpreadUtil, LinkUtil, Legends, 		N7on, InfoWindows, Count, TraceControl, TreeMaker, Windows, Typeimport, 		TypeDLOG, ClickInInfoWindow, GenOpenFile,DisplayMenu;	function QueryImportSequencesDLOG(fileType: integer; var addAsNewSequences, saveCharSet,nameAsFile: boolean; var charSetName: str255): boolean; 	procedure DoImportTaxaMenu (ItemNo: integer);	procedure DoTaxonSetsMenu (ItemNo: integer);	procedure DoTaxaListOptionsMenu (ItemNo: integer);	procedure DoTaxaMenu (ItemNo: integer);	var		ExamineExcluded, MustBeIdentical: boolean;{еееееееееееееееееееееее}implementation {е$S TaxaMenu}{-----------------------------------------------------------------------------}	procedure DoAddTaxa;	var			theDialog: DialogPtr;			tempP: windowptr;			addit: longint;			localItemHit: integer;			addToEnd: boolean;	begin		addToEnd := true;		StartDLOG(403, theDialog, tempP);		myShowDialog(theDialog);		SetDLOGText(theDialog, 3, '1', false);		SelectDialogItemText(theDialog,3,0,32767);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);		until (localItemHit in [1, 2, 6]);		if localItemHit=6 then			begin				addToEnd := false;				localItemHit := 1;			end;		if localItemHit = 1 then			addit := EditTextInt(TheDialog, 3, true);		EndDLOG(thedialog, tempP);		if localItemHit = 1 then			if (addit > 0) then				begin					SetCursor(clockCursor);					if addit + numtaxa > mntaxa then {v3.01}						begin							addit := mntaxa - numtaxa;							NewError(398, 0);						end;					if addToEnd then						AddNewTaxa(addit, molecular)					else						InsertNewTaxa(addit,1,molecular);					SetLastChangeInEditor(lastChangeAddTaxa);					genericSetPort(editorWindow);					EraseRect(WindowPortRect(editorWindow));					InvalidateWindowRect(editorWindow,WindowPortRect(editorWindow),false);					CalcEditorMatrixRect;				end			else				Beep;	end;{-----------------------------------------------------------------------------}	procedure ReOrderTaxaByTree;		var			terminalTaxaEncountered: integer;			it, nextTaxonToMove,taxonToMove: integer;	{.................}		procedure FindNextTaxon (N: NPtr);		begin			if NodeIsInternal(N) then				begin					FindNextTaxon(N^.lf);					FindNextTaxon(N^.rt);				end			else				begin					terminalTaxaEncountered := terminalTaxaEncountered+1;   {this keeps track of the number of terminal taxa encountered as the tree is traversed}					if terminalTaxaEncountered = it then   						begin							nextTaxonToMove:= N^.name;							MoveTaxa(nextTaxonToMove,nextTaxonToMove,it);						end;				end;		end;	{.................}	begin		SetUpBeforeRowMove(taxinfo);		for it := 1 to numtaxain do			begin				terminalTaxaEncountered := 0;				FindNextTaxon(R);						end;		CleanUpAfterRowMove(taxinfo,false);	end;{-----------------------------------------------------------------------------}	procedure ReOrderTaxaRandomly;		var			it, randomTaxon: integer;	begin		if editorSelected & editorOpen then			begin				if SingleCell then 					begin						ReturnValue(editorSelectionTopLeft,false);						if badcellentry then							if BadCellEntryQuery then								badcellentry := false							else								Exit(ReOrderTaxaRandomly);						SetEWClip(noscroll);					end;				ZeroSelection;			end;		SetUpBeforeRowMove(taxinfo);		for it := 1 to numtaxa do			begin				randomTaxon := RandomBetween(it,numtaxa);							MoveTaxa(randomTaxon,randomTaxon,it);			end;		CleanUpAfterRowMove(taxinfo,false);		if editorOpen then			InvalidateWindow(editorWindow,true);	end;{-----------------------------------------------------------------------------}{	function ComparePointers (ctypP: ptr; mustbeidentical, respectcase, examineexcluded: boolean; numbytes: integer; src, dest: Ptr; numchars: integer): boolean;	EXTERNAL;}{if MustBeIdentical is true , then ComparePointer returns true iff all states are absolutely identical , }{otherwise returns true iff }{1:  states are identical }{2:  one is missing , the other is not }{3:  one and only one is uncertain , and the certain one is a subset of the uncertain one }{4:  they are both uncertain , and the intersection of the two exists }{-----------------------------------------------------------------------------}	procedure MergeTwoTaxaStates (it1, it2: integer);{merges states of taxon it1 and it2, placing the result in taxon it1}		var			ic: integer;			stsST, stsIT, stsFinal: LargestSetChars;	begin		for ic := 1 to numchars do			begin				stsST := gettaxonstslargest(it1, ic);				stsIT := gettaxonstslargest(it2, ic);				if stsST <> stsIT then					begin						if MSl in stsST then   {ST is missing or gap}							begin								if MSl in stsIT then									stsFinal := stsST + stsIT   {notice: if one or more gap, turns into a gap}								else									stsFinal := stsIT;							end						else if MSl in stsIT then							stsFinal := stsST						else if not ((UCl in stsIT) or (UCl in stsST)) then   {both are monomorphic, or it's just polymorphisms}							stsFinal := stsST + stsIT						else    					{at least one must be partial uncertainty}							begin								if (UCl in stsIT) and (UCl in stsST) then    {both are uncertain}									begin										stsFinal := stsIT * stsST;										if stsFinal = [UCl] then  {the intersection didn't exist}											begin												stsFinal := stsIT + stsST;												NewError(102, 0);											end;									end								else												{only one is uncertain}									begin										if stsIT * stsST = [] then    {one is uncertain, but they don't intersect}											NewError(102, 0);										if UCl in stsIT then  {take certain one}											stsFinal := stsST										else											stsFinal := stsIT;									end;							end;						settaxonstslargest(it1, ic, stsFinal);					end;			end;	end;{-----------------------------------------------------------------------------}	procedure MergeTaxa (st, et: integer; andbetween,eraseInfoWindow, mergeNames: boolean);{if andbetween true, then merges all taxa from st to et, and places merged taxa into taxon st}{else if andbetween false, then merges taxa st and et, places into taxon st}		var			it: integer;			ds: str255;			toolong: boolean;			piecelength, etLength, stLength: integer;	begin		if Locked(lockData) then			Exit(MergeTaxa);		SetCursor(clockCursor);		if andbetween then			begin				piecelength := tnw div (et - st + 1);				toolong := piecelength < 3;				if toolong then					begin						ds := concat(CopyString(TaxonName(st), 1, tnw - 9), '+', StringFromNum(et - st), ' others')					end				else					ds := CopyString(TaxonName(st), 1, piecelength);				for it := st + 1 to et do					begin						if not toolong then							ds := concat(ds, '+', CopyString(TaxonName(it), 1, piecelength));  {limit length of each name}						MergeTwoTaxaStates(st, it);					end;			end		else   {this must be automerge}			begin				MergeTwoTaxaStates(st, et);				if mergeNames then					begin						stLength := Length(TaxonName(st));						etLength := Length(TaxonName(et));						if (stLength + etLength) + 1 > tnw - 4 then							begin								if CopyString(TaxonName(st), stLength - 3, stLength) <> '+...' then									ds := concat(CopyString(TaxonName(st), 1, tnw - 4), '+...')								else									ds := TaxonName(st);							end						else							ds := concat(TaxonName(st), '+', TaxonName(et));						SetTaxonName(st, ds);					end;			end;		if mergeNames then			SetTaxonName(st, ds);		editorSelectionBotRight := editorSelectionTopLeft;		if not editorTransposed then			editorSelectionBotRight.h := numchars		else			editorSelectionBotRight.v := numchars;		editorSelected := true;		if andbetween then			DestroyTaxa(st + 1, et,true,eraseInfoWindow)		else			DestroyTaxa(et, et,true,eraseInfoWindow);		InvalidateWindow(editorWindow, true);		CalcEditorSelectionRect(editorSelectionTopLeft, editorSelectionBotRight);		CalcEditorMatrixRect;	end;{-----------------------------------------------------------------------------}	procedure MergeSelected;		var			st, et, sc, ec: integer;	begin		CalcSelectedTaxaCharacters(st, et, sc, ec, true);		if (et > st) & WholeTaxonSel then			MergeTaxa(st, et, true,true,true);	end;{-----------------------------------------------------------------------------}	function CheckForDuplicateTaxa (itstart,itend: integer; taxbits: Ptr; remove,respectCase,outtofile,mergeNames,selectInList: boolean; outputH: Handle; var numdest: integer): boolean;		var			it, tt, oldit, oldnumtaxa,newitend: integer;			dupfound: boolean;			TD: DialogPtr;			tempP: WindowPtr;			sp1, sp2, ctypP: Ptr;			dh, dh2: handle;			dL, dLChar: longint;{...........}		procedure LockAndMasters;		begin			HLock(TaxstsCHUNKs);			dL := GetMaster(TaxstsCHUNKs);			HLock(chtypH);			ctypP := Pointer(GetMaster(chtypH));		end;{...........}		procedure GetSP (var whichsp: Ptr; var whichH: Handle; taxnum: integer);		begin			whichH := HdlPtr(dL + HdlSize * (taxnum - 1))^;			HLock(whichH);			whichsp := Ptr(GetMaster(whichH));		end;{...........}		function AlreadyMarkedAsDuplicate (it: integer): boolean;		begin			AlreadyMarkedAsDuplicate := BitTst(Pointer(longint(taxbits) + 4 * (it div 32)), it mod 32);		end;{...........}	begin		numdest := 0;		if selectInList then			begin				for it := 1 to numtaxa do					SelectInfoCell(taxinfo,it,false,false);				ChangeInfoSelectMenuFix(taxinfo);			end;		dupfound := false;		DisableWindowUpdates(infowindow[taxinfo]);		DisableWindowUpdates(editorwindow);		StartThermo(TD, tempP, 0, numtaxa, 'Searching through selected taxa', 'taxa', false);		it := itstart;		newitend := itend;		oldit := itstart;		oldnumtaxa := numtaxa;		HLock(Handle(chCHUNKs));		dLchar := GetMaster(chCHUNKs);		LockAndMasters;{"it" is the number of the taxon, against which other taxa are to be compared}		while it <= newitend - 1 do			begin				UpdateThermo(TD, 0, oldit, oldnumtaxa,false);				if abortedThermo then					leave;				tt := it + 1;				GetSP(sp1, dh, it);{now cycle through other taxa, from tt to numtaxa, and see if any matches to "it".  }{Note, only do this if taxon "it" has not been previously marked as a duplicate.}{Note that if remove is true, then taxa are never marked}{as identical, they are just merged.}				if remove | not AlreadyMarkedAsDuplicate(it) then					while tt <= newitend do						begin							GetSP(sp2, dh2, tt);							if ComparePointers(ctypP, mustbeidentical, respectcase, examineexcluded, numbytes, sp1, sp2, numchars,0) then								begin									dupfound := true;									numdest := numdest + 1;									if outtofile then										AppendToHandle(outputH, concat(TaxonName(tt), ' same as ', TaxonName(it), chr(13)));									if remove then										begin											HUnLock(dh2);											HUnlock(TaxstsCHUNKS);											HUnLock(chtypH);											MergeTaxa(it, tt, false,false,mergeNames);											newitend := newitend-1;  {adjust endpoint}											LockAndMasters;											GetSP(sp1, dh, it);											tt := tt - 1;											if selectInList then												SelectInfoCell(taxinfo,it,true,false);										end									else										begin											if mustbeidentical then												BitSet(Pointer(longint(taxbits) + 4 * (tt div 32)), tt mod 32);  {mark as a duplicate }											if selectInList then												begin													SelectInfoCell(taxinfo,it,true,false);													SelectInfoCell(taxinfo,tt,true,false);												end;											HUnLock(dh2);										end;								end							else								HUnLock(dh2);							tt := tt + 1;						end;				HUnlock(dh);				it := it + 1;				oldit := oldit + 1;			end;		ChangeInfoSelectMenuFix(taxinfo);		HUnLock(chtypH);		HUnLock(TaxstsCHUNKs);		HUnLock(Handle(chCHUNKs));		EndThermo(TD, tempP, true);		CheckForDuplicateTaxa := dupfound;	end;{-----------------------------------------------------------------------------}	procedure FilterTaxa;		label 1;		type			LP = ^longint;		var			longPtr: LP;			longZero: longint;			theDialog: DialogPtr;			tempP: windowptr;			outputH: Handle;			j, it, ic, numdest,st,et,sc,ec: integer;			taxbits: Ptr;			outtofile: boolean;			localItemHit: integer;			respectCase, mergeNames,selectInList: boolean;{............}		procedure CheckFilterTaxa;		begin			ItemCheckMark(theDialog, 5, not ExamineExcluded);			ItemCheckMark(theDialog, 6, not MustBeIdentical);			ItemCheckMark(theDialog, 7, outtofile);			ItemCheckMark(theDialog, 9, respectcase);			ItemCheckMark(theDialog, 10, selectInList);			ItemCheckMark(theDialog, 11, mergeNames);		end;{...........}	begin		respectCase := false;		mergeNames := false;		selectInList := true;		outtofile := false;		taxbits := NewPtr(4 * (numtaxa div 32) + 4);		{taxbits stores identical taxa found so far so that you don't recount them}		LongPtr := LP(taxbits);		longzero := 0;		for j := 1 to GetPtrSize(taxbits) div 4 do			begin				LongPtr^ := longzero;				LongPtr := LP(longint(LongPtr) + 4);			end;		StartDLOG(136, theDialog, tempP);		EnableDisableDLOGItem(theDialog, 5, numchars <> numcharin, false);		EnableDisableDLOGItem(theDialog, 9,nucleotides, false);		myShowDialog(theDialog);		CheckFilterTaxa;		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			case localItemHit of				5: 	ExamineExcluded := not ExamineExcluded;				6, 8:	MustBeIdentical := not MustBeIdentical;				7: 	outtofile := not outtofile;				9:	respectcase := not respectcase;				10:	selectInList := not selectInList;				11:	mergeNames := not mergeNames;				otherwise					;			end;			CheckFilterTaxa;		until (localItemHit in [1, 2, 3]);		DisposeDialog(theDialog);		if localItemHit in [1, 3] then			begin				if localItemHit = 3 then					if not CWarning('Are you sure you want to merge redundant taxa? MacClade cannot undo this.','Merge', 'Cancel') then						goto 1;				CalcSelectedTaxaCharacters(st, et, sc, ec, true);				SetCursor(clockCursor);				if outtofile then					outputH := NewHandle(0);				if outtofile then					begin						AppendToHandle(outputH, concat(MacCladeStamp, chr(13)));						AppendToHandle(outputH, concat(UserStamp(true, true, false), chr(13)));						AppendToHandle(outputH, concat(TimeStamp, chr(13), chr(13)));						AppendToHandle(outputH, concat(DataFileStamp, chr(13), chr(13)));						AppendToHandle(outputH, concat('Redundant taxa:', chr(13), chr(13)));					end;				if CheckForDuplicateTaxa(st,et,taxBits,localItemHit = 3, respectCase, outtofile,mergeNames,selectInList,outPutH,numdest) then					begin						if localItemHit = 1 then							begin								if mustbeidentical then									InstantInfo(concat('Number of redundant taxa in selection: ', StringFromNum(numdest)))								else									InstantInfo(concat('Number of redundant pairs of taxa in selection: ', StringFromNum(numdest)));										for it := 1 to numTaxa do							end						else							begin								InstantInfo(concat('Number of redundant taxa removed from matrix: ', StringFromNum(numdest)));								ZeroSelection;								genericSetPort(editorWindow);								EraseRect(WindowPortRect(editorWindow));								InvalidateWindowRect(editorWindow,WindowPortRect(editorWindow),false);								InvalidateInfoWindow(charinfo);								InvalidateInfoWindow(charinfo);							end;						if selectInList then							begin								OpenOrSelectInfoWindow(taxinfo);								ScrollInfoWindowToSelectedRow(taxinfo);							end;					end				else					begin						InstantInfo('No redundant taxa in selection.');						if outtofile then							AppendToHandle(outputH, ' None.');					end;				if outtofile then					begin						if (getHandleSize(outputH) > 0) then							SaveHandleAs(outputH,'Save Search Info as', 'Redundant Taxa');						ZapHandle(outputH);					end;			end;1:		genericSetPort(tempP);		ZapPointer(taxbits);	end;{-----------------------------------------------------------------------------}	function CheckAndSetDataFormat: boolean;		var			localItemHit: integer;			theDialog: DialogPtr;			newFormat: integer;			tempP: WindowPtr;{............}		procedure CheckDataFormat;		begin			ItemCheckMark(theDialog, 3, newFormat=DNA);			ItemCheckMark(theDialog, 4,newFormat=RNA);			ItemCheckMark(theDialog, 5,newFormat=protein);		end;{............}	begin		newFormat := DNA;		StartDLOG(171, theDialog, tempP);		CheckDataFormat;		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			case localitemhit of				3: 	newFormat := DNA;				4:	newFormat := RNA;				5:	newFormat := protein;				otherwise;			end;			CheckDataFormat;		until localItemHit in [1, 2];		EndDLOG(theDialog, tempP);		CheckAndSetDataFormat:= localitemhit=1;		if localItemHit = 1 then			SetDataFormat(newFormat, true);	end;{-----------------------------------------------------------------------------}	procedure ImportSequencesOptions;		var			theDialog: DialogPtr;			oldImportCLAD: boolean;			tempP: WindowPtr;			localItemHit: integer;	begin		oldImportCLAD := allowCLADImportFromFinder;		StartDLOG(181, theDialog, tempP);		ItemCheckMark(theDialog, 4, allowCLADImportFromFinder);		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			if localItemHit in [4,5] then				begin					allowCLADImportFromFinder := not allowCLADImportFromFinder;					ItemCheckMark(theDialog, 4, allowCLADImportFromFinder);				end			else if localitemhit = 6 then				SetDialogValuesAsDefaults(theDialog, ImportSequencesOptionsID, 0, 0);		until localItemHit in [1, 2];		if localItemHit = 2 then			allowCLADImportFromFinder := oldImportCLAD;		EndDLOG(theDialog, tempP);	end;{-----------------------------------------------------------------------------}	function QueryImportSequencesDLOG(fileType: integer; var addAsNewSequences, saveCharSet,nameAsFile: boolean; var charSetName: str255): boolean; 		var			theDialog: DialogPtr;			tempP: WindowPtr;			localItemHit: integer;			success : boolean;{..............}				procedure  CheckImportQuery;	begin		ItemCheckMark(theDialog,3,addAsNewSequences);		ItemCheckMark(theDialog,4,not addAsNewSequences);		EnableDisableDLOGItem(theDialog,8,not addAsNewSequences,false);		EnableDisableDLOGItem(theDialog,10,addAsNewSequences,false);		if addAsNewSequences then			begin				HideDialogItem(theDialog,5);				HideDialogItem(theDialog,7);			end		else			begin				ShowDialogItem(theDialog,5);				ShowDialogItem(theDialog,7);			end;	end;{..............}				begin		{3 - add, 4 - concatenate, 8 - create charset, 5- charset name}		addAsNewSequences:= true;		charSetName := 'imported';		nameAsFile := false;		saveCharSet:= false;		StartDLOG(167, theDialog, tempP);		SetDLOGText(theDialog, 5, charSetName, false);		ItemCheckMark(theDialog,8,saveCharSet);		ItemCheckMark(theDialog,10,nameAsFile);		CheckImportQuery;		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			if localitemhit = 3 then				begin					addAsNewSequences := true;					CheckImportQuery;					DrawDialog(theDialog);				end			else if localitemhit = 4 then				begin					addAsNewSequences := false;					CheckImportQuery;					DrawDialog(theDialog);				end			else if localitemhit=8 then				begin					saveCharSet := not saveCharSet;					ItemCheckMark(theDialog,8,saveCharSet);				end			else if localitemhit=10 then				begin					nameAsFile := not nameAsFile;					ItemCheckMark(theDialog,10,nameAsFile);				end;		until localItemHit in [1, 2];		if localItemHit = 1 then			charSetName := GetEditText(theDialog, 5);		EndDLOG(theDialog, tempP);		QueryImportSequencesDLOG := localitemHit =1;	end;{-----------------------------------------------------------------------------}	procedure QueryImportSequences(fileType: integer); 		var			addAsNewSequences, saveCharSet: boolean;			charSetName: str255;			nameAsFile: boolean;			success : boolean;	begin		{3 - add, 4 - concatenate, 8 - create charset, 5- charset name}		if newfile & not dirtyfile & (numtaxa=1) & (numchars=1)  then			begin				if  molecular | CheckAndSetDataFormat then					begin						if CWarning('Use file name for sequence name or use name found within file', 'Within file' , 'File name') then							success := ChooseImportSequence(filetype, true, false,false, '')						else							success := ChooseImportSequence(filetype, true, false,true, '');						if success then							begin								DestroyTaxa(1,1,false,true);								DoDataMatrixStyleMenu(styleMolecularItem);							end;					end;			end		else if QueryImportSequencesDLOG(fileType, addAsNewSequences, saveCharSet,nameAsFile, charSetName) then			success := ChooseImportSequence(filetype, addAsNewSequences, saveCharSet,nameAsFile, charSetName);	end;{-----------------------------------------------------------------------------}	procedure DoImportTaxaMenu (ItemNo: integer);	var wasnew, db: boolean;	begin			case ItemNo of				ImportNBRFItem :					QueryImportSequences(nbrf);				ImportGenbankItem:					QueryImportSequences(genbank);				ImportFASTAItem:					QueryImportSequences(fasta);				ImportSimpleTextItem:					QueryImportSequences(simpletext);				ImportSequenceOnlyItem:					if molecular |  (newfile & not dirtyfile & (numtaxa=1) & (numchars=1) & CheckAndSetDataFormat) then						begin							wasnew := newfile & not dirtyfile& (numtaxa=1) & (numchars=1) ;							if ChooseImportSequence(sequenceOnly,true, false,true,'') then								if wasnew then									begin										DestroyTaxa(1,1,false,true);										DoDataMatrixStyleMenu(styleMolecularItem);									end;						end;				ImportOptionsItem:					ImportSequencesOptions;				otherwise					;			end;	end;{-----------------------------------------------------------------------------}	procedure DoTaxonSetsMenu (ItemNo: integer);	begin		case ItemNo of			TaxonSetListItem:				if (fileopen) then					OpenOrSelectInfoWindow(taxsetinfo);			StoreTaxonSetItem:				MakeNewObject(taxsetinfo,'',true, false,true);			otherwise				;		end;	end;{-----------------------------------------------------------------------------}	procedure TransformConsensusIntoTaxon(consensusNumber: integer);	var 	tsts: LargestSetChars;		trueMajority: boolean;		dataFraction: double;		ic:integer;	begin		InsertNewTaxa(1,1,molecular);		SetLastChangeInEditor(lastChangeCantUndo);		SetTaxonName(1,GetConsensusName(consensusNumber));		for ic := 1 to numchars do			begin				tsts := GetConsensusSet(consensusNumber,ic,true,true,trueMajority,[MSl,GAl],dataFraction);				settaxonstslargest(1,ic,tsts);			end;		DestroyConsensus(consensusNumber);		ReSizeEditorWindow;	end;{-----------------------------------------------------------------------------}	procedure DoTaxaListOptionsMenu (ItemNo: integer);	var consensusSelected: integer;	begin		case ItemNo of			ConsiderExcludedInTaxonListItem:				begin					taxInfoConsiderAllCharacters := not taxInfoConsiderAllCharacters;					myCheckMenuItem(TaxonListOptionsMHdl, ConsiderExcludedInTaxonListItem, taxInfoConsiderAllCharacters);					InvalidateInfoWindow(taxinfo);				end;			ShowNucFrequenciesInTaxonListItem:				begin					taxInfoShowNucFrequencies := not taxInfoShowNucFrequencies;					myCheckMenuItem(TaxonListOptionsMHdl, ShowNucFrequenciesInTaxonListItem, taxInfoShowNucFrequencies);					SizeInfoWindow (taxinfo,false,true);				end;							ShowStopCodonsInTaxonListItem:				begin					taxInfoShowStopCodons := not taxInfoShowStopCodons;					myCheckMenuItem(TaxonListOptionsMHdl, ShowStopCodonsInTaxonListItem, taxInfoShowStopCodons);					SizeInfoWindow (taxinfo,false,true);				end;			ShowPartTripletsInTaxonListItem:				begin					taxInfoShowPartTriplets := not taxInfoShowPartTriplets;					myCheckMenuItem(TaxonListOptionsMHdl, ShowPartTripletsInTaxonListItem, taxInfoShowPartTriplets);					SizeInfoWindow (taxinfo,false,true);				end;			ShowFirstBaseInTaxonListItem:				begin					taxInfoShowFirstBase := not taxInfoShowFirstBase;					myCheckMenuItem(TaxonListOptionsMHdl, ShowFirstBaseInTaxonListItem, taxInfoShowFirstBase);					SizeInfoWindow (taxinfo,false,true);				end;			ShowLastBaseInTaxonListItem:				begin					taxInfoShowLastBase := not taxInfoShowLastBase;					myCheckMenuItem(TaxonListOptionsMHdl, ShowLastBaseInTaxonListItem, taxInfoShowLastBase);					SizeInfoWindow (taxinfo,false,true);				end;			ShowLowerCaseInTaxonListItem:				begin					taxInfoShowLowerCase := not taxInfoShowLowerCase;					myCheckMenuItem(TaxonListOptionsMHdl, ShowLowerCaseInTaxonListItem, taxInfoShowLowerCase);					SizeInfoWindow (taxinfo,false,true);				end;			ShowUncertaintyInTaxonListItem:				begin					taxInfoShowUncertainty := not taxInfoShowUncertainty;					myCheckMenuItem(TaxonListOptionsMHdl, ShowUncertaintyInTaxonListItem, taxInfoShowUncertainty);					SizeInfoWindow (taxinfo,false,true);				end;			ShowPolymorphismInTaxonListItem:				begin					taxInfoShowPolymorphism := not taxInfoShowPolymorphism;					myCheckMenuItem(TaxonListOptionsMHdl, ShowPolymorphismInTaxonListItem, taxInfoShowPolymorphism);					SizeInfoWindow (taxinfo,false,true);				end;							otherwise				;		end;	end;{-----------------------------------------------------------------------------}	procedure DoTaxaMenu (ItemNo: integer);	var consensusSelected: integer;	begin		case ItemNo of			TaxonListItem:				if (fileopen) then					OpenOrSelectInfoWindow(taxinfo);			AddEmptyTaxaItem:				DoAddTaxa;			MoveToTaxonItem:				if editorOpen & SomeConsensusSelected(consensusSelected) then					TransformConsensusIntoTaxon(consensusSelected);			xxxxFilterTaxaItem:				if not treeopen then					FilterTaxa;							xxxxMergeTaxaItem: 				if not treeOpen then					if CWarning('Are you sure you want to merge the selected taxa?', 'Merge', 'Cancel') then						MergeSelected;			ReorderRandomlyItem :				ReOrderTaxaRandomly;			ReorderByTreeItem:				if treeopen then					ReOrderTaxaByTree; 			otherwise				;		end;	end;end.