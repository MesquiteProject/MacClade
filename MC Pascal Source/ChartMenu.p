unit ChartMenu;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, CharUtil, TreeGet, ReadWriteUtil, ReadUtil, ChartToType, ProbReconstruct, TreeUtil, TypeUtil, TaxonCHUtil, ReadTreeFile, RestrictChanges, Prohibitions, Windows, SetStates, Count, Equivocal, PolyCalc, TraceControl, ChartWUtil, ChartWCalc, ChartWTable, ChartWindow;	procedure DoChartMenu (ItemNo: integer);	procedure DoBottomChartMenu (ItemNo: integer);{еееееееееееееееееееееее}implementation {е$S ChartMenu}	var		userHasSetCatWid: boolean;{-----------------------------------------------------------------------------}	function DoBlastPolytomy: boolean;		var			theDialog: DialogPtr;			oldblast: boolean;			tempP: WindowPtr;			localItemHit: integer;{............}		procedure CheckBlast;		begin			ItemCheckMark(theDialog, 3, CWBlastPolyT);			ItemCheckMark(theDialog, 4, not CWBlastPolyT);		end;{............}	begin		oldblast := CWBlastpolyT;		StartDLOG(601, theDialog, tempP);		CheckBlast;		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			if localItemHit = 3 then				CWBlastPolyT := true			else if localItemHit = 4 then				CWBlastPolyT := false			else if localItemHit = 6 then				begin					GetRandomSeed;					FrameButton(theDialog, 1);				end;			CheckBlast;		until localItemHit in [1, 2];		if localItemHit = 2 then			CWBlastPolyT := oldblast;		EndDLOG(theDialog, tempP);		DoBlastPolytomy := localItemHit = 1;	end;{-----------------------------------------------------------------------------}	procedure CheckCatWid;		var			newInflation: longint;	begin		newInflation := InflationOnCategory(CWChart);		if not userHasSetCatWid and (defaultCatWid <> newInflation) then  {}{if user has not set category width, and inflation factor has changed since chart last calculated}			begin				defaultCatWid := newInflation;				userCatWid := defaultCatWid;			end;	end;{----------------------------------------------------------------------------}{----------------------------------------------------------------------------}	function GetATreeFile: boolean;		var			typeList: SFTypeList;			theFile: str255;    		UPP: UniversalProcPtr;	begin		GetATreeFile := false;		typeList[0] := 'TEXT';		startreadtree := 1;		endreadtree := -1;{$IFC NOT CARBON}		UPP := MyNewDlgHookYDUPP(@MyTreeFileHook7);  {$ELSEC}		UPP := nil;{$ENDC}		if ChooseFile(1, @typeList, UPP, theFile, FDI^[extraTreeFile1FDI].fs,false,false,true) then  {'Start TreeFile'}			begin				extratreefilename[1]^^ := theFile;				GetATreeFile := true;			end;{$IFC NOT CARBON}		MyDisposeDlgHookYDUPP(UPP);{$ENDC}		startreadcharttree := startreadtree;		endreadcharttree := endreadtree;	end;{-----------------------------------------------------------------------------}{-----------------------------------------------------------------------------}	function CategoryUnits: Str255;		var			ds: str255;	begin		case CWChart of			CWCcst: 				ds := 'steps';  {DRM CST}			CWCProbSteps: 				ds := 'steps';			CWCStates: 				ds := CharStateTerm(true, false, true);			CWCSteps: 				if sequencechart then					ds := CharStateTerm(false, false, true)				else if positionchart then					ds := 'codon position'				else					ds := StepsChartUnits(CWStepsShow, true);			CWCCTAll: 				ds := 'steps';			CWCC2T, CWCC2TF: 				ds := CharStateTerm(false, false, true);			otherwise				;		end;		CategoryUnits := ds;	end;{-----------------------------------------------------------------------------}	procedure ChangeIntervalWidth (theChart: integer);		var			theDialog: DialogPtr;			oldcatwid: integer;			tempP: WindowPtr;			oldmaxint, catInflate: longint;			oldchart: integer;			units: double;			ds: str255;			db: boolean;			localItemHit: integer;	begin		oldmaxint := userMaxChartIntervals;		oldcatwid := usercatwid;		StartDLOG(576, theDialog, tempP);		oldchart := CWChart;		catInflate := InflationOnCategory(theChart);		if catInflate = 1 then			ds := ''		else			ds := RealToIntegerString(1, catInflate);		Paramtext(concat(ds, ' ', CategoryUnits), '', '', '');		CWChart := oldchart;		SetDLOGText(theDialog, 3, StringFromNum(usercatwid), true);		SetDLOGText(theDialog, 6, StringFromNum(userMaxChartIntervals), true);		SelectDialogItemText(theDialog, 3, 0, 32000);		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);		until (localItemHit in [1, 2]);		if localItemHit = 1 then			begin				userHasSetCatWid := true;				usercatwid := EditTextInt(theDialog, 3,true);				if usercatwid < 1 then					usercatwid := 1;				userMaxChartIntervals := EditTextInt(theDialog, 6,true);				db := ResetUserMaxChartIntervalsAllowed(userMaxChartIntervals);			end;		EndDLOG(theDialog, tempP);{    if localItemHit = 1 then if usercatwid <> oldcatwid then CalcChartData;}	end;{-----------------------------------------------------------------------------}	procedure SetPolytomiesButton (theDialog: DialogPtr; num: integer);	begin		if CWBlastPolyT then			SetButtonTitle(theDialog, num, 'Resolve Polytomies...')		else			SetButtonTitle(theDialog, num, 'Resolve Polytomies...');	end;{-----------------------------------------------------------------------------}	procedure EnableDisablePolytomiesButton (theDialog: DialogPtr; num: integer; theChart: integer);	begin		EnableDisableDLOGItem(theDialog, num, (CWTrees[theChart] <> CWCurrentTree) & (CWTrees[theChart] <> CWRandomTrees), false);	end;{-----------------------------------------------------------------------------}	function TreeLengthChartOptions: boolean;		var			theDialog: DialogPtr;			tempP: WindowPtr;			oldCWTrees, itemtype: integer;			H: Handle;			box: rect;			oldchartCalcToText: boolean;			oldCWBlastPolyT, db: Boolean;			gottreefile: boolean;			localItemHit: integer;{........}		procedure CheckChartTreeLengthDLOG;		begin			ItemCheckMark(theDialog, 3, CWTrees[CWCCTAll] = CWStoredTrees);			ItemCheckMark(theDialog, 4, CWTrees[CWCCTAll] = CWRandomTrees);			ItemCheckMark(theDialog, 7, CWTrees[CWCCTAll] = CWTreeFile);			ItemCheckMark(theDialog, 8, ChartCalcToText);			EnableDisablePolytomiesButton(theDialog, 9, CWCCTAll);		end;{........}	begin		oldChartCalcToText := ChartCalcToText;		oldCWBlastPolyt := CWBlastPolyT;		oldCWTrees := CWTrees[CWCCTAll];		StartDLOG(572, theDialog, tempP);		if (UserLinks[treeChain] <= 1) then			begin				EnableDisableDLOGItem(theDialog, 3, false, false);				CWTrees[CWCCTAll] := CWRandomTrees;			end;		CheckChartTreeLengthDLOG;		SetPolytomiesButton(theDialog, 9);		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			case localItemHit of				3: 					CWTrees[CWCCTAll] := CWStoredTrees;				4: 					CWTrees[CWCCTAll] := CWRandomTrees;				7: 					begin						gottreefile := GetATreeFile;						FrameButton(theDialog, 1);						if not gottreefile then							cycle;						CWTrees[CWCCTAll] := CWTreeFile;					end;				6: 					begin						ChangeIntervalWidth(CWCCTAll);						FrameButton(theDialog, 1);					end;				8: 					ChartCalcToText := not ChartCalcToText;				9: 					begin						db := DoBlastPolytomy;						FrameButton(theDialog, 1);						SetPolytomiesButton(theDialog, 9);					end;				otherwise					;			end;			CheckChartTreeLengthDLOG;		until localItemHit in [1, 2];		EndDLOG(theDialog, tempP);		if localItemHit = 2 then			begin				ChartCalcToText := OldChartCalcToText;				CWBlastPolyt := oldCWBlastPolyT;				CWTrees[CWCCTAll] := oldCWTrees;			end;		TreeLengthChartOptions := localitemhit = 1;	end;{$IFC PROBSTEPCHART}{====================================================================}	function ProbStepsChart2: boolean;		var			theDialog: DialogPtr;			tempP: WindowPtr;			tempH: Handle;			ds, rs: str255;			ic: integer;			localItemHit: integer;			oldprobitem: integer;			oldseglisten: boolean;			oldprobchange: array[0..3, 0..3] of double;			maxitems: integer;			oldChartCalcToText: boolean;{.......}		procedure WriteProbability (iffrom, itto, iitem: integer);		begin			RealToString(probchangeRec[iffrom, itto], ds, 10, 4, false);			SetDLOGText(theDialog, iitem, ds, false);		end;{.......}		function GetProbability (iitem: integer): double;     {getting the probability values from the edit text items}			var				intvalue: longint;				realvalue: double;				isreal: boolean;		begin			EditTextNum(theDialog, iitem, realvalue, intvalue, isreal);			if not isreal then				if intvalue = 1 then					realvalue := 1.0				else					begin						if intvalue <> 0 then							begin								InstantError(189);								SelectDialogItemText(theDialog, iitem, 0, 32767);							end;						realvalue := 0.0					end			else if (realvalue < 0.0) or (realvalue > 1.0) then 			 {it's a real value}				begin					realvalue := 0.0;					InstantError(189);					SelectDialogItemText(theDialog, iitem, 0, 32767);				end;			GetProbability := realvalue;		end;{.......}	begin		StartDLOG(149, theDialog, tempP);		maxitems := 12;		oldChartCalcToText := ChartCalcToText;		oldprobitem := probrecitem;		oldseglisten := seglistenProb;		oldprobchange[0, 0] := probchangeRec[0, 0];		oldprobchange[0, 1] := probchangeRec[0, 1];		oldprobchange[1, 0] := probchangeRec[1, 0];		oldprobchange[1, 1] := probchangeRec[1, 1];		WriteProbability(0, 0, 8);		WriteProbability(0, 1, 9);		WriteProbability(1, 0, 10);		WriteProbability(1, 1, 11);		ItemCheckMark(theDialog, 12, seglistenProb);		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			case localItemHit of				1: 					begin						if (abs(probchangeRec[0, 0] + probchangeRec[0, 1] - 1.0) > 0.001) or (abs(probchangeRec[1, 0] + probchangeRec[1, 1] - 1.0) > 0.001) then							begin								InstantInfo('Probabilities don'' t add up to 1 ');								probchangeRec[0, 0] := oldprobchange[0, 0];								probchangeRec[0, 1] := oldprobchange[0, 1];								probchangeRec[1, 0] := oldprobchange[1, 0];								probchangeRec[1, 1] := oldprobchange[1, 1];								if (traceshown = traceProbability) then									TurnOffProbReconstruct;								SetCursorToArrow;							end;					end;				2: 					begin						probrecitem := oldprobitem;						probchangeRec[0, 0] := oldprobchange[0, 0];						probchangeRec[0, 1] := oldprobchange[0, 1];						probchangeRec[1, 0] := oldprobchange[1, 0];						probchangeRec[1, 1] := oldprobchange[1, 1];						seglistenProb := oldseglisten;					end;				8: 					probchangeRec[0, 0] := GetProbability(8); {0 to 0}				9: 					probchangeRec[0, 1] := GetProbability(9); {0 to 1}				10: 					probchangeRec[1, 0] := GetProbability(10); {1 to 0}				11: 					probchangeRec[1, 1] := GetProbability(11); {1 to 1}				12: 					begin						seglistenProb := not seglistenProb;						ItemCheckMark(theDialog, 12, seglistenProb);					end;				4: 					begin						ChartCalcToText := not ChartCalcToText;						ItemCheckMark(theDialog, 4, ChartCalcToText);					end;				otherwise					;			end;		until (localItemHit in [1, 2]);		EndDLOG(theDialog, tempP);		if localitemHit = 1 then			CWChart := CWCProbSteps		else			begin				ChartCalcToText := oldChartCalcToText; 				probrecitem := oldprobitem;				seglistenProb := oldseglisten;				probchangeRec[0, 0] := oldprobchange[0, 0];				probchangeRec[0, 1] := oldprobchange[0, 1];				probchangeRec[1, 0] := oldprobchange[1, 0];				probchangeRec[1, 1] := oldprobchange[1, 1];			end;		if seglistenProb <> oldseglisten or (probchangeRec[0, 0] <> oldprobchange[0, 0]) or (probchangeRec[0, 1] <> oldprobchange[0, 1]) or (probchangeRec[1, 0] <> oldprobchange[1, 0]) or (probchangeRec[1, 1] <> oldprobchange[1, 1]) then			begin{golist := golist + [goProbability];}				godraw := true;			end;		ProbStepsChart2 := localitemhit = 1;	end;{$ENDC}{-----------------------------------------------------------------------------}{-----------------------------------------------------------------------------}	procedure StepsChartUser (theDialog: DialogPtr; itemNo: Integer);	begin		FrameButton(theDialog, 1);		if not nucleotides then			begin				DimBox(GetDLOGItemBox(theDialog, 8));				DimBox(GetDLOGItemBox(theDialog, 14));			end;	end;{-----------------------------------------------------------------------------}	function StepsChartOptions (var modifiedrestrict: boolean): boolean;		var			theDialog: DialogPtr;			tempP: WindowPtr;			theitem, oldCWTrees: integer;			oldChartCalcToText, oldsequencechart, oldpositionchart, mincurrent, maxcurrent: boolean;			oldCWStepsShow: integer;			oldCWChart: integer;			oldCWBlastPolyT, db: boolean;			oldCWTraced: boolean;			localItemHit: integer;			H: Handle;			box: rect;UserItemUProcP: UniversalProcPtr;{.............}		procedure CheckStepsChart (givewarn: boolean);			var				candoMin, candoMax: boolean;		begin			multicharschart := (sequencechart or positionchart) or (CWTrees[CWCSteps] = CWCurrentTree);			if ((CWTrees[CWCSteps] = CWcurrentTree) & not EquivocalLegal(R)) then				begin					if CWStepsShow = CWStepsChanges then						begin							CWStepsShow := CWStepsSteps;							if givewarn then								InstantError(226);						end;				end;			if (not multicharschart & (Typeofchar(i) = fisher)) then				begin					if CWStepsShow = CWStepsChanges then						begin							CWStepsShow := CWStepsSteps;							if givewarn then								InstantError(367);						end;				end;			EnableDisableDLOGItem(theDialog, 24, true, false);			multicharschart := (sequencechart or positionchart) or (CWTrees[CWCSteps] = CWCurrentTree);			candoMin := (mincurrent & multicharschart) | (not multicharschart & MinMaxLenLegalChar(i, minlength));			candoMax := (maxcurrent & multicharschart) | (not multicharschart & MinMaxLenLegalChar(i, maxlength));			EnableDisableDLOGItem(theDialog, 25, candoMin, false);			EnableDisableDLOGItem(theDialog, 26, candoMin and candoMax, false);			EnableDisableDLOGItem(theDialog, 27, candoMin and candoMax, false);{dim item 18 if  (positionchart or CIRICategory)}			if not candoMin then				if CWStepsShow in [CWStepsCI, CWStepsRC, CWStepsRI] then					CWStepsShow := CWStepsSteps;			if not candoMax then				if CWStepsShow in [CWStepsRC, CWStepsRI] then					CWStepsShow := CWStepsSteps;			ItemCheckMark(theDialog, 3, (CWTrees[CWCSteps] = CWCurrentTree) and not (sequencechart or positionchart));			ItemCheckMark(theDialog, 4, (CWTrees[CWCSteps] = CWCurrentTree) and sequencechart);			ItemCheckMark(theDialog, 5, (CWTrees[CWCSteps] = CWCurrentTree) and positionchart);			ItemCheckMark(theDialog, 9, (CWTrees[CWCSteps] <> CWCurrentTree) and not (sequencechart or positionchart));			ItemCheckMark(theDialog, 10, (CWTrees[CWCSteps] <> CWCurrentTree) and sequencechart);			ItemCheckMark(theDialog, 11, (CWTrees[CWCSteps] <> CWCurrentTree) and positionchart);			ItemCheckMark(theDialog, 15, CWTrees[CWCSteps] = CWCurrentTree);			ItemCheckMark(theDialog, 16, CWTrees[CWCSteps] = CWStoredTrees);			ItemCheckMark(theDialog, 17, CWTrees[CWCSteps] = CWRandomTrees);			ItemCheckMark(theDialog, 21, CWTrees[CWCSteps] = CWTreeFile);			ItemCheckMark(theDialog, 22, ChartCalcToText);			ItemCheckMark(theDialog, 23, (CWStepsShow = CWStepsSteps));			ItemCheckMark(theDialog, 24, (CWStepsShow = CWStepsChanges));			ItemCheckMark(theDialog, 25, (CWStepsShow = CWStepsCI));			ItemCheckMark(theDialog, 26, (CWStepsShow = CWStepsRI));			ItemCheckMark(theDialog, 27, (CWStepsShow = CWStepsRC));			EnableDisableDLOGItem(theDialog, 28, (CWStepsShow = CWStepsChanges), false);			EnableDisablePolytomiesButton(theDialog, 30, CWCSteps);		end;{.............}		procedure SetStepsItem (theItem: integer);		begin			if (CWTrees[CWCSteps] <> CWCurrentTree) and (theItem in [3, 4, 5]) then				CWTrees[CWCSteps] := CWCurrentTree;			if (CWTrees[CWCSteps] = CWCurrentTree) and (theItem in [9, 10, 11]) then				if UserLinks[treechain] = 0 then					CWTrees[CWCSteps] := CWRandomTrees				else					CWTrees[CWCSteps] := CWStoredTrees;		end;{.............}		procedure SetTextFileButton;		begin			if (CWTrees[CWCSteps] <> CWCurrentTree) then				EnableDisableDLOGItem(theDialog, 22, true, false)			else				begin					ChartCalcToText := false;					EnableDisableDLOGItem(theDialog, 22, false, true)				end;		end;{.............}		procedure SetAllFalse;		begin			positionchart := false;			sequencechart := false;			CWTraced := false;		end;{.............}		procedure ReSetCatWid;		begin			userHasSetCatWid := false;			defaultCatWid := InflationOnCategory(CWChart);			userCatWid := defaultCatWid;		end;{.............}		procedure SetNewStepsChart (SetToButton: integer; resetWidth: boolean);		begin			SetStepsItem(setToButton);			if resetWidth then				ReSetCatWid;			SetAllFalse;			case setToButton of				4, 10: 					sequencechart := true;				5, 11: 					positionchart := true;				9: 					CWTraced := true;				otherwise					;			end;			CheckCatWid;		end;{.............}	begin		writeRootStates := false;		oldCWBlastPolyt := CWBlastPolyT;		oldCWChart := CWChart;		CWChart := CWCSteps;		oldCWTrees := CWTrees[CWCSteps];		oldCWTraced := CWTraced;		oldsequencechart := sequencechart;		oldpositionchart := positionchart;		oldChartCalcToText := ChartCalcToText;		oldCWStepsShow := CWStepsShow;		StartDLOG(558, theDialog, tempP);		SetRect(box, 0, 0, 10, 10);UserItemUProcP := MyNewUserItemUPP(@StepsChartUser);  H := Handle(UserItemUProcP);		SetDialogItem(theDialog, 31, UserItem, H, box);		if not nucleotides then			positionchart := false;		EnableDisableDLOGItem(theDialog, 5, nucleotides, false);		EnableDisableDLOGItem(theDialog, 11, nucleotides, false);		EnableDisableDLOGItem(theDialog, 9, (traceshown = traceDiscrete), false);		if changesRestricted then			SetButtonTitle(theDialog, 28, 'Restrict...')		else			SetButtonTitle(theDialog, 28, 'Restrict...');		SetPolytomiesButton(theDialog, 30);		if UserLinks[treechain] = 0 then			begin				EnableDisableDLOGItem(theDialog, 16, false, true);				if CWTrees[CWCSteps] = CWStoredTrees then					CWTrees[CWCSteps] := CWRandomtrees;			end;		mincurrent := MinMaxLenLegal(false, minlength);		maxcurrent := MinMaxLenLegal(false, maxlength);		SetTextFileButton;		if (CWTrees[CWCSteps] = CWCurrentTree) or (not (traceshown = traceDiscrete) and not sequencechart and not positionchart) then			begin				theitem := 3;				CWTrees[CWCSteps] := CWCurrentTree;			end		else			theitem := 9;		if sequencechart then			theitem := theitem + 1;		if positionchart then			theitem := theitem + 2;		CWTraced := theItem = 9;		SetStepsItem(theitem);		CheckStepsChart(false);		myShowDialog(theDialog);		repeat			ModalDialog(nil, localItemHit);			case localItemHit of				3, 6:     {upper left icon}					SetNewStepsChart(3, sequencechart or positionchart or CWTraced);				4, 7:      {upper middle icon}					SetNewStepsChart(4, not sequencechart);				5, 8:      {upper right icon}					if nucleotides then						SetNewStepsChart(5, not positionchart);				9, 12:      {lower left icon}					if (traceshown = traceDiscrete) then						SetNewStepsChart(9, sequencechart or positionchart or not CWTraced);				10, 13:      {lower middle icon}					SetNewStepsChart(10, not sequencechart);				11, 14:      {lower right icon}					if nucleotides then						SetNewStepsChart(11, not positionchart);				15:    {current tree button}					begin						if CWTrees[CWCSteps] <> CWCurrentTree then							begin								if positionchart then									SetNewStepsChart(5, false)								else if sequencechart then									SetNewStepsChart(4, false)								else									SetNewStepsChart(3, false);							end;					end;				16, 17, 21:     {16 stored trees, 17 random trees, 21 tree file buttons}					begin						if localItemHit = 21 then							if not GetATreeFile then								cycle;						if CWTrees[CWCSteps] = CWCurrentTree then							begin								if positionchart then									SetNewStepsChart(11, false)								else if sequencechart or not (traceshown = traceDiscrete) then   {turn on multiple trees sequencechart}									begin										SetNewStepsChart(10, not sequencechart);									end								else									SetNewStepsChart(9, not sequencechart);							end;						if localItemHit = 17 then							CWTrees[CWCSteps] := CWRandomTrees						else if localItemHit = 16 then							CWTrees[CWCSteps] := CWStoredTrees						else if localItemHit = 21 then							CWTrees[CWCSteps] := CWTreeFile;					end;				18:{v4: allow changing of interval width if ri,ci,rc chart?}					if positionchart or CIRICategory then						Beep					else						ChangeIntervalWidth(CWCSteps);				22: 					ChartCalcToText := not ChartCalcToText;				23: 					CWStepsShow := CWStepsSTeps;				24: 					CWStepsShow := CWStepsChanges;				25: 					CWStepsShow := CWStepsCI;				26: 					CWStepsShow := CWStepsRI;				27: 					CWStepsShow := CWStepsRC;				28: 					begin						ParamText('Restrict changes plotted to those selected:', '', '', '');						RestrictChangesDLOG(false, modifiedrestrict);						if changesRestricted then							SetButtonTitle(theDialog, 28, 'Restrict...')						else							SetButtonTitle(theDialog, 28, 'Restrict...');					end;				30: 					begin						db := DoBlastPolytomy;						FrameButton(theDialog, 1);						SetPolytomiesButton(theDialog, 30);					end;				otherwise					;			end;			SetTextFileButton;			CheckStepsChart(true);		until localItemHit in [1, 2];		if OptionDown & (localItemHit = 1) & (traceshown = traceDiscrete) & (TypeOfChar(i) < dollo) then			WriteRootStates := true;MyDisposeUserItemUPP(UserItemUProcP);		EndDLOG(theDialog, tempP);		if localItemHit = 1 then			begin				if NumSpotBar(SpotBarSetToShow) > 1 then					CWPercent := false;			end		else			begin				CWBlastPolyt := oldCWBlastPolyT;				sequencechart := oldsequencechart;				CWTraced := oldCWTraced;				positionchart := oldpositionchart;				ChartCalcToText := oldChartCalcToText;				CWStepsShow := oldCWStepsShow;				CWTrees[CWCSteps] := oldCWTrees;			end;		CWChart := oldCWChart;		multicharschart := (sequencechart or positionchart) or (CWTrees[CWCSteps] = CWCurrentTree);		StepsChartOptions := localitemhit = 1;	end;{-----------------------------------------------------------------------------}	procedure CWChangesInfo (theDialog: DialogPtr; itemNo: Integer);	begin		DrawResourceTEXT(theDialog, 9, 135);		FrameButton(theDialog, 1);	end;{-----------------------------------------------------------------------------}	function CWChangesDLOG: boolean;		var			theDialog: DialogPtr;			tempP: WindowPtr;			oldChartchangesmode, oldCWTrees, itype: integer;			oldCWshowconstant, oldCWTraced, oldChartCalcToText, oldaddPolychanges: boolean;			th: handle;			box: rect;			oldCWBlastPolyT, db, modifiedrestrict: boolean;			ds: str255;			localItemHit: integer;UserItemUProcP: UniversalProcPtr;{.............}		procedure CheckChartChangesDLOG;			var				acctrandeltranactive: boolean;		begin			if (nullson or ancon) and (Chartchangesmode <> unambigmode) and (CWTrees[CWCChanges] = CWCurrentTree) then				begin					InstantError(227); {Chart cannot use current tree because equivocal cycling is needed}					if UserLinks[treeChain] >= 1 then						CWTrees[CWCChanges] := CWStoredTrees					else						CWTrees[CWCChanges] := CWRandomTrees;				end;			acctrandeltranactive := ((resolveoption <> allpossible) & CWTRACED & (CWTrees[CWCChanges] = CWCurrentTree));			if (acctrandeltranactive) & (Chartchangesmode <> unambigmode) then				begin					Chartchangesmode := unambigmode;					Instanterror(317);				end;{v3.02:  }			EnableDisableDLOGItem(theDialog, 20, not ((CWTrees[CWCChanges] = CWCurrentTree) & ((chartchangesmode = unambigmode)|CWTraced)), false);			if CWTRACED & (CWTrees[CWCChanges] = CWCurrentTree) & fixon then				begin					if acctrandeltranactive then						begin							if resolveoption = acctran then								ds := '  (fixed + ACCTRAN)'							else if resolveoption = deltran then								ds := '  (fixed + DELTRAN)'						end					else						ds := '  (states fixed)';				end			else if acctrandeltranactive then				begin					if resolveoption = acctran then						ds := '  (ACCTRAN in effect)'					else if resolveoption = deltran then						ds := '  (DELTRAN in effect)'				end			else				ds := '';			SetDLOGText(thedialog, 27, ds, false);{EnableDisableDLOGItem(theDialog, 4, not (acctrandeltranactive), false);}{EnableDisableDLOGItem(theDialog, 23, not (acctrandeltranactive), false);}			if (CWTrees[CWCChanges] = CWCurrentTree) & (chartchangesmode = unambigmode) then				ChartCalcToText := false;			if CWTraced & (CWTrees[CWChart] = CWCurrentTree) then				SetDLOGText(thedialog, 26, 'Include changes in terminals (polymorphisms/fixed)', false)			else				SetDLOGText(thedialog, 26, 'Include changes within polymorphic terminals', false);			ItemCheckMark(theDialog, 3, Chartchangesmode = unambigmode);			ItemCheckMark(theDialog, 4, Chartchangesmode = minmaxmode);			ItemCheckMark(theDialog, 23, Chartchangesmode = meanmode);			ItemCheckMark(theDialog, 24, addpolychanges);			ItemCheckMark(theDialog, 7, not CWshowconstant);			ItemCheckMark(theDialog, 8, CWshowconstant);			ItemCheckMark(theDialog, 10, not CWTraced);			ItemCheckMark(theDialog, 11, CWTraced);			ItemCheckMark(theDialog, 12, CWTrees[CWCChanges] = CWCurrentTree);			ItemCheckMark(theDialog, 13, CWTrees[CWCChanges] = CWStoredTrees);			ItemCheckMark(theDialog, 14, CWTrees[CWCChanges] = CWRandomTrees);			ItemCheckMark(theDialog, 18, CWTrees[CWCChanges] = CWTreeFile);			ItemCheckMark(theDialog, 20, ChartCalcToText);			EnableDisablePolytomiesButton(theDialog, 25, CWCChanges);		end;{.............}	begin		oldCWBlastPolyt := CWBlastPolyT;		oldChartchangesmode := Chartchangesmode;		oldCWshowconstant := CWshowconstant;		oldCWTrees := CWTrees[CWCChanges];		oldCWTraced := CWTraced;		oldChartCalcToText := ChartCalcToText;		oldaddPolychanges := addPolychanges;		StartDLOG(425, theDialog, tempP);		box := GetDLOGItemBox(theDialog, 9);UserItemUProcP := MyNewUserItemUPP(@CWChangesInfo);  tH := Handle(UserItemUProcP);		SetDialogItem(theDialog, 9, UserItem, tH, box);		if ((resolveoption <> allpossible) & CWTRACED & (CWTrees[CWCChanges] = CWCurrentTree)) | CWPercent then			Chartchangesmode := unambigmode;		if not (traceshown = traceDiscrete) or (typeofchar(i) = fisher) then			begin				EnableDisableDLOGItem(theDialog, 11, false, false);				CWTraced := false;			end;		if UserLinks[treechain] = 0 then			begin				EnableDisableDLOGItem(theDialog, 13, false, true);				if CWTrees[CWCChanges] = CWStoredTrees then					CWTrees[CWCChanges] := CWRandomtrees;			end;		CheckChartChangesDLOG;		SetPolytomiesButton(theDialog, 25);		myShowDialog(theDialog);		repeat			ModalDialog(nil, localItemHit);			case localItemHit of				3, 4, 23: 					if localItemHit = 3 then						Chartchangesmode := unambigmode					else if (nullson or ancon) and (CWTrees[CWCChanges] = CWCurrentTree) then						InstantError(320)					else if localItemHit = 4 then						Chartchangesmode := minmaxmode					else						Chartchangesmode := meanmode;				7, 8: 					CWShowConstant := (localItemHit = 8);				10, 11: 					CWTraced := (localItemHit = 11);				12: 					if (nullson or ancon) and (Chartchangesmode <> unambigmode) then						InstantError(227)					else						CWTrees[CWCChanges] := CWCurrentTree;				13: 					CWTrees[CWCChanges] := CWStoredTrees;				14: 					CWTrees[CWCChanges] := CWRandomTrees;				18: 					begin						if not GetATreeFile then							cycle;						CWTrees[CWCChanges] := CWTreeFile;					end;				20: 					ChartCalcToText := not ChartCalcToText;				21: 					begin						ParamText('Calculate total changes in selected class:', '', '', '');						RestrictChangesDLOG(CWShowConstant, modifiedrestrict);					end;				24, 26: 					addpolychanges := not addpolychanges;				25: 					begin						db := DoBlastPolytomy;						FrameButton(theDialog, 1);						SetPolytomiesButton(theDialog, 25);					end;				otherwise					;			end;			CheckChartChangesDLOG;		until localItemHit in [1, 2];MyDisposeUserItemUPP(UserItemUProcP);		EndDLOG(theDialog, tempP);		if localItemHit = 2 then			begin				ChartCalcToText := oldChartCalcToText;				Chartchangesmode := oldChartchangesmode;				CWshowconstant := oldCWshowconstant;				addpolychanges := oldaddpolychanges;				CWTrees[CWCChanges] := oldCWTrees;				CWTraced := oldCWTraced;				CWBlastPolyt := oldCWBlastPolyT;			end		else			begin				if NumSpotBar(SpotBarSetToShow) > 1 then					CWPercent := false;				if (Chartchangesmode = unambigmode) and (CWTrees[CWCChanges] = CWCurrentTree) then  {v3.02}					ChartCalcToText := false;			end;		CWChangesDLOG := localitemhit = 1;	end;{-----------------------------------------------------------------------------}	function StatesChartOptions: boolean;		var			theDialog: DialogPtr;			tempP: WindowPtr;			oldCWTraced: boolean;			localItemHit: integer;{........}		procedure CheckChartStatesDLOG;		begin			ItemCheckMark(theDialog, 3, not CWTraced);			ItemCheckMark(theDialog, 4, CWTraced);		end;{........}	begin		oldCWTraced := CWTraced;		StartDLOG(571, theDialog, tempP);		CheckChartStatesDLOG;		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			if localItemHit in [3, 4] then				CWTraced := localItemHit = 4;			CheckChartStatesDLOG;		until localItemHit in [1, 2];		EndDLOG(theDialog, tempP);		if localItemHit = 2 then			CWTraced := oldCWTraced;		StatesChartOptions := localitemhit = 1;	end;{----------------------------------------------------------------------------}	function Get2TreeFiles: boolean;		var			typeList: SFTypeList;			theFile: str255;	begin		Get2TreeFiles := false;		if not DoBlastPolytomy then			Exit(Get2TreeFiles);		typeList[0] := 'TEXT';		NewsFlash(1);		if ChooseFile(1, @typeList, nil, theFile,  FDI^[extraTreeFile1FDI].fs,false,false,false) then  {'Select First Treefile'}			begin				extratreefilename[1]^^ := theFile;				NewsFlash(2);				if ChooseFile(1, @typeList, nil, theFile, FDI^[extraTreeFile2FDI].fs,false,false,false) then  {'Select Second Treefile'}					begin						extratreefilename[2]^^ := theFile;						Get2TreeFiles := true;					end;			end;	end;{-----------------------------------------------------------------------------}	procedure CalcMaxReconstState;	begin		if AnyType([usedef]) then			begin{Wayne- this is where you calculate the maximum reconstructed state over ALL characters, AND}	{just over the traced character}{Don't worry, I've taken care of the case in which reconstructed states over current tree do not match the}	{reconstructed states over several trees}	{note that the variable actually used in maxChangesState, and it is set in the procedure SetMaxChangesState}	{in chartWUtil}{David- I am not sure from above note whether or not you wanted me to fix up these so that}{they actually find the maximum reconstructed state.  I have done this, and commented}{out calls below to this procedure, CalcMaxReconstState, but if you find the}{new system too risky then I have left your procedure intact.}{New System: }{- whenever Traced Character is on screen, maxReconstructedStatei will}{contain maximum state in i's traced reconstruction, including fixed states. If tree cycling is done}{in a chart for i, then it will get updated for each new tree not by ReconstructTraced, but}{by ReconstructChars(i,i,false).  After the treecycling is done, the call to retrace i on screen}{will restore maxReconstructedStatei to its value for tracing on screen.}{- whenever All characters are reconstructed, such as for trace all changes or }{changes & stasis chart, then maxREconstructedState will contain maximun state accross}{all characters.  Thus maxReconstructedState will get updated for every tree in tree cycling}{After the treecycling is done, if reconstruct all is active for tree on screen, the call to redo}{it when the current tree is restored will restore maxReconstructedStatei to its value for}{tree on screen.}{Will this satisfy the case with multiple tree chart?  }{IF you want  to disable my system then comment out lines marked *** in Count.p}				maxReconstructedState := maxstate;				if (traceshown = traceDiscrete) then					maxReconstructedStatei := maxstate;			end		else			begin				maxReconstructedState := MOS;				if (traceshown = traceDiscrete) then					maxReconstructedStatei := MOS;			end;	end;{-----------------------------------------------------------------------------}	procedure DoChartMenu (ItemNo: integer);		label			2;		var			oldCalcRestChanges, modifiedrestrict: boolean;			oldCWStepsShow, oldCWChart, oldcatwid: integer;			oldcharton, oldminlen, oldmaxlen: boolean;			oldInflation, newInflation: longint;	begin		if allexcluded then			begin				InstantError(304);			end		else			begin				userHasSetCatWid := false;				ChartCalcToText := false;				oldminlen := (charton and (CWChart = CWCSTeps) and (CWStepsShow in [CWStepsCI, CWStepsRC, CWStepsRI]));				oldmaxlen := (charton and (CWChart = CWCSTeps) and (CWStepsShow in [CWStepsRC, CWStepsRI]));				oldCWChart := CWChart;				oldCWStepsShow := CWStepsShow;				oldcatwid := usercatwid;				oldcharton := charton;				newInflation := InflationOnCategory(ItemNo);				if (oldCWChart <> ItemNo) or (CategoryInflation <> newInflation) or (defaultcatwid = -1) then					begin						defaultCatWid := newInflation;						userCatWid := defaultCatWid;					end;				case ItemNo of					sTreeLengthItem: {$IFC DRMCST}						if OptionEvent(Event) and (traceshown = traceDiscrete) & (CharMaxstOBS(i) > 1) then  {DRM CST}							begin								CWChart := CWCcst;								ChartCalcToText := true;							end						else{$ENDC}							begin								CWChart := CWCCTAll;								if not TreeLengthChartOptions then									goto 2;							end;					sStepsItem: 						begin							CWChart := CWCSteps;							if not StepsChartOptions(modifiedrestrict) then								goto 2;						end;					sChangesItem: 						begin							CWChart := CWCChanges;{CalcMaxReconstState;  }							if not CWChangesDLOG then								goto 2;							if (biggestspot = BiggestMaxMax) and not minmaxon then								biggestspot := BiggestAuto;						end;					sStatesItem: {$IFC PROBRECONSTRUCT}						if OptionDown then							begin								if not ControlDown then									begin										if not ProbStepsChart2 then											goto 2;									end								else									begin										DoProbReconstruct(false);										Exit(DoChartMenu);									end;							end						else{$ENDC}							begin								CWChart := CWCStates;								if (traceshown = traceDiscrete) then									begin										if not StatesChartOptions then											goto 2;									end								else									CWTraced := false;							end;					sTwoTreesItem: {$IFC COMPAREALL}						if OptionEvent(Event) then							begin								CWChart := CWCC2T;								ChartCalcToText := true;								CWPercent := false;{    cumview := nocum}							end						else {$ENDC}							begin								CWChart := CWCC2T;								if not TwoInfoRowsSelected(treeinfo,twotrees[0],twotrees[1]) then									begin										NewError(424,0);										goto 2;									end								else									begin										twotrees[0] := LinkNumberFromInfoRow(treechain,twotrees[0]);										twotrees[1] := LinkNumberFromInfoRow(treechain,twotrees[1]);									end;								{ParamText('Select first tree:', '', '', '');								if not GetTree(GT2trees) then									goto 2;}								CWPercent := false;{    cumview := nocum}							end;					sTwoTreeFileItem: 						begin							CWChart := CWCC2TF;							if not Get2Treefiles then								goto 2;							CWPercent := false;{    cumview := nocum;}						end;					otherwise						;				end;				charton := true;				ReSetGoMask;{$IFC FALSE}				if not count and (countall in gomask) then					golist := golist + [countall];{$ELSEC}				if not count and (countall in gomask) then					if not CountTree then {***}						NewError(110, 0);{$ENDC}				if (charton and (CWChart = CWCSTeps) and (CWStepsShow in [CWStepsCI, CWStepsRC, CWStepsRI])) then					begin{$IFC FALSE}						if not (CalcCI or CalcRC or CalcRI or showminsteps) then							golist := golist + [calcminlenall];						if not (CalcRC or CalcRI or showmaxsteps) then							golist := golist + [calcmaxlenall];						if not (CalcCI or CalcRC or CalcRI) and (ciall in gomask) and not (riall in gomask) then							golist := golist + [ciall];						if not (CalcRC or CalcRI) and (riall in gomask) then							begin								golist := golist + [riall];								if (CWChart = CWCSteps) and (CWStepsShow = CWStepsRC) then									golist := golist + [ciall];							end;{$ELSEC}						if not (CalcCI or CalcRC or CalcRI or showminsteps) then							CalcMinMaxTreeLen(minlength);						if (CWStepsShow in [CWStepsRC, CWStepsRI]) & not (CalcRC | CalcRI | showmaxsteps) then							CalcMinMaxTreeLen(maxlength);						if (not (CalcCI or CalcRC or CalcRI) and (ciall in gomask) and not (riall in gomask)) then							CalculateCIAll;						if (CWStepsShow in [CWStepsRC, CWStepsRI]) & (not (CalcRC | CalcRI) & (riall in gomask)) then							begin								CalculateRIAll;								if (CWChart = CWCSteps) and (CWStepsShow = CWStepsRC) then									CalculateCIAll;							end;{$ENDC}						if sequencechart then							CheckCatWid						else							begin								defaultCatWid := 1;								userCatWid := 1;							end;					end				else					CheckCatWid;{$IFC FALSE}				if not ((traceshown = traceAllStates) or (traceshown = traceAllChanges) or calctreechanges) and (reconstructall in gomask) then					golist := golist + [reconstructall];  { downpass done earlier or above in counttree ***}				if not calctreechanges and (changesall in gomask) then					golist := golist + [changesall];{$ELSEC}				if not ((traceshown = traceAllStates) or (traceshown = traceAllChanges) or calctreechanges) and (reconstructall in gomask) then					ReconstructChars(1, numchars, true);  { downpass done earlier or above in counttree ***}{Here calcRestChanges is set.  If it is true, then whenever NChangesInChar is called, for example by}{CountTotalTreeChanges, it also calculates restricted changes based upon changesSel, and stores}{the results in charHdl^^.minRestChg.  Note that "& changesRestricted" is not included here; that is}{checked for where appropriate, in NChangesInChar and CountTotalTreeChanges, to avoid }{unnecessary calculations.}				oldCalcRestChanges := calcRestChanges;				calcRestChanges := (CWChart = CWCSteps) & (CWStepsShow = CWStepsChanges);{David- we had a bug in that a change in restrictions did not cause tree changes calculations to be immediately redone here,}{only sent a golist call to redo them in MEL, but since CalcChartData sets ChartJustCalc to true, the MEL failed to}{execute the chart calculations, and the chart would retain the information from the previously used change restriction.}{This is a symptom of possible problems because of the unconventional use of on-demand calculations here.}{The system as it stands is patched together with duct tape.  I had started to follow our convention by switching}{to a golist system, but got cold feet about the change.  I think for 3.0 we should}{just stick with the patch I have done (modifiedRestrict) but as soon as possible thereafter we must ditch all these}{on-demand calculations and use the golist system.}				if calcRestChanges & ((modifiedrestrict | (not calcTreeChanges | not oldCalcRestChanges)) & (changesall in gomask)) then					begin						CountTotalTreeChanges;						if pleaseOffChart then							goto 2;						golist := golist - [changesall];					end;{$ENDC}				if not (traceshown = traceDiscrete) & CWTraced & (CWChart in [CWCSteps, CWCChanges, CWCStates]) then					NewError(74, 0);  {note: only call this when it is a chart that can be restricted to traced only!}				CLkind := MaxSpotBarKind;				updateHasPriority := true;  {this needs to be included, otherwise user could click mouse on window}										{before it is drawn, and MC will try to figure out location of click, but locations}										{in chart window are not calculated until the chart is drawn}				OpenChartWindow;				Exit(DoChartMenu);2:				usercatwid := oldcatwid;				CWChart := oldCWChart;			end;	end;{-----------------------------------------------------------------------------}	procedure ChartLogOptions;		label			1;		var			theDialog: DialogPtr;			oldChartLogSigDigits: integer;			localitemHit: integer;			tempP: WindowPtr;			tempsig: integer;{............}		procedure GrabChartLogText;		begin			tempsig := EditTextInt(thedialog, 3,true);			if (tempsig < 1) or (tempsig > 4) then				begin					InstantError(249);					localItemHit := NotInDialog;					goto 1;				end			else				ChartLogSigDigits := tempsig;		end;{............}	begin		StartDLOG(156, theDialog, tempP);		SetDLOGText(theDialog, 3, StringFromNum(ChartLogSigDigits), true);		SelectDialogItemText(theDialog, 3, 0, 32767);		myShowDialog(theDialog);		oldChartLogSigDigits := ChartLogSigDigits;{oooooooooooooooooooooooooooooooooooooo}1:		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			case localItemHit of				4: 					begin						GrabChartLogText;						SetDialogValuesAsDefaults(theDialog, chartLogID, 0, 0);					end;				otherwise					;			end;		until localItemHit in [1, 2];{oooooooooooooooooooooooooooooooooooooo}		if localItemHit = 2 then			begin				ChartLogSigDigits := oldChartLogSigDigits;			end		else			GrabChartLogText;		EndDLOG(theDialog, tempP);	end;{-----------------------------------------------------------------------------}	procedure DoBottomChartMenu (ItemNo: integer);	begin		case ItemNo of			ChartOptionsItem: 				if charton then					DoChartMenu(CWChart);			ChartPrintItem: 				if charton then					begin						CWFullPrint := not CWFullPrint;						myCheckMenuItem(NewChartMHdl, ChartPrintItem, CWFullPrint);					end;			ChartWtTypeItem: 				if CWChart = CWCChanges then					ScatterToTypeDLOG				else if emptychart then					Beep				else					ChartToWeightsDLOG;			ChartQuietRecalcItem: 				begin					chartQuietRecalc := not chartQuietRecalc;					myCheckMenuItem(NewChartMHdl, chartQuietRecalcItem, chartQuietRecalc);				end;			ChartLogOptionsItem:					ChartLogOptions;			otherwise				;		end;	end;{-----------------------------------------------------------------------------}end.