unit ReadMatrix;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  UtilLibInterface, MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, TaxonCHUtil, SymbolsNames, CharUtil, Thermos, ReadMisc, ReadWriteUtil, ReadUtil, CHUNK, ReadDataBlock;	procedure FileMatrixToMem;	procedure ReadContinuousMatrix (newNexus: boolean);{еееееееееееееееееееееее}implementation {е$S ReadMatrix}{-----------------------------------------------------------------------------}{	function chariswhite (ccL: char): boolean;	external;}{$IFC FALSE}	function quickCalcTsts (c: char; var SP: Ptr; mss: char): largestsetchars;	external;{$ENDC}{-----------------------------------------------------------------------------}	function nextdarkcharpastWhiteSpace (it, ic: INTEGER): char;{returns the next dark character past whitespace or a semicolon.}{if the next dark character occurs before a newline, then moredark is set to true}{this is to skip over any excess character or taxa at end of lines}		var			hitWhite: boolean;			foundsemi: boolean;	begin		hitWhite := (next in whitespace) or (next = ';');		foundsemi := (next = ';');		if not hitwhite then  {the current character is not white (indeed, it is the symbol for the last cell in the line)}			repeat				next := nextchar;				if (next in whitespace) or (next = ';') then					begin						hitWhite := true;						if next = ';' then							foundsemi := true;					end				else if (it = numtaxa) & (ic = numchars) & not foundsemi then {v3.05: we have found something other than ';'}					begin						NewError(408, 0);						openasuntitled := true;					end;			until not (next in whitespace) or (next = ';') or (fpos >= mcFileLength);   {we have found the next dark char}		if not hitWhite then  {we have found something else before whitespace, which means to many characters,}						{	or too many taxa!}			begin				NewError(124, 0);				repeat					next := nextchar;				until (next in whitespace) or (next = ';') or (fpos >= mcFileLength);   {skip to next whitespace, }																					{and leave it just beyond there}				if next in whitespace then					next := nextdarkchar;			end;		nextdarkcharpastWhiteSpace := next;	end;{-----------------------------------------------------------------------------}	function GetPotentialTaxonNameToken: str255;	begin		CheckAdjacenti;		GetPotentialTaxonNameToken := GetFileToken(maxtok);		{getting taxon name}	end;{-----------------------------------------------------------------------------}	procedure ProcessTaxonName (ds: str255; setit, warnbadname: boolean; it: integer; var taxonNumber: integer);		var			j: integer;	begin		taxonNumber := 0;		if (ds = ';') then			begin				if warnbadName then					begin						InstantError(258);						errorflag := true;						badfile := true;					end;			end		else			begin				if taxaDefined then					taxonnumber := GetTaxonNumber(ds)				else if setit then					begin{$IFC FALSE}{this little section of code converts full caps names into names with only the first letter capitalized}{please do not remove}						if length(ds) > 1 then							for j := 2 to length(ds) do								if (ds[j] >= 'A') and (ds[j] <= 'Z') then									ds[j] := chr(ord(ds[j]) + 32);{$ENDC}						StringToTaxonName(ds, it);					end;			end;	end;	{-----------------------------------------------------------------------------}	procedure CheckForMSl(var tsts: largestsetchars);	begin		if (MSl in tsts) & (tsts <> [MSl]) & (tsts <> [MSl, gal]) & (tsts<>[MSl,SSl]) then			tsts := tsts - [MSl];	end;{-----------------------------------------------------------------------------}	procedure FileMatrixToMem;		label			1, 2, 5;		var			it, il, ic, j, ist, endist, L, posc, icstart, halftaxa, halfchars: integer;			thepos, hsize: integer;			tempTaxonNumber: integer;			taxonNumber: integer;			c: char;			tsts: largestsetchars;			ds: str255;			SP: Ptr;			HP: HdlPtr;			firstblock, nexttaxon, salt: boolean;			wierdthings, doequates, setAltSymbol: boolean;			taxstsHdl: Handle;			firstTaxon: integer;			readMissing,readGap,readMatchchar: char;			oldState, oldState1, oldState2: SignedByte;{.............}		procedure CalcTSTS;		begin			setAltSymbol := false;			tsts := [];			if (c = '{') or (c = '(') then				{reading in polymorphism}				begin					if ((c = '{') and (msTaxa = mstVariable)) or (msTaxa = mstUncertain) then						tsts := [UCl];					repeat						if doequates then							repeat								thepos := thepos + 1;								c := Hchar(eqH, thepos);							until (thepos >= hsize) | not (c in whitespace+vacuum)						else							c := nextdarkchar;						if c = '~' then							begin								if doequates then									repeat										thepos := thepos + 1;										c := Hchar(eqH, thepos);									until (thepos >= hsize) or not (c in whitespace+vacuum)								else									c := nextdarkchar;								endist := NumOfChar(c, taxonNumber, ic);								if endist <> MSl then									tsts := tsts + [ist..endist];							end						else if not (c in [' ', chr(9), chr(13), chr(10), ',', '}', ')']) then							begin								if (c <> missing) then									begin										ist := NumOfChar(c, taxonNumber, ic);										if ist <> MSl then											tsts := tsts + [ist];									end;							end;					until (c = '}') or (c = ')');				end			else		{reading in monomorphic taxon}				begin					if wierdthings then						begin							if equateson & (equates^^[ord(c)] <> []) then								begin									tsts := equates^^[ord(c)];									if MultipleStatesLg(tsts) then										begin											if (msTaxa = mstUncertain) then												tsts := tsts + [UCl]											else if (msTaxa = mstPolymorph) then												tsts := tsts - [UCl];										end;								end							else if nucleotides then{======== DNA RNA ========}								begin									tsts := DNARNASetOfChar(c, msTaxa <> mstPolymorph, firstTaxon, taxonNumber, ic);									if IsAlternativeSymbolChar(c) then										tsts := tsts+[SSl];								end{========= protein ============}							else if datatype = protein then								tsts := ProteinSetOfChar(c, msTaxa <> mstPolymorph, firstTaxon, taxonNumber, ic){========================}							else if matchcharon & (taxonNumber <> firstTaxon) & (c = readMatchchar) then								tsts := gettaxonstsLargest(firstTaxon, ic)							else if c = readMissing then								tsts := [MSl]							else if c = readGap then								tsts := [MSl, GAl]							else								tsts := [NumOfChar(c, taxonNumber, ic)];						end					else  {not wierd}						begin							if c = readMissing then								tsts := [MSl]							else if c = readGap then								tsts := [MSl, GAl]							else								tsts := [StandardNumOfChar(c, taxonNumber, ic)]						end;				end;		end;{.............}		procedure ProcessEquates (var eqH: Handle);			var				k, sym: integer;		begin			doequates := true;			for k := 0 to 255 do				equates^^[k] := [];			hsize := GetHandleSize(eqH);			thepos := 0;			repeat				repeat		{find symbol}					thepos := thepos + 1;					c := Hchar(eqH, thepos);				until (thepos >= hsize) or not (c in whitespace+vacuum);				if thepos < hsize then					begin						if (pos(MakeSmall(c),symbols)>0) | (pos(MakeCaps(c),symbols) >0)then							NewError(457,0);						sym := ord(c);  {new symbol}						repeat		{remove =}							thepos := thepos + 1;							c := Hchar(eqH, thepos);						until (thepos >= hsize) or (c = '=');						repeat		{find symbol}							thepos := thepos + 1;							c := Hchar(eqH, thepos);						until (thepos >= hsize) or not (c in whitespace+vacuum);						tsts := [];						CalcTSTS;						CheckForMSl(tsts);						equates^^[sym] := tsts;					end;			until thepos >= Hsize;			c := Hchar(eqH, thepos);			doequates := false;		end;{.............}	begin		setAltSymbol := false;		CalcSolidIOSymbols(readMissing,readGap,readMatchchar);		firstTaxon := 1;		doequates := false;		wierdthings := molecular or equateson or matchcharon or symbolson;		ic := 0;		taxonNumber := 0;		it := 0;		if equateson then			begin				ProcessEquates(eqH);				ZapHandle(eqH);			end;		halftaxa := numtaxa div 2;		halfchars := numchars div 2;		SetCursID(carabid);		if symbolson then			L := length(symbols);		if interleave then{======================= interleaved matrix ==========================}			begin				salt := true;				firstblock := true;				ic := 1;				icstart := ic;				interleavelength := numchars;				goto 2;1:				firstblock := false;2:				it := 0;				salt := not salt;				if salt then					SetCursID(salticid)				else					SetCursID(carabid);				while it < numtaxa do					begin						UpdateThermo(iothermo, 0, fpos, mcFileLength,true);						errorflag := abortedThermo | errorflag;						if errorflag then							Exit(fileMatrixToMem);						it := it + 1;						ProcessTaxonName(GetPotentialTaxonNameToken, firstblock, true, it, tempTaxonNumber);						if taxaDefined & (tempTaxonNumber > 0) & (tempTaxonNumber <= numtaxa) then							begin								taxonNumber := tempTaxonNumber;								if it = 1 then									firstTaxon := taxonNumber;							end						else							taxonNumber := it;						TaxStsHdl := GetTaxStsHdl(taxonNumber);						LockHandle(TaxstsHdl, oldState);						ic := icstart - 1;						SP := Ptr(GetMaster(TaxStsHdl) + ord4(ic) * tcb);						c := nextdarkchar;						nexttaxon := false;						while not nexttaxon & not errorflag do							begin								if not (c in [' ', chr(9), chr(13), chr(10), ',', ';']) then									begin										ic := ic + 1;										if ic <= numchars then											begin												CalcTSTS;												setAltSymbol := nucleotides & (SSl in tsts);												if (ic > 0) then													CheckForMSl(tsts);												TransferStatesFromLargest(SP, tsts);												{if setAltSymbol then SetAlternativeSymbol(taxonNumber,ic,true);}												SP := Ptr(ord4(SP) + tcb);											end										else											NewError(124, 0);										c := nextchar;									end								else if NewLineChar(c) or (c = ';') then									begin										if firstblock then											interleavelength := ic;										nexttaxon := true;										if (c = ';') and ((it < numtaxa) or (ic < numchars)) then											begin												InstantError(258);												errorflag := true;												badfile := true;											end;									end								else									c := nextchar;								next := c;							end;  {numchars loop}						ResetHandle(TaxstsHdl, oldState);					end;   {numtaxa loop}				if ic < numchars then					begin						icstart := ic + 1;						goto 1;					end;			end		else if not editorTransposed then{========================= normal matrix ==========================}			begin				it := 0;{    LockHandle(TaxstsCHUNKs, oldState1);}{HP := HdlPtr(GetMaster(TaxstsCHUNKs));}				while it < numtaxa do					begin						UpdateThermo(iothermo, 0, fpos, mcFileLength,true);						errorflag := abortedThermo | errorflag;						if errorflag then							Exit(fileMatrixToMem);						if it = halftaxa then							SetCursID(salticid);						it := it + 1;{TaxStsHdl := HP^;}						ProcessTaxonName(GetPotentialTaxonNameToken, true, true, it, tempTaxonNumber);						if taxaDefined & (tempTaxonNumber > 0) & (tempTaxonNumber <= numtaxa) then							begin								taxonNumber := tempTaxonNumber;								if it = 1 then									firstTaxon := taxonNumber;							end						else							taxonNumber := it;						TaxStsHdl := GetTaxStsHdl(taxonNumber);						LockHandle(TaxstsHdl, oldState2);						SP := Ptr(GetMaster(TaxStsHdl));						ic := 0;						c := nextdarkchar;						if somechars then							while (ic < numchars) & not errorflag do								begin									if not chariswhite(c) then										begin											ic := ic + 1;											tsts := [];											if (tsts = []) then												begin													CalcTSTS;													setAltSymbol := nucleotides & (SSl in tsts);													CheckForMSl(tsts);													TransferStatesFromLargest(SP, tsts);													if setAltSymbol then SetAlternativeSymbol(taxonNumber,ic,true);													SP := Ptr(ord4(SP) + tcb);												end;										end									else if c = ';' then										begin											if taxaDefined then												goto 5											else												begin													InstantError(258);													errorflag := true;													badfile := true;												end;										end;									if ic = numchars then										c := nextdarkcharpastWhiteSpace(it, ic)									else										c := nextdarkchar;									if c = ';' then										leave;								end;  {numchars loop}						ResetHandle(TaxstsHdl, oldState2);{HP := HdlPtr(ord4(HP) + HdlSize);}						if c = ';' then							leave;					end;   {numtaxa loop}{    ResetHandle(TaxstsCHUNKs, oldState1);}5:			end		else{========================= transposed matrix ==========================}			begin				ic := 0;				while ic < numchars do					begin						UpdateThermo(iothermo, 0, fpos, mcFileLength,true);						errorflag := abortedThermo | errorflag;						if errorflag then							Exit(fileMatrixToMem);						if ic = halfchars then							SetCursID(salticid);						ic := ic + 1;						ds := GetFileToken(maxtok);		{getting character name}						if ds = ';' then							begin								InstantError(258);								errorflag := true;								badfile := true;								Exit(fileMatrixToMem);							end;						SetCharName(ic, ds);						taxonNumber := 0;						c := nextdarkchar;						while (taxonNumber < numtaxa) & not errorflag do							begin								if c = ';' then									begin										InstantError(258);										errorflag := true;										badfile := true;										Exit(fileMatrixToMem);									end;								if not (c in [' ', chr(9), chr(13), chr(10), ',']) then									begin										taxonNumber := taxonNumber + 1;										CalcTSTS;										setAltSymbol := nucleotides & (SSl in tsts);										if (taxonNumber > 0) then											CheckForMSl(tsts);										settaxonstsLargest(taxonNumber, ic, tsts);										if setAltSymbol then SetAlternativeSymbol(taxonNumber,ic,true);									end;								if taxonNumber = numtaxa then									c := nextdarkcharpastWhiteSpace(it, ic)								else									c := nextdarkchar;							end;  {numtaxa loop}					end;   {numchars loop}			end;	end;{-----------------------------------------------------------------------------}	procedure ReadContinuousMatrix (newNexus: boolean); {TRANSFER:}		var			TaxonHdl: thdl;			ds: str255;			ic, it: integer;			taxonnumber: integer;			db: boolean;			rr, rss: single;			numContinuousInFile: integer;			oldpunct: set of char;	begin{		if numcontinuous > mncontinuous then			begin				InstantError(210);				numcontinuous := 0;				openAsUntitled := true;			end		else			begin}		oldpunct := punctuation;		punctuation := punctuation-['-'];		numContinuousInFile := numContinuous;		if numcontinuous > mncontinuous then			begin				InstantError(210);				numcontinuous := mncontinuous;				openAsUntitled := true;			end;								for it := 1 to numtaxa do					begin						TaxonHdl := GetTaxonHdl(it);						for ic := 1 to mncontinuous do							begin								taxonhdl^^.contsmin[ic] := -1.0;								taxonhdl^^.contsmax[ic] := -1.0;							end;					end;				ds := GetPotentialTaxonNameToken;  {first taxon name}				it := 1;				ProcessTaxonName(ds, true, false, it, taxonNumber);   {v3.05}				if not taxaDefined then					taxonNumber := it;				while (ds <> ';') & not errorflag do					begin						if newNEXUS & minMaxContinuous then							begin								if (taxonnumber > 0) and (taxonnumber <= numtaxa) then									begin										TaxonHdl := GetTaxonHdl(taxonnumber);										for ic := 1 to numContinuousInFile do																						begin												ds := GetFileToken(maxtok); {'('}												ds := GetFileToken(maxtok);												rr := -1.0;												if ds <> '?' then													begin														rr := TokenToReal(ds);														if rr<0.0 then															begin																rr := -1.0;																NewError(452,ic);															end;														if ic<= numcontinuous then taxonhdl^^.contsmin[ic] := rr;													end;												whitespace := whitespace + [','];												ds := GetFileToken(maxtok);												if ds <> '?' then													begin														rss := rr;														rr := TokenToReal(ds);														if rr<0.0 then															begin																rr := -1.0;																NewError(452,ic);															end;														if rr <> rss then															if ic<= numcontinuous then taxonhdl^^.contsmax[ic] := rr;													end;												ds := GetFileToken(maxtok); {')'}												whitespace := whitespace - [','];											end;										ds := GetPotentialTaxonNameToken;									end								else									begin										NewError(55, 0);										badfile := true;										errorflag := true;										Exit(ReadContinuousMatrix);									end;							end						else							begin								if (taxonnumber > 0) and (taxonnumber <= numtaxa) then									begin										TaxonHdl := GetTaxonHdl(taxonnumber);										ds := GetFileToken(maxtok); {first state or '('}										if minMaxcontinuous then											ds := GetFileToken(maxtok);										for ic := 1 to numContinuousInFile do											begin												if ds <> '?' then													begin														rr := TokenToReal(ds);														if rr<0.0 then															begin																rr := -1.0;																NewError(452,ic);															end;														if ic<= numcontinuous then taxonhdl^^.contsmin[ic] := rr;														ds := GetPotentialTaxonNameToken;														if ds = '-' then															begin																ds := GetFileToken(maxtok);  {contsmax[ic]}																if ds <> '?' then																	begin																		rr := TokenToReal(ds);																		if rr<0.0 then																			begin																				rr := -1.0;																				NewError(452,ic);																			end;																		if ic<= numcontinuous then taxonhdl^^.contsmax[ic] := rr;																	end;																ds := GetPotentialTaxonNameToken;															end													end												else													ds := GetPotentialTaxonNameToken;											end;									end								else									begin										NewError(55, 0);										ds := GetPotentialTaxonNameToken;									end;							end;						it := it + 1;						ProcessTaxonName(ds, true, false, it, taxonNumber);   {v3.05: get taxon name for next one}						if not taxaDefined then							taxonNumber := it;					end;			{end;}		contmemorymade := true;		punctuation := oldpunct;	end;{-----------------------------------------------------------------------------}end.