unit SimpleUtil;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright David R. Maddison & Wayne P. Maddison 1986-2000}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{David or Wayne Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}{еееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееNOTE: ALL routines in this unit MUST be entirely self-sufficient, dependingupon NO other routines, even ones in this unit, although they can call routines in MemoryUtilеееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее}interface	uses		QuickDraw, Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound,		 Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, FP,		  Scrap,  Globals, MemoryUtil, CarbonUtil,		   SetLibInterface, UtilLibInterface,   Script;	procedure CallWaitNextEventForDrawing;	procedure pause;	procedure Beep;	procedure SetGeneva9 (var oldfont, oldsize: integer);	procedure SetMonaco9 (var oldfont, oldsize: integer);	procedure ReSetOldFont (oldfont, oldsize: integer);		function TruncateValue(d: double): longint;	function RoundValue(d: double): longint;	function ColorPort: boolean;	function IsSetChain (theChain: Integer): boolean;	function ChainFromInfo(whichInfo: integer): integer;	function InfoHasSelectSets(whichInfo: integer): boolean;	function SelectSetChainFromObjectInfo(whichInfo: integer): integer;	function SelectSetInfoFromObjectInfo(whichInfo: integer): integer;	procedure SetCursH (cursH: twocursors);	procedure SetCursID (cursid: integer);		procedure DrawPICTResourceAtPoint(wh: point; center, erase: boolean;  id: integer);	procedure PlacePictureWhileButtonDown (thePicture: PicHandle; wh: point);	procedure PlaceTextPtrWhileButtonDown (P: Ptr; textLength: integer; wh: point; widest, numLines: integer);	procedure PlaceTextHandleWhileButtonDown (H: Handle; wh: point);	procedure PlaceTextWhileButtonDown (theString: str255; wh: point; useMonaco: boolean);	procedure PlaceFramedPictureWhileButtonDown (thePicture: PicHandle; wh: point);	procedure CalcTemporaryTextBox (theString: str255; wh: point; var offscreenBox,onscreenBox: rect);	procedure SetUpTemporaryPicture (var myOffScreenWorld: GWorldPtr;  var wPort: CGrafPtr; offScreenbox,onScreenBox: Rect; var tempP: WindowPtr; var offPixMapHandle:  PixMapHandle);	procedure DrawTemporaryText (theString: str255; onScreenBox: Rect);	procedure RePlaceTemporaryText (myOffScreenWorld: GWorldPtr; offPixMapHandle:  PixMapHandle; offScreenbox,onScreenBox: Rect; wPort: CGrafPtr; tempP: WindowPtr);	function CopyString (ds: str255; index: integer; count: integer): str255;	function NumericalToken (ds: str255): boolean;	function StringFromNum (dL: longint): str255;	function GetFontNumber (fontName: str255; var fontNumber: integer): boolean;  {v3.05}	function SomeCodePosPartToColor: boolean;	function SomePartitionPartToColor: boolean;	procedure InvalTaxonNames;	function MenuAvailable (theMenu: integer): boolean;	procedure EnableDisableItem (theMenu: MenuHandle; Item: integer; turnon: boolean);		procedure CalcLineWidthDescent(theTE: TEHandle; theFont: integer; var linewidth, descent, ascent: integer);	procedure SetTELineWidthDescent(theTE: TEHandle; linewidth, descent, ascent: integer);	procedure SetStandardSelectionColor(theColor: integer);	procedure SetDarkGrayForeground (var oldFore: RGBColor);	procedure SetGrayBackground (var oldBack: RGBColor; darkness: integer);	procedure ResetForeground (oldFore: RGBColor);	procedure SetTingeBackground (tinge: integer);	procedure SetRGBBackground (back: RGBColor);	procedure GetRGBSetTingeBackground (var oldBack: RGBColor; tinge: integer);	procedure DarkenRectangle (box: rect; darkness: integer);	procedure SwitchShade(darkness: integer);	procedure ShadeSelectedRectangle (box: rect);	procedure SetShade(darker: boolean; weight: double);	procedure SetRGBShade(RGB: RGBColor);	procedure RestoreShade;	function ColorScaleForTicks (fraction: double): RGBColor;	function DimColor (theColor: RGBColor; fraction: double): RGBColor;	function DarkenColor (theColor: RGBColor; fraction: double): RGBColor;	procedure FillRestSymbols;	procedure DoBitSet;	procedure SetDirtyTree;	procedure CheckDirty;	function FlashNonCodonsInEditor: boolean;	procedure ReplaceIfMaximumLong (var oldMax: longint; candidate: longint);	procedure ReplaceIfMinimumLong (var oldMin: longint; candidate: longint);	function IntegerMin (int1, int2: integer): integer;	function IntegerMax (int1, int2: integer): integer;	function FontHeight: integer;	function StartUserLink (theChain: Integer): longint;	function EndUserLink (theChain: Integer): longint;	function LinkNumOfUser (theChain: Integer; usernumber: longint): longint;	function LinksInChain (theChain: Integer): longint;	function LinkNumberFromInfoRow (theChain: Integer; theRow: longint): longint;	function InfoRowFromLinkNumber (theChain: Integer; theLink: longint): longint;	procedure CheckInflate;	procedure AddToGoListIfNotInGoMask (goAdd: goSet);	procedure WtChangeGoList;	procedure FixStateGoList;	procedure RearrangeTreeGoList;	procedure FullTreeOnScreenGoList;	procedure ChangeTypesGolist;	procedure ChangeExclusionsGolist;	procedure ChangeAcctranDeltranGoList;	procedure ChangeCodonsGolist;	procedure ChangeStoredTreesGoList;	function PaintedBranches: boolean;	function AddGenDist (a, b: longint): longint;  {make longint or real if appropriate}	function GenLessThan (a, b: longint): boolean;	function ListCellSelected (theList: ListHandle; zero: boolean): point;	procedure RestoreSystemFonts;	procedure DoSetLineWidth (num, den: integer);	procedure GridLineTo (hor, ver: integer; darkLine: boolean);	procedure ThinLineTo (toh, tov: integer; dogray: boolean);	function GrayScale (range, number: integer): RGBColor;{$IFC TINKERTOY}	function TinkerTree: boolean;{$ENDC}	function AnyFeet (theFoot: integer): boolean;	function calcMinActive: boolean;	function calcMaxActive: boolean;	procedure CheckScreenRectangle;	procedure CreateCellBlock(var cellBlock: cellBlockPtr);	procedure DestroyCellBlock(var cellBlock: cellBlockPtr);	procedure EmptyCellBlock(cellBlock: CellBlockPtr);	function CellBlockHasData(cellBlock:CellBlockPtr): boolean;	function CellBlockHasDataOfLegalSize(cellBlock:CellBlockPtr): boolean;	function CellBlockHasSingleTaxon(cellBlock:CellBlockPtr): boolean;	function flashRNARCHasLegalOriginalBlock: boolean;		function AsArrowOnRCNumber(clickTaxon,clickChar,whichTool: integer): boolean;	function AAAutoTranslationVisible: boolean;	function ShadeCharacterSensitiveToCellChange: boolean;	function ShadeCharacterSensitiveToIncExc: boolean;	function ShadeCharacterSensitiveToCodPos: boolean;		function UpdateAsSensitiveToFirstTaxonChange(it: integer): boolean;	function Consensus(consensusNumber: integer): ConsensusPtr;	function AnyConsensusSelected: boolean;	function ConsensusSequenceVisible: boolean;	function EditorCellsColored: boolean;	function EditorCellsColoredByState: boolean;		function GetDirectLinkH (theChain: Integer; theLink: longint): Handle;	function LinkOffSet (linkH: Handle): integer;	procedure DrawSmallTriangle (pt: Point; theColor: RGBColor);		function Locked(theFeature: integer): boolean;	procedure SpinBeachBall;	procedure ZeroSplitMulti;		function TicksVisible: boolean;	function TickNamesVisible: boolean;	function TicksAreColored: boolean;	function TicksRequireBoxes: boolean;	function TicksHaveLegend: boolean;		procedure DoDeactivateControl(theControl: ControlRef);	procedure DoActivateControl(theControl: ControlRef);	function SelectionQueryRectangle: rect;	procedure InvalidateSelectionQueryRectangle;	function TransferTreesAvailable: boolean;		function OpenNewPicture(box: Rect): PicHandle;	FUNCTION GetControlValueLong(theControl: ControlRef): longint;	PROCEDURE SetControlValueLong(theControl: ControlRef; newValue: univ longint);	FUNCTION GetControlMaximumLong(theControl: ControlRef): longint;	PROCEDURE SetControlMaximumLong(theControl: ControlRef; newMaximum: univ longint);	FUNCTION GetControlMinimumLong(theControl: ControlRef): longint;	PROCEDURE SetControlMinimumLong(theControl: ControlRef; newMinimum: univ longint);	const		leadingSpaceForPopupNotes = 14;		trailingSpaceForPopupNotes = 2;		frameThicknessForPopupNotes = 1;		maxLineWidthForPopupNotes = 150;{еееееееееееееееееееееее}implementation {е$S genutils}{еееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееNOTE: ALL routines in this unit MUST be entirely self-sufficient, dependingupon NO other routines, even ones in this unit, although they can call routines in MemoryUtilAND CarbonUtilеееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее}	{----------------------------------------------------------------------------}	procedure CallWaitNextEventForDrawing;	var db: boolean;		tev: EventRecord;	begin{$IFC CARBON}		if isMacOSX then			db := WaitNextEvent(0, tev, 1, nil);{$ENDC}	end;{----------------------------------------------------------------------------}	procedure SetGeneva9 (var oldfont, oldsize: integer);	 begin		oldfont := QDThePortTextFont;		oldsize := QDThePortTextSize;		TextSize(9);		TextFont(kFontIDGeneva);	 end;{----------------------------------------------------------------------------}	procedure SetMonaco9 (var oldfont, oldsize: integer);	 begin		oldfont := QDThePortTextFont;		oldsize := QDThePortTextSize;		TextSize(9);		TextFont(kFontIDMonaco);	 end;{----------------------------------------------------------------------------}	procedure ReSetOldFont (oldfont, oldsize: integer);	 begin		TextSize(oldsize);		TextFont(oldfont);	 end;{----------------------------------------------------------------------------}	function TruncateValue(d: double): longint;	var newD : double_t;	begin{$IFC TARGET_CPU_68K }		TruncateValue := truncateDouble(d);//		TruncateValue := roundtol(newD);//		TruncateValue := Trunc(d);{$ELSEC}		newD := d;		newD := Trunc(newD);		TruncateValue := roundtol(newD);{$ENDC}  	end;{----------------------------------------------------------------------------}	function RoundValue(d: double): longint;	begin		RoundValue := RoundToL(d);	end;{----------------------------------------------------------------------------}	function ColorPort: boolean;	begin		ColorPort := (ScreenInColor & not printon) | (printerColorGrayScale & printon);	end;{-----------------------------------------------------------------------------}	procedure Beep;	begin		Sysbeep(2);	end;{-----------------------------------------------------------------------------}	function InfoHasSelectSets(whichInfo: integer): boolean;	begin		InfoHasSelectSets := (whichinfo = charinfo) | (whichinfo = taxinfo);	end;{-----------------------------------------------------------------------------}	function IsSetChain (theChain: Integer): boolean;	begin		IsSetChain := (thechain = charsetchain) | (thechain = taxsetchain);	end;{-----------------------------------------------------------------------------}	function ChainFromInfo(whichInfo: integer): integer;	begin 		case whichinfo of			typeSetInfo:				ChainFromInfo := typesetchain;			exSetInfo:				ChainFromInfo := exsetchain;			wtSetInfo:				ChainFromInfo := wtsetchain;			CharPartInfo:				ChainFromInfo := CharPartitionChain;			charSetinfo: 				ChainFromInfo := charSetChain;			taxSetinfo: 				ChainFromInfo := taxSetChain;			treeinfo:				ChainFromInfo := treeChain;			otherwise 				ChainFromInfo := notAChain;		end;	end;{-----------------------------------------------------------------------------}	function SelectSetChainFromObjectInfo(whichInfo: integer): integer;	begin 		case whichinfo of			charinfo: 				SelectSetChainFromObjectInfo := charSetChain;			taxinfo: 				SelectSetChainFromObjectInfo := taxSetChain;			otherwise 				SelectSetChainFromObjectInfo := notAChain;		end;	end;{-----------------------------------------------------------------------------}	function SelectSetInfoFromObjectInfo(whichInfo: integer): integer;	begin 		case whichinfo of			charinfo: 				SelectSetInfoFromObjectInfo := charSetInfo;			taxinfo: 				SelectSetInfoFromObjectInfo := taxSetInfo;			otherwise 				SelectSetInfoFromObjectInfo := noinfo;		end;	end;{-----------------------------------------------------------------------------}	procedure SetCursH (cursH: twocursors);	begin		if cursH.colorH = nil then			if cursH.H = nil then				SetCursorToArrow			else				SetCursor(cursH.H^^)  {don't need to lock as SetCursor does not move memory}		else			SetCCursor(cursH.colorH);	end;{-----------------------------------------------------------------------------}	procedure SetCursID (cursID: integer);		var			CursorHdl: CursHandle;			ColorCursorHdl: CCrsrHandle;			oldState: SignedByte;			nocolor: boolean;	begin		if isforeground then			if cursID = arrowID then				SetCursorToArrow			else				begin					nocolor := true;					if colorQDExists then						begin							ColorCursorHdl := GetCCursor(cursID);							nocolor := (ColorCursorHdl = nil) | (ResError<>noErr);						end;					if nocolor then						begin							CursorHdl := GetCursor(cursID);							LockHandle(cursorHdl,oldstate);							SetCursor(CursorHdl^^);							ResetHandle(cursorHdl,oldstate);							ReleaseResource(Handle(CursorHdl));						end					else						begin{brushcolor changed as appropriate in Shading and MouseInTree}							SetCCursor(ColorCursorHdl);							DisposeCCursor(ColorCursorHdl);						end;				end;	end;{||||||||||||||||||||||||||||||||||||||  |||||||||||||||||||||||||||||||||||||||||||}{---------------------------------------------------------------------}	function CopyString (ds: str255; index: integer; count: integer): str255;	begin		if count+index -1> length(ds) then			count := length(ds)+1-index;		CopyString := copy(ds, index, count);	end;{----------------------------------------------------------------------------}	function NumericalToken (ds: str255): boolean;  {returns true iff ds is entirely numerical (or with blanks and underscores)}		var			j, lastNonBlank: integer;			numToken: boolean;	begin		numToken := not ((ds = ' ') or (ds = '_') or (ds = '')); {if it is one of those, it is false, otherwise true}		if numToken then			begin				lastNonBlank := length(ds);   {v3.02: all this lastNonBlank}				for j := length(ds) downto 1 do					if not ((ds[j] = ' ') | (ds[j] = '_')) then						begin							lastNonBlank := j;							leave;						end;				for j := 1 to lastNonBlank do					if not ((ds[j] >= '0') and (ds[j] <= '9')) then						begin							numToken := false;							leave;						end;			end;		NumericalToken := numToken;	end;{-----------------------------------------------------------------------------}	function StringFromNum (dL: longint): str255;		var			ds: str255;	begin		NumToString(dL, ds);		StringFromNum := ds;	end;{-----------------------------------------------------------------------------}	function GetFontNumber (fontName: str255; var fontNumber: integer): boolean;  {v3.05}{given the font named FontName, then returns the font number in fontNumber.  }{functions itself returns whether or not font was found}		var			systemFontName: str255;	begin		GetFNum(fontName, fontNumber);		if fontNumber = 0 then			begin				GetFontName(0, systemFontName);				GetFontNumber := EqualString(systemFontName, fontName, false, false);			end		else			GetFontNumber := true;	end;{-----------------------------------------------------------------------------}	procedure SetDarkGrayForeground (var oldFore: RGBColor);		var			darkGray: RGBColor;	begin		if colorQDexists then			begin				GetForeColor(oldFore);				darkGray.red := $5555;				darkGray.green := $5555;				darkGray.blue := $5555;				RGBForeColor(darkGray);			end;	end;{-----------------------------------------------------------------------------}	procedure SetGrayBackground (var oldBack: RGBColor; darkness: integer);		var			gray: RGBColor;	begin		if colorQDexists then			begin				GetBackColor(oldBack);  				case darkness of					grayPalest:						begin							gray.red := $EEEE;							gray.green := $EEEE;							gray.blue := $EEEE;						end;					grayPale:						begin							gray.red := $CCCC;							gray.green := $CCCC;							gray.blue := $CCCC;						end;					grayPlain:						begin							gray.red := $BBBB;							gray.green := $BBBB;							gray.blue := $BBBB;						end;					grayDark:						begin							gray.red := $8888;							gray.green := $8888;							gray.blue := $8888;						end;					grayDarkest:						begin							gray.red := $5555;							gray.green := $5555;							gray.blue := $5555;						end;					otherwise						begin							gray.red := $BBBB;							gray.green := $BBBB;							gray.blue := $BBBB;						end;				end;				RGBBackColor(gray);			end;	end;{-----------------------------------------------------------------------------}	procedure JustSetBackground (tinge: integer);	begin	end;{-----------------------------------------------------------------------------}	procedure SetTingeBackground (tinge: integer);		var			theColor: RGBColor;	begin		if colorQDexists then			begin				case tinge of					blueTinge: 						begin							theColor.red := $9791;							theColor.green := $EC4F;							theColor.blue := $FFFF;						end;					infoCurrentTinge: 						begin							theColor.red := $FFFF;							theColor.green := $BBBB;							theColor.blue := $9999;						end;					yellowTinge: 						begin							theColor.red := $FFFF;							theColor.green := $FFFF;							theColor.blue := $BBBB;						end;					grayTinge: 						begin							theColor.red := $DDDD;							theColor.green := $DDDD;							theColor.blue := $DDDD;						end;					otherwise						begin   {noTinge}							theColor.red := $0000;							theColor.green := $0000;							theColor.blue := $0000;						end;				end;				RGBBackColor(theColor);			end;	end;{-----------------------------------------------------------------------------}	procedure DrawPICTResourceAtPoint(wh: point; center, erase: boolean;  id: integer);		var			picBox: rect;			picH: PicHandle;			width, height: integer;			top, left: integer;	begin		picH := GetPicture(id);		if picH <> nil then			begin				width := picH^^.picFrame.right - picH^^.picFrame.left;				height := picH^^.picFrame.bottom - picH^^.picFrame.top;				top := wh.v;				left := wh.h;				if center then					begin						top := top-height div 2;						left := left - width div 2;					end;				SetRect(picBox,left,top,left+width,top+height);				DrawPicture(picH, picBox);				ReleaseResource(Handle(picH));			end;	end;{-----------------------------------------------------------------------------}	procedure SetRGBBackground (back: RGBColor);	begin		if colorQDexists then			RGBBackColor(Back);	end;{-----------------------------------------------------------------------------}	procedure GetRGBSetTingeBackground (var oldBack: RGBColor; tinge: integer);	begin		if colorQDexists then			begin				GetBackColor(oldBack);				SetTingeBackground(tinge);			end;	end;{-----------------------------------------------------------------------------}	procedure ResetForeground (oldFore: RGBColor);	begin		if colorQDexists then			RGBForeColor(oldFore);	end;{----------------------------------------------------------------------------}	procedure SetShade(darker: boolean; weight: double);	 var		origPort: CGrafPtr;		origDevice:GDHandle;		good:  Boolean;		myErr: QDErr;	 begin		GetGWorld(origPort, origDevice); {save onscreen graphics port}		if (selectOffScreenWorld = NIL) then			Exit(SetShade); {handle errors here}		SetGWorld(selectOffScreenWorld, NIL); {set current graphics port to offscreen}		if darker then 			FillBlackRect(selectOffScreenWorldBox)		else			FillWhiteRect(selectOffScreenWorldBox);		selectWeightColor.red := RoundValue(65535*(1.0-weight));		selectWeightColor.green := RoundValue(65535*(1.0-weight));		selectWeightColor.blue :=RoundValue(65535*(1.0-weight));		SetGWorld(origPort, origDevice); {restore onscreen graphics port}	 end;{----------------------------------------------------------------------------}	procedure RestoreShade;	begin		SwitchShade(selectionShade);	end;{----------------------------------------------------------------------------}	procedure SetRGBShade(RGB: RGBColor);	 var		origPort: CGrafPtr;		origDevice:GDHandle;		good:  Boolean;		myErr: QDErr;		box: rect;	 begin		SetRect(box,0,0,1,1);		GetGWorld(origPort, origDevice); {save onscreen graphics port}		if (selectOffScreenWorld = NIL) then			; {handle errors here}		SetGWorld(selectOffScreenWorld, NIL); {set current graphics port to offscreen}		RGBForeColor(RGB);		FillBlackRect(box);{		selectWeightColor.red := RGB.red;		selectWeightColor.green := RGB.green;		selectWeightColor.blue := RGB.blue;}		selectWeightColor.red := 40000;		selectWeightColor.green := 40000;		selectWeightColor.blue := 40000;		RGBForeColor(blackRGB);		SetGWorld(origPort, origDevice); {restore onscreen graphics port} end;{----------------------------------------------------------------------------}	procedure SwitchShade(darkness: integer);	 var		origPort: CGrafPtr;		origDevice:GDHandle;		good:  Boolean;		myErr: QDErr;		box: rect;	 begin		SetRect(box,0,0,1,1);		GetGWorld(origPort, origDevice); {save onscreen graphics port}		if (selectOffScreenWorld = NIL) then			Exit(SwitchShade); {handle errors here}		SetGWorld(selectOffScreenWorld, NIL); {set current graphics port to offscreen}		case darkness of 			muchPaler:				begin					FillWhiteRect(box);					selectWeightColor.red := 50000;					selectWeightColor.green := 50000;					selectWeightColor.blue :=50000;				end;			slightlyPaler:				begin					FillWhiteRect(box);					selectWeightColor.red := 10000;					selectWeightColor.green := 10000;					selectWeightColor.blue :=10000;				end;			paler:				begin					FillWhiteRect(box);					selectWeightColor.red := 45000;					selectWeightColor.green := 45000;					selectWeightColor.blue :=45000;				end;			darker:				begin					FillBlackRect(box);					selectWeightColor.red := 20000;					selectWeightColor.green := 20000;					selectWeightColor.blue := 20000;				end;			selectionShade:				begin					FillBlackRect(box);					selectWeightColor := standardSelectionColor;				end;			muchDarker:				begin					FillBlackRect(box);					selectWeightColor.red := 30000;					selectWeightColor.green := 30000;					selectWeightColor.blue := 30000;				end;			otherwise;		end;		SetGWorld(origPort, origDevice); {restore onscreen graphics port} end;{-----------------------------------------------------------------------------}	procedure SetStandardSelectionColor(theColor: integer);	begin		case theColor of 			1:   {gray}				begin					standardSelectionColor.red := 20000;					standardSelectionColor.green := 20000;					standardSelectionColor.blue := 20000;				end;			2:  {dark gray}				begin					standardSelectionColor.red := 30000;					standardSelectionColor.green := 30000;					standardSelectionColor.blue := 30000;				end;			3:   {strawberry}				begin					standardSelectionColor.red := 5000;					standardSelectionColor.green := 20000;					standardSelectionColor.blue := 20000;				end;			4:   {tangerine}				begin					standardSelectionColor.red := 1000;					standardSelectionColor.green := 10000;					standardSelectionColor.blue := 45000;				end;			5:   {lime}				begin					standardSelectionColor.red := 20000;					standardSelectionColor.green := 5000;					standardSelectionColor.blue := 20000;				end;			6:   {bondi blue}				begin					standardSelectionColor.red := 30000;					standardSelectionColor.green := 5000;					standardSelectionColor.blue := 5000;				end;			7:   {blueberry}				begin					standardSelectionColor.red := 40000;					standardSelectionColor.green := 20000;					standardSelectionColor.blue := 5000;				end;			8:   {grape}				begin					standardSelectionColor.red := 10000;					standardSelectionColor.green := 20000;					standardSelectionColor.blue := 5000;				end;			otherwise;		end;	end;{-----------------------------------------------------------------------------}	function SetFractionalColor(lowValue,highValue: integer; fraction: double): integer;	var lowValueLong,highValueLong, newColorLong: longint;	begin{$R-}		lowValueLong := lowValue;		highValueLong := highValue;		if lowValue<0 then			lowValueLong := 32767+(32767+lowValueLong);		if highValue<0 then			highValueLong := 32767+(32767+highValueLong);		newColorLong := lowValueLong + TruncateValue((highValueLong-lowValueLong)*fraction);		{if newColorLong>32767 then			newColorLong := 32767newColorLong;}		SetFractionalColor := newColorLong;	end;{-----------------------------------------------------------------------------}	function DimColor (theColor: RGBColor; fraction: double): RGBColor;	var tColor: RGBColor;	begin		if fraction < 1.000000 then			begin				tColor.red := SetFractionalColor(whiteRGB.red,theColor.red,fraction);				tColor.green := SetFractionalColor(whiteRGB.green,theColor.green,fraction);				tColor.blue := SetFractionalColor(whiteRGB.blue,theColor.blue,fraction);			end		else			begin				tcolor := theColor;			end;		DimColor := tColor;	end;{-----------------------------------------------------------------------------}	function DarkenColor (theColor: RGBColor; fraction: double): RGBColor;	var tColor: RGBColor;	begin		if fraction < 1.000000 then			begin				tColor.red := SetFractionalColor(theColor.red,blackRGB.red,fraction);				tColor.green := SetFractionalColor(theColor.green,blackRGB.green,fraction);				tColor.blue := SetFractionalColor(theColor.blue,blackRGB.blue,fraction);			end		else			begin				tcolor := blackRGB;			end;		DarkenColor := tColor;	end;{-----------------------------------------------------------------------------}	function ColorScaleForTicks (fraction: double): RGBColor;	var tColor: RGBColor;	begin		if fraction < 1.000000 then			begin				tColor.red := SetFractionalColor(lowValueColor.red,highValueColor.red,fraction);				tColor.green := SetFractionalColor(lowValueColor.green,highValueColor.green,fraction);				tColor.blue := SetFractionalColor(lowValueColor.blue,highValueColor.blue,fraction);			end		else			begin				tcolor := highestValueColor;			end;		ColorScaleForTicks := tColor;	end;{----------------------------------------------------------------------------}	procedure SetUpTemporaryPicture (var myOffScreenWorld: GWorldPtr;  var wPort: CGrafPtr; offScreenbox,onScreenBox: Rect; var tempP: WindowPtr; var offPixMapHandle:  PixMapHandle);	 var		origPort: CGrafPtr;		origDevice:GDHandle;		myErr: QDErr;		good:  Boolean;		j: integer;		globalwh: point;		horadjust,vertadjust: integer;	 begin		genericGetPort(tempP);{$IFC CARBON}  		wPort :=myGetWindowPort(tempP);{$ELSEC}		GetCWMgrPort(wPort);{$ENDC}		GetGWorld(origPort, origDevice); {save onscreen graphics port}		myErr := NewGWorld(myOffScreenWorld, 0, offScreenBox, NIL, NIL, 0); {create offscreen graphics world}		if (myOffScreenWorld = NIL) or (myErr <> noErr) then			Exit(SetUpTemporaryPicture); {handle errors here}		SetGWorld(myOffScreenWorld, NIL); {set current graphics port to offscreen}		offPixMapHandle := GetGWorldPixMap(myOffScreenWorld);		good := LockPixels(offPixMapHandle);{lock offscreen pixel map}		if not good then			Exit(SetUpTemporaryPicture); {handle errors here}		ClipRect(offScreenBox);		EraseRect(offScreenBox); {clear offscreen pixel map}{copy current image to offscreen bitmap}{$IFC CARBON}  		myPortCopyBits(cGrafPtr(wPort),cGrafPtr(myOffScreenWorld), onScreenBox,{myOffScreenWorld^.portRect}offscreenBox, patcopy, NIL);		SetGWorld(origPort, origDevice); {restore onscreen graphics port}		genericSetPort(tempP);{$ELSEC}		myPortCopyBits(cGrafPtr(wPort),cGrafPtr(myOffScreenWorld), onScreenBox,{myOffScreenWorld^.portRect}offscreenBox, patcopy, NIL);		SetGWorld(origPort, origDevice); {restore onscreen graphics port}		genericSetPort(myGetWindowFromPort(wPort));{$ENDC}		ClipRect(ScreenBoundsRect);  	end;{----------------------------------------------------------------------------}	procedure ReplaceTemporaryPicture(			myOffScreenWorld: GWorldPtr; 			wPort: CGrafPtr;			offScreenbox,onScreenBox: Rect;			tempP: WindowPtr;			offPixMapHandle:  PixMapHandle);	begin{once button is released, copy old current image down}{$IFC TRUE}		myPortCopyBits(CGrafPtr(myOffScreenWorld),CGrafPtr(wPort),{myOffScreenWorld^.portRect} offscreenbox, onScreenBox, patcopy, NIL);		genericSetPort(tempP);		UnlockPixels(offPixMapHandle);		DisposeGWorld(myOffScreenWorld);{$ENDC}	end;{----------------------------------------------------------------------------}	procedure CalcTemporaryTextBox (theString: str255; wh: point; var offscreenBox,onscreenBox: rect);	const		leadingSpace =14;		trailingSpace = 2;		frameThickness=3;	 var		numlines, width,height,j,linewidth: integer;		ds: str255;		oldBack: RGBColor; 		oldfont, oldSize: integer;	 begin		SetGeneva9(oldfont,oldSize);		numlines := 1;		linewidth := StringWidth(theString);		TextFace([]);		width := linewidth + leadingSpace + frameThickness*2 +trailingSpace+2;		height := FontHeight * numlines + frameThickness*2+2;		SetRect(offscreenBox,0,0,width,height);		onScreenBox := offScreenBox;		ResetOldFont(oldfont,oldSize);	 end;{----------------------------------------------------------------------------}	procedure DrawTemporaryText (theString: str255; onScreenBox: Rect);	const		leadingSpace =4;		trailingSpace = 2;		frameThickness=3;	 var		box: rect;		numlines, widest,lastj, width,height,j,linewidth: integer;		ds: str255;		oldBack: RGBColor; 		oldClip: RgnHandle;		info:FontInfo;		oldfont, oldsize: integer;	 begin		box := onScreenBox;			 	oldClip := NewRgn;	 	GetClip(oldClip);		ClipRect(box);		SetGeneva9(oldfont,oldSize);		TextFace([]);				ForeColor(blackColor);		GetRGBSetTingeBackground (oldBack, blueTinge);		PenSize(frameThickness,frameThickness);		FrameRect(box);		PenNormal;		InsetRect(box,frameThickness,frameThickness);		EraseRect(box);		box.right := box.right-trailingSpace;		box.left := box.left+leadingSpace;		GetFontInfo(info);		moveto(box.left+leadingSpace,box.bottom-info.descent-2);		DrawString(theString);		{TETextBox(Pointer(ord4(@theString) + 1), length(theString), box, teJustLeft);}		RGBBackColor(oldBack);		ResetOldFont(oldfont,oldSize);		SetClip(oldClip);		ZapRegion(oldClip);	 end;{----------------------------------------------------------------------------}	procedure RePlaceTemporaryText (myOffScreenWorld: GWorldPtr; offPixMapHandle:  PixMapHandle; offScreenbox,onScreenBox: Rect; wPort: CGrafPtr; tempP: WindowPtr);	 begin		ReplaceTemporaryPicture(myOffScreenWorld,wPort,offScreenbox,onScreenBox,tempP,offPixMapHandle)	;		 end;{----------------------------------------------------------------------------}	procedure PlacePictureWhileButtonDown (thePicture: PicHandle; wh: point);	 var		origPort: CGrafPtr;		origDevice:GDHandle;		myErr: QDErr;		myOffScreenWorld: GWorldPtr;		offPixMapHandle:  PixMapHandle;		good:  Boolean;		j: integer;		offScreenbox,onScreenBox: Rect;		//oldImageBoxToStore: Rect;		globalwh: point;		horadjust,vertadjust: integer;		wPort: CGrafPtr;		tempP: WindowPtr;		//whLocal: point;		whGlobal: point;	 begin		if thePicture=nil then			Exit(PlacePictureWhileButtonDown);		genericGetPort(tempP);		//whLocal := wh;		offScreenBox := thePicture^^.picFrame;		onScreenBox := offScreenBox;		//oldImageBoxToStore := offScreenBox;{$IFC CARBON}		wPort :=myGetWindowPort(tempP);		OffSetRect(onScreenBox,wh.h,wh.v);		//OffSetRect(oldImageBoxToStore,whLocal.h,whLocal.v);{$ELSEC}		whGlobal := wh;		LocalToGlobal(whGlobal);  {if it is not Carbon, then we are using the whole screen's port, in which case we need to use global coordinates}		GetCWMgrPort(wPort);		OffSetRect(onScreenBox,whGlobal.h,whGlobal.v);		//OffSetRect(oldImageBoxToStore,whLocal.h-offScreenBox.left,whLocal.v-offScreenBox.top);		 if onScreenBox.bottom > ScreenBoundsRect.bottom - 2 then			OffSetRect(onScreenBox, 0, ScreenBoundsRect.bottom - onScreenBox.bottom - 2);		 if onScreenBox.top < ScreenBoundsRect.top + GetMBarHeight + 2 then  {+2 etc to keep well within screen bounds}			OffSetRect(onScreenBox, 0, ScreenBoundsRect.top + GetMBarHeight - onScreenBox.top);		 if onScreenBox.right > ScreenBoundsRect.right - 2 then			OffSetRect(onScreenBox, ScreenBoundsRect.right - onScreenBox.right - 2, 0);		 if onScreenBox.left < ScreenBoundsRect.left + 2 then		 	OffSetRect(onScreenBox, ScreenBoundsRect.left - onScreenBox.left + 2, 0);{$ENDC}		GetGWorld(origPort, origDevice); {save onscreen graphics port}		myErr := NewGWorld(myOffScreenWorld, 0, offScreenBox, NIL, NIL, 0); {create offscreen graphics world}		if (myOffScreenWorld = NIL) or (myErr <> noErr) then			Exit(PlacePictureWhileButtonDown); {handle errors here}		SetGWorld(myOffScreenWorld, NIL); {set current graphics port to offscreen}		offPixMapHandle := GetGWorldPixMap(myOffScreenWorld);		good := LockPixels(offPixMapHandle);{lock offscreen pixel map}		if not good then			; {handle errors here}		ClipRect(offScreenBox);		EraseRect(offScreenBox); {clear offscreen pixel map}{copy current image to offscreen bitmap}		myPortCopyBits(cGrafPtr(wPort),cGrafPtr(myOffScreenWorld), onScreenBox,{myOffScreenWorld^.portRect}offscreenBox, patcopy, NIL);		SetGWorld(origPort, origDevice); {restore onscreen graphics port}		genericSetPort(myGetWindowFromPort(wPort));		ClipRect(ScreenBoundsRect);  {drawPicture into onscreen}		DrawPicture(thePicture,onScreenBox);		repeat 		until not StillDown;					{once button is released, copy old current image down}		myPortCopyBits(cGrafPtr(myOffScreenWorld),cGrafPtr(wPort),{myOffScreenWorld^.portRect} offscreenbox, onScreenBox, patcopy, NIL);		genericSetPort(tempP);		UnlockPixels(offPixMapHandle);		DisposeGWorld(myOffScreenWorld);	end;{----------------------------------------------------------------------------}	function StringLines(ds: str255; width: integer): integer;{this calculates how many lines the string menu will be if the long string is broken up over multiple}{lines, such that width of line is width.    }{Note that this uses TextEdit to calculate number of lines, whereas actual drawing used }{TETextBox}		var			tport: WindowPtr;			box: rect;			stringTE: TEHandle;	begin		SetRect(box, 0, 0, width, 1000);		stringTE := TENew(box, box);		TESetText(Pointer(ord4(@ds) + 1), length(ds), stringTE);		TECalText(stringTE);		StringLines := stringTE^^.nlines;		TEDispose(stringTE);	end;{----------------------------------------------------------------------------}	procedure PlaceTextPtrWhileButtonDown (P: Ptr; textLength: integer; wh: point; widest, numLines: integer);	 var		box: rect;		picH: PicHandle;		lastj, width,height,j,linewidth: integer;		ds: str255;		oldBack: RGBColor; 		oldClip: RgnHandle;	begin			{Visible Length}		 	oldClip := NewRgn;	 	GetClip(oldClip);		TextFace([]);		width := widest + leadingSpaceForPopupNotes + frameThicknessForPopupNotes*2 +trailingSpaceForPopupNotes+2;		height := FontHeight * numlines + frameThicknessForPopupNotes*2+2;		SetRect(box,0,0,width,height);		ClipRect(box);		picH := OpenNewPicture(box);		GetRGBSetTingeBackground (oldBack, yellowTinge);		EraseRect(box);		PenSize(frameThicknessForPopupNotes,frameThicknessForPopupNotes);		FrameRect(box);		PenNormal;		InsetRect(box,frameThicknessForPopupNotes,frameThicknessForPopupNotes);		box.right := box.right-trailingSpaceForPopupNotes;		box.left := box.left+leadingSpaceForPopupNotes;		TETextBox(P, textLength, box, teJustLeft);		RGBBackColor(oldBack);		ClosePicture;				PlacePictureWhileButtonDown(picH,wh);		ZapHandle(picH);		SetClip(oldClip);		ZapRegion(oldClip);	end;{----------------------------------------------------------------------------}	procedure PlaceTextWhileButtonDown (theString: str255; wh: point; useMonaco: boolean);	const		maxLineWidth = 150;	 var		box: rect;		numlines, widest,lastj, width,height,j,linewidth: integer;		ds: str255;		oldfont, oldsize: integer;	 begin		if useMonaco then			SetMonaco9(oldfont,oldSize)		else			SetGeneva9(oldfont,oldSize);		TextFace([]);		numlines := 1;		widest := 0;		lastj := 0;		if pos(chr(13), theString) > 0 then			begin				TextFace([bold]);				for j := 1 to length(theString) do					if theString[j] = chr(13) then						begin							numlines := numlines + 1;							ds := Copystring(theString, lastj + 1, j - 1 - lastj);							linewidth := StringWidth(ds);							if linewidth > widest then								widest := linewidth;							lastj := j;							TextFace([]);						end;				ds := Copystring(theString, lastj + 1, length(theString));			end		else			ds := theString;		linewidth := StringWidth(ds);		if linewidth > widest then			widest := linewidth;		if (numlines = 1) & (widest > maxLineWidth) then  			begin				widest := maxLineWidth;				numlines := StringLines(ds,widest);			end;				PlaceTextPtrWhileButtonDown ( Pointer(ord4(@theString) + 1), length(theString), wh,widest,numLines);		ResetOldFont(oldfont,oldSize);	 end;{----------------------------------------------------------------------------}	procedure PlaceTextHandleWhileButtonDown (H: Handle; wh: point);	 var		numlines, widest,j, height: integer;		lineLength: longint;		TE: TEHandle;		box: rect;		oldState: SignedByte;		oldfont, oldsize: integer;	 begin		SetGeneva9(oldfont,oldSize);		TextFace([]);		SetRect(box,0,0,ScreenBoundsRect.right - ScreenBoundsRect.left - 50,20000);		TextFace([]);		TE := TENew(box, box);		TESetText(Pointer(GetMaster(H)), GetHandleSize(H), TE);		TECalText(TE);		height := TEGetHeight(1,1,TE);		numlines := TE^^.nLines;				LockHandle(H,oldstate);		widest := 0;		for j := 1 to numLines do			begin				lineLength := TextWidth(Ptr(GetMaster(H)), TE^^.lineStarts[j-1], TE^^.lineStarts[j]-TE^^.lineStarts[j-1]);				if lineLength > widest then					widest := linelength;			end;		ResetHandle(H,oldstate);				if widest > (ScreenBoundsRect.right - ScreenBoundsRect.left) div 2 then			widest := (ScreenBoundsRect.right - ScreenBoundsRect.left) div 2;					PlaceTextPtrWhileButtonDown (Pointer(GetMaster(H)), GetHandleSize(H),wh,widest+5,numLines);		TEDispose(TE);  		ResetOldFont(oldfont,oldSize);	 end;{----------------------------------------------------------------------------}	procedure PlaceFramedPictureWhileButtonDown (thePicture: PicHandle; wh: point);	const		spacer = 4;		frameThickness=1;	 var		box,drawpicbox: rect;		picH: PicHandle;		oldBack: RGBColor; 		oldClip: RgnHandle;	 begin	 	oldClip := NewRgn;	 	GetClip(oldClip);		box := thePicture^^.picFrame;		drawpicbox := box;		OffSetRect(drawpicbox,-drawpicbox.left,-drawpicbox.top);		OffSetRect(drawpicbox,frameThickness+spacer,frameThickness+spacer);		InsetRect(box,-(frameThickness+spacer),-(frameThickness+spacer));		OffSetRect(box,-box.left,-box.top);				ClipRect(box);		picH := OpenNewPicture(box);		GetRGBSetTingeBackground (oldBack, yellowTinge);		EraseRect(box);		PenSize(frameThickness,frameThickness);		FrameRect(box);		PenNormal;		DrawPicture(thePicture,drawpicbox);		RGBBackColor(oldBack);		ClosePicture;				PlacePictureWhileButtonDown(picH,wh);		ZapHandle(picH);		SetClip(oldClip);		ZapRegion(oldClip);	 end;{----------------------------------------------------------------------------}	procedure SetTELineWidthDescent(theTE: TEHandle; linewidth, descent, ascent: integer);	begin		theTE^^.lineheight := lineWidth;		theTE^^.FontAscent := ascent;	end;{----------------------------------------------------------------------------}	procedure CalcLineWidthDescent(theTE: TEHandle; theFont: integer; var linewidth, descent, ascent: integer);		var			info: FontInfo;			largeLetterNudge, extraAscent: integer;	begin		GetFontInfo(info);		if theFont = macCladeSmall then   {font specification is missing some ascent}			extraAscent := 2		else			extraAscent := 0;		lineWidth := info.ascent + info.descent + 2 + extraAscent;   		if lineWidth <= 16 then			largeLetterNudge := 0		else			largeLetterNudge := 1;    {nudge larger fonts down one pixel}		{lineWidth := TEGetHeight(1,1,theTE);}		descent := info.descent + 1 - largeLetterNudge;		ascent := info.ascent + largeLetterNudge + extraAscent;		SetTELineWidthDescent(theTE,linewidth,descent,ascent);	end;{----------------------------------------------------------------------------}	procedure ShadeSelectedRectangle (box: rect);	 var		origPort: CGrafPtr;		currentWindow: WindowPtr;		origDevice:GDHandle;		weightColor: RGBColor;	 begin		//InvertRect(box);		if EmptyRect(box) then			Exit(ShadeSelectedRectangle);		GetGWorld(origPort, origDevice); 		//genericGetPort(currentWindow);		//origPort := myGetWindowPort(currentWindow);		OpColor(selectWeightColor);		//genericSetPort(myGetWindowFromPort(origPort));		//SetPortOpColor(CGrafPtr(selectOffScreenWorld),selectWeightColor);	//	myPortCopyBits(GrafPtr(selectOffScreenWorld)^.portBits,GrafPtr(origPort)^.portBits, selectOffScreenWorld^.portRect, box, blend, NIL);		myPortCopyBits(CGrafPtr(selectOffScreenWorld),CGrafPtr(origPort), selectOffScreenWorldBox, box, blend, NIL); end;{-----------------------------------------------------------------------------}	procedure DarkenRectangle (box: rect; darkness: integer);	var oldRGB: RGBColor;	begin		{PenMode(blend);		GetForeColor(oldRGB);		RGBForeColor(blackRGB);		PaintRect(box);		RGBForeColor(oldRGB);		PenNormal;}	end;{----------------------------------------------------------------------------}	function SelectionQueryRectangle: rect;	var box: rect;	begin		SetRect(box,myGetControlRect(editorHScroll).right, myGetControlRect(editorVScroll).bottom,WindowPortRect(editorWindow).right,myGetControlRect(editorHScroll).bottom+1);		SelectionQueryRectangle := box;	end;{-----------------------------------------------------------------------------}	procedure InvalidateSelectionQueryRectangle;	begin		InvalidateWindowRect(editorWindow, SelectionQueryRectangle, true);	end;{-----------------------------------------------------------------------------}	procedure InvalTaxonNames;{invalidates the area on the treewindow containing the taxon names}		var			box: rect;	begin		SetRect(box, 0, 0, visTWR.right, topmargin);		InvalidateWindowRect(treewindow,box,true);	end;{-----------------------------------------------------------------------------}	procedure EnableDisableItem (theMenu: MenuHandle; Item: integer; turnon: boolean);{enables or disables menu items}	begin{$IFC  ALWAYSENABLED}		myEnableItem(theMenu, item);{$ELSEC}		if turnon then			myEnableItem(theMenu, item)		else			myDisableItem(theMenu, Item);{$ENDC}	end;{-----------------------------------------------------------------------------}	procedure FillRestSymbols;{fills in symbols list beyond those stored in matrix}		var			numtofill: integer;{.......}		procedure tryaddc (c: char);			var				Lc: char;		begin			if (c >= 'A') and (c <= 'Z') then				Lc := char(ord(c) + 32)			else				Lc := c;			if (pos(c, symbols) = 0) & not (c in [missing, gap, orsep, andsep, matchchar]) & (pos(Lc, symbols) = 0) & not (Lc in [missing, gap, orsep, andsep, matchchar]) then				begin					symbols := concat(symbols, c);					numtofill := numtofill - 1;				end;		end;{.......}		procedure tryaddsymbols (startc, endc: char);			var				c: char;		begin			for c := startc to endc do				if (c <> 'I') and (c <> 'O') then   {I and O not used by default}					begin						tryaddc(c);						if numtofill = 0 then							leave;					end;		end;{.......}		procedure addrawsymb;   {tries to add symbols from default symbols list}			var				ls, j: integer;				ds: str255;		begin			ls := length(symbols);			ds := defSymbols;			for j := ls + 1 to 26 do				begin					tryaddc(ds[j]);					if numtofill = 0 then						leave;				end;		end;{.......}	begin		numtofill := maxstbitplusone - length(symbols);		if numtofill > 0 then			begin				if (numbytes = 2) or (length(symbols) <= 10) then					begin						addrawsymb;						if numtofill > 0 then							tryaddsymbols('0', '9');						if numtofill > 0 then							tryaddsymbols('A', 'Z');					end				else if numbytes = 4 then					begin						addrawsymb;						if numtofill > 0 then							tryaddsymbols('A', 'Z');						if numtofill > 0 then							tryaddsymbols('0', '9');					end;			end		else if numtofill < 0 then			symbols := CopyString(symbols, 1, maxstbitplusone);	end;{-----------------------------------------------------------------------------}	procedure DoBitSet;	begin		tcB := numbytes;		{# of bytes for states of 1 character of 1 taxon; 2 or 4}		maxbit := numbytes * 8 - 1;    {highest bit in setchars;  15 or 31}		mnsts := maxbit - 5; 			{max number of states per character; 10 or 26}		chsB := numbytes;				{# of bytes for set of all states of 1 character}		MSb := maxbit;   					{е missing data bit}		ERb := maxbit - 1; 				{е error data bit}		UCb := maxbit - 2;  				{е uncertain data bit}		GAb := maxbit - 3;  				{е gap data bit}		FTb := maxbit - 4;   				{е footnote present bit}		FPb := maxbit - 5;				{е footpict present bit}		maxstbit := mnsts - 1;		dollosize := maxstbit div 3;		maxstbitplusone := mnsts;	end;{----------------------------------------------------------------------------}	function MenuAvailable (theMenu: integer): boolean;	begin		MenuAvailable := GetMenuHandle(theMenu) <> nil;	end;{----------------------------------------------------------------------------}	procedure SetDirtyTree;	begin		dirtytree := true;		treename^^ := UnstoredLink;	end;{-----------------------------------------------------------------------------}	procedure ReplaceIfMinimumLong (var oldMin: longint; candidate: longint);	begin		if candidate < oldmin then			oldmin := candidate;	end;{-----------------------------------------------------------------------------}	procedure ReplaceIfMaximumLong (var oldMax: longint; candidate: longint);	begin		if candidate > oldMax then			oldMax := candidate;	end;{-----------------------------------------------------------------------------}	function IntegerMin (int1, int2: integer): integer;	begin		if int1 < int2 then			IntegerMin := int1		else			IntegerMin := int2;	end;{-----------------------------------------------------------------------------}	function IntegerMax (int1, int2: integer): integer;	begin		if int1 > int2 then			IntegerMax := int1		else			IntegerMax := int2;	end;{-----------------------------------------------------------------------------}	function FontHeight: integer;		var			info: FontInfo;	begin		GetFontInfo(info);		fontheight := info.ascent + info.descent + info.leading;	end;{|||||||||||||||||||||||||||||||    |||||||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	function StartUserLink (theChain: Integer): longint;  {0-based}	begin		StartUserLink := PreDefLinks[theChain];	end;{-----------------------------------------------------------------------------}	function EndUserLink (theChain: Integer): longint;	begin		EndUserLink := PreDefLinks[theChain] + UserLinks[theChain] - 1;	end;{-----------------------------------------------------------------------------}	function LinkNumOfUser (theChain: Integer; usernumber: longint): longint;	begin		LinkNumOfUser := usernumber + StartUserLink(theChain) - 1;	end;{-----------------------------------------------------------------------------}	function LinksInChain (theChain: Integer): longint;	begin		LinksInChain := PreDefLinks[theChain] + UserLinks[theChain];	end;{-----------------------------------------------------------------------------}	function LinkNumberFromInfoRow (theChain: Integer; theRow: longint): longint;	begin		LinkNumberFromInfoRow := theRow + PreDefLinks[theChain] - 1;	end;{-----------------------------------------------------------------------------}	function InfoRowFromLinkNumber (theChain: Integer; theLink: longint): longint;	begin		InfoRowFromLinkNumber := theLink - PreDefLinks[theChain] + 1;	end;{|||||||||||||||||||||||||||||||    |||||||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}	procedure CheckInflate;	begin		lengthinflate := 1;		if realwt then			lengthinflate := lengthinflate * WtInflate;		if realtypes then			lengthinflate := lengthinflate * TypeInflate;	end;{|||||||||||||||||||||||||||||||    |||||||||||||||||||||||||||||||||||}{-----------------------------------------------------------------------------}{-----------------------------------------------------------------------------}	procedure AddToGoListIfNotInGoMask (goAdd: goSet);{This is currently only called in StatsMenu}{    var goNumber: integer;}	begin		golist := golist + goadd * ([0..goMax] - Gomask);{$IFC FALSE}		for goNumber := 0 to goMax do			if (goNumber in goAdd) & not (goNumber in goMask) then				golist := golist + [goNumber];{$ENDC}	end;{-----------------------------------------------------------------------------}	procedure WtChangeGoList;{FROZEN 3.0}	begin		if countall in gomask then			Golist := golist + [resetlengthall]; {don't redo count, just redo sum with new weights}		if calcminlenall in gomask then			golist := golist + [resetminlengthall];		if calcmaxlenall in gomask then			golist := golist + [resetmaxlengthall];		if (brchangesall in gomask) and branchlengthsweighted then			golist := golist + [brchangesall];  {redo branchlengths only if branchlengthsweighted}		golist := golist + [ciall, riall, treelengthschart, Twotreeschart, TwoTreefiles]; {redo indices, & charts concerning treelength}		if (CWStepsShow = CWStepsSteps) then {redo steps charts if involve multiple characters}			begin				if sequencechart or positionchart or (CWTRees[CWChart] = CWCurrentTree) then					golist := golist + [stepschart, stepsAllchartmult];			end		else if not (CWStepsShow = CWStepsChanges) then			begin      			{redo CI/RI charts if involve grouping of character.}				if ((sequencechart and (catwid > 1)) or positionchart) then					golist := golist + [CIRIChart, CIRIAllChartMult];			end;	end;{-----------------------------------------------------------------------------}	procedure FixStateGoList;  {Golist reset on change in fixed state}{FROZEN 3.0}	begin		golist := golist + [reconstructi, changesIchart];	end;{-----------------------------------------------------------------------------}	procedure RearrangeTreeGoList; {Golist reset when tree rearranged but terminal taxa remain same}{FROZEN 3.0}	begin		golist := golist + (FullGotree + fullgochartone - taxaonlygos);	end;{-----------------------------------------------------------------------------}	procedure FullTreeOnScreenGoList;{FROZEN 3.0}	begin   {Golist reset when new tree or taxa added/subtracted}		golist := golist + FullGotree + fullgochartone;	end;{-----------------------------------------------------------------------------}	procedure ChangeTypesGolist;{FROZEN 3.0}	begin   {Golist reset when types changed}		Golist := golist + (FullGoTree + fullgochartone + fullgoChartmult - [statesichart, statesallchart, GOcontinuous]);	end;{-----------------------------------------------------------------------------}	procedure ChangeExclusionsGolist;{FROZEN 3.0}	begin   {Golist reset when character included excluded}		Golist := golist + (FullGotree + fullgochartone + fullgochartMult - igos - [gocontinuous]);		{i things cut out because if i is excluded Main Event Loop will catch it}	end;{-----------------------------------------------------------------------------}	procedure ChangeAcctranDeltranGoList;{FROZEN 3.0}	begin   {Golist reset when resolveoptions changed}		golist := golist + [reconstructi, changesIchart];	end;{-----------------------------------------------------------------------------}	procedure ChangeCodonsGolist;{FROZEN 3.0}	begin   {Golist reset when codon positions changed}		if CWTrees[CWChart] = CWCurrentTree then			golist := golist + [stepschart, stepsChgschart, CIRIchart]  {codon positionchart; redo calculations}		else			golist := golist + [stepsAllChartMult, stepsChgsAllChartMult, CIRIAllChartMult];    {codon positionchart; redo calculations}	end;{-----------------------------------------------------------------------------}	procedure ChangeStoredTreesGoList;{FROZEN 3.0}	begin		if charton & (CWTrees[CWChart] = CWStoredTrees) & not (CWChart in [CWCC2T, CWCC2TF]) then			golist := golist + fullgoChartMult;	end;{-----------------------------------------------------------------------------}	function PaintedBranches: boolean;	begin		PaintedBranches := (traceshown = traceDiscrete) or ((traceshown = traceAllChanges) and (summaryview = aspattern)) or (traceshown = traceContinuous);	end;{------------------------------------------------------}	function GenLessThan (a, b: longint): boolean;{returns true if a less than b}	begin{$IFC FALSE}		if (a = infinity) then			GenLessThan := false		else if (b = infinity) then			GenLessThan := true		else if a < b then			GenLessThan := true		else			GenLessThan := false;{$ENDC}		GenLessthan := (a <> infinity) & ((b = infinity) | (a < b));	end;{-----------------------------------------------------------------------------}	procedure pause;	begin		repeat		until not button;		repeat		until button;		repeat		until not button;	end;{----------------------------------------------------------------------------}	function ListCellSelected (theList: ListHandle; zero: boolean): point;{returns the cell coordinates of the first element in the list theList selected}{if zero is true, then it will return 0,0 as the point if none in list selected}{if zero is false, then it will return 0,-1 as the point if none in list selected}		var			cell: point;	begin		cell.v := 0;		cell.h := 0;		if not LGetSelect(true, cell, theList) then			if zero then				begin					cell.v := 0;					cell.h := 0;				end			else				begin					cell.v := -1;					cell.h := 0;				end;		ListCellSelected := cell;	end;{$IFC TRUE}{----------------------------------------------------------------------------}	procedure RestoreSystemFonts;	begin		TextFont(systemFont);		TextSize(0);		TextFace([]);	end;{----------------------------------------------------------------------------}	procedure DoSetLineWidth (num, den: integer);		const			SetLineWidth = 182;		type			widthHdl = ^widthPtr;			widthPtr = ^WidthPt;			widthPt = Point;		var			theWidth: widthHdl;	begin		theWidth := widthHdl(NewHandle(sizeOf(widthPt)));		theWidth^^.h := den;		theWidth^^.v := num;		PicComment(SetLineWidth, SizeOf(widthPt), Handle(theWidth));		ZapHandle(theWidth);	end;{----------------------------------------------------------------------------}	procedure GridLineTo (hor, ver: integer; darkLine: boolean);		var			thePen: PenState;	begin		PenNormal;		if printon or savepicton then			PenPat(QDBlack)		else if screenInColor then			begin				if darkLine then				 	RGBForeColor(blackRGB) 				 else				 	RGBForeColor(gridColor);			end		else			begin				GetPenState(thePen);				ForeColor(bluecolor);				if (thePen.pnLoc.h = hor) then  {line could disappear if QDltGray}					PenPat(QDGray)				else					PenPat(QDltGray);			end;		DoSetLineWidth(1, 4);		LineTo(hor, ver);		DoSetLineWidth(4, 1);		DoSetLineWidth(1, 1);		ForeColor(blackcolor);		PenNormal;	end;{----------------------------------------------------------------------------}{$ENDC}{$IFC FALSE}	procedure GridLineTo (hor, ver: integer);	begin		PenNormal;		if ScreenInColor & not printon then			begin				RGBForeColor(gridColor);			end		else			begin				ForeColor(bluecolor);				PenPat(QDltGray);			end;		PenSize(editorGridThickness,editorGridThickness);		LineTo(hor, ver);		ForeColor(blackcolor);		PenNormal;	end;{$ENDC}{-----------------------------------------------------------------------------}	function GrayScale (range, number: integer): RGBColor;	begin{$R-}		if (range <= number) or (range = 0) then			GrayScale := blackRGB		else			begin				GrayScale.red := TruncateValue(65535 * (1.0 * (range - number) / range));				GrayScale.green := TruncateValue(65535 * (1.0 * (range - number) / range));				GrayScale.blue := TruncateValue(65535 * (1.0 * (range - number) / range));			end;	end;{$IFC TINKERTOY}{-----------------------------------------------------------------------------}	function TinkerTree: boolean;	begin		TinkerTree := tinkerToy & PaintedBranches;	end;{$ENDC}{----------------------------------------------------------------------------}	function AnyFeet (theFoot: integer): boolean;	begin{    AnyFeet := GetHandleSize(footH[theFoot]) > 4;}		AnyFeet := numFeet[theFoot] > 0;	end;{----------------------------------------------------------------------------}	function calcMinActive: boolean;	begin		calcMinActive := calcCI or calcRI or calcRC or showminsteps;	end;{----------------------------------------------------------------------------}	function calcMaxActive: boolean;	begin		calcMaxActive := calcRI or calcRC or showmaxsteps;	end;{-----------------------------------------------------------------------------}	procedure CheckScreenRectangle;	begin		ScreenRectangle := ScreenBoundsRect;	end;{-----------------------------------------------------------------------------}	function FlashNonCodonsInEditor: boolean;	begin		FlashNonCodonsInEditor := (editorFlashMode=flashNonCodons) & nucleotides;	end;{-----------------------------------------------------------------------------}	function SomeCodePosPartToColor: boolean;	begin		SomeCodePosPartToColor := editorColorCodPosTitle | editorColorCodPosCells | editorColorCodPosNumbers;	end;{-----------------------------------------------------------------------------}	function SomePartitionPartToColor: boolean;	begin		SomePartitionPartToColor := editorColorPartitionTitle | editorColorPartitionCells | editorColorPartitionNumbers;	end;{-----------------------------------------------------------------------------}	procedure CreateCellBlock(var cellBlock: cellBlockPtr);	begin		cellBlock := CellBlockPtr(NewPtrClear(SizeOf(CellBlockRecord)));		cellBlock^.firstEdgeTSTSH := NewHandle(2);		cellBlock^.lastEdgeTSTSH := NewHandle(2);		cellBlock^.H := NewHandle(2);	end;{-----------------------------------------------------------------------------}	procedure DestroyCellBlock(var cellBlock: cellBlockPtr);	begin		ZapHandle(cellBlock^.firstEdgeTSTSH);		ZapHandle(cellBlock^.lastEdgeTSTSH);		ZapHandle(cellBlock^.H);		ZapPointer(cellBlock);	end;{-----------------------------------------------------------------------------}	procedure EmptyCellBlock(cellBlock: CellBlockPtr);	begin		HUnlock(cellblock^.H);		HUnlock(cellblock^.firstEdgeTSTSH);		HUnlock(cellblock^.lastEdgeTSTSH);		SetHandleSize(cellBlock^.H,2);		SetHandleSize(cellBlock^.firstEdgeTSTSH,2);		SetHandleSize(cellBlock^.lastEdgeTSTSH,2);		cellBlock^.ntax := 0;		cellBlock^.nchar := 0;		if (cellBlock=EWFindSequenceBlockP) & (editorFlashMode=flashFindSequence) then			editorFlashMode := flashOff;	end;	{-----------------------------------------------------------------------------}	function CellBlockHasData(cellBlock:CellBlockPtr): boolean;	begin		CellBlockHasData:= (cellBlock^.ntax+cellBlock^.nchar>0);	end;{-----------------------------------------------------------------------------}	function CellBlockHasDataOfLegalSize(cellBlock:CellBlockPtr): boolean;	begin		CellBlockHasDataOfLegalSize:= (cellBlock^.ntax > 0) & (cellBlock^.ntax <=numtaxa)&(cellBlock^.nchar>0)&(cellBlock^.nchar<=numchars);	end;{-----------------------------------------------------------------------------}	function CellBlockHasSingleTaxon(cellBlock:CellBlockPtr): boolean;	begin		CellBlockHasSingleTaxon:= (cellBlock^.ntax=1);	end;{-----------------------------------------------------------------------------}	function flashRNARCHasLegalOriginalBlock: boolean;	begin		flashRNARCHasLegalOriginalBlock:= (flashRNARCFirstChar > 0) & (flashRNARCLastChar > 0) & (flashRNARCLastChar < numChars) & (flashRNARCLastChar<>flashRNARCFirstChar)&(flashRNARCLastChar-flashRNARCFirstChar+1 < numchars) & (flashRNARCFirstTax > 0) & (flashRNARCLastTax <= numtaxa);	end;{-----------------------------------------------------------------------------}	function AAAutoTranslationVisible: boolean;	begin		AAAutoTranslationVisible := editorShowAAwithDNA & nucleotides & not editorTransposed;	end;{-----------------------------------------------------------------------------}	function AsArrowOnRCNumber(clickTaxon,clickChar,whichTool: integer): boolean;	var asArrow: boolean;	begin		asArrow :=(((clickChar=-1)|(clickTaxon=-1))&tool^[editorTools,whichTool].behaveAsArrowOnRCNumbers);		if clickTaxon = -1 then			asArrow :=asArrow | tool^[editorTools,whichTool].behaveAsArrowOnCharacterNumbers;		if clickChar =-1 then			asArrow :=asArrow | tool^[editorTools,whichTool].behaveAsArrowOnTaxonNumbers;		AsArrowOnRCNumber := asArrow;	end;{-----------------------------------------------------------------------------}	procedure ZeroSplitMulti;	begin		splitTaxonStart := 0;		splitTaxonEnd:=0;		splitCharacter:= 0;	end;{-----------------------------------------------------------------------------}	function ConsensusSequenceVisible: boolean;	begin		ConsensusSequenceVisible := (editorNumConsensusSequences>0) & editorShowConsensusSequences;	end;{----------------------------------------------------------------------------}	function ShadeCharacterSensitiveToCellChange: boolean;	begin		ShadeCharacterSensitiveToCellChange := (editorCharacterSetToShade = AllInvariantShadeCharSet) |  (editorCharacterSetToShade = AllGapsMissingShadeCharSet);	end;{----------------------------------------------------------------------------}	function ShadeCharacterSensitiveToIncExc: boolean;	begin		ShadeCharacterSensitiveToIncExc :=  (editorCharacterSetToShade = AllIncludedShadeCharSet) & (editorCharacterSetToShade = AllExcludedShadeCharSet);	end;{----------------------------------------------------------------------------}	function ShadeCharacterSensitiveToCodPos: boolean;	begin		ShadeCharacterSensitiveToCodPos :=  nucleotides & (editorCharacterSetToShade > AllDataTypesStandardShadeCharSet) & (editorCharacterSetToShade <=NucleotideStandardShadeCharSet);	end;{-----------------------------------------------------------------------------}	function UpdateAsSensitiveToFirstTaxonChange(it: integer): boolean;	begin		UpdateAsSensitiveToFirstTaxonChange := (it = 1) & (matchcharon | (editorColorCellsMode=editorColorCellsMatchFirst))	end;{-----------------------------------------------------------------------------}	function EditorCellsColored: boolean;	begin		EditorCellsColored := (editorColorCellsMode=editorColorCellsState) |  (editorColorCellsMode=editorColorCellsPurPyr) | (editorColorCellsMode=editorColorCellsAAState);	end;{-----------------------------------------------------------------------------}	function EditorCellsColoredByState: boolean;	begin		EditorCellsColoredByState := (editorColorCellsMode=editorColorCellsState) | (editorColorCellsMode=editorColorCellsPurPyr);	end;{-----------------------------------------------------------------------------}	function Consensus(consensusNumber: integer): ConsensusPtr;	var theConsensus: ConsensusPtr;		j : integer;	begin		theConsensus := editorConsensus;		if consensusNumber>1 then			for j := 1 to consensusNumber-1 do				if theConsensus <> nil then					theConsensus := theConsensus^.next;		Consensus := theConsensus;	end;{-----------------------------------------------------------------------------}	function AnyConsensusSelected: boolean;	var theConsensus: ConsensusPtr;		j: integer;	begin		AnyConsensusSelected:= false;		for j := 1 to editorNumConsensusSequences do			begin				theConsensus:= Consensus(j);				if (theConsensus<> nil) & theConsensus^.selected then					begin						AnyConsensusSelected := true;						leave;					end;			end;	end;{-----------------------------------------------------------------------------}	function GetDirectLinkH (theChain: Integer; theLink: longint): Handle;	begin		GetDirectLinkH := HdlPtr(GetMaster(strCHUNKs[thechain]) + HdlSize * ord4(thelink))^;	end;{----------------------------------------------------------------------------}	function LinkOffSet (linkH: Handle): integer;  {works on full links}	begin		LinkOffSet := IP(GetMaster(linkH))^;  {don't need to lock}	end;{-----------------------------------------------------------------------------}	procedure DrawSmallTriangle (pt: Point; theColor: RGBColor);		var			dR: RgnHandle;			oldColor: RGBColor;	begin		GetForeColor(oldColor);		RGBForeColor(theColor);		moveTo(pt.h, pt.v);		dR := NewRgn;		OpenRgn;		Line(6, 0);		Line(-3, 3);		Line(-3, -3);		CloseRgn(dR);		FillRgn(dR, QDBlack);		ZapRegion(dR);		RGBForeColor(oldColor);	end;{----------------------------------------------------------------------------}	function Locked(theFeature: integer): boolean;	begin{$IFC LOCKCONTROL}		if applyLockOnlyToRestrictedVersion | (theFeature=lockSaving) then			Locked := false		else{$ENDC}			case theFeature of					lockData:  Locked := dataLocked;					lockAssumptions: Locked := assumptionsLocked;					lockTrees: Locked := treesLocked;					lockSaving: Locked := savingLocked;					lockNexusBlocks: Locked := nexusBlocksLocked;					lockEditorDisplay: Locked := editorDisplayLocked;				otherwise					Locked := false;			end;	end;{----------------------------------------------------------------------------}	procedure SpinBeachBall;	begin		SetCursor(clockCursor);{$IFC POWERPC}//		SpinCursor(0);{$ELSEC}//		SetCursor(clockCursor);{$ENDC}	end;{----------------------------------------------------------------------------}{----------------------------------------------------------------------------}	procedure DoDeactivateControl(theControl: ControlRef);	begin		HiliteControl(theControl,255);	end;{----------------------------------------------------------------------------}	procedure DoActivateControl(theControl: ControlRef);	begin		HiliteControl(theControl,0);	end;{----------------------------------------------------------------------------}	function TicksAreColored: boolean;	begin		if not nucleotides & ((colorTicksClass = colorTicksCodPos)|(colorTicksClass = colorTicksTiTv)) then			colorTicksClass := colorTicksNone;		TicksAreColored := colorTicksClass <> colorTicksNone;	end;{----------------------------------------------------------------------------}	function TicksRequireBoxes: boolean;	begin		TicksRequireBoxes := TicksAreColored | showTickClass;	end;{----------------------------------------------------------------------------}	function TicksHaveLegend: boolean;	begin		TicksHaveLegend := TicksAreColored | showTickClass;	end;	{----------------------------------------------------------------------------}	function TicksVisible: boolean;	begin		TicksVisible := (traceshown=traceAllChanges)& (summaryView=asticks);	end;{----------------------------------------------------------------------------}	function TickNamesVisible: boolean;	begin		TickNamesVisible :=  (traceshown=traceAllChanges)& (summaryView=asticks) & not ticksNoNames;	end;{----------------------------------------------------------------------------}	function TransferTreesAvailable: boolean;	begin		TransferTreesAvailable := treeopen & not Locked(lockTrees)& infoOpen[treeinfo] & infoSomeSelected[treeinfo]& (UserLinks[treechain] > 0);	end;{----------------------------------------------------------------------------}	function OpenNewPicture(box: Rect): PicHandle;	const		cHRes = $00480000; {for 72 dpi}		cVRes = $00480000; {for 72 dpi}	var		myOpenCPicParams: OpenCPicParams;	begin		WITH myOpenCPicParams DO 			BEGIN				srcRect := box; {best rectangle for displaying this picture}				hRes := cHRes; {horizontal resolution}				vRes := cVRes; {vertical resolution}				version := - 2; {always set this field to -2}			END;		OpenNewPicture := OpenCPicture(myOpenCPicParams); {start creating the picture}	end;{FUNCTION GetControl32BitValue(theControl: ControlRef): SInt32;PROCEDURE SetControl32BitValue(theControl: ControlRef; newValue: SInt32);FUNCTION GetControl32BitMaximum(theControl: ControlRef): SInt32;PROCEDURE SetControl32BitMaximum(theControl: ControlRef; newMaximum: SInt32);FUNCTION GetControl32BitMinimum(theControl: ControlRef): SInt32;PROCEDURE SetControl32BitMinimum(theControl: ControlRef; newMinimum: SInt32);}{----------------------------------------------------------------------------}	FUNCTION GetControlValueLong(theControl: ControlRef): longint;	begin{$IFC CARBON}		if has32BitControlValues then			GetControlValueLong := GetControl32BitValue(theControl)		else{$ENDC}			GetControlValueLong := GetControlValue(theControl);	end;{----------------------------------------------------------------------------}	PROCEDURE SetControlValueLong(theControl: ControlRef; newValue: univ longint);	begin{$IFC CARBON}		if has32BitControlValues then			SetControl32BitValue(theControl, newValue)		else{$ENDC}			if newValue > maxCtlValue then				SetControlValue(theControl,maxCtlValue)			else				SetControlValue(theControl, newValue);	end;{----------------------------------------------------------------------------}	FUNCTION GetControlMaximumLong(theControl: ControlRef): longint;	begin{$IFC CARBON}		if has32BitControlValues then			GetControlMaximumLong := GetControl32BitMaximum(theControl)		else{$ENDC}			GetControlMaximumLong := GetControlMaximum(theControl);	end;{----------------------------------------------------------------------------}	PROCEDURE SetControlMaximumLong(theControl: ControlRef; newMaximum: univ longint);	begin{$IFC CARBON}		if has32BitControlValues then			SetControl32BitMaximum(theControl, newMaximum)		else{$ENDC}			if newMaximum > maxCtlValue then				SetControlMaximum(theControl,maxCtlValue)			else				SetControlMaximum(theControl, newMaximum);	end;{----------------------------------------------------------------------------}	FUNCTION GetControlMinimumLong(theControl: ControlRef): longint;	begin{$IFC CARBON}		if has32BitControlValues then			GetControlMinimumLong := GetControl32BitMinimum(theControl)		else{$ENDC}			GetControlMinimumLong := GetControlMinimum(theControl);	end;{----------------------------------------------------------------------------}	PROCEDURE SetControlMinimumLong(theControl: ControlRef; newMinimum: univ longint);	begin{$IFC CARBON}		if has32BitControlValues then			SetControl32BitMinimum(theControl, newMinimum)		else{$ENDC}			if newMinimum > maxCtlValue then				SetControlMinimum(theControl,maxCtlValue)			else				SetControlMinimum(theControl, newMinimum);	end;end.