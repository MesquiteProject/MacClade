unit CharStateTree;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, TypeUtil, CharUtil, TypeDLOGUtil, CsTreeUtil;	procedure DrawCSTree (shift: integer);	procedure UpDateCSTree;	procedure GetCSTree;	procedure CalcCleanCSTree;	procedure ScanCSTree (Event: EventRecord);	function TypeValid (var deletecell: point): boolean;{еееееееееееееееееееееее}implementation {е$S CharStateTree}{COMMENTS:}{character state trees stored as array of sets, the ith set containing the neighbors of i.}{Unnamed states are maxstate+1 through maxCS}{The highest unnamed state is supposed to be maxstar, but not clear that well updated}{----------------------------------------------------------}	procedure DrawCSTree (shift: integer);		var			ir, it: integer;	begin		ir := -1;		repeat			ir := ir + 1;			if not printon | (CurTypeHdl^^.nbors[ir] <> []) then				WriteNumInRect(ir, shift);		until (ir = maxCS) or ((CurTypeHdl^^.nbors[ir] = []) and (ir > maxstate));		for ir := 1 to maxCS do			for it := 0 to ir do				if it in CurTypeHdl^^.nbors[ir] then					DrawConnection(it, ir, shift);	end;{----------------------------------------------------------}	procedure UpdateCSTree;		var			dropB: rect;	begin		Penmode(patXOR);		textmode(srcXOR);		SetRect(dropB, AvailR.left + 1, AvailR.top + 1, AvailR.right - 2, AvailR.bottom - 2);		eraserect(dropB);		SetRect(dropB, paletteR.left + 1, paletteR.top + 1, paletteR.right - 2, paletteR.bottom - 2);		eraserect(dropB);		EraseRect(moveB);		EraseRect(joinB);		EraseRect(rrootB);		DropCursorH(handcurs, moveB.left + 5, moveB.top + 5, srcor);		DropCursor(linkcurs, joinB.left + 5, joinB.top + 5, srcor);		DropCursorH(tool^[treeTools,rerootT].curs, rrootB.left + 5, rrootB.top + 5, srcor);		FrameRect(moveB);		FrameRect(joinB);		FrameRect(rrootB);		if mode = movemode then			invertrect(moveB)		else if mode = join then			invertrect(JoinB)		else if mode = rerootmode then			InvertRect(rrootB);		DrawCSTree(0);		FrameShadowRect(paletteR);		FrameShadowrect(availr);		PenNormal;		textmode(srcOR);	end;{----------------------------------------------------------}	procedure CalcCleanCSTree;		var			ir, it, maxheight: integer;		procedure CalcStatelocs (iat, ifrom: integer);			label				1;			var				ir, firstdesc, lastdesc: integer;				nborsfound: set of 0..maxCS;		begin			nborsfound := [ifrom];			for ir := 0 to maxCS do				if ir in (CurTypeHdl^^.nbors[iat] - [ifrom]) then					begin						nborsfound := nborsfound + [ir];						if CurTypeHdl^^.nbors[ir] - [iat] <> [] then							begin								firstdesc := lastch;								altitude := altitude + 1;								if altitude > maxheight then									maxheight := altitude;								CalcStateLocs(ir, iat);								altitude := altitude - 1;								lastdesc := lastch;								setRect(crect[ir], AvailLeft + altitude * stspace, (firstdesc + lastdesc + stspace) div 2, AvailLeft + altitude * stspace + stsize, (firstdesc + lastdesc + stspace) div 2 + stsize);							end						else							begin								lastch := lastch + stspace;								SetRect(crect[ir], AvailLeft + altitude * stspace, lastch, AvailLeft + altitude * stspace + stsize, lastch + stsize);							end;						InPlay[ir] := true;						if nborsfound = CurTypeHdl^^.nbors[iat] then							goto 1;					end;1:		end;	begin		maxheight := 0;		lastch := firstch;		altitude := 1;		stspace := 30;		stsize := 22;		if root >= 0 then			begin				inPlay[root] := true;				CalcStateLocs(root, root);				if (maxheight + 1) * stspace > HtAvail then					begin						stspace := HtAvail div (Maxheight + 1);						stsize := stspace * 3 div 4;						if (stsize div 2) * 2 <> stsize then							stsize := stsize - 1;						if (stspace div 2) * 2 <> stspace then							stspace := stspace - 1;						maxheight := 0;						lastch := firstch;						altitude := 1;						CalcStateLocs(root, root);					end;				if lastch + stspace > WAvail + firstch then					begin						stspace := (WAvail) div ((lastch - firstch) div stspace + 1);						stsize := stspace * 3 div 4;						lastch := firstch;						altitude := 1;						CalcStateLocs(root, root);					end;				SetRect(crect[root], AvailLeft, (lastch + firstch + stspace) div 2, AvailLeft + stsize, (lastch + firstch + stspace) div 2 + stsize);			end;	end;{----------------------------------------------------------}	procedure ScanCSTree (Event: EventRecord);{This procedure is active when there has been a mousedown In Play or in Holding Area (palette) is touched on, to see what happens next}		var			ir, it, availroot: integer;			found, foundd, dropped: boolean;			wh, m2, pt: point;			hirect, dropbox: rect;{....}		function SpotsWaiting: integer;			var				it, spots: integer;		begin			spots := 0;			for it := maxstate + 1 to maxCS do				if not InPlay[it] then					spots := spots + 1;			SpotsWaiting := spots;		end;{....}	begin		wh := Event.where;		dropbox := AvailR;		InsetRect(dropBox, stsize div 2 + 1, stsize div 2 + 1);		Penmode(patXOR);		textmode(srcXOR);		ir := -1;		foundd := false;		repeat			ir := ir + 1;			if PtinRect(wh, crect[ir]) then {SPOT TOUCHED}				begin					foundd := true;					if ((mode = join) | (mode = disconnect)) & not (ShiftEvent(Event) & not CommandEvent(Event)) & not PtInRect(wh, PaletteR) then						begin  {MODE TO CONNECT/DISCONNECT}							if InPlay[ir] then								begin									invertoval(crect[ir]);									MOVETO(wh.h, wh.v);									m2 := wh;									dropped := false;									repeat   {DRAWING LINE WAITING TO SEE WHERE IT IS DROPPED}										repeat											GETMOUSE(pt);											if not button then												dropped := true;											CallWaitNextEventForDrawing;										until (m2.h <> pt.h) or (m2.v <> pt.v) or dropped;										moveto(m2.h, m2.v);										LINETO(wh.h, wh.v);										LINETO(pt.h, pt.v);										m2 := pt;									until dropped;									MOVETO(m2.h, m2.v);									LINETO(wh.h, wh.v);									LINETO(wh.h, wh.v);									it := -1;									found := false;									repeat  {DROPPED; NOW SEEING WHERE}										it := it + 1;										if PtInRect(pt, crect[it]) & (ir <> it) then  {DROPPED ON OTHER SPOT}											begin												if InPlay[it] & (ir in CurTypeHdl^^.nbors[it]) then													begin														DrawConnection(ir, it, 0);														TypeEdited(curTypeHdl);														CurTypeHdl^^.nbors[ir] := CurTypeHdl^^.nbors[ir] - [it];  {DISCONNECT}														CurTypeHdl^^.nbors[it] := CurTypeHdl^^.nbors[it] - [ir];													end												else if InPlay[it] & not AlreadyConnected(it, ir) then													begin														DrawConnection(ir, it, 0);														TypeEdited(curTypeHdl);														CurTypeHdl^^.nbors[ir] := CurTypeHdl^^.nbors[ir] + [it]; {CONNECT}														CurTypeHdl^^.nbors[it] := CurTypeHdl^^.nbors[it] + [ir];													end;												found := true;											end;									until (it = maxCS) or found;									invertoval(crect[ir]);								end						end					else if (mode = movemode) | (ShiftEvent(Event) & not CommandEvent(Event)) | PtInRect(wh, PaletteR) then						begin  {MODE TO MOVE SPOT}							invertoval(crect[ir]);							setrect(hirect, wh.h - (stsize div 2), wh.v - (stsize div 2), wh.h + (stsize div 2), wh.v + (stsize div 2));							frameoval(hirect);							m2 := wh;							dropped := false;							repeat								repeat									GETMOUSE(pt);									if not button then										dropped := true;									CallWaitNextEventForDrawing;								until (m2.h <> pt.h) or (m2.v <> pt.v) or dropped;								frameoval(hirect);								setrect(hirect, m2.h - (stsize div 2), m2.v - (stsize div 2), m2.h + (stsize div 2), m2.v + (stsize div 2));								frameoval(hirect);								m2 := pt;							until dropped;  {SPOT DROPPED}							frameoval(hirect);							invertoval(crect[ir]);							if PtInRect(pt, PaletteR) and not PtInrect(wh, PaletteR) then  {SPOT WAS DROPPED IN HOLDING AREA}								begin									if ir = root then										begin											it := 0;											availroot := -1;											repeat  {since root is put in away to holding area need to find new root}												it := it + 1;												if (it <> root) and Inplay[it] then													availroot := it;											until (it = maxCS) or (it in CurTypeHdl^^.nbors[root]);											if it in CurTypeHdl^^.nbors[root] then												availroot := it;											root := availroot;											TypeEdited(curTypeHdl);											CurTypeHdl^^.root := availroot;										end;									for it := 0 to maxCS do										if it in CurTypeHdl^^.nbors[ir] then											DrawConnection(ir, it, 0);									writeNumInRect(ir, 0);  {erasing old location}									if (ir < maxstate + 1) or (spotswaiting = 0) then										begin											DisconnectState(ir);											WriteNumInRect(ir, 0);  {placing in new location}										end									else										DisconnectState(ir);								end							else if PtInRect(pt, dropbox) then  {SPOT WAS DROPPED IN PLAY; should limit to just inside AvailR}								begin									for it := 0 to maxCS do										if it in CurTypeHdl^^.nbors[ir] then {ERASE OLD CONNECTIONS}											DrawConnection(ir, it, 0);									writeNumInRect(ir, 0);  {ERASE OLD SPOT}									if not InPlay[ir] then  {NEEDS TO MOVE TO FIELD}										begin											if ir > maxstate then												if spotswaiting > 1 then													writeNumInRect(ir, 0);  {put back OLD SPOT}											InPlay[ir] := true;											if root < 0 then												begin													root := ir;													TypeEdited(curTypeHdl);													CurTypeHdl^^.root := ir;												end;											if ir > CurTypeHdl^^.maxstar then												begin													TypeEdited(curTypeHdl);													CurTypeHdl^^.maxstar := ir;												end;										end;									crect[ir].top := pt.v - stsize div 2;									crect[ir].bottom := pt.v + stsize div 2;									crect[ir].left := pt.h - stsize div 2;									crect[ir].right := pt.h + stsize div 2;									writeNumInRect(ir, 0);									for it := 0 to maxCS do  {redraw connections in case was in play}										if it in CurTypeHdl^^.nbors[ir] then											DrawConnection(ir, it, 0);								end;						end					else if mode = rerootmode then  {Rerootmode now implemented}						begin							if not AllConnectedToRoot then								NewError(385, 0)							else								begin									writeNumInRect(root, 0);									writeNumInRect(ir, 0);									it := root;									root := ir;									CurTypeHdl^^.root := ir;									TypeEdited(curTypeHdl);									writeNumInRect(root, 0);									writeNumInRect(it, 0);									CalcCleanCSTree;									UpdateCSTree;								end;						end;				end;		until (ir = maxCS) or foundd;		PenNormal;		textmode(srcOR);	end;{----------------------------------------------------------------------------}	procedure GetCSTree;		var			ir: integer;	begin		for ir := 0 to maxCS do			begin				InPlay[ir] := false;				PlaceCRectInAvail(ir);			end;		root := CurTypeHdl^^.root;		CalcCleanCSTree;	end;{----------------------------------------------------------------------------}	function OnlyOneState: boolean;		var			jj: integer;			OnlyOne: boolean;	begin		OnlyOne := true;		for jj := 0 to maxCS do			if jj in CurTypeHdl^^.nbors[root] then				begin					OnlyOne := false;					leave;				end;		OnlyOneState := OnlyOne;	end;{----------------------------------------------------------------------------}	function TypeValid (var deletecell: point): boolean;		var			oktree, deleted, deleteit: boolean;			j, jj: integer;			nbor: neighbortype;			dist: distancetype;			mxs, mxstar, numin: integer;			legalset: largestsetchars;	begin		Setcursor(clockCursor);		oktree := true;		deletecell.h := 0;		deletecell.v := -1;		if not showmatrix then			begin				if curtypeHdl = GettypeHdl(ordered) then					oktree := true				else if (CurTypeHdl^^.root < 0) | OnlyOneState then					begin						if CurType in CurTypes then							deleteit := CWarning('Tree is empty or with one state AND type is in use. Do you wish to delete it?', 'Delete', 'Cancel')						else							deleteit := CWarning('Tree is empty or with one state. Do you wish to delete it?', 'Delete', 'Cancel');						if deleteit then							begin								TypeEdited(curTypeHdl);								SubtractType(CurType, true, deletecell);								oktree := true;							end						else							oktree := false;					end				else if not AllConnectedToRoot then					begin						if CWarning('Tree is not fully connected. Do you want MacClade to discard pieces not connected to root?', 'Discard', 'Cancel') then							begin								TypeEdited(curTypeHdl);								for j := 0 to maxCS do									if not AlreadyConnected(root, j) then										Disconnectstate(j);								CalcCleanCSTree;								InvalidateWindowRect(myGetWindowPtrForDialog(editTypeDialog),AvailR,false);								InvalidateWindowRect(myGetWindowPtrForDialog(editTypeDialog),paletteR,false);								nbor := CurTypeHdl^^.nbors;								mxstar := CurTypeHdl^^.maxstar;								NborToDistance(nbor, mxstar, dist, mxs, legalset);								TypeEdited(curTypeHdl);								CurTypeHdl^^.dist := dist;								CurTypeHdl^^.max := mxs;								CurTypeHdl^^.setdefined := legalset;								oktree := true;							end						else							oktree := false;					end				else  {now check to see if any unnamed states are terminal}					begin						repeat							deleted := false;							for j := maxstate + 1 to maxCS do								begin									numin := 0;									if j <> root then										for jj := 0 to maxCS do											if jj in CurTypeHdl^^.nbors[j] then												numin := numin + 1;									if (numin = 1) then										begin											if oktree then												InstantError(253);											DisconnectState(j);											deleted := true;											oktree := false;										end;								end;						until not deleted;						if Oktree then							begin								nbor := CurTypeHdl^^.nbors;								mxstar := CurTypeHdl^^.maxstar;								NborToDistance(nbor, mxstar, dist, mxs, legalset);								TypeEdited(curTypeHdl);								CurTypeHdl^^.dist := dist;								CurTypeHdl^^.max := mxs;								CurTypeHdl^^.setdefined := legalset;							end						else							begin								CalcCleanCSTree;								InvalidateWindowRect(myGetWindowPtrForDialog(editTypeDialog),AvailR,false);								InvalidateWindowRect(myGetWindowPtrForDialog(editTypeDialog),paletteR,false);							end;					end;			end;		SetCursorToArrow;		TypeValid := oktree;	end;end.