unit TraceControl;{본본본본본본본본본본본볗interface	uses		QuickDraw, Printing,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, BoxUtil, CharUtil, TaxonCHUtil, {SetStates,}		Prohibitions, StrUtil, TreeUtil, TypeUtil, Legends, BranchListWindow, InfoWindows, {Calc, Genchar, }		MenuUtil, coloring; {Count, Coloring}	procedure ReSetGoMask;	procedure TurnOnTrace (oldi, ic: integer);	procedure TurnOfftrace (ic: integer; doerase, dosetclip, reallyoff: boolean);	procedure TurnOffShowChg (hideChLeg: boolean);	procedure TurnOffAllStates;	procedure TurnOffContinuous (doerase: boolean);{$IFC PROBRECONSTRUCT}	procedure TurnOffProbReconstruct;{$ENDC}	procedure TurnOnShowChanges;	procedure SetOnOffCount (turnon: boolean);	procedure AcctranDeltranDLOG;	procedure SetColorTicksGoList;{본본본본본본본본본본본볗implementation{-----------------------------------------------------------------------------}	procedure ReSetGoMask; {츻{FROZEN 3.0}{gomask and golist are MacClade's event posting system for calculations.}{Both are sets, each element referring to a particular sort of calculation}{In general the gomask contains all the elements that are currently in use, sort of like}{a visRgn. A few elements (see first line of this procedure) are always in the gomask,}{and are things done on demand in special circumstances.}{The golist contains the calculations which may need to be redone because of }{a change in tree, characters, weights, types, etc.  By putting an element in the}{golist, one is asking for the calculation be updated as long as it is in the gomask,}{like setting the updateRGN.}	begin		gomask := [resetlengthall..reconstructi2] + [settaxdnall];		if count then			gomask := gomask + [countall];		if calctreechanges then			gomask := gomask + [countall, reconstructall, changesall];		if CalcCi then			gomask := gomask + [countall, calcminlenall, ciall];		if CalcRI then			gomask := gomask + [countall, calcminlenall, calcmaxlenall, riall];		if CalcRC then			gomask := gomask + [countall, calcminlenall, calcmaxlenall, riall, ciall];		if showminsteps then			gomask := gomask + [calcminlenall];		if showmaxsteps then			gomask := gomask + [calcmaxlenall];		if (traceshown = traceAllChanges) then			begin				gomask := gomask + [countall, reconstructall, brchangesall];{$IFC COLORTICKS}				if (colorTicksClass=colorTicksIndex) then					begin						gomask := gomask + [calcminlenall];						if colorTicksIndexClass in [colorTicksCI, colorTicksRC] then							gomask := gomask + [ciall];						if colorTicksIndexClass in [colorTicksRI, colorTicksRC] then							gomask := gomask + [calcmaxlenall, riall];					end;{$ENDC}			end;		if (traceshown = traceAllStates) then			gomask := gomask + [countall, reconstructall];		if (traceshown = traceDiscrete) then			gomask := gomask + [reconstructi];		if (traceshown = traceContinuous) then			gomask := gomask + [GOcontinuous];{$IFC PROBRECONSTRUCT}		if (traceshown = traceProbability) then			gomask := gomask + [goProbability];{$ENDC}		if charton then			case CWChart of				CWCCTAll: 					begin						gomask := gomask + [treelengthschart];					end;				CWCSteps: 					begin						case CWStepsShow of							CWStepsSteps: 								if CWTrees[CWChart] = CWCurrentTree then  {all chars, current tree}									gomask := gomask + [stepschart, countall]								else if sequencechart or positionchart then   {all chars, mult trees}									gomask := gomask + [stepsAllchartmult]								else									gomask := gomask + [stepsichartmult];  {traced char, mult trees}							CWStepsChanges: 								if CWTrees[CWChart] = CWCurrentTree then {all chars, current tree}									gomask := gomask + [stepsChgschart, countall, reconstructall, changesall]								else if sequencechart or positionchart then   {all chars, mult trees}									gomask := gomask + [stepsChgsAllchartmult]								else									gomask := gomask + [stepsChgsichartmult];  {traced char, mult trees}							CWStepsCI, CWStepsRI, CWStepsRC: 								if CWTrees[CWChart] = CWCurrentTree then {all chars, current tree}									begin										gomask := gomask + [CIRIchart, countall, calcminlenall];										if CWStepsShow in [CWStepsCI, CWStepsRC] then											gomask := gomask + [ciall];										if CWStepsShow in [CWStepsRI, CWStepsRC] then											gomask := gomask + [calcmaxlenall, riall];									end								else if sequencechart or positionchart then   {all chars, mult trees}									gomask := gomask + [CIRIAllchartmult]								else									gomask := gomask + [CIRIichartmult];  {traced char, mult trees}							otherwise								;						end;					end;				CWCChanges:   {Changes & Stasis chart}					begin						if CWTraced then							begin								if CWTrees[CWChart] = CWCurrentTree then									gomask := gomask + [ChangesIchart, reconstructi]								else									gomask := gomask + [ChangesIchartmult];							end						else							begin								if CWTrees[CWChart] = CWCurrentTree then									gomask := gomask + [ChangesAllchart, countall, reconstructall]								else									gomask := gomask + [ChangesAllchartMult];							end;					end;				CWCStates: 					begin						if CWTraced then							gomask := gomask + [statesichart]						else							gomask := gomask + [statesAllchart];					end;				CWCC2T: 					begin						gomask := gomask + [TwoTreesChart];					end;				CWCC2TF: 					begin						gomask := gomask + [TwoTreefiles];					end;{$IFC PROBSTEPCHART}				CWCProbSteps: 					begin						gomask := gomask + [goProbStepsChart];					end;{$ENDC}				otherwise					;			end;		SetInfoColumnIDShow(charinfo, CharInfoCI,calcCI);		SetInfoColumnIDShow(charinfo,CharInfoRI,calcRI);		SetInfoColumnIDShow(charinfo,CharInfoRC,calcRC);		SetInfoColumnIDShow(charinfo,CharInfosteps,count);		SetInfoColumnIDShow(charinfo,CharInfoChgs,calctreechanges);		SetInfoColumnIDShow(charinfo,CharInfoMin,showminsteps);		SetInfoColumnIDShow(charinfo,CharInfoMax,showmaxsteps);	end;{-----------------------------------------------------------------------------}	procedure TurnOfftrace (ic: integer; doerase, dosetclip, reallyoff: boolean);      {turns off character trace}		var			TaxonHdl: thdl;			ir: INTEGER;			tport: windowptr;			box: rect;			clenP: Lip;	begin		asteriskset := [];		genericGetPort(tport);		genericSetPort(treewindow);		Setcursor(clockCursor);		if reallyoff then			if (TWOrigin.h > RoomNeededOnRight) & (RoomNeededOnRight > 0) then				ZeroTreeOrigin;		if fixon then			OffFix(true);		ClipRect(visTWR);		traceshown := tracenothing;		curTrace := tracenothing;		StringToH('0', fixdataH);		InvalidateWindow(twmesswindow, false);{shownodenumbers}		if showtracelabels or (fixon and showfix) then			godraw := true;		if dosetclip then			DefineTWClip;		SetClip(TWClip);		if treeonscreen then			EraseBoxes;		if reallyoff then			if (currentTool[treeTools] = paintT) | (currentTool[treeTools] = statsTestT) | (currentTool[treeTools] = turpentineT) | (currentTool[treeTools] = queryT)| (currentTool[treeTools] = traceTickT)  then				SetTool(treeTools,arrowT);		if doerase and treeonscreen then			begin				myHideWindow(chlegWindow);				if IsTreeWindow(frontWindow) then					SelectTreeWindows;				penpat(QDBlack);				EraseChar(ScreenR);				tool^[treeTools,paintT].curs := emptybrush;				DropTool(treeTools,paintT);				DropTool(treeTools,statsTestT);				DropTool(treeTools,turpentineT);			end;		DimTool(treeTools,queryT);		DimTool(treeTools,traceTickT);		FixTreeShadingMenus;		ResetGoMask;		CheckToolKit(treeTools,statsTestT);		if reallyoff and (tiplabel = tipstate) then			InvalTaxonNames;		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	procedure TurnOffAllStates;		var			tport: WindowPtr;	begin		genericGetPort(tport);		genericSetPort(treewindow);		SetClip(TWClip);		traceshown := tracenothing;		if currentTool[treeTools] = queryT then			SetTool(treeTools,arrowT);		if BranchListon then			begin				genericSetPort(BranchListWindow);				CloseBranchListWindow;				genericSetPort(treewindow);			end;		DimTool(treeTools,queryT);		if treeonscreen then			EraseChar(ScreenR);		genericSetPort(tport);		FixTreeShadingMenus;		tool^[treeTools,queryT].enabled := false;		ResetGoMask;	end;{-----------------------------------------------------------------------------}	procedure TurnOffShowChg; {hideChLeg: boolean}	begin		TurnOffTickFlash;		myDisableItem(TWDisplayMHdl, BranchPatternsAndColorsItem);		if (TWOrigin.h > RoomNeededOnRight) & (RoomNeededOnRight > 0) then			ZeroTreeOrigin;		traceshown := tracenothing;		curTrace := tracenothing;		if (currentTool[treeTools] = queryT)|(currentTool[treeTools] = traceTickT) then			begin				SetTool(treeTools,arrowT);			end;		if hideChLeg then			begin				myHideWindow(chlegWindow);				if IsTreeWindow(frontWindow) then					SelectTreeWindows;				DropTool(treeTools,queryT);				DropTool(treeTools,traceTickT);			end;		if BranchListon then			begin				genericSetPort(BranchListWindow);				CloseBranchListWindow;				genericSetPort(treewindow);			end;{$IFC SHOWBRANCHLENGTHS}		if (summaryview in [asticks, asLengthNum]) | (showbranchlengths & squarebranches) then			godraw := true{$ELSEC}			if (summaryview in [asticks, asLengthNum]) then				godraw := true{$ENDC}			else				begin					DimTool(treeTools,queryT);					DimTool(treeTools,traceTickT);					DefineTWClip;					if treeonscreen then						EraseChar(screenR);				end;{    InvalidateWindow(tlegwindow, false);}		FixTreeShadingMenus;		ResetGoMask;	end;{-------------------------------------------------------------}{$IFC PROBRECONSTRUCT}	procedure TurnOffProbReconstruct;		var			tport: windowptr;	begin		genericGetPort(tport);		genericSetPort(treewindow);		if (TWOrigin.h > RoomNeededOnRight) & (RoomNeededOnRight > 0) then			ZeroTreeOrigin;		Setcursor(clockCursor);		traceshown := tracenothing;		curTrace := tracenothing;		gomask := gomask - [goProbability]; {get rid of prob reconstruct from gomask}		ClipRect(visTWR);		InvalidateWindow(twmesswindow, false);		DefineTWClip;		myHideWindow(chlegWindow);				if IsTreeWindow(frontWindow) then					SelectTreeWindows;		SetClip(TWClip);		penpat(QDBlack);		godraw := true;		genericSetPort(tport);		FixTreeShadingMenus;	end;{$ENDC}{-------------------------------------------------------------}	procedure TurnOffContinuous (doerase: boolean);		var			tport: windowptr;	begin		genericGetPort(tport);		genericSetPort(treewindow);		if (TWOrigin.h > RoomNeededOnRight) & (RoomNeededOnRight > 0) then			ZeroTreeOrigin;		Setcursor(clockCursor);		traceshown := tracenothing;		curTrace := tracenothing;		gomask := gomask - [GOcontinuous]; {get rid of continuous from gomask}		ClipRect(visTWR);		InvalidateWindow(twmesswindow, false);		DefineTWClip;		myHideWindow(chlegWindow);		if IsTreeWindow(frontWindow) then			SelectTreeWindows;		SetClip(TWClip);		penpat(QDBlack);		if showconttracelabels then			godraw := true		else if treeonscreen and doerase then			EraseChar(ScreenR);		genericSetPort(tport);		FixTreeShadingMenus;	end;{-------------------------------------------------------------------------}	procedure TurnOnTrace (oldi, ic: integer);		var			wastraceon: BOOLEAN;			it, ir: integer;			box: rect;			tport: WindowPtr;	begin		genericGetPort(tport);		SetCursor(clockCursor);		FixLostByUndo := false;		oldtracei := oldi;		i := ic;		SetControlValueLong(chlegScroll, i);		genericSetPort(treewindow);		wastraceon := (traceshown = traceDiscrete);		asteriskset := [];		if (traceshown = traceDiscrete) then			turnoffTrace(oldi, false, false, false);		if (traceshown = traceAllChanges) then			TurnOffShowChg(false)		else if (traceshown = traceAllStates) then			TurnOffAllStates		else if (traceshown = traceContinuous) then			TurnOffContinuous(true);{$IFC PROBRECONSTRUCT}		else if (traceshown = traceProbability) then			TurnOffProbReconstruct;{$ENDC}		traceshown := traceDiscrete;		curTrace := traceDiscrete;		if not wastraceon then			DefineTWClip;		OpenTraceMenus;		tool^[treeTools,queryT].enabled := true;		myEnableItem(TWDisplayMHdl, BranchPatternsAndColorsItem);{FROZEN 3.0}		golist := golist + igos; {trace is turned on so set igos items to do}		if TipLabel = TipState then			InvalTaxonNames;		SetControlMaximumLong(chlegScroll, numchars);		if not equivcycle and IsTreeWindow(frontwindow) and isforeground then			ShowControl(chlegScroll);		brushset := [];		tool^[treeTools,paintT].enabled := true;		tool^[treeTools,paintT].curs := emptybrush;		InvalidateTool(treeTools,queryT);		InvalidateTool(treeTools,paintT);		InvalidateTool(treeTools,statsTestT);		resetGomask;		CheckToolKit(treeTools,statsTestT);		genericSetPort(tport);		CheckPixelDepth(treewindow);		if infoOpen[charinfo] then InvalidateInfoWindow(charinfo);	end;{-----------------------------------------------------------------------------}	procedure SetColorTicksGoList;	begin		if colorTicksIndexClass = colorTicksCI then  			AddToGoListIfNotInGoMask([calcminlenall, ciall])		else if colorTicksIndexClass = colorTicksRI then			AddToGoListIfNotInGoMask([calcminlenall, riall, calcmaxlenall])		else if colorTicksIndexClass = colorTicksRC then			AddToGoListIfNotInGoMask([calcminlenall, ciall, riall, calcmaxlenall]);		resetGoMask;	end;{-----------------------------------------------------------------------------}	procedure TurnOnShowChanges;		var			ir: integer;			tempB: Boolean;			tport: windowptr;	begin		if (nullson | ancon) & ((branchlistmode = maxmode) | (branchlistmode = minmaxmode)) then			NewError(32, 0){$IFC FALSE}		else if ((branchlistmode = maxmode) | (branchlistmode = minmaxmode)) then {& (resolveOption <> Allpossible)}			NewError(338, 0){$ENDC}		else			begin				myEnableItem(TWDisplayMHdl, BranchPatternsAndColorsItem);				tool^[treeTools,queryT].enabled := true;				genericGetPort(tport);				genericSetPort(treewindow);				if not (traceshown = traceAllChanges) then					DefineTWClip;				genericSetPort(tport);{FROZEN 3.0}{$IFC COLORTICKS}				if (colorTicksClass=colorTicksIndex) then					SetColorTicksGoList;{$ENDC}				AddToGoListIfNotInGoMask([brchangesall, countall, reconstructall]);{send all show changes golist items not alreadyin effect}				setcursor(clockCursor);				if (traceshown = traceDiscrete) then					TurnoffTrace(i, true, false, true)				else if (traceshown = traceContinuous) then					TurnOffContinuous(true){$IFC PROBRECONSTRUCT}				else if (traceshown = traceProbability) then					TurnOffProbReconstruct{$ENDC}				else if (traceshown = traceAllStates) then					TurnOffAllStates;				traceshown := traceAllChanges;				curTrace := TraceAllChanges;				resetGomask;				CheckPixelDepth(treewindow);			end;	end;{-----------------------------------------------------------------------------}	procedure SetOnOffCount (turnon: boolean);	begin		count := turnon;		SETCURSOR(clockCursor);		if count then			begin				count := true;{FROZEN 3.0}				golist := golist + [countall]; {request to do count; Gomask reset below}			end		else			begin				Calctreechanges := false;				CalcRC := false;				CalcRI := false;				CalcCI := false;			end;		CheckCalcMenu;		ResetGoMask;  {This resets charinfo shows also}	end;{-----------------------------------------------------------------------------}	procedure AcctranDeltranDLOG;		var			theDialog: DialogPtr;			oldequiv: integer;			tempP: WindowPtr;			localItemHit: integer;{..............}		procedure CheckAcctranDeltranDLOG;		begin			ItemCheckMark(theDialog, 4, resolveoption = deltran);			ItemCheckMark(theDialog, 5, resolveoption = acctran);			ItemCheckMark(theDialog, 6, resolveoption = allpossible);		end;{..............}		procedure ADcheckProhib;		begin{$IFC FALSE}			if resolveOption <> Allpossible then				begin					if EquivocalCyclingNeeded then						begin							InstantError(339);{'ACCTRAN/DELTRAN are not allowed when equivocal cycling is needed'}							resolveOption := allpossible;						end					else if ((traceshown = traceAllChanges) & ((branchlistmode = maxmode) | (branchlistmode = minmaxmode))) then						begin							InstantError(340);{'ACCTRAN/DELTRAN are not allowed when trace all changes (maximum) is in use'}							resolveOption := allpossible;						end;					if resolveoption = allpossible then						CheckAcctranDeltranDLOG;				end;{$ENDC}		end;{..............}	begin		oldequiv := resolveoption;		StartDLOG(420, theDialog, tempP);		CheckAcctranDeltranDLOG;		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ADcheckProhib;			ModalDialog(nil, localItemHit);			if localItemHit in [4, 5, 6] then				begin					case localItemHit of						4: 							resolveoption := deltran;						5: 							resolveoption := acctran;						6: 							resolveoption := allpossible;						otherwise							;					end;					CheckAcctranDeltranDLOG;				end;		until localItemHit in [1, 2];		if localItemHit = 2 then			resolveoption := oldequiv		else if (resolveoption <> oldequiv) then{FROZEN 3.0}			ChangeAcctranDeltranGoList;		EnableDisableItem(TraceMHdl, EquivCycleItem, (traceshown = traceDiscrete) & (resolveoption = allpossible) & EquivocalLegal(screenR));		EnableDisableItem(TraceMHdl, NumberMPRsItem, (traceshown = traceDiscrete) & (resolveoption = allpossible) & EquivocalLegal(screenR));		EndDLOG(theDialog, tempP);	end;end.