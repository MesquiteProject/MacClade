unit TextTree;{еееееееееееееееееееееее}interface	uses		QuickDraw, Printing,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, 		Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, 		EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, SymbolsNames, CharUtil, MenuUtil, TreeUtil;	procedure TextTreeToClipBoard;{еееееееееееееееееееееее}implementation {е$S TextTree}  	const textTreeTaxonSpace = 1; 		textTreeBranchHeight = 3; 		 	var 	maxh: integer; 		rightmostvert, leftmostvert, hpos: integer; 		clipH: Handle;{-----------------------------------------------------------------------------}	procedure AssignLocs (N: NPtr);	begin		if (N <> screenR) then			begin {first, calculate node's location in window based on ancestor's}				if NodeSlantsRight(N) then  					N^.int2 := N^.anc^.int2 + textTreeTaxonSpace * (SizeofClade(N^.anc,true) - SizeofClade(N,true))				else					N^.int2 := N^.anc^.int2 - textTreeTaxonSpace * (SizeofClade(N^.anc,true) - SizeofClade(N,true));				N^.int1 := N^.anc^.int1;				if BranchExists(N) then  { Don't add if null}					begin						N^.int1 := N^.int1 + textTreeBranchHeight;						if PartOfPolytomy(N) then							N^.int1 := N^.int1 + textTreeBranchHeight;  {but add one if part of polytomy so not too short}					end;				if N^.int1 > maxh then					maxh := N^.int1;			end;		if NodeIsInternal(N) then  {if internal recurse up the tree}			begin				AssignLocs(N^.lf);				AssignLocs(N^.rt);			end;	end;{-----------------------------------------------------------------------------}	procedure AdjustLocs(baseN: Nptr);		var			leftmostvert: integer;	{..............}		procedure findLeftmost (N: NPtr);		begin			if NodeIsInternal(N) then  {if internal recurse up the tree}				findLeftmost(N^.lf)			else				leftmostvert := N^.int2;		end;	{..............}		procedure doadjust (N: NPtr);		begin			N^.int2 := N^.int2 + (1 - leftmostvert);			if NodeIsInternal(N) then  {if internal recurse up the tree}				begin					doadjust(N^.lf);					doadjust(N^.rt);				end {else N^.int1 := maxh;}		end;	{..............}		procedure findrightmost (N: NPtr);		begin			if NodeIsInternal(N) then  {if internal recurse up the tree}				findrightmost(N^.rt)			else				rightmostvert := N^.int2;		end;	{..............}	begin		FindLeftmost(baseN);		if leftmostvert <> 1 then			doadjust(baseN);		findrightmost(baseN);	end;{-----------------------------------------------------------------------------}	procedure CenterTextBranches(N: Nptr);	begin		if NodeIsInternal(N) then			begin				CenterTextBranches(N^.lf);				CenterTextBranches(N^.rt);				N^.int2 := firstNonNullLeft(N^.lf)^.int2+(firstNonNullRight(N^.rt)^.int2-firstNonNullLeft(N^.lf)^.int2) div 2;			end;	end;{-----------------------------------------------------------------------------}	procedure WriteToClipH (ds: str255);	begin		AppendToHandle(clipH, ds);	end;{-----------------------------------------------------------------------------}{-----------------------------------------------------------------------------}	function RightMostImmediateDescendantNode (N: NPtr): NPtr;{returns farthest right node among IMMEDIATE descendants of N}		var			rN: NPtr;	begin		if NodeIsInternal(N) then			begin				rN := N^.rt;				while not BranchExists(rN) and (NodeIsInternal(rN)) do					rN := rN^.rt;			end		else			rN := N;		RightMostImmediateDescendantNode := rN;	end;{-----------------------------------------------------------------------------}	function LeftMostImmediateDescendantNode (N: NPtr): NPtr;{returns farthest left node among IMMEDIATE descendants of N}		var			lN: NPtr;	begin		if NodeIsInternal(N) then			begin				lN := N^.lf;				while not BranchExists(lN) and (NodeIsInternal(lN)) do					lN := lN^.lf;			end		else			lN := N;		LeftMostImmediateDescendantNode := lN;	end;{-----------------------------------------------------------------------------}	procedure DoLine (vpos: integer);		var			firstBranchChar: str32;			nextinline: NPtr;			posnext: integer;			bl: integer;			branchChar: Char;			TextbranchRight, TextBranchHeight, branchPieces: integer;		{..............}		procedure FindNextInLine (N: NPtr);		begin			if BranchExists(N) then				begin					if N = screenR then						begin							if (vpos = N^.int2) & (hpos < N^.int1) then								begin									nextinline := N;									posnext := 1;								end						end					else if hpos <= NotNullAnc(N)^.int1 then						begin							if (NotNullAnc(N)^.int1 <= posnext) then								begin									if (vpos = N^.int2) then										begin											nextinline := N;											posnext := NotNullAnc(N)^.int1;										end									else if (((vpos > N^.int2) and (vpos < NotNullAnc(N)^.int2)) or ((vpos < N^.int2) and (vpos > NotNullAnc(N)^.int2))) then										begin											if (nextinline = nil) | not ((vpos = nextinline^.int2) & (NotNullAnc(N)^.int1 = posnext)) then {can't override a direct line up if equal}												begin													neXtinline := N;													posnext := NotNullAnc(N)^.int1;												end;										end								end;						end					else if (hpos <= N^.int1) and (vpos = N^.int2) then {just in case one was missed}						begin							nextinline := N;							posnext := NotNullAnc(N)^.int1;						end;				end;			if NodeIsInternal(N) then  {if internal recurse up the tree}				begin					FindNextInLine(N^.lf);					FindNextInLine(N^.rt);				end;		end; {FindNextInLine}{..............}		procedure WriteTextTreeLine (N: NPtr);			var				jj, interm: integer;				writelink: boolean;				ds: str255;				oldState: SignedByte;		begin{=======  root  =======}			if N = screenR then   {we are writing root of page}				begin					if (vpos = N^.int2) then						begin							for jj := hpos to N^.int1 - 1 do								WriteToClipH('=');							WriteToClipH('|');							hpos := N^.int1 + 1;						end				end{=======  not root  =======}			else if (vpos = N^.int2) then   {Wayne: this means what???}				begin					for jj := hpos to NotNullAnc(N)^.int1 - 1 do						WriteToClipH(' ');					if hpos < NotNullAnc(N)^.int1 then						hpos := NotNullAnc(N)^.int1;					writelink := false;					if NodeIsTerminal(N) then   {it is terminal on page, horizontal position}																			{of terminal is maxh}						TextbranchRight := maxh					else						TextbranchRight := N^.int1;			{it is internal, length of branch is int1, starting position of}																{branch on left is hpos}					TextBranchHeight := TextBranchRight - hpos;					hpos := TextbranchRight + 1;{==== Draw Branch ====}					branchChar := '=';					firstbranchChar := '|';					if N = RightMostImmediateDescendantNode(NotNullAnc(N)) then						firstBranchChar := '='					else if N = LeftMostImmediateDescendantNode(NotNullAnc(N)) then						firstBranchChar := '='					else if N^.int2 = NotNullAnc(N)^.int2 then						firstBranchChar := '=';					branchPieces := TextBranchHeight;					WriteToClipH(firstbranchchar);					branchpieces := branchpieces - 1;					for jj := 1 to branchPieces do						WriteToClipH(branchChar);{==== Draw Terminal Taxon name ====}					if NodeIsTerminal(N) then						begin							WriteToClipH(' ');  {this puts a blank space in front of every terminal taxon name}							WriteToClipH(TaxonName(N^.name));						end					else						WriteToClipH('|');				end			else if ((vpos > N^.int2) and (vpos < NotNullAnc(N)^.int2)) or ((vpos < N^.int2) and (vpos > NotNullAnc(N)^.int2)) then				begin					for jj := hpos to NotNullAnc(N)^.int1 - 1 do						WriteToClipH(' ');					WriteToClipH('|');					hpos := NotNullAnc(N)^.int1 + 1;				end		end; {WriteTextTreeLine}	begin		hpos := 1;		repeat			posnext := 30000;			nextinline := nil;			FindNextInLine(screenR);			if nextinline <> nil then				WriteTextTreeLine(nextinline);		until (nextinline = nil) or (errorflag);		WriteToClipH(chr(13));	end; {DoLine}{-----------------------------------------------------------------------------}	procedure WriteTextTreeToClipH;		var			j: integer;	begin		screenR^.int1 := textTreeBranchHeight + 3;		screenR^.int2 := (SizeofClade(screenR,true) * textTreeTaxonSpace) div 2 + textTreeTaxonSpace + 1;		maxh := 0;		AssignLocs(screenR);		AdjustLocs(screenR);		if centerSquareBranches then			CenterTextBranches(screenR);		WriteToClipH(chr(13));		for j := 1 to rightmostvert do			begin				DoLine(j);				if errorflag then					leave;			end;	end;{-----------------------------------------------------------------------------}	procedure TextTreeToClipBoard;		var			tempTE: TEHandle;			box: rect;	begin		SetCursor(clockCursor);		clipH := NewHandle(0);		WriteTextTreeToClipH;		SetRect(box, 0, 0, 10, 10);		tempTE := TENew(box, box);		TESetText(clipH^, GetHandleSize(clipH), tempTE);		TESetSelect(0, 32700, tempTE);		TECopy(tempTE);		TEDispose(tempTE);		scrapispict := false;		scraptextdirty := true;		ZapHandle(clipH);	end;{-----------------------------------------------------------------------------}end.