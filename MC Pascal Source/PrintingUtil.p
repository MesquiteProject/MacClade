unit PrintingUtil;{еееееееееееееееееееееее}interface	uses		Printing, QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, FixMath, Windows, 		Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, ErrorUtil, EventUtil, 		GenUtil, StrUtil,ReadWriteUtil, PMApplication;{$SETC PRINTSTAMP = TRUE}	const		printStampWidth = 14;	function PrepareDocument: boolean;	procedure GroupBegin;	procedure GroupEnd;		procedure EndPrint;	function StartPrinting(doValidate: boolean):boolean;	procedure CleanUpValidation;	procedure SetDefaultPrintRecord(warn: boolean);	procedure CalcPgSizes (var pgWidth, pgHeight: integer);	function CheckPrinterError(warn: boolean): boolean;	procedure PrintCancelOff;	function CurrentDrawingPortRect: Rect;	function CurrentDrawingPort: CGrafPtr;	function PrinterPortRect: rect;	function NoPrinterError: boolean;	function PrinterError : boolean;	procedure GetPrintPage;	procedure DoPageSetup;	function OpenPrinter(warn: boolean): boolean;	function OpenPrinterPage: boolean;	procedure ClosePrinterPage;	procedure ClosePrinter;	function ValidatePageFormat: OSStatus;	procedure ReadPrintRecordFromFileResource (fileSpec: FSSpec);	procedure SavePrintRecordToFileResource (fileSpec: FSSpec);	{$IFC PRINTSTAMP}	procedure DrawStampLine (box: rect; forDataMatrix: boolean);{$ENDC}	var		pg: longint;		firstPage, lastPage, numberOfPages: longint;		pgheight, pgwidth, laserLegBoxW, laserLegLineW, phylogap, printtreenumber: Integer;		pgVres, pgHres : double;		printPageR: RECT;		printerPort: CGrafPtr;		printerPort2: GrafPtr;		prePrinterPort, originalPrePrintingPort: CGrafPtr;		printCancelDialog: DialogPtr;		{$IFC PRINTSTAMP}		printStampLine: boolean;{$ENDC}		printDriverResFile: integer;				printerOSStatus: OSStatus;		{$IFC CARBON}		printPageFormat: PMPageFormat;		printSession: PMPrintSession;		printSettings: PMPrintSettings;{$ELSEC}		currentClassicPrinterPort: TPPrPortRef;{$ENDC}{еееееееееееееееееееееее}implementation {е$S PrintingUtil}	const kPrintRecordResourceID = 128;		kCarbonPageFormatResourceID=129;		kCarbonPrintSettingsResourceID=130;			var	adjustedPageRect: PMRect;{-----------------------------------------------------------------------------}	function AddHandleToResourceFork(H: Handle; theType: ResType; resID: integer; fileSpec: FSSpec; resFileNum: integer): boolean;	var resH: Handle;		db: boolean;	begin		resH := NewHandle(0);		CopyHandles(H, resH);		AddResource(resH, theType, resID, '');		if (ResError <> NoErr) then			begin				errorFlag := true;				ZapHandle(resH);    //  ok to use this as resH never added to resource map				NewError(419, 0);				CloseResFile(resFileNum);				if OSSuccessful(ResError) then					db := IOSuccessful(FlushVol(nil,fileSpec.vRefNum));				AddHandleToResourceFork := false;				Exit(AddHandleToResourceFork);			end;		ChangedResource(resH);		UpdateResFile(resFileNum);		ReleaseResource(resH);		AddHandleToResourceFork := true;	end;{-----------------------------------------------------------------------------}	function thePrinterError: OSStatus;	begin{$IFC CARBON}		thePrinterError := printerOSStatus;{$ELSEC}		thePrinterError := PRError;{$ENDC}	end;{$IFC CARBON}{-----------------------------------------------------------------------------}	function ResetPrintSettings: OSStatus;	begin		ResetPrintSettings := noErr;		if (printSettings <> kPMNoPrintSettings) then			begin				ResetPrintSettings := PMRelease(PMObject(printSettings));				printSettings := kPMNoPrintSettings;			end;	end;{-----------------------------------------------------------------------------}	function ResetPageFormat: OSStatus;	begin		ResetPageFormat := noErr;		if printPageFormat <> kPMNoPageFormat then			begin				ResetPageFormat := PMRelease(PMObject(printPageFormat));				printPageFormat := kPMNoPageFormat;			end;	end;{$ENDC}{-----------------------------------------------------------------------------}	function CheckPrinterError(warn: boolean): boolean;		var			ds: str255;	begin		CheckPrinterError := false;		case thePrinterError of			iPrSavPFil: 				if warn then InstantError(154);			iPrAbort: 				if warn then InstantError(155);			iMemFullErr: 				if warn then InstantError(156);			fnfErr:				if warn then InstantError(448);			noErr:				CheckPrinterError := true;			otherwise				begin					NumToString(thePrinterError, ds);					if warn then InstantErrorPlus(205, ds);				end;		end;		if treeopen then			godraw := true;	end;{-----------------------------------------------------------------------------}	function CurrentDrawingPortRect: Rect;	var curPort: CGrafPtr;		printerPixMapH: PixMapHandle;	begin		curPort := CurrentDrawingPort;		CurrentDrawingPortRect := GrafPortRect(curPort);	end;{-----------------------------------------------------------------------------}	function CurrentDrawingPort: CGrafPtr;	begin{$IFC CARBON}		CurrentDrawingPort := QDThePort;{$ELSEC}		CurrentDrawingPort := CGrafPtr(QDThePort);{$ENDC}	end;{-----------------------------------------------------------------------------}	function PrepareDocument: boolean;		begin		if (numberOfPages < lastPage) & (numberOfPages > 0) then			lastPage := numberOfPages;{$IFC CARBON}		if isMacOSX then			begin				printerOSStatus := PMSetFirstPage(printSettings, firstPage, false);				if (printerOSStatus=kPMNoError) then					printerOSStatus := PMSetLastPage(printSettings, lastPage, false);			end;		printerOSStatus := PMSessionBeginDocument(printSession, printSettings, printPageFormat);		PrepareDocument := (printerOSStatus=kPMNoError);{$ELSEC}		PrepareDocument:= true;{$ENDC}		end;{$IFC PRINTSTAMP}{-----------------------------------------------------------------------------}	procedure DrawStampLine (box: rect; forDataMatrix: boolean);		var			oldfont, oldsize, start: integer;			oldface: style;			ds: str255;			oldstate: SignedByte;			wh: point;	begin		start := box.top + 10;		oldfont := QDThePortTextFont;		oldsize := QDThePortTextSize;		oldface := QDThePortTextFace;		textfont(kFontIDGeneva);		textsize(9);		TextFace([]);		MoveTo(0, start);		LockHandle(filename, oldstate);		TextFace([bold]);		ds := filename^^;		if not forDataMatrix then			begin				DrawString(TimeStamp);				MoveTo(box.right - 30 - StringWidth(ds) - StringWidth(StringFromNum(pg)), start);			end;		DrawString(ds);		TextFace([]);		ResetHandle(filename, oldstate);{$IFC TRUE}		ds := StringFromNum(pg);		if forDataMatrix & printon then			MoveTo(0, start+12)		else			MoveTo(box.right - 10 - StringWidth(ds), start);		DrawString(ds);{$ENDC}		if forDataMatrix then			begin				start := box.top + editorTitlesWidth - 1;				PenSize(2, 2);				MoveTo(0, start);				LineTo(box.right, start);				if not grid then					LineTo(box.right, box.top);				PenSize(1, 1);			end		else			begin				MoveTo(0, start + 2);				LineTo(box.right, start + 2);				MoveTo(0, start + 4);				LineTo(box.right, start + 4);			end;		textfont(oldfont);		textsize(oldsize);		textface(oldface);	end;{$ENDC}{-----------------------------------------------------------------------------}	procedure PrintCancelOn;  	begin		printCancelDialog := GetNewDialog(PrintNoteID, nil, Pointer(-1));		CenterDLOG(printCancelDialog);		genericSetPort(myGetWindowPtrForDialog(printCancelDialog));		HLock(Handle(filename));		SetWTitle(myGetWindowPtrForDialog(printCancelDialog), filename^^);		HUnLock(Handle(filename));		myShowDialog(printCancelDialog);		DrawDialog(printCancelDialog);	end;{-----------------------------------------------------------------------------}	procedure GroupBegin;	begin		PicComment(picGrpBeg, 0, nil);	end;{-----------------------------------------------------------------------------}	procedure GroupEnd;	begin		PicComment(picGrpEnd, 0, nil);	end;{-----------------------------------------------------------------------------}	procedure CalcPgSizes (var pgWidth, pgHeight: integer);	begin		pgWidth := RoundValue(((printPageR.right) / (pgVres)) * 72) - 40;		pgHeight := RoundValue(((printPageR.bottom) / (pgVres)) * 72) - 20;	end;{-----------------------------------------------------------------------------}	procedure CleanUpValidation;	begin{$IFC CARBON}  		printerOSStatus := ResetPageFormat;		if printSession <> nil then			begin				printerOSStatus := PMRelease(PMObject(printSession));				printSession := nil;			end;{$ELSEC}{$ENDC}	end;{-----------------------------------------------------------------------------}	procedure PrintCancelOff;	begin{$IFC NOT CARBON}		DisposeDialog(printCancelDialog);		SetCursorToArrow;{$ENDC}	end;{-----------------------------------------------------------------------------}	function OpenPrinter(warn: boolean): boolean;	begin{$IFC CARBON}		OpenPrinter := true;    {don't need to OpenPrinter this in Carbon}{$ELSEC}		OpenPrinter := false;		PrOpen;		if CheckPrinterError(warn) then			begin				if not printDefaultsSet then					begin						if (printRecordH <> nil) then							begin								PrintDefault(printRecordH);								printerOK := CheckPrinterError(warn);								printDefaultsSet := printerOK;							end;						GetPrintPage;					end;				OpenPrinter := true;			end;{$ENDC}	end;{-----------------------------------------------------------------------------}	procedure ClosePrinter;	begin{$IFC NOT CARBON}		PrClose;{$ENDC}	end;{еееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее}{еееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее}{еееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее}{$IFC CARBON}  {-----------------------------------------------------------------------------}	function NoPrinterError: boolean;	begin		NoPrinterError := printerOSStatus=kPMNoError ;  	end;{-----------------------------------------------------------------------------}	function PrinterError: boolean;	begin		PrinterError := printerOSStatus<>kPMNoError ;  	end;{-----------------------------------------------------------------------------}	function OpenPrinterPage: boolean;	var 	pageRect: PMRect;			begin		GetPort(prePrinterPort);		printerOSStatus := PMSessionBeginPage(printSession, printPageFormat,adjustedPageRect);		if (printerOSStatus=kPMNoError) then			printerOSStatus := PMSessionGetGraphicsContext(printSession, CFStringCreateWithPascalString (nil, 'com.apple.graphicscontext.quickdraw', CFStringGetSystemEncoding), printerPort);		if (printerOSStatus=kPMNoError) then			SetPort(printerPort);		OpenPrinterPage :=  (printerOSStatus=kPMNoError);	end;{-----------------------------------------------------------------------------}	procedure ClosePrinterPage;		begin		SetPort(prePrinterPort);		printerOSStatus := PMSessionEndPage(printSession);	end;{-----------------------------------------------------------------------------}	procedure EndPrint;     	begin		printerOSStatus := PMSessionEndDocument(printSession);		printerOSStatus := ResetPrintSettings;		if (printSession<>nil) then			begin				printerOSStatus := PMRelease(PMObject(printSession));				printSession := nil;			end;		SetPort(originalPrePrintingPort);	end;{-----------------------------------------------------------------------------}	function ValidatePageFormat: OSStatus;	var		db: boolean;	begin		printerOSStatus := PMCreateSession(printSession);		if (printerOSStatus = noErr) then			if printPageFormat = kPMNoPageFormat then				begin					printerOSStatus := PMCreatePageFormat(printPageFormat);					if (printerOSStatus=kPMNoError) then						if (printPageFormat <> kPMNoPageFormat) then							begin								printerOSStatus := PMSessionDefaultPageFormat(printSession, printPageFormat);							end						else							printerOSStatus := kPMGeneralError;				end			else				printerOSStatus := PMSessionValidatePageFormat(printSession, printPageFormat,db);		if (printerOSStatus<>kPMNoError) then			CleanUpValidation;		ValidatePageFormat := printerOSStatus;	end;{-----------------------------------------------------------------------------}	procedure SetPrintJobName(localPrintSettings: PMPrintSettings);  	var	printJobName: CFStringRef;		ds: str255;			begin		HLock(Handle(filename));		ds := filename^^;		HUnLock(Handle(filename));		printJobName := CFStringCreateWithPascalString (nil, ds, CFStringGetSystemEncoding);		if printJobName <> nil then			begin				printerOSStatus := PMSetJobNameCFString(localPrintSettings, printJobName);				CFRelease(CFTypeRef(printJobName));			end;	end;{-----------------------------------------------------------------------------}	function StartPrinting(doValidate: boolean):boolean;     	var		//localPrintSettings: PMPrintSettings;		userClickedPrintButton: boolean;		colorMode: PMColorMode;	begin		GetPort(originalPrePrintingPort);		StartPrinting := false;		//printDriverResFile := CurResFile;		if doValidate then			printerOSStatus := ValidatePageFormat;  {validates format and creates printSession and printPageFormat}		if CheckPrinterError(true) then			begin				GetPrintPage;								//PrintCancelOn(printCancelDialog);				//UseResFile(printDriverResFile);								printSettings := kPMNoPrintSettings;								printerOSStatus := PMCreatePrintSettings(printSettings);				if ((printerOSStatus = kPMNoError) & (printSettings <> kPMNoPrintSettings)) then					begin						SetPrintJobName(printSettings);						printerOSStatus := PMSessionDefaultPrintSettings(printSession,printSettings);					end;								if isMacOSX then					begin						printerOSStatus := PMSetPageRange(printSettings, 1, kPMPrintAllPages);						printerOSStatus := PMSetFirstPage(printSettings, 1, false);						printerOSStatus := PMSetLastPage(printSettings, kPMPrintAllPages, false);					end;								if (printerOSStatus=kPMNoError) then					begin						printerOSStatus := PMSessionPrintDialog(printSession, printSettings, printPageFormat, userClickedPrintButton);						if (printerOSStatus= kPMNoError) & not userClickedPrintButton then							printerOSStatus := kPMCancel;						if (printerOSStatus<> kPMNoError) | (printerOSStatus =kPMCancel) then							begin								printerOSStatus := ResetPrintSettings;								if (printSession <> nil) then									begin										printerOSStatus := PMRelease(PMObject(printSession));										printSession := nil;									end;							end;					end;								if (printerOSStatus=kPMNoError) then					begin						printerOSStatus := PMGetColorMode(printSettings,colorMode);						if (printerOSStatus=kPMNoError) then							printerColorGrayScale := colorMode > kPMBlackAndWhite;						pg := 1;						SetCursor(clockCursor);						printerOSStatus:=kPMNoError;						//currentClassicPrinterPort := PrOpenDoc(printRecordH, nil, nil);					end;														if (printerOSStatus=kPMNoError) then					begin						numberOfPages := 0;						printerOSStatus := PMGetFirstPage(printSettings, UInt32(firstPage));						if (printerOSStatus=kPMNoError) then 							printerOSStatus := PMGetLastPage(printSettings, UInt32(lastPage));					end;				if (printerOSStatus=kPMNoError) then 					printerOSStatus := PMGetAdjustedPageRect(printPageFormat, adjustedPageRect);				if (printerOSStatus=kPMNoError) then 					begin						printPageR.top := RoundValue(adjustedPageRect.top);						printPageR.bottom := RoundValue(adjustedPageRect.bottom);						printPageR.left := RoundValue(adjustedPageRect.left);						printPageR.right := RoundValue(adjustedPageRect.right);					end;				StartPrinting := printerOSStatus=kPMNoError;			end;	end;{-----------------------------------------------------------------------------}	procedure SetDefaultPrintRecord(warn: boolean);	begin	//\\	end;{-----------------------------------------------------------------------------}	procedure GetPrintPage;     	var width, height: longint;		resolution: PMResolution;				pageRect: PMRect;	begin		pgVres := 72.0;		pgHres := 72.0;		SetRect(printPageR, 0, 0, 576, 720);		if printPageFormat <> kPMNoPageFormat then			begin				printerOSStatus := PMGetResolution(printPageFormat,resolution);				if printerOSStatus=kPMNoError then					begin						pgVres := resolution.vRes;						pgHres := resolution.hRes;					end;				printerOSStatus := PMGetAdjustedPageRect(printPageFormat,pageRect);				if printerOSStatus=kPMNoError then					begin						printPageR.top := RoundValue(pageRect.top);						printPageR.bottom := RoundValue(pageRect.bottom);						printPageR.left := RoundValue(pageRect.left);						printPageR.right := RoundValue(pageRect.right);						width := printPageR.right-printPageR.left;						height := printPageR.bottom-printPageR.top;						if (width < 5) | (height < 5) then 							begin								SetRect(printPageR, 0, 0, 576, 720);   								InstantErrorPlus(434, concat(StringFromNum(width),', ',StringFromNum(height)));							end;					end;			end;	end;{-----------------------------------------------------------------------------}	procedure DoPageSetup;	var 			userClickedOKButton: boolean;	begin		printerOK := false;		printerOSStatus := ValidatePageFormat;		if (printerOSStatus<> kPMNoError) then			Exit(DoPageSetup)		else			pageSetupChanged := true;				printerOSStatus := PMSessionPageSetupDialog(printSession, printPageFormat,userClickedOKButton);				if ((printerOSStatus=noErr) | (printerOSStatus = kPMNoError)) then			begin				if userClickedOKButton then					pageSetupChanged := true;				printerOK := true;			end;					if  printSession <> nil then			begin				printerOSStatus := PMRelease(PMObject(printSession));				printSession := nil;			end;					GetPrintPage;	end;{-----------------------------------------------------------------------------}	procedure ReadPrintRecordFromFileResource (fileSpec: FSSpec);     	var 	refnum,oldRefNum, theResult: integer;		resFileNum: integer;		prRecH: THPrint;		db: boolean;		os: OSStatus;		flattenFormat: Handle;		flattenSettings: Handle;	begin		oldRefNum := CurResFile;		resFileNum := FSpOpenResFile(fileSpec, fsRdPerm);		if (ResError=noErr) & (resFileNum<>-1) then			begin				UseResFile(resFileNum);				if (ResError=noErr) then					begin							flattenFormat := Get1Resource('SPRC',kCarbonPageFormatResourceID);						if (ResError=noErr) & (flattenFormat <> nil) then  // got print record successfully							begin								DetachResource(flattenFormat);    // detach format, so free to do as we wish with it								os := ResetPageFormat;								if (os=noErr) then									os := PMUnflattenPageFormat (flattenFormat, printPageFormat);							end;						flattenSettings := Get1Resource('SPRC',kCarbonPrintSettingsResourceID);						if (ResError=noErr) & (flattenSettings <> nil) then  // got print record successfully							begin								DetachResource(flattenSettings);    // detach settings, so free to do as we wish with it								os := ResetPrintSettings;								if (os=noErr) then									os := PMUnflattenPrintSettings (flattenSettings, printSettings);							end;					end;				CloseResFile(resFileNum);				if OSSuccessful(ResError) then					db := IOSuccessful(FlushVol(nil,fileSpec.vRefNum));				UseResFile(oldRefNum);			end;	end;{-----------------------------------------------------------------------------}	procedure SavePrintRecordToFileResource (fileSpec: FSSpec);    	label 1;	var 	refnum,oldRefNum, theResult: integer;		resFileNum: integer;		resH, res2H: Handle;		db: boolean;		os : OSErr;				flattenFormat: Handle;		flattenSettings: Handle;	begin		os := noErr;		flattenFormat := nil;		flattenSettings := nil;		if errorFlag | ((printPageFormat = kPMNoPageFormat) & (printSettings=kPMNoPrintSettings))  then			Exit(SavePrintRecordToFileResource);		if (printPageFormat <> kPMNoPageFormat) then			os := PMFlattenPageFormat (printPageFormat, flattenFormat);		if (os=noErr) & (printSettings <> kPMNoPrintSettings) then			os := PMFlattenPrintSettings (printSettings, flattenSettings);		if (os=noErr) then			begin				oldRefNum := CurResFile;				if FSpCreateResourceFork(fileSpec,'CLAD','TEXT') then					begin						resFileNum := FSpOpenResFile(fileSpec, fsRdWrPerm);						if (resFileNum = -1)   then							NewError(419, 0)						else							begin								UseResFile(resFileNum);								theResult := ResError;								if (flattenFormat<> nil) then									if not AddHandleToResourceFork(flattenFormat, 'SPRC', kCarbonPageFormatResourceID,fileSpec,resFileNum) then										goto 1;								if (flattenSettings<> nil) then									if not AddHandleToResourceFork(flattenSettings, 'SPRC', kCarbonPrintSettingsResourceID,fileSpec,resFileNum) then										goto 1;								CloseResFile(resFileNum);								if OSSuccessful(ResError) then									db := IOSuccessful(FlushVol(nil,fileSpec.vRefNum));								UseResFile(oldRefNum);							end;					end;			end;1:		ZapHandle(flattenFormat);		ZapHandle(flattenSettings);		end;{-----------------------------------------------------------------------------}{еееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее}{$ELSEC}         //Non-Carbon{-----------------------------------------------------------------------------}	function PrinterError: boolean;	begin		PrinterError := PrError<>NoErr;	end;{-----------------------------------------------------------------------------}	function NoPrinterError: boolean;	begin		NoPrinterError := PrError=NoErr;	end;{-----------------------------------------------------------------------------}	function OpenPrinterPage: boolean;	begin		PrOpenPage(currentClassicPrinterPort, nil);		OpenPrinterPage := PrError =NoErr;	end;{-----------------------------------------------------------------------------}	procedure ClosePrinterPage;	begin		PrClosePage(currentClassicPrinterPort);	end;{-----------------------------------------------------------------------------}	function ValidatePageFormat: OSStatus;	var		db: boolean;	begin		db := PrValidate(printRecordH);		ValidatePageFormat := NoErr;	end;{-----------------------------------------------------------------------------}	function StartPrinting(doValidate: boolean):boolean;	{this presumes the printer driver is open!}	var db:  boolean;		printerGraphPortVersion: integer;	begin		StartPrinting := false;		printDriverResFile := CurResFile;		if doValidate then			begin				db := PrValidate(printRecordH);				GetPrintPage;			end;		if CheckPrinterError(true) then			begin				PrintCancelOn;				UseResFile(printDriverResFile);				if PrJobDialog(printRecordH) then					begin						pg := 1;						DrawDialog(printCancelDialog);						SetCursor(clockCursor);						UseResFile(printDriverResFile);						currentClassicPrinterPort := PrOpenDoc(printRecordH, nil, nil);{From IM: "In what would be the rowBytes field of the BitMap record stored in the portBitsfield of a GrafPort record, a CGrafPort record has a 2-byte portVersion field inwhich the 2 high bits are always set. QuickDraw uses these bits to distinguishCGrafPort records from GrafPort records, in which the 2 high bits of therowBytes field are always clear."}							firstPage:= printRecordH^^.prJob.ifstPage;						lastPage:= printRecordH^^.prJob.ilstPage;						printerGraphPortVersion := CGrafPort(currentClassicPrinterPort^.gPort).portVersion;						printerColorGrayScale := BitTst(@printerGraphPortVersion,0);						StartPrinting := CheckPrinterError(true);					end;			end;	end;{-----------------------------------------------------------------------------}	procedure EndPrint;	var myStRec: TPPrStatus;		db: boolean;	begin		PrCloseDoc(currentClassicPrinterPort);		if (printRecordH^^.prJob.bjDocLoop = bSpoolLoop) & NoPrinterError then			PrPicFile(printRecordH, nil, nil, nil, @myStRec);		db := CheckPrinterError(true);	end;{----------------------------------------------------------------------------}	procedure GetPrintPage;	var width, height: longint;	begin		if printRecordH <> nil then			begin				pgVres := printRecordH^^.prInfo.iVRes;				pgHres := printRecordH^^.prInfo.iHRes;				printPageR := printRecordH^^.prInfo.rPage;				width := printPageR.right-printPageR.left;				height := printPageR.bottom-printPageR.top;				if (width < 5) | (height < 5) then 					begin						SetRect(printPageR, 0, 0, 576, 720);   {for Executor?}						InstantErrorPlus(434, concat(StringFromNum(width),', ',StringFromNum(height)));					end;			end		else			begin				pgVres := 72;				pgHres := 72;				SetRect(printPageR, 0, 0, 576, 720);			end;	end;{-----------------------------------------------------------------------------}	procedure DoPageSetup;	begin		if OpenPrinter(true) then			begin				if PrValidate(printRecordH) then					pageSetupchanged := true;				if CheckPrinterError(true) then					begin						if PrStlDialog(printRecordH) then							pageSetupChanged := true;						PrinterOK := true;					end;				ClosePrinter;			end		else			PrinterOK := false;				GetPrintPage;	end;{-----------------------------------------------------------------------------}	procedure SetDefaultPrintRecord(warn: boolean);	begin		if OpenPrinter(warn) then			ClosePrinter;	end;	{-----------------------------------------------------------------------------}	procedure ReadPrintRecordFromFileResource (fileSpec: FSSpec);	var 	refnum,oldRefNum, theResult: integer;		resFileNum: integer;		prRecH: THPrint;		db: boolean;	begin		oldRefNum := CurResFile;		resFileNum := FSpOpenResFile(fileSpec, fsRdPerm);		if (ResError=noErr) & (resFileNum<>-1) then			begin				UseResFile(resFileNum);				if (ResError=noErr) then					begin						prRecH := THPrint(Get1Resource('SPRC', kPrintRecordResourceID));   // get print record stored in file						if (ResError=noErr) & (prRecH <> nil) then  // got print record successfully							begin								DetachResource(Handle(prRecH));    // detach print record resource, so free to do as we wish with it								ZapHandle(printRecordH);								printRecordH := prRecH;							end;					end;				CloseResFile(resFileNum);				if OSSuccessful(ResError) then					db := IOSuccessful(FlushVol(nil,fileSpec.vRefNum));				UseResFile(oldRefNum);			end;	end;{-----------------------------------------------------------------------------}	procedure SavePrintRecordToFileResource (fileSpec: FSSpec);	var 	refnum,oldRefNum, theResult: integer;		resFileNum: integer;		resH: Handle;		db: boolean;		os : OSErr;	begin		if errorFlag | (printRecordH=nil) then			Exit(SavePrintRecordToFileResource);		oldRefNum := CurResFile;		if FSpCreateResourceFork(fileSpec,'CLAD','TEXT') then			begin				resFileNum := FSpOpenResFile(fileSpec, fsRdWrPerm);				if (resFileNum = -1)   then					NewError(419, 0)				else					begin						UseResFile(resFileNum);						theResult := ResError;						if not AddHandleToResourceFork(Handle(printRecordH),'SPRC', kPrintRecordResourceID,fileSpec, resFileNum) then							Exit(SavePrintRecordToFileResource);						CloseResFile(resFileNum);						if OSSuccessful(ResError) then							db := IOSuccessful(FlushVol(nil,fileSpec.vRefNum));						UseResFile(oldRefNum);					end;			end;		end;{$ENDC}  //non-Carbonend.