unit FlashUtil;{본본본본본본본본본본본볗interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, 		GenUtil;	procedure ZeroTickFlash;	procedure PaintTickFlash;	procedure TurnOnTickFlash;	procedure TurnOffTickFlash;		procedure FlashRect(flashRect: rect);	procedure FlashRegion(flashRgn: RgnHandle);	procedure FlashRegionNew;	procedure PaintFlash;	procedure ShowFlash;	procedure HideFlash;	procedure TurnOffFlash;	procedure TurnOnFlash;	procedure ZeroSplitFlash;	procedure FullTurnOffSplitMultiFlash;{본본본본본본본본본본본볗implementation{-----------------------------------------------------------------------------}	procedure ZeroTickFlash;	begin		SetRect(flashTickBox,0,0,0,0);		flashTickCharacter := 0;		flashTickN := subR;		flashTickOn := false;	end;{-----------------------------------------------------------------------------}	procedure PaintTickFlash;	var tPort: WindowPtr;	begin		if treeOpen then			begin				{PenMode(patXOR);				Penpat(dashpat);				PaintRect(flashTickBox);								PenNormal;}				genericGetPort(tport);				genericSetPort(treeWindow);				InvertRect(flashTickBox);				genericSetPort(tport);			end;	end;{-----------------------------------------------------------------------------}	procedure TurnOnTickFlash;	begin		if not flashTickOn then 			PaintTickFlash;		flashTickOn := true;	end;	{-----------------------------------------------------------------------------}	procedure TurnOffTickFlash;	begin		if flashTickOn then 			PaintTickFlash;		flashTickOn := false;	end;{-----------------------------------------------------------------------------}	procedure FlashRect(flashRect: rect);	const delaylength = 4;	var		 thePat: pattern;	begin		PenMode(patXor);		GetIndPattern(thePat, 128, 1);		PenPat(thePat);		PaintRect(flashRect);		delay(delaylength,ticks);		PaintRect(flashRect);		delay(delaylength,ticks);		GetIndPattern(thePat, 128, 2);		PenPat(thePat);		PaintRect(flashRect);		delay(delaylength,ticks);		PaintRect(flashRect);		PenNormal;		{InvertRgn(flashRgn);		Delay(8,ticks);		InvertRgn(flashRgn);}	end;{-----------------------------------------------------------------------------}	procedure FlashRegion(flashRgn: RgnHandle);	const delaylength = 4;	var		 thePat: pattern;	begin		PenMode(patXor);		GetIndPattern(thePat, 128, 1);		PenPat(thePat);		PaintRgn(flashRgn);		delay(delaylength,ticks);		PaintRgn(flashRgn);		delay(delaylength,ticks);		GetIndPattern(thePat, 128, 2);		PenPat(thePat);		PaintRgn(flashRgn);		delay(delaylength,ticks);		PaintRgn(flashRgn);		PenNormal;		{InvertRgn(flashRgn);		Delay(8,ticks);		InvertRgn(flashRgn);}	end;{-----------------------------------------------------------------------------}	procedure PaintFlash;	var tport: WindowPtr;		 thePat: pattern;		 oldClip: RgnHandle;	begin		if editorOpen then			begin				genericGetPort(tport);				genericSetPort(editorWindow);				oldClip:= NewRgn;				GetClip(oldClip);				SetEWClip(justdata);				SetClip(EWClip);				PenMode(patXor);				if curFlashPattern > maxFlashPattern then					curFlashPattern := 1;				if curFlashPattern > 0 then					GetIndPattern(thePat, 129, curFlashPattern);   				PenPat(thePat);				PaintRgn(theFlashRgn);				PenNormal;				SetClip(oldClip);				ZapRegion(oldClip);				genericSetPort(tport);			end;	end;{-----------------------------------------------------------------------------}	procedure EraseOldFlash;	begin		if editorOpen & (curFlashPattern > 0) & editorFlashOn & not flashHidden then				PaintFlash;	end;{-----------------------------------------------------------------------------}	procedure HideFlash;	begin		EraseOldFlash;		curFlashPattern := 0;		flashHidden := true;	end;{-----------------------------------------------------------------------------}	procedure ShowFlash;	begin		flashHidden := false;	end;{-----------------------------------------------------------------------------}	procedure TurnOffFlash;	begin		HideFlash;		editorFlashOn := false;	end;{-----------------------------------------------------------------------------}	procedure TurnOnFlash;	begin		flashHidden := false;	end;{-----------------------------------------------------------------------------}	procedure ZeroSplitFlash;	begin		splitCharacter := 0;		splitTaxonStart:= 0;		splitTaxonEnd := 0;	end;{-----------------------------------------------------------------------------}	procedure FullTurnOffSplitMultiFlash;	begin		if not flashHidden then			HideFlash;		editorFlashOn := false;		ZeroSplitFlash;	end;{-----------------------------------------------------------------------------}	procedure FlashRegionNew;	begin		if (TickCount-lastFlashTime > flashInterval)  & not flashHidden & IsEditorWindow(frontwindow) then			begin				editorFlashOn := true;				EraseOldFlash;						curFlashPattern := curFlashPattern+1;				if curFlashPattern > maxFlashPattern then					curFlashPattern := 1;									PaintFlash;				lastFlashTime := TickCount;			end;	end;end.