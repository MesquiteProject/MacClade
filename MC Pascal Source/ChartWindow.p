unit ChartWindow;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, 		EventUtil, GenUtil, BoxUtil, CharUtil, StrUtil, MenuUtil, TreeUtil, Settings, ColorPicker, 		TypeUtil, SymbolsNames, Shading, TaxonCHUtil, ChartWText, ChartWUtil, 		ChartWTable, ChartWHisto, ChartWScatter, TrackThumb;	procedure ChartWindowTitle;	procedure DrawChartWindow (boundary: rect);	procedure AdjustCWScrolls;	procedure CalcCWBoxes (boundary: rect);	procedure ScrollCWUpDown (whichControl: ControlRef; theCode: INTEGER);	procedure ScrollCW;	procedure ReDrawChartWindow;	procedure MouseInChartWindow (wh: point);	procedure DoChartShowMenu (ItemNo: integer);	procedure DoChartViewsMenu (ItemNo: integer);	procedure DoChartDisplayMenu (ItemNo: integer);{еееееееееееееееееееееее}implementation {е$S ChartWindow}{	type		onViewBtype = array[0..numChartViews] of Rect;	var		gridB, vertaxisB, horaxisB, minmaxB, PaintB, titleB: rect;		spotB, fontB: rect;		onViewB: onViewBtype;}{-----------------------------------------------------------------------------}	procedure chartwindowtitle;	begin		if cwtraced then			begin			end;		SetWTitle(ChartWindow, ChartTitle);	end;{-----------------------------------------------------------------------------}	procedure BarUser (theDialog: DialogPtr; itemNo: Integer);		var			box, halfBox: rect;			thepat: pattern;	begin		if (NumSpotBar(SpotBarSetToShow) = 1) then			thepat := pat[histopat]		else			thepat := QDBlack;		box := GetDLOGItemBox(theDialog, 9);		if ColorPort & nucleotides & CWScatterMultiColor & (CWChart = CWCChanges) then			begin				halfBox := box;				halfBox.right := halfbox.left + (box.right - box.left) div 2;				RGBForeColor(redRGB);				Fillrect(halfBox, thepat);				RGBForeColor(blueRGB);				halfbox.left := halfbox.right;				halfbox.right := box.right;				Fillrect(halfBox, thepat);				ForeColor(BlackColor);			end		else			begin				if ColorPort & not (colorCodPosLegal & (chartColorMode=chartColorCodPos)) & not (chartColorMode = chartColorPartitions)  & not MinMaxIrregular then					RGBForeColor(histocolor);				Fillrect(box, thepat);				if ColorPort then					RGBForeColor(blackRGB);			end;		FrameRect(box);		FrameButton(theDialog, 1);		if not ((CWView = Scatterview) and nucleotides) then			DimBox(GetDLOGItemBox(theDialog, 4));	end;{-----------------------------------------------------------------------------}	procedure PaintOptions;		var			pos: point;			incolor, outcolor, oldhistocolor: RGBColor;			inpat, outpat, oldhistopat: integer;			oldChartColorMode: integer;			oldcolorcodpos: boolean;			theDialog: DialogPtr;			pixwidH, H: Handle;			colorbox: RECT;			j: integer;			tempP: WindowPtr;			ds: str255;			oldCWScatterMultiColor: boolean;			localItemHit: integer;UserItemUProcP: UniversalProcPtr;{....}		procedure CheckPaintOptions;		begin			EnableDisableDLOGItem(theDialog, 6, colorQDExists and not MinMaxIrregular and not (chartColorMode = chartColorPartitions) and not ((((chartColorMode=chartColorCodPos) and ColorCodPosLegal) or ((CWView = scatterview) and CWScatterMultiColor)) and nucleotides), false);			ItemCheckMark(theDialog, 7, (chartColorMode=chartColorCodPos) & ColorCodPosLegal);			ItemCheckMark(theDialog, 11, (chartColorMode=chartColorPartitions));			ItemCheckMark(theDialog, 12, (chartColorMode=chartColorNone));			ItemCheckMark(theDialog, 8, nucleotides and CWScatterMultiColor);		end;{....}	begin		pos.v := 45;		pos.h := 40;		oldhistopat := histopat;		oldhistocolor := histocolor;		oldChartColorMode := chartColorMode;		oldCWScatterMultiColor := CWScatterMultiColor;		StartDLOG(552, theDialog, tempP);		colorbox := GetDLOGItemBox(theDialog, 9);UserItemUProcP := MyNewUserItemUPP(@BarUser);  H := Handle(UserItemUProcP);		SetDialogItem(theDialog, 9, UserItem, H, colorbox);		if not ColorCodPosLegal & (chartColorMode=chartColorCodPos) then			chartColorMode := chartColorNone;		if not (not onePartition & ColorCharInChartsLegal) & (chartColorMode=chartColorPartitions) then			chartColorMode := chartColorNone;		CheckPaintOptions;		EnableDisableDLOGItem(theDialog, 5, (NumSpotBar(SpotBarSetToShow) = 1), false);		EnableDisableDLOGItem(theDialog, 8, (CWView = Scatterview) and nucleotides, false);		EnableDisableDLOGItem(theDialog, 7, ColorCodPosLegal, false);		CheckAllOnePartition;		EnableDisableDLOGItem(theDialog, 11, not onePartition & ColorCharInChartsLegal, false);		myShowDialog(theDialog);		repeat			ModalDialog(nil, localItemHit);			case localItemHit of				5: 					begin						inpat := histopat;						if GetPat(inpat, outpat) then							histopat := outpat;					end;				6: 					begin						incolor := histocolor;						if GetColor(pos, 'select color', incolor, outcolor) then							histocolor := outcolor;					end;				7: 					chartColorMode := chartColorCodPos;				11: 					chartColorMode := chartColorPartitions;				12: 					chartColorMode := chartColorNone;				8, 4: 					if (localItemHit = 8) or ((CWView = Scatterview) and nucleotides) then						CWScatterMultiColor := not CWScatterMultiColor;				10: 					SetDialogValuesAsDefaults(theDialog, chartPaintID, 0, 0);				otherwise					;			end;			if (localItemHit in [5, 6, 7,11,12,8,4]) then				begin					EraseRect(colorBox);					InvalidateWindowRect(myGetWindowPtrForDialog(theDialog),colorBox,false);				end;			CheckPaintOptions;		until (localItemHit in [1, 2]);		if localItemHit = 2 then			begin				histopat := oldhistopat;				histocolor := oldhistocolor;				chartColorMode := oldChartColorMode;				CWScatterMultiColor := oldCWScatterMultiColor;			end;MyDisposeUserItemUPP(UserItemUProcP);		EndDLOG(theDialog, tempP);		if localItemHit = 1 then			ReDrawChartWindow;	end;{-----------------------------------------------------------------------------}	procedure BiggestSpotOptions;		var			theDialog: DialogPtr;			tempP: WindowPtr;			oldBiggestSpot: integer;			oldCWScatterArea: boolean;			localItemHit: integer;{.....}		procedure CheckBiggest;		begin			ItemCheckMark(theDialog, 3, BiggestSpot > 0);			ItemCheckMark(theDialog, 4, BiggestSpot = BiggestAuto);			ItemCheckMark(theDialog, 5, BiggestSpot = BiggestMaxMax);			ItemCheckMark(theDialog, 10, not CWScatterArea);		end;{......}	begin		oldBiggestSpot := biggestSpot;		oldCWScatterArea := CWScatterArea;		StartDLOG(595, theDialog, tempP);		if (BiggestSpot = BiggestMaxMax) & (not MinMaxOn) then			biggestSpot := BiggestAuto;		EnableDisableDLOGItem(theDialog, 5, MinMaxOn, false);		checkBiggest;		if BiggestSpot > 0 then			SetEditTextNum(theDialog, 6, 0, BiggestSpot, false, true);		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			case localItemHit of				3, 6, 7: 					BiggestSpot := 1;				4: 					BiggestSpot := BiggestAuto;				5: 					BiggestSpot := BiggestMaxMax;				10, 11: 					CWScatterArea := not CWScatterArea;				12: 					SetDialogValuesAsDefaults(theDialog, BiggestSpotid, 0, 0);				otherwise					;			end;			checkBiggest;		until localItemHit in [1, 2];		if localItemHit = 2 then			begin				BiggestSpot := oldBiggestSpot;				CWScatterArea := oldCWScatterArea;			end		else			begin				if BiggestSpot = 1 then   {it's a user-defined spot size}					begin						BiggestSpot := EditTextInt(theDialog, 6,true);						if BiggestSpot <= 0 then							BiggestSpot := oldBiggestSpot;					end;				if (BiggestSpot <> oldBiggestSpot) or (CWScatterArea <> oldCWScatterArea) then					RedrawChartWindow;			end;		EndDLOG(theDialog, tempP);	end;{-----------------------------------------------------------------------------}	procedure ScatterPercentOptions;		var			theDialog: DialogPtr;			tempP: WindowPtr;			oldCWPercent, oldCWNormRows: boolean;			localItemHit: integer;{..........}		procedure CheckScatterPercent;		begin			ItemCheckMark(theDialog, 3, CWPercent);			ItemCheckMark(theDialog, 4, CWNormRows);			EnableDisableDLOGItem(theDialog, 4, CWPercent, true);		end;{..........}	begin		oldCWPercent := CWPercent;		oldCWNormRows := CWNormRows;		StartDLOG(589, theDialog, tempP);		CheckScatterPercent;		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			if localItemHit = 3 then				CWpercent := not cwpercent			else if localItemHit = 4 then				CWnormRows := not CWNormRows			else if localitemhit = 6 then				SetDialogValuesAsDefaults(theDialog, scatterPercentID, 0, 0);			CheckScatterPercent;		until localItemHit in [1, 2];		EndDLOG(theDialog, tempP);		if localItemHit = 2 then			begin				CWPercent := oldCWPercent;				CWNormRows := oldCWNormRows;			end		else			ReDrawChartWindow;	end;{-----------------------------------------------------------------------------}	procedure ChartHorAxesOptions;		label			1;		var			oldautoPixWid: boolean;			theDialog: DialogPtr;			tempP: WindowPtr;			localItemHit: integer;			oldpixWid: integer;{.....}		procedure GrabPixText;		begin			if not AutoPixWid then				begin					pixwid := EditTextInt(theDialog, 5,true);					if (pixwid <= 0) or (pixwid > (WindowPortRect(chartWindow).right - chartRightMargin) div 2) then						begin							AutoPixWid := true;							InstantError(392);							localitemhit := NotInDialog;						end;				end;		end;{......}	begin		oldpixWid := pixWid;		oldautopixwid := autopixwid;		StartDLOG(551, theDialog, tempP);		myShowDialog(theDialog);		ItemCheckMark(theDialog, 3, AutoPixWid);		ItemCheckMark(theDialog, 4, not AutoPixWid);		if not AutoPixWid then			SetDLOGText(theDialog, 5, StringFromNum(PixWid), true);		FrameButton(theDialog, 1);1:		repeat			ModalDialog(nil, localItemHit);			if localItemHit in [3, 4, 5] then				begin					AutoPixWid := not (localItemHit in [4, 5]);					ItemCheckMark(theDialog, 3, AutoPixWid);					ItemCheckMark(theDialog, 4, not AutoPixWid);				end			else if localItemHit = 9 then				begin					GrabPixText;					SetDialogValuesAsDefaults(theDialog, chartPixWidID, 0, 0);				end;		until (localItemHit in [1, 2]);		if localItemHit = 1 then			begin				GrabPixText;				if localitemhit = notInDialog then					goto 1;			end;		EndDLOG(theDialog, tempP);		if localItemHit = 1 then			ReDrawChartWindow		else			begin				autopixwid := oldautopixwid;				pixWid := oldPixWid;			end;	end;{-----------------------------------------------------------------------------}	procedure InvertThreeBoxes (theDialog: DialogPtr; startbox: integer; dobox1, dobox2, dobox3: boolean);	begin		if dobox1 then			InvertDLOGitem(theDialog, startbox);		if dobox2 then			InvertDLOGitem(theDialog, startbox + 1);		if dobox3 then			InvertDLOGitem(theDialog, startbox + 2);	end;{-----------------------------------------------------------------------------}	procedure ChartVertAxisUser (theDialog: DialogPtr; itemNo: Integer);	begin		FrameButton(theDialog, 1);		InvertThreeBoxes(theDialog, 3, not CWpercent, CW100Axis and CWPercent, not CW100Axis and CWPercent);		InvertThreeBoxes(theDialog, 6, axisleft and not axisright, axisleft and axisright, not axisleft and axisright);		if (NumSpotBar(SpotBarSetToShow) > 1) or CIRIData or (CWChart in [CWCC2T, CWCC2TF, CWCProbSteps]) then			begin				DimBox(GetDLOGItemBox(theDialog, 4));				DimBox(GetDLOGItemBox(theDialog, 5));			end;	end;{-----------------------------------------------------------------------------}	procedure ChartVertAxesOptions;		var			theDialog: DialogPtr;			box: RECT;			itemtype: integer;			tempP: WindowPtr;			H: Handle;			oldCWpercent, oldCW100Axis, oldaxisright, oldaxisleft, oldC2TsayShorter: boolean;			oldCWScaleToMax, multispots, cantpercent: boolean;			localItemHit: integer;UserItemUProcP: UniversalProcPtr;	begin		multispots := NumSpotBar(SpotBarSetToShow) > 1;		cantpercent := multispots or CIRIData or (CWChart in [CWCC2T, CWCC2TF, CWCProbSteps]);		oldC2TsayShorter := C2TsayShorter;		oldCWScaleToMax := CWScaleTomax;		oldCWpercent := CWpercent;		if cantpercent then			CWPercent := false;		oldCW100Axis := CW100Axis;		oldaxisright := axisright;		oldaxisleft := axisleft;		StartDLOG(574, theDialog, tempP);		myShowDialog(theDialog);UserItemUProcP := MyNewUserItemUPP(@ChartVertAxisUser);  H := Handle(UserItemUProcP);		SetRect(box, 0, 0, 10, 10);		SetDialogItem(theDialog, 10, UserItem, H, box);		EnableDisableDLOGItem(theDialog, 11, multispots, false);		EnableDisableDLOGItem(theDialog, 13, (CWChart in [CWCC2T, CWCC2TF, CWCProbSteps]), false);		ItemCheckMark(theDialog, 11, CWScaleToMax);		if CWChart in [CWCC2T, CWCC2TF, CWCProbSteps] then			ItemCheckMark(theDialog, 13, C2TsayShorter);		repeat			ModalDialog(nil, localItemHit);			if (localItemHit in [3, 4, 5]) and not cantpercent then				begin					InvertThreeBoxes(theDialog, 3, not CWpercent, CW100Axis and CWPercent, not CW100Axis and CWPercent);					CWpercent := localItemHit in [4, 5];					CW100Axis := localItemHit = 4;					InvertThreeBoxes(theDialog, 3, not CWpercent, CW100Axis and CWPercent, not CW100Axis and CWPercent);				end			else if localItemHit in [6, 7, 8] then				begin					InvertThreeBoxes(theDialog, 6, axisleft and not axisright, axisleft and axisright, not axisleft and axisright);					axisleft := localItemHit in [6, 7];					axisright := localItemHit in [7, 8];					InvertThreeBoxes(theDialog, 6, axisleft and not axisright, axisleft and axisright, not axisleft and axisright);				end			else if localItemHit = 11 then				begin					CWScaleToMax := not CWScaleTomax;					ItemCheckMark(theDialog, 11, CWScaleToMax);				end			else if localitemhit = 12 then				SetDialogValuesAsDefaults(theDialog, chartVertAxisid, 0, 0)			else if localitemhit = 13 then				begin					C2TsayShorter := not C2TsayShorter;					ItemCheckMark(theDialog, 13, C2TsayShorter);				end;		until (localItemHit in [1, 2]);MyDisposeUserItemUPP(UserItemUProcP);		EndDLOG(theDialog, tempP);		if localItemHit = 1 then			begin				if cantpercent then					CWpercent := oldCWpercent;				chartAlreadyDrawn := false;				ReDrawChartWindow;			end		else			begin				CWpercent := oldCWpercent;				CW100Axis := oldCW100Axis;				axisright := oldaxisright;				axisleft := oldaxisleft;				CWScaleToMax := oldCWScaleTomax;				C2TsayShorter := oldC2TsayShorter;			end;	end;{$IFC CUMUL}{-----------------------------------------------------------------------------}	procedure CumulativeUser (theDialog: DialogPtr; itemNo: Integer);	begin		FrameButton(theDialog, 1);		InvertThreeBoxes(theDialog, 3, cumview = cumup, cumview = nocum, cumview = cumdown);	end;{-----------------------------------------------------------------------------}	procedure CumulativeOptions;		var			oldcumview: integer;			theDialog: DialogPtr;			box: RECT;			itemtype: integer;			H: Handle;			tempP: WindowPtr;			localItemHit: integer;UserItemUProcP: UniversalProcPtr;	begin		oldcumview := cumview;		StartDLOG(573, theDialog, tempP);		myShowDialog(theDialog);UserItemUProcP := MyNewUserItemUPP(@CumulativeUser);  H := Handle(UserItemUProcP);		SetRect(box, 0, 0, 10, 10);		SetDialogItem(theDialog, 6, UserItem, H, box);		repeat			ModalDialog(nil, localItemHit);			if localItemHit in [3, 4, 5] then				begin					InvertThreeBoxes(theDialog, 3, cumview = cumup, cumview = nocum, cumview = cumdown);					if localItemHit = 3 then						cumview := cumup					else if localItemHit = 4 then						cumview := nocum					else if localItemHit = 5 then						cumview := cumdown;					InvertThreeBoxes(theDialog, 3, cumview = cumup, cumview = nocum, cumview = cumdown);				end;		until (localItemHit in [1, 2]);		if localItemHit = 2 then			cumview := oldcumview;MyDisposeUserItemUPP(UserItemUProcP);		EndDLOG(theDialog, tempP);		if (localItemHit = 1) and (cumview <> oldcumview) then			ReDrawChartWindow;	end;{$ENDC}{-----------------------------------------------------------------------------}	procedure MinMaxUser (theDialog: DialogPtr; itemNo: Integer);	begin		FrameButton(theDialog, 1);		InvertDLOGItem(theDialog, CWScatterMinMax + 3);	end;{-----------------------------------------------------------------------------}	procedure MinMaxOptions;		var			theDialog: DialogPtr;			box: RECT;			itemtype: integer;			H: Handle;			tempP: WindowPtr;			oldCWScatterMinMax: integer;			localItemHit: integer;UserItemUProcP: UniversalProcPtr;	begin		oldCWScatterMinMax := CWScatterMinMax;		StartDLOG(575, theDialog, tempP);		myShowDialog(theDialog);UserItemUProcP := MyNewUserItemUPP(@MinMaxUser);  H := Handle(UserItemUProcP);		SetRect(box, 0, 0, 10, 10);		SetDialogItem(theDialog, 7, UserItem, H, box);		repeat			ModalDialog(nil, localItemHit);			if localItemHit in [3, 4, 5, 6] then				begin					InvertDLOGItem(theDialog, CWScatterMinMax + 3);					CWScatterMinMax := localItemHit - 3;					InvertDLOGItem(theDialog, CWScatterMinMax + 3);				end			else if localitemhit = 9 then				SetDialogValuesAsDefaults(theDialog, chartMinMaxid, 0, 0);		until (localItemHit in [1, 2]);MyDisposeUserItemUPP(UserItemUProcP);		EndDLOG(theDialog, tempP);		if (localItemHit = 1) then			begin				case CWScatterMinMax of					0: 						CMshow := [CMminmin, CMmaxmax];					1: 						CMshow := [CMminmean, CMmaxmean];					2: 						CMshow := [CMminmin, CMminmean, CMminmax];					3: 						CMshow := [CMmaxmin, CMmaxmean, CMmaxmax];					otherwise						;				end;				ReDrawChartWindow;			end		else			CWScatterMinMax := oldCWScatterMinMax;	end;{-----------------------------------------------------------------------------}	procedure ResetCWScrollMinMax;		var			box: rect;	begin		if (CWView = tableview) then			begin				if numIntervals[CLkind] - CWTableRows + 1 < 0 then					SetControlMaximumLong(CWScroll, 0)				else					SetControlMaximumLong(CWScroll, numIntervals[CLkind] - CWTableRows + 1);			end		else if (CWView = histoview) then			begin				if numIntervals[CLkind] - chartintervals < 0 then					SetControlMaximumLong(CWScroll, 0)				else					SetControlMaximumLong(CWScroll, numIntervals[CLkind] - chartintervals);			end		else if (CWView = infoview) then			begin				if FontHeight * (chartTextLines + 2) < WindowPortRect(chartWindow).bottom then					begin						SetControlMaximumLong(CWScroll, 0);						chartorigin := 0;					end				else					SetControlMaximumLong(CWScroll, chartTextLines - WindowPortRect(chartWindow).bottom div FontHeight + 2);			end;	end;{-----------------------------------------------------------------------------}	procedure ResetCWScroll;		var			box: rect;			tport: WindowPtr;	begin		genericGetPort(tport);		genericSetPort(chartwindow);		ClipRect(WindowPortRect(chartWindow));		if (CWView = tableview) then			begin				with CWTableBox do					SetRect(box, right, top, right + scrollwidth + 1, bottom);				SizeControl(CWScroll, scrollwidth + 1, box.bottom - box.top + 4);				MoveControl(CWScroll, box.left + 1, box.top - 2);			end		else if (CWView = histoview) then			begin				box := WindowPortRect(chartWindow);				box.top := box.bottom - scrollwidth;				box.right := box.right - 20;				SizeControl(CWScroll, box.right - box.left + 6, scrollwidth + 1);				MoveControl(CWScroll, box.left, box.top);			end		else if (CWView = infoview) then			begin				box := WindowPortRect(chartWindow);				box.right := box.right - 20;				box.left := box.right - scrollwidth;				SizeControl(CWScroll, scrollwidth + 1, box.bottom - box.top + 4);				MoveControl(CWScroll, box.left - 1, box.top - 2);			end;		ResetCWScrollMinMax;		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	procedure CalcCWBoxes (boundary: rect);		var			box: rect;	begin		CWLW := FontHeight + 2;		CWTableBox := boundary;		InsetRect(CWTableBox, 40, 40);		CWTableBox.top := CWTableBox.top + ChartImageTitleHeight;		with CWTableBox do			begin				right := right - Scrollwidth - 20 - 1;				CWTableRows := (bottom - top) div CWLW;				bottom := top + CWTableRows * CWLW - 1;			end;		chartintervals := CWTableRows;		if not printon then			ResetCWScroll;	end;{-----------------------------------------------------------------------------}	procedure DrawChartWindowControls;	begin		ClipRect(WindowPortRect(chartWindow));		ResetCWScrollMinMax;		ChartWindowTitle;		DrawGrowBox(ChartWindow);		DrawControls(Chartwindow);	end;{-----------------------------------------------------------------------------}	procedure DrawChartWindow (boundary: rect);		var			tport: windowptr;			ds: str255;			oldPercent: boolean;			box: rect;	begin		chartTitleStart.h := boundary.left + 25;		chartTitleStart.v := boundary.top + 5;		emptychart := false;		SetCursor(clockCursor);		oldPercent := CWPercent;		if CIRIData then			CWPercent := false;		if not printon and not savepicton then			CheckPixelDepth(Chartwindow);		Textsize(CWfontsize);		TextFont(CWfont);		TextFace(CWstyle);		if not printon and not savepicton then			begin				genericGetPort(tport);				genericSetPort(ChartWindow);			end;		if not printon then			begin				box := boundary;				box.right := box.right - scrollwidth - 3;				box.bottom:= box.bottom-scrollwidth;				if CWView = infoview then					box.right := box.right - scrollwidth - 1;				ClipRect(box);			end;{$IFC True}		if ShowChartTitle then			DrawChartImageTitle;{$ENDC}		case CWView of			histoview: 				begin					DrawHistogram(boundary);					chartAlreadyDrawn := true;				end;			scatterview: 				DrawScatter(boundary);			tableview: 				DrawTable(boundary);			infoview: 				DrawChartText(boundary);		end;		if not printon and not savepicton then			begin				DrawChartWindowControls;   {v3.01: this moved from above}				genericSetPort(tport);			end;		EnableDisableItem(FileMHdl, GraphicFileItem, (CWview in [scatterview, histoview]) & not emptychart & (frontwindow = chartwindow));		EnableDisableItem(EditMHdl, CopyItem, (CWview in [scatterview, histoview]) & not emptychart & (frontwindow = chartwindow));		EnableDisableItem(NewChartMHdl, ChartWtTypeItem, (CWView <> infoview) and not emptychart and (((CWChart = CWCSteps) and (sequencechart or positionchart)) or (CWChart = CWCChanges)));		CWPercent := oldPercent;		SetCursorToArrow;	end;{-----------------------------------------------------------------------------}	procedure ReDrawChartWindow;		var			box: rect;			upRgn: RgnHandle;	begin		genericSetPort(ChartWindow);		upRgn := NewRgn;		OpenRgn;		with WindowPortRect(chartWindow) do			begin				moveTo(left, top);				lineto(right - scrollwidth, top);				lineto(right - scrollwidth, bottom-scrollwidth);				lineTo(right, bottom-scrollwidth);				lineto(right, bottom);				lineto(left, bottom);				lineto(left, top);			end;		CloseRgn(upRgn);		EraseRgn(upRgn);		InvalidateWindowRegion(chartWindow,upRgn,false);		ZapRegion(upRgn);	end;{-----------------------------------------------------------------------------}	procedure ScrollCW;		var			dv, dh, oldchartorigin: longint;			ic: integer;			box: rect;			info: FontInfo;			fontheight: integer;			axisRgn: RgnHandle;			tport: WindowPtr;	begin		oldchartorigin := chartorigin;		chartorigin := GetControlValueLong(CWScroll);		if chartorigin <> oldchartorigin then			if (CWView = tableview) then				begin					dv := (oldchartorigin - chartorigin);	{if chartorigin is greater, then must be going up, and dv is negative, there fore must suptract it}					CWTableTop := CWTableTop - dv;					if abs(dv) > CWTablerows then			{this is here to protect agains dv*CWLw being  greater than 32000}						begin							EraseRect(CWTableBox);							DrawScrollableTable;						end					else						begin							dv := dv * CWlw;							ScrollRect(CWTableBox, 0, dv, updateRgn);							SetClip(updateRgn);							if dv = CWlw then								CWTableLine(CWTabletop)							else if (dv = -CWlw) & WindowBotRightOnScreen(chartwindow, true, CWTableBox.bottom) then								begin									ic := CWTAbletop + CWTablerows - 1;									if ic < numIntervals[CLkind] then										CWTableLine(ic);								end							else if dv <> 0 then								DrawScrollableTable;						end;				end			else if (CWView = histoview) then				begin					axisRgn := NewRgn;					dh := (oldchartorigin - chartorigin) * pixwid;					if dh = -1 then						chartbox.right := chartbox.right - 1;					ScrollRect(chartBox, dh, 0, updateRgn);					if dh = -1 then						chartbox.right := chartbox.right + 1;{SetRectRgn(axisRgn, chartbox.right, chartBox.top, chartBox.right + 1, chartBox.bottom);}{UnionRgn(updateRgn, axisRgn, updateRgn);}					GetFontInfo(info);					fontheight := info.ascent + info.descent + info.leading;					SetRect(box, 0, chartBox.bottom + 1, WindowPortRect(chartWindow).right - 20, chartBox.bottom + 1 + fontheight);					RectRgn(axisRgn, box);					EraseRect(box);					UnionRgn(updateRgn, axisRgn, updateRgn);					ZapRegion(axisRgn);					SetClip(updateRgn);					DrawHistogram(WindowPortRect(chartWindow));				end			else if (CWView = infoview) then				begin					box := WindowPortRect(chartWindow);					box.right := myGetControlRect(CWScroll).left;					dv := (oldchartorigin - chartorigin);	{if chartorigin is greater, then must be going up, and dv is negative, there fore must suptract it}					GetFontInfo(info);					fontheight := info.ascent + info.descent + info.leading;					dv := dv * FontHeight;					ScrollRect(box, 0, dv, updateRgn);					SetClip(updateRgn);					DrawChartText(WindowPortRect(chartWindow));				end;		ClipRect(WindowPortRect(chartWindow));	end;{----------------------------------------------------------------------------}	procedure ScrollCWUpDown (whichControl: ControlRef; theCode: INTEGER);	begin		if scrollup then			begin				if theCode = kControlUpButtonPart then					begin						SetControlValueLong(whichControl, GetControlValueLong(whichControl) - 1);						ScrollCW					end			end		else if theCode = kControlDownButtonPart then			begin				SetControlValueLong(whichControl, GetControlValueLong(whichControl) + 1);				ScrollCW			end	end;{-----------------------------------------------------------------------------}	procedure DoCWScroll (wh: Point);		var			MyControl: integer; 			t, visibleintervals: longint;			mypt: point;			oldCWPercent: boolean;	begin		MyControl := FindControl(wh, ChartWindow, whichControl);		if whichControl=nil then Exit(DoCWScroll);		oldCWPercent := CWPercent;		if CIRIData then			CWPercent := false;		if (CWView = tableview) then			visibleintervals := CWTableRows		else			if CWView = infoview then				visibleintervals := chartTextLines			else				visibleintervals := chartintervals;		ClipRect(WindowPortRect(chartWindow));		case MyControl of			kControlUpButtonPart: 				begin					scrollup := true;					t := myTrackControl(whichControl, wh, ScrollCWUpDownUPP);				end;			kControlDownButtonPart: 				begin					scrollup := false;					t := myTrackControl(whichControl, wh, ScrollCWUpDownUPP);				end;			kControlPageUpPart: 				repeat					GetMouse(myPt);					if TestControl(whichControl, myPt) = mycontrol then						begin							SetControlValueLong(whichControl, GetControlValueLong(whichControl) - visibleintervals);							ScrollCW						end				until not StillDown;			kControlPageDownPart: 				repeat					GetMouse(myPt);					if TestControl(whichControl, myPt) = mycontrol then						begin							SetControlValueLong(whichControl, GetControlValueLong(whichControl) + visibleintervals);							ScrollCW						end				until not StillDown;			kControlIndicatorPart: 				begin{$IFC TRACKPAGENUMBERS}					TrackFeedbackThumb(whichControl,wh, whichWindow);{$ELSEC}												t := myTrackControl(whichControl, wh, nil);{$ENDC}					ScrollCW;				end;			otherwise				;		end;		chartorigin := GetControlValueLong(CWScroll);		CWPercent := oldCWPercent;	end;{-----------------------------------------------------------------------------}	procedure CheckMouseInChartLegend (wh: point);		var			setToShow: set15;			numtoshow, j: integer;	begin		settoshow := SpotBarSetToShow;		numtoshow := NumSpotBar(settoshow);		if numtoshow = 1 then			Exit(CheckMouseInChartLegend);		for j := 1 to numtoshow do			if PtInRect(wh, spotbox[j]) then				begin					PopUpStringMenu(wh, SpotBarName(GetSpotBarKind(SetToShow, j), true));					leave;				end;	end;{-----------------------------------------------------------------------------}	procedure MouseInChartBox (wh: point);		var			ds, ds2: str255;			interval: integer;			thePos, isto, isfrom: integer;	begin		if (CWView = histoview) then			begin				interval := (wh.h - chartbox.left) div pixwid + chartorigin;				if (((CWChart = CWCSteps) and sequencechart) or (CWChart in [CWCC2T, CWCC2TF])) and not molecular and (catwid = 1) then					begin						ds := CharName(interval + 1);						if ds = '' then							ds := concat('Character ', StringFromNum(interval + 1))						else							ds := concat(StringFromNum(interval + 1), ': ', ds);					end				else if ((CWChart = CWCSteps) & sequencechart) & nucleotides & (catwid = 1) then					begin						thePos := CharCodPos(interval + 1);						if thePos >= 1 then							ds := concat(CategoryTitle, ': ', CategoryString(interval, 3, true, false), chr(13), 'Position ', StringFromNum(thepos))						else							ds := concat(CategoryTitle, ': ', CategoryString(interval, 3, true, false));					end				else if (CWChart = CWCStates) and CWTraced then					begin						ds := CharStateName(i, interval);						if ds = '' then							ds := concat('State: ', CharOfNum(interval));					end				else					ds := concat(CategoryTitle, ': ', CategoryString(interval, 3, true, false));				if IntervalLegal(interval) then					if CWPercent then						ds := concat(ds, chr(13), 'Value: ', CLAllValuesString(interval), ' %')					else						ds := concat(ds, chr(13), 'Value: ', CLAllValuesString(interval))				else					ds := concat(ds, chr(13), '(not calculated)');				PopUpStringMenu(wh, ds);			end		else if (CWView = Scatterview) & (BiggestSpotToShow>0) then			begin				isto := (wh.h - chartbox.left) div boxedge;				isfrom := (wh.v - chartbox.top) div boxedge;				if CWTraced then					ds := concat(AvailCharStateName(i, isfrom), ' -> ', AvailCharStateName(i, isto))				else					ds := concat(CharOfNum(isfrom), ' -> ', CharOfNum(isto));				if CWShowConstant & (isfrom = isto) then					ds := concat(ds, chr(13), CMAllValuesString(isfrom, isto, ds2), ' events')				else if isfrom <> isto then					ds := concat(ds, chr(13), CMAllValuesString(isfrom, isto, ds2), ' changes')				else					ds := concat(ds, chr(13), '(not calculated)');				PopUpStringMenu(wh, ds);			end	end;{-----------------------------------------------------------------------------}	procedure SwitchViews (newview: integer);	begin		genericSetPort(ChartWindow);		ClipRect(WindowPortRect(chartWindow));		CWView := newview;		EraseRect(WindowPortRect(chartWindow));		InvalidateWindowRect(chartWindow,WindowPortRect(chartWindow),false);		if CWLinear then			begin				if (CWView = tableview) then					begin						CWTableTop := 0;						chartorigin := 0;						SetControlValueLong(CWScroll, GetControlMinimumLong(CWScroll));						ResetCWScroll;						ShowControl(CWScroll);					end				else if (CWView = histoview) then					begin						chartorigin := 0;						SetControlValueLong(CWScroll, GetControlMinimumLong(CWScroll));						Hidecontrol(CWScroll);						ResetCWScroll;					end				else					if (CWView = infoview) then						begin							chartorigin := 0;							SetControlValueLong(CWScroll, 0);							ResetCWScroll;							ShowControl(CWScroll);						end					else						Hidecontrol(CWScroll);			end		else			Hidecontrol(CWScroll);		CheckChartViewsMenu;	end;{-----------------------------------------------------------------------------}	procedure MouseInChartWindow;  {wh: point}		var			oldchartorigin: integer;			box, trect: rect;			lastwh: point;			updateRgn: RgnHandle;	begin		genericSetPort(chartwindow);		box := WindowPortRect(chartWindow);		box.right := box.right - 20;		GlobalToLocal(wh);		ClipRect(WindowPortRect(chartWindow));		{if PtInRect(wh, onViewB[histoview]) and (CWView <> histoview) and CWLinear then			SwitchViews(histoview)		else if PtInRect(wh, onViewB[tableview]) and (CWView <> tableview) then			SwitchViews(tableview)		else if PtInRect(wh, onViewB[infoview]) and (CWView <> infoview) then			SwitchViews(infoview)		else if PtInRect(wh, onViewB[scatterview]) and (CWView <> scatterview) and not CWLinear then			SwitchViews(scatterview)}{$IFC CUMUL}		 if PtInRect(wh, cumulativeB) then			begin				if CWLinear and (CWView <> infoview) then					CumulativeOptions				else if not CWLinear and (CWView = scatterview) then					BiggestSpotOptions;			end{$ENDC}		{ if PtInRect(wh, spotB) then			begin				if not CWLinear and (CWView = scatterview) then					BiggestSpotOptions;			end}		{else if PtInRect(wh, fontB) then			begin				CWFontsDLOG;			end}		{else if PtInRect(wh, gridB) and ((CWLinear and (CWView = histoview)) or (CWView = scatterview)) then			begin				Chartgrid := not Chartgrid;				InvertRect(gridB);				ReDrawChartWindow;			end}		{else if PtInRect(wh, titleB) and not (CWView = infoview) then			begin				ShowChartTitle := not ShowChartTitle;				InvertRect(titleB);				ReDrawChartWindow;			end}		{else if PtInRect(wh, vertaxisB) then			begin				if CWLinear and (CWView = histoview) then 					ChartVertAxesOptions				else if not CWLinear and (CWView = tableView) and (NumSpotBar(SpotBarSetToShow) = 1) then					ScatterPercentOptions			end}		{else if PtInRect(wh, horaxisB) and CWLinear and (CWView = histoview) then			ChartHorAxesOptions}		{else if PtInRect(wh, PaintB) and ((CWView = histoview) or (CWView = scatterview)) and not MinMaxIrregular then			PaintOptions}		{else if PtInRect(wh, minmaxB) and MinMaxEnabled then			MinMaxOptions}		{else			begin}				trect := myGetControlRect(CWScroll);				if PtInRect(wh, trect) and ((CWView = infoview) or (CWLinear and ((CWView = tableview) or (biggraph and (CWView = histoview))))) then					begin						ClipRect(WindowPortRect(chartWindow));						DoCWScroll(wh);					end				else if PtInRect(wh, chartbox) then					MouseInChartBox(wh)				else					CheckMouseInChartLegend(wh);			{end;}	end;{-----------------------------------------------------------------------------}	procedure DoChartShowMenu (ItemNo: integer);	begin		case ItemNo of			ChartShowTitleItem: 				if not (CWView = infoview) then					begin						ShowChartTitle := not ShowChartTitle;						myCheckMenuItem(ShowMHdl,ChartShowTitleItem,ShowChartTitle);						ReDrawChartWindow;					end;			ChartShowGridItem:				if((CWLinear and (CWView = histoview)) or (CWView = scatterview)) then					begin						Chartgrid := not Chartgrid;						myCheckMenuItem(ShowMHdl,ChartShowGridItem,chartGrid);						ReDrawChartWindow;					end;			otherwise				;		end;	end;{-----------------------------------------------------------------------------}	procedure DoChartViewsMenu (ItemNo: integer);	begin		case ItemNo of			ChartViewsChartItem: 				 if ((CWView <> histoview) & CWLinear) then					SwitchViews(histoview)				else if  (CWView <> scatterview) & not CWLinear then					SwitchViews(scatterview);			ChartViewsTableItem: 				if (CWView <> tableview) then					SwitchViews(tableview);			ChartViewsSummaryItem: 				if (CWView <> infoview) then					SwitchViews(infoview);			otherwise				;		end;		FixChartDisplayMenu;	end;{-----------------------------------------------------------------------------}	procedure DoChartDisplayMenu (ItemNo: integer);	begin		case ItemNo of			ChartDisplayShowSubMenuItem: 				;			ChartDisplayViewSubMenuItem: 				;			ChartDisplayVerticalAxisItem: 				if CWLinear and (CWView = histoview) then					ChartVertAxesOptions;			ChartDisplayHorizontalAxisItem: 				if CWLinear and (CWView = histoview) then					ChartHorAxesOptions;			ChartDisplayPercentageItem:				if not CWLinear and (CWView = tableView) and (NumSpotBar(SpotBarSetToShow) = 1) then					ScatterPercentOptions;			ChartDisplayCircleSizeItem: 				if not CWLinear and (CWView = scatterview) then					BiggestSpotOptions;;			ChartDisplayPatternsColorsItem: 				if ((CWView = histoview) or (CWView = scatterview)) and not MinMaxIrregular then					PaintOptions;			ChartDisplayValuesItem: 				if MinMaxEnabled then					MinMaxOptions;			otherwise				;		end;		FixChartDisplayMenu;	end;{-----------------------------------------------------------------------------}end.