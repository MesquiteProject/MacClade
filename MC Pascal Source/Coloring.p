unit Coloring;{еееееееееееееееееееееее}interface	uses		QuickDraw, Printing,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, 		Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, 		EventUtil, GenUtil, BoxUtil, CharUtil, SpreadUtil, TaxonCHUtil, StrUtil, Prohibitions, Settings, 		TreeUtil, TypeUtil, Legends, BranchListWindow, InfoWindows, MenuUtil;	procedure TerminalTaxaBoxes (N: Nptr; coverTicks: boolean);	procedure ColorTree (var N: Nptr; coverTicks: boolean);	procedure ColorChar;	procedure TemporaryColorCharacter(coverTicks: boolean);	procedure EraseBoxes;	procedure EraseChar (N: Nptr);	procedure CalcTickBoundaries(N: Nptr; vpos: longint; var left,right: longint);	procedure CalcVertTickSpacings (N: NPtr; var vinc: integer; var vpos: longint);	procedure ColorContinuous (leavecurrentPort: boolean);	procedure LabelTheNodes (N: Nptr; whichport: WindowPtr; labelNums, labelEvolveSegments, labelEvolveRealLengths: boolean);	procedure ColorTraceLabels (whichport: WindowPtr);	procedure ColorChanges (whichport: WindowPtr);	procedure ReShadeTree;	procedure FlashFix;	procedure FlashBranch (N: Nptr);	procedure AllStatesLabelDLOG;	procedure CharTraceLabelDLOG;	procedure ContTraceLabelDLOG;	var		maxGrayScale: integer;{еееееееееееееееееееееее}implementation {е$S Coloring}	var		trect: rect;{-----------------------------------------------------------------------------}{Placement of numbers on branches}{trace char   1/3 of way}{trace all changes 1/3 of way}{show Evolve segments 1/2 of way if shownodenumbers on, 2/3 otherwise}{shownodenumbers 2/3 of way}{-----------------------------------------------------------------------------}	procedure TerminalTaxaBoxes (N: Nptr; coverTicks: boolean);		var			TaxonHdl: thdl;			trect: rect;{........}		procedure TermTaxaBoxesRec (N: Nptr);			{tree traversal to find locations}		begin			if NodeIsTerminal(N) then				begin					TaxonHdl := gettaxonHdl(N^.name);					if coverTicks then						SETRECT(trect, N^.loc.h-tickOverHang, N^.loc.v - 8, N^.loc.h + edw+tickOverHang, N^.loc.v - 1)					else						SETRECT(trect, N^.loc.h, N^.loc.v - 8, N^.loc.h + boxedw, N^.loc.v - 1);					taxonHdl^^.B := trect;				end			else				begin					TermTaxaBoxesRec(N^.lf);					TermTaxaBoxesRec(N^.rt);				end;		end; {............}	begin		TermTaxaBoxesRec(N);	end;{-----------------------------------------------------------------------------}	function OrientBranchBoxRotate (r: rect): rect;		var			newr: rect;	begin{$IFC FLIPTREE}		if treeflipped then			begin				newR.left := R.left - (R.bottom - R.top);				newR.right := R.left;				newR.bottom := R.bottom;				newR.top := newR.bottom - (R.right - R.left);				OrientBranchBoxRotate := newR;			end		else{$ENDC}			OrientBranchBoxRotate := r;	end;{-----------------------------------------------------------------------------}	procedure FillBranch (N: Nptr; patt: Pattern; pixPatH: PixPatHandle; coverTicks: boolean);		var			an: Nptr;			box: rect;	begin{$IFC TINKERTOY}		if tinkertoy then  {v4: not fixed for fliptree}			begin				PenPat(Patt);				box := GetTinkerBox(N);				PaintOval(box);				PenPat(QDBlack);				if branchShades[curTrace] <> branchPatterns then					ForeColor(blackcolor);				FrameOval(box);			end		else{$ENDC}			begin				aN := NotNullAnc(N);				if pixPatH <> nil then					PenPixPat(pixPatH)				else					PenPat(Patt);{$IFC SQUAREBRANCHES}				if squareBranches and not printon then					begin						if coverTicks then							begin								PenSizeOrient(edw - 2+tickOverHang*2, 1);								MoveToOrient(N^.loc.h + 1-tickOverHang, aN^.loc.v - 2);								LineToOrient(N^.loc.h + 1-tickOverHang, N^.loc.v + 1);							end						else							begin								PenSizeOrient(edw - 2, 1);								MoveToOrient(N^.loc.h + 1, aN^.loc.v - 2);								LineToOrient(N^.loc.h + 1, N^.loc.v + 1);							end;					end				else {$ENDC}					if printon and laser^.treeshape[squaretree] then						begin							PenSizeOrient(edw - 2, 1);							MoveToOrient(N^.loc.h + 1, aN^.loc.v + edw - 2);{was just N^.loc.v+1}							LineToOrient(N^.loc.h + 1, N^.loc.v + 1);							if (NodeIsInternal(N)) then								begin									PenSizeOrient(1, edw - 2);									MoveToOrient(Farthestleft(N) + 1, N^.loc.v + 1);									LineToOrient(Farthestright(N) + edw - 2, N^.loc.v + 1);									PenSizeOrient(edw - 2, 1);								end;						end					else if printon and laser^.treeshape[eurotree] then						begin							PenSizeOrient(edw - 2, edw - 2);							MoveToOrient(aN^.loc.h + 1, aN^.loc.v + 1);							LineToOrient(N^.loc.h + 1, aN^.loc.v - laser^.versp div 3);							LineToOrient(N^.loc.h + 1, N^.loc.v + 1);						end					else						begin							if coverTicks then								begin									PenSizeOrient(edw - 2+tickOverHang*2, 1);									MoveToOrient(aN^.loc.h + 1-tickOverHang, aN^.loc.v);									LineToOrient(N^.loc.h + 1-tickOverHang, N^.loc.v);								end							else								begin									PenSizeOrient(edw - 2, 1);									MoveToOrient(aN^.loc.h + 1, aN^.loc.v);									LineToOrient(N^.loc.h + 1, N^.loc.v);								end;							if (NodeIsInternal(N)) then								if (polyreal or not (NodeIsPolytomous(N))) then									if printon then {and laser^.postscripton}    {for pict files, laser printing}										begin											if savepicton then {or odd(edw)}												OffSetPOLYOrient(Nodetriangle, N^.loc.h + 1, N^.loc.v - 1)											else												OffSetPOLYOrient(Nodetriangle, N^.loc.h + 1, N^.loc.v);											PaintPoly(Nodetriangle);											if savepicton then {or odd(edw)}												OffSetPOLYOrient(Nodetriangle, -N^.loc.h - 1, -N^.loc.v + 1)											else												OffSetPOLYOrient(Nodetriangle, -N^.loc.h - 1, -N^.loc.v);										end									else										begin											OffSetRgnOrient(NodeClip, N^.loc.h, N^.loc.v);											PaintRgn(NodeClip);											OffSetRgnOrient(NodeClip, -N^.loc.h, -N^.loc.v);										end;						end;				PenSizeOrient(1, 1);				PenPat(QDBlack);				if (NodeIsTerminal(N)) then					begin						if branchShades[curTrace] <> branchPatterns then							ForeColor(blackcolor);						MoveToOrient(N^.loc.h, N^.loc.v);						LineToOrient(N^.loc.h + edw - 1, N^.loc.v);					end;			end;	end;{-----------------------------------------------------------------------------}	procedure ColorEdge (N: Nptr; coverTicks: boolean);{FROZEN 3.0}{Shades the branch for ColorTree, which colors for character tracing only.}{Equivocal cycling is accommodated by placing resolved state into N^.final}		var			usepat: PATTERN;			UseColor: RGBColor;			tsts: largestsetchars;			useequivocal: boolean;	begin		useequivocal := false;		FindPat(usepat, usecolor, N^.final, i, curTrace);		if (branchShades[curTrace] <> branchPatterns) & ColorPort then			RGBForeColor(usecolor);		if cfound then				{it's monomorphic}			FillBranch(N, usepat,nil,coverTicks)		else if NodeIsTerminal(N) then	{terminal taxon that's polymorphic, equivocal, or uncertain}			useequivocal := true		else if not N^.fixanc then  {internal node}			useequivocal := true		else {internal node, but fixanced by observed taxon}			begin				if typeofchar(i) = fisher then  {v4: figure out whether polymorphic or equivocal}					FILLBRANCH(N, stratpat,stratPatPPH,coverTicks)				else if FixancedByMissing(N, i) then					useequivocal := true				else if FixancedByPolymorphic(N, i) then					begin						polyon := TRUE;						FillBranch(N, polym,polymPPH,coverTicks);					end				else if FixancedbyUncertain(N, i) then					begin						uncertpres := TRUE;						FillBranch(N, uncert,uncertPPH,coverTicks);					end				else					useequivocal := true			end;		if useequivocal then			begin				equivpres := TRUE;				FILLBranch(N, equivocalPattern,equivocalPPH, coverTicks);			end;		if (branchShades[curTrace] <> branchPatterns) & colorPort then			RGBForeColor(blackRGB);	end;{-----------------------------------------------------------------------------}	procedure ColorTree (var N: Nptr; coverTicks: boolean);{Colors the tree for the traced character.}{Both colors the branches, as well as the boxes at the terminal taxa.}{Called by ColorChar below, as well as directly by NextResolutionInCycle in Equivocal}{- Before this is called, SetMaxGrayScale must be called}		const			rightfixbrush = 231;			leftfixbrush = 149;		var			TaxonHdl: thdl;			usepat: PATTERN;			UseColor: RGBColor;{..............}		procedure DropBrush (ID: integer; left, top: integer);			var				dropcurs: cursor;				box: rect;		begin			LoadCursor(dropcurs, ID);			SetRect(box, left, top, left + 16, top + 16);			cursormap.baseAddr := @dropcurs.mask;			CopyBits(cursormap, myGetPortBits(QDThePort), cursormap.bounds, box, srcBIC, nil);			cursormap.baseAddr := @dropcurs.data;			CopyBits(cursormap, myGetPortBits(QDThePort), cursormap.bounds, box, srcOR, nil);		end;{..............}		procedure DrawPaintBrush (N: Nptr);		begin			if NodeSlantsRight(N) then				DropBrush(rightfixbrush, N^.loc.h + edw - 9, N^.loc.v - 3)			else				DropBrush(leftfixbrush, N^.loc.h - 3, N^.loc.v - 3);		end;{..............}	begin		if (NodeIsInternal(N)) then			begin				ColorTree(N^.lf,coverTicks);				ColorTree(N^.rt,coverTicks);				if equivcycle then					EquivocalCursor(true);{==== internal branch shading ====}				if not N^.null then					ColorEdge(N,coverTicks);				if showfix and fixon then					begin						if BranchExists(N^.lf) & N^.lf^.fix then							DrawPaintBrush(N^.lf);						if BranchExists(N^.rt) & N^.rt^.fix then							DrawPaintBrush(N^.rt);						if (N = screenR) and N^.fix then							DrawPaintBrush(N);					end;			end		else   {Terminal Node}			begin{==== boxes for terminal taxa ====}				TaxonHdl := gettaxonHdl(N^.name);				trect := taxonHdl^^.B;				if not Qtaxon(N, i) then					begin						FindPat(usepat, usecolor, gettaxonstsLargest(N^.name, i), i, traceDiscrete);						if (branchShades[traceDiscrete] <> branchPatterns) & ColorPort then							RGBForeColor(usecolor);						FillRectOrient(trect, usepat);						if (branchShades[traceDiscrete] <> branchPatterns) & ColorPort then							RGBForeColor(blackRGB);						FrameRectOrient(trect);{$IFC SHADOWTREE}						if shadowTree then							ShadowBox(trect);{$ENDC}						HiliteDataBox(trect, N^.name, i);					end				else					EraseRectOrient(trect);{==== terminal taxa branch shading ====}				if not N^.fixanc then					ColorEdge(N,coverTicks);			end;	end;{-----------------------------------------------------------------------------}	procedure ColorChar;{This calls colorTree to color the tree for traced character.}{Called only below in ReshadeTree}		var			ir: integer;			tport: windowptr;			oldRgn: RgnHandle;	begin		if (i > numchars) | (i < 1) | (not CharIncluded(i)) then {this is a safety net; if anything wrong with i, ditches and goes again}			begin				i := NextIncludedChar(i);				SetControlValueLong(chlegScroll, i);				NewError(127, 0);{FROZEN 3.0}				golist := golist + igos;  {if old i was no good, change i and redo calculations}			end		else			begin				CheckPixelDepth(treewindow);				Equivpres := false;				genericGetPort(tport);				genericSetPort(treewindow);				oldRgn := NewRgn;				GetClip(oldRgn);				setcursor(clockCursor);				if nex7on then					ClipRectOrient(treerect)				else					SetClip(TWClip);				SetMaxGrayScale;				ColorTree(ScreenR,false);				SetClip(oldRgn);				ZapRegion(oldRgn);				if not WindowVisible(chlegwindow) then					DrawCHLeg;{    if not twscrolling then InvalidateWindow(chlegwindow, false);}				genericSetPort(tport);			end;	end;{-----------------------------------------------------------------------------}	procedure DrawBranchOutline (N: Nptr);		var			an: Nptr;	begin		aN := NotNullAnc(N);		if squareBranches then			begin				PenSizeOrient(edw - 2+tickOverHang*2+2, 1);				MoveToOrient(N^.loc.h + 1-tickOverHang-1, aN^.loc.v - 1);				LineToOrient(N^.loc.h + 1-tickOverHang-1, N^.loc.v);			end		else			begin				PenSizeOrient(edw - 2+tickOverHang*2, 1);				MoveToOrient(aN^.loc.h + 1-tickOverHang-1, aN^.loc.v);				LineToOrient(N^.loc.h + 1-tickOverHang-1, N^.loc.v);			end;	end;{-----------------------------------------------------------------------------}	procedure QuickThickBranchedTree (N: Nptr);	begin		if (NodeIsInternal(N)) then			begin				QuickThickBranchedTree(N^.lf);				QuickThickBranchedTree(N^.rt);				if not N^.null then					DrawBranchOutline(N);			end		else   {Terminal Node}			begin				if not N^.fixanc then					DrawBranchOutline(N);			end;	end;{-----------------------------------------------------------------------------}	procedure TemporaryColorCharacter(coverTicks: boolean);{This is used for temporary shading of a traced character}		var			tport: windowptr;			oldRgn: RgnHandle;			oldTrace : integer;	begin		if (i > numchars) | (i < 1) | (not CharIncluded(i)) then {this is a safety net; if anything wrong with i, ditches and goes again}			begin			end		else			begin				oldTrace := traceShown;				CheckPixelDepth(treewindow);				Equivpres := false;				genericGetPort(tport);				genericSetPort(treewindow);				oldRgn := NewRgn;				GetClip(oldRgn);				if nex7on then					ClipRectOrient(treerect)				else					SetClip(TWClip);				SetMaxGrayScale;				RGBForeColor(blackRGB);				QuickThickBranchedTree(screenR);				PenNormal;				TerminalTaxaBoxes(screenR,coverTicks);				ColorTree(ScreenR,coverTicks);				TerminalTaxaBoxes(screenR,false);								traceShown:= traceDiscrete;				DrawCHLeg;				repeat until not StillDown;				traceShown := oldTrace;				DrawCHLeg;				SetClip(oldRgn);				ZapRegion(oldRgn);				genericSetPort(tport);				godraw:= true;			end;	end;{-----------------------------------------------------------------------------}	procedure EraseBoxes;{Erases boxes for traced character which appear for each terminal taxon}		var			TaxonHdl: thdl;			it: integer;			box: rect;			oldRgn: RgnHandle;	begin{if taxon is outside of screenR's clade, then all boxes set to 0011 by ZeroBoxes}		oldRgn := NewRgn;		GetClip(oldRgn);		if nex7on then			ClipRectOrient(treerect)		else			SetClip(TWClip);		for it := 1 to numtaxa do			if taxonintree(it) then				begin					TaxonHdl := gettaxonHdl(it);					box := taxonHdl^^.B;					InsetREct(box, -1, -1);{$IFC SHADOWTREE}					if shadowTree then						begin							box.right := box.right + 1;							box.bottom := box.bottom + 1;						end;{$ENDC}					EraserectOrient(box);				end;		SetClip(OldRgn);		ZapRegion(oldRgn);	end;{-----------------------------------------------------------------------------}	procedure EraseChar; {N : Nptr} {erases coloring of branches}		var			aN: nptr;			tport: WindowPtr;			tclip: RgnHandle;		procedure EraseCharRec (N: Nptr);		begin			if BranchExists(N) then				begin					aN := NotNullanc(N);					PenSizeOrient(edw, 1);{$IFC SQUAREBRANCHES}					if squarebranches then						begin							MoveToOrient(N^.loc.h, aN^.loc.v);							LineToOrient(N^.loc.h, N^.loc.v);						end					else						begin							MoveToOrient(aN^.loc.h, aN^.loc.v);							LineToOrient(N^.loc.h, N^.loc.v);						end;{$ELSEC}					MoveToOrient(aN^.loc.h, aN^.loc.v);					LineToOrient(N^.loc.h, N^.loc.v);{$ENDC}					PenSizeOrient(1, 1);					Penpat(QDBlack);					if (NodeIsTerminal(N)) then						begin							MoveToOrient(N^.loc.h, N^.loc.v);							LineToOrient(N^.loc.h + edw - 1, N^.loc.v);						end;				end;			if NodeIsInternal(N) then				begin					EraseCharRec(N^.lf);					EraseCharRec(N^.rt);				end;		end;	begin		genericGetPort(tport);		tclip := NewRgn;		GetClip(tclip);		genericSetPort(treewindow);		SetClip(TWClip);		if nex7on then			ClipRectOrient(treerect);		EraseCharRec(N);		if showNodeNumbers or showEvolveSegments or showEvolveRealLengths then			LabelTheNodes(screenR, treewindow, shownodenumbers, showEvolveSegments,showEvolveRealLengths);		SetClip(tclip);		ZapRegion(tclip);		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	procedure ColorAllStates;{This turns whole tree QDGray for trace All States}		var			tport: WindowPtr; {..............}		procedure colorgray (N: Nptr);		begin			if BranchExists(N) then				FillBranch(N, QDGray,nil,false);			if NodeIsInternal(N) then				begin					colorgray(N^.lf);					colorgray(N^.rt);				end;		end; {..............}	begin		genericGetPort(tport);		if BranchListon then			DrawBranchListWindow;		genericSetPort(treewindow);		SetClip(TWClip);		colorgray(ScreenR);		genericSetPort(tport);	end; {-----------------------------------------------------------------------------}	function LabelHoriz (N: Nptr; vpos: integer): integer;{gives horizontal position of ticks for Trace All Changes}		var			afn: Nptr;			posttemp: longint;	begin{$IFC SQUAREBRANCHES}		if not printon & squarebranches then			LabelHoriz := N^.loc.h		else{$ENDC}			if printon & laser^.square then				LabelHoriz := N^.loc.h			else				begin					afN := NotNullAnc(N);					posttemp := (-vpos);					posttemp := posttemp * (N^.loc.h - afN^.loc.h);					if NodeSlantsRight(N) then						LabelHoriz := N^.loc.h - (posttemp div (N^.loc.v - afN^.loc.v)) + 3					else						LabelHoriz := N^.loc.h - (posttemp div (N^.loc.v - afN^.loc.v));				end{    else if N^.slant = -1 then TickHoriz := N^.loc.h + vpos - 3 else TickHoriz := N^.loc.h - vpos - 3;}	end;{-----------------------------------------------------------------------------}	procedure CalcVertTickSpacings (N: NPtr; var vinc: integer; var vpos: longint);	var afN: Nptr;	begin		afN:= NotNullAnc(N);		if squarebranches & showbranchLengths & not printon & not branchlengthsWeighted then			vinc := branchLengthSpacing   {note if branchlengthsweighted we can't use this}		else			vinc := (afN^.loc.v - N^.loc.v) div (N^.chg + 1);		if printon | not (showbranchlengths & squarebranches) then			vpos := vinc		else if ticksNoNames then			vpos := screenExtraBranchLength		else			vpos := screenExtraBranchLength + vinc div 2;  {v3.02:   was just vpos := vinc;}	end;{-----------------------------------------------------------------------------}	procedure CalcTickBoundaries(N: Nptr; vpos: longint; var left,right: longint);	var overhang: integer;	begin		overhang := tickOverHang;		left := LabelHoriz(N, vpos) - overhang;		right := left + edw + overhang*2;			end;	{---------------------------------------------------------------------}	procedure DrawTickOrient (r: rect; h, v: integer; pat: pattern; color: RGBColor; tickClass: integer; tickAsLine: boolean);	var box: rect;		thePoly: PolyHandle;	begin		if tickAsLine then			begin				MoveToOrient(h, v);				if (ambigDistinguish & (tickClass=tickAmbiguous)) then					begin						PenSizeOrient(1, 1);						if ScreenInColor and not printon then							RGBForeColor(faintTextRGB);					end				else if showTickClass & (tickClass = tickUnique) then					PenSizeOrient(2,4)				else					PenSizeOrient(2, 2);				PenPat(pat);				RGBForeColor(color);				LineOrient(edw + 4, 0);				RGBForeColor(blackRGB);				MoveOrient(2, 2);				PenNormal;			end		else			begin				RGBForeColor(color);			{	RGBForeColor(GrayScale(ticksIndexColorLevels, TruncateValue(ticksIndexColorLevels * index)));}				PenSize(1,1);				if showTickClass then					DrawFancyTick(r,pat,tickClass)				else if (ambigDistinguish & (tickClass=tickAmbiguous)) then					begin						if not TicksAreColored then							RGBForeColor(faintTextRGB);						FillOval(OrientRect(r), pat);						RGBForeColor(faintTextRGB);						FrameOval(OrientRect(r));						RGBForeColor(blackRGB);					end				else					begin						FillRect(OrientRect(r), pat);						if colorTicksFramed then							RGBForeColor(blackRGB);						FrameRectOrient(r);					end;				PenNormal;				RGBForeColor(blackRGB);			end;				end;{-----------------------------------------------------------------------------}	procedure DrawTicksOnBranch(N: Nptr);	var		afN: NPtr;		vpos, v, h: longint;		vinc: integer;		 right: longint;		index: double;		thePen: Point;		box: rect;		tickClass, tickBelow,tickAbove, changeClass: integer;		hiliteUnique: boolean;		ic: integer;		ambigTick: boolean;		ds: str255;		info: FontInfo;		test : longint;	begin{v4: numChangesShown := numChangesShown + N^.length1; }		test := N^.loc.v;		//if (N^.loc.v > visTWR.bottom) then //  | (N^.loc.v<0) then 		//	Exit(DrawTicksOnBranch);		GetFontInfo(info);		afN := NotNullAnc(N);		CalcVertTickSpacings (N,vinc,vpos);		if N^.chg > maxChg then			maxChg := N^.chg;		for ic := 1 to numchars do			if CharIncluded(ic) & (typeofchar(ic) <> fisher) then				begin					if changetoshow(N, afN, ic, branchlistmode, false) then						begin							CalcTickBoundaries(N,vpos,h,right);							v := N^.loc.v + vpos;							if (not printon & (v > visTWR.bottom)) | (printon & (v > 32600))  then //  | (v<0) then 								Exit(DrawTicksOnBranch);							DetermineTickClass(N,ic,tickClass, tickBelow, tickAbove, changeClass);							ambigTick := ambigDistinguish & (tickClass = tickAmbiguous);							hiliteUnique := showTickClass & (tickClass=tickUnique);							SetRect(box, h, v - colorTicksBarWidth div 2, right, v + colorTicksBarWidth div 2);							{$IFC COLORTICKS}							case colorTicksClass of								colorTicksNone: 									DrawTickOrient (box,h,v,QDBlack,blackRGB,tickClass,not showTickClass);								colorTicksIndex: 									begin										if not MinMaxLenLegalChar(ic, minlength) | (not MinMaxLenLegalChar(ic, maxlength) & (colorTicksIndexClass in [colorTicksRI, colorTicksRC])) then											begin												DrawTickOrient (box,h,v,QDBlack,blackRGB,tickClass,not showTickClass)											end										else											begin												if colorTicksIndexClass = colorTicksRI then													index := getchhdl(ic)^^.ri												else if colorTicksIndexClass = colorTicksCI then													index := getchhdl(ic)^^.ci												else													index := getchhdl(ic)^^.ri * getchhdl(ic)^^.ci;												if ColorPort then													DrawTickOrient (box,0,0,QDBlack,ColorScaleForTicks(index),tickClass,false)												else if index = 1.0 then													DrawTickOrient (box,0,0,QDBlack,blackRGB,tickClass,false)												else if index >= 0.75 then													DrawTickOrient (box,0,0, QDdkGray,blackRGB,tickClass,false)												else if index >= 0.50 then													DrawTickOrient (box,0,0,QDGray,blackRGB,tickClass,false)												else if index >= 0.25 then													DrawTickOrient (box,0,0,QDltGray,blackRGB,tickClass,false)												else													DrawTickOrient (box,0,0,QDWhite,whiteRGB,tickClass,false);											end;									end;								colorTicksCodPos:									if nucleotides then										DrawTickOrient (box,h,v,QDBlack,CharCodonPosRGB(ic),tickClass,false)									else										DrawTickOrient (box,h,v,QDBlack,blackRGB,tickClass,not showTickClass);								colorTicksPartition:									DrawTickOrient (box,h,v,QDBlack,GetPartNameColor(CharPartition(ic)),tickClass,false);								colorTicksTiTv:									if nucleotides then										case changeClass of 											changeTransversion:												DrawTickOrient (box,h,v,QDBlack,blackRGB,tickClass,false);											changeTransition:												DrawTickOrient (box,h,v,QDBlack,GrayScale(10,0),tickClass,false);											otherwise												DrawTickOrient (box,h,v,QDBlack,GrayScale(2,1),tickClass,false);										end									else										DrawTickOrient (box,h,v,QDBlack,blackRGB,tickClass,not showTickClass);								otherwise									DrawTickOrient (box,h,v,QDBlack,blackRGB,tickClass,not showTickClass);							end;{$ELSEC}							DrawTickOrient (box,h,v,QDBlack,blackRGB,tickClass,not showTickClass);{$ENDC}							MoveToOrient(right+2, v + 2);							MoveOrient(1, 0);   {Pen is left exactly where text is to be drawn!!!}							if not ticksNoNames then								begin									if tickstates then										begin											ds := GetCharAndStates(N, getstslargest(afN, ic), getstslargest(N, ic), false, ic, ticknames);											PrepareCharAndStates(ds);										end									else										begin											ds := '';											if ticknames then												ds := charname(ic);											if ds = '' then												NumToString(ic, ds);										end;{$IFC FLIPTREE}									if treeflipped then										begin											h := h + info.ascent;											Move(0, 5);										end;{$ENDC}									if ambigdistinguish & (branchlistmode <> unambigmode) then  {v3.04:}										TextFace([]);  {v3.02: }									if ambigTick then										begin											if not ScreenInColor or printon then												TextFace([italic])											else if ScreenInColor then												RGBForeColor(faintTextRGB);										end									else if hiliteUnique then										if printon then											TextFace(laser^.fonts[treeB].face+[bold])										else											TextFace([bold]);{$IFC FALSE}									if tickboxes then										begin											h := h + edw + 8;											SetRect(box, h - 3, v - info.ascent + 1, h + Stringwidth(ds), v + 4);  {v3.04: changed box size}											EraseRectOrient(OrientBranchBoxRotate(box));										end;{$ENDC}									if tickboxes then   {v3.04}										begin											GetPen(thePen);											SetRect(box, thePen.h - 2, thePen.v - info.ascent - 1, thePen.h + Stringwidth(ds) + 2, thePen.v + info.descent);  {v3.04: changed box size}											EraseRectOrient(OrientBranchBoxRotate(box));										end;									DrawString(ds);{Note setting of TextFace a little complicated.  As it was, there was a bug,}{as, remember, in printing the user can set a TextFace for the branch labels to be something other than [],}{but because you had a simply TextFace([]), it always reset to [] after the first label was written}									if ambigdistinguish & (branchlistmode <> unambigmode) then										if printon then											TextFace(laser^.fonts[treeB].face)										else											TextFace([])									else if hiliteUnique then										TextFace([]);									if tickboxes then										FrameRectOrient(OrientBranchBoxRotate(box));									ForeColor(blackColor);   {v3.04: moved this here so boxes colored too}								end;							vpos := vpos + vinc;						end;				end;	end;{-----------------------------------------------------------------------------}	procedure ColorChanges;{whichport: WindowPtr}{Colors or places ticks or other information on branches for Trace All Changes}{N^.chg is the number of changes on the branch}{N^.length1 is the length of the branch {may be different because of weighting or stasis cost}		var			afN: Nptr;			 ir, h, v, ctyp,right: integer;			ds, dms: str255;			tport: WindowPtr;			box: rect;			info: FontInfo;			vpos: integer;			usepat: pattern;			minbrlengthreal, maxbrlengthreal: single;			usecolor: rgbcolor; {v4: minbrlength and maxbrlength are not used anywhere but ColorChanges, although they are globals}{..............}		procedure SetLengthCategories (N: Nptr);{Sets the categories for the legend, dividing into 10 the range of branchlengths}			var				ir: integer;			procedure findminmaxlengths (pN: NPtr);			begin				if BranchExists(pN) then					begin						if branchlistmode = minmaxmode then							begin								if pN^.lengthmean < minbrlengthreal then									minbrlengthreal := pN^.lengthmean;								if pN^.lengthmean > maxbrlengthreal then									maxbrlengthreal := pN^.lengthmean;							end						else if pN^.length1 < minbrlength then							minbrlength := pN^.length1;						if pN^.length1 > maxbrlength then							maxbrlength := pN^.length1;					end;				if NodeIsInternal(pN) then					begin						findminmaxlengths(pN^.lf);						findminmaxlengths(pN^.rt);					end;			end;		begin			minbrlength := 1000000;			maxbrlength := 0;			minbrlengthreal := 100000000.0;			maxbrlengthreal := 0;			findminmaxlengths(N);			if branchlistmode = minmaxmode then				begin					for ir := 0 to 9 do						categories[ir] := RoundValue((minbrlengthreal + (maxbrlengthreal - minbrlengthreal) / 10.0 * ir) * 1000.0);				end			else if maxbrlength < 10 then				for ir := 0 to 9 do					categories[ir] := ir			else if maxbrlength - minbrlength < 10 then  {v3.02:}				for ir := 0 to 9 do					categories[ir] := minbrlength + ir			else				for ir := 0 to 9 do					categories[ir] := minbrlength + (maxbrlength - minbrlength) div 10 * ir;		end;  {..............}		procedure MaxChgPass (N: Nptr);{Calculates maxChg, the maximum amount of change on branches in tree}		begin			if BranchExists(N) then				begin					if not PartOfPolytomy(N) or polyreal then						if N^.length1 > maxChg then							maxChg := N^.length1;				end;			if NodeIsInternal(N) then				begin					MaxChgPass(N^.lf);					MaxChgPass(N^.rt);				end;		end;{..............}		procedure ShowChgPass (N: Nptr);{Colors branch with darker shades to show more changes/amount of change}			var				ir, cat: integer;		begin			if NodeIsInternal(N) then				begin					ShowChgPass(N^.lf);					ShowChgPass(N^.rt);				end;			if BranchExists(N) then				begin					if PartOfPolytomy(N) and not polyreal then						FillBranch(N, equivocalPattern,equivocalPPH, false)					else						begin							cat := 0;							if branchlistmode = minmaxmode then								begin									if N^.lengthmean * 1000 > maxlongint then										cat := 9									else										for ir := 0 to 9 do											if RoundValue(N^.lengthmean * 1000) >= categories[ir] then												cat := ir;								end							else								begin									for ir := 0 to 9 do										if N^.length1 >= categories[ir] then											cat := ir;									if branchShades[curTrace] <> branchGrayScale then  {already calculated maxChg}										if N^.length1 > maxChg then											maxChg := N^.length1;								end;{numChangesShown := numChangesShown + N^.length1;  }{v4: use this to record total number of changes on showallchanges tree}							FindSummaryPat(usepat, usecolor, maxChg, cat);  {Note that maxChg is used only for printing, for which already calculated}							if branchShades[curTrace] = branchPatterns then								FillBranch(N, usepat,nil,false)							else								begin									RGBForeColor(usecolor);									FillBranch(N, QDBlack,nil,false);									RGBForeColor(blackRGB);								end;						end;				end;		end;{..............}		procedure ShowLengthNumPass (N: Nptr);{Places tick with box containing amount of change indicated}		begin			if BranchExists(N) then				begin					if PartOfPolytomy(N) and not polyreal then						begin							FillBranch(N, equivocalPattern,equivocalPPH,false);							ds := 'NC';    {v3.02:  note changed to NC rather than the too lengthy not calc.}						end					else						ds := NodeLengthString(N);					if ds <> '' then						begin							afN := NotNullAnc(N);							vpos := (afN^.loc.v - N^.loc.v) div 3;   {1/3 of way}							v := N^.loc.v + vpos;							h := LabelHoriz(N, vpos) - 3;							MoveToOrient(h, v - 4);							LineOrient(edw + 6, 0);							MoveToOrient(h, v - 2);							LineOrient(edw + 6, 0);							MoveToOrient(h, v);							LineOrient(edw + 6, 0);							MoveOrient(2, 2);							h := h + edw + 8;{$IFC FLIPTREE}							if treeflipped then								h := h + info.ascent;{$ENDC}							SetRect(box, h - 2, v - info.ascent + 2, h + Stringwidth(ds) + 1, v + 4);							EraseRectOrient(OrientBranchBoxRotate(box));{$IFC FLIPTREE}							if treeflipped then								Move(0, 5);{$ENDC}							TextFace([]);  {v3.02: }							DrawString(ds);							FrameRectOrient(OrientBranchBoxRotate(box));						end				end;			if NodeIsInternal(N) then				begin					ShowLengthNumPass(N^.rt);					ShowLengthNumPass(N^.lf);				end;		end;{..............}		procedure ShowTicksPass (N: Nptr);{places tick on branch for each character changing according to current criterion}			var				ic: integer;		begin			if BranchExists(N) and (N <> R) then				begin					if PartOfPolytomy(N) and not polyreal then						FillBranch(N, equivocalPattern,equivocalPPH,false)					else if (N^.chg > 0) then						DrawTicksOnBranch(N);				end;			if NodeIsInternal(N) then				begin					ShowTicksPass(N^.rt);					ShowTicksPass(N^.lf);				end;		end;{..............}	begin		genericGetPort(tport);		if BranchListon then			DrawBranchListWindow;		if whichport = treewindow then			begin				DropTool(treeTools,queryT);				DropTool(treeTools,traceTickT);			end;		genericSetPort(whichport);		GetFontInfo(info);		if not printon & (whichport = treewindow) then			SetClip(TWClip);	{	else			ClipRect(WindowPortRect(whichport));}		if branchlistmode = minmaxmode then			maxchg := 9		else			begin				maxChg := 0;				if branchShades[curTrace] = branchGrayScale then  {must know maxChg in advance}					MaxChgPass(R);   {v3.04: was screenR}				if maxChg > maxchangesshown then					maxChg := maxchangesshown;			end;		case summaryview of			asticks: 				begin					if not printon then  {v3.02: }						begin							TextFont(maccladesmall);							TextFace([]);						end;					GetFontInfo(info);					ShowTicksPass(ScreenR);					if not printon then  {v3.02: }						begin							TextFont(kFontIDGeneva);							TextFace(treetaxastyle);						end;				end;			aspattern: 				begin					SetLengthCategories(R);   {v3.04: was screenR}					ShowChgPass(ScreenR);				end;			asLengthNum: 				ShowLengthNumPass(ScreenR);			otherwise				;		end;		if maxChg > maxchangesshown then			maxChg := maxchangesshown;		if (whichport = treewindow) and (traceshown = traceAllChanges) then {and (summaryview = aspattern) }			begin				if not WindowVisible(chlegwindow) then					DrawCHLeg				else					InvalidateWindow(chlegwindow, true);			end;		genericSetPort(tport);		FixTreeShadingMenus;	end;{-----------------------------------------------------------------------------}	procedure ClipTreeRectBox (box: rect);		var			tempBox: rect;	begin		if not printon & SectRect(OrientRect(OrientBranchBoxRotate(box)), treerect, tempBox) then {the box and the tree rectangle intersect; they will not intersect if nex7on and tree scrolled}			ClipRectOrient(tempBox);   		{let's just draw in the part of the box visible on the tree.}	end;{-----------------------------------------------------------------------------}	procedure LabelTheNodes (N: Nptr; whichport: WindowPtr; labelNums, labelEvolveSegments, labelEvolveRealLengths: boolean);{Numbers nodes for list printing etc.}		var			tport: WindowPtr;			afN: Nptr;			v, h: integer;			info: FontInfo;			ds: str255;			box: rect;			numlabels : integer;{...........}		procedure LabelNode (N: NPtr; num, den: integer; dobox: boolean);		begin			afN := NotNullAnc(N);			v := N^.loc.v + (afN^.loc.v - N^.loc.v) * num div den;			h := LabelHoriz(N, (afN^.loc.v - N^.loc.v) * num div den + 1);			MoveToOrient(h, v);{$IFC FLIPTREE}			if treeflipped then				h := h + info.ascent;{$ENDC}			SetRect(box, h - 2, v - info.ascent + 1, h + Stringwidth(ds) + 1, v + 2);			ClipTreeRectBox(box);			if dobox then				begin					EraseRoundRect(OrientRect(box), 6, 6);					FrameRoundRect(OrientRect(box), 6, 6);				end			else				EraserectOrient(box);			DrawStringOrient(ds);		end;{...........}		procedure LabelTheNodesPass (N: Nptr);		begin			if BranchExists(N) then				begin					if labelNums then						begin							ForeColor(bluecolor);							NumToString(NumberOfNode(N), ds);							LabelNode(N, 1, 2, false);{note that will conflict with showtracelabels}						end;					if labelEvolveSegments then						begin							ForeColor(redcolor);							ds := StringFromNum(N^.setLength);{    ds := concat('s:', StringFromNum(N^.setLength));}							LabelNode(N, 2,3, true); 						end;					if labelEvolveRealLengths then						begin							ForeColor(greencolor);							RealToString(N^.realLength,ds,1000000,branchLengthSigDigits,false);							LabelNode(N, 4, 5, true)  						end;				end;			if NodeIsInternal(N) then				begin					LabelTheNodesPass(N^.lf);					LabelTheNodesPass(N^.rt);				end;		end;	begin {v4: allow change font of these}	{	numlabels := 0;		if labelNums then numlabels := numlabels+1;		if labelEvolveSegments then numlabels := numlabels+1;		if labelEvolveRealLengths then numlabels := numlabels+1;}				genericGetPort(tport);		genericSetPort(Whichport);		TextFace([]);		GetFontInfo(info);		LabelTheNodesPass(N);		ForeColor(blackcolor);		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	procedure ColorTraceLabels (whichport: WindowPtr);		var			afN: Nptr;			v, h, vpos: integer;			ds, ds2: str255;			info: FontInfo;			tport: WindowPtr;			box: rect;{..........}		procedure InColorNodeBoxes (var N: Nptr);		begin			if BranchExists(N) & not ((traceshown = traceProbability) & (NodeIsTerminal(N)) & (probRecitem in [stateexact, statenotwrong])) & not ((traceshown = traceProbability) & (N = R) & (probRecitem in [changecorrect, numchangeUnamb, numchangeAllowed])) & not ((traceshown = traceContinuous) & (((N = R) & (Continuousmode = squnrooted)) | ((continuousmode in [sqFelsContrast, sqFelsContrastSTD]) & NodeIsTerminal(N)))) then  {ввв}				begin					if (traceshown = traceDiscrete) then						ds := StsToString(AddUclToSet(N^.final, N, i), i, tracelabelsbyname,false)					else if (traceshown = traceContinuous) then						begin							RealToString(N^.finalC, ds, 1000, sigcontinuous, true);							if ((continuousmode = manhattan) & (abs(N^.finalC - N^.finalD) > 0.001)) then								begin									RealToString(N^.finalD, ds2, 1000, sigcontinuous, true);									ds := concat(ds, '-', ds2);								end;						end					else if (traceshown = traceProbability) then						begin							RealToString(N^.finalC, ds, 1000, 5, true);						end;					afN := NotNullAnc(N);					vpos := (afN^.loc.v - N^.loc.v) div 3;					v := N^.loc.v + vpos;					h := LabelHoriz(N, vpos) + edw - (stringwidth(ds) div 2);{$IFC FLIPTREE}					if treeflipped then						h := h + info.ascent;{$ENDC}					SetRect(trect, h - 2, v - info.ascent + 1, h + Stringwidth(ds) + 1, v + 3);					ClipTreeRectBox(trect);					EraseRectOrient(OrientBranchBoxRotate(trect));					MoveToOrient(h, v);{$IFC FLIPTREE}					if treeflipped then						Move(0, 5);{$ENDC}					DrawString(ds);					FrameRectOrient(OrientBranchBoxRotate(trect));				end;			if (NodeIsInternal(N)) then				begin					InColorNodeBoxes(N^.lf);					InColorNodeBoxes(N^.rt);				end;		end;{..........}	begin		genericGetPort(tport);		genericSetPort(Whichport);		TextFace([]);		GetFontInfo(info);		InColorNodeBoxes(screenR);		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	procedure ColorContinuous (leavecurrentPort: boolean);		var			ir: integer;			tport: windowptr;		//	WP: WindowPeek;			oldRgn: RgnHandle;			cat: integer;			usepat: pattern;			usecolor: RGBColor;		procedure SetCategories (N: Nptr);			var				ir: integer;			procedure findminmaxcont (pN: NPtr);			begin				if BranchExists(pN) and not (((pN = R) and (continuousmode = squnrooted)) or (NodeIsTerminal(pN) and (continuousmode in [sqFelsContrast, sqFelsContrastSTD]))) then {ввв}					begin						if pN^.finalC < mincont then							mincont := pN^.finalC;						if ContinuousIsManhattan then {ввв}							begin								if pN^.finalD > maxcont then									maxcont := pN^.finalD;							end						else							begin								if pN^.finalC > maxcont then									maxcont := pN^.finalC;							end;					end;				if NodeIsInternal(pN) then					begin						findminmaxcont(pN^.lf);						findminmaxcont(pN^.rt);					end;			end;		begin			mincont := 1000000.0;			maxcont := 0.0;			findminmaxcont(N);			for ir := 0 to 9 do				realcategories[ir] := mincont + (maxcont - mincont) / 10.0 * ir;		end;		procedure ColorTreeContinuous (N: Nptr);			var				ir: integer;				catC, catD: integer;		begin			if NodeIsInternal(N) then				begin					ColorTreeContinuous(N^.lf);					ColorTreeContinuous(N^.rt);				end;			if BranchExists(N) then				begin					catC := 0;					catD := 0;					for ir := 0 to 9 do						begin							if N^.finalC > realcategories[ir] then								catC := ir;							if ContinuousIsManhattan & (N^.finalD > realcategories[ir]) then {ввв}								catD := ir;						end;					if (ContinuousIsManhattan & (catC <> catD)) | ((N = R) & not NodeIsPolytomous(R) & (continuousmode = squnrooted)) | (NodeIsTerminal(N) & (continuousmode in [sqFelsContrast, sqFelsContrastSTD])) then  {ввв}						FILLBranch(N, equivocalPattern,equivocalPPH,false)  {ввв}					else						begin							FindSummaryPat(usepat, usecolor, continuousBoxes - 1, catC);							if branchShades[curTrace] = branchPatterns then								FillBranch(N, usepat,nil,false)							else								begin									RGBForeColor(usecolor);									FillBranch(N, QDBlack,nil,false);									RGBForeColor(blackRGB);								end;						end;				end;		end;	begin		if not leavecurrentport then			begin				CheckPixelDepth(treewindow);				genericGetPort(tport);				genericSetPort(treewindow);				oldRgn := NewRgn;				GetClip(oldRgn);				setcursor(clockCursor);				if nex7on then					ClipRectOrient(treerect)				else					SetClip(TWClip);			end;		setCategories(R);   {v3.04: was screenR}		ColorTreeContinuous(ScreenR);		if not WindowVisible(chlegwindow) then			DrawCHLeg;		if not leavecurrentport then			begin				SetClip(oldRgn);				ZapRegion(oldRgn);				genericSetPort(tport);			end;	end;{-----------------------------------------------------------------------------}	procedure ReShadeTree;	begin		if (traceshown = traceDiscrete) then			ColorChar		else if (traceshown = traceAllChanges) then			ColorChanges(treewindow)		else if (traceshown = traceAllStates) then			ColorAllStates		else if (traceshown = traceContinuous) then			ColorContinuous(false);		if showNodeNumbers or showEvolveSegments or showEvolveRealLengths then			LabelTheNodes(screenR, treewindow, shownodenumbers, showEvolveSegments, showEvolveRealLengths);		if ((traceshown = traceDiscrete) & showtracelabels) | ((traceshown = traceContinuous) & ShowContTraceLabels) | ((traceshown = traceProbability) & ShowProbTraceLabels) then			ColorTraceLabels(treewindow);	end;{-----------------------------------------------------------------------------}	procedure InFlashFix (N: Nptr);{FROZEN 3.0}	begin		if N^.fix then			FillBranch(N, dashpat,dashpatPPH,false);		if NodeIsInternal(N) then			begin				InFlashFix(N^.lf);				InFlashFix(N^.rt);			end;	end;	procedure FlashFix;		var			tport: WindowPtr;			j: integer;			oldRgn: RgnHandle;	begin		if fixon then			begin				genericGetPort(tport);				genericSetPort(treewindow);				OldRgn := NewRgn;				GetClip(oldRgn);				SetDataBoxesClip;				Penmode(patXOR);				PenPat(pat[7]);				for j := 1 to 4 do					begin						InFlashFix(screenR);						delay(5, ticks);						InFlashFix(screenR);						delay(5, ticks);					end;				PenNormal;				SetClip(oldRgn);				ZapRegion(oldRgn);				genericSetPort(tport);			end;	end;{-------------------------------------------------------------------------}	procedure FlashBranch; {(N : Nptr);}		var			aN: Nptr;			OldRgn: RgnHandle;	begin		OldRgn := NewRgn;		GetClip(oldRgn);		SetDataBoxesClip;		aN := NotNullAnc(N);{$IFC SQUAREBRANCHES}		if squarebranches then			begin				MoveToOrient(N^.loc.h, N^.loc.v);				LineToOrient(n^.loc.h, aN^.loc.v);				MoveToOrient(N^.loc.h + edw - 1, N^.loc.v);				LineToOrient(n^.loc.h + edw - 1, aN^.loc.v);			end		else			begin				MoveToOrient(N^.loc.h, N^.loc.v);				LineToOrient(an^.loc.h, aN^.loc.v);				MoveToOrient(N^.loc.h + edw - 1, N^.loc.v);				LineToOrient(an^.loc.h + edw - 1, aN^.loc.v);			end;{$ELSEC}		MoveToOrient(N^.loc.h, N^.loc.v);		LineToOrient(an^.loc.h, aN^.loc.v);		MoveToOrient(N^.loc.h + edw - 1, N^.loc.v);		LineToOrient(an^.loc.h + edw - 1, aN^.loc.v);{$ENDC}		SetClip(oldRgn);		ZapRegion(oldRgn);	end;{-----------------------------------------------------------------------------}	procedure AllStatesLabelDLOG;		var			theDialog: DialogPtr;			tempP: WindowPtr;			oldBranchListByNames: boolean;			localItemHit: integer;			d1, d2: longint;{......}	begin		oldBranchListByNames := BranchListStatesByNames;		StartDLOG(138, theDialog, tempP);		ItemCheckMark(theDialog, 3, BranchListStatesByNames);		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			case localItemHit of				3: 					BranchListStatesByNames := not BranchListStatesByNames;				5: 					SetDialogValuesAsDefaults(theDialog, AllStatesBranchLabelID, 0, 0);				otherwise					;			end;			ItemCheckMark(theDialog, 3, BranchListStatesByNames);		until localItemHit in [1, 2];		EndDLOG(theDialog, tempP);		if localItemHit = 2 then			BranchListStatesByNames := OldBranchListByNames		else if (BranchListStatesByNames <> oldBranchListByNames) then			if BranchListon then				begin					MakeBranchList(BranchListN, d1, d2, 0, 0, listToWindow);					InvalidateWindow(branchlistwindow, true);				end;	end;{-----------------------------------------------------------------------------}	procedure ContTraceLabelDLOG;		var			theDialog: DialogPtr;			tempP: WindowPtr;			oldShowTraceLabels: boolean;			localItemHit: integer;			oldRoom: integer;{......}	begin		oldRoom := RoomNeededOnRight;		oldShowTraceLabels := ShowContTraceLabels;		StartDLOG(133, theDialog, tempP);		ItemCheckMark(theDialog, 3, ShowContTraceLabels);		myShowDialog(theDialog);		FrameButton(theDialog, 1);		if printon then			HideControl(controlHandle(GetDLOGItemHandle(theDialog, 5)));  {hiding save preferences button}		repeat			ModalDialog(nil, localItemHit);			case localItemHit of				3: 					ShowContTraceLabels := not ShowContTraceLabels;				5: 					SetDialogValuesAsDefaults(theDialog, contBranchLabelID, 0, 0);				otherwise					;			end;			ItemCheckMark(theDialog, 3, ShowContTraceLabels);		until localItemHit in [1, 2];		EndDLOG(theDialog, tempP);		if localItemHit = 2 then			ShowContTraceLabels := oldShowTraceLabels		else if (ShowContTraceLabels <> oldShowTraceLabels) then			begin				godraw := true;				InvalidateWindow(chlegwindow, true);				if (oldroom > RoomNeededOnRight) & (TWOrigin.h > RoomNeededOnRight) then					ZeroTreeOrigin;			end;	end;{-----------------------------------------------------------------------------}	procedure CharTraceLabelDLOG;		var			theDialog: DialogPtr;			tempP: WindowPtr;			oldShowTraceLabels, oldshowfix, oldchlegbynames, oldtracelabelsbyname: boolean;			localItemHit: integer;			oldRoom: integer;{......}		procedure CheckBranchLabel;		begin			ItemCheckMark(theDialog, 8, tracelabelsbyname);			ItemCheckMark(theDialog, 10, chlegbynames);			ItemCheckMark(theDialog, 3, ShowTraceLabels);			ItemCheckMark(theDialog, 4, showfix);			EnableDisableDLOGItem (theDialog,8,ShowTraceLabels,false);		end;{......}	begin		oldRoom := RoomNeededOnRight;		oldchlegbynames := chlegbynames;		oldtracelabelsbyname := tracelabelsbyname;		oldShowTraceLabels := ShowTraceLabels;		oldshowfix := showfix;		StartDLOG(135, theDialog, tempP);		CheckBranchLabel;		myShowDialog(theDialog);		if printon then			HideControl(controlHandle(GetDLOGItemHandle(theDialog, 6)));  {hiding save preferences button}		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			case localItemHit of				3: 					ShowTraceLabels := not ShowTraceLabels;				4: 					showfix := not showfix;				8: 					tracelabelsbyname := not tracelabelsbyname;				10: 					chlegbynames := not chlegbynames;				6: 					SetDialogValuesAsDefaults(theDialog, BranchLabelID, 0, 0);				otherwise					;			end;			CheckBranchLabel;		until localItemHit in [1, 2];		EndDLOG(theDialog, tempP);		if localItemHit = 2 then			begin				showfix := oldshowfix;				ShowTraceLabels := oldShowTraceLabels;				tracelabelsbyname := oldtracelabelsbyname;				chlegbynames := oldchlegbynames;			end		else			begin  {(traceshown = traceDiscrete) must be one; see menu}				if (ShowTraceLabels <> oldShowTraceLabels) | (oldtracelabelsbyname <> tracelabelsbyname) | (fixon & (showfix <> oldshowfix)) then					godraw := true;				if (oldchlegbynames <> chlegbynames) or (ShowTraceLabels <> oldShowTraceLabels) or (oldtracelabelsbyname <> tracelabelsbyname) then					InvalidateWindow(chlegwindow, true);				if (oldroom > RoomNeededOnRight) & (TWOrigin.h > RoomNeededOnRight) then					ZeroTreeOrigin;			end;	end;{-----------------------------------------------------------------------------}end.