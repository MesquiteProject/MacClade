unit WriteData;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface, 		 MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, SymbolsNames, 		 TreeUtil, ReadMisc, TypeUtil, Thermos, CharUtil, LinkUtil, WriteTreeFile, SpreadUtil, DrawSpread, Windows, 		 WriteDataUtil, ReadWriteUtil, ReadUtil, WriteUtil, NexusBlocks, PrintingUtil;	procedure WriteFile(writeNotes,writeTrees, writeForeign: boolean);	procedure SaveAsFile;	procedure SaveFile;{еееееееееееееееееееееее}implementation {е$S WriteData}	var		longesttaxname, longestcharname: integer;		totconstant: integer;{$SETC WRITEUSERSTAMP=TRUE}{$SETC STARCONST=FALSE}{$IFC STARCONST}{-----------------------------------------------------------------------------}	procedure StarConstant (icstart, icend: integer);		var			it, ic: integer;			ds: str255;			writestar: boolean;			tsts: LargestSetChars;	begin		putreturn;		putSingleChar('[');		ds := 'Const                           ';		delete(ds, longesttaxname + 2, length(ds) - longesttaxname - 1);		puttoken(ds);		for ic := icstart to icend do			begin				if CharConstant(ic) then					begin						tsts := gettaxonstsLargest(1, ic);						writestar := true;						for it := 2 to numtaxa do							if gettaxonstsLargest(it, ic) <> tsts then  {is diversity, don't write *}								begin									writestar := false;									leave;								end;						if writestar then							begin								putSingleChar('*');								totconstant := totconstant + 1;							end						else							putSpace;					end				else					putSpace;{$IFC    SPACETRIPLETS}				if spacetriplets & nucleotides & (ic < icEnd) & (CharCodPos(ic) = 3) then					putSpace				else{$ENDC}					if spaceEveryTenth & (ic mod 10 = 0) & (ic <> icstart) & (ic < icEnd) then						putSpace;			end;		putSingleChar(']');		putreturn;		if icend = numchars then			begin				puttoken('[ Total Constant: ');				puttoken(StringFromNum(totconstant));				putSingleChar(']');				putreturn;			end;	end;{$ENDC}{$IFC SPACETRIPLETS}{-----------------------------------------------------------------------------}	procedure FindNearest3rdPosition (var icend: integer);{if in a non-coding region, leaves where it is}{note that if not in simple triplets, then doesn't necessarily break after thirds}	begin		if icend > numchars then			icend := numchars;		if CharCodPos(icend) = 1 then			icend := icend - 1		else if CharCodPos(icend) = 2 then			begin				icend := icend + 1;				if icend > numchars then					icend := numchars;			end;	end;{$ENDC}{-----------------------------------------------------------------------------}	procedure WriteConsensusToNexusFile (consensusNumber, icstart, icend: integer);	var		ic, it: integer;		tsts: LargestSetChars;		dataFraction: double;		trueMajority: boolean;		ds: str255;	begin		putSingleChar('[');		ds := GetConsensusName(consensusNumber);		ds := concat (ds, '                                       ');		delete(ds, longesttaxname + 2, length(ds) - longesttaxname - 1);		puttoken(ds);		for ic := icstart to icend do			begin				tsts := GetConsensusSet(consensusNumber,ic,consensusNumber=1,false,trueMajority,[],dataFraction);				if tsts <> [] then					begin						ds := StsToString(tsts, ic, editorShowFullStateNames & not nucleotides,nucleotides);						putToken(ds);					end				else putSpace;			end;		putSingleChar(']');		putreturn;	end;{-----------------------------------------------------------------------------}	procedure WriteMatrix;		var			it, ic, j, k, icstart, icend, numblocks, halftaxa, halfchars: integer;			salt: boolean;			tot: longint;			ds: str255;			writemissing, writematchchar, writegap: char;			tsts: largestsetchars;			cmaxst: SignedByte;			taxonHdl: thdl;{...................................}		procedure WriteSTS(cmaxst: SignedByte);			var				c: char;		begin			tsts := gettaxonstsLargest(it, ic);			if molecular & not (gal in tsts) then				taxonHdl^^.nonGaps := taxonHdl^^.nonGaps + 1;  {another non-gap to add to total for current taxon}			StateSetToNexusStates(tsts,it,ic,cmaxst,matchcharon,writemissing,writegap,writematchchar,c,ds);			if c=chr(13) then				putToken(ds)			else				putSingleChar(c);{$IFC FALSE}			if tsts = [MSl] then				putSingleChar(writemissing)			else if tsts = [msl, gal] then				putSingleChar(writegap)			else if matchcharon & (it <> 1) & (tsts = gettaxonstsLargest(1, ic)) then				putSingleChar(writematchchar)			else if nucleotides then	{@@@@@  DNA RNA @@@@@}				begin					if not (UCl in tsts) & (mstaxa = mstVariable) & (MultipleStatesLg(tsts)) then						WritePolySTS(tsts,cmaxst)					else						putSingleChar(DNARNACharOfSet(tsts));				end			else if datatype = protein then			{@@@@@  protein @@@@@}				begin					c := ProteinCharOfSet(tsts);					if c = '?' then						WritePolySTS(tsts,cmaxst)					else						putSingleChar(c)				end			else if MonomorphLg(tsts) then			{@@@@@  standard @@@@@}				begin					j := minLg(tsts);					putSingleChar(CharOfNum(j));				end			else				WritePolySTS(tsts,cmaxst);{$ENDC}		end;{...................................}		procedure WriteHeader (thestart, theend: integer);			var				j, k, m, skipped, HeaderLines, oldj,consensusNumber: integer;				emptyskips: integer;				maxTaxonNameBlank: str255;		begin			if saveAbbrevHeader then				HeaderLines := 1			else				HeaderLines := OrderOfMag(theend);			maxTaxonNameBlank := ' ';			for k := 1 to longestTaxName+1 do				maxTaxonNameBlank := concat(maxTaxonNameBlank,' ');			for k := HeaderLines downto 0 do				begin					putSingleChar('[');					ds := maxTaxonNameBlank;					if not editorTransposed then						delete(ds, longesttaxname + 2, length(ds) - longesttaxname - 1)					else						delete(ds, longestcharname + 2, length(ds) - longestcharname - 1);					puttoken(ds);					if not SaveAbbrevHeader then						begin							for j := thestart to theend do								begin									if (j mod Exp10(k) = 0) | ((j = thestart) & (j > Exp10(k))) then										begin											NumToString((j div Exp10(k)) mod 10, ds);											puttoken(ds);										end									else										putSpace;{$IFC    SPACETRIPLETS}									if spacetriplets & nucleotides & (CharCodPos(j) = 3) then										putSpace									else{$ENDC}										if spaceEveryTenth & (j mod 10 = 0) & (j <> thestart) & (j <> theEnd) then											putSpace;								end						end					else						begin							j := thestart;							while j <= theend do								begin									oldj := j;									emptyskips := 0;									if j mod 10 = 0 then										begin											if k = 1 then												NumToString(j, ds)											else												ds := '.';											puttoken(ds);											j := j + length(ds);											for skipped := oldj to j - 2 do{$IFC    SPACETRIPLETS}												if spacetriplets & nucleotides then													begin														if (skipped <= numchars) & (CharCodPos(skipped) = 3) then															emptyskips := emptyskips + 1;													end												else{$ENDC}													if spaceEveryTenth & (skipped mod 10 = 0) & (skipped <> thestart) & (skipped < theEnd) then														emptyskips := emptyskips + 1;											j := j - emptyskips;										end									else										begin											putSpace;											j := j + 1;										end;{$IFC    SPACETRIPLETS}									if spacetriplets & nucleotides & (j < theEnd) & (CharCodPos(j) = 3)  then										putSpace									else{$ENDC}										if spaceEveryTenth & (j mod 10 = 0) & (j <> thestart) & (j <> theEnd) then											putSpace;								end;						end;					putSingleChar(']');					putReturn;				end;			putReturn;			if not editorTransposed & ConsensusSequenceVisible then				begin					for consensusNumber := 1 to editorNumConsensusSequences do						WriteConsensusToNexusFile(consensusNumber,thestart, theend);					putreturn;				end;		end;{||||||||||||||||||||||||||||||||||||||||||||}	begin		totconstant := 0;		halftaxa := numtaxa div 2;		halfchars := numchars div 2;		SetCursID(carabid);		putReturn;		PutTokenReturn('MATRIX');		CalcSolidIOSymbols(writemissing,writegap,writematchchar);				if molecular then			for it := 1 to numtaxa do				begin					TaxonHdl := getTaxonHdl(it);					taxonHdl^^.nonGaps := 0;  {v3.01: used nonGaps rather than tipNumbers[0], thus avoiding the bug}													{caused when states chart was on screen and file was saved}				end;{======== interleaved matrix ========}		if interleave then			begin				salt := true;				numblocks := numchars div interleavelength;				if (numchars mod interleavelength <> 0) then					numblocks := numblocks + 1;				icend := 0;				for k := 1 to numblocks do					begin						if icend >= numchars then							leave;						salt := not salt;						if salt then							SetCursID(salticid)						else							SetCursID(carabid);						icstart := icend + 1;						icend := icstart + interleavelength - 1;{$IFC SPACETRIPLETS}						if spacetriplets & nucleotides then							FindNearest3rdPosition(icend);{$ENDC}						if icend > numchars then							icend := numchars;						putReturn;						if not mst or molecular then							WriteHeader(icstart, icend);						for it := 1 to numtaxa do							begin								WriteUnit := WriteUnit + 1;								if 1.0 * writeUnit / totwriteunits > 0.96 then									begin									end;								UpdateThermo(iothermo, 0, WriteUnit, TotWriteUnits,true);								ds := TaxonName(it);								PrepareToken(ds, tnw);{    if ItalicTaxon(it) then ds := concat(ds, MCFlagString);}								if ItalicTaxon(it) then									ds := concat('[\i]', ds, '[\p]');								ds := concat(ds, '                                   ');								delete(ds, longesttaxname + 2, length(ds) - longesttaxname - 1);								Puttoken(ds);								putSpace;								TaxonHdl := getTaxonHdl(it);								for ic := icstart to icend do									begin										cmaxst := CharMaxstOBS(ic);										WriteSTS(cmaxst);										if ErrorFlag then											Exit(WriteMatrix);{$IFC    SPACETRIPLETS}										if spacetriplets & nucleotides & (CharCodPos(ic) = 3) then											putSpace										else{$ENDC}											if spaceEveryTenth & (ic mod 10 = 0) & (ic <> icstart) & (ic <> icEnd) then												putSpace;									end;								if molecular then   {write the number of non-gap elements here}									begin										PutToken('   [');										Puttoken(StringFromNum(taxonHdl^^.nonGaps));										putSingleChar(']');									end;								putReturn;							end;{$IFC STARCONST}						if molecular then							StarConstant(icstart, icend);{$ENDC}					end			end		else if not editorTransposed then{======== normal matrix ========}			begin				if not mst or molecular then					WriteHeader(1, numchars);				for it := 1 to numtaxa do					begin						WriteUnit := WriteUnit + 1;						UpdateThermo(iothermo, 0, WriteUnit, TotWriteUnits,true);						if it = halftaxa then							SetCursID(salticid);						ds := TaxonName(it);						PrepareToken(ds, tnw);{if ItalicTaxon(it) then ds := concat(ds, MCFlagString);}						if ItalicTaxon(it) then							ds := concat('[\i]', ds, '[\p]');						ds := concat(ds, '                                   ');						delete(ds, longesttaxname + 2, length(ds) - longesttaxname - 1);						Puttoken(ds);						putSpace;						TaxonHdl := getTaxonHdl(it);						for ic := 1 to numchars do							begin								cmaxst := CharMaxstOBS(ic);								WriteSTS(cmaxst);								if ErrorFlag then									Exit(WriteMatrix);{$IFC SPACETRIPLETS}								if spacetriplets & nucleotides & (CharCodPos(ic) = 3) then									putSpace								else{$ENDC}									if spaceEveryTenth & (ic mod 10 = 0) & (ic <> 1) & (ic <> numchars) then										putSpace;							end;						if molecular then   {write the number of non-gap elements here}							begin								PutToken('   [');								Puttoken(StringFromNum(taxonHdl^^.nonGaps));								putSingleChar(']');							end;						putReturn;					end;{$IFC STARCONST}				if molecular then					StarConstant(1, numchars);{$ENDC}			end{========= transposed matrix =========}		else			begin				if not mst or molecular then					WriteHeader(1, numtaxa);				for ic := 1 to numchars do					begin						WriteUnit := WriteUnit + 1;						UpdateThermo(iothermo, 0, WriteUnit, TotWriteUnits, true);						if ic = halfchars then							SetCursID(salticid);						ds := CharName(ic);						PrepareToken(ds, cnw);						ds := concat(ds, '                                   ');						delete(ds, longestcharname + 2, length(ds) - longestcharname - 1);						Puttoken(ds);						putSpace;						cmaxst := CharMaxstOBS(ic);						for it := 1 to numtaxa do							begin								WriteSTS(cmaxst);								if ErrorFlag then									Exit(WriteMatrix);{$IFC SPACETRIPLETS}								if spacetriplets & nucleotides & (CharCodPos(ic) = 3) then									putSpace								else{$ENDC}									if spaceEveryTenth & (it mod 10 = 0) & (it <> 1) & (it <> numtaxa) then										putSpace;							end;						putReturn;					end;			end;		putSingleChar(';');		putReturn;	end;{-----------------------------------------------------------------------------}	function ContinuousDataValid (taxonHdl: tHdl; ic: integer; isMin: boolean): boolean;	begin		if isMin then			ContinuousDataValid := (taxonhdl^^.contsmin[ic] > -0.000001) and (taxonhdl^^.contsmin[ic] < 9999.999)		else			ContinuousDataValid := (taxonhdl^^.contsmax[ic] > -0.000001) and (taxonhdl^^.contsmax[ic] < 9999.999);	end;{-----------------------------------------------------------------------------}	function SomeContinuousRanges: boolean;   {v3.05}		label			1;		var			it, ic: integer;			taxonHdl: tHdl;			someranges: boolean;	begin		someranges := false;		for it := 1 to numtaxa do			begin				taxonHdl := getTaxonHdl(it);				for ic := 1 to numcontinuous do					begin						if ContinuousDataValid(taxonhdl, ic, true) & ContinuousDataValid(taxonhdl, ic, false) then							begin								someRanges := true;								goto 1;							end;					end;			end;1:		SomeContinuousRanges := someRanges;	end;{-----------------------------------------------------------------------------}	procedure WriteContinuousBlock(theNexusBlock: NexusBlockPtr);		var			TaxonHdl: thdl;			it, ic: integer;			ds, rs: str255;			someRanges: boolean;	begin		if fullNexus1 then			someRanges := SomeContinuousRanges;		if fullNexus1 then  {v3.05}			PutTokenReturn('BEGIN CHARACTERS;')		else			PutTokenReturn('BEGIN CONTINUOUS;');		WriteNexusBlockTitle(theNexusBlock);		WriteNexusBlockLinkText(theNexusBlock);		putTab;		PutTokenReturn(concat('DIMENSIONS NCHAR=', StringFromNum(numcontinuous), ' ;'));		PutTabToken('FORMAT DATATYPE=CONTINUOUS');		putTab;		if fullNexus1 & someRanges then			PutTokenReturn(' ITEMS=(MIN  MAX);')		else			PutTokenReturn(';');		WriteForeignLinesInBlock(continuousBlock);		SetCursID(owlfly);		PutTokenReturn('MATRIX');		for it := 1 to numtaxa do			begin				ds := TaxonName(it);				PrepareToken(ds, tnw);				ds := concat(ds, '                                   ');				delete(ds, longesttaxname + 2, length(ds) - longesttaxname - 1);				Puttoken(ds);				TaxonHdl := GetTaxonHdl(it);				for ic := 1 to numcontinuous do					begin						puttab;						if ContinuousDataValid(taxonhdl, ic, true) then							begin								if fullNexus1 & someRanges then									putSingleChar('(');								RealTostring(taxonhdl^^.contsmin[ic], ds, 10000, 4, true);								if ContinuousDataValid(taxonhdl, ic, false) then									begin										RealTostring(taxonhdl^^.contsmax[ic], rs, 10000, 4, true);										if fullNexus1 then											ds := concat(ds, ' ', rs)										else											ds := concat(ds, ' - ', rs);									end								else if fullNexus1 & someRanges then									begin										RealTostring(taxonhdl^^.contsmin[ic], rs, 10000, 4, true);  {TRANSFER:}										ds := concat(ds, ' ', rs);									end;								puttoken(ds);								if fullNexus1 & someRanges then									putSingleChar(')');							end						else if fullNexus1 & someRanges then  {TRANSFER:}							puttoken('(? ?)')						else							putSingleChar('?');					end;				putReturn;			end;		putSingleChar(';');		putReturn;		putEndofBlock;	end;{-----------------------------------------------------------------------------}	procedure WriteDataBlockStart (ds: str255; blockType: integer; dotax, dochar, dofilecomments: boolean);	var theNexusBlock: NexusBlockPtr;	begin		puttoken('BEGIN ');		puttoken(ds);		putSingleChar(';');		putReturn;		theNexusBlock := NexusBlockFromBlockType(blockType);		WriteNexusBlockTitle(theNexusBlock);		WriteNexusBlockLinkText(theNexusBlock);		putTabToken('DIMENSIONS ');		if dotax then			puttoken(concat(' NTAX=', StringFromNum(numtaxa)));		if dochar then			puttoken(concat(' NCHAR=', StringFromNum(numchars)));		putSingleChar(';');		putReturn;{==== filecomments ====}		if dofilecomments then			if textWindowInfo[aboutFileText]^.TE^^.teLength > 0 then				begin					putReturn;					puttoken('[!');					WriteTE(textWindowInfo[aboutFileText]^.TE, true);					putSingleChar(']');					PutReturn;				end;	end;{----------------------------------------------------------------------------}	procedure WriteTypeSet (extendH: Handle);  {converts Type in extended form (extendH) to Type in compact form (compactH)}		var			modalChar, cr, ic: integer;			firstwritten, foundone: boolean;			ctypP: IP;			offset: integer;			oldState: SignedByte;	begin		firstwritten := false;		LockHandle(extendH, oldState);		offset := LinkOffset(extendH);		for cr := 1 to numtypes do			begin				foundone := false;				ic := 1;				ctypP := IP(GetMaster(extendH) + offset);				while not foundone and (ic <= numchars) do					begin						if ctypP^ = cr then							foundone := true;						ic := ic + 1;						ctypP := IP(ord4(ctypP) + chtb);					end;				if foundone then					begin						if firstwritten then							putToken(', ');						putToken(TypeNameToWrite(cr));						putSingleChar(':');						WriteCharTaxList(extendH, cr, chtb, true);						firstwritten := true;					end;			end;		ResetHandle(extendH, oldState);	end;{----------------------------------------------------------------------------}	procedure WriteWtSet (extendH: Handle);		var			charHdl: chHdl;			wt, ic, decimalwt: integer;			firstwt: boolean;			cwtP: IP;			offset: integer;			ds: str255;			oldState: SignedByte;			oldrealwt: boolean;	begin		oldrealwt := realwt;		realwt := TestLinkBit(0,0,extendH,wtrealbit);		firstwt := true;		LockHandle(extendH, oldState);		offset := LinkOffset(extendH);		ZeroCharExtra;		ic := 0;		while ic <= numchars do			begin				repeat					ic := ic + 1;					if ic > numchars then						leave;					charHdl := GetChHdl(ic);				until not charHdl^^.extra;				if ic > numchars then					leave;				wt := IP(GetMaster(extendH) + offset + chwb * longint(ic - 1))^;				if not firstwt then					putToken(', ');				firstwt := false;{decimalwt := wt - (wt div 100) * 100;}				if realwt then					begin						decimalwt := wt mod WtInflate;						if decimalwt < 10 then							ds := concat(StringFromNum(wt div WtInflate), '.0', StringFromNum(decimalwt))						else							ds := concat(StringFromNum(wt div WtInflate), '.', StringFromNum(decimalwt));					end				else					NumToString(wt, ds);				putToken(ds);				putSingleChar(':');				WriteCharTaxList(extendH, wt, chwb, true);			end;		ResetHandle(extendH, oldState);		realwt := oldrealwt;	end;{----------------------------------------------------------------------------}	procedure WriteCharPart (extendH: Handle);		var			charHdl: chHdl;			part, ic: integer;			firstpart: boolean;			cpartP: IP;			offset: integer;			ds: str255;			oldState: SignedByte;	begin		firstpart := true;		LockHandle(extendH, oldState);		offset := LinkOffset(extendH);		ZeroCharExtra;		ic := 0;		while ic <= numchars do			begin				repeat					ic := ic + 1;					if ic > numchars then						leave;					charHdl := GetChHdl(ic);				until not charHdl^^.extra;				if ic > numchars then					leave;				part := IP(GetMaster(extendH) + offset + chpartb * longint(ic - 1))^;				if not firstpart then					putToken(', ');				firstpart := false;				ds := NameOfCharPartNameFromNumber(part);				PrepareToken(ds,maxtok);				putToken(ds);				putSingleChar(':');				WriteCharTaxList(extendH, part, chpartb, true);			end;		ResetHandle(extendH, oldState);	end;{----------------------------------------------------------------------------}	procedure WriteStartLink (chainName, formatName, linkName: str255; writestar: boolean);	begin		puttoken(chainName);		if writeStar then			puttoken('*');		putSpace;		PrepareToken(linkName, linknw);		puttoken(linkName);		putToken(formatName);		putToken(' = ');	end;{----------------------------------------------------------------------------}	procedure WriteLinks (theChain: Integer);		var			theLink: longint;			linkH: Handle;			oldState: SignedByte;	begin		LockHandle(strCHUNKs[theChain], oldState);		for thelink := StartUserLink(theChain) to EndUserLink(thechain) do			begin				if ErrorFlag then					Exit(WriteLinks);				putTab;				linkH := HdlPtr(GetMaster(strCHUNKs[theChain]) + HdlSize * ord4(thelink))^;				case thechain of					CharPartitionchain: 						begin							WriteStartLink('CHARPARTITION ', ' ', GetLinkName(linkH), (thelink = DefaultLink[theCHAIN]));							WriteCharPart(linkH);						end;					wtSetchain: 						begin							if fullNexus1 or not TestLinkBit(0,0,linkH,wtrealbit)then  {v3.05}								WriteStartLink('WTSET ', ' ', GetLinkName(linkH), (thelink = DefaultLink[theCHAIN]))							else								WriteStartLink('WTSET ', ' REAL ', GetLinkName(linkH), (thelink = DefaultLink[theCHAIN]));							WriteWtSet(linkH);						end;					typeSetChain: 						begin							WriteStartLink('TYPESET ', ' ', GetLinkName(linkH), (thelink = DefaultLink[theCHAIN]));							WriteTypeSet(linkH);						end;					exsetchain: 						begin							WriteStartLink('EXSET ', ' ', GetLinkName(linkH), (thelink = DefaultLink[theCHAIN]));							WriteCharTaxList(linkH, 0, exb, true);						end;					charsetchain: 						begin							WriteStartLink('CHARSET ', ' ', GetLinkName(linkH), false);							WriteCharTaxList(linkH, 0, exb, true);						end;					taxsetchain: 						begin							WriteStartLink('TAXSET ', ' ', GetLinkName(linkH), false);							WriteCharTaxList(linkH, 0, exb, false);						end;					otherwise						;				end;				putSingleChar(';');				putReturn;			end;		ResetHandle(strCHUNKs[theChain], oldState);	end;{-----------------------------------------------------------------------------}	procedure AddQuoteLength (ds: str255; var k: integer);		var			m: integer;	begin		k := k + 2;		if pos('''', ds) > 0 then			begin				for m := 1 to length(ds) do					if ds[m] = '''' then						k := k + 1;			end;	end;{-----------------------------------------------------------------------------}	procedure CalcLongestTaxonName;		var			j, k: integer;			ds: str255;	begin		longesttaxname := 0;		for j := 1 to numtaxa do			begin				ds := TaxonName(j);				k := length(ds);				if not LegalChars(ds) then					AddQuoteLength(ds, k);				if ItalicTaxon(j) then					k := k + 8;				if k > longesttaxname then					longesttaxname := k;			end;		if not editorTransposed & ConsensusSequenceVisible then			for j := 1 to editorNumConsensusSequences do				begin					ds := GetConsensusName(j);					if length(ds) > longesttaxname then						longesttaxname := length(ds);				end;		longesttaxname := longesttaxname + 2;	end;{-----------------------------------------------------------------------------}	procedure WriteTaxaBlock;	begin		if DuplicateNames then 			InstantError(423);		WriteDataBlockStart('TAXA', taxaBlock, true, false,true);		WriteTaxLabels;		WriteForeignLinesInBlock(taxaBlock);		putEndOfBlock;	end;{-----------------------------------------------------------------------------}	procedure WriteDataBlock(writeCharacters: boolean);	begin{==== data block ====}		if writeCharacters then			WriteDataBlockStart('CHARACTERS', charactersBlock, false, true, false)		else			WriteDataBlockStart('DATA', dataBlock, true, true, true);		if errorflag then Exit(WriteDataBlock);		WriteFORMAT;		if errorflag then Exit(WriteDataBlock);		WriteOPTIONS;		if errorflag then Exit(WriteDataBlock);		if interleave and editorTransposed then			interleave := false;		WriteUnit := WriteUnit + 1;		UpdateThermo(iothermo, 0, WriteUnit, TotWriteUnits,true);		if editorTransposed and not writeTaxaCharBlocks then			begin				WriteTaxLabels;				if errorflag then Exit(WriteDataBlock);				WriteUnit := WriteUnit + 1;				UpdateThermo(iothermo, 0, WriteUnit, TotWriteUnits, true);			end;		if fullnexus1 then			begin				WriteCharStateLabels(not editorTransposed);				if errorflag then Exit(WriteDataBlock);				WriteUnit := WriteUnit + 1;				UpdateThermo(iothermo, 0, WriteUnit, TotWriteUnits,true);			end		else			begin				if not editorTransposed then					WriteCharLabels;				WriteStateLabels;				if errorflag then Exit(WriteDataBlock);				WriteUnit := WriteUnit + 1;				UpdateThermo(iothermo, 0, WriteUnit, TotWriteUnits,true);			end;		WriteMatrix;		if (writeTaxaCharBlocks & ForeignLinesInBlock(charactersBlock)) | (not writeTaxaCharBlocks & ForeignLinesInBlock(dataBlock)) then			begin{putReturn;}				if writeTaxaCharBlocks then					WriteForeignLinesInBlock(charactersBlock)				else					WriteForeignLinesInBlock(dataBlock);				if errorflag then Exit(WriteDataBlock);			end;		putEndOfBlock;	end;{----------------------------------------------------------------------------}	procedure WritePartColor (partNumber: integer);	begin		putToken('  COLOR=(RGB ');		WriteDecimalRGB(GetPartNameColor(partNumber));		putToken(')');	end;{-----------------------------------------------------------------------------}	procedure WriteCharPartNames;	var partNumber : integer;		ds: str255;	begin		for partNumber := 2 to numCharPartNames do			begin				putTab;				PutToken('CharGroupLabel  ');				ds := NameOfCharPartNameFromNumber(partNumber);				PrepareToken(ds,maxtok);				putToken(ds);				WritePartColor(partNumber);				putSingleChar(';');				putReturn;			end;	end;{-----------------------------------------------------------------------------}	procedure WriteAssumptionsBlock;	var theNexusBlock: NexusBlockPtr;	begin		PutTokenReturn('BEGIN ASSUMPTIONS;');		theNexusBlock := NexusBlockFromBlockType(assumptionsBlock);		WriteNexusBlockTitle(theNexusBlock);		WriteNexusBlockLinkText(theNexusBlock);		if (numtypes >= usedef) or (fisheredited) then			WriteUserTypes;		if errorflag then Exit(WriteAssumptionsBlock);		putTab;		Puttoken('OPTIONS ');		puttoken(' DEFTYPE=');		case deftype of			unordered: 				puttoken('unord');			ordered: 				puttoken('ord');			irreversible: 				puttoken('irrev');			fisher: 				puttoken('strat');			dollo: 				puttoken('Dollo');			otherwise				puttoken(TypeName(deftype));		end;{if fullNEXUS1 then WriteIGNORE;}		puttoken(' PolyTcount=');		if polyreal then			puttoken('MAXSTEPS ')		else			puttoken('MINSTEPS ');		putSingleChar(';');		putReturn;		if not ShouldWriteNexusBlock(setsBlock) then			begin				if (UserLinks[charSetchain] > 0)  then  					begin						SetCursID(virus);						WriteLinks(charSetChain);						if errorflag then Exit(WriteAssumptionsBlock);					end;				if (UserLinks[taxSetchain] > 0)  then					begin						SetCursID(virus);						WriteLinks(taxSetChain);						if errorflag then Exit(WriteAssumptionsBlock);					end;				if UserLinks[CharPartitionchain] > 0 then					begin		{    putReturn;}						SetCursID(bacteria);						WriteLinks(CharPartitionchain);						if errorflag then Exit(WriteAssumptionsBlock);					end; 			end;		if UserLinks[typeSetChain] > 0 then			begin				SetCursID(anemone);{    putReturn;}				WriteLinks(typeSetChain);				if errorflag then Exit(WriteAssumptionsBlock);			end;		if UserLinks[wtSetchain] > 0 then			begin{    putReturn;}				SetCursID(mouse);				WriteLinks(wtSetChain);				if errorflag then Exit(WriteAssumptionsBlock);			end;		if UserLinks[exSetchain] > 0 then			begin				SetCursID(planaria);{    putReturn;}				WriteLinks(exSetChain);				if errorflag then Exit(WriteAssumptionsBlock);			end;	{	if ForeignLinesInBlock(setsBlock) then			begin				putReturn;				WriteForeignLinesInBlock(setsBlock);				if errorflag then Exit(WriteAssumptionsBlock);			end;}		WriteForeignLinesInBlock(assumptionsBlock);		if errorflag then Exit(WriteAssumptionsBlock);		putEndofBlock;	end;{-----------------------------------------------------------------------------}	procedure WriteSetsBlock;	var theNexusBlock: NexusBlockPtr;	begin		PutTokenReturn('BEGIN SETS;');		if errorflag then Exit(WriteSetsBlock);		theNexusBlock := NexusBlockFromBlockType(setsBlock);		WriteNexusBlockTitle(theNexusBlock);		WriteNexusBlockLinkText(theNexusBlock);		if UserLinks[charSetchain] > 0 then			begin{putReturn;}				WriteLinks(charSetChain);				if errorflag then Exit(WriteSetsBlock);			end;		if UserLinks[taxSetchain] > 0 then			begin{putReturn;}				WriteLinks(taxSetChain);				if errorflag then Exit(WriteSetsBlock);			end;		if UserLinks[CharPartitionchain] > 0 then			begin{    putReturn;}				SetCursID(bacteria);				WriteLinks(CharPartitionchain);				if errorflag then Exit(WriteSetsBlock);			end;		WriteForeignLinesInBlock(setsBlock);		if errorflag then Exit(WriteSetsBlock);		putEndofBlock;	end;{-----------------------------------------------------------------------------}	procedure WriteLabelsBlock;	var theNexusBlock: NexusBlockPtr;	begin		PutTokenReturn('BEGIN LABELS;');		if errorflag then Exit(WriteLabelsBlock);		theNexusBlock := NexusBlockFromBlockType(labelsBlock);		WriteNexusBlockTitle(theNexusBlock);		WriteNexusBlockLinkText(theNexusBlock);		if numCharPartNames > 1 then			WriteCharPartNames;		WriteForeignLinesInBlock(labelsBlock);		if errorflag then Exit(WriteLabelsBlock);		putEndofBlock;	end;{-----------------------------------------------------------------------------}	procedure WriteNexusBlock(theNexusBlock: NexusBlockPtr; writeNotes,writeTrees: boolean);	begin		if theNexusBlock^.nativeBlock then			begin				if ShouldWriteNexusBlock(theNexusBlock^.blockType) then					begin						putReturn;						putReturn;						SetNexusBlockCursor(theNexusBlock^.blockType);						case theNexusBlock^.blockType of 							macCladeStartBlock: 								WriteMacCladeInfoStart;							taxaBlock:								WriteTaxaBlock;  							charactersBlock:								WriteDataBlock(true);  							dataBlock:								WriteDataBlock(false);  							continuousBlock:								writeContinuousBlock(theNexusBlock);							codonsBlock:								WriteCODONSBlock;							setsBlock:								WriteSetsBlock;							labelsBlock:								WriteLabelsBlock;							assumptionsBlock:								WriteAssumptionsBlock;							treesDataBlock:								if writeTrees then									WriteTreeBlock(datafilechain);							notesBlock:								if writeNotes then									WriteNotesBlock;							MacCladeBlock:								WriteFileSettings;							otherwise;						end;						putReturn;					end;			end		else			begin				WriteForeignNexusBlock(theNexusBlock);   {relevant putReturns are embedded herein}			end;	end;{-----------------------------------------------------------------------------}	procedure WriteFile(writeNotes,writeTrees, writeForeign: boolean);		label			1, 7000;		var			ds: str255;			j, fb, k: integer;			savenodefault: boolean;			wtnumchars: longint;			tport: WindowPtr;			db: boolean;			olddirtyfile: boolean;			oldState: SignedByte;			theNexusBlock: NexusBlockPtr;{................}		procedure CheckAbortWriting;		begin			if ErrorFlag then				goto 7000;		end;{................}	begin		olddirtyfile := dirtyfile;		StartWrite;		if ErrorFlag then			Exit(WriteFile);				ThermoAbortable := false;		if interleave then			begin				TotWriteUnits := numchars div interleavelength;				if (numchars mod interleavelength <> 0) then					TotWriteUnits := TotWriteUnits + 1;				TotWriteUnits := numtaxa * TotWriteUnits			end		else if not editorTransposed then			TotWriteUnits := numtaxa		else			TotWriteUnits := numchars;		TotWriteUnits := TotWriteUnits + 2 + (numtypes - usedef + 1) + UserLinks[datafilechain];		if fisheredited then			TotWriteUnits := TotWriteUnits + 1;		WriteUnit := 0;		StartThermo(iothermo, tport, 0, TotWriteUnits, 'Writing File', 'percent', true);		CalcLongestTaxonName;		longestcharname := 0;		for j := 1 to numchars do			begin				ds := CharName(j);				k := length(ds);				if not LegalChars(ds) then					AddQuoteLength(ds, k);				if k > longestcharname then					longestcharname := k;			end;		longestcharname := longestcharname + 3;		SaveDefaultAssumpLinks;		if nodes or (GetHandleSize(treedataH) > 2) then			begin				savenodefault := not treefile and not dirtytree and not dirtyfix and not fixon and (linknumber[treechain] >= StartUserLink(treechain));{note: currently dirty treefile link is saved to data file}				if savenodefault then					begin						defaultLink[treechain] := linknumber[treechain];						if nodes & not allSetLengths1 then   {v3.05}							SaveSegmentsForTree(treedataH, segdataH);						if nodes & not allRealLengthsDefault then							SaveRealLengthsForTree(treedataH, realBranchLengthsDataH);					end				else					begin						SaveDefaultLink(datafilechain);						TotWriteUnits := TotWriteUnits + 1;					end;			end;		puttoken('#NEXUS ');		putReturn;{$IFC WRITEUSERSTAMP}		putToken('[MacClade ');		putToken(VERSION);  {v3.01}		putSpace;		putToken(UserStamp(false, true, false));		putSingleChar(']');		PutReturn;{$ENDC}		fb := 1;		SetCursID(amoeba);{now write all the NEXUS blocks in turn}		theNexusBlock := NexusBlocks;		while theNexusBlock <> nil do			begin				if writeForeign | theNexusBlock^.nativeBlock then					WriteNexusBlock(theNexusBlock, writeNotes, writeTrees);				theNexusBlock := theNexusBlock^.next;				CheckAbortWriting;			end;		EndWrite;		ExciseDefaultAssumpLinks;		if nodes or (GetHandleSize(treedataH) > 2) then			if not savenodefault then				ExciseDefaultLink(datafilechain);		if not saveAsStationery then			begin				datachanged := false;				dirtyfix := false;				dirtyfile := false;				newfile := false;			end		else			dirtyfile := olddirtyfile;  {needed as dirtyfile set to true with excise links}		SavePrintRecordToFileResource (FDI^[writeFileFDI].fs);		goto 1;7000:		currentIOPosition := 41;   {v3.05}		db := IOSuccessful(FSpDelete(FDI^[extraIOFileFDI].fs));1:		EndThermo(iothermo, tport, false);		ThermoAbortable := true;		godraw := true;   {this forces an update to prevent user from grabbing control and moving branches too fast}	end;{-----------------------------------------------------------------------------}	function SaveFileDlgHook (item: integer; theDialog: DialogPtr; myDataPtr: Ptr): integer;	const		optionsItem=13;	var		H: Handle;		menuItemNo: integer;		box: rect;		ignore: integer;	begin		SaveFileDlgHook:= item;		if GetWRefCon(myGetWindowPtrForDialog(theDialog))<> longint(sfMainDialogRefCon) then		   Exit(SaveFileDlgHook);		case item of 			sfHookFirstCall:				begin					{GetDialogItem(theDialog, fileFormatPopUpItem, menuItemNo,H,box);}					{CreateModuleChoiceSubmenu(MenuHandle(H),dExportData,[]);}					{SetControlValueLong(ControlRef(H), currentSaveFileFormat);}					SaveFileDlgHook := sfHookNullEvent;				end;			optionsItem:				begin				end;			{fileFormatPopUpItem:				begin					GetDialogItem(theDialog, fileFormatPopUpItem, ignore,H,box);					currentSaveFileFormat := GetControlValueLong(ControlRef(H));					SaveFileDlgHook := sfHookNullEvent;				end;}			otherwise;		end;	end;{-----------------------------------------------------------------------------}	procedure SaveAsFile;	label		1;	var		theInfo: FInfo;		oldexists, db: BOOLEAN;		writename: str255;		oldname: str255;		oldState: SignedByte;		Freply: StandardFileReply;		UPP: UniversalProcPtr;		doStationery: boolean;		removeGaps: boolean;		FSP: FSSpec;		j: integer;	begin{$IFC NOT CARBON}		UPP := MyNewDlgHookYDUPP(@SaveFileDlgHook);  {$ELSEC}		UPP := nil;{$ENDC}		oldexists := false;		doStationery := false;		removeGaps := false;		LockHandle(filename, oldState);		if saveAsStationery then			PutCustomFile('Save Stationery as', 'Stationery Pad', Freply,sfgetwhere,UPP)		else			PutCustomFile('Save data file as', filename^^, Freply,sfgetwhere,UPP);		ShowCursor;		if Freply.sfGood then			begin				if Locked(lockSaving)then					begin						if EqualFileSpecs (Freply.sffile,FDI^[dataFileFDI].fs) then   {person is trying to save over top of old file; don't allow that}							goto 1; 					end;			end		else			Errorflag := true;		if errorflag then goto 1;				FspCreateSaveFile(Freply.sffile, oldexists, 'CLAD', 'TEXT');		{this procedure takes the Freply.sffile, and creates a writing file; if Freply.sffile 		exists, then this writing file is a new temporary file, otherwise it is Freply.sffile.		The writing file is referred to by extraIOFileFDI or writeFileFDI, which are the same}				{oldexists is true if a file of that same name is on disk, and unlocked,		which means it is being replaced}					if errorflag then goto 1;					FDI^[dataFileFDI].fs := Freply.sffile;		{if oldexists then   			FDI^[dataFileFDI].fs:= Freply.sffile;}					if errorflag then goto 1;			if not SaveAsStationery then			begin				if editorOpen then					SetWTitle(editorWindow, Freply.sfFile.Name);				if (treewindow <> nil) then					SetWTitle(treeWindow, Freply.sfFile.Name);			end;				WriteFile(true,true,true);  {uses FDI^[writeFileFDI].fs to write into, which is equivalent to that for extraIOFileFDI}		if Errorflag then			begin				HLock(Handle(filename));				if editorOpen then					SetWTitle(editorWindow, filename^^);				if (treewindow <> nil) then					SetWTitle(treeWindow, filename^^);				HUnLock(Handle(filename));			end		else			begin				if not SaveAsStationery then					begin						currentIOPosition := 73;   {v3.05}						filename^^ := Freply.sfFile.Name;					end;				if oldexists then						FSpExchangeFilesDeleteTemp(FDI^[dataFileFDI].fs)				else 					FDI^[dataFileFDI].fs:= FDI^[writeFileFDI].fs; 				if errorflag then					goto 1;				if not SaveAsStationery then					begin						FSpSetFileCreatorType(FDI^[dataFileFDI].fs, 'CLAD', 'TEXT');						fileSaved := true;					end				else					begin						resultCode := FSpGetFInfo(FDI^[dataFileFDI].fs, theInfo);						BitSet(@theInfo.fdFlags, 15 - 11);   {v4: 11 isStationery}						currentIOPosition := 42;   {v3.05}						db := IOSuccessful(FSpSetFInfo(FDI^[dataFileFDI].fs, theInfo));					end;				if errorflag then					goto 1;			end;		fileLastModified := FSpLastModified(FDI^[dataFileFDI].fs);		if Locked(lockSaving)then			savingLocked := false;1:{$IFC NOT CARBON}		MyDisposeDlgHookYDUPP(UPP);{$ENDC}		ResetHandle(filename, oldState);	end;{-----------------------------------------------------------------------------}	procedure SaveFile;		label			1;		var			theInfo: FInfo;			writename: str255;			db: boolean;			oldState: SignedByte;			curLastMod: longint;	begin		if not fileSaved then			SaveAsFile		else			begin				LockHandle(filename, oldState);				curLastMod := FSpLastModified(FDI^[dataFileFDI].fs);				if errorflag then					goto 1;				if curLastMod <> fileLastModified then					if not CWarning('Warning! File has been modified by another program after it was opened by MacClade.  Do you want to replace it by saving?', ' Save ', ' Cancel ') then						begin							errorFlag := true;							goto 1;						end;				if nonCLADwarn then					begin						resultCode := FSpGetFInfo(FDI^[dataFileFDI].fs, theInfo);						if (resultcode = NoErr) & (theInfo.fdCreator <> 'CLAD') & not CWarning('This was originally not a MacClade file - do you want to replace anyway?', 'Replace', 'Cancel') then							goto 1;					end;				FSpCreateSaveFile(FDI^[dataFileFDI].fs, db, 'CLAD', 'TEXT');				if errorflag then					goto 1;				if errorflag then					begin						goto 1;					end;				WriteFile(true,true,true);				if errorflag then					goto 1;				FSpExchangeFilesDeleteTemp(FDI^[dataFileFDI].fs);  			{changed from filename^^}				fileLastModified := FSpLastModified(FDI^[dataFileFDI].fs);				if errorflag then					goto 1;				if alwaysCLAD then					FSpSetFileCreatorType(FDI^[dataFileFDI].fs, 'CLAD', 'TEXT');1:				ResetHandle(filename, oldState);			end;	end;end.