unit Selection;{еееееееееееееееееееееее}interface	uses		Printing, QuickDraw,		Types, Events, QuickDrawText, OSUtils, TextUtils,Controls, Menus, Files,  Windows, Sound, Dialogs, TextEdit, Lists, ToolUtils, Memory, Fonts, Resources, Scrap, Devices, 		Globals, MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, TaxonCHUtil, TreeUtil, BoxUtil, MenuUtil, 		TypeUtil, SymbolsNames, LinkUtil, InfoWindows, MCWindows, InfoWindowsDraw,NexusBlocks;	procedure MakeNewObject(whichinfo: integer; objectName: str255; prepareToEditName, useSecondarySource,useDefaultName: boolean);   {///}	function NamedObjectExists(whichinfo: integer; objectName: str255): boolean;	function NamedObjectNumber(whichinfo: integer; objectName: str255): integer;		procedure DoStatesWindowSelectMenu (itemNo: integer);	procedure NextContiguousSelection(whichinfo: integer; current: longint; var startSel,endSel: longint);	procedure ShiftSelectInfo (whichinfo: integer; rowClicked: longint);	procedure SelectInfoCell (whichinfo: integer; ic: longint; on: boolean; fixMenus: boolean);	procedure SelectChosenSet (whichinfo, theLink: longint; var didchange: boolean);	procedure DoInfoWindowSelectMenu (whichinfo, ItemNo: integer);	procedure SelectAllWithSameValue (whichinfo, whichColumn, ij: longint; shift,comm, cntrl, opt: boolean);	procedure SelectAllTaxaWithState(tsts: largestsetchars; ic: integer);{еееееееееееееееееееееее}implementation {е$S Selection}{-----------------------------------------------------------------------------}	procedure MakeNewObject(whichinfo: integer; objectName: str255; prepareToEditName, useSecondarySource,useDefaultName: boolean);   {///}		var			db: boolean;			name: str255;	begin		if useDefaultName then			name := DefaultInfoObjectName(whichinfo)		else			name := objectName;		case whichInfo of			charInfo: 				;			taxinfo: 				;{    treeinfo:  NewStoreTree;}			typeinfo: 				begin					{MakeNewType('untitled');					AddOpenEditLastInfoRowName(typeinfo, true);					if infoOpen[typeinfo] then						InvalidateWindow(infoWindow[typeinfo], true);}				end;			typesetinfo,wtsetinfo,exsetinfo,charsetinfo,taxsetinfo,charpartinfo: 				begin					SaveLinkToChain(ChainFromInfo(whichinfo), name, false,useSecondarySource);					linknumber[ChainFromInfo(whichinfo)] := EndUserLink(ChainFromInfo(whichinfo));					AddOpenEditLastInfoRowName(whichinfo, prepareToEditName);					if infoOpen[whichinfo] then						InvalidateWindow(infoWindow[whichinfo], true);					dirtyfile := true;				end;			charpartnameinfo:				begin					AddNewCharPartName(name);					AddOpenEditLastInfoRowName(charpartnameinfo,prepareToEditName);					if infoOpen[charpartnameinfo] then						InvalidateWindow(infoWindow[charpartnameinfo], true);					dirtyfile := true;				end;			nexusblockinfo:				begin					AddNewNexusBlock(name,foreignBlock,false);					AddOpenEditLastInfoRowName(nexusblockinfo,prepareToEditName);					if infoOpen[nexusblockinfo] then						InvalidateWindow(infoWindow[nexusblockinfo], true);					dirtyfile := true;				end;			otherwise				;		end;	end;{-------------------------------------------------------------------------}	function NamedObjectExists(whichinfo: integer; objectName: str255): boolean;	begin		NamedObjectExists := false;		case whichinfo of			nexusblockinfo:				NamedObjectExists := NexusBlockNumberFromBlockName(objectName) <> 0;			otherwise;		end;	end;{-------------------------------------------------------------------------}	function NamedObjectNumber(whichinfo: integer; objectName: str255): integer;	begin		NamedObjectNumber := 0;		case whichinfo of			nexusblockinfo:				NamedObjectNumber := NexusBlockNumberFromBlockName(objectName);			otherwise;		end;	end;{-------------------------------------------------------------------------}	procedure DoStatesWindowSelectMenu (itemNo: integer);	begin	end;{-------------------------------------------------------------------------}	procedure SelectInfoCell (whichinfo: integer; ic: longint; on: boolean; fixMenus: boolean);		var			box: rect;			tport: WindowPtr;	begin		if on & not infoRowSelectable(whichinfo,ic) then			Exit(SelectInfoCell);		if on = InfoRowSelected(whichinfo, ic) then		{it is already as requested}			SetRect(box, 0, 0, 0, 0)		else			box := InfoRowBox(whichinfo, InfoHeight(whichinfo, ic));		genericGetPort(tport);		genericSetPort(infoWindow[whichinfo]);		SelectInfoRow(whichinfo, ic, on);		ClipRect(infoAllCellsDrawRect[whichinfo]);  		if frontwindow= infowindow[whichinfo] then			if ic >= infoTop[whichinfo] then		{$IFC COLORINFOBACKGROUND}				InvertRect(box);		{$ELSEC}				InvertHiliteRect(box);		{$ENDC}		if on then			infoSomeSelected[whichinfo] := true;		if fixMenus then			ChangeInfoSelectMenuFix(whichinfo);		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	procedure NextContiguousSelection(whichinfo: integer; current: longint; var startSel,endSel: longint);	var ir: longint;	begin		ir := current;		startSel := 0;		endSel := 0;		if (ir <= MaximumInfoRows(whichinfo)) then		 if InfoRowSelected(whichinfo,ir) then			begin				startSel := ir;			end		else   {we are in an unselected row, need to find next selected row}			begin				repeat					ir := ir+1;				until (ir > MaximumInfoRows(whichinfo)) | InfoRowSelected(whichinfo,ir) ;				if (ir <= MaximumInfoRows(whichinfo)) then					startSel := ir;			end;		if startSel > 0 then  {there is actually a selection present}			begin				repeat					ir := ir+1;				until (ir > MaximumInfoRows(whichinfo)) | not InfoRowSelected(whichinfo,ir) ;				if (ir <= MaximumInfoRows(whichinfo)) then					endSel := ir - 1				else 					endSel := MaximumInfoRows(whichinfo);			end;	end;{-------------------------------------------------------------------------}	procedure ShiftSelectInfo (whichinfo: integer; rowClicked: longint);		var			box: rect;			firstSel, lastsel, k: longint;			numElements: longint;	begin		numElements := MaximumInfoRows(whichinfo);		firstSel := 0;		repeat			firstSel := firstSel + 1;		until (firstSel >= numElements) | InfoRowSelected(whichinfo, firstSel);		if InfoRowSelected(whichinfo, firstSel) and (firstSel <> rowclicked) then			begin				lastSel := numElements + 1;				repeat					lastSel := lastSel - 1;				until (lastSel = firstsel) | InfoRowSelected(whichinfo, lastSel);				if rowclicked > firstSel then					begin						for k := firstSel to rowclicked do							SelectInfoRow(whichinfo, k, true);						for k := rowclicked + 1 to numElements do							SelectInfoRow(whichinfo, k, false);						if rowclicked > lastsel then							InvalidateInfoRow(whichinfo, firstSel, rowclicked)						else							InvalidateInfoRow(whichinfo, firstSel, lastsel);					end				else					begin						for k := rowclicked to firstSel do							SelectInfoRow(whichinfo, k, true);						for k := firstSel + 1 to numElements do							SelectInfoRow(whichinfo, k, false);						InvalidateInfoRow(whichinfo, rowclicked, lastsel);					end;				infoSomeSelected[whichinfo] := true;			end		else			SelectInfoCell(whichinfo, rowclicked, true,true);	end;{-------------------------------------------------------------------------}	procedure SelectAllInfo (whichinfo: integer);		var			ic: longint;	begin		for ic := 1 to MaximumInfoRows(whichinfo) do			SelectInfoRow(whichinfo, ic, true);		infoSomeSelected[whichinfo] := true;		InvalidateWindow(infoWindow[whichinfo], true);	end;{----------------------------------------------------------------------------}	procedure MenuDeSelectInfoLine (whichinfo: integer; ic: longint; var didchange: boolean);	begin		if selectMode = selectIntersection then			begin				SelectInfoRow(whichinfo, ic, false);				didchange := true;			end;	end;{----------------------------------------------------------------------------}	procedure MenuSelectInfoLine (whichinfo: integer; ic: longint; var didchange: boolean);	begin		if selectMode = selectIntersection then			if InfoRowSelected(whichinfo, ic) then				infoSomeSelected[whichinfo] := true			else				SelectInfoRow(whichinfo, ic, false)		else  {if it is union or replace}			begin				SelectInfoRow(whichinfo, ic, true);				didchange := true;				infoSomeSelected[whichinfo] := true;			end;	end;{-------------------------------------------------------------------------}	procedure SelectCodPos (whichpos: integer; var didchange: boolean);		var			ic: integer;	begin		for ic := 1 to numchars do			if whichpos = CharCodPos(ic) then				MenuSelectInfoLine(charinfo, ic, didchange)			else				MenuDeSelectInfoLine(charinfo, ic, didchange);	end;{----------------------------------------------------------------------------}	procedure SelectChosenSet (whichinfo, theLink: longint; var didchange: boolean);	var ic: longint;	begin		if whichinfo=charinfo then			begin 				LinkNumber[charsetchain] := theLink;				ChooseLink(charsetchain, false);				for ic := 1 to numchars do					if inCharSet(ic) then						MenuSelectInfoLine(charinfo, ic, didchange)					else						MenuDeSelectInfoLine(charinfo, ic, didchange);			end		else if  whichinfo=taxinfo then			begin				LinkNumber[taxsetchain] := theLink;				ChooseLink(taxsetchain, false);				for ic := 1 to numtaxa do					if inTaxSet(ic) then						MenuSelectInfoLine(taxinfo, ic, didchange)					else						MenuDeSelectInfoLine(taxinfo, ic, didchange);			end;	end;{-----------------------------------------------------------------------------}	function TerminalGap(it,ic: integer) : boolean;	var  furtheric: integer;		AllGapsOneWay: boolean;	begin		AllGapsOneWay := true;		for furtheric := ic - 1 downTo 1 do			if not IsGap(it,furtheric) then				begin					AllGapsOneWay := false;					leave;				end;		if AllGapsOneWay then			TerminalGap := true		else			begin				AllGapsOneWay := true;				for furtheric := ic + 1 to numchars do					if  not IsGap(it,furtheric) then						begin							AllGapsOneWay := false;							leave;						end;				TerminalGap := AllGapsOneWay;			end;	end;{-----------------------------------------------------------------------------}		procedure SelectGapRun(runLength: integer);		var				it,ic, ic2, gapsBefore, gapsAfter: integer;				stringOfGaps, oneSelected: boolean;				startic, endic, ic3, gapLength: integer;		begin			oneSelected := false;			SpinBeachBall;								for ic := 1 to numchars do				SelectInfoCell (charinfo, ic, false, false);							for it := 1 to numtaxa do   				begin					SpinBeachBall;					startic := 1;					if IsGap(it,1) then 						repeat							startic := startic+1;						until (startic>numchars) | not IsGap(it,startic);					endic := numchars;					if IsGap(it,numchars) then 						repeat							endic := endic-1;						until (endic=0) | not IsGap(it,endic);					if (startic <= numchars) then						begin							ic := startic;							repeat								gapLength := 0;								ic2 := ic;								if IsGap(it,ic) then									begin										repeat 											gapLength := gapLength+1;											ic2 := ic2+1;										until (ic2>endic)|not IsGap(it,ic2);										if gapLength>= runLength then											begin												for ic3 := ic to ic2-1 do													SelectInfoCell (charinfo, ic3, true,false);												oneSelected := true;											end;										ic := ic2;									end								else									ic := ic+1;							until (ic>endic);						end;				end;			if oneSelected then				infoSomeSelected[charinfo]:= true;			ChangeInfoSelectMenuFix(charinfo);		end;{----------------------------------------------------------------------------}	procedure SelectGapped(var success: boolean);	var	dL : longint;	begin		dL := GetLongint('Minimum length of consecutive gaps:', 5, 1,numchars-2,success);		if success then SelectGapRun(dL);	end;{----------------------------------------------------------------------------}	procedure DoInfoWindowSelectMenu (whichinfo, ItemNo: integer);		var			CharHdl: chHdl;			menucode: longint;			currentsel, j, ic: integer;			ds: str255;			didchange, db: boolean;	begin		if (whichinfo > 0) & (MaximumInfoRows(whichinfo)>0)  then			begin				if ItemNo = RenameDeleteSetMenuItem[whichinfo] then					begin						OpenOrSelectInfoWindow(SelectSetInfoFromObjectInfo(whichinfo));					end				else if ItemNo = SaveSetItem[whichinfo] then					begin						MakeNewObject(SelectSetInfoFromObjectInfo(whichinfo),'',true, false,true);					end				else if ItemNo > 0 then					begin						TurnOffInfoEditing(whichinfo);						didchange := false;						if selectMode = selectIntersection then							infoSomeSelected[whichinfo] := false						else if selectMode = selectReplace then							if ItemNo <> infoSelectReverseItem then								begin									SetAllInfoDeSelected(whichinfo);									didchange := true;								end;						case ItemNo of   {here are the ones common to all}							infoSelectAllItem:    {select all}								if selectMode <> selectIntersection then  {if it is intersection, then useless}									begin										SelectAllInfo(whichinfo);										didchange := true;									end								else									infoSomeSelected[whichinfo] := true;							infoSelectNoneItem:    {select none}								if selectMode <> selectUnion then  {if it is union, then useless}									begin										DeSelectAllInfo(whichinfo);										didchange := true;									end;							infoSelectReverseItem:    {reverse}								begin									//StartTime;									infoSomeSelected[whichinfo] := false;									for ic := 1 to MaximumInfoRows(whichinfo) do										begin											SelectInfoCell(whichinfo, ic, not InfoRowSelected(whichinfo, ic),false);											if InfoRowSelected(whichinfo, ic) then												infoSomeSelected[whichinfo] := true;										end;									didchange := true;									ChangeInfoSelectMenuFix(whichinfo);									//ReportTime;								end;							otherwise								;						end;						if whichinfo = charinfo then							begin								case ItemNo of									infoSelectIncludedCharsItem:   {all included}										begin											for ic := 1 to numchars do												if charincluded(ic) then													MenuSelectInfoLine(charinfo, ic, didchange)												else													MenuDeSelectInfoLine(charinfo, ic, didchange);										end;									infoSelectExcludedCharsItem:   {all excluded}										begin											for ic := 1 to numchars do												if not charincluded(ic) then													MenuSelectInfoLine(charinfo, ic, didchange)												else													MenuDeSelectInfoLine(charinfo, ic, didchange);										end;									infoSelectInvariantCharsItem:   {all invariant}										begin											for ic := 1 to numchars do												if InvariantChar(ic) then   {invariant character}													MenuSelectInfoLine(charinfo, ic, didchange)												else													MenuDeSelectInfoLine(charinfo, ic, didchange);										end;									infoSelectGapsMissingCharsItem:    {all gaps/missing}										begin											for ic := 1 to numchars do												if AllGaps(ic, true) then   													MenuSelectInfoLine(charinfo, ic, didchange)												else													MenuDeSelectInfoLine(charinfo, ic, didchange);										end;									infoSelectEvery10thCharsItem:    {every 10th}										begin											for ic := 1 to numchars do												if ic mod 10 = 0 then   													MenuSelectInfoLine(charinfo, ic, didchange)												else													MenuDeSelectInfoLine(charinfo, ic, didchange);										end;									otherwise										;								end;								if molecular & (ItemNo=infoSelectGapRunsCharsItem) then									begin										SelectGapped(didChange);									end;								if nucleotides then									case ItemNo of										infoSelectCodingCharsItem:    {coding}											begin												for ic := 1 to numchars do													if IsCoding(ic) then														MenuSelectInfoLine(charinfo, ic, didchange)													else														MenuDeSelectInfoLine(charinfo, ic, didchange);											end;										infoSelectNonCodingCharsItem:     {non-coding}											begin												for ic := 1 to numchars do													if not IsCoding(ic) then														MenuSelectInfoLine(charinfo, ic, didchange)													else														MenuDeSelectInfoLine(charinfo, ic, didchange);											end;										infoSelectPos1CharsItem..infoSelectPos3CharsItem: 											SelectCodpos(ItemNo -infoSelectPos1CharsItem+1, didchange);										otherwise											;									end;								if (ItemNo >= FirstUserSetMenuItem[whichinfo]) & (ItemNo < SaveSetItem[whichinfo] - 1) then									SelectChosenSet(whichinfo,ItemNo - FirstUserSetMenuItem[whichinfo],didchange);								FixAssumpMenu;								if didchange then									InvalidateWindow(infoWindow[charinfo], numcharin <> numchars);							end						else if whichinfo = taxinfo then							begin								case ItemNo of									infoSelectIncludedTaxaItem:   {all included}										begin											for ic := 1 to numtaxa do												if TaxonInTree(ic) then													MenuSelectInfoLine(taxinfo, ic, didchange)												else													MenuDeSelectInfoLine(taxinfo, ic, didchange);										end;									infoSelectExcludedTaxaItem:   {all excluded}										begin											for ic := 1 to numtaxa do												if not TaxonInTree(ic) then													MenuSelectInfoLine(taxinfo, ic, didchange)												else													MenuDeSelectInfoLine(taxinfo, ic, didchange);										end;									otherwise										;								end;								if (ItemNo >= FirstUserSetMenuItem[whichinfo]) & (ItemNo < SaveSetItem[whichinfo] - 1) then									begin										SelectChosenSet(whichinfo,ItemNo - FirstUserSetMenuItem[whichinfo],didchange);									end;								if didchange then									InvalidateWindow(infoWindow[taxinfo], false); {еее false?}								if frontWindow=infoWindow[taxinfo] then									EnableDisableItem(xxTaxonSetsMHdl, StoreTaxonSetItem,infoSomeSelected[taxinfo]);							end						else if didchange then							InvalidateWindow(infoWindow[whichinfo], false); {еее false?}						if didchange then							ChangeInfoSelectMenuFix(whichinfo);					end;			end;	//	EnableDisableItem(CharPartListMHdl, SetGroupColorItem, infoSomeSelected[charpartnameinfo]);	end;{----------------------------------------------------------------------------}	procedure SelectAllWithSameValue (whichinfo, whichColumn, ij: longint; shift,comm, cntrl, opt: boolean);	var		 match: boolean;		originalString, rowString: str255;		originalLongint, rowLongint : longint;		originalDouble, rowDouble: double;		theRow: integer;		columnType: integer;		columnID: integer;	begin		columnID := InfoColumnID (whichInfo, whichColumn);		columnType := InfoColumnType (whichInfo, columnID);		case columnType of 			columnIsDouble:				originalDouble:= InfoCellDouble (whichinfo, columnID, ij);			columnIsLongint:				originalLongint:= InfoCellLongint (whichinfo, columnID, ij);			otherwise				originalString:= InfoCellString (whichinfo, whichColumn, ij);		end;		for theRow := 1 to MaximumInfoRows(whichinfo) do			begin				match := false;				case columnType of 					columnIsDouble:						begin							rowDouble:= InfoCellDouble (whichinfo, columnID, theRow);							if opt then								match := (rowDouble>=originalDouble)							else if cntrl then								match :=  (rowDouble<=originalDouble)							else								match := (originalDouble = rowDouble);						end;					columnIsLongint:						begin							rowLongint:= InfoCellLongint (whichinfo, columnID, theRow);							if opt then								match := (rowLongint>=originalLongint)							else if cntrl then								match :=  (rowLongint<=originalLongint)							else								match := (originalLongint = rowLongint);						end;					otherwise						begin							rowString:= InfoCellString (whichinfo, whichColumn, theRow);							match := originalString = rowString;						end;				end;				if (match <> InfoRowSelected(whichinfo,theRow)) then					begin						if match | (not (shift | comm ) & InfoRowSelected(whichinfo,theRow)) then							SelectInfoCell(whichinfo,theRow, match,false);						{InvalidateInfoRow(whichinfo,theRow, theRow);}					end;			end;		CheckInfoSomeSelected(whichinfo);	end;	{----------------------------------------------------------------------------}	procedure SelectAllTaxaWithState(tsts: largestsetchars; ic: integer);	var it: integer;			begin		for it := 1 to numtaxa do			SelectInfoCell(taxinfo,it,gettaxonstslargest(it,ic) = tsts,false);		ChangeInfoSelectMenuFix(taxinfo);		OpenOrSelectInfoWindow(taxinfo);		ScrollInfoWindowToSelectedRow(taxinfo);		CheckInfoSomeSelected(taxinfo);	end;end.