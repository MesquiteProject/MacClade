unit StatusNotes;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, WriteUtil, TaxonCHUtil, SymbolsNames, CharUtil, TypeUtil, CalcUtil, TreeUtil, MenuUtil, Activates;	procedure StampFile;	procedure StampFileName;	procedure DrawTime (drawPort: WindowPtr);	procedure StatusNotes;{еееееееееееееееееееееее}implementation {е$S StatusNotes}{----------------------------------------------------------------------------}	procedure StampFile;	begin		drawWriteStringLines := 0;  {v3.01}		DrawWriteStringLn(MacCladeStamp);	{$IFC RELEASEVERSION}		DrawWriteStringLn(UserStamp(true, true, false));	{$ELSEC}		DrawWriteStringLn('*** TEST VERSION - DO NOT DISTRIBUTE ***');		DrawWriteStringLn('*** DO NOT PUBLISH RESULTS WITHOUT PERMISSION ***');	{$ENDC}		DrawWriteStringLn(TimeStamp);		DrawWriteReturn;	end;{----------------------------------------------------------------------------}	procedure StampFileName;		var			oldState: SignedByte;	begin		DrawWriteReturn;		DrawWriteStringLn(DataFileStamp);		DrawWriteReturn;	end;{----------------------------------------------------------------------------}	procedure DrawTime (drawPort: WindowPtr);		var			tport: windowptr;			box: rect;	begin		genericGetPort(tport);		if drawport <> nil then			begin				genericSetPort(drawPort);				ClipRect(WindowPortRect(drawPort));				SetRect(box, marg, 0, 300, 5 + fontheight);				EraseRect(box);				moveto(marg, 3 + fontheight);			end;		genericSetPort(tport);	end; {-----------------------------------------------------------------------------}	procedure CountMatrixElements(var numMissing,numGaps,numMissingAll, numGapsAll: longint);	var it,ic: integer;		tsts: largestsetchars;	begin		numMissing := 0;		numMissingAll := 0;		numGaps := 0;		numGapsAll := 0;		for it := 1 to numtaxa do			for ic := 1 to numchars do					begin						tsts := gettaxonstslargest(it,ic);						if tsts=[MSl,GAl] then							begin								numGapsAll := numGapsAll+1;								if CharIncluded(ic) then numGaps := numGaps+1;							end						else if tsts = [MSl] then							begin								numMissingAll := numMissingAll+1;								if CharIncluded(ic) then numMissing := numMissing+1;							end;					end;	end;{----------------------------------------------------------------------------}	procedure StatusNotes;		label			1;		var			poly3trouble: boolean;			ic, it, j: integer;			ds: str255;			tempset: largestsetchars;			numMissing,numGaps,numMissingAll, numGapsAll, totalCells: longint;	begin		MoveTo(marg, 6 + fontheight * 2);		if not printon then			TextFace([bold]);		StampFile;		DrawWriteStringLn('General Notes');		if not printon then			TextFace([]);		DrawWriteStringLn('======================');		StampFileName;{========= taxa ===========}		DrawWriteStringLn(concat(StringFromNum(numtaxa), ' taxa'));		DrawWriteStringLn('');{========= characters ===========}		DrawWriteStringLn('CHARACTERS');		DrawWriteStringLn(concat(StringFromNum(numchars), ' characters'));		DrawWriteStringLn(concat(StringFromNum(numcharin), ' characters included'));		if numcharin <> numchars then			DrawWriteStringLn(concat(StringFromNum(numchars - numcharin), ' characters excluded'))		else			DrawWriteStringLn('No characters excluded');		 		if nodes then			begin				if ((traceshown = traceDiscrete)) then					begin						if fixon then							DrawWriteStringLn('Character traced has states at some branches fixed');						if (resolveoption = ACCTRAN) then							DrawWriteStringLn('ACCTRAN option used')						else if (resolveoption = DELTRAN) then							DrawWriteStringLn('DELTRAN option used');					end;				poly3trouble := false;				if Anytype([usedef]) then					for ic := 1 to numchars do						if (TypeOfChar(ic) >= usedef) & CharIncluded(ic) & (CharWeight(ic) > 0) then							if Poly3inchar(ic) then								begin									poly3trouble := true;									goto 1;								end;1:				if poly3trouble then					begin						DrawWriteStringLn('Polymorphism of more than 2 states found in user-defined');						DrawWriteStringLn('     type character.  Character steps/trace may be incorrect');					end;			end;		DrawWriteStringLn('Character Transformation types:');		ds := '     Types currently in use:';		for ic := 1 to numtypes do			if ic in curTypes then				ds := concat(ds, ' ', Typename(ic));		DrawWriteStringLn(ds);		if anydirected then			DrawWriteStringLn('     Directed types in use:  yes')		else			DrawWriteStringLn('     Directed types in use:  no');		for j := typesetchain to exsetchain do			if not dirtylink[j] then				begin					ds := curLinkNames[j]^^;					if ds = '' then						DrawWriteStringLn(concat('     Current ', ChainNames[j]^^, ' unnamed'))					else						DrawWriteStringLn(concat('     Current ', ChainNames[j]^^, ' stored as ', ds));				end;		DrawWriteStringLn('');{======== MISSING DATA etc ==============}		CountMatrixElements(numMissing,numGaps,numMissingAll, numGapsAll);				totalCells := ord4(numtaxa)*numchars;		DrawWriteString('Missing data, entire matrix:  ');		DrawWriteString(concat(StringFromNum(numMissingAll), ' cell(s), '));		RealToString(100.0*numMissingAll/totalCells,ds,1000, 2,false);		DrawWriteStringLn(concat(ds, '%'));		 if numchars <> numcharin then		 	begin				totalCells := ord4(numtaxa)*numcharin;				DrawWriteString('Missing data, included characters:  ');				DrawWriteString(concat(StringFromNum(numMissing), ' cell(s), '));				RealToString(100.0*numMissing/totalCells,ds,1000, 2,false);				DrawWriteStringLn(concat(ds, '%'));		 	end;		totalCells := ord4(numtaxa)*numchars;		DrawWriteString('Gaps, entire matrix:  ');		DrawWriteString(concat(StringFromNum(numGapsAll), ' cell(s), '));		RealToString(100.0*numGapsAll/totalCells,ds,1000, 2,false);		DrawWriteStringLn(concat(ds, '%'));		 if numchars <> numcharin then		 	begin				totalCells := ord4(numtaxa)*numcharin;				DrawWriteString('Gaps, included characters:  ');				DrawWriteString(concat(StringFromNum(numGaps), ' cell(s), '));				RealToString(100.0*numGaps/totalCells,ds,1000, 2,false);				DrawWriteStringLn(concat(ds, '%'));		 	end;		DrawWriteStringLn('');{======== TREES ==============}		DrawWriteStringLn('TREES');		if treeChain <> treefileChain then			DrawWriteStringLn('Current tree repository:  (data file)')		else			DrawWriteStringLn(concat('Current tree repository:  tree file (', treefilename^^, ')'));		if polyreal then			DrawWriteStringLn('Polytomies assumed to represent multiple speciation')		else			DrawWriteStringLn('Polytomies assumed to represent uncertain resolution');		if nodes then			begin				DrawWriteStringLn('Current tree: ');{if treesavedinfile then DrawWriteStringLn(concat('     Stored in file as ', treename));}				if nullson and count then					begin						if polyreal then							begin								DrawWriteStringLn('     Contains hard polytomies; thus treelength may');								DrawWriteStringLn('          overestimate length of worst dichotomous resolution');							end						else							begin								DrawWriteStringLn('     Contains soft polytomies; thus treelength may');								DrawWriteStringLn('          underestimate length of best dichotomous resolution');							end;					end;				if fixancPolymorph then					begin						DrawWriteStringLn('     Some observed taxa fixed as ancestors are polymorphic');						DrawWriteStringLn('          in some characters; thus lengths/trace may be incorrect');					end;				if numtaxain <> numtaxa then					begin						DrawWriteStringLn(concat('     Includes ', StringFromNum(numtaxain), ' taxa in data file'));						DrawWriteStringLn(concat('     Excludes ', StringFromNum(numtaxa - numtaxain), ' taxa'))					end				else					DrawWriteStringLn(concat('     Includes all ', StringFromNum(numtaxa), ' taxa in data file'));			end;	end;end.