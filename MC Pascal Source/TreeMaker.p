unit TreeMaker;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, TypeUtil, CharUtil, MenuUtil, Thermos, Prohibitions, TreeUtil, LinkUtil, RandomTree, TreeMakerUtil;	procedure MakeTree (var status, querycyclepoly: boolean; makeregardless: boolean; OKtoPolytomy, OKtoFixanc,domaxMem, doCursorChange: boolean);	procedure MakeTreeAfterEdit;{еееееееееееееееееееееее}implementation {е$S TreeMaker}	var		treeP: ptr;{-----------------------------------------------------------------------------}	procedure restoreFix;		var			ikk: longint; {v3.05:  changed to longint}{    ds: str255;}{............}		procedure inRestoreFix (N: Nptr);		begin			if NodeIsInternal(N) then				begin					if BranchExists(N) then						begin							ikk := ikk + 1;							if Hchar(fixdataH, ikk) = '{' then								begin									ikk := ikk + 2;									N^.fixsts := [ord(Hchar(fixdataH, ikk)) - 48];									N^.fix := true;									ikk := ikk + 2;								end							else if Hchar(fixdataH, ikk) <> '(' then								NewError(37, 0);						end;					inRestoreFix(N^.lf);					inRestoreFix(N^.rt)				end			else if BranchExists(N) then				begin					ikk := ikk + 1;					if Hchar(fixdataH, ikk) = 'T' then						begin							ikk := ikk + 2;							N^.fixsts := [ord(Hchar(fixdataH, ikk)) - 48];							N^.fix := true;							ikk := ikk + 2;						end					else if Hchar(fixdataH, ikk) <> 't' then						NewError(37, 0);				end;		end;{............}	begin		ikk := 0;		repeat			ikk := ikk + 1		until Hchar(fixdataH, ikk) = ' ';		InRestoreFix(R);		fixon := true;		dirtyfix := false;		if ErrorPosted(37) then			Offfix(true);	end;{-----------------------------------------------------------------------------}	procedure restoreSegs;		var			ikk: longint;  {v3.05:  changed to longint}			segdataHLength: longint;{    ds: str255;}{............}		procedure inRestoreSegs (N: Nptr);{.....}			procedure GetSetLength;				var					chno: longint;			begin				N^.setlength := 0;				ikk := ikk + 1;				chno := ord(Hchar(segdataH, ikk)) - 48;				repeat					N^.setLength := N^.setlength * 10 + chno;					ikk := ikk + 1;					chno := ord(Hchar(segdataH, ikk)) - 48;				until (chno < 0) or (chno > 9) or (ikk > segdataHLength);   {v3.02:}				ikk := ikk - 1;			end;{.....}		begin			if NodeIsInternal(N) then				begin					if BranchExists(N) then						begin							ikk := ikk + 1;							if Hchar(segdataH, ikk) = '(' then								GetsetLength							else								NewError(389, 0);						end					else						N^.setlength := 1;					inRestoreSegs(N^.lf);					inRestoreSegs(N^.rt)				end			else if BranchExists(N) then				begin					ikk := ikk + 1;					if Hchar(segdataH, ikk) = 't' then						GetsetLength					else						NewError(389, 0);				end			else				N^.setlength := 1;		end;{............}	begin		ikk := 0;		segdataHLength := GetHandleSize(segDataH);		repeat			ikk := ikk + 1		until Hchar(segdataH, ikk) = ' ';		InRestoresegs(R);	end;{-----------------------------------------------------------------------------}	procedure restoreBranchLengths;		var			ikk: longint;  {v3.05:  changed to longint}			realBranchLengthdataHLength: longint;			ds : str255;{    ds: str255;}{............}		procedure GetRealLength(N: Nptr);			var				c: char;				bl: double;		begin			N^.realLength := realBranchLengthDefault;			ikk := ikk + 1;			ds := Hchar(realBranchLengthsDataH, ikk);			repeat				ikk := ikk + 1;				c := Hchar(realBranchLengthsDataH, ikk);				if not ((c='(') | (c='t') | (c=';')) then					ds := concat(ds,c);			until ((c='(') | (c='t') | (c=';')) | (ikk > realBranchLengthdataHLength);   {v3.02:}			bl := TokenToReal(ds);			if bl<> -1.0 then N^.realLength := bl;  {Davidv4.1: but what if really is -1.0?}			ikk := ikk - 1;		end;{............}		procedure InRestoreBranchLengths (N: Nptr);		begin			if NodeIsInternal(N) then				begin					if BranchExists(N) then						begin							ikk := ikk + 1;							if Hchar(realBranchLengthsDataH, ikk) = '(' then								GetRealLength(N)							else								NewError(389, 0);						end					else						N^.realLength := realBranchLengthDefault;					InRestoreBranchLengths(N^.lf);					InRestoreBranchLengths(N^.rt)				end			else if BranchExists(N) then				begin					ikk := ikk + 1;					if Hchar(realBranchLengthsDataH, ikk) = 't' then						GetRealLength(N)					else						NewError(389, 0);				end			else				N^.realLength := realBranchLengthDefault;		end;{............}	begin		ikk := 0;		realBranchLengthdataHLength := GetHandleSize(realBranchLengthsDataH);		repeat			ikk := ikk + 1		until Hchar(realBranchLengthsDataH, ikk) = ' ';		InRestoreBranchLengths(R);	end;{-----------------------------------------------------------------------------}{$SETC ALLOWTYPECHANGE=FALSE}{$IFC ALLOWTYPECHANGE}	procedure SetToUnordered (queryset: setchars15);		var			ic: integer;			oldtype: integer;	begin		for ic := 1 to numchars do			if CharIncluded(ic) then				begin					oldtype := TypeOfChar(ic);					if (oldtype in queryset) | ((oldtype >= usedef) & (usedef in queryset)) then						begin							SetType(ic, unordered);							UseToTypeStorage(ic);						end;				end;		CheckCurrentTypes;	end;{$ENDC}{-----------------------------------------------------------------------------}{This is the grand treemaking procedure.  It builds a tree from description in treedataH.}{If treedataH starts with null node, then this procedure knows it is just a shorthand}{request to make default or random tree.}{If treedataH contains fixed ancestors or polytomies this procedure checks to see if they're legal.}{There is a complex and klunky system to passing notes back and forth to inform the calling}{procedure what happened.  For instance status is used to inform a tree cycling procedure}{whether or not tree successfully built}{STATUS}{Iff true on input, then Make tree will give user message as to why tree was not made}{True in UndoFromSaved, RestoreCurrentTree, OpenTheTree, MakeTreeAfterEdit}{False in BuildTree (TreeCycle)}{Iff true on input, then requested treedataH was successfuly made}	procedure MakeTree (var status, querycyclepoly: boolean; makeregardless: boolean; OKtoPolytomy, OKtoFixanc,domaxMem, doCursorChange: boolean);		label			2;		var			TaxonHdl: thdl;			temptoken: str255;{warningstr}			oldik, it, specialtree: integer;			InputStatus, turnoffnulls, turnoffanc, dontbuild: boolean;			tn: Nptr;			nextnode, thisnode, sizeoftreeblock, numterminals: longint;			oldState: SignedByte;			amountneeded: longint;			cancel: boolean;			localItemHit: integer;			willbeundoH: Handle;{...........................}		procedure MakeNode (var N: Nptr; aN: Nptr; Nslant: INTEGER);					 {constructs tree from tree description in buffer treedataTE}			var				NameOfN: integer;		begin			thisnode := thisnode + 1;			nextnode := nextnode + 1;			N := NEWnode(nextnode);			N^.rt := nil;			N^.lf := nil;			N^.slant := Nslant;			N^.anc := aN;			if not FillNode(N) then				treemakingfailed := true;			nameofN := GetPackedNode(TreeP, thisnode);			if (NameOfN = 0) or (NameOfN = nullpacked) then				begin					N^.null := (NameOfN = nullpacked);					N^.name := 0;					MakeNode(N^.lf, N, -1);					MakeNode(N^.rt, N, 1);				end			else				begin					if NameOfN < 0 then {if negative then fixed ancestor}						begin							nextnode := nextnode + 1;							N^.lf := NEWnode(nextnode);							N^.lf^.rt := nil;							N^.lf^.lf := nil;							if not FillNode(N^.lf) then								treemakingfailed := true;							N^.name := 0;							N^.null := false;							N^.fixanc := true;							N^.lf^.null := false;							N^.lf^.slant := -1;							N^.lf^.anc := N;							N^.lf^.fixanc := true;							N^.lf^.name := -NameOfN;							if N^.lf^.name <= numtaxa then								begin									if TaxonPolyFixancBeware(N^.lf^.name) then										NewError(90, 0);									TaxonHdl := GetTaxonHdl(N^.lf^.name);									taxonhdl^^.deleted := false;									taxonHdl^^.N := N^.lf;								end;							MakeNode(N^.rt, N, 1);						end					else						begin							N^.null := false;							N^.name := NameOfN;							if N^.name <= numtaxa then								begin									TaxonHdl := GetTaxonHdl(N^.name);									taxonhdl^^.deleted := false;									taxonHdl^^.N := N;								end							else								begin								end;						end;					numtaxain := numtaxain + 1;				end;		end;  {procedure Make Node}{...........................}{...........................}	begin		if equivcycle then			pleaseoffequivocal := true;		if doCursorChange then			SetCursor(oldtreecurs);		ResetForNew;		if domaxMem then			grow1 := MaxMem(grow2);		willbeundoH := nil;		InputStatus := status;		turnoffnulls := false;		turnoffanc := false;		dontbuild := false;		treemakingfailed := false;		if makeregardless then			begin			end		else if PackedtreehasPolytomies(treedataH) and PackedTreeHasFixanc(treedataH) then			begin				NewError(79, 0);				dontbuild := true;			end		else			begin				if PackedtreehasPolytomies(treedataH) then  {polytomous}					begin  {NOTE: polytomies allowed to be built with continuous which is then turned off in MainEventLoop if needed}						if blastpolytomies then							begin								turnoffnulls := true							end						else if not OKtoPolytomy then							begin								if querycyclepoly then									begin										if CWarning('Polytomies not currently allowed.  Do you want to resolve all polytomies in all trees ARBITRARILY as they are processed, or skip all polytomous trees', 'Resolve', 'Skip') then											begin												turnoffnulls := true;												blastpolytomies := true;											end										else											begin												dontbuild := true;												querycyclepoly := false;											end;									end								else if Anytype([usedef, dollo, fisher, irreversible]) then									begin{$IFC ALLOWTYPECHANGE}										if status then											begin												localItemHit := DoAlert(145, StopA);												case localItemHit of													1: 														turnoffnulls := true;													2: 														SetToUnordered([usedef, dollo, fisher, irreversible]);													3: 														dontbuild := true;												end;											end										else											dontbuild := true;{$ELSEC}										if status then											begin												if CWarning('Tree being built is currently illegal, because polytomies are allowed only with characters of unordered and ordered type.  Do you want to resolve polytomies ARBITRARILY?', 'Resolve', 'Cancel') then													turnoffnulls := true												else													dontbuild := true;												NewError(120, 0);											end										else											dontbuild := true;{$ENDC}									end								else									begin										dontbuild := true;										if status then											begin												if PolytomiesLegal(true) then {reporting what error was}													;												NewError(120, 0);											end;									end;							end;					end;				if PackedTreeHasFixanc(treedataH) then  {fixanced}					begin {NOTE: fixanc allowed to be built with continuous which is then turned off in MainEventLoop}						if not OKtofixanc then							begin								if Anytype([dollo, usedef]) then									begin{$IFC ALLOWTYPECHANGE}										if status then											begin												localItemHit := DoAlert(146, StopA);												case localItemHit of													1: 														turnoffanc := true;													2: 														SetToUnordered([dollo, usedef]);													3: 														dontbuild := true;												end;											end										else											dontbuild := true;{$ELSEC}										if status then											begin												if cWarning('Tree being built is currently illegal, because fixing observed taxa as ancestors is not allowed with characters of Dollo or user-defined type.  Do you want to push ancestors to terminal position?', 'Push', 'Cancel') then													turnoffanc := true												else													dontbuild := true;												NewError(120, 0);											end										else											dontbuild := true;{$ENDC}									end								else									begin										dontbuild := true;										if status then											begin												if FixancLegal(R, true) then {reporting what error was}													;												NewError(120, 0);											end;									end;							end;					end;			end;		DisposeNODEs;		sizeoftreeblock := longint(numtaxa * 2 + 2) * sizeof(Ntype);{NOTE: Old system was to build a tree in this procedure regardless, even if cycling}{and illegal and about to skip the tree.  The tree built was sometimes the old tree, sometimes}{the default tree, but it was built.  If doing multiple tree cycling in chart and dontbuild was called}{then status was left as false, which meant the requested tree was not successfully built,}{and the calling procedure would proceed to ignore the tree (default, etc.) that had been}{built instead.  This old system was safe but klunky.  I have moved to system which}{builds no tree if calling procedure will ignore consolation tree produced (iff status}{was input to MakeTree with value false);  this is risky but better probably in low memory}{situations}		if inputstatus & (dontbuild | turnoffnulls | turnoffanc) then			copyHandles(treedataH, willbeundoH);		if dontbuild then			begin				status := false;				if InputStatus then					begin						if treeinmemory and not noundo then							begin								copyHandles(oldtreeH, treedataH);								LinkNumber[treechain] := oldtreelinknumber;							end						else							begin								GetLink(datafilechain, 0, treedataH, true);								LinkNumber[treechain] := 0;								Newerror(324, 0);							end;					end			end		else			status := true;		if inputstatus & (dontbuild | turnoffnulls | turnoffanc) then			begin				copyHandles(willbeundoH, oldtreeH);				noundo := false;				fullundo := true;				undotype := justgot;				justundid := false;			end;{if status was input as false, then we are coming from BuildTree whose callers are}{expecting a status=false message to mean tree was not built; therefore we won't build tree}		if not (dontbuild and not inputstatus) then			begin				numterminals := GetNumTaxaInpackedTree(treedataH);  {don't need to lock}				if numterminals = 0 then					numterminals := numtaxa; {except if random not all}				if numterminals > mntaxa then					begin						InstantError(177);						treemakingfailed := true;					end				else if not EnoughMemory(memoryForTree(numterminals, numchars), amountneeded) then					begin						InstantErrorPlus(178, concat(StringFromNum(amountneeded div 1024), 'K'));						treemakingfailed := true;					end				else					begin{The old memory check didn't work for two reasons.  It only calculated memory for}{ the pointers for the tree structure and a  bit of character storage}{it didn't include the character storage times the number of nodes. }{Note new function MemoryForTree in Treemakerutil}{Second Problem is that these calculations used numtaxa, instead of numtaxain.  What if you}{have a humongous data matrix but only want to read in tree on subset of 5 taxa? Do we}{prevent them from reading it in?  We didn't use to know until tree is read in how many}{taxa are in it; now I store in treedataH early bytes the number of terminal taxa in the tree}{so that we know here immediately how many there are, before building.  This is what I used}{In above calculations}						LockHandle(treedataH, oldstate);  {===========================}						treename^^ := GetLinkName(treedataH);						taxcount := 1;						treeblock := newptr(sizeoftreeblock);    {disposed in DisposeNodes}						tN := Nptr(ord4(treeblock) + 3 * sizeof(Ntype));						for it := 4 to (numtaxa * 2 + 2) do							begin								tN^.name := -1;								tN := Nptr(ord4(tN) + sizeof(Ntype));							end;						subR := NEWnode(1);						subsubR := NEWnode(2);						subRlf := NEWnode(3);						subsubR^.lf := nil;						subsubR^.rt := subR;						subsubR^.anc := nil;						subRlf^.rt := nil;						subRlf^.lf := nil;						subRlf^.anc := subR;						nextnode := 3;						subR^.anc := subsubR;						subR^.slant := 1;						subR^.lf := subRlf;						if not FillNode(subR) then							treemakingfailed := true;						subsubR^.stsH := NewHandle(tcb * ord4(numchars));						TreeP := StartOFPackedTree(0, 0, treedataH);						if GetPackedNode(treeP, 1) = nullpacked then  {first node is null; must be special}							begin								specialtree := GetPackedNode(treeP, 2);								if specialtree = RTEquiprobable then									begin										oldnumtaxain := numtaxain;										MakeRandomTree(RTEquiprobable);										numtaxain := oldnumtaxain;									end								else if specialtree = RTJoining then									begin										oldnumtaxain := numtaxain;										MakeRandomTree(RTJoining);										numtaxain := oldnumtaxain;									end								else if specialtree = RTPartition then									begin										oldnumtaxain := numtaxain;										MakeRandomTree(RTpartition);										numtaxain := oldnumtaxain;									end								else									begin										for it := 1 to numtaxa do											begin												TaxonHdl := gettaxonHdl(it);												taxonHdl^^.deleted := true;											end;										MakeDefaultTree(R, SubR, (specialtree = ladder));										numtaxain := numtaxa;									end							end						else							begin								for it := 1 to numtaxa do									begin										TaxonHdl := gettaxonHdl(it);										taxonHdl^^.deleted := true;									end;								numtaxain := 0;								thisnode := 0;								MakeNode(R, subR, 1);							end;						R^.null := false;2:{$IFC FALSE}						ConsistencyCheck; {$ENDC}						if turnoffanc then							begin								offanc(R);								if inputstatus then									status := false;							end;						if turnoffnulls then							begin								PrepareToRandomPoly(R);								RandomizeAllPolytomies(R);								polytomiesBlasted := true;								if inputstatus then									status := false;							end;						Setancon;						SetNullson;						if Bittst(ptr(GetMaster(treedataH)), charfixedbit) and (GetHandleSize(fixdataH) > 1) then							restoreFix;						if Bittst(ptr(GetMaster(treedataH)), segstoredbit) and (GetHandleSize(segdataH) > 1) then							restoreSegs;  {Segments:}						if Bittst(ptr(GetMaster(treedataH)), branchLengthStoredBit) and (GetHandleSize(realBranchLengthsDataH) > 1) then							restoreBranchLengths;  {Segments:}						ResetHandle(treedataH, oldstate);						ScreenR := R;						DrawR := ScreenR;						subR^.null := false;						subR^.rt := R;						subRlf^.null := false;						subsubR^.null := false;						lastselN := subR;						storedN := subR;						BranchListN := subR;						cladeN := subR;						ntscreen := numtaxain;						nodes := true;						treeinmemory := true;						InVAlidateWindow(tlegwindow, false);						FixTreeShadingMenus;{$IFC FALSE}						ConsistencyCheck; {$ENDC}					end;			end	end;{Description of a BAD BUG.  It took 2.5 days of work to solve.  Finally, it began crashing in}{run-time environment, which made it possible to finally solve.  Basically, what was happening was}{this.  In ReOrderTaxa, I was calling LockHandle and RestoreHandle twice, once for taxonCHUNKs,  another time}{for taxonHdl.  Clearly, what was happening was that I was calling LockHandle(taxonHdl,oldstate1) when}{I should have been calling LockHandle(taxonHdl,oldstate2).  This meant that oldstate2 was not defined when}{it came to resetting the Handle, and oldstate one was not what it should be.  The result was that at some times,}{taxonCHUNKs was set to purgeable, because of the incorrect setting of the Handle's states.  }{In MakeTree, when MaxMem was called, this memory was then tossed out the window, and the program}{would crash when taxonCHUNKs was first called (which was in gettaxonHdl). -DRM  3 August 1991}{----------------------------------------------------------------------------}	procedure MakeTreeAfterEdit;		var			status, querycyclepoly: boolean;	begin		noundo := true;		fixlostbyundo := false;		justundid := false;		SetCursor(clockCursor);		ancon := false;		status := true;		querycyclepoly := false;		Maketree(status, querycyclepoly, false, PolytomiesLegal(false), FixancLegal(subR, false),true,true);		FullTreeOnScreenGoList; {send all golist items}		if infoOpen[taxinfo] then			InvalidateWindow(infoWindow[taxinfo], false);		expd := false;{$IFC NOT ALWAYSENABLED}		myDisableItem(ShowMHdl, ShrinkItem);		myDisableItem(EditMHdl, UndoItem);{$ENDC}		SetCursorToArrow;		if not treemakingfailed then			FixTreeShadingMenus;	end;end.