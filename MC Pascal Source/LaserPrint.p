unit LaserPrint;{еееееееееееееееееееееее}interface	uses		Printing, QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, TaxonCHUtil, CharUtil, StrUtil, TypeUtil, Prohibitions, PolyCalc, TreeUtil, PrintingUtil, PrintingMisc, Equivocal, SetStates, TreeCycle, TraceAllChangesCalc, ProbReconstruct, TreeGet, LaserTreeUtil, LaserDraw, Coloring, count, Continuous;	procedure PrintLaserTree;{еееееееееееееееееееееее}implementation {е$S LaserPrint}	var		querycyclepoly: boolean;{-----------------------------------------------------------------------------}	function GetNextTree (trees: integer; var itree: integer): boolean;		label			2;		var			status: boolean;			OKtoPolytomy, OKtofixanc: boolean;	begin		GetNextTree := true;2:		repeat			itree := itree + 1;		until InfoRowSelected(treeinfo,itree) or (itree > UserLinks[treechain]);  		if (itree<=UserLinks[treechain]) & InfoRowSelected(treeinfo,itree) then			begin				OKtofixanc := not (AnyType([dollo, usedef]) & ((count & laser^.showbox[treestatsB]) | (traceshown = traceAllChanges))); {can't have fixanced if tree calcs and doll/usedef}				OKtofixanc := OKtofixanc & not ((traceshown = traceAllChanges) & ((branchlistmode = minmaxmode) | (branchlistmode = maxmode))); {can't have fixanced if showchanges equiv cycle}				OKtofixanc := OKtofixanc & not (calctreechanges & laser^.showbox[treestatsB]); {can't have fixanced if equiv cycling needed}				OKtofixanc := OKtofixanc & not (traceshown = traceContinuous); {can't have fixanced if continuous is traced}				OKtofixanc := OKtofixanc & not (traceshown = traceProbability); {can't have fixanced if prob is traced}				OKtofixanc := OKtofixanc & not ((traceshown = traceDiscrete) & ((resolveoption <> allpossible) | (typeofchar(i) >= dollo))); {can't have fixanced if acctran/deltran or tracing doll or or user def}				OKtoPolytomy := not (AnyType([irreversible, fisher, dollo, usedef]) & ((count & laser^.showbox[treestatsB]) | (traceshown = traceAllChanges))); {can't have polytomy if tree calcs and doll/usedef}				OKtoPolytomy := OKtoPolytomy & not ((traceshown = traceAllChanges) & ((branchlistmode = minmaxmode) | (branchlistmode = maxmode))); {can't have polytomy if showchanges equiv cycle}				OKtoPolytomy := OKtoPolytomy & not (calctreechanges & laser^.showbox[treestatsB]); {can't have polytomy if equiv cycling needed}				OKtoPolytomy := OKtoPolytomy & not ((traceshown = traceDiscrete) & ((resolveoption <> allpossible) | (typeofchar(i) >= irreversible))); {can't have polytomy if acctran/deltran or tracing doll or or user def}				OKtoPolytomy := OKtoPolytomy & not ((traceshown = traceContinuous) & (not polyreal | continuousismanhattan));				OKtoPolytomy := OKtoPolytomy & not (traceshown = traceProbability);				BuildTree(nil, itree + StartUserLink(treechain) - 1, status, querycyclepoly, false, OKtopolytomy, Oktofixanc);				if treemakingfailed then					begin						GetNextTree := false;						InstantError(206);						Exit(GetNextTree);					end;				if not status then					begin						NewError(35, 0);						goto 2;					end;			end		else			GetNextTree := false;	end;{-----------------------------------------------------------------------------}	procedure ForceReCalculateTree (var aborted: boolean);  {Modified 3.02}	begin		if ((count or CalcCi or calcRi or CalcRC or calctreechanges or showminsteps or showmaxsteps) and laser^.showbox[treestatsB]) or (traceshown = traceAllChanges) then			begin				SetTaxaDnsts(1, numchars);				if (traceshown = traceAllChanges) then					begin						if not CountTree then  {This does DOWNPASSES v3.02:}							NewError(311, 0);						ReconstructChars(1, numchars, true);  {THIS NEEDS DOWNPASSES}						CountBranchLengths(1, numchars, branchlistmode, branchlengthsweighted, aborted);					end				else if laser^.showbox[treestatsB] then					begin						if (calcMinActive) then							CalcMinMaxTreeLen(minlength);						if (calcMaxActive) then							CalcMinMaxTreeLen(maxlength);						if count & not CountTree then  {This does DOWNPASSES}							NewError(311, 0);						if (calctreechanges & laser^.showbox[treestatsB]) | (traceshown = traceAllChanges) then							begin								if not count then  {This does DOWNPASSES v3.02:}									if not CountTree then										NewError(311, 0);								ReconstructChars(1, numchars, true);  {THIS NEEDS DOWNPASSES}								CountTotalTreeChanges;							end;						if (calcCI or calcRI or calcRC) then							CalculateCIAll;						if (calcRI or calcRC) then							CalculateRIAll;					end;			end;		if (traceshown = traceContinuous) then			ReconstructContinuous{$IFC PROBRECONSTRUCT}		else if (traceshown = traceProbability) then			CalcProbReconstruct;{$ENDC}	end;{-----------------------------------------------------------------------------}	procedure PrintLaserTree;		label			1, 3;		var			tempP, printerport: WindowPtr;			horpg, vertpg, j, ic, trees, oldi, panelwidth, panelheight, thepanel, itree: Integer;			db: boolean;			box, startpanel, panelBox, trect: rect;			Panel: Point;			storetreeH: Handle;			oldtreename: str255;			manytrees, storetreeforFix, paneled: boolean;			aborted: boolean;			numchosen: integer;			pageStillOpen: boolean;			printCanceled: boolean;			oldequivcyclenum: integer;	begin		manytrees := false;   {v3.04}		oldequivcyclenum := equivcyclenum;		pg := 1;		if laser^.multicharacters & (traceshown = traceDiscrete) then			begin				numchosen := numchars;			end		else			numchosen := 1;		pageStillOpen := false;		genericGetPort(tempP);		oldtreename := treename^^;		itree := 0;		oldi := i;		printCanceled := true;		if OpenPrinter(true) then			begin				if StartPrinting(true) & PrepareDocument then					begin						box := printPageR;						printCanceled := false;						manytrees := (numtreeschosen >= 1);						storetreeforFix := laser^.multicharacters and (traceshown = traceDiscrete) and not manytrees and fixon;						if manytrees or storetreeforfix then							StoreCurrentTree(storetreeH);						if storetreeforFix then							begin								NewError(128, 0);								offfix(false);							end;						Delay(20, ticks);						itree := 0;						thepanel := 1;						paneled := (laser^.treesPerPage.v > 1) or (laser^.treesPerPage.h > 1);{$IFC FALSE}						with currentClassicPrinterPort^.gPort.portrect do							begin								panelheight := (bottom - top) div laser^.treesPerPage.v;								panelwidth := (right - left) div laser^.treesPerPage.h;								SetRect(startpanel, left, top, left + panelwidth, top + panelheight);							end;{$ENDC}						with box do							begin								panelheight := (bottom - top) div laser^.treesPerPage.v;								panelwidth := (right - left) div laser^.treesPerPage.h;								startpanel := box;							end;						querycyclepoly := true;						blastpolytomies := false;{||||||||||||  cycling through trees |||||||||||||||||}						for trees := 0 to numtreeschosen do							begin								if not manytrees and (trees = 0) then									begin										if dirtytree then											treename^^ := 'Untitled';										GetTreeNumber;									end								else if manytrees and (trees > 0) then									begin										if not GetNextTree(trees, itree) then											goto 3;										printtreenumber := itree;									end								else									cycle;{||||||||||||  do necessary calculations |||||||||||||||||}								if manytrees then									ForceRecalculateTree(aborted);								SetCursor(clockCursor);{||||||||||||||| cycling through characters ||||||||||||||||||}								for ic := 1 to numchosen do									begin										if (traceshown = traceDiscrete) and laser^.multicharacters then											if CharIncluded(ic) then												begin													i := ic;													reconstructTraced;												end											else												cycle  {go to next cycle of char loop}										else if (traceshown = traceDiscrete) and manytrees and (trees > 0) then											ReconstructTraced;    {reconstruct traced character on subsequent trees;}										if laser^.printequiv then											begin												Equiv_MakeFirstResolution(screenR, i, TracedTrue);												equivcycleNum := 0;											end;{||||||||||||||| cycling through resolutions ||||||||||||||||||}										repeat											equivcycleNum := equivcyclenum + 1;											if equivcycleNum = maxLongint then												begin													NewError(443,ic);													leave;												end;											if laser^.printequiv then												Equiv_TransferRestoSts(screenR, i, true);											genericGetPort(printerport);											genericSetPort(tempP);											DrawTreePicture(fulltreeframe, false, false);											genericSetPort(printerport);{$IFC NOT CARBON}											UseResFile(printDriverResFile);{$ENDC}{====not paneled====}											if not paneled then												for horpg := 1 to laser^.treepages.h do													for vertpg := 1 to laser^.treepages.v do														begin															pageStillOpen := true;															if OpenPrinterPage then																begin																	SetOrigin((horpg - 1) * pgwidth, (vertpg - 1) * pgheight);																	SetRect(tRect,0,0,pgWidth,pgHeight);																	OffsetRect(tRect,(horpg - 1) * pgwidth, (vertpg - 1) * pgheight);																	ClipRect(tRect);																	DrawPicture(treepicture, fulltreeframe);																	ClipRect(fulltreeframe);																	SetOrigin(0,0);{																	OffSetRect(currentClassicPrinterPort^.gPort.portrect, (horpg - 1) * pgwidth, (vertpg - 1) * pgheight);																	trect := printPageR;																	OffSetRect(trect, (horpg - 1) * pgwidth, (vertpg - 1) * pgheight);																	printPageR := trect;																	ClipRect(fulltreeframe);																	DrawPicture(treepicture, fulltreeframe);																	ClipRect(fulltreeframe);																	OffSetRect(currentClassicPrinterPort^.gPort.portrect, -(horpg - 1) * pgwidth, -(vertpg - 1) * pgheight);																	printPageR := box;}																																		ClosePrinterPage;																	pageStillOpen := false;																end															else																begin																	ClosePrinterPage;																	pageStillOpen := false;																	goto 1;																end;														end{==== paneled====}											else {paneled}  {note that this presumes that if paneled then = 1 page per panel}												begin													if thepanel = 1 then														begin															pageStillOpen := OpenPrinterPage;														end;													panel.v := (thepanel - 1) div laser^.treesPerPage.h + 1;													panel.h := thepanel - ((panel.v - 1) * laser^.treesPerPage.h);													panelbox := startpanel;													OffSetRect(PanelBox, (Panel.h - 1) * panelwidth, (Panel.v - 1) * panelheight);													ClipRect(PanelBox);													DrawPicture(treepicture, PanelBox);													ClipRect(fulltreeframe);												end;											if (paneled and (thepanel = laser^.treesPerPage.v * laser^.treesPerPage.h)) then												begin													ClosePrinterPage;													thepanel := 1;													pageStillOpen := false;												end											else												thepanel := thepanel + 1;										until not laser^.printequiv | (uniqueresolution) | (Equiv_NextResInClade(screenR, screenR, i, TypeOfChar(i), true));{||||||||||||||||| end cycling through resolutions ||||||||||||||||}										if laser^.printequiv then											Equiv_RestoreSts(screenR, i, true);									end;  {characters loop - ic}{||||||||||||||||| end cycling through characters ||||||||||||||||}							end; {trees loop}{||||||||||||||||| end cycling through trees ||||||||||||||||}						querycyclepoly := false;						blastpolytomies := false;3:						if pageStillOpen then							ClosePrinterPage;1:						EndPrint;						if manytrees or storetreeforfix then							RestoreCurrentTree(storetreeH, true); {!!!!!}						printPageR := box;					end;				PrintCancelOff;				ClosePrinter;			end;		genericSetPort(tempP);		i := oldi;		if not printCanceled then   {v3.04: we have asked to print, therefore things may need to be recalculated}			begin				if manytrees then					begin						ForceReCalculateTree(aborted);						if (traceshown = traceDiscrete) then							ReconstructTraced;{Here we have to force recalculation of various things, as we have}{just done multiple trees, and as we are in the Laser tree DLOG, the golist}{which is set just below is not used}{e.g. multiple trees with branch lengths: need to force recalc here}{What if traced character is fixed, or in equivocal cycling before multiple tree printing;}{does it come back exactly the same?}{perhaps makes it so that can't do multiple trees if have a single equivocal resolution}{trace on the tree in the treewindow}{I have dealt with the above problem with fixing.  For this reason, }{if in equivocal cycling, multiple trees printing is disabled}					end				else if laser^.multicharacters then					if (traceshown = traceDiscrete) then						ReconstructTraced; {don't need to settaxdnsts for reconstruct traced}				treename^^ := oldtreename;				if (numtreeschosen >= 1) then					FullTreeOnScreenGoList;{FROZEN 3.0}				if numchosen > 1 then					golist := golist + igos; {if had printed more than one char, ask to redo calculations for i}{if had done equiv cycle,stop equiv cycle would also have asked for such calculations}			end;		oldtreename := treename^^;		equivcyclenum := oldequivcyclenum;	end;end.