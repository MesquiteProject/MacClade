unit DrawSpread;{ееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, 		TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap, 		 Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil,		  EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, CharUtil, SpreadUtil, Footnote, EditorCellEntry,		  EditorGeneralUtil,ConsensusSequences;	procedure DrawGrayEditorRgn(drawControls: boolean);	procedure DrawEditMessageBox;	procedure FrameEditorMatrixRect;	procedure DrawRCNumbers;	procedure DrawRowNames;	procedure DrawDataEditorLock;	procedure DrawColCells (col: integer; erase, dofullgrid, doFrameDRect, showSelection: boolean);	procedure DrawRowCells (row: integer);	procedure DrawCells (dofullgrid, changeclip, showSelection: boolean);			{ееееееееееееееееееееее}implementation {е$S DrawSpread}{$SETC DARKTENTH=FALSE}{v4: fix darktenth, make blue lines}{----------------------------------------------------------------------------}	procedure DrawEditMessageBox;	var ds: str255;	begin{				ds := concat(StringFromNum(FreeMem div 1024), 'K');				EraseRect(editMessageBox);				MoveTo(editMessageBox.left + 3, editMessageBox.bottom - 4);				TextSize(9);				TextFont(kFontIDGeneva);				TextFace([]);				DrawString(ds);				TextFace(spreadstyle);				TextSize(editorFontSize);				TextFont(editorFont);}										{EraseRect(editMessageBox);}		{if not printon & ScreenInColor & (editorColorCodPosMode=editorColorPartitionsCodPos) & nucleotides & someCoding then			begin				MoveTo(editMessageBox.left + 20, editMessageBox.bottom - 4);				TextSize(9);				TextFont(kFontIDGeneva);				TextFace([]);				RGBForeColor(blueRGB);				DrawString('1 ');				RGBForeColor(greenRGB);				DrawString('2 ');				RGBForeColor(redRGB);				DrawString('3 ');				ForeColor(blackColor);				TextFace(spreadstyle);				TextSize(editorFontSize);				TextFont(editorFont);			end;}	end;{----------------------------------------------------------------------------}	procedure DrawGrayEditorRgn(drawControls: boolean);		var			tRgn: RgnHandle;			grayRgn: RgnHandle;			box: rect;			oldRGB: RGBColor;	begin		grayRgn:= newRgn;		tRgn := NewRgn;		box := editorBoundaryRect;		box.left := editorRowNameStart;		box.top := editorTitleLineWidth;		RectRgn(grayRgn,box);		RectRgn(tRgn,editorMatrixRect);		DiffRgn(grayRgn,tRgn,grayRgn);		box := editorTitleCornerRect;		box.right := box.right-editorGridThickness-editorExtraGridThickness;		box.bottom:= box.bottom-editorGridThickness-editorExtraGridThickness;		RectRgn(tRgn,box);		UnionRgn(tRgn,grayRgn,grayRgn);				if drawControls then			begin				box:= WindowPortRect(editorWindow);				box.left := box.right-scrollwidth;				box.bottom := editorTitlesWidth;				RectRgn(tRgn,box);				{little rectangle at upper right}				UnionRgn(tRgn,grayRgn,grayRgn);				SetRect(box,myGetControlRect(editorHScroll).right, myGetControlRect(editorVScroll).bottom,WindowPortRect(editorWindow).right,WindowPortRect(editorWindow).bottom);				RectRgn(tRgn,box);				{little rectangle at lower right}				UnionRgn(tRgn,grayRgn,grayRgn);				OpenRgn;				MoveTo(0,editorBoundaryRect.bottom+1);				LineTo(editorFootNoteRect.left - 1, editorBoundaryRect.bottom+1);				LineTo(editorFootNoteRect.left - 1, editorFootNoteRect.top + 4);				LineTo(editorFootNoteRect.left + 4, editorFootNoteRect.top - 1);				LineTo(editorRowNameEnd+1, editorFootNoteRect.top - 1);				LineTo(editorRowNameEnd+1, editorBoundaryRect.bottom+1);				LineTo(0,editorBoundaryRect.bottom+1);				CloseRgn(tRgn);				UnionRgn(tRgn,grayRgn,grayRgn);			end;				if ColorPort then			begin				SetGrayBackground(oldRGB,grayPale);				EraseRgn(grayRgn);				RGBBackColor(oldRGB);			end		else			FillRgn(grayRgn, QDltGray);		ZapRegion(tRgn);		ZapRegion(grayRgn);	end;{----------------------------------------------------------------------------}	procedure EraseCellRect (B: rect);	begin		if grid then			begin				B.right := B.right-editorGridThickness;				B.bottom := B.bottom-editorGridThickness;			end;		{B.top := B.top + 2;		B.left := B.left + 2;		B.right := B.right - 2;}		EraseRect(B);	end;{----------------------------------------------------------------------------}	procedure FrameEditorMatrixRect;	const grabBoxWidth = 12;{frames editorMatrixRect}		var			B: rect;			adj, adk, st: integer;			oldClip: RgnHandle;	begin		oldClip := NewRgn;		GetClip(OldClip);		ClipRect(WindowPortRect(editorWindow));		PenNormal;		moveto(editorBoundaryRect.right,0);		lineto(editorBoundaryRect.right,editorBoundaryRect.bottom);		lineto(editorBoundaryRect.left,editorBoundaryRect.bottom);		if editorMatrixRect.bottom < editorBoundaryRect.bottom then			begin				st := editorRowNameStart+grabBoxWidth+2;				PenSize(2, 2);				moveto(editorRowNameStart, editorMatrixRect.bottom);				lineto(editorMatrixRect.right, editorMatrixRect.bottom);				if ColorPort then					begin						RGBForeColor(editorEdgeColor);						PenPat(QDBlack);					end				else					PenPat(QDltGray);				moveto(st, editorMatrixRect.bottom + 2);				if editorMatrixRect.right < editorBoundaryRect.right then					begin						adj := 2;						adk := 4;					end				else					begin						adj := -2;						adk := -2;					end;				lineto(editorMatrixRect.right + adj, editorMatrixRect.bottom + 2);				if ColorPort then					RGBForeColor(blackRGB);				PenPat(QDBlack);				moveto(st, editorMatrixRect.bottom + 4);				lineto(editorMatrixRect.right + adk, editorMatrixRect.bottom + 4);				PenNormal;				SetREct(B, st - grabBoxWidth, editorMatrixRect.bottom + 1, st, editorMatrixRect.bottom + grabBoxWidth+1);				Eraserect(B);				Framerect(B);			end;		if editorMatrixRect.right < editorBoundaryRect.right then			begin				st := editorTitleLineWidth+grabBoxWidth+2;				PenSize(2, 2);				moveto(editorMatrixRect.right, editorTitleLineWidth);				lineto(editorMatrixRect.right, editorMatrixRect.bottom);				if ColorPort then					begin						RGBForeColor(editorEdgeColor);						PenPat(QDBlack);					end				else					PenPat(QDltGray);				moveto(editorMatrixRect.right + 2, st);				if editorMatrixRect.bottom < editorBoundaryRect.bottom then					begin						adj := 2;						adk := 4;					end				else					begin						adj := -2;						adk := -2;					end;				lineto(editorMatrixRect.right + 2, editorMatrixRect.bottom + adj);				if ColorPort then					RGBForeColor(blackRGB);				PenPat(QDBlack);				moveto(editorMatrixRect.right + 4, st);				lineto(editorMatrixRect.right + 4, editorMatrixRect.bottom + adk);				PenNormal;				SetREct(B, editorMatrixRect.right + 1, st - grabBoxWidth, editorMatrixRect.right + grabBoxWidth+1, st);				Eraserect(B);				Framerect(B);			end;		SetClip(OldClip);		ZapRegion(oldClip);	end;{||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}{----------------------------------------------------------------------------}	procedure DrawRowNumber (rownum, row: integer);	begin		DrawRCNumberBox(rownum, true);	end;{----------------------------------------------------------------------------}	procedure DrawColNumber (colnum, col: integer);	begin		DrawRCNumberBox(colnum, false);	end;{----------------------------------------------------------------------------}	procedure DrawRowNames;		var			j, rownum: integer;	begin		if not editorTransposed & editorShowConsensusSequences & (editorNumConsensusSequences>=1) then			for j:= 1 to editorNumConsensusSequences do				begin						RowColumnFromConsensusSequence(rownum,j);						if ConsensusSelected(j) then							DrawRowName(rownum,selectionModeOn)						else							DrawRowName(rownum,selectionModeOff);						PenNormal;				end;		for j := 1 to editorRows do			begin				rownum := j + editorOrigin.v - 1;				if (not printon or (rownum <= editorTotalRows)) then					DrawRowNumber(rownum, j);				if rownum <= editorTotalRows then					begin						DrawRowName(rownum,selectionModeAsIs);						PenNormal;					end;			end;	end;{----------------------------------------------------------------------------}	procedure DrawRCNumbers;		var			col, row, left, top, right, bottom, rownum, colnum, nr, nc: integer;	begin		if printon and (editorOrigin.v + editorRows - 1 > editorTotalRows) then			nr := editorTotalRows - (editorOrigin.v) + 1		else			nr := editorRows;		for row := 1 to nr do			begin				rownum := editorOrigin.v + row - 1;				CellVer(rownum, top, bottom, true);				DrawRowNumber(rownum, row);			end;		if printon and (editorOrigin.h + editorColumns - 1 > editorTotalColumns) then			nc := editorTotalColumns - (editorOrigin.h) + 1		else			nc := editorColumns;		for col := 1 to nc do			begin				colnum := col + editorOrigin.h - 1;				CellHor(colnum, left, right, true);				DrawColNumber(colnum, col);			end;	end;{||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}{----------------------------------------------------------------------------}	procedure DrawColCells (col: integer; erase, dofullgrid, doFrameDRect, showSelection: boolean);		var			k, hor, colnum, rownum, maxrow: integer;			left, right, top, bottom,j,consensusSequence: integer;			B: REct;	begin		colnum := col + editorOrigin.h - 1;		CellHor(colnum, left, right, true);		if not printon then			DrawColNumber(colnum, col);		if colnum <= editorTotalColumns then			begin				{GRID: } SetRect(B, left + 2, editorTitleLineWidth + 2, right - 2, editorTitlesWidth - 1);				SetRect(B, left, editorTitleLineWidth + 2, right, editorTitlesWidth - 1);  {:GRID}				if erase then					EraseRect(B);				if showSelection then					DrawColName(colnum,selectionModeAsIs)				else					DrawColName(colnum,selectionModeOff);				if not editorTransposed & ConsensusSequenceVisible then					for j := 1 to editorNumConsensusSequences do							begin								RowColumnFromConsensusSequence(rownum,j);								CellVer(rownum, top, bottom, true);								SetRect(B, left, top, right, bottom);								if erase then									EraseCellRect(B);								WriteCell(B, rownum, colnum, -1, ConsensusSelected(j), false, false,writeStandardCells);							end;				maxRow := editorOrigin.v + editorRows - 1;				if maxRow > editorTotalRows then					maxRow := editorTotalRows;				for rownum := editorOrigin.v to maxRow do					begin						CellVer(rownum, top, bottom, true);						SetRect(B, left, top, right, bottom);						if erase then							EraseCellRect(B);						WriteCell(B, rownum, colnum, -1, showSelection & CellInSelection(rownum,colnum), false, false,writeStandardCells);						if (rownum = editorTotalRows) then							if not printon and (editorMatrixRect.bottom < editorBoundaryRect.bottom) then								begin									PenNormal;									PenSize(2, 2);									moveto(left, bottom);									lineto(right, bottom);									moveto(left, bottom + 4);									lineto(right, bottom + 4);									if ColorPort then										RGBForeColor(editorEdgeColor)									else										PenPat(QDltGray);									moveto(left, bottom + 2);									lineto(right, bottom + 2);									if ColorPort then										RGBForeColor(blackRGB);									PenNormal;								end;					end;				PenNormal;				{PenSize(2, 2);				moveto(left - 3, editorTitlesWidth - 1);				lineto(left + editorColumnWidth, editorTitlesWidth - 1);				PenSize(1, 1);}			end;		if (colnum = editorTotalColumns + 1) and doFrameDRect then			FrameEditorMatrixRect;	end;{----------------------------------------------------------------------------}	procedure DrawRowCells (row: integer);		var			k, rownum, colnum: integer;			left, right, top, bottom,j,consensusSequence: integer;			B: REct;	begin		rownum := row + editorOrigin.v - 1;		DrawRowNumber(rownum, row);		CellVer(rownum, top, bottom, true);		if rownum <= editorTotalRows then			begin				DrawRowName(rownum,selectionModeAsIs);				for k := 1 to editorColumns do					begin						if editorTransposed & editorShowConsensusSequences & (editorNumConsensusSequences>=1) then							for j := 1 to editorNumConsensusSequences do									begin										RowColumnFromConsensusSequence(colnum,j);										CellHor(colnum, left, right, true);										SetRect(B, left, top, right, bottom);										WriteCell(B, rownum, colnum, -1, false, false, false,writeStandardCells);									end;						colnum := k + editorOrigin.h - 1;						CellHor(colnum, left, right, true);						SetRect(B, left, top, right, bottom);						if colnum <= editorTotalColumns then							WriteCell(B, rownum, colnum, -1, CellInSelection(rownum,colnum), false, false, writeStandardCells);						if (colnum = editorTotalColumns) then							begin								PenNormal;								if (editorMatrixRect.right < editorBoundaryRect.right) then									begin										PenSize(2, 2);										moveto(right - 2, bottom);										lineto(right - 2, top);										moveto(right + 2, bottom);										lineto(right + 2, top);										if ColorPort then											RGBForeColor(editorEdgeColor)										else											PenPat(QDltGray);										moveto(right, bottom);										lineto(right, top);										if ColorPort then											RGBForeColor(blackRGB);										PenNormal;									end;							end;					end;				PenSize(2, 2);				moveto(editorRowNameEnd - 1, top - 2);				lineto(editorRowNameEnd - 1, top + editorLineWidth);				PenNormal;			end;		if rownum = editorTotalRows + 1 then			FrameEditorMatrixRect;	end;{||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}{----------------------------------------------------------------------------}	procedure InvertAutoTabBox (box: rect);	begin		if ColorQDExists and false then			DropCursorID(160, box.left + 2, box.top - 1, blend)		else			InvertRect(box);	end;{----------------------------------------------------------------------------}	procedure DrawDataEditorLock;	var wh: point;		tport: WindowPtr;		oldClip: RgnHandle;		oldRGB: RGBColor;	begin		genericGetPort(tport);		genericSetPort(editorWindow);		oldClip := NewRgn;		GetClip(OldClip);		ClipRect(WindowPortRect(editorWindow));				SetGrayBackground(oldRGB,grayPale);				wh.h := WindowPortRect(editorWindow).right-scrollwidth;		wh.v := 0;		DrawLock(wh,true,false,Locked(lockData));				RGBBackColor(oldRGB);				SetClip(oldClip);		ZapRegion(oldClip);		genericSetPort(tport);	end;{----------------------------------------------------------------------------}	procedure DrawEditControls;		var			B, B2: rect;			tick, j, pos: integer;			oldClip: RgnHandle;			theButton: CIconHandle;			theBWButton: Handle;			wh: point;			ds: str255;			oldRGB: RGBColor;	begin{SetGrayBackground(oldBack,grayPlain);}		oldClip := NewRgn;		GetClip(OldClip);{next three lines are to fill upper left with gray}		SetRect(B, 1, 1, editorRowNameEnd, editorTitlesWidth - 1);		ClipRect(B);		{eraseRect(B);}				SetClip(oldClip);		ClipRect(WindowPortRect(editorWindow));		FrameRect(editorTitleCornerRect);		moveTo(0,0);	{	lineTo(editorRowNameEnd,editorTitlesWidth);}		moveTo(5,editorTitlesWidth-5);		TextFont(kFontIDGeneva);		TextSize(9);		if not editorTransposed then			DrawString('Taxa')		else			DrawString('Characters');		if not editorTransposed then			ds :='Characters'		else			ds := 'Taxa';		moveTo(editorRowNameEnd-StringWidth(ds)-5,editorTitleLineWidth);		DrawString(ds);		DrawDataEditorLock;		TextFont(editorFont);		TextSize(editorFontSize);				PenSize(editorGridThickness+editorExtraGridThickness,1);		moveTo(editorRowNameEnd-editorGridThickness-editorExtraGridThickness, 0);		lineTo(editorRowNameEnd-editorGridThickness-editorExtraGridThickness, editorTitlesWidth-editorGridThickness-editorExtraGridThickness);		PenSize(1,editorGridThickness+editorExtraGridThickness);		moveTo(0, editorTitlesWidth-editorGridThickness-editorExtraGridThickness);		lineTo(editorRowNameEnd, editorTitlesWidth-editorGridThickness-editorExtraGridThickness);				SetClip(OldClip);		SetGrayBackground(oldRGB,grayPale);{==== dropping down autotab cursors ====}		ClipRect(WindowPortRect(editorWindow));		SetRect(dataTabRightBox, 0, 0, 21, 15);		OffsetRect(dataTabRightBox, editorBoundaryRect.left + 6, editorBoundaryRect.bottom + 2);		dataTabDownBox := dataTabRightBox;		OffsetRect(dataTabDownBox, 22, 0);		{EraseRect(dataTabRightBox);}{next two lines are to fill lower left with gray}		{SetRect(B, editorBoundaryRect.left, editorBoundaryRect.bottom + 1, editorRowNameEnd, WindowPortRect(editorWindow).bottom - scrollwidth - 1);		EraseRect(B);}		if ColorQDExists then			begin				B := dataTabRightBox;				OffSetRect(B, 1, -1);				B.right := B.left + 32;				B.bottom := B.top + 32;				theButton := GetCIcon(302);				if theButton <> nil then					begin						PlotCIcon(B, theButton);						DisposeCIcon(theButton);					end;				B := dataTabDownBox;				OffSetRect(B, 1, -1);				B.right := B.left + 32;				B.bottom := B.top + 32;				theButton := GetCIcon(303);				if theButton <> nil then					begin						PlotCIcon(B, theButton);						DisposeCIcon(theButton);					end;			end		else			begin				DropCursorID(302, dataTabRightBox.left + 2, dataTabRightBox.top - 1, srcOr);				EraseRect(dataTabDownBox);				DropCursorID(303, dataTabDownBox.left + 2, dataTabDownBox.top - 1, srcOr);			end;		if autotabright then			InvertAutoTabBox(dataTabRightBox);		if autotabdown then			InvertAutoTabBox(dataTabDownBox);		RGBBackColor(oldRGB);{==== dropping down autotab cursors ====}		editMessagebox := dataTabDownBox;		editMessagebox.left := editMessagebox.right;		editMessagebox.right := editorRowNameEnd - 1;		editMessagebox.bottom := editMessageBox.bottom-1;		DrawEditMessageBox;		ZapRegion(oldClip);	end;{||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}{----------------------------------------------------------------------------}	procedure DrawSelectionQueryRectangle;	var box: rect;	begin		box := SelectionQueryRectangle;		EraseRect(box);		ShadeSelectedRectangle(box);		PenNormal;	end;{----------------------------------------------------------------------------}	procedure DrawCells (dofullgrid, changeclip, showSelection: boolean);		var			col,j: integer;			tport: WindowPtr;			oldRgn: RgnHandle;	begin{				lasttime := TickCount;}		genericGetPort(tport);		genericSetPort(editorWindow);		if changeclip then			ClipRect(WindowPortRect(editorWindow));	{	SetCursor(clockCursor);}		mySetPortTextFont(editorWindow,editorFont);		mySetPortTextSize(editorWindow,editorFontSize);		ClipRect(WindowPortRect(editorWindow));		DrawGrayEditorRgn(true);				{DrawSelectionQueryRectangle;}		DrawEditControls;		FrameEditorMatrixRect;{========| drawing main spreadsheet =======}		SetClip(EWClip);		DrawRowNames;		SetClip(EWClip);		if dofullgrid then			for col := 1 to editorColumns do				begin					DrawColCells(col, false, true, false,showSelection);					if col mod 20 = 0 then						CallWaitNextEventForDrawing;				end		else			for col := 1 to editorColumns do				begin					DrawColCells(col, true, false, false,showSelection);					if col mod 10 = 0 then						CallWaitNextEventForDrawing;				end;		if ConsensusSequenceVisible & editorTransposed then			for j := 1 to editorNumConsensusSequences do				DrawConsensusSequence(j,selectionModeAsIs);		{if editorSelected then			ReFixCell;}		ClipRect(WindowPortRect(editorWindow));		DrawFootText(false, false);		DrawGrowBox(editorWindow);		if isforeground then			DrawControls(editorWindow);		genericSetPort(tport);	{			if OptionDown then InstantInfo(StringFromNum(TickCount - LastTime));}	end;end.