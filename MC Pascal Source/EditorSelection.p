unit EditorSelection;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{ееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, 		ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  UtilLibInterface, MemoryUtil, CarbonUtil, SimpleUtil, 		WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, TypeUtil, CharUtil, TreeUtil, MenuUtil, SymbolsNames, 		FootNote, SpreadUtil, EditorCellEntry, ConsensusSequences;	function AllGapsSelected(missingAsGaps: boolean): boolean;	procedure BorderCell (colnum, rownum: integer);	procedure InvertSelRect (CellTL, CellBR: point);	procedure SelectSelRect (CellTL, CellBR: point);	procedure DeSelectSelRect (CellTL, CellBR: point);	procedure InvertOldCell;	procedure MovesTE;	procedure RefixCell;	procedure EndSetUpEdit (var TE: TEHandle);	procedure SetUpCellEdit;	procedure DiscardCellChanges;	procedure CleanOldCell (OldCellTL, OldCellBR: point);	procedure FixNewCell (NewCellTL, NewCellBR: point);	procedure ZeroSelection;	procedure QuickDeselectEditor ;	procedure UnSelectAll;	function DeSelectEditor: boolean ;	procedure DeselectAllConsenses;{ееееееееееееееееееееее}implementation {е$S SpreadUtil}{----------------------------------------------------------------------------}	function AllGapsSelected(missingAsGaps:boolean): boolean;  	label 1;	var 	allgaps: boolean;		st,et,sc,ec, it,ic: integer;	begin		allgaps:= true;		CalcSelectedTaxaCharacters(st, et, sc, ec, true);		if (st >= 1) & (sc >= 1) then			for it := st to et do			for ic := sc to ec do				if not IsGapLike(it,ic,missingAsGaps) then					begin						allgaps:= false;						goto 1;					end;1:		AllGapsSelected := allgaps;	end;{----------------------------------------------------------------------------}	procedure BorderCell (colnum, rownum: integer);{draws border around the single selected cell}		var			B: rect;			oldR: RgnHandle;	begin	{	oldR := NewRgn;		GetClip(oldR);		if colnum = 0 then			SetRect(B, 0, editorTitlesWidth + 1, editorRowNameEnd - 1, editorMatrixRect.bottom)		else if rownum = 0 then			SetRect(B, editorRowNameEnd + 1, 0, editorMatrixRect.right, editorTitlesWidth)		else			SetRect(B, editorRowNameEnd + 1, editorTitlesWidth + 1, editorMatrixRect.right, editorMatrixRect.bottom);		ClipEditBox(B);		B := CellRect(colnum, rownum);		B.bottom := B.bottom + 2;		B.left := B.left - 1;		B.top := B.top - 1;		PenMode(patXor);		PenSize(2, 2);		FrameRect(B);		PenNormal;		SetClip(oldR);		ZapRegion(oldR);}	end;{----------------------------------------------------------------------------}	procedure DrawEditorSelection (CellTL, CellBR: point; selectionMode: integer);		var			oldClip, dClip: RgnHandle;	begin		dClip := NewRgn;		oldClip := NewRgn;		GetClip(OldClip);		if (CellTL.v > 0) and (CellTL.h > 0) then			SetRectRgn(dClip, editorRowNameEnd, editorFirstRowTop, editorMatrixRect.right, editorMatrixRect.bottom)		else if (CellTL.v <= 0) and (CellTL.h > 0) then			begin				SetEWClip(horscroll);				CopyRgn(EWClip, dClip);				SetEWClip(noscroll);			end		else if (CellTL.h <= 0) and (CellTL.v > 0) then			begin				SetEWClip(vertscroll);				CopyRgn(EWClip, dClip);				SetEWClip(noscroll);			end		else			begin				SetEWClip(noscroll);				CopyRgn(EWClip, dClip);			end;		SectRgn(dClip, oldClip, dClip);		SetClip(dClip); {}		CopyRgn(dClip, EWClip);		if CellVisible(CellTL, CellBR) then			begin				if not UpdatePending(editorWindow) then					DrawDataCellsBetweenCorners(CellTL, CellBR,selectionMode)				else					InvalidateWindow(editorWindow, false);			end;		SetEWClip(noscroll);		SetClip(OldClip);		ZapRegion(dClip);		ZapRegion(oldClip);	end;{----------------------------------------------------------------------------}	procedure InvertOldCell;	{for temporary reversion of selection rectangle to unselected appearance}		var			oldstate: SignedByte;			oldClip: RgnHandle;	begin		if SingleCell then			begin				TEDeactivate(editorCellTE);				oldClip := NewRgn;				GetClip(oldclip);				ClipRect(editorFootNoteRect);				TEDeactivate(noteTE);				LockHandle(noteTE, oldstate);				EraseRect(noteTE^^.viewrect);				ResetHandle(noteTE, oldstate);				SetClip(oldclip);				ZapRegion(oldClip);				BorderCell(editorSelectionTopLeft.h, editorSelectionTopLeft.v);			end		else			begin				{DRMnewselect  InvertHiliteRect(editorSelectionRect);}				DrawDataCellsInRect(editorSelectionRect,selectionModeOff);			end;	end;{||||||||||||||||||||||||||||   Fixing Old and Newly Selected Cells   |||||||||||||||||||||||||||||||||}{----------------------------------------------------------------------------}	procedure MovesTE;{moves the text edit rectangle to the location of the currently selected cell}		var			box: rect;	begin		box := editorSelectionRect;		{insetrect(box, 2, 1);		if box.bottom - box.top > editorLineWidth then			box.top := box.bottom - editorLineWidth;		if (editorSelectionTopLeft.v <> 0) then			box.bottom := box.bottom + 1;}		if grid then			begin				box.right := box.right-editorGridThickness;				box.bottom := box.bottom-editorGridThickness;			end;		if editorSelectionTopLeft.h = 0 then			box.right := box.right-editorExtraGridThickness;		if editorSelectionTopLeft.v = 0 then			box.bottom := box.bottom-editorExtraGridThickness;		editorCellTE^^.destRect := box;		if editorSelectionTopLeft.h = 0 then			editorCellTE^^.destrect.left := editorCellTE^^.destrect.left + 6;		editorCellTE^^.viewRect := box;		{editorCellTE^^.viewrect.right := editorCellTE^^.viewrect.right - 1;}	end;{----------------------------------------------------------------------------}	procedure ReFixCell;{reselects cell that was temporarily deselected, e.g. for scrolling}		var			oldClip: RgnHandle;	begin		oldClip := NewRgn;		GetClip(OldClip);		SetClip(EWClip);		if SingleCell then			begin				if CellVisible(editorSelectionTopLeft, editorSelectionBotRight) then					begin						TEActivate(editorCellTE);						BorderCell(editorSelectionTopLeft.h, editorSelectionTopLeft.v);					end;				ClipRect(editorFootNoteRect);				TEActivate(noteTE);				TEUpdate(noteTE^^.viewrect, noteTE);			end		else if CellVisible(editorSelectionTopLeft, editorSelectionBotRight) then			DrawEditorSelection(editorSelectionTopLeft, editorSelectionBotRight,selectionModeOn);		SetClip(OldClip);		ZapRegion(oldClip);	end;{----------------------------------------------------------------------------}	procedure EndSetUpEdit (var TE: TEHandle);		var			oldstate: SignedByte;	begin		LockHandle(TE, oldstate);		EraseRect(TE^^.viewrect);		TEUpdate(TE^^.viewrect, TE);		TESetSelect(0, TE^^.selEnd, TE);		TEActivate(TE);		FixEditMenu;		ResetHandle(TE, oldstate);	end;{----------------------------------------------------------------------------}	procedure SetUpCellEdit;		var			oldstate: SignedByte;			oldClip: RgnHandle;	begin		LockHandle(editorCellTE, oldstate);		FillsTE(editorCellTE, CellString);		{if editorSelected & not someDataSel then			undoNameCellStringH^^ := CellString;}		MovesTE;		EndSetUpEdit(editorCellTE);		ResetHandle(editorCellTE, oldstate);		oldClip := NewRgn;		GetClip(oldClip);		ClipRect(editorFootNoteRect);		LockHandle(noteTE, oldstate);		FillnoteTE;		EraseRect(noteTE^^.viewrect);		if foottexton then			begin				TEUpdate(noteTE^^.viewrect, noteTE);				TEActivate(noteTE);				TESetSelect(32767, 32767, noteTE);			end;		ResetHandle(noteTE, oldstate);		SetClip(oldClip);		ZapRegion(oldClip);		SelCellChanged := false;		{SetLastChangeInEditor(lastChangeCantUndo);}{$IFC NOT ALWAYSENABLED}		myDisableItem(EditMHdl, UndoItem); {$ENDC}	end;{----------------------------------------------------------------------------}	procedure DiscardCellChanges;		var			box: rect;	begin		FillsTE(editorCellTE, CellString);		box := editorSelectionRect;		InsetRect(box, -2, -2);		InvalidateWindowRect(editorWindow,box,false);		EraseEditorRect(box);		badcellentry := false;	end;{----------------------------------------------------------------------------}	procedure CleanOldCell (OldCellTL, OldCellBR: point);{deactivating editorCellTE and noteTE, and redrawing cell contents}		var			B: rect;	begin		if editorSelected then			if EqualPt(OldCellTL, OldCellBR) then  {old selection was a single cell}				begin					ReturnValue(OldCellTL,false);					if badcellentry then						begin							if BadCellEntryQuery then								begin									badcellentry := false;   {discard changes, carry on to new cell}									InvalidateWindow(editorWindow, true);								end							else if badcellentry then								begin									editorSelectionTopLeft := OldCellTL;									editorSelectionBotRight := OldCellBR;									Exit(CleanOldCell);								end;						end;					if CellVisible(OldCellTL, OldCellBR) then						begin							if not poorentry then								TEDeactivate(editorCellTE);							TEDeactivate(noteTE);{    CellHor(OldCellTL.h, B.left, B.right,true);}{    CellVer(OldCellTL.v, B.top, B.bottom,true);}							if not poorentry then								begin									B := CellRect(OldCellTL.h, OldCellTL.v);									{InSetRect(B, 2, 2);									if OldCellTL.v = 0 then										B.bottom := B.bottom + 1									else										B.bottom := B.bottom + 2;}									EraseEditorRect(B);									if (OldCellTL.v > 0) and (OldCellTL.h > 0) then										begin											{B.bottom := B.bottom - 2;											InsetREct(B, -2, -2);}											WriteCell(B, OldCellTL.v, OldCellTL.h, -1, false, false,false, writeStandardCells);										end;									BorderCell(OldCellTL.h, OldCellTL.v);									if OldCellTL.v = 0 then										DrawColName(OldCellTL.h,selectionModeOff)									else if OldCellTL.h = 0 then										DrawRowName(OldCellTL.v,selectionModeOff);								end;						end;				end			else				begin					DrawEditorSelection(OldCellTL, OldCellBR,selectionModeOff);				end;	end;{----------------------------------------------------------------------------}	procedure FixNewCell (NewCellTL, NewCellBR: point);	begin		editorSelected := true;		CalcEditorSelectionRect(NewCellTL, NewCellBR);		if not poorentry then			if EqualPt(NewCellTL, NewCellBR) then				BorderCell(NewCellTL.h, NewCellTL.v)			else				begin					DrawEditorSelection(NewCellTL, NewCellBR,selectionModeOn);				end;	end;{-----------------------------------------------------------------------------}	procedure ZeroSelection;	begin		editorSelected := false;		footediting := false;		editorSelectionTopLeft.v := 0;		editorSelectionTopLeft.h := 0;		editorSelectionBotRight := editorSelectionTopLeft;		SetRect(editorSelectionRect, 0, 0, 0, 0);	end;{-----------------------------------------------------------------------------}	procedure UnSelectAll;		label			1;		var			tport: WindowPtr;			oldRgn: RgnHandle;	begin		genericGetPort(tport);		genericSetPort(editorWindow);		OldRgn := NewRgn;		GetClip(OldRgn);		if (editorSelectionTopLeft.v > 0) and (editorSelectionTopLeft.h > 0) then			SetEWClip(justdataAndConsenses)		else			SetEWClip(noscroll);		SetClip(EWClip);		if SingleCell then			begin				CleanOldCell(editorSelectionTopLeft, editorSelectionTopLeft);				if badcellentry then					goto 1;			end		else if CellVisible(editorSelectionTopLeft, editorSelectionBotRight) then  {not single cell}			DrawEditorSelection(editorSelectionTopLeft, editorSelectionBotRight,selectionModeOff);		ZeroSelection;{=== drawing FootText ===}		ClipRect(editorFootNoteRect);		EraseEditorRect(noteTE^^.destrect);		DrawFootText(true, false);		SetEWClip(noscroll);1:		SetClip(oldRgn);		ZapRegion(oldRgn);		genericSetPort(tport);	end;{----------------------------------------------------------------------------}	function DeSelectEditor: boolean ;	begin		DeSelectEditor:= true;	end;{----------------------------------------------------------------------------}	procedure QuickDeselectEditor ;	begin		SetPt(editorSelectionTopLeft,0,0);		SetPt(editorSelectionBotRight,0,0);		editorSelected := false;		SetRect(editorSelectionRect,0,0,0,0);			end;{-----------------------------------------------------------------------------}	procedure DeselectAllConsenses;	var consensusNumber: integer;	begin		if SomeConsensusSelected(consensusNumber) then			begin				SelectConsensus(consensusNumber,false);				DrawConsensusSequence(consensusNumber, selectionModeOff);			end;	end;end.