unit Speak;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, 		Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, CharUtil, BoxUtil, 		TaxonCHUtil, Settings, TreeUtil, SpreadUtil, ScrollSpread, SpeechSynthesis, Thermos;{$IFC SPEECH}	procedure SayStringChannel(ds: str255);	procedure SpeakMatrix(speakSelected: boolean);	procedure SpeakSettings;	procedure SpeakIt (ds: str255);	procedure SpeakResourceTEXT (resID: integer);{    var theSpeech: SpeechChannel;}{$ENDC}{еееееееееееееееееееееее}implementation {е$S Speak}{$IFC SPEECH}	const		speakmissing = 1000;		speakgap = 1001;		speakor = 1002;		speakand = 1003;		speaktaxon = 1004;		speakcharacter = 1005;		speaknumber = 1006;		speakmatchchar = 1007;		speakNotApplicable = 1008;	var		openbeak: boolean;{things to do: global boolean for matchchar pronunciation or not}{global booleans for voice info}{-----------------------------------------------------------------------------}	function SpeakStringChannel (stringToSpeak: str255): OSErr;	var	os:   OSErr;		theSpeech: SpeechChannel;	begin		theSpeech := nil;		os := NewSpeechChannel(NIL, theSpeech);            	   	IF (os = noErr) & (theSpeech<>nil) THEN			BEGIN                                                 	     			os := SpeakText(theSpeech, Ptr(ord4(@stringToSpeak)+1), length(stringToSpeak));	      			if (os=noErr) then	      			 	while (SpeechBusy <> 0) DO                {wait until speaking is done}						begin    						end; 				SpeakStringChannel := os;				os := DisposeSpeechChannel(theSpeech);			END;	end;{-----------------------------------------------------------------------------}	procedure SpeakResourceTEXT (resID: integer);{draws text from TEXT resource ID into the box of itemNum in theDialog}	var	H: Handle;		   myErr:   OSErr;		   myErr2:  OSErr;		   theSpeech: SpeechChannel;		   counter: longint;	begin		H := GetResource('TEXT', resID);		HLock(H);		myErr := NewSpeechChannel(NIL, theSpeech);             {create the channel}	   	IF (myErr = noErr) THEN			BEGIN                                                 {speak the string}	     			myErr := SpeakText(theSpeech, Ptr(GetMaster(H)), GetHandleSize(H));	     			counter := 0;	      			WHILE (SpeechBusy <> 0) DO                {wait until speaking is done}					BEGIN    						counter := counter + 1;	         				IF (Button | ((counter mod 5 = 0) & CommandPeriod)) THEN							myErr := StopSpeech(theSpeech);         {stop speech at mouse down}					END;  				IF (theSpeech <> NIL) THEN				 	myErr2 := DisposeSpeechChannel(theSpeech);			END;		HUnlock(H);		ReleaseResource(H);	end;{-----------------------------------------------------------------------------}	procedure SpeakIt (ds: str255);		var			sErr: OsErr;	begin		serr := SpeakString(ds);	end;{-----------------------------------------------------------------------------}	function ReturnResString (id: integer): str255;		var			sH: Stringhandle;			oldState: SignedByte;				begin		sH := GetString(id);		if (sH <> nil) & (ResError=noErr) then			begin				LockHandle(sH, oldState);				ReturnResString := sH^^;				ResetHandle(sH, oldState);			end		else			ReturnResString := '';	end;{-----------------------------------------------------------------------------}	procedure SayString (s: str255);		var			theText: Handle;			SErr: OSErr;			L: longint;			thepos: integer;			ds: str255;	begin		ds := s;		openbeak := not openbeak;		if openbeak then			SetCursID(304)   {openbeak}		else			SetCursID(305);		while pos(orsep, ds) > 0 do			begin				thepos := pos(orsep, ds);				delete(ds, thepos, 1);				insert(ReturnResString(speakOr), ds, thepos);			end;		while pos(andsep, ds) > 0 do			begin				thepos := pos(andsep, ds);				delete(ds, thepos, 1);				insert(ReturnResString(speakAnd), ds, thepos);			end;		if ds <> '' then			begin{$IFC TRUE}				serr := SpeakStringChannel(ds);{$ELSEC}				serr := SpeakString(ds);				currentIOPosition := 76;   {v3.05}				if OSSuccessful(serr) then					repeat					until (SpeechBusy <=0);{$ENDC}			end;	end;{-----------------------------------------------------------------------------}	procedure SayStringChannel(ds: str255);	var serr:OSStatus;	begin		serr := SpeakStringChannel(ds);	end;{-----------------------------------------------------------------------------}	procedure InvertCell (it, ic: integer);		var			speakcell: point;			tport: WindowPtr;	begin		genericGetPort(tport);		genericSetPort(editorWindow);		if not editorTransposed then			begin				speakcell.v := it;				speakcell.h := ic;			end		else			begin				speakcell.v := ic;				speakcell.h := it;			end;		if CellVisible(speakcell, speakcell) then			begin				InvertRect(CellRect(speakcell.h, speakcell.v));   				CallWaitNextEventForDrawing;			end;		genericSetPort(tport);	end;{-----------------------------------------------------------------------------}	procedure SayDataCell (it, ic: integer);		var			ds: str255;			tsts: largestsetchars;	begin		InvertCell(it, ic);		tsts := GetTaxonStsLargest(it, ic);		ds := StsToString(tsts, ic, editorShowFullStateNames & not nucleotides,editorShowIUPACSymbols);		if matchcharon & ((it <> 1) & (Gettaxonstslargest(1, ic) = tsts) & not (MSl in tsts)) then			ds := ReturnResString(speakMatchchar)  {say matchchar}		else if ds[1] = missing then			ds := ReturnResString(speakMissing)		else if ds[1] = gap then			if molecular then				ds := ReturnResString(speakGap)			else				ds := ReturnResString(speakNotApplicable);		SayString(ds);		InvertCell(it, ic);	end;{-----------------------------------------------------------------------------}{$SETC SPEAKSTOPBUTTON=TRUE}{as is; 837 ticks}{with only commandperiod removed: 774 ticks (gain of 63 ticks or 8%)}{with commandperiod removed and Delay(speechdelay, ticks) removed: 786}{with above removed + InvertCell nullified: 784 ticks}	procedure SpeakMatrix(speakSelected: boolean);		label			1, 2;		var			it, ic: integer;			initialic,initialit,startit, startic, endit,endic: integer;			db: boolean;			firstCell : boolean;			ds: str255;			theDialog: DialogPtr;			tempP: WindowPtr;	begin		ds := '';		it := 1;		ic := 1;		openbeak := true;		initialit:= 1;		initialic := 1;		startit := 1;		startic := 1;		endit := numtaxa;		endic := numchars;{    SpeechRate(TheSpeech, speechspeed);}		if speakSelected then			begin				if editorSelected then					if not editorTransposed then						begin							startit := editorSelectionTopLeft.v;							startic := editorSelectionTopLeft.h;							endit := editorSelectionBotRight.v;							endic := editorSelectionBotRight.h;						end					else						begin							startic := editorSelectionTopLeft.v;							startit := editorSelectionTopLeft.h;							endit := editorSelectionBotRight.h;							endic := editorSelectionBotRight.v;						end;				initialit := startit;				initialic := startic;			end		else if editorSelected and SingleCell then			begin				ReturnValue(editorSelectionTopLeft,false);				if badcellentry then					if BadCellEntryQuery then {v4: check: changed here}						DiscardCellChanges					else						Exit(SpeakMatrix);				if not editorTransposed then					begin						startit := editorSelectionTopLeft.v;						startic := editorSelectionTopLeft.h;						if startit < 1 then							startic := 1;					end				else					begin						startic := editorSelectionTopLeft.v;						startit := editorSelectionTopLeft.h;						if startic < 1 then							startit := 1;					end;				if startit < 1 then					startit := 1;				if startic < 1 then					startic := 1;				initialit := startit;				initialic := startic;			end;		FlushEvents(everyevent, 0);		it := initialit;		ic := initialic;		firstCell := true;{$IFC SPEAKSTOPBUTTON}		StartButtonThermo(theDialog, tempP,'Speaking Matrix');{$ENDC}		if not editorTransposed then			begin				while (it <= endit) do					begin						if not firstCell then							ic := startic;						firstCell := false;						if commandperiod or abortedThermo then							begin								if (ic = 1) and (it > 1) then									SelectCell(it - 1, numchars)								else									SelectCell(it, ic - 1);								goto 1;							end;						while (ic <= endic) do							begin								if commandperiod  or abortedThermo then									begin										SelectCell(it, ic - 1);										goto 1;									end;								if (ic = startic) then									begin										ds := ReturnResString(speakTaxon);										SayString(ds);{$IFC SPEAKSTOPBUTTON} 					UpdateButtonThermo(theDialog);	{$ENDC}										ds := TaxonName(it);										if (ds = '') or (ds = ' ') or (ds = '_') then											begin												NumToString(it, ds);												ds := concat(ReturnResString(speakNumber), ds);											end;{Delay(speechdelay, ticks);}										InvertCell(it, 0);										SayString(ds);										InvertCell(it, 0);										if commandperiod  or abortedThermo  then											begin												SelectCell(it, 0);												goto 1;											end;									end;{Delay(speechdelay, ticks);}{$IFC SPEAKSTOPBUTTON} 			UpdateButtonThermo(theDialog);	{$ENDC}								SayDataCell(it, ic);{$IFC SPEAKSTOPBUTTON} 			UpdateButtonThermo(theDialog);	{$ENDC}								if speechpause > 0 then									if (ic-startic+1) mod speechpause = 0 then										Delay(40, ticks);								ic := ic + 1;							end;						//startic := 1;						it := it + 1;					end;			end		else			begin				while (ic <= endic) do					begin						if not firstCell then							it := startit;						firstCell := false;						if commandperiod  or abortedThermo then							begin								if (it = 1) and (ic > 1) then									SelectCell(numtaxa, ic - 1)								else									SelectCell(it - 1, ic);								goto 1;							end;						while (it <= endit) do							begin								if commandperiod  or abortedThermo then									begin										SelectCell(it - 1, ic);										goto 1;									end;								if (it = startit) then									begin										SayString(ReturnResString(speakCharacter));{$IFC SPEAKSTOPBUTTON} 					UpdateButtonThermo(theDialog);	{$ENDC}										ds := CharName(ic);										if (ds = '') or (ds = ' ') or (ds = '_') then											begin												NumToString(ic, ds);												ds := concat(ReturnResString(speakNumber), ds);											end;{Delay(speechdelay, ticks);}										InvertCell(0, ic);										SayString(ds);										InvertCell(0, ic);										if commandperiod  or abortedThermo then											begin												SelectCell(0, ic);												goto 1;											end;									end;{Delay(speechdelay, ticks);}{$IFC SPEAKSTOPBUTTON} 			UpdateButtonThermo(theDialog);	{$ENDC}								SayDataCell(it, ic);{$IFC SPEAKSTOPBUTTON} 			UpdateButtonThermo(theDialog);	{$ENDC}								if speechpause > 0 then									if (it-startit+1) mod speechpause = 0 then										Delay(40, ticks);								it := it + 1;							end;						//startit := 1;						ic := ic + 1;					end;			end;		goto 2;1:		db := GetNextEvent(mdownmask, Event);  {get rid of button at end}2:{$IFC SPEAKSTOPBUTTON}		EndButtonThermo(theDialog, tempP, false);{$ENDC}	end;{$IFC FALSE}{-----------------------------------------------------------------------------}	procedure SpeakSettings;		var			voice: voiceSpecPtr;			os: oserr;			v, numVoices: integer;			infoLength: longint;			info: VoiceDescriptionPtr;	begin		numVoices := 1;		voice := VoiceSpecPtr(newPtr(SizeOf(voiceSpec)));		info := VoiceDescriptionPtr(newPtr(SizeOf(VoiceDescription)));		currentIOPosition := 77;   {v3.05}		if OSSuccessful(CountVoices(numVoices)) then			for v := 1 to numVoices do				begin					os := GetIndVoice(v, voice);					os := GetVoiceDescription(voice, info, infoLength);				end;	end;{-----------------------------------------------------------------------------}	procedure SetSpeechCharacters;		var			voice: voiceSpecPtr;			os: oserr;			v, numVoices: integer;			infoLength: longint;			voiceDesc: VoiceDescription;			chan: SpeechChannel;	begin		os := GetIndVoice(1, voice);		currentIOPosition := 78;   {v3.05}		if OSSuccessful(NewSpeechChannel(voice, chan)) then			begin				os := SetSpeechRate(chan, speechspeed);				os := SetSpeechPitch(chan, 100);			end;	end;{$ENDC}{-----------------------------------------------------------------------------}	procedure SpeakSettings;		var			theDialog: DialogPtr;			tempP: WindowPtr;			localItemHit: integer;			tspeechpause: longint;			ds: str255;{.................}		procedure CheckSpeechSettings;		begin			ItemCheckMark(theDialog, 4, speechpause > 0);			ItemCheckMark(theDialog, 6, speechpause = 0);		end;{.................}	begin		tspeechpause := speechpause;		StartDLOG(358, theDialog, tempP);		myShowDialog(theDialog);		if speechpause > 0 then			SetDLOGText(theDialog, 3, StringFromNum(speechpause), true);		CheckSpeechSettings;		FrameButton(TheDialog, 1);		repeat			ModalDialog(nil, localItemHit);			case localItemHit of				3, 4: 					begin						ds := GetEditText(theDialog, 3);						if StringIsLongint(ds) then							StringToNum(ds, speechpause)						else if ds <> '' then							begin								Beep;								if speechpause > 0 then									SetDLOGText(theDialog, 3, StringFromNum(speechpause), true)								else									SetDLOGText(theDialog, 3, '', true);							end;					end;				6: 					speechpause := 0;				8: 					begin						SetDialogValuesAsDefaults(theDialog, Speechid, 0, 0);					end;				otherwise					;			end;			CheckSpeechSettings;		until (localItemHit in [1, 2]);		if localItemHit = 2 then			begin				speechpause := tspeechpause;			end;		EndDLOG(theDialog, tempP);	end;{$ENDC}end.