unit InfoWindowsMisc;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}interface	uses		QuickDraw, 		Types, Events, QuickDrawText, OSUtils, Menus, TextUtils, Windows,		 Controls, Dialogs, TextEdit, Lists, ToolUtils, Memory, Fonts, Resources, Scrap, 		Globals, MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, 		SetLibInterface, UtilLibInterface, TaxonCHUtil, CharUtil, WriteUtil, TreeUtil, MenuUtil, SpreadUtil,TypeUtil, 		LinkUtil, InfoWindowsUtil,EditorCellEntry,CharPartitions;	function TypeSetSomeDirected (theTypeSetRow: integer): boolean;	function TypeSetSomeUserDefined (theTypeSetRow: integer): boolean;	function MaxWeightInSet (theWtSetRow: integer): str255;	function MinWeightInSet (theWtSetRow: integer): str255;	function NumMissingInCharacter (ic: integer; allTaxa: boolean): longint;	function NumGapsInCharacter (ic: integer; allTaxa: boolean): longint;	function NumMissingInTaxon (it: integer; allCharacters: boolean): longint;	function NumGapsInTaxon (it: integer; allCharacters: boolean): longint;	function FirstDataInTaxon (it: integer; allCharacters: boolean): longint;	function LastDataInTaxon (it: integer; allCharacters: boolean): longint;	function SequenceLength (it: integer; allCharacters: boolean): longint;	function NumPartTripletsInTaxon (it: integer; allCharacters: boolean): longint;	function NumStopCodonsInTaxon (it: integer; allCharacters: boolean): longint;	function NumPartsInPartition(thePartition: integer): longint;	function NumLowerCaseInTaxon (it: integer; allCharacters: boolean): longint;	function NumUncertaintyInTaxon (it: integer; allCharacters: boolean): longint;	function NumPolymorphismInTaxon (it: integer; allCharacters: boolean): longint;{еееееееееееееееееееееее}implementation {е$S InfoWindows}{v4: have user able to see Weighted character steps in char status window}{-----------------------------------------------------------------------------}	function TypeSetSomeDirected (theTypeSetRow: integer): boolean;  {sets wt of all excluded characters to zero; presumes an extendedHandle with no leading bytes & name etc.}		var			ic: integer;			intP: IP;			oldState: SignedByte;			H: Handle;			ds: str255;			directed: boolean;			thisType: integer;	begin		H := GetDirectLinkH(typeSetChain, LinkNumberFromInfoRow(typeSetChain,theTypeSetRow));		LockHandle(H, oldState);		intP := IP(GetMaster(H)+LinkOffSet(H));		directed := false;		for ic := 1 to numchars do			begin				thisType:= intP^;				if gettypeHdl(thisType)^^.polar then					begin						directed := true;						leave;					end;				intP := IP(ord4(intP) + chtb);			end;		ResetHandle(H, oldstate);		TypeSetSomeDirected:= directed;	end;{-----------------------------------------------------------------------------}	function TypeSetSomeUserDefined (theTypeSetRow: integer): boolean;  {sets wt of all excluded characters to zero; presumes an extendedHandle with no leading bytes & name etc.}		var			ic: integer;			intP: IP;			oldState: SignedByte;			H: Handle;			ds: str255;			userdefined: boolean;			thisType: integer;	begin		H := GetDirectLinkH(typeSetChain, LinkNumberFromInfoRow(typeSetChain,theTypeSetRow));		LockHandle(H, oldState);		intP := IP(GetMaster(H)+LinkOffSet(H));		userdefined := false;		for ic := 1 to numchars do			begin				thisType:= intP^;				if thisType >= usedef then					begin						userdefined := true;						leave;					end;				intP := IP(ord4(intP) + chtb);			end;		ResetHandle(H, oldstate);		TypeSetSomeUserDefined:= userdefined;	end;{-----------------------------------------------------------------------------}	function MinWeightInSet (theWtSetRow: integer): str255;  {sets wt of all excluded characters to zero; presumes an extendedHandle with no leading bytes & name etc.}		var			ic: integer;			intP: IP;			oldState: SignedByte;			H: Handle;			isReal: boolean;			minWt, thisWt: integer;			ds: str255;	begin		H := GetDirectLinkH(wtsetchain, LinkNumberFromInfoRow(wtsetChain,theWtSetRow));		LockHandle(H, oldState);		intP := IP(GetMaster(H)+LinkOffSet(H));		isReal := TestLinkBit(0,0,H,wtrealbit);		if isReal then 			minWt := MaxWtReal 		else			minWt := MaxWtInt;		for ic := 1 to numchars do			begin				thisWt:= intP^;				if thisWt < minWt then 					minWt := thisWt;				intP := IP(ord4(intP) + chwb);			end;		ResetHandle(H, oldstate);		if isReal then			begin				RealToString(minWt/WtInflate,ds,0.0000001, 2, false);				MinWeightInSet := ds;			end		else			MinWeightInSet := StringFromNum(minWt);	end;{-----------------------------------------------------------------------------}		function NumPartsInPartition(thePartition: integer): longint;		var			ic: integer;			intP: IP;			oldState: SignedByte;			H: Handle;			numParts: longint;			thisPart: integer;			ds: str255;	begin		for thisPart := 1 to numCharPartNames do 			SetPartNameInPartition(thisPart,false);		H := GetDirectLinkH(charpartitionchain, LinkNumberFromInfoRow(charpartitionchain,thePartition));		LockHandle(H, oldState);		intP := IP(GetMaster(H)+LinkOffSet(H));		for ic := 1 to numchars do			begin				thisPart:= intP^;				SetPartNameInPartition(thisPart,true);				intP := IP(ord4(intP) + chpartb);			end;		ResetHandle(H, oldstate);		numParts := 0;		for thisPart := 1 to numCharPartNames do 			if GetPartNameInPartition(thisPart) then 				numParts := numParts+1;		NumPartsInPartition := numParts;	end;{-----------------------------------------------------------------------------}	function MaxWeightInSet (theWtSetRow: integer): str255;  {sets wt of all excluded characters to zero; presumes an extendedHandle with no leading bytes & name etc.}		var			ic: integer;			intP: IP;			oldState: SignedByte;			H: Handle;			isReal: boolean;			maxWt, thisWt: integer;			ds: str255;	begin		H := GetDirectLinkH(wtsetchain, LinkNumberFromInfoRow(wtsetChain,theWtSetRow));		LockHandle(H, oldState);		intP := IP(GetMaster(H)+LinkOffSet(H));		isReal := TestLinkBit(0,0,H,wtrealbit);		maxWt := 0;		for ic := 1 to numchars do			begin				thisWt:= intP^;				if thisWt > maxWt then 					maxWt := thisWt;				intP := IP(ord4(intP) + chwb);			end;		ResetHandle(H, oldstate);		if isReal then			begin				RealToString(maxWt/WtInflate,ds,0.0000001, 2, false);				MaxWeightInSet := ds;			end		else			MaxWeightInSet := StringFromNum(maxWt);	end;{-----------------------------------------------------------------------------}	function NumMissingInCharacter (ic: integer; allTaxa: boolean): longint;	var dL: longint;		it: integer;		tsts: largestsetchars;	begin			dL:= 0;		for it := 1 to numtaxa do			if allTaxa | not treeopen | TaxonInTree(it) then				begin					tsts := gettaxonstsLargest(it, ic);					if tsts = [MSl] then						dL := dL + 1;				end;		NumMissingInCharacter:= dL;	end;{-----------------------------------------------------------------------------}	function NumGapsInCharacter (ic: integer; allTaxa: boolean): longint;	var dL: longint;		it: integer;		tsts: largestsetchars;	begin			dL:= 0;		for it := 1 to numtaxa do			if allTaxa | not treeopen | TaxonInTree(it) then				begin					tsts := gettaxonstsLargest(it, ic);					if tsts = [MSl,GAl] then						dL := dL + 1;				end;		NumGapsInCharacter:= dL;	end;{-----------------------------------------------------------------------------}	function NumPartTripletsInTaxon (it: integer; allCharacters: boolean): longint;	var	dL: longint;		 ic: integer;	begin			dL:= 0;		if someCoding then			for ic := 1 to numchars do				if allCharacters | CharIncluded(ic) then					if PartTripletStartsHere(it,ic) then						dL := dL+1;		NumPartTripletsInTaxon:= dL;	end;{-----------------------------------------------------------------------------}	function NumStopCodonsInTaxon (it: integer; allCharacters: boolean): longint;	const stopCodonState = 20;	var	codon: codontype;		 dL: longint;		 ic: integer;		tsts: largestsetchars;	begin			dL:= 0;		if (datatype=protein) then			begin				for ic := 1 to numchars do					if allCharacters | CharIncluded(ic) then						if gettaxonstsLargest(it, ic)  = [stopCodonState] then							dL := dL+1;			end		else if someCoding then			for ic := 1 to numchars do				if allCharacters | CharIncluded(ic) then					if (CharCodPos(ic)=1) & (ic <= numchars-2) then						if (CharCodPos(ic+1)=2) & (CharCodPos(ic+2)=3) then 							begin								PrepareAAfromDNA(it,ic,ic,tsts,false,writeStandardCells);								if tsts = [stopCodonState] then									dL := dL+1;							end;		NumStopCodonsInTaxon:= dL;	end;{-----------------------------------------------------------------------------}	function FirstDataInTaxon (it: integer; allCharacters: boolean): longint;	var	 dL: longint;		 ic: integer;		tsts: largestsetchars;	begin			dL:= numchars;		for ic := 1 to numchars do			if allCharacters | CharIncluded(ic) then				begin					tsts := gettaxonstsLargest(it, ic);					if (tsts<>[MSl,GAl]) & (tsts<>[MSl]) then						begin							dL := ic;							leave;						end;				end;		FirstDataInTaxon:= dL;	end;{-----------------------------------------------------------------------------}	function LastDataInTaxon (it: integer; allCharacters: boolean): longint;	var	 dL: longint;		 ic: integer;		tsts: largestsetchars;	begin			dL:= 1;		for ic := numChars downto 1 do			if allCharacters | CharIncluded(ic) then				begin					tsts := gettaxonstsLargest(it, ic);					if (tsts<>[MSl,GAl]) & (tsts<>[MSl]) then						begin							dL := ic;							leave;						end;				end;		LastDataInTaxon:= dL;	end;{-----------------------------------------------------------------------------}	function NumUncertaintyInTaxon (it: integer; allCharacters: boolean): longint;	var dL: longint;		ic: integer;		tsts: largestsetchars;	begin			dL:= 0;		for ic := 1 to numchars do			if allCharacters | CharIncluded(ic) then				begin					tsts := gettaxonstsLargest(it, ic);					if (tsts<>[MSl,GAl]) & (tsts<>[MSl]) & not MonomorphLg(tsts) & (UCl in tsts) then						dL := dL + 1;				end;		NumUncertaintyInTaxon:= dL;	end;{-----------------------------------------------------------------------------}	function NumPolymorphismInTaxon (it: integer; allCharacters: boolean): longint;	var dL: longint;		ic: integer;		tsts: largestsetchars;	begin			dL:= 0;		for ic := 1 to numchars do			if allCharacters | CharIncluded(ic) then				begin					tsts := gettaxonstsLargest(it, ic);					if (tsts<>[MSl,GAl]) & (tsts<>[MSl]) & not MonomorphLg(tsts) & not (UCl in tsts) then						dL := dL + 1;				end;		NumPolymorphismInTaxon:= dL;	end;{-----------------------------------------------------------------------------}	function NumLowerCaseInTaxon (it: integer; allCharacters: boolean): longint;	var dL: longint;		ic: integer;		tsts: largestsetchars;	begin			dL:= 0;		for ic := 1 to numchars do			if allCharacters | CharIncluded(ic) then				begin					tsts := gettaxonstsLargest(it, ic);					if (tsts<>[MSl,GAl]) & (tsts<>[MSl]) & AlternativeSymbol(it,ic) then						dL := dL + 1;				end;		NumLowerCaseInTaxon:= dL;	end;{-----------------------------------------------------------------------------}	function NumMissingInTaxon (it: integer; allCharacters: boolean): longint;	var dL: longint;		ic: integer;		tsts: largestsetchars;	begin			dL:= 0;		for ic := 1 to numchars do			if allCharacters | CharIncluded(ic) then				begin					tsts := gettaxonstsLargest(it, ic);					if tsts = [MSl] then						dL := dL + 1;				end;		NumMissingInTaxon:= dL;	end;{-----------------------------------------------------------------------------}	function NumGapsInTaxon (it: integer; allCharacters: boolean): longint;	var dL: longint;		ic: integer;		tsts: largestsetchars;	begin			dL:= 0;		for ic := 1 to numchars do			if allCharacters | CharIncluded(ic) then				begin					tsts := gettaxonstsLargest(it, ic);					if tsts = [MSl,GAl] then						dL := dL + 1;				end;		NumGapsInTaxon:= dL;	end;{-----------------------------------------------------------------------------}	function SequenceLength (it: integer; allCharacters: boolean): longint;	var dL: longint;		ic: integer;		tsts: largestsetchars;	begin			dL:= 0;		for ic := 1 to numchars do			if allCharacters | CharIncluded(ic) then				begin					tsts := gettaxonstsLargest(it, ic);					if tsts <> [MSl,GAl] then						dL := dL + 1;				end;		SequenceLength:= dL;	end;{-----------------------------------------------------------------------------}	procedure NumMPRs(ic: integer; var numResL: longint; var numResD: double; useDouble: boolean);	begin	end;end.