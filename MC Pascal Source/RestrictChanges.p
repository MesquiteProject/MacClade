unit RestrictChanges;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, TypeUtil, SymbolsNames, ChartWUtil;	procedure RestrictChangesDLOG (allowStasis: boolean; var ModifiedRestrict: boolean);{еееееееееееееееееееееее}implementation {е$S RestrictChanges}	type		ChangesBArray = array[0..absmaxstate, 0..absmaxstate] of rect;		ChangesBPtr = ^ChangesBArray;	var		changesBoxes: ChangesBPtr;		defaultPattern: boolean;{----------------------------------------------------------------------------}	procedure InvertChangesSelRect (j, k: integer);		var			box: rect;	begin{    with changesBoxes^[j, k] do SetRect(box, left + 1, top + 1, right, bottom);}		InvertRect(changesBoxes^[j, k]);	end;{----------------------------------------------------------------------------}	function RestrictChangesFilter (TD: DialogPtr; var Event: EventRecord; var localItemHit: INTEGER): BOOLEAN;		label			1;		var			k, j: integer;	begin		RestrictChangesFilter := FALSE;		GlobalToLocal(Event.where);		if (Event.what = keyDown) and HitReturn(Event) then			begin				localItemHit := PressButton(TD, 1);				RestrictChangesFilter := true;			end;		if (Event.what = mouseDown) then			begin				for j := 0 to maxChangesState do					for k := 0 to maxChangesState do						if CWShowConstant or (j <> k) then							if PtInRect(Event.where, changesBoxes^[j, k]) then								begin									if defaultPattern then										SetDLOGText(TD, 7, '', true);									defaultPattern := false;									changesSel^[j, k] := not changesSel^[j, k];									InvertChangesSelRect(j, k);									RestrictChangesFilter := true;									localItemHit := NotInDialog;									goto 1;								end;1:			end;		LocaltoGlobal(Event.where);	end;{-----------------------------------------------------------------------------}	procedure RestrictChangesUser (theDialog: DialogPtr; itemNo: Integer);		var			j, k: integer;			box: rect;	begin		FrameButton(theDialog, 1);		moveto(changesBoxes^[0, 0].left - 55, changesBoxes^[0, 0].bottom - 3);		DrawString('From:');		moveto(changesBoxes^[0, 0].left, changesBoxes^[0, 0].top - 20);		DrawString('To:');		if maxChangesState > 15 then			begin				TextFont(macCladeSmall);				TextSize(8);			end;		for j := 0 to maxChangesState do			{isfrom}			with changesBoxes^[j, 0] do				begin					moveto(left - 15, bottom - 3);					DrawChar(CharOfNum(j));				end;		for k := 0 to maxChangesState do			{isto}			with changesBoxes^[0, k] do				begin					moveto(left + 2, top - 5);					DrawChar(CharOfNum(k));				end;		if maxChangesState > 15 then			begin				TextFont(systemfont);				TextSize(0);			end;		for j := 0 to maxChangesState do			for k := 0 to maxChangesState do				begin					with changesBoxes^[j, k] do						SetRect(box, left - 1, top - 1, right, bottom);					PenPat(QDGray);					FrameRect(box);					PenPat(QDBlack);					if changesSel^[j, k] then						if CWShowConstant or (j <> k) then							InvertChangesSelRect(j, k);				end;	end;{-----------------------------------------------------------------------------}	procedure RestrictChangesDLOG (allowStasis: boolean; var ModifiedRestrict: boolean);		label			1, 2;		var			theDialog: DialogPtr;			box: RECT;			itemtype, j, k, startleft, starttop, boxwidth, boxheight: integer;			H: Handle;			tempP: WindowPtr;DLOGFilterUPP: UniversalProcPtr;			oldchangesSel: ChangesSelPtr;			oldState: SignedByte;			localItemHit: integer;UserItemUProcP: UniversalProcPtr;	begin		defaultPattern := true;		if AnyType([usedef]) then			maxChangesState := MaxStateDefinedAllUseDef(true)		else			maxChangesState := MOS;		oldchangesSel := ChangesSelPtr(NewPtr(SizeOf(ChangesSelArray)));		oldchangesSel^ := changesSel^;		changesBoxes := ChangesBPtr(NewPtr(SizeOf(ChangesBArray)));		if not allowStasis then			for j := 0 to maxChangesState do				changesSel^[j, j] := false;		StartDLOG(591, theDialog, tempP);		box := WindowPortRect(myGetWindowPtrForDialog(theDialog));		box.right := box.right - 20;		with box do			begin				startleft := 60;				starttop := 50;				boxwidth := (right - left - startleft * 2) div (maxChangesState + 1);				if boxwidth > 30 then					boxwidth := 30;				boxheight := (bottom - top - starttop * 2) div (maxChangesState + 1);				if boxheight > 20 then					boxheight := 20;				startleft := (right - left - boxwidth * (maxChangesState + 1)) div 2;				starttop := (bottom - top - boxheight * (maxChangesState + 1)) div 2;				for j := 0 to maxChangesState do					for k := 0 to maxChangesState do						SetRect(changesBoxes^[j, k], startleft + k * boxwidth, starttop + j * boxheight, startleft + (k + 1) * boxwidth, starttop + (j + 1) * boxheight);			end;		myShowDialog(theDialog);		if not nucleotides then			begin				HideDialogItem(theDialog, 9);				HideDialogItem(theDialog, 10);			end;UserItemUProcP := MyNewUserItemUPP(@RestrictChangesUser);  H := Handle(UserItemUProcP);		SetRect(box, 0, 0, 10, 10);		SetDialogItem(theDialog, 3, UserItem, H, box);		LockHandle(CWClassName, oldState);		SetDLOGText(theDialog, 7, CWClassName^^, true);		ResetHandle(CWClassName, oldState);		DLOGFilterUPP := MyNewModalFilterUPP(@RestrictChangesFilter);  2:		repeat			myModalDialog(DLOGFilterUPP, localItemHit);			case localItemHit of				5:   {none}					begin						SetDLOGText(theDialog, 7, 'No changes', true);						for j := 0 to maxChangesState do							for k := 0 to maxChangesState do								begin									if changesSel^[j, k] then										InvertChangesSelRect(j, k);									changesSel^[j, k] := false;								end;						defaultPattern := true; {this means that a default restrict changes pattern has been chosen}					end;				6: 			{all}					begin						SetDLOGText(theDialog, 7, 'all events', true);						for j := 0 to maxChangesState do							for k := 0 to maxChangesState do								if (allowStasis and CWShowConstant) or (j <> k) then									begin										if not changesSel^[j, k] then											InvertChangesSelRect(j, k);										changesSel^[j, k] := true;									end;						defaultPattern := true;					end;				9: 					begin						SetDLOGText(theDialog, 7, 'Transversions', true);						for j := 0 to maxChangesState do							for k := 0 to maxChangesState do								if (abs(k - j) <> 2) and (j <> k) then									begin										if not changesSel^[j, k] then											InvertChangesSelRect(j, k);										changesSel^[j, k] := true;									end								else									begin										if changesSel^[j, k] then											InvertChangesSelRect(j, k);										changesSel^[j, k] := false;									end;						defaultPattern := true;					end;				10: 					begin						SetDLOGText(theDialog, 7, 'Transitions', true);						for j := 0 to maxChangesState do							for k := 0 to maxChangesState do								if (abs(k - j) = 2) and (j <> k) then									begin										if not changesSel^[j, k] then											InvertChangesSelRect(j, k);										changesSel^[j, k] := true;									end								else									begin										if changesSel^[j, k] then											InvertChangesSelRect(j, k);										changesSel^[j, k] := false;									end;						defaultPattern := true;					end;				otherwise					;			end;		until (localItemHit in [1, 2]);		if localItemHit = 1 then			begin				ModifiedRestrict := true;				if charton & ((CWChart = CWCSteps) & (CWStepsShow = CWstepsChanges)) then					golist := golist + [changesall];				golist := golist + [stepsChgschart, stepsChgsAllchartmult, stepsChgsichartmult];				golist := golist + [ChangesIchart, ChangesIchartmult, ChangesAllchart, ChangesAllchart, ChangesAllchartMult];				CWClassName^^ := GetEditText(theDialog, 7);				if CWClassName^^ = '' then					begin						InstantInfo('Please give a name to the class of changes.');						goto 2;					end;				changesRestricted := false;				for j := 0 to maxChangesState do					for k := 0 to maxChangesState do						if CWShowConstant or (j <> k) then							if not changesSel^[j, k] then								begin									changesRestricted := true;									goto 1;								end;1:			end		else			begin				changesSel^ := oldchangesSel^;				ModifiedRestrict := false;			end;		MyDisposeUserItemUPP(UserItemUProcP);		MyDisposeModalFilterUPP(DLOGFilterUPP);		EndDLOG(theDialog, tempP);		ZapPointer(changesBoxes);		ZapPointer(oldchangesSel);	end;{-----------------------------------------------------------------------------}end.