unit ErrorUtil;{еееееееееееееееееееееее}{MacClade Source Code}{Copyright Wayne P. Maddison and David R. Maddison 1986-1991}{No portions of the source code of MacClade can be used in any program,}{or published in any form, without the express written consent of }{Wayne or David Maddison}{еееееееееееееееееееееее}{еееееееееееееееееееееее}interface	uses		Quickdraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, 		TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface, MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, EventUtil, Script;	procedure NewError (ierrnum, ierrchar: integer);		function ErrorPosted (ierrnum: integer): boolean;	procedure ShowErrors (note: str255);	procedure ZeroErrorSet (errset: ptr);	function NumErrorWords: integer;	procedure RemoveError (ierrnum: integer);		procedure InstantError (errnum: integer);	procedure InstantErrorPlus (errnum: integer; note: str255);	procedure InstantInfo (warn: str255);	function CWarning (warn: str255; button1, button2: str32): boolean;	procedure NewsFlash (newsID: integer);	function IOSuccessful (resultcode: integer): boolean;	function OSSuccessful (OS: OSErr): boolean;	function MemoryOK: boolean;	function SetHandleSizeSuccessful(H: univ Handle; Hsize: longint): boolean;	function NewHandleSuccessful (H: univ Handle; Hsize: longint): boolean;	procedure PostBackGroundNotification;	procedure RemoveBackGroundNotification;		const		highesterror = 512;{еееееееееееееееееееееее}implementation {е$S ErrorUtil}{|||||||||||||||||||||||||||||||||||||| Error System |||||||||||||||||||||||||||||||||||||||||||}{There are 4 basic error/Warning systems:}{NewError (posted errors): get reported in Main Event Loop; string stored in rsrc 259}{InstantError: get reported instantly; string stored in rsrc 259}{InstantErrorPlus: get reported instantly; string stored in rsrc 259 but additional string is}{	passed to be added to rsrc string.  If rsrc string contains 'xxx', the additional string is}{    inserted there; otherwise it is concatenated}{NOTE that all errors are stored in the same resource.  This allows a single numbering system,}{and will make it easier for us to go through these errors and add page number references}{to manual.}{In addition to errors, InstantInfo (formerly oops) is now used strictly for information - no}{error messages - such as telling the user the number of resolutions}{also, InstantInfo, gets reported instantly, string passed to procedure}{-----------------------------------------------------------------------------}{Errors}{#			UNIT					PROCEDURE						ERROR	}{1			CharUtil,Count		FindPat, RecTraced		state higher than maxst for character}{2			CharUtil				Maxmin							ER in result (usually empty set)	}{3			PolyCalc,Count		Polycalc,RecTraced				illegal character type in polycalcs	}{4.  ACCTRAN/DELTRAN used only for characters of unordered and ordered type.}{5			Calc					StSetOp							Dollo in StSetOp	}{6			Calc					UpPass							Dollo in uppass	}{7.			Equivocal				FirstResInClade					fixanc with cycling	}{8			Equivocal				FirstResInClade					polytomies with cycling	}{9			Calc					TriplePass						highbits in set	}{10.  Empty set found in Final pass of algorithms.  May indicate you have violated or made inconsistent assumptions.}{11.	Error: State set at node includes states not listed in legend}{12.	doublecheckreconstruct error: downpass}{13.	Not that many reconstructions; last reconstruction will be shown}{14		Count					CountTree							Infinite number of steps in user-defined character	}{15.	ACCTRAN/DELTRAN turned off because character is not of unordered or ordered type.}{16	Infinity required in polymorphic terminal taxon}{17. Invalid number specification found where number expected}{18		TreeMakerUtil		NewNode()						empty slot not found	}{19		SetStates				CalcMinCharLen					too many non-singleton nodes for unordered CI	}{20		CalcUtil				AddDistBetweenSets				irreversibility of character violated	}{21		StringIn				ExtendSet							Weight out of bounds	}{22		StringIn				ExtendSet							Real and integer weights mixed	}{23		StringIn				ExtendSet							misformatted wtset ( '=' not found)	}{24		Attempt to trace or count excluded character	}{25		Genchar				GenDownPass						polymorph3;  count or trace may be incorrect	}{26.	Transformation type definition violates the triangle inequality.}{27		ReadTreeFile			PackTree							taxon in tree that is not in matrix	}{28		ReadTreeFile			PackTree							tree making stumbled - description bad?	}{29		ReadTreeFile			PackTree							unknown tree format	}{30. Stratigraphic character has ancestor and descendant in same stratum.  ***PROBABLY NOT CALLED}{31. Taxon with multiple states in Dollo character fixed as ancestor; trace and count may be incorrect.}{32.	Neither polytomies nor fixed ancestors allowed when maximum option in use with Trace All Changes. }{33.	Types cannot be applied to some characters. }{34. Slant inconsistent with left/right status of node}{35. Some trees not processed because they were faulty, or included aspects (polytomies, fixed ancestors) not allowed in current situation.}{36. Trace cannot be done because all characters excluded.}{37. Problems in restoring fixed states in stored tree!}{38. Some tree description(s) contained too many taxa not in matrix and were ignored.}{39. Some trees in file were deleted because they included less than three valid taxa.}{40. Tree in tree window replaced with default ladder because all of its taxa were deleted.}{41. Character(s) cannot be included because the tree has polytomies or observed taxa fixed as ancestors, or the assigned types of the characters are not defined for all states in the characters.}{42. Bad definition(s) of user-defined transformation types.}{43. Attempt to use ACCTRAN/DELTRAN with Irreversible, Dollo or User-defined type character.}{44.	Some trees were not included in chart calculations because of user abort.}{45.	ACCTRAN/DELTRAN not used in chart calculations.}{46.	Polytomies and ancestor fixing not allowed when DELTRAN/ACCTRAN in effect}{47. Bad label in tree translation table.}{48. DELTRAN/ACCTRAN turned off because not allowed with polytomous tree.}{49. DELTRAN/ACCTRAN turned off because not allowed with taxa fixed as ancestors.}{50. 	Some unambiguous changes within terminal polymorphisms may not have been counted.}{51. Missing or illegal character value with continuous character}{52. State value too high found in calculations with Dollo character}{53. Empty set encountered (SpreadUtil, tracelabels, etc).}{54. Infinite branch length found (TraceAllChangesCalc) [52-54].}{55. Bad taxon name in continuous data block in file. (ReadData)}{56. Can''t collapse branch if any taxa made ancestral}{57. Can collapse branch only if all characters are of unordered or ordered type}{58. Can''t collapse branch if continuous character traced minimizing sum of changes (manhattan).}{59. Only terminal taxa can be fixed as ancestors}{60. Can''t make taxon into ancestor if there are polytomies}{61. Terminal taxa cannot be fixed as ancestors if some characters are of Dollo or user-defined type.}{62. Can''t make taxon into ancestor if continuous character traced}{63. Chart has chosen only one of possible pathways of change within polymorphic terminal taxa for some unordered character(s) }{64. Error: polytomies found in ACCTRAN/DELTRAN procedure.}{65.  Can't have uncertain-resolution polytomies with continuous character traced}{66.  Can't calculate weighted branch lengths for ambiguous/not max changes}{67.  No continuous characters available.}{68.  Can't trace continuous characters with "soft" polytomies}{69.  Can't trace continuous characters with polytomies when minimizing sum of changes (manhattan).}{70.  Can't trace continuous characters with polytomy at root when minimizing sum of squared changes (unrooted).}{71.  Can't trace continuous characters with terminal taxa fixed as ancestors}{72.  Calculations aborted.  Chart may display incorrect information.}{73.  Calculations aborted.  Changes/branch lengths will be turned off.}{74.  Attempt to show chart based on traced character when no character is traced.}{75.  Empty set in equivocal cycling.}{76. Type cannot be applied (character has too many states, or tree has polytomies or fixed ancestors)}{77.  Quickest Descent search option used because some characters are of stratigraphic, Dollo or User-defined types}{78.  Polytomies and fixing taxa as ancestors not allowed when equivocal cycling is needed.}{79. Polytomies and ancestor-fixing not allowed together.}{80. Changes from fixed terminal branch to uncertain terminal taxon not counted. }{81. 'CI/RI/RC can''t be calculated for any characters.'}{82. 'RI/RC can''t be calculated for any characters.'}{83. CI/RI/RC will exclude characters of stratigraphic, dollo and user defined types}{84. RI/RC will exclude characters of irreversible, stratigraphic, dollo and user defined types}{85. Recoding attempted to state not allowed for character type.}{86. Polytomous root has forced use of Rooted option for squared change parsimony.}{87.  More than xxx chart intervals not allowed. }{88. Invalid character state symbol}{89. can't include character because new states added that are outside of setdefined of that type of character}{90. Observed taxon in ancestral position is polymorphic in some chars.  Tracing and number of steps may be incorrect for non-stratigraphic characters!}{91. Only characters of unordered and ordered types were processed to exclude uninformative.}{92. Changes within terminal taxa polymorphic for 3 or more states in user-defined character not included within chart.}{93.  Some continuous character(s) contain missing or illegal values.}{94. Too many nodes in polytomy for unordered character.  Character evolution will be reconstructed incorrectly.}{95. some of the settings could not be read from the settings file}{96. At least one polytomy has been resolved arbitrarily!}{97. Too many user-defined types in file; limit is 245.}{98. Undefined state symbols present in definition of user-defined type}{99.  'Cost value in user-defined type higher than the maximum allowable (99.9 or 999).  All elements divided by 10's until small enough.'}{100. Weights for some characters reduced to 1 in exported PHYLIP file}{101. Some polymorphic entries converted to missing data to make text file MacCladeReadable.}{102. Some entries could not be merged to preserve original states.}{103.  Illegal state symbols: two symbols differ only in being upper and lower case.}{104. Can''t edit pictures as temporary file for storing pictures cannot be written to disk.}{105. Maximum number of lines in branch list window is 4000 - subsequent lines omitted.}{106. Illegal character in state name deleted.}{107. Can''t go to tree window or make trees when there less than three taxa.}{108. Invalid character state symbol}{109. Because Shift and Option key were held down, Branch Swap sought to increase tree length. }{110. Error: Overflow in calculations of treelength; treelength is not correct!}{111. Error: Number of steps counted does not match number of steps rechecked.  An expected error, because detected in character with polymorphic taxon fixed as ancestor}{112. Illegal state name.}{113. No trees examined in chart calculations!}{114.  The tree cannot be shrunk as far as requested, as taxon names would overlap.}{115.  Some taxa appear more than once in tree description.}{116.  Taxa present in translation table not present in data matrix.}{117.  Problem encountered while attempting to read tree file.}{118.  Footnotes cannot be more than 255 characters in length.}{119. Chart requires more than the maximum number of intervals; a partial chart will be presented.}{120. Tree that is currently illegal will be placed as Undo tree. To see it, remove prohibiting conditions and choose Undo from the Edit menu.}{121.  Cannot swap if all characters excluded.}{122. Tree could not be made; default ladder was made instead.}{123. Some states in clipboard omitted during paste as greater than current maximum state.}{124. More taxa or characters in data matrix than specified by DIMENSIONS command.}{125. Some states were not changed as new state was not allowed given the type of the character.}{126. At least one of missing, gap, matchar, and state symbols multiply defined.}{127. Traced character excluded or deleted; other character traced}{128. Printed tracing of current character on screen will not show fixing of states.}{129. Error: Number of steps counted does not match number of steps rechecked.  This may indicate serious problems.}{130. Invalid number specified in dialog box.}{131. Fixing of states at branches not preserved by Undo}{132. 'State was unfixed on branches involved in branch move. '}{133.  'Fixing of observed taxon as ancestor at root was destroyed by branch move '}{134.  'Observed taxon fixed as ancestor was made terminal. '}{еее135.  'Node of tree could not be built because of lack of memory.  Some taxa were excluded from tree. '}{136.  Can't fix observed taxon as ancestor if its ancestor is already another observed taxon'}{137.  Chart closed because traced character is now of type not allowing CI, RI, or RC calculations}{138.  Too many DATA or CHARACTERS blocks in file!}{139.  MacClade only reads pictures of FORMAT=PICT. }{140.  MacClade only reads pictures stored in the resource fork (SOURCE=RESOURCE).}{141. 'Only minima of observed states used' }{142.  'Reconstruction of continuous character appears faulty}{143. Shade of QDGray not found.}{144. No Trees found in treefile.}{145. Sum of probabilities in at least one row not near enough to 1.0!}{146. Sorry, can't cycle through possible reconstructions if there are polytomies.}{147. Sorry, can't cycle through possible reconstructions if ancestors are fixed.}{148. Sorry, can't cycle through possible reconstructions if DELTRAN or ACCTRAN active.}{149. Overflow in exact calculations  -- simulations are required.}{150. Character correlation test only works if character is traced.}{151. Character traced must be binary (0,1) for correlation test.}{152. Codon Positions could not be calculated on a non-contiguous set of characters.}{153. 'Type name not recognized: xxx.  The type may be missing or improperly defined.'}{154. Sorry, not enough room on disk to make temporary printing file.  Printing aborted.}{155. Printing stopped at your request.}{еее156. Sorry, not enough memory to complete printing.  Printing aborted.}{157. Hey! This is the help file! It is not a data file!}{158. Elements in file foreign to MacClade.  File will open as Untitled.}{159. That won't do much good! That's your data file.}{160. No user-defined types found in file!}{161. For help, you need to find and open file xxx}{162.'The following type is not defined for all the states found in characters xxx'}{163. Some polymorphisms have been converted to uncertainties during adjustment of disjunct amino acids.}{164. Negative weights not allowed.}{165. Decimal weights above xxx not allowed.(ClickInCharWindow)}{166. Integral weights above xxx not allowed. (ClickInCharWindow)}{167. MacClade is not capable of editing PICT files.}{168. Traced character is now excluded or deleted .}{169. File includes elements other than trees; treefile will open as Untitled .}{170.  'Error: attempt to save tree when none exists'}{еее171. 'Not enough memory to store.  Approximately xxx more memory needed.'}{172. Can''t delete all taxa and characters'}{173. 'Can''t delete all taxa'}{174. 'Can''t delete all characters'}{175. Can''t delete all xxx}{176. 'Can''t reconstruct continuous character on one taxon tree'}{177. 'Tree contains too many taxa.'}{еее178. 'Not enough memory to make tree.  Approximately xxx more memory needed.'}{179. 'Any taxa fixed as ancestors in clade will be made terminal. '}{180. 'Searching cannot be done if some taxa are fixed as ancestors. '}{еее181. 'Memory full problem'}{182. 'Error: simulation did not assign changes to branches evenly'}{183. 'Problem in calculations: probabilities do not sum to 1.'}{184. 'Calculations cannot be done if there are no gains or losses'}{185. 'Calculations cannot be done if there are more gains and losses than branches in the clade selected'}{186. 'Cannot do correlation test if taxa fixed as ancestors'}{187. 'Can''t build random tree of only one taxon'}{188. 'Sorry, treefiles to be processed into charts must be NEXUS treefiles.'}{189. 'Illegal probability value'}{190. 'Weight too big' (DEVELOPMENT ONLY)}{191. 'MacClade does not support font sizes greater than 127'}{192. 'The list is too long to be shown!'}{193. 'All user-defined types pass triangle inequality check'}{194. 'No types are user-defined'}{195. 'Current type is not user-defined'}{196. 'Check only matrix types'}{197. 'Type passes triangle inequality check' (TypeDlogUtil)}{198. 'If you want continuous values, use Continous... button'}{199. 'type value too high'}{200. 'Can''t make continuous since some values in matrix are larger than 99'}{201. 'not triangle violated' (TypeDlog; DRMMETRIC only)}{202. 'Maximum number of types is xxx; can't add any more.'}{203. 'User-defined and Dollo types not allowed when ancestors fixed. '}{204. 'Only unordered and ordered characters allowed when there are polytomies. '}{205. 'Sorry, there was a problem with printing (error xxx), and it was not completed.''}{еее206. 'Printing of some trees failed due to lack of memory'}{207. 'Branches must be square'}{208. 'Incorrect data file format'}{209. 'This is a treefile -- please open a data file first.' }{210. 'Continuous Block must have 4 or fewer characters'}{211. 'Some characters not of ordered or unordered type - MacClade cannot translate to Hennig86 v1.5'}{212. 'Some characters with state higher than 9 - MacClade cannot translate to Hennig86 v1.5'}{213. 'Some taxa polymorphic or with partial uncertainties - MacClade cannot translate to Hennig86 v1.5'}{214. 'Some characters of stratigraphic or user-defined types - MacClade cannot translate to PHYLIP'}{215. 'Some characters multistate - MacClade cannot translate to PHYLIP'}{216. 'Some taxa polymorphic or with partial uncertainties - MacClade cannot translate to PHYLIP'}{217. 'no weights changed'}{218. 'can''t choose userdef' }{219. 'Select characters in Character List window first'}{220. 'Can''t make continuous since some characters have weight larger than 99'}{221. 'Choose weights to change by selecting appropriate cells in Character List Window'}{222. 'Use discrete/continuous menu item if you want to use continuous-valued weights'}{223. 'Trees must have at least three taxa'}{224. 'State fixed at branch will be lost'}{225. 'Excluded are characters uninformative for taxa in current tree; thus Tree window must be open'}{226. 'Can''t show numbers of changes if equivocal cycling not legal on current tree'}{227. Chart cannot use current tree because it has polytomies or observed taxa fixed as ancestors, preventing equivocal cycling.}{228. 'Please make sure the disk is unlocked and MacClade itself is not a locked file before using this copy of MacClade}{229. 'This test version of MacClade has expired'}{230. 'The "Change From" and "Change To" entries are equivalent!'}{231. 'That kind of change is not allowed!'}{232. 'Printing not allowed from Finder - File will simply be opened'}{233. 'Chart closed  because character no longer traced'}{234. 'Non-standard amino acids exist in matrix - MacClade cannot translate to PHYLIP'}{235. 'Chart closed  because traced character excluded'}{236. 'Can''t collapse branch if any taxa made ancestral'}{237. 'Can collapse branch only if all characters are of unordered or ordered type'}{238. 'Can''t collapse branch if Trace All Changes (All possible/maximum number) in use.'}{239. 'Can''t collapse branch if ACCTRAN/DELTRAN in use.'}{240. 'Can''t collapse branch if continuous character traced minimizing sum of changes (manhattan).}{241. 'Can''t have SOFT polytomy if continuous character traced.'}{242. 'Can''t have polytomous Root if continuous character traced minimizing sum of squared changes (unrooted).'}{243. 'Can''t collapse branch if equivocal cycling is needed.'}{244. 'File format error: 'xxx' not found.' (ReadUtil only)}{245. 'Undefined transformation type: xxx'}{246. 'MacClade only supports extension ".up" to type xxx'}{247. 'Can''t have nested charsets'}{248. 'Sum of probabilities not close enough to 1.0'}{249. 'Significant digits must be between 1 and 4'}{250. 'Polytomies allowed only with characters of unordered and ordered type.'}{251. 'Taxa with identical names present: saving trees to file and other operations may fail.'}{252. 'Too many characters to list...'}{253. 'Unnamed states cannot be terminal in character state tree; they will be removed.'}{254. 'You can''t redefined a pre-defined type'}{255. 'improper matrix size' (typenewdlog)}{256. 'That type is currently in use - all characters of that type will be changed to the default type'}{257. 'Must have two or more taxa on screen' (LaserTree)}{258. 'Data matrix contains too few elements!' (ImpForeignFiles, read matrix)}{259. 'Illegal data entry!' (ImpForeignFiles)}{260. 'This data file was saved by a test copy of MacClade. Any results based upon that test copy of MacClade may be false and should not be published.'}{261. 'MacClade does not support data format: xxx'}{262. 'MacClade cannot support more than 26 states per character'}{263. 'MacClade does not support 'xxx' in FORMAT. MacClade will close file.' }{264. 'MacClade does not support MSTAXA option 'xxx'.}{265. 'MacClade does not support IGNORE option 'xxx'.}{266. 'MacClade does not support GAPMODE option 'xxx'.}{267. 'MacClade does not support 'xxx' in OPTIONS.'}{еее268. 'Not enough memory to read in data matrix; MacClade will close file.  Approximately xxx more memory needed.'}{269. 'TAXA block does not contain a DIMENSIONS statement!'}{270. 'CHARACTERS block does not contain a DIMENSIONS statement!'}{271. 'DATA block does not contain a DIMENSIONS statement!'}{272. 'NTAX specification in DIMENSIONS statement of DATA or CHARACTER block ignored!'}{273. 'NCHAR specification in DIMENSIONS statement of TAXA block ignored!'}{274. Too many taxa in data file. MacClade will close file. '}{275. Too many characters in data matrix. MacClade will close file.}{276. 'OPTIONS command ignored in continuous CHARACTER blocks!'}{277. 'TAXLABELS command ignored in CHARACTER blocks!'}{278. 'TAXLABELS command ignored for non-transposed matrices!'}{279. Two or more xxx blocks in file.  Only one will be processed; the remainder will be stored and skipped.}{280. 'CHARLABELS command ignored for transposed matrices!'}{281. 'STATELABELS command ignored in continuous CHARACTER blocks!'}{282. 'MacClade does not support interleaved transposed matrices'}{283. 'MacClade does not support interleaved or transposed empty matrices'}{284. 'File format error: two xxx  blocks in file; only first used.''}{285. 'File format error: valid DATA or TAXA block must precede xxx  block.'}{286. 'File format error: valid CHARACTERS or DATA block must precede xxx block.', }{287. 'File format error: file must contain a DATA block or a TREES block.'}{288. 'This is not a NEXUS file. MacClade can only import types from a NEXUS file.'}{289. 'Calculation only works if a single contiguous block of cells selected!'}{290. ' problems with help file'}{291. 'At least three taxa must remain in tree'}{292. Can't translate because adjacent bases do not have adjacent codon positions, or non-coding position found in the midst of an apparent triplet.}{293. 'Can''t translate as less than 3 coding bases'}{еее294. 'Not enough memory to store picture in clipboard.  Approximately xxx more memory needed.'}{еее295. 'Not enough memory to run MacClade - if running under Multifinder, please increase memory given to MacClade.'}{296. 'MacClade requires System version 4.1 or later.'}{еее297. 'Memory is getting low. Close down some windows.....!'}{еее298. 'Memory is getting dangerously low. Quit before it''s too late!'}{299. File format error: No Trees found in TREES block}{300. File format error: No Trees found in tree file}{301. File format error: file must contain an XREAD or TREAD command.}{302. File format error: format xxx of USERTYPE unknown.'}{303. xxx turned off because all characters excluded.}{304. 'All characters are excluded; can''t show chart.'}{305. Correlation test cannot be done if clade has polytomies.}{306. Overflow in calculation of minimum or maximum conceivable lengths.}{307. Overflow in calculation of CI/RI/RC's.}{308. Overflow in treelength calculation during branch swapping.}{309. Overflow in branch length calculation.}{310. Overflow in treelength calculation of chart.}{311. Overflow in treelength calculation during printing.}{312. DoubleCheckReconstruct error: upPass}{313. DoubleCheckReconstruct error: TriplePass}{314. 'Reconstruction of continuous character appears faulty}{315. 'Only minima of observed states used in continuous character reconstruction with squared-change parsimony'}{316. Cannot show all possible changes or minimum-average-maximum if polytomies or ancestors fixed}{317. Only unambiguous changes can be shown because chart is of traced character and ACCTRAN/DELTRAN are active}{318. Branches cannot be weighted when almost all possible (approximate maximum) option is in use}{319. Type changed to default in some stored type sets.  This cannot be cancelled.}{320. Can only show unambiguous changes because current tree has polytomies or observed taxa fixed as ancestors.}{321. Error: Empty set in reconstructed character (not traced).}{322. Error: Illegal value found in set in reconstructed character (not traced).}{323. State fixed at a branch in character tracing is too high for current character type.  Fixing of all states will be turned off.}{324.  Default Tree used.}{325.  Overflow in calculations for user-defined type character.  Results will be unreliable.}{326.  No amino acids were produced in the translation!}{327.  All characters were removed!}{328.  Illegal character or taxon name encountered.}{329.  Invalid character number or name encountered.}{330. Only part of treefile read in; it will be opened as Untitled.}{331. There was a problem saving the settings.}{332.  Error: inconsistency in tree regarding observed taxon fixed as ancestor}{333.  Equivocal cycling turned off.}{334.  State fixed at ancestor of deleted branch was unfixed.}{335.  No changes are shown on branches participating in soft polytomies because they were not calculated.}{336. Number of steps counted does not match number of steps rechecked.  There may be no error, as this was detected in stratigraphic character whose rechecking is not accurate.}{337. Cannot use almost all possible changes (approximate maximum) option if branch lengths are weighted.}{338. Cannot show all possible changes or minimum-average-maximum if ACCTRAN/DELTRAN in use.}{*NOT CALLED 339. ACCTRAN/DELTRAN are not allowed when equivocal cycling is needed.}{*NOT CALLED 340. ACCTRAN/DELTRAN are not allowed when trace all changes (all possible or min.-avg.-max.) is in use.}{341.  Cannot use selected state because it is not allowed by current type of traced character.}{342. Requested trees not present in treefile.}{343. xxx block not allowed after a DATA or CHARACTERS block.}{344. Error reading in PICT file.}{345. Stratigraphic and user-defined types can not be set as program defaults.}{еее346. Not enough memory to make chart.  Approximately xxx more memory needed.}{еее347. Not enough memory to add taxa or characters. Approximately xxx more memory needed .}{348. Beware! One or two gaps in isolation were found - these were treated as missing data in the translation!}{349. Chart closed as one of the two treefiles contained no trees suitable for the calculations.}{350. Tree in tree window removed because too many of its taxa were deleted}{351. Steps in character more than calculated maximum conceivable.  May be due to fixing observed taxon as ancestor.}{Ensemble RI or RC may be misleading or negative.}{352. Improper punctuation in some trees (e.g., missing comma); trees may be incompletely read.}{353. Cannot fix state at branch that is observed taxon in ancestral position.}{354.  Chart is based upon last saved version of treefile, not the current version of the treefile in memory.}{355. Some elements in type matrix were reduced to zero when others were scaled down to fit within limits.}{356. More than two stratigraphic data types encountered; only the last encountered will be used.}{357. Some state names contain the AND separator used in the data editor!}{358. Some state names contain the OR separator used in the data editor!}{359. Inconsistency found in tree structure concerning observed taxon fixed as ancestor!}{360. Note that MacClade does not perform reverse translation; protein states were converted directly into nucleotide states.}{361. Calculation of changes not done for stratigraphic characters.}{362.  Dollo type not allowed with nucleotide data; characters will be reassigned to default type.}{363. Chart turned off because changes cannot be calculated for stratigraphic character.}{364. This is a character state tree and as such cannot be edited as a matrix.}{365.  Calculation of number of changes aborted.}{366.  Pre-defined types cannot be edited.}{367.  Changes cannot be calculated for stratigraphic character.}{368.  Changes not calculated for some characters because they are of stratigraphic type.}{369.  Equivocal cycling not allowed for stratigraphic characters.}{370.  Equivocal cycling was not carried out for stratigraphic characters.  Calculations may be incomplete. Please exclude these characters first}{371.  Illegal taxon, character, or CHARSET name encountered, consisting only of numbers. Please edit these to include at least one non-numerical character.}{372.  To see the list of steps required for each state fixed at the node selected, you need to hold down the mouse button until the list appears.}{373.  Fixing of states not allowed with stratigraphic characters.}{еее374.  Not enough memory to calculate averages when done by classes of change.}{еее375. Not enough memory to continue chart calculations; a partial chart will be presented.}{еее376. Not enough memory to complete operation.}{еее377. Memory error.}{еее378. Memory is getting low - beware!}{еее379.  Tree window closed because MacClade could not build tree due to serious lack of memory - Beware!}{еее380.  Chart closed because MacClade could not build some trees due to lack of memory! }{еее381.  Random trees not fully made because of lack of memory!}{еее382.  Trees in file not fully converted because of lack of memory!}{еее383.  Severe memory shortage; tree window had to be closed.}{384.  Problem encountered in algorithms; calculations and character type incompatible.  May be due to violations of prohibitions.}{385.  Cannot reroot character state tree if some states are not connected to current root.}{386. xxx character(s) excluded.}{387. 'MacClade does not support 'xxx' in DIMENSIONS. MacClade will close file.' }{388. Stratigraphic type cannot have elements with values of zero.}{389.  Error in restoring Evolve Segments from stored tree}{390.  Collapsing branch will lose its information on Evolve Segments.  Information will not be restored even with Undo Collapse.}{391.  Cannot set Evolve Segments if observed taxon is fixed as ancestor.}{392.  Illegal width value!}{393.  Cannot make trees wider than tall.}{394.  Taxon names in translation table of tree file do not match those in data file; trees cannot be read in.}{395.  Taxa fixed as ancestors will be saved as terminal taxa in exported tree file.}{396.  Polytomies arbitrarily resolved in trees written in PHYLIP tree file.}{397.  Dollo not allowed as default type for nucleotide data; default type will be set to unordered.}{398.  Some taxa or characters not added as total number exceeds maximum allowed.}{399.  End of file encountered before expected.}{еее400.  Not enough memory available to display or save pictures attached to cells.}{401.  Clipboard is too large for MacClade to import.}{402.  Error: Reconstruction disagrees with MOS.}{403.  Missing, gap, and matching symbols set to their defaults, as one of them conflicts with a state symbol.}{404.  You cannot change this value if branches are drawn proportional to number of changes.}{405.  Felsenstein's contrast calculations not allowed if tree contains polytomies. ввв}{406.  Polytomies not allowed when Felsenstein's contrast calculations in effect. ввв}{407.  Branches cannot have zero segments when doing weighted squared-change parsimony; all zero-segment branches will be treated as having one segment.  ввв}{408.  Less taxa or characters in matrix than specified in the DIMENSIONS command}{409.  Conflict between Display State Names and Interpret State Names as names of some states are the same as the symbol or number of a state!  MacClade will remove conflict. }{410.  MacClade only accepts GENETICCODE commands with NUCORDER=TCAG, CODEORDER=231, and using SYMBOLS}{411.  Polytomies and observed taxa fixed as ancestors not allowed when reconstruction probabilities calculated.}{412.  MacClade Font File not found - please place MacClade Font File in same folder as MacClade or in Font Folder in System Folder.}{413.  Character set 'UNINFORM' not processed by MacClade, and will be ignored}{еее414.  Not enough memory to complete operation.  At least XXX more memory needed.}{415.  Taxa must be selected first.}{416.  File is not of the correct format.  You cannot import NEXUS files in this manner.  You can import the sequences in these files by opening the file in MacClade and saving it as an NBRF formatted file, then using the Import Sequences submenu.}{417.  Quickest Descent search options used as it is necessary with the NNI/SPR search procedure.}{418. File incorrectly formatted.}{419. There was a problem in saving the printer settings into the file.}{420. Output file name truncated as it was too long.}{421. MacClade does not currently accept pictures or notes attached to states.}{452. MacClade does not accept negative continuous values; they will be reset to missing data.}{453. Taxon or character number out of range}{457. Warning: An EQUATE symbol is identical to an existing character state symbol; this is not allowed.  The data may be interpreted incorrectly.}{* 512. ( maximum number of errors = highesterror) }{-----------------------------------------------------------------------------}	function NumberInERWC (ernum: integer): integer;{returns whether or not current error is already in list of errors with characters; 0 if no, position in array if yes}		var			ir, erfound: integer;	begin		erfound := 0;		for ir := 1 to maxerrorswithchars do			if errorswithchars[ir, 0] = ernum then				begin					erfound := ir;					leave;				end;		numberinERWC := erfound;	end;{-----------------------------------------------------------------------------}	procedure AddErrorToSEt (errnum: integer; errset: ptr);	begin		BitSet(errset, errnum);	end;{-----------------------------------------------------------------------------}	function ErrorInSet (errnum: integer; errset: ptr): boolean;	begin		ErrorInSet := Bittst(errset, errnum);	end;{-----------------------------------------------------------------------------}	function NumErrorWords: integer;{returns the number of 2-byte words occupied by error sets}	begin		NumErrorWords := (highesterror div 8 + 2) div 2+2;	end;{-----------------------------------------------------------------------------}	function ErrorSetEmpty (errset: ptr): boolean;		var			ir, numwords: integer;			iptt: ip;			isempty: boolean;	begin		numwords := NumErrorWords;		isempty := true;		iptt := ip(errset);		for ir := 1 to numwords do			begin				if iptt^ <> 0 then					begin						isempty := false;						leave;					end;				iptt := ip(ord4(iptt) + 2);			end;		ErrorSetEmpty := isempty;	end;{-----------------------------------------------------------------------------}	procedure ZeroErrorSet (errset: ptr);		var			ir, numwords: integer;			iptt: ip;	begin		numwords := NumErrorWords;		iptt := ip(errset);		for ir := 1 to numwords do			begin				iptt^ := 0;				iptt := ip(ord4(iptt) + 2);			end;	end;{-----------------------------------------------------------------------------}	procedure AddMemoryErrors;	begin	end;{-----------------------------------------------------------------------------}	procedure SubtractErrorSets (errorig, errminus: ptr);		var			ir, numwords: integer;			iptt, ipts: SetPointer15;	begin		numwords := NumErrorWords;		iptt := SetPointer15(errorig);		ipts := SetPointer15(errminus);		for ir := 1 to numwords do			begin				iptt^ := iptt^ - ipts^;				iptt := SetPointer15(ord4(iptt) + 2);				ipts := SetPointer15(ord4(ipts) + 2);			end;	end;{-----------------------------------------------------------------------------}	function ErrorString (errnum: integer): str255;		var			ds: str255;			sH: StringHandle;	begin		{if ErrorInSet(errnum, memoryErrors) then			begin}				sH := GetString(errnum);				if sH <> nil then					ds := sH^^				else					ds := '';		{	end		else			GetIndString(ds, 259, errnum);}		ErrorString := ds;	end;{-----------------------------------------------------------------------------}	procedure NewError (ierrnum, ierrchar: integer);{call this to post an error of number ierrnum for character number ierrchar}		var			inERWC, ir: integer;	begin		if not ErrorInSet(ierrnum, errorsturnedoff) then			begin				goerror := true;				AddErrortoSet(ierrnum, Errorsposted);				{if not isforeground & not notificationPosted then					begin						PostBackGroundNotification;					end;}				if ierrchar > 0 then					begin						inERWC := NumberInERWC(ierrnum);						if inERWC > 0 then  {error already is posted as having character}							begin								for ir := 1 to maxcharsoferrors do									begin										if errorswithchars[inERWC, ir] = ierrchar then											begin												leave;											end										else if errorswithchars[inERWC, ir] <= 0 then											begin												errorswithchars[inERWC, ir] := ierrchar;												leave;											end;									end;							end						else  {error is new for having character}							begin								inERWC := NumberInERWC(-1);								if inERWC > 0 then									begin										errorswithchars[inERWC, 0] := ierrnum;										errorswithchars[inERWC, 1] := ierrchar;									end;							end;					end;			end;	end;{-----------------------------------------------------------------------------}	procedure RemoveError (ierrnum: integer);		var			RemoveSet: Ptr;	begin		RemoveSet := newPtr(NumErrorWords * 2);		ZeroErrorSet(removeSet);		AddErrorToSet(ierrnum, removeSet);{v3.02: removed this: if ErrorInSet(ierrnum, memoryErrors) then SubtractErrorSets(memoryErrors, removeSet) else}		SubtractErrorSets(Errorsposted, removeSet);		ZapPointer(removeSet);	end;{-----------------------------------------------------------------------------}	function ErrorPosted (ierrnum: integer): boolean;{returns true iff error number ierrnum has already been posted}	begin		ErrorPosted := ErrorInSet(ierrnum, Errorsposted);	end;{-----------------------------------------------------------------------------}	procedure DealwithUpdatesSmall (Event: EventRecord);		var			UpDateWindow, TempP: WindowPtr;	begin		UpDateWindow := myGetWindowPtrFromEventMessage(Event);		if updateWindow = nil then			Exit(DealwithUpdatesSmall);		genericGetPort(TempP);		genericSetPort(UpDateWindow);		BeginUpDate(UpDateWindow);		EndUpDate(UpDateWindow);		genericSetPort(TempP);	end;{----------------------------------------------------------------------------}	function ErrorDLOGFilter (theDialog: DialogPtr; var Event: EventRecord; var localItemHit: INTEGER): BOOLEAN;	var		MouseLoc: Point;			windowLoc: integer;			dragArea: rect;			itemtype: integer;			H: handle;			box: rect;			codeWord: longint;			cancel: boolean;			updateWindow: WindowPtr;	begin		ErrorDLOGFilter := FALSE;		case Event.what of			updateEvt:				begin					UpDateWindow := myGetWindowPtrFromEventMessage(Event);					if (updateWindow<>myGetWindowPtrForDialog(theDialog)) then						DealwithUpdatesSmall(Event);				end;			keyDown: 				if HitReturn(Event) then					begin						localItemHit := PressButton(theDialog, 1);						ErrorDLOGFilter := true;					end;			osEvent: 				begin					//DoSuspendResume(theEvent);					ErrorDLOGFilter := true;				end;			mousedown:{if isforeground then}				begin					MouseLoc := Event.Where;					windowLoc := FindWindow(MouseLoc, WhichWindow);					ErrorDLOGFilter := true;					case windowLoc of						inMenuBar: 							begin 								codeWord := MenuSelect(mouseloc);							end;{$IFC NOT CARBON}						inSysWindow: 							SystemClick(Event, WhichWindow);{$ENDC}												inContent: 							if whichwindow = myGetWindowPtrForDialog(thedialog) then								begin									wh := Event.where;									GlobalToLocal(wh);									GetDialogItem(theDialog, 1, itemtype, H, box);									if PtInRect(wh, box) & (MyTrackControl(ControlHandle(H),wh,nil)<>0) then										localItemHit := 1									else										begin											GetDialogItem(theDialog, 2, itemtype, H, box);											if PtInRect(wh, box) & (MyTrackControl(ControlHandle(H),wh,nil)<>0) then												localItemHit := 2											else												begin													GetDialogItem(theDialog, 5, itemtype, H, box);													if PtInRect(wh, box) & (MyTrackControl(ControlHandle(H),wh,nil)<>0) then														localItemHit := 5;												end;										end;								end;						inDrag: 							if whichwindow =  myGetWindowPtrForDialog(thedialog) then								if StillDown then									begin										DragArea := ScreenRectangle;										InsetREct(DragArea, 4, 4);										DragArea.top := DragArea.top + 12;										myDragWindow(whichwindow, mouseLoc, DragArea)									end;						otherwise							;					end;				end;			otherwise;			end;	end;{-----------------------------------------------------------------------------}{$IFC TRUE}	function CError (warn: str255): boolean;		var			theDialog: DialogPtr;			tempP: WindowPtr;			H: Handle;			itemtype: integer;			box: rect;			localItemHit: integer;			DLOGFilterUPP: UniversalProcPtr;	begin		StartDLOG(705, theDialog, tempP);		GetDialogItem(theDialog, 3, itemtype, H, box);		SetDialogItemText(H, warn);		if not readon then HideButton(theDialog,5);		myShowDialog(theDialog);		FrameButton(theDialog, 1);		Beep;		DLOGFilterUPP := MyNewModalFilterUPP(@ErrorDLOGFilter);  		repeat{$IFC CARBON}			myModalDialog(DLOGFilterUPP, localItemHit);{$ELSEC}			myModalDialog(nil, localItemHit);{$ENDC}		until localItemHit in [1, 2, 5];		MyDisposeModalFilterUPP(DLOGFilterUPP);		EndDLOG(theDialog, tempP);		InvalidateAllWindows;		if localitemHit = 5 then    {this button is only there if readon}			begin				errorFlag := true;				if readon then 					begin						badfile := true;						userCanceledRead := true;					end;			end;		CError := (localItemHit = 2);		if nodes & ((drawR <> ScreenR) | (DrawR <> R)) then			drawR := screenR;		if (localItemHit = 2) & NoNewErrorStopped then  {only give this message once per run of program}			begin				InstantInfo('You can restore reporting of this message by holding down the Option key and choosing Restore Messages under the File menu.');				NoNewErrorStopped := false;			end;	end;{$ELSEC}{-----------------------------------------------------------------------------}{-----------------------------------------------------------------------------}	procedure ProcessErrorEvent (theEvent: EventRecord; theDialog: DialogPtr; var userAction: integer);		var			whichWindow: WindowPtr;			MouseLoc: Point;			windowLoc: integer;			codeWord: longint;			dragArea: rect;			itemtype: integer;			H: handle;			box: rect;	begin		case theEvent.what of			keydown: 				if KeyBoardCancel(theEvent) then					begin						userAction := 1;					end;			updateEvt: 				{DealWthUpdates(theEvent); }				begin end;  {this needs to be fixed!!!}						osEvent: 				begin					DoSuspendResume(theEvent);				end;			mousedown:{if isforeground then}				begin					MouseLoc := theEvent.Where;					windowLoc := FindWindow(MouseLoc, WhichWindow);					case windowLoc of						inMenuBar: 							begin 								codeWord := MenuSelect(mouseloc);							end;{$IFC NOT CARBON}						inSysWindow: 							SystemClick(theEvent, WhichWindow);{$ENDC}												inContent: 							if whichwindow = thedialog then								begin									GetDialogItem(theDialog, 2, itemtype, H, box);									wh := theEvent.where;									GlobalToLocal(wh);									cancel := PtInRect(wh, box);									if cancel then										InvertRoundRect(box, 16, 16);									if not Button then										InvertRoundRect(box, 16, 16);								end;						inDrag: 							if whichwindow = thedialog then								if StillDown then									begin										DragArea := ScreenRectangle;										InsetREct(DragArea, 4, 4);										DragArea.top := DragArea.top + 12;										DragWindow(whichwindow, mouseLoc, DragArea)									end;						otherwise							;					end;				end;			otherwise				;		end;	end;{-----------------------------------------------------------------------------}	function CError (warn: str255): boolean;		var			theDialog: DialogPtr;			tempP: WindowPtr;			H: Handle;			itemtype: integer;			tev: EventRecord;			box: rect;			localItemHit: integer; 			db: boolean;	begin		StartDLOG(705, theDialog, tempP);		GetDialogItem(theDialog, 3, itemtype, H, box);		SetDialogItemText(H, warn);		myShowDialog(theDialog);		FrameButton(theDialog, 1);		Beep;		repeat		 	//CallWaitNextEventForDrawing;		 			db := GetEvent(everyevent-updatemask, tev);					GetDialogItem(theDialog, 2, itemtype, H, box);					GetMouse(wh);					cancel := PtInRect(wh, box);					if cancel then						InvertRoundRect(box, 8, 8);		until button;		localItemHit := 1;		isforeGround := true;		EndDLOG(theDialog, tempP);		CError := (localItemHit = 2);		if nodes & ((drawR <> ScreenR) | (DrawR <> R)) then			drawR := screenR;		if (localItemHit = 2) & NoNewErrorStopped then  {only give this message once per run of program}			begin				InstantInfo('You can restore reporting of this message by holding down the Option key and choosing Restore Messages under the File menu.');				NoNewErrorStopped := false;			end;	end;{$ENDC}{-----------------------------------------------------------------------------}	procedure ShowErrors (note: str255);		var			ds: str255;			sH: StringHandle;			ir, ic, inERWC: integer;	begin		SubtractErrorSets(errorsposted, errorsturnedoff);		if not ErrorSetEmpty(errorsposted) then			begin				for ir := 0 to highesterror do					if not userCanceledRead & ErrorInSet(ir, errorsposted) then						begin							ds := ErrorString(ir);							if ds = '' then								NumToString(ir, ds);							inERWC := NumberInERWC(ir);							if inERWC > 0 then								begin									if errorswithchars[inERWC, 2] > 0 then										ds := concat(ds, ' (Characters ')									else										ds := concat(ds, ' (Character ');									for ic := 1 to maxcharsoferrors do										if errorswithchars[inERWC, ic] > 0 then											ds := concat(ds, stringfromnum(errorswithchars[inERWC, ic]), ' ');									if errorswithchars[inERWC, maxcharsoferrors] > 0 then										ds := concat(ds, 'and possibly other characters as well');									ds := concat(ds, ')');								end;							if note <> '' then								ds := concat(ds, ' ', note);							if cError(ds) then								AddErrorToSet(ir, errorsturnedoff);						end;			end;		for ir := 1 to maxerrorswithchars do			for ic := 0 to maxcharsoferrors do				errorswithchars[ir, ic] := -1;		goerror := false;		ZeroErrorSet(errorsposted);	end;{-----------------------------------------------------------------------------}	procedure InstantError (errnum: integer);{These errors are like showerrors in that they can be turned off, use same dialog box, etc}{are numbered, and at least some of string stored in resource InstantErrors STR#}		var			ds: str255;	begin		if not ErrorInSet(errnum, errorsturnedoff) then			begin				PostBackGroundNotification;				ds := ErrorString(errnum);				if ds = '' then					NumToString(errnum, ds);				if cError(ds) then					AddErrorToSet(errnum, errorsturnedoff);{$IFC CARBON}				if isMacOSX then					InvalidateAllWindows;{$ENDC}				RemoveBackGroundNotification;			end;	end;{-----------------------------------------------------------------------------}	procedure InstantErrorPlus (errnum: integer; note: str255);{These errors are like showerrors in that they can be turned off, use same dialog box, etc}{are numbered, and at least some of string stored in resource InstantErrors STR#}{"Note" string can be passed to add extra string}		var			ds: str255;			insertpoint: integer;	begin		if not ErrorInSet(errnum, errorsturnedoff) then			begin				PostBackGroundNotification;				ds := ErrorString(errnum);				if ds = '' then					ds := concat(StringFromNum(errnum), '. xxx');				insertpoint := pos('xxx', ds);				if insertpoint > 0 then					begin						delete(ds, insertpoint, 3);						insert(note, ds, insertpoint);					end				else					ds := concat(ds, note);				if cError(ds) then					AddErrorToSet(errnum, errorsturnedoff);{$IFC CARBON}				if isMacOSX then					InvalidateAllWindows;{$ENDC}				RemoveBackGroundNotification;			end;	end;{-----------------------------------------------------------------------------}	procedure InstantInfo (warn: str255);		var			theDialog: DialogPtr;			tempP: WindowPtr;			H: Handle;			itemtype: integer;			box: rect;			localItemHit: integer;			DLOGFilterUPP: UniversalProcPtr;	begin		PostBackGroundNotification;{this is a dialog so that we don't need to use ParamText, which can screw up underlying DLOG boxes}		StartDLOG(304, theDialog, tempP);		GetDialogItem(theDialog, 2, itemtype, H, box);		SetDialogItemText(H, warn);		myShowDialog(theDialog);		FrameButton(theDialog, 1);		Beep;		//DLOGFilterUPP := MyNewModalFilterUPP(@ErrorDLOGFilter);  		repeat			ModalDialog(nil, localItemHit);		until localItemHit  =1;		isforeGround := true;		//MyDisposeModalFilterUPP(DLOGFilterUPP);		EndDLOG(theDialog, tempP);		InvalidateAllWindows;		if nodes & ((drawR <> ScreenR) | (DrawR <> R)) then			drawR := screenR;		dontCancelUpdate := true;		RemoveBackGroundNotification;	end;{-----------------------------------------------------------------------------}	function CWarning (warn: str255; button1, button2: str32): boolean;{v4: convert to using resource string}{cancellable warning alert }		var			theDialog: DialogPtr;			tempP: WindowPtr;			H: Handle;			itemtype: integer;			box: rect;			localItemHit: integer;			DLOGFilterUPP: UniversalProcPtr;	begin{this is a dialog so that we can easily manipulate button titles, etc.}		PostBackGroundNotification;		StartDLOG(331, theDialog, tempP);		GetDialogItem(theDialog, 3, itemtype, H, box);		SetDialogItemText(H, warn);		GetDialogItem(theDialog, 1, itemtype, H, box);		SetControlTitle(ControlHandle(H), button1);		GetDialogItem(theDialog, 2, itemtype, H, box);		SetControlTitle(ControlHandle(H), button2);		myShowDialog(theDialog);		FrameButton(theDialog, 1);		Beep;		//DLOGFilterUPP := MyNewModalFilterUPP(@ErrorDLOGFilter);  		repeat			ModalDialog(nil, localItemHit);		until localItemHit in [1, 2];		isforeGround := true;		//MyDisposeModalFilterUPP(DLOGFilterUPP);		EndDLOG(theDialog, tempP);{$IFC CARBON}		if isMacOSX then			InvalidateAllWindows;{$ENDC}		RemoveBackGroundNotification;		if nodes & ((drawR <> ScreenR) | (DrawR <> R)) then			drawR := screenR;		dontCancelUpdate := true;		Cwarning := (localItemHit = 1);	end;{----------------------------------------------------------------------------}	procedure NewsFlash (newsID: integer);		var			theDialog: DialogPtr;			tempP: WindowPtr;			H: Handle;			itemtype: integer;			box: rect;			ds: str255;	begin{this is a dialog so that we don't need to use ParamText, which can screw up underlying DLOG boxes}		StartDLOG(130, theDialog, tempP);		GetDialogItem(theDialog, 1, itemtype, H, box);		GetIndString(ds, 130, newsID);		SetDialogItemText(H, ds);		myShowDialog(theDialog);		DrawDialog(theDialog);{$IFC FALSE}		Note(700, 250, 10);		Note(500, 250, 6); {$ENDC}		Delay(25, ticks);		Beep;		EndDLOG(theDialog, tempP);{$IFC CARBON}		if isMacOSX then			InvalidateAllWindows;{$ENDC}		if nodes & ((drawR <> ScreenR) | (DrawR <> R)) then			drawR := screenR;		dontCancelUpdate := true;	end;{-----------------------------------------------------------------------------}	procedure SysErrorReport (resultcode: integer);{reports operating system errors, including i/o errors }		var			ignore: integer;			errorString: str255;	begin{    currentIOPosition := 85 is current maximum}		case resultcode of			DskFulErr: 				errorString := 'Disk full.';   {can't be more specific as can get this error whenever write files,}												{not just with Save File...}			flckdErr: 				errorString := 'File locked.';			wrPermErr: 				errorString := 'Your access privileges do not allow you to alter this file.';			vlckdErr: 				errorString := 'Disk or Folder locked.';			wPrErr: 				errorString := 'Disk or Folder locked.';			bdNamErr: 				errorString := 'Invalid file name.';			tmfoErr: 				errorString := 'Too many files open.';			opWrErr: 				errorString := 'File already busy.';			memFullErr: 				errorString := 'Not enough memory to complete operation.';			dupFNErr: 				errorString := 'File already exists.';			FNFErr: 				errorString := 'File could not be found.';			permErr:				errorString := 'Your access privileges do not allow you to alter this file; it may be busy in another application.';			fBsyErr:				errorString := 'File is busy.';			afpAccessDenied :				errorString := 'You do not have sufficient access privileges.';			paramErr:				errorString := 'Parameters passed to an input/output routine are bad.';			otherwise				begin					NumtoString(resultcode, errorString);					errorstring := Concat('OS Error number ', errorstring, '.');				end;		end;		errorstring := Concat(errorstring, chr(13), '(Code Location ', StringFromNum(currentIOPosition), ')');		ParamText(errorString, '', '', '');		SetCursorToArrow;		ignore := DoAlert(302, StopA);{$IFC CARBON}		if isMacOSX then			InvalidateAllWindows;{$ENDC}		quit := false;		ErrorFlag := true;	end;{-----------------------------------------------------------------------------}	function IOSuccessful (resultcode: integer): boolean;{checks for I/0 errors }	begin		if resultcode <> NoErr then			SysErrorReport(resultcode);		IOSuccessful := (resultcode = NoErr);	end;{-----------------------------------------------------------------------------}	function OSSuccessful (OS: OSErr): boolean;{checks for OSErrs}	begin		if OS <> NoErr then			SysErrorReport(OS);		OSSuccessful := OS = NoErr;	end;{----------------------------------------------------------------------------}	function MemoryOK: boolean;	begin		badMemory := MemError <> noErr;		if badmemory then			if MemError = MemFullErr then				NewError(376, 0)			else				NewError(377, 0);		MemoryOK := not badMemory;	end;{-----------------------------------------------------------------------------}	function SetHandleSizeSuccessful(H: univ Handle; Hsize: longint): boolean;	var memFree : longint;	begin		memFree := myFreeMem;		SetHandleSizeSuccessful :=  true;		if (Hsize > memFree) | (H=nil) then 			begin				errorflag := true;				SetHandleSizeSuccessful := false;				SysErrorReport(memFullErr);			end		else			begin				SetHandleSize(H,Hsize);				if not OSSuccessful(MemError)	then					begin						SetHandleSizeSuccessful := false;						errorflag := true;					end;			end;	end;{-----------------------------------------------------------------------------}	function NewHandleSuccessful (H: univ Handle; Hsize: longint): boolean;	begin	end;{-----------------------------------------------------------------------------}	procedure PostBackGroundNotification;		var			myErr: OSErr;			db: boolean;			notificationIcon: Handle;			notificationString: str255;	begin		if not isforeground & not notificationPosted & hasNotificationManager then			begin				notificationString := 'Please bring MacClade to the foreground';				notificationIcon := GetResource('SICN', 128);				with notificationRecord do					begin						qType := ord(nmType);						nmMark := 1;						nmIcon := notificationIcon;						nmSound := Handle(-1);						nmResp := nil; 						nmStr := nil;					end;								notificationPosted :=  OSSuccessFul(NMInstall(@notificationRecord));			end;	end;{-----------------------------------------------------------------------------}	procedure RemoveBackGroundNotification;		var			myErr: OSErr;			db: boolean;	begin		if hasNotificationManager & notificationPosted then			begin				myErr := NMRemove(@notificationRecord);				db := IOSuccessful(myErr);				notificationPosted := false;			end;	end;end.