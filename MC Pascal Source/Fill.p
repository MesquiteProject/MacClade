unit Fill;{ееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, 		GenUtil, BoxUtil, StrUtil, TaxonCHUtil, SymbolsNames, CharUtil, MenuUtil, SpreadUtil, copypaste, EditorUndo;	function CellMatchesStateToFill(it,ic: integer; stateOfCellsToFill: largestSetChars): boolean;	procedure FillRandomWithObsStates(st, et, sc, ec: integer; restrictFill: boolean; stateOfCellsToFill: largestSetChars; fillFraction: integer);	procedure FillRandomWithObsFreq(st, et, sc, ec: integer; restrictFill: boolean; stateOfCellsToFill: largestSetChars; fillFraction: integer);	procedure FillWithRandom (st, et, sc, ec: integer; changeCursor: boolean; setTextEdit: boolean; restrictFill: boolean; stateOfCellsToFill: largestSetChars; fillFraction: integer);	procedure FillSelected (fillchar: char);	procedure FillTaxonNames(itstart,itend: integer; doAlphabet: boolean; namestr: str255; doNumber: boolean; beginNumber: integer; doLeadingZeros: boolean);	procedure FillNamesDLOG;	procedure FillInnerCellDLOG;	function RandomStateDLOG (sayfill: boolean): boolean;	procedure FillSelectedWithRandom;	procedure FillBlockWithRandom (st, et, sc, ec: integer; restrictFill: boolean; stateOfCellsToFill: largestSetChars; fillFraction: integer);	var		highstate: integer;{ееееееееееееееееееееее}implementation {е$S Fill} {-----------------------------------------------------------------------------}	function CellMatchesStateToFill(it,ic: integer; stateOfCellsToFill: largestSetChars): boolean;	var tsts: largestsetchars;	begin		if stateOfCellsToFill = [] then			CellMatchesStateToFill := true		else if stateOfCellsToFill = [ERl] then			begin				tsts := getTaxonStsLargest(it,ic);				CellMatchesStateToFill := not (MSl in tsts);			end		else			CellMatchesStateToFill := (stateOfCellsToFill=getTaxonStsLargest(it,ic)) ;	end;{-----------------------------------------------------------------------------}	procedure FillSelected (fillchar: char);{fills the selected block in the spreadsheet with the char fillchar}		var			charHdl: chHdl;			st, et, sc, ec, it, ic, ist, maxist: integer;			okchar: boolean;			newset, tsts: largestsetchars;	begin		okchar := true;		SetCursor(clockCursor);		CalcSelectedTaxaCharacters(st, et, sc, ec, true);		if fillchar = missing then			for it := st to et do				for ic := sc to ec do					settaxonstsLargestFoot(it, ic, [MSl])		else if fillchar = gap then			for it := st to et do				for ic := sc to ec do					settaxonstsLargestFoot(it, ic, [msl, gal])		else if fillchar = EndNames then			{fill with same state as first taxon}			begin				if (st = 1) and (et > 1) then					st := 2;				for ic := sc to ec do					begin						tsts := gettaxonstsLargest(1, ic);						for it := st to et do							settaxonstsLargestFoot(it, ic, tsts);					end;			end		else			begin				if not ErrorPosted(88) then					for ic := sc to ec do						begin							tsts := SetOfChar(fillchar, true, 1, ic);   {taxon number passed to SetOfChar is irrelevant}							if ErrorPosted(88) then								begin									okchar := false;									leave;								end;							if not MakeLegalSet(tsts, newset, ic) then								cycle;							Maxist := Maxlg(newset);							charHdl := getchHdl(ic);							if charHdl^^.maxst < Maxist then								charHdl^^.maxst := Maxist;							if nucleotides then								if (fillchar='N') | (fillchar='n') | IsAlternativeSymbolChar(fillchar) then									newset := newset + [SSl];							for it := st to et do								settaxonstsLargestOverwriteCase(it, ic, newset);						end				else					begin						Beep;						okchar := false;					end;			end;		CheckRedrawFullCharactersInEditor(st,et,sc,ec,true);		{if UpdateAsSensitiveToFirstTaxonChange(st) then			MatchCharUpdate(sc, ec);}		if okchar then			SetDirtyEditor(true);	end;{-----------------------------------------------------------------------------}	function DataCellIsGap (it, ic: integer): boolean;	begin		DataCellIsGap := gettaxonstsLargest(it, ic) = [MSl, GAl];	end;{-----------------------------------------------------------------------------}	function StringFromNumLeadingZeros(number: longint; stringLen: integer): str255;	var j: integer;		ds: str255;	begin		ds := StringFromNum(number);		for j := length(ds) + 1 to stringLen do			ds := concat('0',ds);		StringFromNumLeadingZeros := ds;	end;{-----------------------------------------------------------------------------}	procedure FillTaxonNames(itstart,itend: integer; doAlphabet: boolean; namestr: str255; doNumber: boolean; beginNumber: integer; doLeadingZeros: boolean);	var it: integer;		ds: str255;		ik, stringLen : integer;	begin		ds := '';		if doLeadingZeros then			stringLen := length(StringFromNum(beginnumber + itend-itstart))		else			stringLen := 0;		for it := itstart to itend do			begin				if doAlphabet then					begin						if it <= 26 then							ds := chr(it+ord('A')-1)						else							begin								ds := concat(chr((it-26) div 100+ord('A')),StringFromNum((it-26) mod 100));							end;						SetTaxonName(it, ds);					end				else if donumber then					begin						ds := concat(namestr, StringFromNumLeadingZeros(beginnumber + it - itstart,stringLen));  {have to store in ds!!!}						SetTaxonName(it, ds);					end				else					SetTaxonName(it, namestr);			end;		infoDirtyNames[taxinfo] := true;		dirtytaxnames := true;		if treefile then			dirtytreefile := true;   {at least translation table is}		EraseRect(editorSelectionRect);		InvalidateWindowRect(editorWindow,editorSelectionRect,false);		datachanged := true;	end;	{-----------------------------------------------------------------------------}{-----------------------------------------------------------------------------}	procedure FillNamesDLOG;{this procedure brings up and processes the dialog box for automatic filling of character or taxon names}		const			numbitem = 4;			nameitem = 3;			spaceitem = 7;		var			theDialog: DialogPtr;			tempP: WindowPtr;			itstart, itend, icstart, icend: integer;			beginnumber: longint;			ik: integer;			dotaxa, donumber, dospace, doleadingZeros: boolean;			ds, namestr: str255;			localItemHit, stringLen: integer;			numDone, lastDone: integer;{...........}		procedure CheckNameFill;		begin			ItemCheckMark(theDialog, 6, donumber);			ItemCheckMark(theDialog, 7, dospace);			ItemCheckMark(theDialog, 8, not dotaxa & autoCharNumberByRef);			ItemCheckMark(theDialog, 9, donumber & doLeadingZeros);			EnableDisableDlogItem(theDialog,9,donumber, false);		end;{...........}	begin		StartDLOG(427, theDialog, tempP);		itstart := TaxonOfCell(editorSelectionTopLeft);		if itstart > 0 then			begin				dotaxa := true;				itend := TaxonOfCell(editorSelectionBotRight);				SetDLOGText(theDialog, nameitem, 'taxon', true);				SetDLOGText(theDialog, numbitem, StringFromNum(itstart), false);				EnableDisableDLOGItem(theDialog, 8, false, false);				Paramtext('taxon names', '', '', '');			end		else			begin				autoCharNumberByRef := false;				dotaxa := false;				icstart := CharOfCell(editorSelectionTopLeft);				icend := CharOfCell(editorSelectionBotRight);				if molecular then					SetDLOGText(theDialog, nameitem, 'site', true)				else					SetDLOGText(theDialog, nameitem, 'char', true);				SetDLOGText(theDialog, numbitem, StringFromNum(icstart), false);				Paramtext('character names', '', '', '');			end;		donumber := true;		dospace := true;		doLeadingZeros := false;		CheckNameFill;		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			case localItemHit of				4: 					if not donumber then						donumber := true;				6: 					donumber := not donumber;				7: 					dospace := not dospace;				8: 					autoCharNumberByRef := not autoCharNumberByRef;				9:  	doLeadingZeros := not doLeadingZeros;				otherwise					;			end;			CheckNameFill;		until localItemHit in [1, 2];		if localItemHit = 1 then			begin				if donumber then					beginnumber := EditTextInt(theDialog, numbitem,true);				namestr := GetEditText(theDialog, nameitem);				StripBlanks(namestr);				if dospace and donumber then					if (namestr <> '') then						namestr := concat(namestr, ' ');			end;		EndDLOG(theDialog, tempP);		if (localItemHit = 1) & CWarning('Filling names cannot be undone. Do you want to proceed?','Proceed','Cancel') then			begin				SetLastChangeInEditor(lastChangeCantUndo);				if dotaxa then					FillTaxonNames(itstart,itend,false, namestr,doNumber,beginNumber, doLeadingZeros)				else					begin						numDone := -1;						lastDone := icStart - 1;						if doLeadingZeros then							stringLen := length(StringFromNum(beginnumber + icend - icstart))						else							stringLen := 0;						for ik := icstart to icend do							if donumber then								begin									if not autoCharNumberByRef then										begin											ds := concat(namestr, StringFromNumLeadingZeros(beginnumber + ik - icstart,stringLen));											SetCharName(ik, ds);										end									else if not DataCellIsGap(autoCharNumberRefSequence, ik) then										begin											ds := concat(namestr, StringFromNumLeadingZeros(beginnumber + numDone + 1,stringLen));											SetCharName(ik, ds);											numDone := numDone + 1;											lastDone := ik;										end									else										begin											if ik - lastDone > 26 then												ds := concat(namestr, StringFromNum(beginnumber + numDone), 'z+')											else												ds := concat(namestr, StringFromNum(beginnumber + numDone), char(ord('a') + ik - lastDone - 1));											SetCharName(ik, ds);										end;								end							else if not autoCharNumberByRef | not DataCellIsGap(autoCharNumberRefSequence, ik) then								SetCharName(ik, namestr);						dirtycharnames := true;						infoDirtyNames[charinfo] := true;						EraseRect(editorSelectionRect);						InvalidateWindowRect(editorWindow,editorSelectionRect,false);						datachanged := true;					end;			end;	end;{-----------------------------------------------------------------------------}	procedure FillInnerCellDLOG;{DLOG to fill inner data cells with non-random values}		var			theDialog: DialogPtr;			tempP: WindowPtr;			st, et, sc, ec: integer;			whichradio: integer;			db: boolean;			ds: str255;			localItemHit: integer;{.........................}		procedure CheckInnerFill;		begin			ItemCheckMark(theDialog, 3, whichradio = 3);			ItemCheckMark(theDialog, 4, whichradio = 4);			ItemCheckMark(theDialog, 5, whichradio = 5);		end;{.........................}	begin		StartDLOG(337, theDialog, tempP);		myShowDialog(theDialog);		CalcSelectedTaxaCharacters(st, et, sc, ec, true);		EnableDisableDLOGItem(theDialog, 4, et > 1, false);  {disable if only first taxon is selected}		if (fillchar = missing) or ((et = 1) and (fillchar = EndNames)) then			begin				whichradio := 3;				fillchar := missing;			end		else if fillchar = EndNames then{note: ASCII 8 (global constant EndNames) is used as a signal that the fillchar is that found in}{first taxon in matrix}			whichradio := 4		else			begin				SetDLOGText(theDialog, 6, fillchar, true);				whichradio := 5;			end;		CheckInnerFill;		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			if localItemHit in [3, 4, 5] then				whichradio := localItemHit			else if localItemHit = 6 then				whichradio := 5;			CheckInnerFill;		until (localItemHit in [1, 2]);		if localItemHit = 1 then			begin				dirtymaxst := true;				datachanged := true;				if whichradio = 3 then					fillchar := missing				else if whichradio = 5 then					begin						ds := GetEditText(theDialog, 6);						if (ds = '') or (ds = ' ') then							fillchar := missing						else							fillchar := ds[1];					end				else if whichradio = 4 then					fillchar := EndNames;			end;		EndDLOG(theDialog, tempP);		if localItemHit = 1 then			begin				if  StoreSelectedCellBlockForUndo(false,false,true) then 						FillSelected(fillchar);			end;	end;{-----------------------------------------------------------------------------}{|||||||||||||||||||||||||||  RANDOM FILL |||||||||||||||||||||||||}	var		distribB: rect;    {the rectangle into which the frequency histogram is to be drawn}		randpullB: rect;   {a tall, thin rectangle enclosing randpullH, on right of state value randommax}		randpullH: integer;   {the horizontal position of the QDBlack vertical line on the right of the }							{histograms, that demarcates the highest valued state considered}							{the norming buttons}		randwidth: integer;   {width in pixels of each bar in the histogram}{-----------------------------------------------------------------------------}	procedure WriteRandomStateAmount (j: integer);{writes probability currently assigned to state j under the bar}		var			box: rect;			adj: integer;	begin		if numbytes = 4 then			begin				TextFont(macCladeSmall);				TextSize(8);				adj := 2;			end		else if numbytes = 2 then			begin				TextFont(kFontIDGeneva);				TextSize(9);				adj := 4;			end;		with distribB do			begin				SetRect(box, left + j * randWidth, bottom + 11, left + (j + 1) * randwidth + 1, bottom + 20);				EraseRect(box);				moveto(left + j * randwidth + adj, bottom + 20);				if RandomStatesH^^[j] = 100 then					DrawString('1.0')				else if RandomStatesH^^[j] < 10 then					DrawString(concat('.0', StringFromNum(RandomStatesH^^[j])))				else					DrawString(concat('.', StringFromNum(RandomStatesH^^[j])));			end;		TextFont(systemfont);		TextSize(0);	end;{-----------------------------------------------------------------------------}	procedure RandomPull;{draws vertical pull bar}	begin		PenSize(2, 2);		moveto(randpullH, distribB.bottom + 9);		LineTo(randpullH, distribB.top);		PenSize(1, 1);	end;{-----------------------------------------------------------------------------}	procedure RandomHorAxis;{draws horizontal axis of histogram}	begin		with distribB do			begin				moveto(left - 1, bottom);				lineto(left + (randommax + 1) * randwidth, bottom);				PenPat(QDGray);				lineto(right, bottom);				PenNormal;			end;	end;  {-----------------------------------------------------------------------------}  	procedure SetForeColorOfBar(theState: integer); 		var			theColor: RGBColor;	begin		if molecular then			theColor := GetStateSetColor(MOS+1,[theState])		else			theColor :=blueRGB;		RGBForeColor(theColor);	end;  {-----------------------------------------------------------------------------}	procedure RandomFillDraw (theDialog: DialogPtr; itemNo: INTEGER);{user proc for drawing random fill dialog box}		var			box: rect;			j: integer;	begin		FrameButton(theDialog, 1);		TextFont(kFontIDGeneva);		TextSize(9);		with distribB do			begin				moveto(left - 1, top);				lineto(left - 1, bottom);				RandomHorAxis;{===== filling the histogram bars =====}				for j := 0 to randommax do					begin						if RandomStatesH^^[j] = 0 then							SetRect(box, left + j * randWidth, bottom - 1, left + (j + 1) * randwidth, bottom)						else							SetRect(box, left + j * randWidth, bottom - RandomStatesH^^[j], left + (j + 1) * randwidth, bottom);						SetForeColorOfBar(j);						FillRect(box, QDBlack);						ForeColor(blackcolor);						Framerect(box);					end;{==== drawing vertical axis ticks and labels ====}				for j := 0 to 10 do					begin						moveto(left, bottom - j * 10);						Line(-2, 0);						Move(-20, 4);						if j <> 10 then							begin								DrawString('0.');								DrawString(StringFromNum(j));							end						else							DrawString('1.0');					end;{==== drawing horizontal axis ticks and labels ====}				ClipRect(WindowPortRect(myGetWindowPtrForDialog(theDialog)));				for j := 0 to highstate do					begin						moveto(left + j * randwidth, bottom);						line(0, 2);						move(7, 8);						DrawString(CharOfNum(j));						WriteRandomStateAmount(j);						TextFont(kFontIDGeneva);						TextSize(9);					end;				RandomPull;			end;		TextFont(systemfont);		TextSize(0);	end;{----------------------------------------------------------------------------}	function Normed: boolean;{checks to see if probability values add up to near enough 1; }{i.e. RandomStatesH values add to 100}		var			j, tot, numnonZero: integer;	begin		tot := 0;		numNonZero := 0;		for j := 0 to RandomMax do			begin				tot := tot + RandomStatesH^^[j];				if RandomStatesH^^[j] <> 0 then					numNonZero := numNonZero + 1;			end;		Normed := abs(tot - 100) < numNonZero;	end;{----------------------------------------------------------------------------}	function RandomFillFilter (theDialog: DialogPtr; var Event: EventRecord; var localItemHit: INTEGER): BOOLEAN;		const			sens = 4;		var			wh, oldwh, rawwh: point;			colnum, j, oldrandommax: integer;			box, oldbox: rect;	begin		wh := Event.where;		GlobalToLocal(wh);{====== cursors ========}		if PtInRect(wh, randpullB) then			SetCursH(handcurs)		else if PtInRect(wh, distribB) then			begin				colnum := (wh.h - distribB.left) div randwidth;				if (colnum <= RandomMax) & (abs(wh.v - (distribB.bottom - RandomStatesH^^[colnum])) < sens) then					SetCursor(clasper)				else					SetCursorToArrow;			end		else			SetCursorToArrow;		RandomFillFilter := FALSE;{====== keydown ========}		if (Event.what = keyDown) then			if HitReturn(Event) then				begin					localItemHit := PressButton(theDialog, 1);					RandomFillFilter := true;				end;{====== mousedown ========}		if (Event.what = mouseDown) then			begin				box := distribB;				InsetRect(box, -sens, -sens);{====== pulling the vertical line ========}				if PtInRect(wh, randpullB) then					begin						oldrandommax := randommax;						PenMode(patxor);						repeat							wh.h := IntegerMax(wh.h, distribB.left + randwidth);							wh.h := IntegerMin(wh.h, distribB.right);							oldwh := wh;							GetMouse(wh);							if not EqualPt(oldwh, wh) and (wh.h < distribB.right) and (wh.h > distribB.left + randwidth) then								with distribB do									begin										RandomPull;										randpullH := wh.h;										RandomPull;									end;							CallWaitNextEventForDrawing;						until not button;						with distribB do							begin								RandomMax := (wh.h - left) div randwidth - 1;								if randommax > highstate then									randommax := highstate								else if randommax < 1 then									randommax := 1;								RandomPull;								randpullH := left + (RandomMax + 1) * randwidth;								SetRect(randpullB, randpullH - 2, top, randpullH + 2, bottom + 9);								RandomPull;							end;						if oldrandommax <> randommax then							begin								EraseRect(distribB);								InvalidateWindowRect(myGetWindowPtrForDialog(theDialog),distribB,false);							end;						PenMode(patcopy);						RandomHorAxis;						for j := randomMax + 1 to highstate do							begin								RandomStatesH^^[j] := 0;								WriteRandomStateAmount(j);							end;					end{====== moving the bars up and down ========}				else if PtInRect(wh, distribB) then					begin						colnum := (wh.h - distribB.left) div randwidth;						with distribB do							SetRect(box, left + colnum * randWidth, bottom - RandomStatesH^^[colnum], left + (colnum + 1) * randwidth, bottom);						oldbox := box;						if (colnum <= RandomMax) and (abs(wh.v - (distribB.bottom - RandomStatesH^^[colnum])) < sens) then							begin								if RandomStatesH^^[colnum] = 0 then									wh.v := (distribB.bottom - RandomStatesH^^[colnum] - 1)								else									wh.v := (distribB.bottom - RandomStatesH^^[colnum]);								repeat									oldwh := wh;									GetMouse(wh);									rawwh := wh;									if not EqualPt(oldwh, rawwh) then										with distribB do											begin												wh.v := IntegerMin(wh.v, distribB.bottom - 1);												wh.v := IntegerMax(wh.v, distribB.top);												SetRect(box, left + colnum * randWidth, wh.v, left + (colnum + 1) * randwidth, bottom);												SetRect(oldbox, left + colnum * randWidth, oldwh.v, left + (colnum + 1) * randwidth, bottom);												if wh.v > oldwh.v then													begin														oldbox.bottom := wh.v + 1;														EraseRect(oldbox);														FrameRect(box);													end												else if wh.v < oldwh.v then													begin														oldbox.bottom := oldwh.v + 1;														oldbox.top := wh.v;														EraseRect(oldbox);														SetForeColorOfBar(colnum);														FillRect(oldbox, QDBlack);														ForeColor(blackcolor);														FrameRect(box);													end;												if rawwh.v > wh.v then													RandomStatesH^^[colnum] := 0												else													RandomStatesH^^[colnum] := distribB.bottom - wh.v;												WriteRandomStateAmount(colnum);											end;										CallWaitNextEventForDrawing;								until not button;								wh.v := IntegerMax(wh.v, distribB.top);								if wh.v >= distribB.bottom - 1 then									begin										wh.v := distribB.bottom - 1;										RandomStatesH^^[colnum] := 0;									end								else									RandomStatesH^^[colnum] := distribB.bottom - wh.v;							end;						RandomFillFilter := true;						localItemHit := notinDialog;					end;			end;	end;{-----------------------------------------------------------------------------}	procedure InvalWholeRandom(theDialog: DialogPtr);{invalidates the entire histogram area}	begin		distribB.bottom := distribB.bottom + 20;		EraseRect(distribB);		InvalidateWindowRect(myGetWindowPtrForDialog(theDialog),distribB,false);		distribB.bottom := distribB.bottom - 20;	end;{-----------------------------------------------------------------------------}	procedure FillWithRandom (st, et, sc, ec: integer; changeCursor: boolean; setTextEdit: boolean; restrictFill: boolean; stateOfCellsToFill: largestSetChars; fillFraction: integer);{fillst selected cells with random data}		type			boundarytype = array[0..absmaxstate] of integer;		var			charHdl: chHdl;			it, ic, tot, randfill, j: integer;			boundaries: boundarytype;	begin		if changeCursor then			SetCursor(clockCursor);		tot := 0;		for j := 0 to RandomMax do			tot := tot + RandomStatesH^^[j];		boundaries[0] := RandomStatesH^^[0];		for j := 1 to highstate do			boundaries[j] := boundaries[j - 1] + RandomStatesH^^[j];		for ic := sc to ec do			for it := st to et do				if CellMatchesStateToFill(it,ic,stateOfCellsToFill) then					if (fillFraction=defaultFillFraction)|(RandomBetween(1, defaultFillFraction)<=fillFraction) then						begin							randfill := RandomBetween(1, tot);							for j := 0 to RandomMax do								if randfill <= boundaries[j] then									begin										charHdl := getchHdl(ic);										if j in LegalSetChars(ic, true) then											begin												if charHdl^^.maxst < j then													charHdl^^.maxst := j;												settaxonstsLargestFoot(it, ic, [j]);											end										else											NewError(125, ic);										leave;									end;						end;		if setTextEdit then			if (st = et) and (sc = ec) then				FillsTE(editorCellTE, CellString);		CheckRedrawFullCharactersInEditor(st,et,sc,ec,true);		{if UpdateAsSensitiveToFirstTaxonChange(st) then			MatchCharUpdate(sc, ec);}		if changeCursor then			SetCursorToArrow;		SetDirtyEditor(true);	end;{-----------------------------------------------------------------------------}	procedure FillRandomWithObsStates(st, et, sc, ec: integer;restrictFill: boolean; stateOfCellsToFill: largestSetChars; fillFraction: integer);{this procedure examines all taxa in the currently selected characters, determines the }{states present in those taxa for each, and fills the selected block for each character with}{those states, in equal probabilities}		var			 ic, j: integer;			tsts: LargestSetChars;			numstates: longint;	begin		if dirtymaxst then			ReCalcMaxstAndStates(1,numchars);		RandomMax := maxstate;		highstate := maxstate;		for ic := sc to ec do			begin				tsts := CharStatesLargest(ic);				numstates := cardLg(tsts);				for j := 0 to maxstate do					if j in tsts then						RandomStatesH^^[j] := 100 div numstates    {not very accurate}					else						RandomStatesH^^[j] := 0;				FillWithRandom(st, et, ic, ic, false, (sc = ec) & SingleCell, restrictFill,stateOfCellsToFill,fillFraction);			end;	end;{-----------------------------------------------------------------------------}	procedure FillRandomWithObsFreq(st, et, sc, ec: integer; restrictFill: boolean; stateOfCellsToFill: largestSetChars; fillFraction: integer);{this fills each character with the observed states, with probabilities equal to}{the observed frequency of each state in a character}		type			stateFreqArray = array[0..absmaxstate] of double;		var			 ic, j, it: integer;			numRecorded: longint;			tsts: LargestSetChars;			numstates: integer;			stateFreq: stateFreqArray;	begin		if dirtymaxst then			ReCalcMaxstAndStates(1,numchars);		RandomMax := maxstate;		highstate := maxstate;		for ic := sc to ec do			begin				for j := 0 to absmaxstate do					stateFreq[j] := 0.0;				numRecorded := 0;				for it := 1 to numtaxa do					begin						tsts := gettaxonstsLargest(it, ic);						if (MSl in tsts) | (UCl in tsts) then							cycle;						numstates := cardLg(tsts);						for j := 0 to maxstate do							if j in tsts then								stateFreq[j] := stateFreq[j] + 1.0 / numstates;   {for Polymorphic cells, there is a down-weighting of}										{each observed state.  E.g.  if A&G, then A counted as a 1/2 occurence; same for G}						numRecorded := numRecorded + 1;					end;				tsts := CharStatesLargest(ic);				for j := 0 to maxstate do					begin						if j in tsts then							RandomStatesH^^[j] := RoundValue(100 * stateFreq[j] / numRecorded)						else							RandomStatesH^^[j] := 0;					end;				FillWithRandom(st, et, ic, ic, false, (sc = ec) & SingleCell, restrictFill,stateOfCellsToFill,fillFraction);			end;	end;{-----------------------------------------------------------------------------}	procedure FillRandomWithObserved;		var			theDialog: DialogPtr;			tempP: WindowPtr;			localitemHit: integer;			fillObservedFreq: boolean;			st, et, sc, ec: integer; 	begin		fillObservedFreq := true;		StartDLOG(603, theDialog, tempP);		ItemCheckMark(theDialog, 3, not fillObservedFreq);		ItemCheckMark(theDialog, 4, fillObservedFreq);		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			if localItemHit in [3, 4] then				begin					fillObservedFreq := (localItemHit = 4);					ItemCheckMark(theDialog, 3, not fillObservedFreq);					ItemCheckMark(theDialog, 4, fillObservedFreq);				end			else if localItemHit = 6 then				GetRandomSeed;		until localItemHit in [1, 2];		EndDLOG(theDialog, tempP);		if localItemHit = 1 then			begin				CalcSelectedTaxaCharacters(st, et, sc, ec, true);				if fillObservedFreq then					FillRandomWithObsFreq(st, et, sc, ec,false,[],defaultFillFraction)				else					FillRandomWithObsStates(st, et, sc, ec,false,[],defaultFillFraction);			end;	end;{-----------------------------------------------------------------------------}	function RandomStateDLOG (sayfill: boolean): boolean;{DLOG returns info about the relative random fill probabilities of states}		label			1;		var			theDialog: DialogPtr;			box: RECT;			tempH: Handle;			j, tot, numnonzero: integer;			tempP: WindowPtr;			zeroed: boolean;			localItemHit: integer;UserItemUProcP: UniversalProcPtr;DLOGFilterUPP: UniversalProcPtr;	begin{note that RandomStatesH must be set to the approprate Handle - either RandomFillH or RandomAncH -}{before it is used}		NewRandomSeed;		randommax := IntegerMin(highstate, randomMax);		for j := randomMax + 1 to highstate do			RandomStatesH^^[j] := 0;		if numbytes = 4 then			begin				randwidth := 14;				StartDLOG(561, theDialog, tempP);			end		else if numbytes = 2 then			begin				randwidth := 20;				StartDLOG(543, theDialog, tempP);			end;		myShowDialog(theDialog);		if sayfill then			begin				SetButtonTitle(theDialog, 1, 'Fill');			end		else			begin				SetButtonTitle(theDialog, 1, 'Set');				HideDialogItem(theDialog, 9);			end;		distribB := GetDLOGItemBox(theDialog, 7);		if highstate < maxstbit then			InsetRect(distribB, (maxstbit - highstate) * randwidth div 2, 0);		with distribB do			begin				randpullH := left + (RandomMax + 1) * randwidth;				SetRect(randpullB, randpullH - 2, top, randpullH + 2, bottom + 9);			end;UserItemUProcP := MyNewUserItemUPP(@RandomFillDraw);  tempH := Handle(UserItemUProcP);		SetDialogItem(theDialog, 7, UserItem, tempH, box);		DLOGFilterUPP := MyNewModalFilterUPP(@RandomFillFilter);  		repeat			myModalDialog(DLOGFilterUPP, localItemHit);			case localItemHit of				1,9: 					if not Normed then						begin							InstantError(248);							localItemHit := Notindialog;						end;				4:  {norm by +-}					begin						FlashBox(GetDLOGItemBox(theDialog, 4));1:						zeroed := false;						tot := 0;						for j := 0 to RandomMax do							if RandomStatesH^^[j] > 0 then								begin									tot := tot + RandomStatesH^^[j];								end;						if tot > 100 then							begin								numnonzero := 0;								for j := 0 to RandomMax do									if RandomStatesH^^[j] > 0 then										numnonzero := numnonzero + 1;							end						else							numnonzero := RandomMax + 1;						if not Normed then							begin								for j := 0 to RandomMax do{if RandomStatesH^^[j] > 0 then}									RandomStatesH^^[j] := RandomStatesH^^[j] + (100 - tot) div (numnonzero);								for j := 0 to RandomMax do									begin										if RandomStatesH^^[j] < 0 then											begin												RandomStatesH^^[j] := 0;												zeroed := true;											end;									end;								InvalWholeRandom(theDialog);								if zeroed or not Normed then									goto 1;							end;					end;				5:  {norm by */}					begin						FlashBox(GetDLOGItemBox(theDialog, 5));						if not Normed then							begin								tot := 0;								for j := 0 to RandomMax do									tot := tot + RandomStatesH^^[j];								if tot > 0 then									begin										for j := 0 to RandomMax do											RandomStatesH^^[j] := RandomStatesH^^[j] * 100 div tot;										InvalWholeRandom(theDialog);									end								else									Beep;							end;					end;				6:  {equiprobable norming}					begin						FlashBox(GetDLOGItemBox(theDialog, 6));						for j := 0 to RandomMax do							RandomStatesH^^[j] := 100 div (randomMax + 1);						InvalWholeRandom(theDialog);					end;				8: 					GetRandomSeed;				otherwise					;			end;		until (localItemHit in [1, 2, 9]);		if localItemHit = 1 then			oldRandSeed := OurRandSeed;		if localitemhit in [1,9] then			begin				if sayFill then					RandomFillMax := RandomMax				else					RandomAncMax := RandomMax;			end;		RandomStateDLOG := localItemHit = 1;MyDisposeUserItemUPP(UserItemUProcP);MyDisposeModalFilterUPP(DLOGFilterUPP);		EndDLOG(theDialog, tempP);	end;{-----------------------------------------------------------------------------}	procedure FillSelectedWithRandom;		var			st, et, sc, ec: integer;			db: boolean;	begin{$IFC false}		if OptionEvent(Event) then			begin				RandomStatesH := RandomObservedFillH;				RandomMax := RandomObservedFillMax;				FillRandomWithObserved;			end		else{$ENDC}			begin				RandomStatesH := RandomFillH;				RandomMax := RandomFillMax;				ParamText('Fill selected cells with random data in the following probabilities:', '', '', '');				highstate := maxstate;				if editorSelected & ((editorSelectionBotRight.v > 0) & (editorSelectionBotRight.h > 0)) then					begin						if RandomStateDLOG(true) then							begin								CalcSelectedTaxaCharacters(st, et, sc, ec, true);								If not StoreCellBlockForUndo(st, et, sc, ec, false,false,true) then Exit(FillSelectedWithRandom);								FillWithRandom(st, et, sc, ec, true, true, false,[],defaultFillFraction);							end;					end				else					db := RandomStateDLOG(false);			end;	end;{-----------------------------------------------------------------------------}	procedure FillBlockWithRandom (st, et, sc, ec: integer; restrictFill: boolean; stateOfCellsToFill: largestSetChars; fillFraction: integer);	var j: integer;	begin		RandomStatesH := RandomFillH;		RandomMax := RandomFillMax;		highstate := maxstate;		randommax := IntegerMin(maxstate, randomMax);		for j := randomMax + 1 to maxstate do			RandomStatesH^^[j] := 0;		SetCursor(clockCursor);		FillWithRandom(st, et, sc, ec, false, true, restrictFill,stateOfCellsToFill,fillFraction);	end;end.