unit PrintSpreadSheet;{еееееееееееееееееееееее}interface	uses		Printing, QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows,		 Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, 		 Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, 		 WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, 		 Spreadutil, DrawSpread, PrintingUtil, PrintingMisc, TaxonCHUtil, ConsensusSequences;	procedure PrettyPrintData;	procedure PrintData;{еееееееееееееееееееееее}implementation {е$S PrintSpreadSheet}//	procedure PrettyPrintData; begin end;//	procedure PrintData; begin end;const	spaceBelowConsensus = 2;{-----------------------------------------------------------------------------}	function SpacesBetweenCodons(columnWidth: integer): integer;	begin		SpacesBetweenCodons := columnWidth div 2;	end;{-----------------------------------------------------------------------------}	function ColorElementIsSmall(theValue: integer): boolean;	var theValueLong: longint;	begin		theValueLong := theValue;		if theValue<0 then			theValueLong := 32767+(32767+theValueLong);		ColorElementIsSmall := theValueLong<20000;	end;{-----------------------------------------------------------------------------}	function ColorElementIsLarge(theValue: integer): boolean;	var theValueLong: longint;	begin		theValueLong := theValue;		if theValue<0 then			theValueLong := 32767+(32767+theValueLong);		ColorElementIsLarge := theValueLong>40000;	end;{-----------------------------------------------------------------------------}{	function DimColor (theColor: RGBColor; fraction: double): RGBColor;	var tColor: RGBColor;	begin		if fraction < 1.000000 then			begin				tColor.red := SetFractionalColor(whiteRGB.red,theColor.red,fraction);				tColor.green := SetFractionalColor(whiteRGB.green,theColor.green,fraction);				tColor.blue := SetFractionalColor(whiteRGB.blue,theColor.blue,fraction);			end		else			begin				tcolor := theColor;			end;		DimColor := tColor;	end;}{-----------------------------------------------------------------------------}	function IsPaleColor(theColor: RGBColor): boolean;	begin		isPaleColor :=ColorElementIsLarge(theColor.red) & ColorElementIsLarge(theColor.blue) & ColorElementIsLarge(theColor.green);	end;{-----------------------------------------------------------------------------}	procedure DrawPrettyPrintBlock(var top: integer; leftmargin,fontsize,columnWidth,lineWidth,namesWidth,startit,endit,startic,endic: integer);	{top is vertical positioning on page of top of block}	var it,ic: integer;		firstCharLeft : integer;		tsts: largestsetchars;		ds: str255;		box: rect;		theColor: RGBColor;		consensusNumber: integer;		trueMajority: boolean;		dataFraction: double;		oldClip: RgnHandle;		consensusDim, shade: boolean;		theConsensus: ConsensusPtr;		codPosAdjustment: longint;		codposGap: integer;	begin		codposGap := SpacesBetweenCodons(columnWidth);		oldClip := NewRgn;		GetClip(oldClip);		firstCharLeft:= leftmargin+namesWidth;		TextFace([]);		TextSize(fontsize-1);		MoveTo(firstcharLeft,top);		DrawString(StringFromNum(startic));		codPosAdjustment := 0;		for ic := startic to endic do			begin				if nucleotides & prettyPrintSpaceBetweenCodons & (CharCodPos(ic)=1) then 					codPosAdjustment := codPosAdjustment+codPosGap;				if (ic mod 10 = 0) & (ic<>startic) & (ic<>endic) & (ic<>startic+1) & (ic<> endic-1)then					begin						MoveTo(firstcharLeft+(ic-startic)*columnWidth+codPosAdjustment,top);						DrawString(StringFromNum(ic));					end;			end;		MoveTo(firstcharLeft+(endic-startic)*columnWidth+codPosAdjustment,top);		DrawString(StringFromNum(endic));		TextFace([bold]);		TextSize(fontsize);		top := top+linewidth;		for it := startit to endit do			begin				if it=1 then 					top := top+spaceBelowConsensus;				MoveTo(leftmargin,top);				SetRect(box,leftmargin,0,firstCharLeft-4,top+linewidth);				ClipRect(box);				if it < 1 then					begin						consensusNumber := it + editorNumConsensusSequences;						TextFace([bold,italic]);						DrawString(GetConsensusName(consensusNumber));						TextFace([bold]);						theConsensus := Consensus(consensusNumber);					end				else					DrawString(TaxonName(it));				SetClip(oldClip);				MoveTo(firstCharLeft, top);				codPosAdjustment := 0;				for ic := startic to endic do					begin						shade := editorShadeCharSetCells & ShadeCharacter(ic);						consensusDim := false;												if nucleotides & prettyPrintSpaceBetweenCodons & (CharCodPos(ic)=1) then 							codPosAdjustment := codPosAdjustment+codPosGap;						MoveTo(firstCharLeft+(ic-startic)*columnWidth+codPosAdjustment,top);						if it< 1 then							begin								tsts := GetConsensusSet(consensusNumber,ic,consensusNumber=1,false,trueMajority,[],dataFraction);								consensusDim := (dataFraction < 1.0) & (theConsensus<> nil) &((theConsensus^.dimProportionalToFreq)|(theConsensus^.dimProportionalToNonGaps));								if editorShowCellSymbol then									if tsts = [] then										ds := ''									else 										ds := StsToString(tsts, ic, editorShowFullStateNames & not nucleotides,nucleotides);							end						else							begin								tsts := GetTaxonStsLargest(it, ic);								if editorShowCellSymbol then									if matchcharon & (it > 1) & (Gettaxonstslargest(1, ic) = tsts) & not (MSl in tsts) then										ds := matchchar									else										begin											ds := StsToString(tsts, ic, editorShowFullStateNames & not nucleotides,nucleotides);											CheckConvertAlternativeSymbol(false,true,it,ic,ds);										end;							end;						SetRect(box,0,0,columnWidth,lineWidth);						OffsetRect(box,firstCharLeft+(ic-startic)*columnWidth-2+codPosAdjustment,top-lineWidth+2);						if not (msl in tsts) & (tsts <> []) then							begin								{if nucleotides then									RGBForeColor(GrayScale(4,MinLg(tsts)+1))								else									RGBForeColor(colorCellKey^[MinLg(tsts)]);}								theColor := whiteRGB;								case editorColorCellsMode of									editorColorCellsMatchFirst:										if not (MSl in tsts) & ((it = 1) | (Gettaxonstslargest(1, ic) = tsts)) then											theColor := GrayScale(5,2);									editorColorCellsAAState:										begin											if it < 1 then												 PrepareAAfromDNA(consensusNumber,ic,ic,tsts,true,writeStandardCells)											else												 PrepareAAfromDNA(it,ic,ic,tsts,false,writeStandardCells);											if (tsts<>[]) & not (MSl in tsts) then												if (CardLg(tsts)=1)then													theColor := proteinColorKey^[MinLg(tsts)]												else													theColor := polyMorphColor;										end;									editorColorCellsState:										theColor := GetCellColor(ic,tsts);									otherwise ;								end;								if (it<1) & consensusDim then									theColor := DimColor(theColor,dataFraction);								if shade then									if editorShadeCharSetLighter then										theColor :=  DimColor(theColor,0.2)									else										theColor :=  DarkenColor(theColor,0.7);								RGBForeColor(theColor);								FillRect(box,QDBlack);							{	if not IsPaleColor(theColor) then									RGBForeColor(whiteRGB)								else									RGBForeColor(blackRGB);}								if prettyPrintWhiteSymbols & (tsts<> []) & not ((theColor.red=whiteRGB.red)&(theColor.blue=whiteRGB.blue)&(theColor.green=whiteRGB.green)) then									RGBForeColor(whiteRGB)								else									RGBForeColor(blackRGB);							end						else							RGBForeColor(blackRGB);						if editorShowCellSymbol then							if (length(ds) <= 1) | (editorShowFullStateNames & not nucleotides & (length(ds) <=5)) then  {Davidv4.1: have this as an option???}								DrawString(ds)							else if UCl in tsts then									DrawString (orsep) 								else									DrawString (andsep);						RGBForeColor(blackRGB);					end;				top := top+linewidth;			end;		top := top+linewidth;		ZapHandle(oldClip);	end;{-----------------------------------------------------------------------------}	function QueryPrettyPrint: boolean;{if ever add more options to this, then get rid of "if editorShowCellSymbol then" below}	var oldprettyPrintWhiteSymbols, oldprettyPrintSpaceBetweenCodons: boolean;			localItemHit: integer;			theDialog: DialogPtr;			oldboolean: boolean;			tempP: WindowPtr;{............}		procedure CheckPrettyPrintOptions;		begin			ItemCheckMark(theDialog, 3, prettyPrintWhiteSymbols);			ItemCheckMark(theDialog, 4, not prettyPrintWhiteSymbols);			ItemCheckMark(theDialog, 6, nucleotides & someCoding&prettyPrintSpaceBetweenCodons);		end;{............}	begin		if (editorColorCellsMode=editorColorCellsOff) & not (nucleotides & SomeCoding) then //there are no choices!			begin				QueryPrettyPrint := true;				{prettyPrintWhiteSymbols := false;}			end		else			begin				oldprettyPrintWhiteSymbols:= prettyPrintWhiteSymbols;				oldprettyPrintSpaceBetweenCodons := prettyPrintSpaceBetweenCodons;				if editorColorCellsMode=editorColorCellsOff then					prettyPrintWhiteSymbols := false;				StartDLOG(173, theDialog, tempP);				CheckPrettyPrintOptions;				myShowDialog(theDialog);				EnableDisableDLOGItem(theDialog,6,nucleotides & someCoding,false);				EnableDisableDLOGItem(theDialog,3,editorColorCellsMode<>editorColorCellsOff,false);				FrameButton(theDialog, 1);				repeat					ModalDialog(nil, localItemHit);					case localitemHit of						3:	prettyPrintWhiteSymbols := true;						4: 	prettyPrintWhiteSymbols := false;						6: 	prettyPrintSpaceBetweenCodons := not prettyPrintSpaceBetweenCodons;						otherwise;					end;					CheckPrettyPrintOptions;				until localItemHit in [1, 2];				if localItemHit = 2 then					begin						prettyPrintWhiteSymbols := oldprettyPrintWhiteSymbols;						prettyPrintSpaceBetweenCodons := oldprettyPrintSpaceBetweenCodons;					end;				EndDLOG(theDialog, tempP);				QueryPrettyPrint := localItemHit = 1;			end;	end;{-----------------------------------------------------------------------------}	procedure PrettyPrintData;	label 1;		var			col: integer;			trect,boundaryRect: rect;			theDialog: DialogPtr;			tempP: WindowPtr;			{%%%pgWidth, pgHeight, }leftmargin: Integer;			colperpage, TotalBlocks, rowperpage, numPagesPerBlock: integer;			verpg, horpg: longint;			numBlocksPerPage: integer;			oldnumcols, oldnumrows, nc: integer;			startit,endit,startic,endic: integer;			numpages: integer;			top: integer;			theBlock, thePage: integer;			whichPageInBlock: integer;			columnWidth, namesWidth, linewidth, fontsize : integer;			oldeo: point;			codPosGaps,firstColPerPage, endCodPos: integer;			numConsenses : integer;	begin{v4: vertMatrixNames := OptionEvent(Event);}		if editorShowCellSymbol then  {remove this if ever add more options to QueryPrettyPrint!}			if not QueryPrettyPrint then				Exit(PrettyPrintData);		SetCursorToArrow;		genericGetPort(tempP);		if ConsensusSequenceVisible then			numConsenses := editorNumConsensusSequences		else			numConsenses := 0;		if OpenPrinter(true) then			begin				if StartPrinting(true) then					begin						CalcPgSizes(pgWidth, pgHeight);						fontsize := editorFontSize;						TextFont(editorFont);						TextSize(fontSize);						TextFace([bold]);						codPosGaps := 0;						if nucleotides then							begin								columnWidth := CharWidth('G');								if CharWidth('A') > columnWidth then columnWidth := CharWidth('A');								if CharWidth('C') > columnWidth then columnWidth := CharWidth('C');								if CharWidth('T') > columnWidth then columnWidth := CharWidth('T');								columnWidth := columnWidth + 2;								codPosGaps := SpacesBetweenCodons(columnWidth);							end						else							begin								if editorShowFullStateNames & not nucleotides then									columnWidth := CharWidth('M')*3								else									columnWidth := CharWidth('M')+2;							end;						namesWidth := editorRowNameEnd-editorRowNameStart;						if AAAutoTranslationVisible then							lineWidth := (editorLineWidth-2) div 2						else							lineWidth := editorLineWidth-2;	  {width in pixels}						colperpage := (pgwidth - namesWidth) div columnWidth;						if nucleotides & someCoding & prettyPrintSpaceBetweenCodons then							begin								colperpage := colperpage - ((colperpage div 3) * codPosGaps) div columnWidth;								firstColPerPage := colPerPage;								colperpage := (colperpage div 3)*3;								endCodPos := CharCodPos(colPerPage);								firstColPerPage := colPerPage;								if (endCodPos = 1) then									firstColPerPage := colPerPage-1								else if (endCodPos=2) then									if firstColPerPage>colPerPage then										firstColPerPage := colPerPage + 1									else										firstColPerPage := colPerPage -2;							end						else							begin								colperpage := (colperpage div 5)*5;								firstColPerPage := colPerPage;							end;						{ok, so we know there will be colperpage columns wide for each page} 										TotalBlocks := 1+ (editorTotalColumns - firstColPerPage) div colperpage;  {TotalBlocks:  number of blocks the matrix will be divided into}						if (editorTotalColumns - firstColPerPage) mod colperpage > 0 then							TotalBlocks := TotalBlocks + 1;	  {height in pixels}						rowperpage := (pgHeight - spaceBelowConsensus) div lineWidth-2;						numPagesPerBlock := editorTotalRows div rowperpage;  {numPagesPerBlock:  number of pages each block will be printed on}						if editorTotalRows mod rowperpage > 0 then							numPagesPerBlock := numPagesPerBlock + 1;													if numPagesPerBlock = 1 then 							begin								numBlocksPerPage := rowPerPage div (editorTotalRows+2);								numPages := TotalBlocks div numBlocksPerPage;								if TotalBlocks mod numBlocksPerPage > 0 then									numPages := numPages + 1;							end						else							begin								numBlocksPerPage := 0;								numPages := numPagesPerBlock * TotalBlocks;							end;												if lastPage > numPages then lastPage := numPages;						BoundaryRect := printPageR;						leftmargin := printPageR.left;						topmargin:=  printPageR.top;												startic := 1;						endic:= firstColPerPage;						if PrepareDocument then							if numBlocksPerPage> 0 then								begin									startit:= 1-numconsenses;									endit:= numtaxa;									for thePage := 1 to numpages do										if (thePage >= firstPage) & (thePage <= lastPage) then											begin												if thePage = firstPage then													begin														startic := 1;														endic:= startic+firstColPerPage-1;													end												else													begin														startic := firstColPerPage-colPerPage+colPerPage*(thePage-1)*numBlocksPerPage+1;														endic:= startic+colPerPage-1;													end;												top:= topmargin+lineWidth*2;												if OpenPrinterPage then													begin														ClipRect(BoundaryRect);														for theBlock := 1 to numBlocksPerPage do															begin																if endic > numchars then																	endic := numchars;																DrawPrettyPrintBlock(top,leftmargin,fontsize,columnWidth,lineWidth,namesWidth,startit,endit,startic,endic);																startic := endic + 1;																endic := startic+colPerPage-1;																if startic > numchars then leave;																if PrinterError then goto 1;															end;														ClosePrinterPage;													end;											end										else											begin  {empty pages}												if not OpenPrinterPage then goto 1;												ClosePrinterPage;											end;								end							else   {each block goes over more than one page}								for thePage := 1 to numPages do									if (thePage >= firstPage) & (thePage <= lastPage) then										begin											theBlock := thePage div numPagesPerBlock+1;											whichPageInBlock := thePage mod numPagesPerBlock;											if thePage mod numPagesPerBlock=0 then												begin													theBlock := theBlock - 1;													whichPageInBlock := numPagesPerBlock;												end;											startit := (whichPageInBlock-1)*rowPerPage+1-numConsenses;											endit := startit+rowPerPage-1;											if endit > numtaxa then												endit := numtaxa;											startic := colPerPage*(theBlock-1)+1;											endic:= startic+colPerPage-1;											if endic > numchars then												endic := numchars;											top:= topmargin+lineWidth*2;											if OpenPrinterPage then												begin													ClipRect(BoundaryRect);													DrawPrettyPrintBlock(top,leftmargin,fontsize,columnWidth,lineWidth,namesWidth,startit,endit,startic,endic);													if PrinterError then goto 1;													ClosePrinterPage;												end;										end									else										begin  {empty pages}											if not OpenPrinterPage then goto 1;											ClosePrinterPage;										end;{							for theBlock := 1 to TotalBlocks do								begin									startit:= 1;									endit:= rowperpage;									if endic > numchars then										endic := numchars;									for thePage := 1 to numPagesPerBlock do										begin											top:= topmargin+editorLineWidth*2;											OpenPrinterPage; 											if endit > numtaxa then												endit := numtaxa;											DrawPrettyPrintBlock(top,leftmargin,startit,endit,startic,endic);											startit := endit + 1;											endit := startit+rowPerPage-1;											if startit > numtaxa then leave;											if PrinterError then goto 1;											ClosePrinterPage;										end;									startic := endic + 1;									endic := startic+colPerPage-1;									if startic > numchars then leave;								end;}													1:{============================}						EndPrint;					end;				PrintCancelOff;				if not editorOpen then					textfont(TWFont);				ClosePrinter;			end;		genericSetPort(tempP);		CalcEditorBoundaryRect;		CalcEditorMatrixRect;		vertMatrixNames := false;	end;{-----------------------------------------------------------------------------}	procedure PrintData;		var			col: integer;			trect: rect;			theDialog: DialogPtr;			tempP: WindowPtr;			{%%%pgWidth, pgHeight, }leftmargin: Integer;			colperpage, npwidth, rowperpage, npheight, verpg, horpg: longint;			oldnumcols, oldnumrows, nc: integer;			oldeo: point;	begin{v4: vertMatrixNames := OptionEvent(Event);}		SetCursorToArrow;		oldnumcols := editorColumns;		oldnumrows := editorRows;		oldeo := editorOrigin;		genericGetPort(tempP);		if OpenPrinter(true) then			begin				if StartPrinting(true) then					begin						CalcPgSizes(pgWidth, pgHeight);	  {width in pixels}						colperpage := (pgwidth - editorRowNameEnd) div editorColumnWidth;						npwidth := editorTotalColumns div colperpage;						if editorTotalColumns mod colperpage > 0 then							npwidth := npwidth + 1;						editorColumns := colperpage;						leftmargin := printPageR.left;	  {height in pixels}						rowperpage := (pgHeight - editorTitlesWidth) div editorLineWidth;						npheight := editorTotalRows div rowperpage;						if editorTotalRows mod rowperpage > 0 then							npheight := npheight + 1;						editorRows := rowperpage;						editorBoundaryRect := printPageR;						SetEWClip(noscroll);						editorOrigin.v := 1;						editorOrigin.h := 1;						CalcEditorMatrixRect;						TextFont(editorFont);						TextSize(editorFontSize);						verpg := 1;						if PrepareDocument then						while NoPrinterError and (verpg <= npheight) do							begin								horpg := 1;								editorOrigin.v := (verpg - 1) * rowperpage + 1;								while NoPrinterError and (horpg <= npwidth) do									begin										editorOrigin.h := (horpg - 1) * colperpage + 1;										if OpenPrinterPage then{SetOrigin(-36, 0);}{this SetOrigin seems fine when printing normal on an Imagewriter, but causes total}{bizarre screw-up if printing sideways}											begin												trect := printPageR;												cliprect(trect);{$IFC PRINTSTAMP}												if printStampLine then													begin														trect.right := editorRowNameEnd;														DrawStampLine(trect, true);													end;{$ENDC}												{if grid then													DrawGrid												else													begin}														PenSize(2, 2);														MoveTo(editorRowNameEnd, editorTitlesWidth);														LineTo(editorRowNameEnd, editorMatrixRect.bottom);														PenSize(1, 1);												{	end;}												DrawRCNumbers;												DrawRowNames;												if (editorOrigin.h + editorColumns - 1 > editorTotalColumns) then													nc := editorTotalColumns - (editorOrigin.h) + 1												else													nc := editorColumns;												for col := 1 to nc do													DrawColCells(col, false, true, false, false);{SetOrigin(0, 0);}												ClosePrinterPage;											end;										pg := pg + 1;										horpg := horpg + 1;									end;								verpg := verpg + 1;							end;{============================}						EndPrint;					end;				PrintCancelOff;				if not editorOpen then					textfont(TWFont);				ClosePrinter;			end;		genericSetPort(tempP);		editorOrigin := oldeo;		editorColumns := oldnumcols;		editorRows := oldnumrows;		CalcEditorBoundaryRect;		CalcEditorMatrixRect;		vertMatrixNames := false;	end;end.