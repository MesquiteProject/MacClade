unit ExportUtil;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, 		TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, 		ErrorUtil, EventUtil, GenUtil, StrUtil, TaxonCHUtil, SymbolsNames, TypeUtil, 		SpreadUtil, CharUtil, TreeUtil, CHUNK, ReadWriteUtil, ReadUtil, WriteUtil, LinkUtil, 		TreeMaker, TreeCycle, FootNote;	procedure PutExportReturn (filetype: integer);	procedure OddToUnderline (var ds: str255);	function exportTaxonName (filetype, it, numplaces: integer): str255;	procedure WriteFileComments;	function QueryText (var dotitles, dostates, maccladereadable, dostatenames, doFeet: boolean): boolean;	procedure WriteTextFile (dotitles, dostates, maccladereadable, dostatenames, doFeet: boolean);	procedure WriteDescriptionsFile;	procedure WriteForeignTrees (filetype: integer; theChain: Integer; indatafile: boolean);	procedure WriteExportTrees (filetype: integer);	var nbrfCondenseNames: boolean;		nbrfCreateTranslationTable: boolean;{еееееееееееееееееееееее}implementation {е$S ExportUtil}{----------------------------------------------------------------------------}	procedure PutExportReturn (filetype: integer);	begin		case ExportDelimiter[filetype] of			ExpCR: 				putSingleChar(Char(13));			ExpLF: 				putSingleChar(Char(10));			ExpCRLF: 				begin					putSingleChar(Char(13));					putSingleChar(Char(10));				end;			otherwise				;		end;	end;{-----------------------------------------------------------------------------}	procedure OddToUnderline (var ds: str255);		var			j: integer;	begin		if length(ds) > 0 then			begin				if ((ds[1] >= '0') and (ds[1] <= '9')) or (ds[1] = '_') then					insert('a', ds, 1);		{make first character alphabetical}				for j := 1 to length(ds) do					if not ((ds[j] = '_') or ((ds[j] >= 'a') and (ds[j] <= 'z')) or ((ds[j] >= 'A') and (ds[j] <= 'Z')) or ((ds[j] >= '0') and (ds[j] <= '9'))) then						ds[j] := '_';			end;	end;{----------------------------------------------------------------------------}	function exportTaxonName (filetype, it, numplaces: integer): str255;		var			ds: str255;			j: integer;	begin		ds := TaxonName(it);		BlanksToUnderLine(ds);		if filetype = hennig then			OddToUnderline(ds)		else if filetype = phylip then			if pos(';', ds) > 0 then				for j := 1 to length(ds) do					if ds[j] = ';' then						ds[j] := '_';		ds := concat(ds, '                                        ');		ds := CopyString(ds, 1, numplaces);		exportTaxonName := ds;	end;{----------------------------------------------------------------------------}	procedure WriteCharStateNames (dofull: boolean);		var			ic, endchar: integer;			ds: str255;			state, j: integer;			chunksize: longint;			laststate: integer;{.............}		procedure HennigToken (var ds: str255);		begin			repeat				if pos(';', ds) > 0 then					ds[pos(';', ds)] := '.';			until pos(';', ds) = 0;			repeat				if pos('''', ds) > 0 then					ds[pos('''', ds)] := '_';			until pos('''', ds) = 0;		end;{.............}	begin		if not molecular then			begin				endchar := numchars;				while (endchar > 0) and (CharName(endchar) = '') do					endchar := endchar - 1;				if endchar > 0 then					begin						if dofull then							begin								puttoken('quote ');								putExportReturn(hennig);							end;						puttoken('Named Characters and States');						for ic := 1 to endchar do							begin								putExportReturn(hennig);								putTab;								putSingleChar('[');								puttoken(StringFromNum(ic));								putSingleChar(']');								putTab;								ds := CharName(ic);								HennigToken(ds);								puttoken(ds);								laststate := LastStateName(ic);								if laststate >= 0 then									begin										putTab;										CHUNKpos := 0;										for state := 0 to laststate do											begin												ds := GetNextStateName(ic);												if ds = NoName then													ds := '_'												else if ds = EndNames then													leave												else													HennigToken(ds);												puttoken(ds);												if state <> laststate then													putSpace;											end;									end;							end;						if dofull then							begin								putExportReturn(hennig);								putSingleChar(';');								putExportReturn(hennig);							end;					end;			end;	end;{-----------------------------------------------------------------------------}	procedure WriteFileComments;{writes file comments into Hennig files}		var			j: integer;			chdl: CharsHandle;			c: char;	begin		putExportReturn(hennig);		if textWindowInfo[aboutFileText]^.TE^^.teLength > 0 then			begin				puttoken('quote ');				chdl := TEGetText(textWindowInfo[aboutFileText]^.TE);				for j := 0 to textWindowInfo[aboutFileText]^.TE^^.telength - 1 do					begin						c := chdl^^[j];						if c = ';' then							c := '.';						putSingleChar(c);					end;				putExportReturn(hennig);				putExportReturn(hennig);				WriteCharStateNames(false);				putSingleChar(';');				putExportReturn(hennig);			end		else			WriteCharStateNames(true);	end;{-----------------------------------------------------------------------------}	function QueryText (var dotitles, dostates, maccladereadable, dostatenames, doFeet: boolean): boolean;		var			theDialog: DialogPtr;			tempP: WindowPtr;			oldtextsep: char;			localItemHit: integer;{................}		procedure CheckQueryText;		begin			ItemCheckMark(theDialog, 4, dotitles);			ItemCheckMark(theDialog, 5, dostates);			ItemCheckMark(theDialog, 6, dostatenames);			ItemCheckMark(theDialog, 7, maccladeReadable);			ItemCheckMark(theDialog, 8, textsep = chr(9));			ItemCheckMark(theDialog, 9, textsep = ' ');			ItemCheckMark(theDialog, 10, textsep = BS);			if AnyFeet(foottext) then				ItemCheckMark(theDialog, 12, doFeet);		end;{................}	begin		oldtextsep := textsep;		doFeet := true;   {v3.01}		dotitles := false;		dostates := false;		dostatenames := not nucleotides & editorShowFullStateNames;		maccladereadable := false;		StartDLOG(544, theDialog, tempP);{    EnableDisableDLOGItem(theDialog, 7, MOS <= 9, false); } {can't make it MacClade readable if MOS > 9}		EnableDisableDLOGItem(theDialog, 12, AnyFeet(foottext), false);  {disable footnotes export if no feet}		CheckQueryText;		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			if localItemHit in [4, 5, 6, 12] then				maccladeReadable := false;			case localItemHit of				4: 					dotitles := not dotitles;				5: 					dostates := not dostates;				6: 					dostatenames := not dostatenames;				7: 					begin						maccladeReadable := not maccladeReadable;						dotitles := false;						dostates := false;						dostatenames := false;						doFeet := false;					end;				8: 					textsep := chr(9);				9: 					textsep := ' ';				10: 					textsep := BS;				12: 					dofeet := not dofeet;				otherwise					;			end;			CheckQueryText;		until localItemHit in [1, 2];		EndDLOG(theDialog, tempP);		if localItemHit = 2 then			textsep := oldtextsep;		queryText := (localItemHit = 1);	end;{----------------------------------------------------------------------------}	procedure WriteCharLegend (ic: integer);		var			ir, numnames: integer;	begin		numnames := LastStateName(ic);		if numnames >= 0 then			for ir := 0 to numnames do				if CharStateName(ic, ir) <> '' then					begin						putTab;						PutToken(StringFromNum(ir));						PutToken(':  ');						PutToken(charstatename(ic, ir));						putExportReturn(simpletext);					end;		putExportReturn(simpletext);	end;{----------------------------------------------------------------------------}	procedure FootTextWrite (it, ic: integer);		var			ds: str255;			db: boolean;	begin		if footpresent(it, ic) then			begin				PutToken(FootCellTitle(it, ic));				db := GetFootString(footText, it, ic, ds);				Puttoken(ds);				putExportReturn(simpletext);			end;	end;{----------------------------------------------------------------------------}	procedure WriteFootTexts;		var			it, ic: integer;	begin		putExportReturn(simpletext);		putExportReturn(simpletext);		putToken('FOOTNOTES');		putExportReturn(simpletext);		for it := 1 to numtaxa do			FootTextWrite(it, 0);		for ic := 1 to numchars do			FootTextWrite(0, ic);		for it := 1 to numtaxa do			for ic := 1 to numchars do				FootTextWrite(it, ic);	end;{----------------------------------------------------------------------------}	procedure WriteTextFile (dotitles, dostates, maccladereadable, dostatenames, doFeet: boolean);{dotitles: draw titles at head of columns}{dostates: put full state legends}{dostatenames: use statenames in matrix}{doFeet: write footnotes at end of matrix}		var			k, ic, it, icstart, icend: integer;			numblocks, blocklength, leavelength: integer;			ds: str255;			tsts: largestsetchars;			convertpoly: boolean;			oldsymbols: str255;			olddrawstates: boolean;			oldmatchcharon: boolean;			oldState: SignedByte;	begin		oldsymbols := symbols;		olddrawstates := editorShowFullStateNames;		oldmatchcharon := matchcharon;		leavelength := interleavelength;{===========  MacClade Readable ===============}		if MacCladeReadable then			begin				if not molecular then					symbols := defSymbols;				editorShowFullStateNames := false;				matchcharon := false;		{turn off matchchar so all states written}				convertpoly := false;				puttoken('[Exported from MacClade file ');				LockHandle(filename, oldState);				puttoken(filename^^);				ResetHandle(filename, oldState);				putSingleChar(']');				putExportReturn(simpletext);				for it := 1 to numtaxa do					begin						ds := TaxonName(it);						PrepareToken(ds, tnw);						puttoken(ds);						if textsep <> chr(9) then							puttab;						for ic := 1 to numchars do							begin								if textsep <> BS then									putSingleChar(textsep);								tsts := GetTaxonStsLargest(it, ic);								if MultipleStatesLg(tsts) then									begin										putSingleChar('?');										convertpoly := true;										NewError(101, 0);									end								else if gal in tsts then									putSingleChar('-')								else if msl in tsts then									putSingleChar('?')								else									putSingleChar(CharOfNum(minLg(tsts)));							end;						putExportReturn(simpletext);					end;				if convertpoly then					puttoken('[!Note that some polymorphic entries were converted to missing data!]');			end		else			begin				editorShowFullStateNames := dostatenames;{===========  not editorTransposed ===============}				if not editorTransposed then					begin						if interleave then							begin								numblocks := numchars div leavelength;								if (numchars mod leavelength <> 0) then									numblocks := numblocks + 1;								blocklength := leavelength;							end						else							begin								numblocks := 1;								blocklength := numchars;								leavelength := numchars;							end;						for k := 1 to numblocks do							begin								icstart := (k - 1) * leavelength + 1;								icend := icstart + leavelength - 1;								if icend > numchars then									icend := numchars;{............ character titles ...........}								if dotitles then									begin										if textsep <> chr(9) then											puttab;										for ic := icstart to icend do  {do titles}											begin												if textsep <> BS then													putSingleChar(textsep);												ds := CharName(ic);												if ds = '' then			{v3.01}													putToken(StringFromNum(ic))												else													puttoken(Charname(ic));											end;										putExportReturn(simpletext);									end;{............ matrix ...........}								for it := 1 to numtaxa do									begin										puttoken(TaxonName(it));										if textsep <> chr(9) then											puttab;										for ic := icstart to icend do											begin												if textsep <> BS then													putSingleChar(textsep);												puttoken(TaxonCharacterCellEntry(it, ic,tsts));											end;										putExportReturn(simpletext);									end;{............ state legends ...........}								if dostates then									begin										putExportReturn(simpletext);   {v3.01}										for ic := icstart to icend do											if (CharName(ic) <> '') or SomeStateNames(ic) then												begin													puttoken(StringFromNum(ic));													putSingleChar(".");													putSpace;													puttoken(AvailCharname(ic));													putExportReturn(simpletext);													WriteCharLegend(ic);												end;									end;							end					end{=========  transposed   ========}				else					begin{............ taxon titles ...........}						if dotitles then							begin								if textsep <> chr(9) then									puttab;								for it := 1 to numtaxa do									begin										if textsep <> BS then											putSingleChar(textsep);										puttoken(TaxonName(it));									end;								putExportReturn(simpletext);							end;{............ matrix ...........}						for ic := 1 to numchars do							begin								puttoken(Charname(ic));								if textsep <> chr(9) then									puttab;								for it := 1 to numtaxa do									begin										if textsep <> BS then											putSingleChar(textsep);										puttoken(TaxonCharacterCellEntry(it,ic, tsts));  									end;								putExportReturn(simpletext);								if dostates then									WriteCharLegend(ic);							end;					end;{write footnotes if requested}				if doFeet & AnyFeet(footText) then					WriteFootTexts;   {v3.01}			end;		editorShowFullStateNames := olddrawstates;		symbols := oldsymbols;		matchcharon := oldmatchcharon;	end;{----------------------------------------------------------------------------}	procedure WriteDescriptionsFile;		var			it, ic, j: integer;			tsts: largestsetchars;			firstState: boolean;	begin		for it := 1 to numtaxa do			begin				putExportReturn(descriptions);				puttoken(TaxonName(it));				putExportReturn(descriptions);				for ic := 1 to numchars do					begin						tsts := gettaxonstsLargest(it, ic);						if tsts = [MSl] then							begin								if false then  {v4: do only if ask to include unknowns}									begin										puttoken(Charname(ic));										puttoken(' unknown.  ');									end							end						else							begin								puttoken(Charname(ic));								putSpace;								firstState := true;								for j := 0 to MOS do									if j in tsts then										begin											if not firstState then												if UCl in tsts then													puttoken(' or ')												else													puttoken(' and ');											tsts := tsts - [j];											PutToken(AvailCharStateName(ic, j));											if tsts = [] then												leave;											firstState := false;										end;								puttoken('.  ');							end;					end;				putExportReturn(descriptions);			end;	end;{----------------------------------------------------------------------------}	procedure WriteForeignTrees (filetype: integer; theChain: Integer; indatafile: boolean);		var			j: integer;			ds: str255;			H: Handle;			status, querycyclepoly, oldtreeinmemory: boolean;{......................}		procedure SaveTreeHenn (N: Nptr);  {converts tree to parenthesis strings}		begin			if NodeIsTerminal(N) then				begin					NumToString(N^.name - 1, ds);					AppendToHandle(treedataH, ds)				end			else				begin					if not N^.null then						AppendToHandle(treedataH, '(');					SaveTreeHenn(N^.lf);					AppendToHandle(treedataH, ' ');					SaveTreeHenn(N^.rt);					if not N^.null then						AppendToHandle(treedataH, ')');				end;		end;{......................}		procedure SaveTreePhylip (N: Nptr);  {converts tree to parenthesis strings}		begin			if NodeIsTerminal(N) then				begin					AppendToHandle(treedataH, exportTaxonName(phylip, N^.name, 10))				end			else				begin					AppendToHandle(treedataH, '(');					SaveTreePhylip(N^.lf);					AppendToHandle(treedataH, ',');					SaveTreePhylip(N^.rt);					AppendToHandle(treedataH, ')');				end;		end;{...........}	begin		if (filetype = hennig) then			begin				puttoken('tread');				putExportReturn(filetype);				puttoken('''exported from MacClade''');				putExportReturn(filetype);			end		else if (filetype = phylip) and ((phylipversion = 33) or indatafile) then   {v3.05: added indatafile}			begin				NumToString(UserLinks[theChain], ds);				puttoken(ds);				putExportReturn(filetype);			end;		querycyclepoly := false;		status := false;		blastpolytomies := false;		oldtreeinmemory := treeinmemory;		if treeopen then			StoreCurrentTree(H)		else if treeinmemory then			begin				H := NewHandle(2);				CopyHandles(treedataH, H);			end;		for j := StartUserLink(theChain) to EndUserLink(theChain) do			begin				BuildTree(nil, j, status, querycyclepoly, true, true, true);				if treemakingfailed then					NewError(382, 0)				else if status then					begin						if ancon then							NewError(395, 0);						if (filetype = phylip) & nullson then   {v3.04: put restriction filetype=phylip}							NewError(396, 0);						if filetype = hennig then							SaveTreeHenn(R)						else if filetype = phylip then							SaveTreePhylip(R);						WriteHandle(treedataH,ExportDelimiter[filetype]);						if filetype = hennig then							if j < EndUserLink(theChain) then								putSingleChar('*')							else								putSingleChar(';')						else if filetype = phylip then							putSingleChar(';');						putExportReturn(filetype);					end				else					NewError(35, 0);			end;		if treeopen then			RestoreCurrentTree(H, true)			{H disposed of within RestoreCurrentTree as "true" passed}		else if oldtreeinmemory then			begin				CopyHandles(H, treedataH);				ZapHandle(H);			end;		treeinmemory := oldtreeinmemory;		if (filetype = hennig) and not indatafile then			puttoken('proc/;');	end;{----------------------------------------------------------------------------}	procedure WriteExportTrees (filetype: integer);		label			1;		var			j: integer;			theInfo: FInfo;			thefile: integer;			oldexists, db: BOOLEAN;			ds, writename: str255;			H: Handle;			dL: longint;			Freply: StandardFileReply;	begin		if infoOpen[treeinfo] & infoEditing[treeinfo] then			ReturnInfoValue(treeinfo);		oldexists := false;		if treefile then			ds := treefilename^^		else			ds := filename^^;		if filetype = hennig then			begin				ds := concat(ds, '.HENtrees');				ds := Copystring(ds, 1, 31);				PutStandardFile('Save HENNIG tree file as:', ds, Freply)			end		else if filetype = phylip then			begin				ds := concat(ds, '.PHYLtrees');				ds := Copystring(ds, 1, maxFileNameLength);				PutStandardFile('Save PHYLIP tree file as:', ds, Freply);			end;		ShowCursor;		if Freply.sfGood then			FSpCreateSaveFile(Freply.sffile,oldexists, 'ttxt', 'TEXT')		else			Errorflag := true;		if errorflag then			goto 1;		StartWrite;		WriteForeignTrees(filetype, treeChain, false);		EndWrite;		if errorflag then			goto 1;		if oldexists then			FSpExchangeFilesDeleteTemp(Freply.sfFile);1:	end;end.