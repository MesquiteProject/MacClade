unit TypeDLOGUtil;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, TaxonCHUtil, TypeUtil, CharUtil, CHUNK, SpreadUtil, EditControl, LinkUtil, Windows;	const		specleft = 66;		spectop = 120;		TDcopy = 3;		TDpaste = 4;		TDclear = 5;		TDrename = 6;		TDnew = 9;		TDshowmatrix = 10;		TDcstree = 11;		TDcleancheck = 12;		TDdefault = 13;		TDsize = 14;		TDenter = 16;		TDsym = 17;		TDApply = 18;		TDDiscCont = 20;		noteleft = 12;		movemode = 1;		join = 2;		disconnect = 3;		rerootmode = 4;		nummodes = 4;		HtAvail = 360;		WAvail = 180;		firstch = 78;		AvailLeft = 10;		topPalette = 263;		leftPalette = 100;	type		StepCellsArray = array[0..absmaxstate, 0..absmaxstate] of boolean;		StepCellsPtr = ^StepCellsArray;	var		StepCells: StepCellsPtr;		editTypeDialog: DialogPtr;		typList: ListHandle;		fulltyprect: RECT;		{rectangle of list of types + scrollbar}		NameRect: RECT;			{rectangle of list of types}		SpecRect: RECT;			{rectangle of step matrix}{StepCellRect: RECT;	}	{rectangle of selected cell in step matrix}		matsizeB: RECT;			{}		fromB: RECT;				{}		toB: RECT;				{}		maxmat: INTEGER;		{maximum number of cells, minus 1, along each edge of the step matrix}		maxdrawMat: INTEGER;	{maximum number of cells DRAWN, minus 1, along each edge of the step matrix}		cliproot: INTEGER;		{}		CurType: INTEGER;		{type number of currently displayed type}		oldCurType: INTEGER;	{type number of last displayed type}		maxTypeEditMat: INTEGER;		{maximum size of step matrix as drawn on window (i.e. only expands to 0..9)}		StepCellHeight, StepCellWidth: integer;		typeBoundaryRect: rect;{    StepCellSel: BOOLEAN;		}		specchanged: BOOLEAN;		{}		showmatrix: BOOLEAN;		{}		TypeInUseChanged: boolean;		AnyTypeChanged: boolean;		curTypeCell: POINT;			{last element in list of type names clicked on}{StepCell: POINT;			}	{currently selected cell in stepmatrix}		CurTypeHdl: typeHandle;		typname: string[typesig];{===== cstree stuff ======}		scount, root, altitude, mode, lastch, leftBoundary, stspace, stsize: integer;		nds: str255;		paletteR, AvailR: rect;		InPlay: array[0..maxCS] of boolean;		crect: array[0..maxCS] of rect;		joinB, moveB, rrootB, scrollTypeRect: rect;		rrootcurs: Cursor;		vTypeStart, hTypeStart: integer;		vTypeScroll, hTypeScroll: ControlRef;	function TypeListName (typnum: integer): str255;	procedure CheckMaxMat;	procedure DrawMatScrolls;	procedure ZeroStepMatrixPos;	procedure AddType (tname: str255);	procedure RenameTypesInChunks (thetype: integer; newname: str255; var somechanged: boolean);	procedure SubtractType (typnum: integer; adjustlist: boolean; var deletecell: point);	procedure CopyTypeSpecs (cfrom, cto: integer; docopy: boolean);	procedure SetStepMatrixFont;	procedure CalcScrollTypeRect;	procedure CalcSpecRect (thetype, theleft, thetop: integer; var typeRect: rect);	function StepCellVisible (stepv, stepH: integer): Boolean;	procedure InvertStepCellRect (stepv, stepH: integer);	function FindStepCellRect (row, col: integer): RECT;	function StepCellSel: boolean;	procedure TriangleDLOG;	procedure TypeEdited (typHdl: typeHandle);	function TypeNumFromList (cell: point): integer;	function ListCellofType (typNum: integer): integer;{еееееееееееееееееееееее}implementation {е$S TypeDLOGUtil}{-----------------------------------------------------------------------------}	function TypeListName (typnum: integer): str255;		var			typeHdl: TypeHandle;			ds: str255;	begin		typeHdl := gettypeHdl(typnum);		ds := typeHdl^^.name;		if typnum = deftype then			ds := concat('*', ds);		if typeHdl^^.inuse then			ds := concat('е', ds);		TypeListName := ds;	end;{-----------------------------------------------------------------------------}	procedure FixMetricity (typHDL: typehandle);		var			ia, ib, ic: integer;			ddist: distancetype;			maxdef, triangleDist: integer;			setdef: largestsetchars;			clean: boolean;	begin		ddist := typHDL^^.dist;		maxdef := typHDL^^.max;		Setdef := typHDL^^.setdefined;		repeat			clean := true;			for ia := 0 to maxdef do				if ia in setdef then					for ib := 0 to maxdef do						if ib in setdef then							for ic := 0 to maxdef do								if ic in setdef then									begin										triangleDist := AddGEndist(ddist[ia, ib], ddist[ib, ic]);										if GenLessThan(triangleDist, ddist[ia, ic]) then											begin												ddist[ia, ic] := triangleDist;												clean := false;											end;									end;		until clean;		typHdl^^.dist := ddist;		InvalidateWindowRect(myGetWindowPtrForDialog(editTypeDialog),specrect,false);		TypeEdited(typHdl);	end;{----------------------------------------------------------------------------}	procedure TriangleDLOG;		const			Checkallitem = 5;			checkcuritem = 4;		var			theDialog: DialogPtr;			checkall, allpass: boolean;			tempP: WindowPtr;			TH: TypeHandle;			j: integer;			localItemHit: integer;{........}		procedure CheckTriangle;		begin			ItemCheckMark(theDialog, checkcuritem, not checkall);			ItemCheckMark(theDialog, checkallitem, checkall);		end;{........}	begin		Checkall := false;		StartDLOG(707, theDialog, tempP);		CheckTriangle;		myShowDialog(theDialog);		FrameButton(theDialog, 1);		repeat			ModalDialog(nil, localItemHit);			case localItemHit of				checkcuritem: 					Checkall := false;				checkallitem: 					Checkall := true;				otherwise					;			end;			CheckTriangle;		until localItemHit in [1, 2];		EndDLOG(theDialog, tempP);		if localItemHit = 1 then			begin				SetCursor(clockCursor);				if checkall then					begin						if numtypes >= usedef then							begin								allpass := true;								for j := usedef to numtypes do									begin										TH := GetTypeHdl(j);										allpass := allpass and PassMetricity(TH);									end;								if allpass then									InstantError(193)								else if CWarning('Triangle inequality violated in at least one type', 'Fix', 'Leave alone') then									for j := usedef to numtypes do										begin											TH := GetTypeHdl(j);											if not PassMetricity(TH) then												FixMetricity(TH);										end;							end						else							InstantError(194);					end				else if (CurType <= dollo) then					InstantError(195)				else if not showmatrix then					InstantError(196)				else if passMetricity(CurTypeHdl) then					InstantError(197)				else if CWarning('Triangle inequality violated!', 'Fix', 'Leave alone') then					FixMetricity(curtypeHdl);			end;		SetCursorToArrow;	end;{----------------------------------------------------------------------------}	procedure CheckMaxMat;	begin		if (maxMat > maxstate) then			maxmat := maxstate;		maxdrawmat := IntegerMin(maxmat, maxTypeEditMat);	end;{----------------------------------------------------------------------------}	procedure DrawMatScrolls;	begin		if (maxMat > maxstate) then			maxmat := maxstate;		maxdrawmat := IntegerMin(maxmat, maxTypeEditMat);		if not printon then			if (maxmat > maxTypeEditMat) and showmatrix then				begin					SetControlMaximumLong(vTypeScroll, maxmat - MaxTypeEditMat);					SetControlMaximumLong(hTypeScroll, maxmat - MaxTypeEditMat);					ShowControl(vTypeScroll);					ShowControl(hTypeScroll);					DoActivateControl(vTypeScroll);					DoActivateControl(hTypeScroll);				end			else				begin					HideControl(vTypeScroll);					HideControl(hTypeScroll);				end;	end;{----------------------------------------------------------------------------}	procedure ZeroStepMatrixPos;	begin		vTypeStart := 0;		hTypeStart := 0;		SetControlValueLong(vTypeScroll, 0);		SetControlValueLong(hTypeScroll, 0);	end;{----------------------------------------------------------------------------}	procedure AddType (tname: str255);		var			deftypeHdl: typeHandle;			ir: integer;			tempname: string[typesig];	begin		AddCHUNKs(typeCHUNKs, 1, Sizeof(typeRecord));		if badmemory then			Exit(AddType);		numtypes := numtypes + 1;		numitems := numitems + 1;		typeHdl := gettypeHdl(numtypes);		if deftype in [dollo, fisher] then			deftypeHdl := gettypeHdl(unordered)		else			deftypeHdl := gettypeHdl(deftype);		typeHdl^^.max := deftypeHdl^^.max;		TypeHdl^^.setdefined := deftypeHdl^^.setdefined;		typeHdl^^.dist := deftypeHdl^^.dist;		tempname := CopyString(tname, 1, typesig);		typeHdl^^.name := tempname;		typeHdl^^.root := -1;		typeHdl^^.inuse := false;		if not showmatrix then			begin				typeHdl^^.isreal := false;				typeHdl^^.maxstar := maxstate;				for ir := 0 to maxCS do					typeHdl^^.nbors[ir] := [];			end		else			begin				typeHdl^^.isreal := deftypeHdl^^.isreal;			end;	end;{----------------------------------------------------------------------------}	procedure ResetTypeLink (linkH: Handle; typnum, offset: integer; deletion: boolean; var somechanged: boolean);		var			ic: integer;			cell: point;			ctypP: IP;			oldState: SignedByte;	begin		LockHandle(linkH, oldstate);		ctypP := IP(GetMaster(linkH) + offset);		for ic := 1 to numchars do			begin				if ctypP^ = typnum then					begin						ctypP^ := deftype;						somechanged := true;					end				else if (ctypP^ > typnum) and deletion and (ctypP^ <> excluded) then					ctypP^ := ctypP^ - 1;				ctypP := IP(ord4(ctypP) + chtb);			end;		ResetHandle(linkH, oldstate);	end;{----------------------------------------------------------------------------}	procedure SubtractType (typnum: integer; adjustlist: boolean; var deletecell: point);		var			somechanged: boolean;			cell: point;			linkH: Handle;			offset, j: integer;	begin		if typnum <> fisher then			begin				DeleteCHUNKs(typeCHUNKs, typnum, 1);				numtypes := numtypes - 1;				numitems := numitems - 1;				if typnum = deftype then					deftype := unordered;				if typnum = curtype then					curtype := unordered;			end;		if alignmentCostMatrix = typnum then			alignmentCostMatrix := unordered		else if alignmentCostMatrix > typnum then			alignmentCostMatrix := alignmentCostMatrix-1;		somechanged := false;		ResetTypeLink(chtypH, typnum, 0, typnum <> fisher, somechanged);		ResetTypeLink(chstoretypH, typnum, 0, typnum <> fisher, somechanged);		somechanged := false;		linkH := NewHandle(2);		for j := StartUserLink(typesetChain) to EndUserLink(typesetChain) do			begin				GetLink(typesetChain, j, linkH, false);				offset := LinkOffSet(linkH);				ResetTypeLink(linkH, typnum, offset, typnum <> fisher, somechanged);				SetLink(typesetChain, j, linkH);			end;		ZapHandle(linkH);		if somechanged then			Newerror(319, 0);		deletecell := ListCellSelected(typList, false);		if typnum <> fisher then			begin				if adjustlist then					begin						if deletecell.v >= 0 then							LDelRow(1, deletecell.v, typList);						cell.v := 0;						cell.h := 0;						LSetSelect(true, cell, typList);						LAutoScroll(typList);					end;			end		else			ReSetFisher;		CheckCurrentTypes;		goNex7on := nex7on & treeopen;	end;{-----------------------------------------------------------------------------}	procedure CopyTypeSpecs; {(cfrom, cto : char; docopy : boolean);}		var			fromtypeHdl, totypeHdl: typeHandle;	begin		fromtypeHdl := gettypeHdl(cfrom);		totypeHdl := gettypeHdl(cto);		totypeHdl^^.isreal := fromtypeHdl^^.isreal;		totypeHdl^^.dist := fromtypeHdl^^.dist;		totypeHdl^^.max := fromtypeHdl^^.max;		totypeHdl^^.setdefined := fromtypeHdl^^.setdefined;		if docopy then			begin				cliproot := fromtypeHdl^^.root;				if fromtypeHdl^^.root >= 0 then					begin						totypeHdl^^.nbors := fromtypeHdl^^.nbors;						totypeHdl^^.maxstar := fromtypeHdl^^.maxstar;					end;			end		else	{it's a paste}			begin				if showmatrix then					totypeHdl^^.root := -1				else					begin						totypeHdl^^.root := cliproot;						if cliproot >= 0 then							begin								totypeHdl^^.nbors := fromtypeHdl^^.nbors;								totypeHdl^^.maxstar := fromtypeHdl^^.maxstar;							end;					end;			end;	end;{-----------------------------------------------------------------------------}	procedure SetStepMatrixFont;	begin		if typeisreal(CurType) then			begin				textfont(macCladeSmall);				textsize(8);			end		else			begin				textfont(kFontIDMonaco);				textsize(9);			end;	end;{-----------------------------------------------------------------------------}	procedure CalcScrollTypeRect;	begin		scrollTypeRect := specrect;		scrollTypeRect.left := scrollTypeRect.left - 20;		scrollTypeRect.top := scrollTypeRect.top - 20;		scrollTypeRect.bottom := scrollTypeRect.bottom - 1;	end;{-----------------------------------------------------------------------------}	procedure CalcSpecRect (thetype, theleft, thetop: integer; var typeRect: rect);	begin{    typeHdl := gettypeHdl(thetype);}		with typeRect do			begin{$IFC FALSE}				left := theleft + ((maxTypeEditMat - maxdrawmat) * StepCellWidth) div 2;				if printon then					top := theTop				else					top := thetop + ((maxTypeEditMat - maxdrawmat) * StepCellHeight) div 2;				right := left + (maxdrawmat + 1) * StepCellWidth + 1;				bottom := top + (maxdrawmat + 1) * StepCellHeight;{$ENDC}				left := typeBoundaryRect.left + (typeBoundaryRect.right - typeBoundaryRect.left) div 2 - ((maxdrawmat + 1) * StepCellWidth) div 2;				if printon then					top := theTop				else					top := typeBoundaryRect.top + ((maxTypeEditMat - maxdrawmat) * StepCellHeight) div 2;				right := left + (maxdrawmat + 1) * StepCellWidth + 1;				bottom := top + (maxdrawmat + 1) * StepCellHeight;				SetRect(fromB, left - 72, top, left, top + StepCellHeight - 4);				SetRect(toB, left - 25, top - 22, left, top - 6);			end;	end;{----------------------------------------------------------------------------}	function FindStepCellRect (row, col: integer): RECT;		var			B: rect;	begin		B.right := SpecREct.left + (col - hTypeStart + 1) * StepCellWidth;		B.left := B.right - StepCellWidth + 1;		B.bottom := SpecRect.top + (row - vTypeStart + 1) * StepCellHeight;		B.top := B.bottom - StepCellHeight + 1;		FindStepCellRect := B;	end;{----------------------------------------------------------------------------}	function StepCellVisible (stepv, stepH: integer): Boolean;	begin		StepCellVisible := (Stepv >= vTypeStart) and (Stepv <= vTypeStart + maxdrawmat) and (Steph >= hTypeStart) and (Steph <= hTypeStart + maxdrawmat);	end;{----------------------------------------------------------------------------}	procedure InvertStepCellRect (stepv, stepH: integer);	begin		if StepCellVisible(stepv, stepH) then			InvertHiliteRect(FindStepCellRect(Stepv, Steph));	end;{----------------------------------------------------------------------------}	procedure TypeEdited (typHdl: typeHandle);	begin		anyTypeChanged := true;		if typHdl^^.inuse then			typeInUseChanged := true;	end;{----------------------------------------------------------------------------}	function StepCellSel: boolean;		var			isfrom, isto: integer;	begin		StepCellSel := false;		for isfrom := 0 to maxmat do			for isto := 0 to maxmat do				if StepCells^[isfrom, isto] then					begin						StepCellSel := true;						Exit(StepCellSel);					end;	end;{----------------------------------------------------------------------------}	function TypeNumFromList (cell: point): integer;{pass it listcell , it the type number; }{does not work for empty CST's}		var			typeHdl: TypeHandle;			j: integer;			listpos: integer;	begin		if showmatrix then			TypeNumFromList := cell.v + 1		else			begin				j := 0;				listpos := -1;				while (j < numtypes) and (listpos < cell.v) do					begin						j := j + 1;						typeHdl := gettypeHdl(j);						if typeHdl^^.root >= 0 then							listpos := listpos + 1;					end;				TypeNumFromList := j;			end;	end;{----------------------------------------------------------------------------}	function ListCellofType (typNum: integer): integer;{pass it typnumber, it returns the vertical position (0-based)}{in typelist); does not work for empty CST's}		var			typeHdl: TypeHandle;			j: integer;			listpos: integer;	begin		if showmatrix then			ListCellofType := typNum - 1		else			begin				listpos := -1;				for j := 1 to typNum do					begin						typeHdl := gettypeHdl(j);						if typeHdl^^.root >= 0 then							listpos := listpos + 1;					end;				ListCellofType := listpos;			end;	end;end.