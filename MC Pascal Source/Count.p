unit Count;{еееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, Sound, Dialogs, TextEdit, 		QuickDrawText,Lists, ToolUtils, Memory, Fonts, Resources, Scrap,  		Globals, SetLibInterface, UtilLibInterface,  UtilLibInterface, SetLibInterface,  		 MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, StrUtil, BoxUtil, 		 TaxonCHUtil, CharUtil, SetStates, SymbolsNames, TreeUtil, Prohibitions, TypeUtil, 		 Legends, Polycalc, CalcUtil, Calc, CalcTraced, Genchar;	procedure CountChar (ic: integer);	procedure ResetTreeLength;	function CountTree: boolean;	procedure CalculateCIRiChar (ic: integer; wantCI: boolean);	procedure CalculateCIAll;	procedure CalculateRIAll;	procedure ReconstructChars (ist, iend: integer; findmaxforall: boolean);	procedure ReconstructTraced;	procedure TryAllFixes (N: Nptr);{$IFC FALSE}	procedure CalcGrayIndicesImmediately; {$ENDC}{еееееееееееееееееееееее}implementation {е$S Count}{-----------------------------------------------------------------------------}	procedure AcctranDeltran;{FROZEN 3.0}{Performs the ACCTRAN/DELTRAN procedure of Swofford & Maddison 1987.}{Note that it may give different results from PAUP if there is ambiguity at the root;}{I believe PAUP chooses the lower state for ACCTRAN; MacClade leaves the }{ambiguity there (since the original A/D definition allowed it).}{Also will perform the MINSTATE/MAXSTATE optimization for ordered characters,}{ which places the minimum state of each final state set.}{MINSTATE/MAXSTATE reconstruction: This must be an MPR for ordered characters because}{if each of minimum states assigned, must be parsimonious together.  Can't be the case}{that one of node should have state moved to right (i.e. non-minimum), because then by moving other}{nodes away from their minimum can only encourage the first node to stay right; could}{not encourage it to move back left to its minimum, thus in no circumstances could it be}{assigned its minimum, contradicting the fact that the minimum is in mpr-set.}{For Unordered characters the MINSTATE reconstruction is not necessarily MPR; a simple}{counter-example is ((0,(1,(1,0))),(2,(2,1)))   }		procedure inresolve (N: Nptr);			var				ic: integer;				nsts, ancsts, nfinalsts: largestsetchars;		begin			if N <> R then				begin					if not N^.fix then						begin							case resolveoption of								acctran, deltran: 									begin										if resolveoption = deltran then  {deltran; get N^.final to adjust}											Nsts := N^.final										else if resolveoption = acctran then {acctran; get N^.down to adjust}											Nsts := N^.down;										ancsts := N^.anc^.final;  {get final ancestral states; note acctran/deltran not allowed with polytomies}										if (MultipleStatesLg(Nsts)) then											begin {if current state set has multiple states then find states closest to ancestor}							{(used to be that terminal polymorphic not resolved)}												nfinalsts := ClosestInAtoB(nsts, ancsts, typeofchar(i))											end										else											nfinalsts := nsts;  {otherwise just use nsts}									end;								mintran: 									Nfinalsts := [minLg(N^.final)];								maxtran: 									Nfinalsts := [maxLg(N^.final)];							end;							N^.final := nfinalsts {place result in final state set}						end;				end;			if (NodeIsInternal(N)) then				begin					inresolve(N^.lf);					inresolve(N^.rt);				end;		end;	begin		if (typeofchar(i) > ordered) then			NewError(43, i)		else if nullson then			NewError(64, 0)		else			inresolve(R);	end;{###################===COUNTING====###########################################}{-----------------------------------------------------------------------------}{е controls downpass & counting length of character ic of user-defined type}	procedure CountGen (ic: integer; traced: boolean);{FROZEN 3.0}		var			iq, ctyp: integer;			lent: longint;			clenP: LIP;			oldState: SignedByte;	begin		ctyp := TypeOfChar(ic);		GenDownPass(R, ic, traced);  {call downpass for user defined type}{looks through states at root for minimum length}		lent := infinity;		for iq := 0 to MaxStateDefined(ctyp) do			if GenLessThan(R^.gdnst[iq], lent) then				lent := R^.gdnst[iq];  {new minimum found}		if (lent = Infinity) then			NewError(14, ic);		if traced then			isteps := lent		else			begin				LockHandle(chlenH, oldState);				clenP := LIP(GetMaster(chlenH) + chlb * ord4(ic - 1));				clenP^ := lent;				ResetHandle(chlenH, oldState);			end;	end;{-----------------------------------------------------------------------------}{е cycle back up tree to count Dollo chars which can't be }{   counted on downpass}{е steps due to polymorphism counted in SetTaxDnst; all other steps here}{-----------------}	procedure CountDollo (ist, iend: integer; traced: boolean);{This procedure is needed to count Dollo characters because their length cannot be just counted on single}{pass down tree.  Therefore a full reconstruction is needed}		var			nstepsadd: integer;			ic: integer;			clenP: LIP;			ctypP: IP;			stepsadd: longint;			oldstate1, oldstate2: SignedByte;{..........}		procedure CountUpDollo (N: Nptr; ic: integer; ancset1: largestsetchars);{FROZEN 3.0}{goes up the tree, counting the length of a dollo character.  Note that}{it has to resolve equivocal regions as it goes, basically taking the first resolution}{Steps between fixed terminal node and observed states of terminal taxon already}{counted in DownTerminalTraced; steps within polymorphic terminals}{counted in SetStates}			var				Nset1: largestsetchars;		begin			if traced then				Nset1 := N^.final			else				Nset1 := GetStsLargest(N, ic);			if MultipleStatesLg(Nset1) then {resolving ambiguity in state set}				begin					if N = R then						Nset1 := [minLg(Nset1)]  {resolve root to smallest state}					else						Nset1 := ClosestInAtoB(Nset1, ancset1, dollo);  {find closest to state below}				end;			if N <> R then  {calculate distance between state set and ancestral state set}				begin					nstepsadd := minLg(Nset1) - minLg(ancset1);					if nstepsadd > 0 then						stepsadd := stepsadd + nstepsadd					else						stepsadd := stepsadd - nstepsadd;				end;			if NodeIsInternal(N) then				begin					CountUpDollo(N^.lf, ic, Nset1);					CountUpDollo(N^.rt, ic, Nset1);				end;		end;{..........}	begin		if allowCursorChange then SetCursID(11935);		if traced then			begin				stepsadd := 0;				TriplePassTraced(R); {presumed that downpasstraced already done}				CountUpDollo(R, i, []); {character counted}				isteps := isteps + stepsadd; {stepsadd added to length of char (char may already have polymorphism length considered}			end		else			begin				TriplePass(R, ist, iend, dollo); {reconstruct states (presumed that downpass already done); true parameter passed indicates dolloonly}				LockHandle(chtypH, oldstate1);				LockHandle(chlenH, oldstate2);				ctypP := IP(GetMaster(chtypH) + chtb * ord4(ist - 1));				clenp := LIP(GetMaster(chlenH) + chlb * ord4(ist - 1));				for ic := ist to iend do {cycle through characters, counting those that are dollo}					begin						if ctypP^ = dollo then							begin								stepsadd := 0;								CountUpDollo(R, ic, []); {character counted}								clenP^ := clenP^ + stepsadd; {stepsadd added to length of char (char may already have polymorphism length considered}							end;						ctypP := IP(ord4(ctypP) + chtb);						clenp := LIP(ord4(clenP) + chlb);					end;				ResetHandle(chtypH, oldstate1);				ResetHandle(chlenH, oldstate2);			end;		if allowCursorChange then SetCursorToArrow;	end;{-----------------------------------------------------------------------------}	procedure CountFisher (ist, iend: integer; traced: boolean);{This procedure is needed to count Fisher characters because their length cannot be just counted on single}{pass down tree.  Therefore a full reconstruction is needed}		var			nstepsadd: integer;			ic: integer;			clenP: LIP;			ctypP: IP;			stepsadd: longint;			oldstate1, oldstate2: SignedByte;{-------------}		procedure CountUpFisher (N: Nptr; ic: integer; ancst: integer; takencareof: boolean);			var				sendup, nfm: integer;{This procedure goes up the tree, counting the length of a stratigraphic character.  }{Note that it has to resolve equivocal regions as it goes.  It tries to use the minimum state}{allowed at node, counting missing strata when it is forced to move higher}{until it hits an observed taxon fixed as ancestor, in which it skips to highest state}{ reconstructed for the node without the cost of missing strata.}{--ancst is the state assigned to ancestor of N in this resolving process}{-- takencareof indicates whether the crossing of stratum ancst is already accounted for,}{by an ancestor having been fixed there }				Nset1, nfset: largestsetchars;				senduptakencareof, ancsttakencareof: boolean;		begin			ancsttakencareof := takencareof;			senduptakencareof := takencareof;			sendup := ancst;			if BranchExists(N) then				begin					if traced then						Nset1 := N^.final					else						Nset1 := GetStsLargest(N, ic);					if ancsttakencareof and (minLg(Nset1) = ancst) then{if current state can be as low as one already taken care of,}{ must be case of contemporaneous anc/desc therefore say not actually taken care of}						begin							ancsttakencareof := false;							senduptakencareof := false;						end;{measure strata missed between node below to lowest at current node. If lowest at current}{is below highest below, then don't count anything}					if (N <> R) and (minlg(Nset1) > ancst) then						begin							stepsadd := stepsadd + FisherDistance([ancst, minlg(Nset1)], not ancsttakencareof);							ancsttakencareof := true;							senduptakencareof := false; {might be later set to true if fixanc}						end;{Then pass state at current node higher up, using minimum unless fixanc, in which case skip to}{highest}					if N^.fixanc then						begin							sendup := maxLG(Nset1);  {send up to higher nodes the maximum allowed for fixanc node}{Some extra counting is needed to deal with special cases not dealt with above in stepadd}{First, we get the original states observed in the fixanced terminal}{get original states in fixanced to see if missing up to them}							Nfset := GetTaxonStsLargest(TermofFixanc(N)^.name, ic);{senduptakencareof if Nfset is missing because then it can cover any strata, or if}{sendup is part of Nfset, or if Nfset polymorphic and sendup within its range}							senduptakencareof := (MSL in Nfset) | (sendup in Nfset) | (not (UCL in Nfset) & (sendup in SpanLG(Nfset)));  {says whether or not sendup has been accounted for as stratum with fossil}{ancsttakencareof if already taken care of, or if Nfset is missing because then it can cover any strata,}{ or if ancst is part of Nfset, or if Nfset polymorphic and sendup within its range}							ancsttakencareof := (N = R) | (MSL in Nfset) | ancsttakencareof | ((ancst in Nfset) | (not (UCL in Nfset) & (ancst in SpanLG(Nfset))));{Now if the fixanced was uncertain in state, if there were gaps in its possible states (e.g. "0 or 2")}{and if the fixanced internal is reconstructed as spanning this stratigraphic range, then 0 and 2}{can be optimistically viewed as strata with possible observations, but not 1, so we need to}{count the cost for missing these strata.  This is needed also for polymorphic cases, but the }{polymorphic case already had these steps added in settaxdnst, whereas it didn't with}{the uncertain case}							if (ucl in Nfset) & (sendup > ancst) then								begin									stepsadd := stepsadd + FisherDistance([ancst..sendup] * Nfset + [ancst, sendup], not ancsttakencareof);									ancsttakencareof := true;								end;{In case the fixanced terminal did not have any fossils observed deep enough, we had to presume}{it occurred deeper to avoid violating irreversibility at fixancd internal.  Thus we  need to }{suppose it was missing from strata, and therefore we}{add distance from reconstructed fixanc internal to observed base of fixanced terminal}							Nfm := minLg(Nfset);							if not (MSL in Nfset) & (Nfm > sendup) then								stepsadd := stepsadd + FisherDistance([sendup, nfm], not senduptakencareof);{One case will have been missed, that is if we have moved up to sendup but ancst not yet taken care of,}{e.g., if monomorphic 2 fixanced onto branch with uncertain descendants, could be tossup whether}{1 on branch changing to 2 in fixanced, or 2 throughout changed below from 1; won't be counted}{except here}							if (sendup > ancst) and (not ancsttakencareof) and (N <> R) then								stepsadd := stepsadd + FisherDistance([ancst], true);						end {N^.fixanc}					else if N = R then						sendup := maxlg(Nset1) {if not fixanc and at root, send up highest value}					else						sendup := integermax(ancst, minlg(Nset1)); {if not fixanc then send up as new ancst the maximum value allowed}				end;			if NodeIsInternal(N) then				begin					CountUpFisher(N^.lf, ic, sendup, senduptakencareof);					CountUpFisher(N^.rt, ic, sendup, senduptakencareof);				end;		end;{-------------}	begin		if traced then			begin				stepsadd := 0;				TriplePassTraced(R); {presumed that downpasstraced already done}				CountUpFisher(R, i, 0, false); {character counted}				isteps := isteps + stepsadd; {stepsadd added to length of char (char may already have polymorphism length considered}			end		else			begin				TriplePass(R, ist, iend, fisher); {reconstruct states (presumed that downpass already done); true parameter passed indicates dolloonly}				LockHandle(chtypH, oldstate1);				LockHandle(chlenH, oldstate2);				ctypP := IP(GetMaster(chtypH) + chtb * ord4(ist - 1));				clenp := LIP(GetMaster(chlenH) + chlb * ord4(ist - 1));				for ic := ist to iend do {cycle through characters, counting those that are dollo}					begin						if ctypP^ = fisher then							begin								stepsadd := 0;								CountUpFisher(R, ic, 0, false); {character counted}								clenP^ := clenP^ + stepsadd; {stepsadd added to length of char (char may already have polymorphism length considered}							end;						ctypP := IP(ord4(ctypP) + chtb);						clenp := LIP(ord4(clenP) + chlb);					end;				ResetHandle(chtypH, oldstate1);				ResetHandle(chlenH, oldstate2);			end;		if allowCursorChange then SetCursorToArrow;	end;{-----------------------------------------------------------------------------}	procedure CountChar; {ic : integer}{FROZEN 3.0}{Count single character, using non-traced storage}{Called in ChartWCST (conditonaled out), ChartWCalc, charmenu (conditionaled out),}{and MacClade}		var			clenP: LIP;			cpLP: LIP;			clen, cwt: longint;			ctype: integer;			oldstate: SignedByte;	begin		ctype := typeofchar(ic);		if (ctype < usedef) then {if not user-defined, then initialize length with that due to polymorphism}			begin				LockHandle(chlenH, oldstate);				clenp := LIP(GetMaster(chlenH) + chlb * ord4(ic - 1));				clenP^ := CharPolymorphLength(ic);				ResetHandle(chlenH, oldstate);				DownPass(R, ic, ic);				if ctype = dollo then					CountDollo(ic, ic, tracedfalse)				else if ctype = fisher then					CountFisher(ic, ic, tracedfalse);			end		else if ctype = excluded then			NewError(24, ic)		else   {if user-defined, use countGEn; here length initialization not needed}			CountGen(ic, false);	end;{-----------------------------------------------------------------------------}	procedure ResetTreeLength;{FROZEN 3.0}{Resets total length of tree, assuming lengths of characters already calculated}		var			cwtP, cTypP: IP;			clenP: LIP;			ic: integer;			oldstate1, oldstate2, oldstate3: SignedByte;	begin		treelength := 0; {initialized treelength to 0}		LockHandle(chlenH, oldstate1);		LockHandle(chwtH, oldstate2);		LockHandle(chtypH, oldstate3);		clenP := LIP(GetMaster(chlenH));		cwtP := IP(GetMaster(chwtH));		ctypP := IP(GetMaster(chtypH));		for ic := 1 to numchars do			begin				if ctypP^ <> excluded then					if not AddToLength(treelength, clenP^, cwtP^, ctypP^) then						NewError(110, 0);				clenP := LIP(ord4(clenP) + chlb);				cwtP := IP(ord4(cwtp) + chwb);				ctypP := IP(ord4(ctypp) + chtb);			end;		ResetHandle(chlenH, oldstate1);		ResetHandle(chwtH, oldstate2);		ResetHandle(chtypH, oldstate3);	end;{-----------------------------------------------------------------------------}	function CountTree: boolean;{FROZEN 3.0}{Counts treelength, by counting length of characters}{Returns FALSE if overflow occurred during counting}		var			ic, iq: INTEGER;			ctype: integer;			clenP: LIP;			ctypP, cwtP: IP;			clen: longint;			cntr: boolean;			oldstate1, oldstate2, oldstate3: SignedByte;	begin{Note(1200, 90, 5);}{Note(1200, 90, 5);}		if allowCursorChange then setcursor(clockCursor);		cntr := true;{initialize character lengths}		CopyHandles(chpLH, chlenH); {for all characters, initialize lengths to those due to polymorphisms}{recall that chPLH  has 0's for user-defined characters}{count all the characters}		if anytype([unordered, ordered, irreversible, fisher, dollo]) then			Downpass(R, 1, numchars); 	{Do downpass for all chars (except use-def)}		if Anytype([dollo]) then			CountDollo(1, numchars, tracedfalse);    	{Count any Dollo characters}		if Anytype([fisher]) then			CountFisher(1, numchars, tracedfalse);{now will cycle all characters, adding their lengths into treelength}		treelength := 0; {initializing length}		LockHandle(chlenH, oldstate1);		LockHandle(chwtH, oldstate2);		LockHandle(chtypH, oldstate3);		clenP := LIP(GetMaster(chlenH));		cwtP := IP(GetMaster(chwtH));		ctypP := IP(GetMaster(chtypH));		for ic := 1 to numchars do			begin				ctype := ctypP^;				if ctype <> excluded then					begin						if (ctype >= usedef) then   	{Do downpass & counting for user-def chars}							begin								GenDownPass(R, ic, false);								clen := infinity;								for iq := 0 to maxstateDefined(ctype) do  {look through states at root for minimum length}									if GenLessThan(R^.gdnst[iq], clen) then										clen := R^.gdnst[iq];  {new minimum found}								clenP^ := clen;  {store length found}								if (clen = Infinity) then									NewError(14, ic);							end;						if not AddToLength(treelength, clenP^, cwtP^, ctype) then							cntr := false;  {add found length to treelength}					end;				clenP := LIP(ord4(clenP) + chlb);				cwtP := IP(ord4(cwtp) + chwb);				ctypP := IP(ord4(ctypp) + chtb);			end;		ResetHandle(chlenH, oldstate1);		ResetHandle(chwtH, oldstate2);		ResetHandle(chtypH, oldstate3);		countTree := cntr;	end;{-----------------------------------------------------------------------------}	procedure CalculateCIRiChar (ic: integer; wantCI: boolean);{FROZEN 3.0}{for character ic, calculates consistency index or retention index.}{if wantCI=true, then calculate ci}{if false, calculate ri}		var			charHdl: chHdl;			clen: longint;	begin		charHdl := getchhdl(ic);		clen := CharSteps(ic);		if wantCI then			begin				if MinMaxLenLegalChar(ic, minlength) and (clen > 0) then  {if legal to calculate minlength and if length is more than 0}					CharHDL^^.ci := CharHDL^^.minlen / clen  {ci=range/length}				else					CharHDL^^.ci := 0;  {Note: 0 used if ci illegal because minlength can't  be calculated or if length is 0}			end {if legal to calc max and min length and if informative (i.e. maxlen-minlen >0) then calculate ri}		else if MinMaxLenLegalChar(ic, minlength) & MinMaxLenLegalChar(ic, maxlength) then			begin{here check if number of steps is more than required maximum }				if CharHDL^^.maxlen < clen then					begin						NewError(351, ic);						charHDL^^.ri := 0;  {Note: 0 used if ri illegal}					end				else if (CharHDL^^.maxlen - CharHDL^^.minlen > 0) then					charHDL^^.ri := (CharHDL^^.maxlen - clen) / (CharHDL^^.maxlen - CharHDL^^.minlen)				else					charHDL^^.ri := 0;  {Note: 0 used if ri illegal because ri can't  be calculated or if max-minlength is 0}			end		else			charHDL^^.ri := 0;  {Note: 0 used if ri illegal}	end;{-----------------------------------------------------------------------------}	procedure CalculateCIAll;{FROZEN 3.0}{for all characters, calculate consistency index}		var			charHdl: chHdl;			cwtP, ctypP: IP;			clenP: LIP;			nongenlength, clen, cwt, ic: longint;			oldstate1, oldstate2, oldstate3: SignedByte;	begin		if not PleaseOffMinAll & MinMaxLenLegal(false, minlength) then			begin				nongenlength := 0;				LockHandle(chlenH, oldstate1);				LockHandle(chwtH, oldstate2);				LockHandle(chtypH, oldstate3);				ctypP := IP(GetMaster(chtypH));				cwtP := IP(GetMaster(chwtH));				clenP := LIP(GetMaster(chLenH));				for ic := 1 to numchars do					begin						clen := clenP^;						cwt := cwtP^;						charHdl := getchhdl(ic);						if (clen > 0) & MinMaxLenLegalChar(ic, minlength) then							charHdl^^.ci := charHdl^^.minlen / clen  {calculate ci for character}						else							charHdl^^.ci := 0;						if MinMaxLenLegalChar(ic, minlength) then							if not AddToLength(nongenlength, clen, cwt, ctypP^) then								NewError(307, 0); {adding character length into total legal length - nongenlength}						ctypP := IP(ord4(ctypP) + chtb);						cwtP := IP(ord4(cwtP) + chwb);						clenP := LIP(ord4(clenP) + chlb);					end;				ResetHandle(chlenH, oldstate1);				ResetHandle(chwtH, oldstate2);				ResetHandle(chtypH, oldstate3);				if nongenlength > 0 then					ci := minTreeLength / nongenlength  {overall CI calculated}				else					ci := 0.0;			end		else			begin				PleaseOffCI := true;				PleaseOffRIRC := true;				ci := 0.0			end;	end;{-----------------------------------------------------------------------------}	procedure CalculateRIAll;{FROZEN 3.0}{for all characters, calculate retention index}		var			charHdl: chHdl;			cwtP, ctypP: IP;			clenP: LIP;			nongenlength, minlengthrestrict, clen, cwt, ic: longint;			oldstate1, oldstate2, oldstate3: SignedByte;	begin		if (not PleaseOffMinAll) & MinMaxLenLegal(false, minlength) & (not PleaseOffMaxAll) & MinMaxLenLegal(false, maxlength) then			begin				nongenlength := 0;				minlengthrestrict := 0;				LockHandle(chlenH, oldstate1);				LockHandle(chwtH, oldstate2);				LockHandle(chtypH, oldstate3);				ctypP := IP(GetMaster(chtypH));				cwtP := IP(GetMaster(chwtH));				clenP := LIP(GetMaster(chLenH));				for ic := 1 to numchars do					begin						clen := clenP^;						cwt := cwtP^;						charHdl := getchhdl(ic);						if MinMaxLenLegalChar(ic, minlength) & MinMaxLenLegalChar(ic, maxlength) then							begin								if not AddToLength(minlengthrestrict, charHdl^^.minlen, cwt, ctypP^) then									NewError(307, 0); {adding character length into total legal length - nongenlength }								if (charHdl^^.maxlen < clen) then									begin										NewError(351, ic);										charHdl^^.ri := 0;									end								else if (charHdl^^.maxlen - charHdl^^.minlen > 0) then									begin										charHdl^^.ri := (charHdl^^.maxlen - clen) / (charHdl^^.maxlen - charHdl^^.minlen); {calculate ri for character}									end								else									charHdl^^.ri := 0;								if not AddToLength(nongenlength, clen, cwt, ctypP^) then									NewError(307, 0); {adding character length into total legal length - nongenlength}							end						else							charHdl^^.ri := 0;						ctypP := IP(ord4(ctypP) + chtb);						cwtP := IP(ord4(cwtP) + chwb);						clenP := LIP(ord4(clenP) + chlb);					end;				ResetHandle(chlenH, oldstate1);				ResetHandle(chwtH, oldstate2);				ResetHandle(chtypH, oldstate3);				if (maxTreeLength - minlengthrestrict) > 0 then {overall RI calculated}					ri := (maxTreeLength - nongenlength) / (maxTreeLength - minlengthrestrict)				else					ri := 0.0;				if ri < 0.0 then  {if problem with ci because maxlength violated, then assign 0}					ri := 0.0;			end		else			begin				PleaseOffRIRC := true;				ri := 0.0;			end;	end;{-----------------------------------------------------------------------------}	procedure CheckStatesCHARS (maxforall: boolean);{FROZEN 3.0}{This procedure checks reconstructed states to see if they are within bounds (for error checking)}{and to find out what is the maximum state reconstructed (it might not be the same as the maximum}{state observed if  user-defined types reconstruct states higher than observed}{MAXFORALL determines if all characters (1 to numchars) or just i}		type			lgPtr = ^lgsetchars;		var			maxREC, ist, iend: integer;{......}		procedure inCheckStatesCHARS (N: Nptr);			var				ic: integer;				NstsP, taxonstsP: lgPtr;				taxonstsH: Handle;				CtypP: IP;				mxHere: integer;				oldstate1, oldstate2: SignedByte;				temp: lgsetchars; {new for v3.5}		begin			if BranchExists(N) then				begin					LockHandle(N^.stsH, oldstate1);					LockHandle(chtypH, oldstate2);					NstsP := lgPtr(ord4(GetMaster(N^.stsH)) + tcb * ord4(ist - 1));					CtypP := IP(ord4(GetMaster(chtypH)) + chtb * ord4(ist - 1));					for ic := ist to iend do						begin							if ctypP^ <> excluded then								begin									if BitAnd(ord4(NstsP^), -201326592) <> 0 then  {-67108864 for all highbits; -201326592 excluding FTl}					{check to see if NstsP^ has highbits; ok to test if actually 2 byte storage since highbits same}										NewError(322, ic);									if maxbit = 15 then										begin											{v 3.5}											mxhere := MaxLg(set15to31(IP(NstsP)^));																					end									else										mxhere := MaxG(NstsP^);									if mxhere = ERl then										Newerror(321, ic)									else if (CtypP^ >= usedef) or not maxforall then					{generally don't need to check states if all characters since}					{then MOS used as starting point}										begin											if mxhere > maxREC then												maxREC := mxhere;										end									else if mxhere > MOS then										NewError(402, 0);								end;							NstsP := lgPtr(ord4(NstsP) + tcb);							CtypP := IP(ord4(CtypP) + chtb);						end;					ResetHandle(N^.stsH, oldstate1);					ResetHandle(chtypH, oldstate2);				end;			if NodeIsInternal(N) then				begin					inCheckStatesCHARS(N^.lf);					inCheckStatesCHARS(N^.rt);				end			else {need here to check OBSERVED states in terminal taxa}				if not maxforall then {don't need to check maxforall since uses MOS}					begin						mxhere := MaxLg(GetTaxonStsLargest(N^.name, i));						if mxhere > maxREC then							maxREC := mxhere;					end;		end;{......}	begin		if maxforall then {if checking all chars then use Maximum Observed State as starting point}			begin				ist := 1;				iend := numchars;				maxREC := MOS {***}			end		else			begin  {otherwise needs to be calculated}				ist := i;				iend := i;				maxREC := 0; {***}			end;		inCheckStatesCHARS(R);		if maxforall then			maxReconstructedState := maxREC {***}		else			maxReconstructedStatei := maxREC; {***}	end;{-----------------------------------------------------------------------------}	procedure ReconstructChars (ist, iend: integer; findmaxforall: boolean);{FROZEN 3.0}{Does full reconstruction of states in all characters at all nodes.}{PRESUMED that DownPass already done.}{Called in MacClade in response to golist, but also in}{ChartWCalc, in tree cycling}{LaserPrint, when multiple trees printed (1 place)}{ChartMenu, when tree first turned on (THIS I DON'T LIKE)}{CharMenu, in consistency check}		var			ic, ctype: integer;	begin{Note(700, 90, 10);}		ctype := typeofchar(ist);		if (ist = iend) & (ctype = excluded) then			NewError(24, ist);{first call upPass for any unordered and ordered characters}		if ((ist = iend) & (ctype <= ordered)) | ((ist <> iend) & AnyType([unordered, ordered])) then			UpPass(R, ist, iend);{next call TriplePass for any non user-defined characters}		if ((ist = iend) & (ctype <= dollo)) | anytype([unordered, ordered, irreversible, fisher, dollo]) then			TriplePass(R, ist, iend, -1);{call GenUpPass & GenTriplePass for user-defined characters}		if ((ist = iend) & (ctype >= usedef)) | anytype([usedef]) then			for ic := ist to iend do				begin					ctype := typeofchar(ic);					if (ctype >= usedef) and (ctype <> excluded) then						begin							CountGen(ic, false);							GenUpPass(R, ic, false);							GenTriplePass(R, ic, false);						end;				end;{$IFC FALSE}{adjust for ACCTRANDELTRAN if in effect}		if resolveoption <> allpossible then			AcctranDeltran(ist, iend, false);{$ENDC}		CheckStatesCHARS(findmaxforall);{here is updating of maxreconstructedstate. }{It is also an error checking procedure.}{FROZEN 3.0}		if ((traceshown = traceAllChanges) & ((branchlistmode = maxmode) | (branchlistmode = minmaxmode))) then {this is needed to restore bit marking changes}			golist := golist + [brchangesall];	end;{--------------------------------------------------------------------------}	procedure ReconstructTraced;{FROZEN 3.0}{reconstructs states at all nodes for traced character}		var			itype: integer;			prohibitedbits: largestsetchars;{.............}		function CheckFixStates: boolean;{FROZEN 3.0}			var				fixOK: boolean;			procedure InCheckFixStates (N: Nptr);{errorchecking to make sure that only legal states were assigned in fixed states sets}{May occur if type changed to one allowing only lower state values}			begin				if N^.fix & BranchExists(N) then					if N^.fixsts * prohibitedbits <> [] then						fixOK := false;				if NodeIsInternal(N) then					begin						InCheckFixStates(N^.lf);						InCheckFixStates(N^.rt);					end;			end;		begin			fixOK := true;			InCheckFixStates(R);			if not fixOK then				NewError(323, 0);			CheckFixStates := fixOK;		end;{..............}		procedure CheckStates;{FROZEN 3.0}			var				obsmax: integer;			procedure InCheckStates (N: Nptr);{errorchecking to make sure that only legal states were assigned to the state sets}{Also finding maxReconstructedi}			begin				if BranchExists(N) then					begin						if N^.final = [] then							NewError(10, i)						else if N^.final * prohibitedbits <> [] then							NewError(9, i);						if maxLg(N^.final) > maxReconstructedStatei then							maxReconstructedStatei := maxLg(N^.final);					end;				if NodeIsInternal(N) then					begin						InCheckStates(N^.lf);						InCheckStates(N^.rt);					end				else					begin						obsmax := maxLg(GetTaxonStsLargest(N^.name, i));						if obsmax > maxReconstructedStatei then							maxReconstructedStatei := obsmax;					end;			end;		begin			maxReconstructedStatei := 0;			InCheckStates(R);			if maxReconstructedStatei > maxstate then				maxReconstructedStatei := maxstate;		end;{.............}{$IFC DEBUG}		procedure doublecheckreconstruct;			var				clenP: LIP;				oldstate: SignedByte;			procedure InDoublecheck (N: Nptr);{adjust states to down or upstates if }			begin				if BranchExists(N) then					begin						if (itype < USEDEF) & (GetDnstLargest(N, i) <> N^.down) then							INSTANTErrorPLUS(12, 'DOWNPASS STATE');						if ((N <> R) & (NodeIsInternal(N)) & (itype <= ordered)) then							if GetUpstLargest(N, i) <> N^.up then								INSTANTErrorPLUS(12, 'UPPASS STATE');						if GetstsLargest(N, i) <> N^.final then							INSTANTErrorPLUS(12, 'FINAL STATE');					end;				if NodeIsInternal(N) then					begin						InDoublecheck(N^.lf);						InDoublecheck(N^.rt);					end;			end;		begin			LockHandle(chlenH, oldstate);			clenp := LIP(GetMaster(chlenH) + chlb * ord4(i - 1));			clenP^ := CharPolymorphLength(i); {getting polymorphism length}			DownPass(R, i, i);			ReconstructChars(i, i, false);			if itype = fisher then				CountFisher(i, i, tracedfalse) {triplepass not needed since done in CountFisher}			else if itype = dollo then				CountDollo(i, i, tracedfalse);			InDoubleCheck(R);			if (itype <> dollo) and (itype <> fisher) and (isteps <> clenP^) and not fixon then {itype<> dollo since dollo not counted with reconstruct}				INSTANTErrorPLUS(12, 'STEPS');			ResetHandle(chlenH, oldstate);		end;{$ENDC}{.............}	begin		itype := typeofchar(i);		if equivcycle then			pleaseoffequivocal := true;		prohibitedbits := [(charmaxstDEF(i) + 1)..31];		if fixon then			if not CheckFixStates then				OffFix(true)			else if itype = fisher then				begin					NewError(373, 0);					Offfix(true);				end;		case itype of			unordered, ordered: 				begin					DownPassTraced(R);					UpPassTraced(R);					TriplePassTraced(R);				end;			irreversible: 				begin					DownPassTraced(R);					TriplePassTraced(R);				end;			fisher: 				begin					DownPassTraced(R);					CountFisher(i, i, tracedtrue);{triplepass not needed since done in CountFisher}				end;			dollo: 				begin					DownPassTraced(R);					CountDollo(i, i, tracedtrue); {triplepass not needed since done in CountDollo}				end;			otherwise {user-defined type}				begin					CountGen(i, true);					GenUpPass(R, i, true);					GenTriplePass(R, i, true);				end;		end;{$IFC DEBUG}		if dodoublecheck then			if not fixon and (resolveoption = allpossible) then				DoublecheckReconstruct;{$ENDC}		if (resolveoption <> allpossible) then  {do acctran/deltran if in effect}			begin				if itype > ordered then {acctran/deltran not allowed}					begin						NewError(15, 0);						resolveoption := allpossible;{if change resolveoption need to re reconstruct}{FROZEN 3.0}						ChangeAcctranDeltranGoList;					end				else					AcctranDeltran;			end;		CheckStates; { procedure checks legality as well as checks maxreconstructedstatei}	end;{-----------------------------------------------------------------------------}	procedure TryAllFixes (N: Nptr);{FROZEN 3.0}		var			ds, dds: str255;			ifx: integer;			stepsforstate: longint;			oldfixsts: largestsetchars; {.....}		function ConcatStepsForStateString (var ds: str255; ifx: integer; stepsforstate: longint): boolean;			var				ads: str255;		begin			if tracelabelsbyname then				ads := concat(AvailCharStateName(i, ifx), ':   ')			else				ads := concat(CharOfNum(ifx), ':   ');			ads := concat(ads, CharStepsString(stepsforstate, i), chr(13));			if length(ads) + length(ds) > 245 then				begin					if length(ds) <= 250 then						ds := concat(ds, 'etc.');					ConcatStepsForStateString := false;				end			else				begin					ds := concat(ds, ads);					ConcatStepsForStateString := true;				end;		end;{.....}	begin		TWMessage := 'Hold button for list';		writeTWmessageB;		if N^.fix then			oldfixsts := N^.fixsts		else			oldfixsts := [];		if typeofchar(i) < usedef then			begin				N^.fix := TRUE;				fixon := TRUE;				ds := concat('Steps if state fixed', chr(13));				ds := concat(ds, 'State:   Steps:', chr(13));				for ifx := 0 to CharMaxstDef(i) do					if ifx in legendstates then						begin							N^.fixsts := [ifx];							ReconstructTraced;							if not button then								begin									Newerror(372, 0);									leave;								end;							if not ConcatStepsForStateString(ds, ifx, isteps) then								leave;						end;			end		else			begin				N^.fix := false;				ds := concat('Steps if state fixed', chr(13));				ds := concat(ds, 'State:   Steps:', chr(13));				maxdefgen := MaxStateDefined(TypeOfChar(i));				typehdl := getTypeHdl(TypeOfChar(i));				ddist := TypeHdl^^.dist;				ReconstructTraced;				for ifx := 0 to CharMaxstDef(i) do					if ifx in legendstates then						begin							if not button then								begin									Newerror(372, 0);									leave;								end;							if Nodeisterminal(N) then								begin									GenUpCalcNode(N, MaxStateDefined(TypeOfChar(i)), true);									stepsforstate := AddGenDist(GNabove(N, ifx), GNbelow(N, ifx))								end							else if N <> R then								stepsforstate := AddGenDist(GNabove(N^.lf, ifx), AddGenDist(GNabove(N^.rt, ifx), GNbelow(N, ifx)))							else								stepsforstate := N^.gdnst[ifx]; {Root: just use down costs calculated}							if not ConcatStepsForStateString(ds, ifx, stepsforstate) then								leave;						end;			end;		SetCursH(arrowcurs);		popUpStringMenu(wh, ds);{v4: better would be other sort of window, Like BLW}		TWMessage := ' ';		writeTWmessageB;		if oldfixsts = [] then			N^.fix := false		else			begin				N^.fixsts := oldfixsts;				N^.fix := true;			end;		SetFixon;{godraw := true;}		FixStateGoList;		InvalidateWindow(twmesswindow, false);	end;{$IFC FALSE}{-----------------------------------------------------------------------------}	procedure CalcGrayIndicesImmediately; 	begin		if not (CalcCI or CalcRC or CalcRI or showminsteps) then			CalcMinMaxTreeLen(minlength);		if (colorTicksIndexClass in [colorTicksRC, colorTicksRI]) & not (CalcRC | CalcRI | showmaxsteps) then			CalcMinMaxTreeLen(maxlength);		if (not (CalcCI or CalcRC or CalcRI) and (ciall in gomask) and not (riall in gomask)) then			CalculateCIAll;		if (colorTicksIndexClass in [colorTicksRC, colorTicksRI]) & (not (CalcRC | CalcRI) & (riall in gomask)) then			begin				CalculateRIAll;				if (colorTicksIndexClass = colorTicksRC) then					CalculateCIAll;			end;	end; {$ENDC}end.