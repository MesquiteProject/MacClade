unit EditControl;{ееееееееееееееееееееее}interface	uses		QuickDraw,  Types, Events, QuickDrawText, OSUtils, TextUtils, menus, Windows, 		Sound, Dialogs, TextEdit, QuickDrawText,Lists, ToolUtils, Memory, Fonts, 		Resources, Scrap,  Globals, SetLibInterface, UtilLibInterface,  MemoryUtil, CarbonUtil, SimpleUtil, WindowUtil, ErrorUtil, EventUtil, GenUtil, 		StrUtil, BoxUtil, TaxonCHUtil, CharUtil, MenuUtil, 		SymbolsNames, TreeUtil, Fill, SpreadUtil, Footnote, DrawSpread, RowColumn, 		StatesWindow, ScrollSpread, CopyPaste, MCWindows, EditorTools, ToolPalette, MoveData, EditorUndo, 		ConsensusSequences, BlockMoveTool, TrackThumb;	procedure SwitchEditorTransposed;	function PtInEditorTitleCornerRect(wh: point):boolean;	procedure MouseInEdit (Event: EventRecord);		procedure KeyInEdit (theChar: Char);{ееееееееееееееееееееее}implementation {е$S EditControl}{----------------------------------------------------------------------------}	procedure SwitchEditorTransposed;	var oldEditOrigin: point;		oldDRect: rect;		tempi: integer;		success : boolean;	begin		if (interleave | AAAutoTranslationVisible) & not editorTransposed then			begin				if CWarning('Can''t transpose matrix if file is written as interleaved or amino acid translation is displayed. Do you want to cancel interleaving and translation display?', 'Yes', 'No') then					begin						interleave := false;						if editorShowAAwithDNA then							SwitchEditorShowAAWithDNA;					end				else					Exit(SwitchEditorTransposed);			end;		InvertOldCell;  {temporarily revert selection rect to unselected appearance}		editorTransposed := not editorTransposed;		FixTotNums;		oldEditOrigin := editorOrigin;		SetScrollMax;		editorOrigin.v := oldEditOrigin.h;		editorOrigin.h := oldEditOrigin.v;		SetControlValueLong(editorHScroll, editorOrigin.h - 1);		SetControlValueLong(editorVScroll, editorOrigin.v - 1);		OldDREct := editorMatrixRect;		CalcEditorMatrixRect;		tempi := editorSelectionTopLeft.h;		editorSelectionTopLeft.h := editorSelectionTopLeft.v;		editorSelectionTopLeft.v := tempi;		tempi := editorSelectionBotRight.h;		editorSelectionBotRight.h := editorSelectionBotRight.v;		editorSelectionBotRight.v := tempi;		CalcEditorSelectionRect(editorSelectionTopLeft, editorSelectionBotRight);		SetEWClip(noscroll);		SetClip(EWClip);		MovesTE;		if ConsensusSequenceVisible then ReSizeEditorWindow;		if not EqualRect(OldDRect, editorMatrixRect) then			begin				EraseREct(editorBoundaryRect);				DrawCells(true, true,true);			end		else			DrawCells(false, true,true);		myCheckMenuItem(EWDisplayMHdl, EditorTransposedItem, editorTransposed);	end;{----------------------------------------------------------------------------}	procedure ClickInTitleCornerRect (wh: point);	var 	ds: str255;		st,et,sc,ec: integer;{a click in the command region on the upper left of the editorWindow}	begin		ds := concat(StringFromNum(numtaxa), ' taxa', chr(13), StringFromNum(numchars), ' characters', chr(13),'-------',chr(13));		if editorSelected & someDataSel then			begin				CalcSelectedTaxaCharacters(st, et, sc, ec, true);				if singleCell then					ds := concat(ds,'Current selection: ', chr(13), AvailTaxonName(st), ', ', AvailCharName(sc))				else if st = et then					ds := concat(ds,'Current selection: ', chr(13), AvailTaxonName(st), chr(13), 'Characters: ', StringFromNum(sc), '-', StringFromNum(ec))				else if sc = ec then					ds := concat(ds,'Current selection: ', chr(13), 'Taxa: ', StringFromNum(st), '-', StringFromNum(et), chr(13), AvailCharName(sc))				else					ds := concat(ds,'Current selection: ', chr(13), 'Taxa: ', StringFromNum(st), '-', StringFromNum(et), chr(13), 'Characters: ', StringFromNum(sc), '-', StringFromNum(ec))			end		else			ds := concat(ds, 'No data selected');		PopUpStringMenu(wh, ds);	end;{----------------------------------------------------------------------------}	procedure ClickInSpread (Event: EventRecord; whichTool: integer);		var			oldSelCellTL, oldSelCellBR, wh, clickcell: point;			B: rect;			clickTaxon,clickChar: integer;			consensusNumber:integer;			{ st, et, sc, ec: integer;}	begin		if (not Locked(lockData)) then			DeselectAllConsenses;					if not editorSelected then			begin				SetPt(oldSelCellTL, 0, 0);				SetPt(oldSelCellBR, 0, 0);			end		else			begin				oldSelCellTL := editorSelectionTopLeft;				oldSelCellBR := editorSelectionBotRight;			end;		SetEWClip(noscroll);		clickCell := FindCell(Event.where, true, false);		TaxonCharacterFromRowColumn(clickTaxon,clickChar,clickCell.v,clickCell.h);					if CommandDown | AsArrowOnRCNumber(clickTaxon,clickChar,whichTool) then			ToolInDataEditor(arrowT,clickTaxon,clickChar, clickCell, Event)		else			ToolInDataEditor(whichTool,clickTaxon,clickChar, clickCell, Event);									if (not Locked(lockData)) then			DrawFootText(not EqualPt(editorSelectionTopLeft, OldSelCellTL), true);	end;{----------------------------------------------------------------------------}{$IFC EXPANDFEET}	procedure PullNoteBox (wh: point);		var			pt: point;			newLines: integer;	begin		while StillDown do			begin				GetMouse(pt);				FlashHorLine(pt.v, false);			end;		if pt.v > editorFirstRowTop + editorLineWidth + 2 then			begin				newLines := footNoteLines + (wh.v - pt.v) div editorLineWidth;				if newLines < 1 then					NewLines := 1;				if newLines <> footNoteLines then					begin						footNoteLines := newLines;						dirtyfile := true;						AdjustFonts;						ReSizeEditorWindow;					end;			end;	end; {$ENDC}{----------------------------------------------------------------------------}	procedure MoveConsensus(consensusNumber,newConsensusNumber: integer);	var theConsensus, dropConsensus: ConsensusPtr;	begin		theConsensus := Consensus(consensusNumber);		dropConsensus := Consensus(newConsensusNumber);		if (theConsensus <> nil) & (dropConsensus<> nil) & (consensusNumber <> newConsensusNumber) then			begin				if theConsensus^.next <> nil then					theConsensus^.next^.prev := theConsensus^.prev;				if theConsensus^.prev <> nil then					theConsensus^.prev^.next := theConsensus^.next;				if consensusNumber>newConsensusNumber then					begin						if dropConsensus^.prev <> nil then							dropConsensus^.prev^.next := theConsensus;						theConsensus^.prev := dropConsensus^.prev;						dropConsensus^.prev := theConsensus;						theConsensus^.next := dropConsensus;						if newConsensusNumber=1 then {have to reset editorConsensus}							editorConsensus := theConsensus;					end				else if consensusNumber<newConsensusNumber then					begin						if dropConsensus^.next <> nil then							dropConsensus^.next^.prev := theConsensus;						if consensusNumber=1 then {have to reset editorConsensus}							editorConsensus := theConsensus^.next;						theConsensus^.next := dropConsensus^.next;						dropConsensus^.next := theConsensus;						theConsensus^.prev := dropConsensus;					end;			end;	end;{----------------------------------------------------------------------------}	procedure ClickInConsensus(wh: point);	var consensusNumber: integer;		clickTaxon, clickChar, oldSelected,j,newConsensusNumber: integer;		wasSelected,consensusMoved: boolean;		clickCell: point;		newWH: point;	begin		SetEWClip(noscroll);		clickCell := FindCell(wh, true, false);		TaxonCharacterFromRowColumn(clickTaxon,clickChar,clickCell.v,clickCell.h);		ConsensusSequenceFromRowColumn(consensusNumber,clickTaxon);		if (consensusNumber > 0) & (consensusNumber <= editorNumConsensusSequences) then			if dblclick then				begin					if ConsensusDialog(consensusNumber) then						begin							InvalidateWindow(editorWindow, true);							ReSizeEditorWindow;						end;				end			else				begin					if editorNumConsensusSequences > 1 then						begin							repeat								GetMouse(newwh);								if editorTransposed then									FlashVerLine(newwh.h,false)								else									FlashHorLine(newwh.v,false);							until not StillDown;							clickCell := FindCell(newwh, true, false);							TaxonCharacterFromRowColumn(clickTaxon,clickChar,clickCell.v,clickCell.h);							ConsensusSequenceFromRowColumn(NewConsensusNumber,clickTaxon);							consensusMoved := false;							if (newConsensusNumber>0) & (NewConsensusNumber<= editorNumConsensusSequences) & (consensusNumber<> newConsensusNumber) then								begin									consensusMoved:= true;									MoveConsensus(consensusNumber,newConsensusNumber);									consensusNumber := newConsensusNumber;								end;						end;										UnselectAll;					if badcellEntry then						Exit(ClickInConsensus);					wasSelected := SomeConsensusSelected(oldSelected);					if ConsensusSelected(consensusNumber) & not consensusMoved then						SelectConsensus(consensusNumber,false)					else						SelectConsensus(consensusNumber,true);					if consensusMoved then						for j := 1 to editorNumConsensusSequences do								DrawConsensusSequence(j,selectionModeAsIs)					else						begin							if wasSelected then								DrawConsensusSequence(oldSelected,selectionModeAsIs);							DrawConsensusSequence(consensusNumber,selectionModeAsIs);						end;				end;			end;{----------------------------------------------------------------------------}	procedure AdjustRowNameEnd(wh: point);	var oldwh: point;	begin		oldwh := wh;		repeat			GetMouse(wh);			FlashVerLine(wh.h, false);		until not button;		GetMouse(wh);		if oldwh.h <> wh.h then			begin				if (wh.h < editorMinRowNameEnd) then					wh.h := editorMinRowNameEnd				else if (wh.h > editorBoundaryRect.right - 20) then					wh.h := editorBoundaryRect.right - 20;				editorRowNameWidth := wh.h - editorRowNameStart;				if odd(editorRowNameWidth) then					editorRowNameWidth := editorRowNameWidth + 1;				AdjustFonts;				EraseREct(editorBoundaryRect);				ReSizeEditorWindow;			end;	end;{----------------------------------------------------------------------------}	function PtInEditorTitleCornerRect(wh: point): boolean;	begin		PtInEditorTitleCornerRect := PtInRect(wh, editorBoundaryRect) and PtinRect(wh, editorTitleCornerRect) and not (wh.h - editorRowNameEnd > -editorLineSensitivity);	end;	{----------------------------------------------------------------------------}	function MightBeInsertingItem(OandC, comm: boolean; Event: EventRecord; wh: point): boolean;	begin		MightBeInsertingItem := not OandC & not ShiftEvent(Event) & not PtInREct(wh, editorSelectionRect) & (comm | tool^[editorTools,currentTool[editorTools]].behaveAsArrowOnRCNumbers);	end;		{----------------------------------------------------------------------------}	function ReadyToInsertRowColumn(isColumn, contDown: boolean; startwh: point): boolean;	var wh: point;		width: integer;	begin		ReadyToInsertRowColumn:= false;		if not Locked(lockData) then				begin				FullTurnOffSplitMultiFlash;				if isColumn & contDown then					begin						repeat							GetMouse(wh);							FlashVerLine(wh.h, false);							until not StillDown;						width := editorColumnWidth + wh.h-startwh.h;						if (width > 6) & (width<>editorColumnWidth) then							begin								editorColumnWidth := width;								ReSizeEditorWindow;								CheckColumnWidthMenu;								//InvalidateWindow(editorWindow,true);							end;					end				else					ReadyToInsertRowColumn:= true;			end;	end;{----------------------------------------------------------------------------}	procedure MouseInEdit (Event: EventRecord);		var			MyControl, t, amount, oldFSS: integer;			pullrightR, pullDownR: REct;			ds: str255;			oldwh, wh, mypt: point;			wasFootEditing, OandC: boolean;   {true if both option and command keys held down}			st, et, sc, ec: integer;			comm, flashWasOn: boolean;	begin{===== SetUp =====} 		updateHasPriority := true;		SetREct(pulldownR, editorRowNameStart, editorMatrixRect.bottom, editorMatrixRect.right, editorMatrixRect.bottom + editorTitleLineWidth);		SetREct(pullrightR, editorMatrixRect.right, editorTitleLineWidth, editorMatrixRect.right + editorTitleLineWidth, editorMatrixRect.bottom);		wasFootEditing := footediting;		OandC := OptionEvent(Event) and CommandEvent(Event);		comm := CommandEvent(Event);		genericSetPort(editorWindow);		ClipREct(WindowPortRect(editorWindow));		GlobalToLocal(Event.where);		wh := Event.where;		flashWasOn  := editorFlashOn & not flashHidden;		if flashWasOn then			HideFlash;{===== processing mouse location =====}		if PtInEditorTitleCornerRect(wh) then			ClickInTitleCornerRect(wh)		else if PtInRect(wh, editorBoundaryRect) and PtinRect(wh, pullrightR) and not OandC and not ShiftEvent(Event) and not PtInREct(wh, editorSelectionRect) then			begin				FullTurnOffSplitMultiFlash;				if not Locked(lockData) then						PullLeftRight(Event);			end		else if PtInRect(wh, editorBoundaryRect) and PtinRect(wh, pulldownR) and not OandC and not ShiftEvent(Event) and not PtInREct(wh, editorSelectionRect) then			begin				FullTurnOffSplitMultiFlash;				if not Locked(lockData) then						PullUpDown(Event);			end{===== adjust width of rowname box =====}		else if (wh.h > editorRowNameEnd - editorLineSensitivity) and (wh.h < editorRowNameEnd + editorLineSensitivity) and (wh.v < editorMatrixRect.bottom) and (wh.v > editorTitlesWidth) then			begin				FullTurnOffSplitMultiFlash;				AdjustRowNameEnd(wh)			end			{===== in consensus sequences =====}		else if editorShowConsensusSequences &PtInREct(wh, editorMatrixRect)& ((editorTransposed & (wh.h<editorFirstColumnLeft)& (wh.h>editorRowNameEnd))| (not editorTransposed & (wh.v<editorFirstRowTop)& (wh.v>editorTitlesWidth))) then			begin				if not Locked(lockData) then					begin						FullTurnOffSplitMultiFlash;						ClickInConsensus(wh);					end;			end{===== inserting rows and columns =====}		else if (wh.v < editorTitleLineWidth) & ((wh.h - editorRowNameEnd) mod editorColumnWidth < editorLineSensitivity) & (wh.h <= editorMatrixRect.right) & MightBeInsertingItem(OandC,comm,Event,wh) then			begin				if ReadyToInsertRowColumn(true,ControlEvent(Event),wh) then						begin						if wh.h < editorRowNameEnd then							wh.h := editorRowNameEnd + 1;						wh := FindCell(wh, true, false);						PullInsertCols(wh.h);					end;			end		else if (wh.v < editorTitleLineWidth) & (editorColumnWidth - (wh.h - editorRowNameEnd) mod editorColumnWidth < editorLineSensitivity) & (wh.h <= editorMatrixRect.right) & MightBeInsertingItem(OandC,comm,Event,wh) then			begin				if ReadyToInsertRowColumn(true,ControlEvent(Event),wh) then						begin						wh.h := wh.h + editorLineSensitivity;						wh := FindCell(wh, true, false);						PullInsertCols(wh.h);					end;			end		else if (wh.h < editorRowNameStart) & ((wh.v - editorFirstRowTop) mod editorLineWidth < editorLineSensitivity) & (wh.v <= editorMatrixRect.bottom) & MightBeInsertingItem(OandC,comm,Event,wh) then			begin				if ReadyToInsertRowColumn(false,ControlEvent(Event),wh) then						begin						if wh.v < editorFirstRowTop then							wh.v := editorFirstRowTop + 1;						wh := FindCell(wh, true, false);						PullInsertRows(wh.v);					end;			end		else if (wh.h < editorRowNameStart) & (editorLineWidth - (wh.v - editorFirstRowTop) mod editorLineWidth < editorLineSensitivity) & (wh.v <= editorMatrixRect.bottom) & MightBeInsertingItem(OandC,comm,Event,wh) then			begin				if ReadyToInsertRowColumn(false,ControlEvent(Event),wh) then						begin						wh.v := wh.v + editorLineSensitivity;						wh := FindCell(wh, true, false);						PullInsertRows(wh.v);					end;			end{===== in cells =====}		else if PtInRect(wh, editorMatrixRect) then			begin				footediting := false;				if (not Locked(lockData)) | (currentTool[editorTools]=showPictureT)| (currentTool[editorTools]=editorArrowT) then						begin						ClickInSpread(Event, currentTool[editorTools]);					end;			end{===== in selection query rectangle =====}{		else if PtInRect(wh, edSelQueryRect) then			begin				if editorSelected & someDataSel then					begin						CalcSelectedTaxaCharacters(st, et, sc, ec, true);						if singleCell then							PopUpStringMenu(wh, concat('Current selection:', chr(13), AvailTaxonName(st), ', ', AvailCharName(sc)))						else if st = et then							PopUpStringMenu(wh, concat('Current selection:', chr(13), AvailTaxonName(st), chr(13), 'Characters: ', StringFromNum(sc), '-', StringFromNum(ec)))						else if sc = ec then							PopUpStringMenu(wh, concat('Current selection:', chr(13), 'Taxa: ', StringFromNum(st), '-', StringFromNum(et), chr(13), AvailCharName(sc)))						else							PopUpStringMenu(wh, concat('Current selection:', chr(13), 'Taxa: ', StringFromNum(st), '-', StringFromNum(et), chr(13), 'Characters: ', StringFromNum(sc), '-', StringFromNum(ec)))					end				else					PopUpStringMenu(wh, 'No data selected');			end}{===== in autotabs =====}		else if PtInRect(wh, dataTabRightBox) then			begin				autotabright := not autotabright;				if autotabright and autotabdown then					begin						autotabdown := false;						InvertRect(dataTabDownBox);					end;				InvertRect(dataTabRightBox);			end		else if PtInRect(wh, dataTabDownBox) then			begin				autotabdown := not autotabdown;				if autotabright and autotabdown then					begin						autotabright := false;						InvertRect(dataTabRightBox);					end;				InvertRect(dataTabDownBox);			end{===== in editmessagebox =====}		else if PtInRect(wh, editMessagebox) then			PopUpFreeMemory(wh){$IFC EXPANDFEET}		else if PtInRect(wh, notePullR) then			begin				PullNoteBox(wh);			end {$ENDC}{===== in FootText =====}		else if PtInRect(wh, editorFootNoteRect) & foottexton & editorSelected then			begin				if not Locked(lockData) then						begin						TEClick(wh, ShiftEvent(Event), noteTE);						footediting := true;						if not wasfootediting then							HiliteFootNote(true);					end;			end{===== in one of the editorWindow scrollbars =====}		else			begin				MyControl := FindControl(wh, editorWindow, whichControl);				if whichControl = nil then 					begin						if editorSelected then							UnselectAll						else 							DeselectAllConsenses					end				else					case MyControl of						kControlUpButtonPart: 							begin								scrollup := true;								t := myTrackControl(whichControl, wh, ScrollSpreadUpDownUPP);							end;						kControlDownButtonPart: 							begin								scrollup := false;								t := myTrackControl(whichControl, wh, ScrollSpreadUpDownUPP);							end;						kControlPageUpPart: 							begin								if whichControl = editorVScroll then									amount := 1 - editorRows								else									amount := 1 - editorColumns;								if amount = 0 then amount := -1;								repeat									GetMouse(myPt);									if TestControl(whichControl, myPt) = mycontrol then										begin											SetControlValueLong(whichControl, GetControlValueLong(whichControl) + amount);											ScrollEditor(true,nil,true)										end								until not StillDown;							end;						kControlPageDownPart: 							begin								if whichControl = editorVScroll then									amount := editorRows - 1								else									amount := editorColumns - 1;								if amount = 0 then amount := 1;								repeat									GetMouse(myPt);									if TestControl(whichControl, myPt) = mycontrol then										begin											SetControlValueLong(whichControl, GetControlValueLong(whichControl) + amount);											ScrollEditor(true,nil,true)										end								until not StillDown;							end;						kControlIndicatorPart: 							begin	{$IFC TRACKPAGENUMBERS}								TrackFeedbackThumb(whichControl,wh, editorWindow);	{$ELSEC}															t := myTrackControl(whichControl, wh, nil);	{$ENDC}								ScrollEditor(true,nil,true)							end;						otherwise							if editorSelected then								UnselectAll							else DeselectAllConsenses;					end;							end;				FixEditMenu;		if wasfootediting & not footediting then			HiliteFootNote(false);		SetEWClip(noscroll);{    FlushEvents(mDownMask, 0);  prevents override of updating}				if flashWasOn & editorFlashOn then			ShowFlash;	end;{----------------------------------------------------------------------------}	procedure AutoReturnCleanUp;	begin		Beep;		editorSelectionBotRight := editorSelectionTopLeft;		if not trackcell then			begin				SetEWClip(justdata);				SetClip(EWClip);			end;	end;{----------------------------------------------------------------------------}	procedure DoAutoTab (direction: integer);{handles autotabbing}		var			OldSelCell: point;	begin		oldSelCell := editorSelectionTopLeft;		if direction = rightA then			begin				if (editorSelectionTopLeft.h < editorTotalColumns) then					MoveOver(rightA)				else if (editorSelectionTopLeft.v < editorTotalRows) then		{hit end of row}					begin						editorSelectionTopLeft.v := editorSelectionTopLeft.v + 1;						editorSelectionTopLeft.h := 1;						AutoReturnCleanUp;						if not MoveCell(trackcell, oldselcell) then							Exit(DoAutoTab);					end				else					Beep;			end		else if direction = downA then			begin				if (editorSelectionTopLeft.v < editorTotalRows) then					MoveOver(DownA)				else if (editorSelectionTopLeft.h < editorTotalColumns) then					begin						editorSelectionTopLeft.h := editorSelectionTopLeft.h + 1;						editorSelectionTopLeft.v := 1;						AutoReturnCleanUp;						if not MoveCell(trackcell, oldselcell) then							Exit(DoAutoTab);					end				else					Beep;			end;	end;{----------------------------------------------------------------------------}	procedure NudgeBlock (direction: integer);{will nudge the selected block of cells over 1 cell in the direction specified, leaving}{in its wake either gaps if molecular data or missing if non-molecular}		var			it, ic, st, et, sc, ec: integer;			tsts, oldtsts: largestsetchars;			nudgeOK: boolean;			db: boolean;	begin		CalcSelectedTaxaCharacters(st, et, sc, ec, true);		nudgeOK := false;		if molecular then			oldtsts := [MSl, GAl]		else			oldtsts := [MSl];		if ((direction = upA) and (editorSelectionTopLeft.v > 1) and not editorTransposed) or ((direction = leftA) and (editorSelectionTopLeft.h > 1) and editorTransposed) then{== shift to one lower taxon ==}			begin				if CheckIfAllGaps(st-1,st-1,sc,ec,editorToolsTreatMissingAsGaps) | not CWarning('Move will erase nucleotides','Cancel','Move') then					begin						if not StoreCellBlockForUndo(st-1, et, sc, ec, false,false,true) then							Exit(NudgeBlock);						nudgeOK := true;						for it := st to et do							for ic := sc to ec do								begin									tsts := gettaxonstsLargestCase(it, ic);									settaxonstsLargest(it - 1, ic, tsts);								end;						for ic := sc to ec do							settaxonstsLargest(et, ic, oldtsts);						if UpdateAsSensitiveToFirstTaxonChange(st-1) then							MatchCharUpdate(sc, ec);					end;			end		else if ((direction = downA) and (editorSelectionBotRight.v < editorTotalRows) and not editorTransposed) or ((direction = rightA) and (editorSelectionBotRight.h < editorTotalColumns) and editorTransposed) then{== shift to one higher taxon ==}			begin				if CheckIfAllGaps(et+1,et+1,sc,ec,editorToolsTreatMissingAsGaps) | not CWarning('Move will erase nucleotides','Cancel','Move') then					begin						if not StoreCellBlockForUndo(st, et+1, sc, ec, false,false,true) then							Exit(NudgeBlock);						nudgeOK := true;						for it := et downto st do							for ic := sc to ec do								begin									tsts := gettaxonstsLargestCase(it, ic);									settaxonstsLargest(it + 1, ic, tsts);								end;						for ic := sc to ec do							settaxonstsLargest(st, ic, oldtsts);						if UpdateAsSensitiveToFirstTaxonChange(st) then							MatchCharUpdate(sc, ec);					end;			end		else if ((direction = leftA) and (editorSelectionTopLeft.h > 1) and not editorTransposed) or ((direction = upA) and (editorSelectionTopLeft.v > 1) and editorTransposed) then{== shift to one lower character ==}			begin				if CheckIfAllGaps(st,et,sc-1, sc-1,editorToolsTreatMissingAsGaps) | not CWarning('Move will erase nucleotides','Cancel','Move') then					begin						if not StoreCellBlockForUndo (st, et, sc-1, ec, false,false,true) then							Exit(NudgeBlock);						nudgeOK := true;						ShiftCharacters(st,et,sc,ec,1,true,closeGapsNormalMode);					end;			end		else if ((direction = rightA) and (editorSelectionBotRight.h < numchars) and not editorTransposed) or ((direction = downA) and (editorSelectionBotRight.v < numchars) and editorTransposed) then{== shift to one higher character ==}			begin				if CheckIfAllGaps(st,et,ec+1, ec+1,editorToolsTreatMissingAsGaps) | not CWarning('Move will erase nucleotides','Cancel','Move') then					begin						if not StoreCellBlockForUndo(st, et, sc, ec+1, false,false,true) then							Exit(NudgeBlock);						nudgeOK := true;						ShiftCharacters(st,et,sc,ec,1,false,closeGapsNormalMode);					end;			end;		if nudgeOK then			ShiftSelection(direction,1,false)		else			Beep;	end;{----------------------------------------------------------------------------}	procedure ArrowExtendSelection (charcode: integer; toEnd: boolean);{if toEnd is true, then extends all the way to end}		var			box: rect;			wasSingleCell: boolean;			oldSelCellTL, oldSelCellBR: point;	begin		oldSelCellTL := editorSelectionTopLeft;		oldSelCellBR := editorSelectionBotRight;		wasSingleCell := SingleCell;		box := editorSelectionRect;		if charcode = upA then			begin				if toEnd then					editorSelectionTopLeft.v := 1				else if editorSelectionTopLeft.v > 1 then					editorSelectionTopLeft.v := editorSelectionTopLeft.v - 1;			end		else if (charcode = downA) & (editorSelectionBotRight.v > 0) then   {only allow this if not in column titles}			begin				if toEnd then					editorSelectionBotRight.v := editorTotalRows				else if editorSelectionBotRight.v < editorTotalRows then					editorSelectionBotRight.v := editorSelectionBotRight.v + 1;			end		else if charcode = leftA then			begin				if toEnd then					editorSelectionTopLeft.h := 1				else if editorSelectionTopLeft.h > 1 then					editorSelectionTopLeft.h := editorSelectionTopLeft.h - 1;			end		else if (charcode = rightA) & (editorSelectionBotRight.h > 0) then   {only allow this if not in row titles}			begin				if toEnd then					editorSelectionBotRight.h := editorTotalColumns				else if editorSelectionBotRight.h < editorTotalColumns then					editorSelectionBotRight.h := editorSelectionBotRight.h + 1			end;		CalcEditorSelectionRect(editorSelectionTopLeft, editorSelectionBotRight);		if (not EqualPt(OldSelCellTL, editorSelectionTopLeft) or not EqualPt(OldSelCellBR, editorSelectionBotRight)) then  {it has changed}			begin				if wasSingleCell then					begin						SetEWClip(noscroll);						SetClip(EWClip);						CleanOldCell(oldSelCellTL, oldSelCellBR);						if badcellentry then							Exit(ArrowExtendSelection);						DrawFootText(true, true);						EraseRect(editorSelectionRect);						InvalidateWindowRect(editorWindow,editorSelectionRect,false);						SetEWClip(noscroll);					end				else					begin						SetEWClip(justdata);						if editorSelectionRect.right > box.right then   {extending on to right}							begin								if editorSelectionTopLeft.v <= 0 then									SetEWClip(horScroll);								box.left := box.right;								box.right := editorSelectionRect.right;							end						else if editorSelectionRect.left < box.left then  {extending to the left}							begin								if editorSelectionTopLeft.v <= 0 then									SetEWClip(horScroll);								box.right := box.left;								box.left := editorSelectionRect.left;							end						else if editorSelectionRect.top < box.top then  {extending to the top}							begin								if editorSelectionTopLeft.h <= 0 then									SetEWClip(vertScroll);								box.bottom := box.top;								box.top := editorSelectionRect.top;							end						else if editorSelectionRect.bottom > box.bottom then  {extending to the bottom}							begin								if editorSelectionTopLeft.h <= 0 then									SetEWClip(vertScroll);								box.top := box.bottom;								box.bottom := editorSelectionRect.bottom;							end;						SetClip(EWClip);						{DRMnewselect  InvertHiliteRect(box);  }						DrawDataCellsInRect(box,selectionModeAsIs);{DRMnewselect}						SetEWClip(noscroll);					end;				FixEditMenu;			end;	end;{----------------------------------------------------------------------------}	procedure KeyInEdit (theChar: char);		var			charcode, ti, tii, j, consensusNumber: integer;			wh: point;			dotaxa, success, db: boolean;			box: rect;	begin		if Locked(lockdata) then Exit(KeyInEdit);		updateHasPriority := true;		genericSetPort(editorWindow);		charcode := BitAnd(Event.message, charcodemask);{======== escape key hit, go to taxon or char in editor  =========}		{if EscapeChar(chr(charcode)) then			begin				dotaxa := OptionEvent(Event);				SetCursorToArrow;				if dotaxa then					j := GetLongint('Go to taxon number:', 1, 1, numtaxa, success)				else					j := GetLongint('Go to character number:', 1, 1, numchars, success);				if success then					if dotaxa then						ScrollToTaxon(j, true)					else if not dotaxa then						ScrollToChar(j, true)					else						Beep;			end		else}		{======== CapsLock fill selected  =========}{charcode > 31 means must be greater than ASCII 31, which takes care of enter, tab, qd.arrow, etc.}{		 if editorSelected & not SingleCell & (not footediting | not foottexton) & (charcode > 31) & CapsLockEvent(Event) then			FillSelected(theChar)  		else } if editorSelected & (not footediting | not foottexton) & ShiftEvent(Event) & ((charcode = upA) | (charcode = downA) | (charcode = rightA) | (charcode = leftA)) then			begin				ArrowExtendSelection(charCode, OptionEvent(Event));			end		else if SomeConsensusSelected(consensusNumber) then			begin				DestroyConsensus(consensusNumber);				{InvalidateWindow(editorWindow,true);}				ReSizeEditorWindow;			end		else if editorSelected and SingleCell then			if not footediting or not foottexton then{======== in data cell  =========}				begin					if trackcell or (editorSelectionTopLeft.v = 0) or (editorSelectionTopLeft.h = 0) then						ScrolltoSelection(true,true);					if (((charcode = upA) | (charcode = downA)) | (((charcode = rightA) | (charcode = leftA)) & not OnlySingleRowNameSelected)) & not OptionEvent(Event)  then						MoveOver(charcode)					else if (charcode = downA) and OptionEvent(Event) and foottexton then   {popping down to FootTexts}						begin							wh.v := noteTE^^.viewrect.top + 4;							wh.h := noteTE^^.viewrect.right - 4;							ClipREct(WindowPortRect(editorWindow));							TEClick(wh, ShiftEvent(Event), noteTE);							footediting := true;							HiliteFootNote(true);						end{$IFC TRUE}{note: with this commented out, tab and return keys no longer move selection between cells}					else if theChar = char(9) then  		{tab}						if ShiftEvent(Event) then							MoveOver(leftA)						else							begin								if (editorSelectionTopLeft.h = editorTotalColumns) and autotabright and not (OptionEvent(Event) and CommandEvent(Event)) and (editorSelectionTopLeft.v > 0) and (editorSelectionTopLeft.h > 0) then									DoAutoTab(rightA)								else									MoveOver(rightA);							end					else if theChar = char(13) then  	{return}						if ShiftEvent(Event) then							MoveOver(upA)						else							begin								if (editorSelectionTopLeft.v = editorTotalRows) and autotabdown and not (OptionEvent(Event) and CommandEvent(Event)) and (editorSelectionTopLeft.v > 0) and (editorSelectionTopLeft.h > 0) then									DoAutoTab(downA)								else									MoveOver(downA);							end{$ELSEC}					else if (theChar = char(9)) or (theChar = char(13)) then						Beep{$ENDC}					else if (theChar = char(3)) then  	{enter key}						begin							if not OptionEvent(Event) then								begin									CleanOldCell(editorSelectionTopLeft, editorSelectionTopLeft);									editorSelected := false;								end							else if not trackcell then								ScrollToSelection(true,true);						end					else						begin							if (editorSelectionTopLeft.v > 0) and (editorSelectionTopLeft.h > 0) then  {it's a data cell}								dirtymaxst := true							else if (theChar = '_') then								theChar := ' ';							if not trackcell and ((editorSelectionTopLeft.v > 0) and (editorSelectionTopLeft.h > 0)) then  {v3.05: added test for data cell}								begin									SetEWClip(justdata);									SetClip(EWClip);								end;							TEKey(theChar, editorCellTE);   {typing into cell}							SelCellChanged := true;							StoreSelectedSingleCellForUndo;							myEnableItem(EditMHdl, UndoItem);{note these changed may be reversed if illegal, thus datachanged might be false, but we don't consider this}							datachanged := true;							myDisableItem(EditMHdl, CutItem);							myDisableItem(EditMHdl, CopyItem);							myDisableItem(EditMHdl, ClearItem);							if autotabright and not (OptionEvent(Event) and CommandEvent(Event)) and (editorSelectionTopLeft.v > 0) and (editorSelectionTopLeft.h > 0) then								DoAutoTab(rightA)							else if autotabdown and not (OptionEvent(Event) and CommandEvent(Event)) and (editorSelectionTopLeft.v > 0) and (editorSelectionTopLeft.h > 0) then								DoAutoTab(downA);						end;				end{|||||||||||||||| in FootText ||||||||||||||||||||}			else  {we're in the FootText}				begin					if (charcode = upA) and OptionEvent(Event) then   {bouncing back up from footediting}						begin							CellHor(editorSelectionTopLeft.h, ti, tii, true);							Event.where.h := tii - 4;							CellVer(editorSelectionTopLeft.v, ti, tii, true);							Event.where.v := tii - 2;							footediting := false;							HiliteFootNote(false);							ClipREct(WindowPortRect(editorWindow));							ClickInSpread(Event,editorArrowT);						end					else   {we are simply typing into FootText}						begin							if thechar <> chr(13) then								begin									ClipREct(WindowPortRect(editorWindow));									TEKey(theChar, noteTE);									footdirty := true;									dirtyfile := true;									CheckNoteLength;								end							else								Beep;						end;				end{|||||||||||||||| delete key hit with more than one cell selected ||||||||||||||||||||}		else if editorSelected and (charcode = 8) then			db := ClearSelected(true)		else if editorSelected & not SingleCell & ((charcode = upA) | (charcode = downA) | (charcode = rightA) | (charcode = leftA)) & ((currentTool[editorTools]=selectedBlockMoveT)|(currentTool[editorTools]=blockMoveT)) then			NudgeBlock(charcode)		else			Beep;	end;end.