(*	File:		BasicApp.p		Contains:	Basic sample code shell, Carbon API	You may incorporate this sample code into your applications without	restriction, though the sample code has been provided "AS IS" and the	responsibility for its operation is 100% yours.  However, what you are	not permitted to do is to redistribute the source as "Apple Sample Code"	after having made changes. If you're going to re-distribute the source,	we require that you make it clear in the source that the code was	descended from Apple Sample Code, but that you've made changes.	Copyright © 1998-2000 Apple Computer, Inc., All Rights Reserved*)PROGRAM BasicApp;USES  Events , Fonts , GestaltEqu , Menus , QuickDraw , Resources , ToolUtils ,  MacTypes , MacWindows , Sound;{$IFC UNDEFINED TARGET_API_MAC_CARBON}{$SETC TARGET_API_MAC_CARBON := 1}{$ENDC}CONST 	kAboutBox		    = 200	;	rMenuBar		    = 128	;	// Menu Bar	mApple			    = 128	;	// Apple menu	iAbout			    = 1;	mFile			      = 129	;	// File menu 	iNew			      = 1;	iClose			    = 4;	iQuitSeperator	= 10;	iQuit			      = 11;	mEdit			      = 130	;	// Edit menu 	mTest			      = 131	;	// Game menu 	iThis			      = 1;	iThat			      = 2;		FUNCTION QuitAppleEventHandler ( appleEvt : AppleEvent ; reply : AppleEventPtr ; refCon : UInt32 ) : OSErr ;VAR  thisErr : OSErr;  BEGIN  thisErr := noErr;  ExitToShell;  QuitAppleEventHandler := thisErr;END;PROCEDURE initialize;VAR  err          : OSErr;  BEGIN  err := noErr;  InitCursor;  {	err := AEInstallEventHandler ( kCoreEventClass , 	                               kAEQuitApplication,	                               NewAEEventHandlerUPP ( QuitAppleEventHandler ) , 	                               0, 	                               false );}  if ( err <> noErr ) then    ExitToShell;END;PROCEDURE DrawWindow( window : WindowPtr);VAR	tempRect	: Rect;	curPort   : GrafPtr;	newPort   : GrafPtr;BEGIN		GetPort ( curPort );	//SetPort ( GetWindowPort ( window ));	BeginUpdate ( window );	//EraseRect ( GetWindowPortBounds ( window , &tempRect ));	DrawControls ( window );	DrawGrowIcon ( window );	EndUpdate ( window );	SetPort ( curPort );END;PROCEDURE doSomething ;BEGIN  SysBeep ( 2 );END;PROCEDURE DoAboutBox ;VAR  index : DialogItemIndex;BEGIN  index := Alert ( kAboutBox , NIL );END;PROCEDURE MakeMenu();	VAR	menuBar  : Handle		;	menu     : MenuRef		;	response : longint		;	err      : OSErr		;BEGIN		menuBar := GetNewMBar ( rMenuBar );		if ( menuBar <> nil) then		BEGIN			SetMenuBar(menuBar);		//	AppendResMenu(GetMenuHandle(mApple), 'DRVR');			err := Gestalt ( gestaltSystemVersion , response );						if (( err = noErr ) AND ( response >= $00001000 )) THEN			  BEGIN					menu := GetMenuHandle ( mFile );					DeleteMenuItem ( menu , iQuit );					DeleteMenuItem ( menu , iQuitSeperator );			  END;			DrawMenuBar();		END	ELSE	DebugStr('MakeMenu failed');END;PROCEDURE DoMenuCommand ( menuResult : longint );VAR	menuID    : INTEGER		;				// resource ID of selected menu	menuItem  : INTEGER		;			  // item number of selected menuBEGIN		menuID   := HiWrd ( menuResult );	menuItem := LoWrd ( menuResult );		CASE menuID of	  mApple  : BEGIN	              case menuItem OF iAbout : DoAboutBox;	              END;	            END;	            	  mFile   : BEGIN	              case menuItem of iQuit : ExitToShell;	              END;	            END;	  	  mEdit   : BEGIN	            END;	            	  mTest   : BEGIN	              case menuItem of iThis , iThat : DoSomething;	              END;	            END;	END;  HiliteMenu ( 0 );END;PROCEDURE MakeWindow;VAR	wRect     : Rect		  ;	myWindow  : WindowPtr	;  noWindow  : WindowPtr;  BEGIN  noWindow := NIL;	SetRect ( wRect , 50 , 50 , 600 , 200 );		myWindow := NewCWindow ( nil , wRect, 'Hello' , TRUE , zoomNoGrow,   noWindow , true, 0);		if (myWindow <> nil) then	  BEGIN	  END		//SetPort ( GetWindowPort ( myWindow ));	else  DebugStr('NewWindow failed');END;PROCEDURE doEvent ( event : EventRecord );VAR  part     : INTEGER;  hit      : BOOLEAN;  key      : CHAR;  tempRect : rect;  myWindow : WindowPtr;  theErr   : OSErr;  BEGIN  Case event.what of    mouseDown : BEGIN                  part := FindWindow ( event.Where , myWindow );                                    CASE part of                    inMenuBar   : DoMenuCommand ( menuSelect ( event.Where ));                                        inSysWindow : BEGIN                                  END;                                                      inContent   : If ( myWindow <> FrontWindow ) Then                                    SelectWindow ( myWindow );                                                        inDrag      : BEGIN                                    //GetRegionBounds ( GetGrayRgn , @tempRect );                                    DragWindow ( myWindow , event.Where , @tempRect );                                  END;                                                      inGrow      : BEGIN                                  END;                                        inGoAway    : DisposeWindow ( myWindow );                                        inZoomIn    ,                    inZoomOut   : BEGIN                                    Hit := TrackBox ( myWindow , event.Where , part );                                                                        if ( hit ) then                                      begin                                        //SetPort ( GetWindowPort ( myWindow ));            		                                    //EraseRect ( GetWindowPortBounds ( myWindow , @tempRect ));		                                    ZoomWindow ( myWindow , part , true );						                            //InvalWindowRect ( myWindow , GetWindowPortBounds ( myWindow , &tempRect ));	                                      END;                                                                        END;                     END;                  END;                  		keyDown   : BEGIN		            END;		            		autoKey   : BEGIN		              key := chr ( BAND  ( event.Message , charCodeMask ));		              		              if ( BAND ( event.Modifiers , cmdKey ) <> 0 ) THEN		                if ( event.What = keyDown ) THEN		                  doMenuCommand ( MenuKey ( key ));		            END;		            	  activateEvt	            : BEGIN	              END;	              	  upDateEvt : BEGIN	                DrawWindow ( WindowPtr ( event.Message ));	              END;	              	  kHighLevelEvent	            : theErr := AEProcessAppleEvent ( event );	            	  diskEvt   : BEGIN	              END;	END;END;PROCEDURE eventLoop;VAR  gotEvent    : BOOLEAN;  event       : EventRecord;  working     : BOOLEAN;BEGIN  REPEAT    BEGIN      gotEvent := WaitNextEvent ( everyEvent , event , 0 , NIL );            if ( gotEvent ) then        doEvent ( event );    END;  UNTIL FALSE;END;                                  BEGIN  Initialize;  MakeWindow;  MakeMenu;  EventLoop;END.