/* ; general Library for set manipulations *//* ; contains union, intersection, min, max, cardinality and span functions,;[0..9],#1023;;[0..15];#65535;;[0..25];#67108863;[10..15];#64512;[16..31];#-65536;[26..31];#-67108864*/#define set32  unsigned long#define set16  unsigned short#define int16  short#define set09 1023#define set025 67108863/* prototypes */pascal set32 Union2(set32 s2, set32 s1);pascal set32 SubtractSets (set32 s1, set32 s2);pascal set32 Union3 (set32 s1, set32 s2, set32 s3);pascal set32 Intersect2 (set32 s1, set32 s2);pascal set32 Intersect3 (set32 s1, set32 s2, set32 s3);pascal set32 Un3ofInt2 (set32 s1, set32 s2, set32 s3);pascal set32 UnordOperator2 (set32 s1, set32 s2);pascal set32 UnordOperator3 (set32 s1, set32 s2, set32 s3);pascal set32 MakeSet (int16 i);pascal set32 MakeSpan (int16 i, int16 j);pascal set32 SetFromMin (set32 s);pascal set32 AddToSet (set32 s, unsigned int16 i);pascal set32 SubtractFromSet (set32 s, int16 i);pascal unsigned int16 Enset (int16 i, set32 s);pascal set32 ZeroHighBitsLg (set32 s);pascal set32 NewSetFromOld (set32 s);pascal set32 OldSetFromNew (set32 s);pascal int16 MinG (set32 s);pascal int16 MinLg (set32 s);pascal int16 MaxG (set32 s);pascal int16 MaxLg (set32 s);pascal int16 MinP (set32 *sp32, int16 slength);pascal int16 MaxP (set32 *sp32, int16 slength);pascal void MaxMinLg (set32 s, int16 *minL, int16 *maxL);pascal int16 CardG  (set32 s);pascal int16 CardLg  (set32 s);pascal int16 CardP (set32 *s, int16 slength);pascal int16 CardFrom (set32 *s, int16 slength);pascal unsigned int16 MultipleStatesG (set32 s);pascal unsigned int16 MultipleStatesLg (set32 s);pascal unsigned int16 MonomorphG (set32 s);pascal unsigned int16 MonomorphLg (set32 s);pascal set32 Set15to31G (set16 s);  pascal set16 Set31to15S (set32 s);pascal set32 Set15to31 (set16 s);  pascal set16 Set31to15 (set32 s);/*===================================================*/	/*function Union2 (s1, s2: lgsetchars): lgsetchars;		returns union of two 4-byte sets */pascal set32 Union2(set32 s2, set32 s1){ return (s1|s2); }/*===================================================*/	/*function SubtractSets (s1, s2: lgsetchars): lgsetchars; 		returns s1-s2 */pascal set32 SubtractSets (set32 s1, set32 s2){ return(s1 & ~s2); }/*===================================================*/	/*function Union3 (s1, s2, s3: lgsetchars): lgsetchars; 		returns union of three 4-byte sets */pascal set32 Union3 (set32 s1, set32 s2, set32 s3){ return(s1 | s2 | s3); }/*===================================================*/	/*function Intersect2 (s1, s2: lgsetchars): lgsetchars; 		returns intersection of two 4-byte sets */pascal set32 Intersect2 (set32 s1, set32 s2){ return(s1 & s2); }/*===================================================*/	/*function Intersect3 (s1, s2, s3: lgsetchars): lgsetchars;  		returns intersection of three 4-byte sets */pascal set32 Intersect3 (set32 s1, set32 s2, set32 s3){ return(s1 & s2 & s3); }/*===================================================*/	/*function Un3ofInt2 (s1, s2, s3: lgsetchars): lgsetchars;  		returns union of pairwise intersections of three 4-byte sets */pascal set32 Un3ofInt2 (set32 s1, set32 s2, set32 s3){ return((s1 & s2) | (s1 & s3) |(s2 & s3)); }/*===================================================*/	/*function UnordOperator2 (s1, s2: lgsetchars): lgsetchars; */pascal set32 UnordOperator2 (set32 s1, set32 s2){ set32 s;if ((s = (s1 & s2)) == 0) 	s = s1 | s2;return(s); }/*===================================================*/	/*function UnordOperator3 (s1, s2, s3: lgsetchars): lgsetchars; */pascal set32 UnordOperator3 (set32 s1, set32 s2, set32 s3){ set32 s;if ((s = (s1 & s2 & s3)) == 0) 	if ((s = (s1 & s2) | (s1 & s3) |(s2 & s3)) == 0)		 s = s1 | s2 | s3;return(s); }/*===================================================*/	/*function MakeSet (i1: integer): lgsetchars; 		returns set equal to [i1] */pascal set32 MakeSet (int16 i){ return (1 << i);}/*===================================================*/	/*function MakeSpan (i1, i2: integer): lgsetchars;		returns set = [i1..i2] */pascal set32 MakeSpan (int16 i, int16 j){if (i>j)return((~(~0 << (i+1))) & (~0 << j));elsereturn((~(~0 << (j+1))) & (~0 << i));}/*===================================================*/	/*function AddToSet (s1: lgsetchars; i1: integer): lgsetchars;	returns set consisting of union of s1 and [i1] */pascal set32 AddToSet (set32 s, unsigned int16 i){return (s | ((set32)1 << i));}/*===================================================*/	/*function SubtractFromSet (s1: lgsetchars; i1: integer): lgsetchars;	returns set consisting of s1 - [i1] */pascal set32 SubtractFromSet (set32 s, int16 i){return (s & (~((set32)1 << i)));}/*===================================================*/	/*function EnSet (i1: integer; s1: lgsetchars): boolean;;		returns whether or not i1 is in set s1 */pascal unsigned int16 Enset (int16 i, set32 s){if (s & ((set32)1 << i))return(256); /* or ~0*/elsereturn(0);}/*===================================================*/	/*function ZeroHighBitsLg (s1: largestsetchars): largestsetchars;	returns set with high bits zeroed */pascal set32 ZeroHighBitsLg (set32 s){return(s & set025);}	/*===================================================*/	/*function SetfromMin (s1: lgsetchars): lgsetchars;	returns set containing only minimum value of s1	if s1 is empty, returns empty set */pascal set32 SetFromMin (set32 s){s &= set025;if (s == 0 )	return (0);else	{	set32 b=1;	while ((s & b)==0)		b <<= 1;	return b;	}}/*===================================================*/	/*function NewSetFromOld (s1: largestsetchars): lgsetchars;	this function coerces old pascal set into new storage */pascal set32 NewSetFromOld (set32 s){return(s);}/*===================================================*/	/*function OldSetFromNew (s1: lgsetchars): largestsetchars;	coerces new storage set into old pascal set */pascal set32 OldSetFromNew (set32 s){return(s);}/*===================================================*/	/*FUNCTION MinG (s : lgsetchars) : integer; */pascal int16 MinG (set32 s){s &= set025;if (s == 0 ) return (30);else	{ set32 b = 1; int m = 0;	while ((s & b)==0)		{ b <<= 1; m++; } 	return m; }}	/*FUNCTION MinLg (s : largestsetchars) : integer; */	/* 30 is errorvalue */pascal int16 MinLg (set32 s){s &= set025;if (s == 0 )	return (30);else	{	set32 b = 1;	int m = 0;		while ((s & b)==0)		{		b <<= 1;		m++; 		} 	return m;	}}/*===================================================*/	/*FUNCTION MaxG (s : lgsetchars) : integer; */pascal int16 MaxG (set32 s){s &= set025;if (s == 0 ) return (30);else	{ set32 b = 1; int m = 0;	while ((s &= ~b) != 0)		{ b <<= 1; m++;  } 	return m; }}/*===================================================*/	/*FUNCTION MaxLg (s : largestsetchars) : integer;	returns maximum value in s, 30 if empty from 0 to 26	Previously this procedure started at 25 and counted	down until first bit found.  Now it starts from 0 and clears bits	until last bit is cleared */pascal int16 MaxLg (set32 s){s &= set025;if (s == 0 )	return (30);else	{	set32 b = 1;	int m = 0;		while ((s &= ~b) != 0)		{		b <<= 1;		m++; 		} 	return m;	}}/*===================================================*/	/*FUNCTION MaxMinLg (s : largestsetchars, var minL,maxL:integer);	returns min and max values in set, 30 if empty from 0 to 25 */pascal void MaxMinLg (set32 s, int16 *minL, int16 *maxL){int16 min;int16 max;s &= set025;if (s == 0 )	{min = 30; max = 30;}else	{	set32 b = 1;	min = 0;		while ((s & b)==0)  /*finding minimum*/		{		b <<= 1;		min++; 		} 	max = min;	while ((s &= ~b) != 0)		{		b <<= 1;		max++; 		} 	}*minL = min;*maxL = max;}/*===================================================*/	/*FUNCTION MinP (s : ptr; slength: integer) : integer;; for set at address s of length slength (15 or 31), returns minimum value;	or 14/30 if empty */pascal int16 MinP (set32 *sp32, int16 slength){if (slength==15)	{	typedef set16 *ptr16;	set16 s16;	s16 = (*((ptr16) sp32)) & set09;	if (s16 == 0 )		return (14);	else	{		set16 b = 1;		int m = 0;			while ((s16 & b)==0)			{			b <<= 1;			m++; 			} 		return m;	}		}else	{	set32 s32 = (*sp32) & set025;	if (s32 == 0)		return (30);	else		{		set32 b = 1;		int m = 0;			while ((s32 & b)==0)			{			b <<= 1;			m++; 			} 		return m;		}	}}/*===================================================*/	/*FUNCTION MaxP (s : ptr; slength: integer) : integer;; for set starting at s anc of length slength (15 or 31), returns maximum value;	or 14/30 if empty */pascal int16 MaxP (set32 *sp32, int16 slength){if (slength==15)	{	typedef set16 *ptr16;	set16 s16;	s16 = (*((ptr16) sp32)) & set09;	if (s16 == 0 )		return (14);	else	{		set16 b = 1;		int m = 0;			while ((s16 &= ~b) != 0)			{			b <<= 1;			m++; 			} 		return m;	}		}else	{	set32 s32 = (*sp32) & set025;	if (s32 == 0)		return (30);	else		{		set32 b = 1;		int m = 0;			while ((s32 &= ~b) != 0)			{			b <<= 1;			m++; 			} 		return m;		}	}}/*===================================================*/	/*FUNCTION CardP (s : Ptr; slength: integer) : integer;; for set starting at s anc of length slength (15 or 31), returns cardinality */pascal int16 CardP (set32 *s, int16 slength){if (slength==15)        {        typedef set16 *ptr16;        set16 s16;        s16 = (*((ptr16) s)) & set09;        if (s16 == 0 )                return (0);        else                {                int b;                for (b = 0; s16 != 0; s16 >>=1)                        if (s16 & 01)                                b++;                return b;                }        }else        {        set32 s32 = (*s) & set025;        if (s32 == 0 )                return (0);        else                {                int b;                for (b = 0; s32 != 0; s32 >>=1)                        if (s32 & 01)                                b++;                return b;                }        }}	/*===================================================*/	/*FUNCTION CardG (s : lgsetchars) : integer;; returns cardinality of elements 0 to 25 in set */pascal int16 CardG  (set32 s){ s &= set025;if (s == 0 ) return (0);else	{ int b;	for (b = 0; s != 0; s >>=1)		if (s & 01)			b++;	return b; } }/*===================================================*/	/*FUNCTION CardLg (s : largestsetchars) : integer;; returns cardinality of elements 0 to 25 in set; differs; from above CardG only in that it accepts type largestsetchars as argument */pascal int16 CardLg  (set32 s){s &= set025;if (s == 0 )	return (0);else	{	int b;	for (b = 0; s != 0; s >>=1)		if (s & 01)			b++;	return b;	}}//;-------------------------------------------------//; 	FUNCTION CardFrom (sptr: ptr; length: integer) : integer;//; returns cardinality of elements 0 through length of set starting at//; location sptrpascal int16 CardFrom (set32 *s, int16 slength){set32 s32 = (*s);int goon = 1;int b = 0;while (goon){       s32 = (*s);        s++;        {        if (slength <= 32)                {                 for (s32 &= (~0 << (32 - slength)); s32 != 0; s32 >>=1)                        if (s32 & 01)                                b++;                goon = 0;                }        else                {                for (; s32 != 0; s32 >>=1)                        if (s32 & 01)                                b++;                slength -= 32;                }        }        }return (b);}/*===================================================*/	/*FUNCTION MultipleStatesG (s : lgsetchars) : boolean;; returns true if s has more than one element  */pascal unsigned int16 MultipleStatesG (set32 s){if ((s &= set025)==0)	return(0);else{	set32 b = 1;	while ((s & b)==0)  /*finding minimum*/		b <<= 1;	if ((s & ~b) != 0)		return(256); 	else		return(0);}}pascal unsigned int16 MultipleStatesLg (set32 s){if ((s &= set025)==0)	return(0);else{	set32 b = 1;	while ((s & b)==0)  /*finding minimum*/		b <<= 1;	if ((s & ~b) != 0)		return(256); 	else		return(0);}}/*===================================================*/	/*FUNCTION MonomorphG (s : lgsetchars) : boolean;; returns true if s has only one element  */pascal unsigned int16 MonomorphG (set32 s){if ((s &= set025)==0) return(0);else	{ set32 b = 1;	while ((s & b)==0)  /*finding minimum*/		b <<= 1;	if ((s & ~b) == 0) return(256); 	else return(0);}}/*===================================================*/	/*FUNCTION MonomorphLg (s : largestsetchars) : boolean;; returns true if s has only one element  */pascal unsigned int16 MonomorphLg (set32 s){if ((s &= set025)==0)	return(0);else{	set32 b = 1;	while ((s & b)==0)  /*finding minimum*/		b <<= 1;	if ((s & ~b) == 0)		return(256); 	else		return(0);}}//;===========================================================================//;//; 	FUNCTION Set15to31 (s : setchars15) : setchars31//;//; converts a 2 byte setchars into a 4 byte setchars; for use when data//; format is changed//;FROZEN 3.0pascal set32 Set15to31 (set16 s){ set32 shigh = 0;set32 slow = 0;shigh = s;slow = s;return(((shigh << 16) & ~set025)|(slow & set09) );	}//;===========================================================================//;//; 	FUNCTION Set15to31 (s : setchars15) : setchars31//;//; converts a 2 byte setchars into a 4 byte setchars; for use when data//; format is changed//;FROZEN 3.0pascal set32 Set15to31G (set16 s)  { set32 shigh = 0;set32 slow = 0;shigh = s;slow = s;return(((shigh << 16) & ~set025)|(slow & set09) );	}	//;===========================================================================//;; 	FUNCTION Set31to15 (s : setchars31) : setchars15;//; converts a 4 byte setchars into a 2 byte setchars; for use when data//; format is changed//;FROZEN 3.0pascal set16 Set31to15 (set32 s){ set32 slong = ((s & ~set025) >> 16)|(s & set09);set16 sshort = slong;return(sshort);	}pascal set16 Set31to15S (set32 s){ set32 slong = ((s & ~set025) >> 16)|(s & set09);set16 sshort = slong;return(sshort);	}