/* ; down, up, final pass calculations *//*;[0..9],#1023;;[0..15];#65535;;[0..25];#67108863;[10..15];#64512;[16..31];#-65536;[26..31];#-67108864*/#include <stdlib.h>#include <FixMath.h>#include "CCode.h"/*#define set32  unsigned long#define set16  unsigned short#define boolean  unsigned short#define int16  short#define int32  long#define set09 1023#define set025 67108863#define missingbit 0x80000000#define uncertainbit 0x20000000#define gapbit 0x10000000#define missingbit2 0x8000#define gapbit2 0x1000#define uncertainbit2 0x2000 */typedef set32 *set32ptr;typedef set16 *set16ptr;typedef char *charptr;//typedef unsigned short UInt16;/* prototypes */pascal	boolean chariswhite (short ccL); pascal	void  ZeroBlockWords (short *p, long numWords);pascal	void  ZeroBlockLongwords (long *p, long numLongWords);pascal	boolean  charinstringC(short ch, char *s); pascal	boolean  ComparestringC (char *st1, char *st2);pascal	boolean  StringsEqual (char *st1, char *st2, short siglen);pascal	void  sectHandles (short *src, short *dest, long numbytes);pascal	void  UnionHandles (short *src, short *dest, long numbytes);pascal	short CharAtPointer (char *p);pascal	void  ConcatStringChar (char *s, short ch);pascal	void  ContractCHBlock (short newmaxstate, set16 *dest, set32 *source, short numchars);pascal	void  ExpandCHBlock (set32 *dest, set16 *source, short numchars);pascal	long multaddC (long a, long b, long c);pascal 	short lowWord (long a);pascal 	short highWord (long a);pascal	void  SetToCellString (short missing, short gap, short uncertain, short polymorphic, char *symb, char *dest, char *statenames, set32 setc);pascal    	boolean ComparePointers (short *ctypP, char mustbeidentical, char respectcase, char examineexcluded, short nummbytes, set32 *block1, set32 *block2, short numchars, short numMisMatches);//pascal  	boolean ComparePointersFlexible (short *ctypP, char mustbeidentical, char respectcase, char examineexcluded, char ignoreBlock2Gaps, short numMismatches, short nummbytes, set32 *block1, set32 *block2, short block1NumChars, short block2NumChars);pascal	void  GetNodeTokenC (charptr *sourceP,char  *token, char *punctuation, double *branchlength, char *hasbranchlength);pascal 	void StringToRealNumber (char *pStr, double *r);pascal 	boolean HasFileIDFunctions(short yourVRef);pascal	long RandomPosLong (long *seed);	pascal	short RandomInteger (long *seed);	pascal 	long truncateDouble (double x);/*-----------------------------------------------------------------------------*/pascal void PutByte (char *P, long ir, char c);pascal void PutByte (char *P, long ir, char c)	{		P+=ir;		(*P)=c;	}/*-----------------------------------------------------------------------------*/pascal char GetByte (char *P, long ir);pascal char GetByte (char *P, long ir)	{		P+=ir;		return (*P);	}//еееееееееееееееееееееееееееееееееееееееееееееееееее//;===========================================================================//;function lowWord (a: longint): integer//;// returns the lowWord of apascal short lowWord (long a){		return 0xFFFF & a;  }//еееееееееееееееееееееееееееееееееееееееееееееееееее//;===========================================================================//;function highWord (a: longint): integer//;// returns the highWord of apascal short highWord (long a){		return (0xFFFF0000 & a)>>16;  }//еееееееееееееееееееееееееееееееееееееееееееееееееее//;===========================================================================//;function multaddC (n, l,r: longint): longint//;// multiplies b and c together and adds to a,and returns result// if overflows, returns a negative numberpascal long multaddC (long a, long b, long c){if ((b==0)|(c==0))	{return(a);}else	{if (b==1)		return(a+c);	else if (c==1)		return(a+b);	else  		{		long bLow = 0xFFFF & b;  //get lowword of b		long cLow = 0xFFFF & c;  //get lowword of c		long bHigh = (0xFFFF0000 & b)>>16; //get highword of b		long cHigh = (0xFFFF0000 & c)>>16; //get highword of c		long runningtotal;				if (cHigh && bHigh)  //bits in both high words; will overflow			return(-1);		else			{				long runningtotal = bLow*cLow;  // start with both low words				long lowhighmult = bLow*cHigh;				if (0xFFFF0000&lowhighmult) //bits in high word; will overflow					return(-2);				else					{runningtotal+=(lowhighmult<<16);					if (runningtotal<0)						return(-3);					else						{long highlowmult = cLow*bHigh;						if (0xFFFF0000&highlowmult) //bits in high word; will overflow							return(-4);						else							{runningtotal+=(highlowmult<<16);							if (runningtotal<0)								return(-5);							else								{runningtotal+=a;								if (runningtotal<0)									return(-6);								else									return(runningtotal);								}							}						}					}			}		}	}}//=====================================================================//;   ZeroBlockWords    Clears an entire block, moving by words//;//;  p:ptr,numbytes: integerpascal	void  ZeroBlockWords (short *p, long numWords){ 	for (; numWords>0;numWords--)		(*p++)=0;		}//=====================================================================//;   ZeroBlockLongWords    Clears an entire block, moving by long words//;//;  p:ptr,numbytes: integerpascal	void  ZeroBlockLongwords (long *p, long numLongWords){ 	for (; numLongWords>0;numLongWords--)		(*p++)=0;}//=====================================================================// intersects contents of two pointers (NOT HANDLES)pascal	void  sectHandles (short *src, short *dest, long numbytes){	while (numbytes>0)		{		numbytes-=2;		(*dest++)&=(*src++);		}}// =====================================================================// unions contents of two pointers (NOT HANDLES)pascal	void  UnionHandles (short *src, short *dest, long numbytes){	while (numbytes>0)		{		numbytes-=2;		(*dest++)|=(*src++);		}}//; =====================================================================//; function chariswhite (tchar: char): boolean;//;		if not (c in [' ', chr(9), chr(13), ',', ';']) thenpascal boolean chariswhite (short ccL){if ((ccL==32)||(ccL==9)||(ccL==13)||(ccL==10)||(ccL==44)||(ccL==59))	return(257);else	return(0);}//;===================================================//;function charinstringC (ch:char; s: ptr): boolean;pascal	boolean  charinstringC(short ch, char *s){char length=(*s++); // get length byte of stringshort found=0;while ((~found) && (length>0))	{	length--;	if (ch==(*s++))		found=257;	} return (found);}//=====================================================================//	function CharAtPointer (p: ptr): char;pascal	short CharAtPointer (char *p){return (*p);}//;===================================================//;procedure ConcatStringChar (s: ptr//; ch: char)//;pascal	void  ConcatStringChar (char *s, short ch){unsigned char length=(*s);if (length<255)	{(*s)++;  // increment length byte	s+=length+1; // set pointer to end	(*s)=ch;	}}//=====================================================================//; now case insensitivepascal	boolean  ComparestringC (char *st1, char *st2){		char b1=(*st1++);  // get first byte (size)	char b2=(*st2++);  // get first byte (size)	char b;	if (b1 != b2)		return(0);	else		{		if (b1==0)			return(257);		else			{char count=b1;			int keepgoing=1;				while (keepgoing)					{					b1=(*st1++);					b2=(*st2++);					if ((b1==b2)||((b1='_')&&(b2==' '))||((b2='_')&&(b1==' ')))						{count--;						if (count==0)							{							keepgoing=false;							return(257);							}						}					else 						{						if (b1>b2)							{b=b1; b1=b2; b2=b;}						if ((b1<'a')||(b1>'z'))							{							keepgoing=false;							return(0);							}						else							{							b1 += 32;							if (b1!=b2)								{								keepgoing=false;								return(0);								}							else								{count--;								if (count==0)									{									keepgoing=false;									return(257);									}								}							}						}										}			}		}	return(0);}	//=====================================================================//;  function StringsEqual(@str1, @str2: ptr//; siglen: integer):boolean//;//;FROZEN 3.0pascal	boolean  StringsEqual (char *st1, char *st2, short siglen){		char b1=(*st1++);  // get first byte (size)	char b2=(*st2++);  // get first byte (size)	char b;	if ((siglen>b1)||(siglen>b2))		{if (b1 != b2)			return(0);		else			siglen=b1;		}		if (b1==0)		return(257);	else		{		int keepgoing=1;		while (keepgoing)			{			b1=(*st1++);			b2=(*st2++);			if (b1==b2)				{siglen--;				if (siglen==0)					{					keepgoing=false;					return(257);					}				}			else 				{   				if (b1>b2)					{b=b1; b1=b2; b2=b;}  				if (b2==95)  //convert underline to blank;					b2=32;				else if (b1>=64 && b1<=90)  //check to make sure it is a letter					b1 += 32;  //lower case to upper case				if (b1!=b2)					{					keepgoing=false;					return(0);					}				else					{siglen--;					if (siglen==0)						{						keepgoing=false;						return(257);						}					}				}						}		}	return(0);}//;#############################//;pass to comparePointer 2 more booleans: MustBeIdentical, ExamineExcluded}//;if MustBeIdentical is true, then ComparePointer returns true iff all states are absolutely identical,}//;otherwise returns true iff }//;1: states are identical}//;2: one is missing, the other is not}//;4: one and only one is uncertain, and the certain one is a subset of the uncertain one}//;5: they are both uncertain, and the intersection of the two exists }//;if ExamineExcluded is true, then examine all numchars characters//; otherwise, examine only}//;those that are included//; for these purposes, one needs also to pass to ComparePointer a pointer}//;to the character types}//;function ComparePointers (ctypP: ptr, mustbeidentical,respectcase,examineexcluded: boolean//; numbytes: integer//; src, dest: Ptr//; numchars: integer): boolean//;//; numbytes is 2 or 4// еееNOT FULLY TESTEDеееpascal boolean ComparePointers (short *ctypP, char mustbeidentical, char respectcase, char examineexcluded, short nummbytes, set32 *block1, set32 *block2, short numchars, short numMisMatches){short identical = 257;  // if return 257, then the states at the pointers are identical; if 0, they are notshort oldnumchars = numchars;if (nummbytes==4)	{	set32 *taxonA4;	set32 *taxonB4;	taxonA4 = block1;	taxonB4 = block2;	while (numchars>0)		{		set32 setA4=(*taxonA4++);		set32 setB4=(*taxonB4++);		if ((ctypP==0) || ((examineexcluded)||((*ctypP++)!=255)))  // check if examine all or if included			{			if (mustbeidentical)				{if (setA4!=setB4)					{					if ((gapbit & setA4)||(gapbit & setB4))   // one of them has a gap						{						identical=0;						numchars=0; //to stop cycle						}					else if (numMisMatches==0) 						{						identical=0;						numchars=0; //to stop cycle						}					numMisMatches--;					}				}			else//;1: states are identical//;2: one is missing, the other is not//;4: one and only one is uncertain, and the certain one is a subset of the uncertain one//;5: they are both uncertain, and the intersection of the two exists 				{				if (setA4!=setB4)  // no luck so far; not identical					{					if (!((missingbit & setA4)||(missingbit & setB4)))  //no luck so far; neither missing					//if (!(((missingbit & setA4)&!(gapbit & setA4))||((missingbit & setB4)&!(gapbit & setB4))))  //no luck so far; neither missing						{						identical=0;						oldnumchars=numchars;						numchars=0;  // presume we are at end; only resurrect if appropriate intersection found						if (uncertainbit & setA4)							{if (uncertainbit & setB4)  //both uncertain								{if (((~uncertainbit & setA4)&(~uncertainbit & setB4))==0)									{identical=257;									numchars=oldnumchars;}								}							else  //just A uncertain								{if ((setA4&setB4)!=setB4)									{identical=257;									numchars=oldnumchars;}								}							}						else if (uncertainbit & setB4)    //just B uncertain							{if ((setA4&setB4)!=setA4)								{identical=257;								numchars=oldnumchars;}							}						}					else if ((gapbit & setA4)||(gapbit & setB4))   // one of them has a gap						{						//if (numMisMatches==0) 						//	{							identical=0;							numchars=0; //to stop cycle						//	}						//numMisMatches--;						}					}											}			}		numchars--;		}	}else //2 byte sets	{	set16 *taxonA2;	set16 *taxonB2;	taxonA2 = (set16ptr)block1;	taxonB2 = (set16ptr)block2;	while (numchars>0)		{		set16 setA2=(*taxonA2++);  // getting new values		set16 setB2=(*taxonB2++);		if ((ctypP==0) || ((examineexcluded)||((*ctypP++)!=255)))  // check if examine all or if included			{			if (!respectcase)				{				setA2 = ((~altsymbolbit2)& setA2);				setB2 = ((~altsymbolbit2)& setB2);				}			if (mustbeidentical)				{if (setA2!=setB2)					{					if ((gapbit2 & setA2)||(gapbit2 & setB2)) // one has gaps						{						identical=0;						numchars=0; //to stop cycle						}					else if (numMisMatches==0) 						{						identical=0;						numchars=0; //to stop cycle						}					numMisMatches--;					}				}			else//;1: states are identical//;2: one is missing, the other is not//;4: one and only one is uncertain, and the certain one is a subset of the uncertain one//;5: they are both uncertain, and the intersection of the two exists 				{				if (setA2!=setB2)  // no luck so far; not identical					{										if (!((missingbit2 & setA2)||(missingbit2 & setB2)))  //no luck so far; neither missing					//if (!(((missingbit2 & setA2)&!(gapbit2 & setA2))||((missingbit2 & setB2)&!(gapbit2 & setB2))))  //no luck so far; neither missing						{						identical=0;						oldnumchars=numchars;						numchars=0;  // presume we are at end; only resurrect if appropriate intersection found						if (uncertainbit2 & setA2)							{if (uncertainbit2 & setB2)  //both uncertain								{if ((~uncertainbit2 & setA2)&(~uncertainbit2 & setB2)!=0)  // remove uncertainbit from each, then is the remaining intersection non-zero									{identical=257;									numchars=oldnumchars;}								}							else  //just A uncertain								{if ((setA2&setB2)!=0)									{identical=257;									numchars=oldnumchars;}								}							}						else if (uncertainbit2 & setB2)    //just B uncertain							{if ((setA2&setB2)!=0)								{identical=257;								numchars=oldnumchars;}							}						else if (numMisMatches>0)							{							identical=257;							numchars=oldnumchars;							numMisMatches--;							}						}					else if ((gapbit2 & setA2)||(gapbit2 & setB2))   // one of them has a gap						{						//if (numMisMatches==0) 						//	{							identical=0;							numchars=0; //to stop cycle						//	}						//numMisMatches--;						}					}											}			}		numchars--;		}	}return(identical);}//=====================================================================//;	procedure ExpandCHBlock(dest,source: ptr//; numchar: integer)//;pascal	void  ExpandCHBlock (set32 *dest, set16 *source, short numchars){	set32 shigh;	set32 slow;	set16 original;	while (numchars>0)		{original = (*source++);		shigh=original;		slow=original;		(*dest++)=(slow & setbound15L)|((shigh << 16) & ~setbound31);		numchars--;		}}//=====================================================================//;	procedure ContractCHblock(dest,source: ptr//; numchar: integer)//;//; FROZEN 3.0pascal	void  ContractCHBlock (short newmaxstate, set16 *dest, set32 *source, short numchars){	set32 slong;	set16 sshort;	set32 mask;	set32 original;	if (newmaxstate==9)		mask=setbound15L;	else		mask=15;	while (numchars>0)		{original = (*source++);		slong=((original & ~setbound31) >> 16)|(original & mask);		sshort=slong;		if (sshort==0)			sshort = missingbit2;		(*dest++)=sshort;		numchars--;		}}	//=====================================================================//;	procedure SetToCellString(miss,gap,uncert,poly: char//; 31,29,27,25(30,28,26,24)//;						symb,dest,statenames: ptr//; 20,16,12//;						setc: largestsetchars)//; 8pascal	void  SetToCellString (short missing, short gap, short uncertain, short polymorphic, char *symb, char *dest, char *statenames, set32 setc){char *originaldest=dest;  // saving just in casechar count=0;  // count of number of chars in output stringchar notfirst=0;char numsymbols = (*symb++);char c=0;	//char of state namelong usestatenames=1;if (statenames==0) 	usestatenames=0;  //nil passed; don't use statenameselse if ((*statenames)==7)		usestatenames=0;  //no state names; don't use statenames//statenames++;(*dest++)=0;  //initialize length and skip to next placeif (missingbit & setc)  //missing bit set in stateset; use missing or gap symbol	{count=1;	if (gapbit & setc)		(*dest)=gap;	else		(*dest)=missing;	}else  //not missing; find all states in state set	{	char separator;	unsigned long maskbit=1;		if (uncertainbit & setc) separator = uncertain;	else separator = polymorphic;			while (maskbit&setbound31)  //go along bit by bit seeing what is in set		{if ((maskbit) & setc)	//element in set found			{			if (notfirst)	//not first element, thus put separator before state symbol/name				{				(*dest++)=separator;				count++;				}			else notfirst=1;//			if ((usestatenames) & ((c!=7)&&(c!=8)))			if ((usestatenames) & (c!=7))     // NoName is 8;  EndNames is 7				{				c=(*statenames++);	//get first character of next state name				if (c==32)					 c=(*statenames++);					 				while ((c!=7)&&(c!=32)&&(c!=8))					{					if (c==95)						(*dest++)=32;  // put char in;  if underline (95), change to blank					else						(*dest++)=c; // put char in					c=(*statenames++);  //get next char					count++;					}									if (c==7)					{					usestatenames=0;					(*dest++)=(*symb);					count++;					}				else if (c==8)  //nothing for that state name					{					(*dest++)=(*symb);					count++;					}				}			else				{				(*dest++)=(*symb);				count++;				}			}//		else if ((c!=7)&&(c!=8))	//element not in set, but need to skip corresponding statename		else if ((usestatenames) & (c!=7)) 	//element not in set, but need to skip corresponding statename			{				c=(*statenames++);	//get first character of next state name				if (c==32)					 c=(*statenames++);					 				while ((c!=7)&&(c!=32)&&(c!=8))					c=(*statenames++);  //get next char			}		symb++;		maskbit<<=1;		}			}(*originaldest)=count;  //setting length on output string}pascal char IsWhiteSpace(char c);pascal char IsWhiteSpace(char c){	return((c<=32));}//=====================================================================/*pascal void ReadPointerToken(char *P, long *pos, long numbytes, char *T, MagicPtr magic);pascal void ReadPointerToken(char *P, long *pos, long numbytes, char *T, MagicPtr magic){	char count=0;	char *origT = T;	P+= (*pos);  // go to offset	(*T++)='\0';	// initialize to null string;		while (IsWhiteSpace((*P)) & ((*pos)<numbytes))		{P++;		// jump to next char		(*pos)++;  //increment position		}		if ((*pos)<numbytes)		{		while (!IsWhiteSpace((*P)) & ((*pos)<numbytes))			{			(*T++)=(*P++);			count++;			(*pos)++;  //increment position			}		}	(*origT)=count;}//=====================================================================pascal void WritePointerToken(char *P, long *pos, long numbytes, char *T, MagicPtr magic);pascal void WritePointerToken(char *P, long *pos, long numbytes, char *T, MagicPtr magic){	char count;	short *orig = (short *)P;	P+=2;  //skip length bytes	P+= (*pos);  // go to offset	(*orig)+=(*T); // add to length bytes of pointer		for (count=(*T++); count--;  (((*pos)<numbytes) & (count>0)))			{			(*P++)=(*T++);			(*pos)++;  //increment position			}}*///=====================================================================pascal void TransferFromPtrToString(char *dsP, char *P, long numbytes);pascal void TransferFromPtrToString(char *dsP, char *P, long numbytes){	/* first, convert to c string */	char count;	(*dsP++)=numbytes;		for (count = 1; count <= numbytes ; count++)		{			(*dsP++) = (*P++) ;		}}//=====================================================================pascal void StringToRealNumber (char *pStr, double *r){	/* first, convert to c string */	char count;	char L= (*pStr++);	char cStr[256];		for (count = 0; count <= L ; count++)		{			cStr[count] = (*pStr++) ;		}	cStr[++count] = '\0';		/* then, use standard atof library function */	(*r) = atof(cStr);}//=====================================================================#define colon  58#define space  32#define carriagereturn  13#define linefeed  10#define tab  9#define rtparen  41#define lfparen  40#define comma  44#define semicolon  59#define quote  39//=======================char IsTreeWhiteSpace(char c);char IsTreeWhiteSpace(char c){	return((c==space)||(c==carriagereturn)||(c==linefeed)||(c==tab));}//=======================char IsTreePunctuation(char c);char IsTreePunctuation(char c){	return((c==rtparen)||(c==lfparen)||(c==comma)||(c==semicolon)||(c==colon));}//=======================pascal	void  GetNodeTokenC (charptr *sourceP,char  *token, char  *punctuation, double *branchlength, char *hasbranchlength){char *originaltoken=token;char *punc = punctuation;char thischar;long buffer2;short count=0;char adjustForSinglePunc = false;char done=false;charptr source=(*sourceP);  //sourceP is pointer to pointer to characters, since was a VAR(*punc++)=0;  //must zero first byte since Pascal chars are 2 byte(*punc)=0;  //default is null character; unless set, indicates that full token read(*token)=0;  //default is zero length string returned;  unless set, indicates that punctuation only(*branchlength)=0.01; //default(*hasbranchlength) = 0;//assumes sitting at previously dealt with charwhile (IsTreeWhiteSpace(thischar=(*++source)))  //go to first dark character	;if (IsTreePunctuation(thischar)) //a tree punctuation mark	{	(*punc)=thischar;  //put in single char	if (thischar==rtparen)		{while (IsTreeWhiteSpace(thischar=(*++source)))  //go to next dark character			;/* the three lines commented out in the following piece, if reincluded, cause problems	with reading in files with fixanc.  they were commented out just before 4.0b2 was released.*/	//	if (IsTreePunctuation(thischar))  //next is punc, thus back up just before it	//		{			if (thischar!=colon)				{				done=true;				source--;				}	//		}		adjustForSinglePunc=true;		}	else		done=true;	} if (done)   /*done if it was punctuation and is still punctuation, unless that punctuation is a colon */	(*sourceP)=source;  //put new pointer value backelse /* not done if either a taxon name, or the special case of a right parens whose next dark char is not a non-colon punctuation */	{	if (thischar==quote)  //quoted token, thus go to next lone quote		{		char stillgoing=true;		token++;  //go to first char of token		while (stillgoing)			{				while ((thischar=(*++source))!=quote)					{					(*token++)=thischar;					count++;					(*originaltoken)=count; 					}				// we know that thisChar is a quote				if ((thischar=(*++source))!=quote)	//next is not quote,  thus done					{					stillgoing=false;  //was closing quote; effectively not added since count had been decremented					(*originaltoken)=count;  //set length byte					thischar=(*++source); //source++;  //skip second quote, or go to next character					}				else  {   //next IS a quote, therefore grab one and put it into token					(*token++)=thischar;					count++;					(*originaltoken)=count; 					}			}		adjustForSinglePunc=false;		}	else if (!IsTreePunctuation(thischar)) //not quoted token, thus add chars until hit WhiteSpace or punctuation		{token++;		while (!(IsTreeWhiteSpace(thischar)||IsTreePunctuation(thischar)))			{(*token++)=thischar;			count++;			thischar=(*++source);			}		(*originaltoken)=count;  //set length byte		adjustForSinglePunc=false;		}	while (IsTreeWhiteSpace(thischar))  //go to first dark character		{		thischar=(*++source);		adjustForSinglePunc=false;		}	if (thischar==colon)		{char *startlength;		startlength=++token;  //remembering current part of token array; will borrow it to extract number		thischar=(*++source);		while (!(IsTreeWhiteSpace(thischar)||IsTreePunctuation(thischar)))			{			(*token++)=thischar;  //getting number into trail end of token			thischar=(*++source);			}		(*token++)='\0'; //bounding string		(*branchlength)=atof(startlength);		(*hasbranchlength) = 257;		}	else if (adjustForSinglePunc)		source++;	source--;  //back up on source, one to get back to this punctuation/WhiteSpace and one to get back to last token	(*sourceP)=source;  //put new pointer value back	}	}/*	The following are from:|	random.c||	A machine-independent multiplicative congruential pseudorandom number|	generator with associated utility routines.||	Copyright (c) 1991 by David Swofford, Illinois Natural History Survey.||	Implementation notes:||		1.	The types 'Int32' and 'UInt32' should be typedef'd in a header|			file as 32-bit signed and unsigned integers, respectively.||		2.	See comments in function 'RandUni' regarding definition of|			constants 'A' and 'M'.*/typedef long Int32;//typedef unsigned long UInt32;#define	A	397204094L		/* multiplier */#define	M	2147483647L		/* modulus = 2**31 - 1 *//*-------------------------------- Prototypes --------------------------------*/pascal	long RandomPosLong (long *seed);/*--| RandPosLong |----------------------------------------------------------------|| (modified from RandUni of Swofford's PAUP ca. v. 3.1|	Return a pseudorandom number on U(0,2**31 - 1) via the multiplicative|	congruential method:||		x(i) = A * x(i-1) mod (2**31 - 1).||	It is recommended that the multiplier A be set to 397204094.  This is the|	smallest multiplier that performed well in Fishman and Moore's (1982,|	JASA 77:129-136) comprehensive evaluation.  (Smaller multipliers are much|	faster, and may be "good enough" depending on the purpose.)  Do not change|	the multiplier unless you know what you're doing!||	Pass a pointer to an 'Int32' variable containing the previous number in the|	sequence (or the starting seed, if this is the first call).  The seed must|	be greater than 0 and less than 2**31 - 1.  It is up to the caller to make|	sure that the seed falls within these bounds.||	The algorithm used here is based on that of Payne, Rabung, and Bogyo (1969;|	Comm. ACM 12:85-86).||	This routine is portable, so long as a 32-bit integer type is available.  |	(The code can easily be modified, and simplified as well, for machines|	with long's of 64 bits or longer.)  Note that the "overflow" in the|	comments below simply means that the value exceeded 2**31 -1 (but it|	will never exceed 2**32 - 1, so no actual hardware overflow occurs).||	Dave Swofford 9/21/87|  	Modified 1 March 1996 Wayne Maddison to yield random positive integer |	between 0 and 2**31-1;  done by deleting last line of RandUni which had said|	return (double)x / M; and substituting return(x)*/pascal	long RandomPosLong (long *seed){	register UInt32		x, y;#if TARGET_CPU_68K	Int64Bit		Ax;	LongMul(*seed, A, &Ax);		// A * x 	x = Ax.loLong;					// move to register variables 	y = Ax.hiLong;					//	for speed				#else	wide			Ax;	WideMultiply(*seed, A, &Ax);		// A * x 	x = Ax.lo;					// move to register variables 	y = Ax.hi;					//	for speed				#endif				y = (y << 1) | (x >> 31);		// isolate high-order 31 bits 	x = (x << 1) >> 1;				// isolate low-order 31 bits 	x += y;							// x'(i + 1) unless overflows 	if (x & 0x80000000) 			// overflow check 		x -= M;						// deal with overflow 		*seed = x;						// save for next time	return(x);	// return (double)x / M;			// scale to (0,1) 	}//========================================================pascal	short RandomInteger (long *seed){	register UInt32		x, y;	UInt16 q;#if TARGET_CPU_68K	Int64Bit		Ax;	LongMul(*seed, A, &Ax);		// A * x 	x = Ax.loLong;					// move to register variables 	y = Ax.hiLong;					//	for speed				#else	wide			Ax;	WideMultiply(*seed, A, &Ax);		// A * x 	x = Ax.lo;					// move to register variables 	y = Ax.hi;					//	for speed				#endif				y = (y << 1) | (x >> 31);		// isolate high-order 31 bits 	x = (x << 1) >> 1;				// isolate low-order 31 bits 	x += y;							// x'(i + 1) unless overflows 	if (x & 0x80000000) 			// overflow check 		x -= M;						// deal with overflow 		*seed = x;						// save for next time 	q=x;	return(q);	}//========================================================pascal long      truncateDouble (double x){	return((long)x);}/* CODE EXAMPLE #1 */// Testing for PBCatSearch// Assumes inclusion of MacHeaders// prototype your function like this prior to calling itpascal boolean HasFileIDFunctions(short  yourVRef){	HParamBlockRec myHPBRec;	HParmBlkPtr myHPBPtr;	GetVolParmsInfoBuffer VParmsBuf;	OSErr myErr;	myHPBPtr  = &myHPBRec;	myHPBRec.ioParam.ioCompletion = nil;   // no completion routine	myHPBRec.ioParam.ioNamePtr = nil;	myHPBRec.ioParam.ioVRefNum = yourVRef;	myHPBRec.ioParam.ioBuffer = (Ptr)&VParmsBuf;	myHPBRec.ioParam.ioReqCount = sizeof(GetVolParmsInfoBuffer);	myErr = PBHGetVolParms(myHPBPtr, FALSE);	if ( myErr )		return FALSE;	else		{		if (  VParmsBuf.vMAttrib &  bHasFileIDs << 1 )			return TRUE;		else			return FALSE;		}					/*	 bHasBlankAccessPrivileges                          =  4;    {volume supports inherited privileges}           bHasBTreeMgr   =  5;    {reserved}           bHasFileIDs    =  6;    {volume supports file ID functions}           bHasCatSearch  =  7;    {volume supports PBCatSearch}           bHasUserGroupList                          =  8;    {volume supports AFP privileges}           bHasPersonalAccessPrivileges                          =  9;    {local file sharing is enabled}           bHasFolderLock =  10;   {volume supports locking of folders}           bHasShortName  =  11;   {volume supports AFP short names}           bHasDesktopMgr =  12;   {volume supports Desktop Manager}           bHasMoveRename =  13;   {volume supports _MoveRename}           bHasCopyFile   =  14;   {volume supports _CopyFile}           bHasOpenDeny   =  15;   {volume supports shared access modes}           bHasExtFSVol   =  16;   {volume is external file system volume}           bNoSysDir      =  17;   {volume has no system directory}           bAccessCntl    =  18;   {volume supports AFP access control}           bNoBootBlks    =  19;   {volume is not a startup volume}           bNoDeskItems   =  20;   {do not place objects on the desktop}           bNoSwitchTo    =  25;   {do not switch launch to applications}           bTrshOffLine   =  26;   {zoom volume when it is unmounted}           bNoLclSync     =  27;   {don't let Finder change mod. date}           bNoVNEdit      =  28;   {lock volume name}           bNoMiniFndr    =  29;   {reserved; always 1}           bLocalWList    =  30;   {use shared volume handle for window }                                   { list}           bLimitFCBs     =  31;   {limit file control blocks}  */}