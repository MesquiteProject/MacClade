/*	File:		NavigationServicesSupport.c	Copyright:	© 1997-1998 by Apple Computer, Inc., all rights reserved.	This code is originally Apple sample code which has been modified by Ken Beath*/#include <Files.h>#include <Navigation.h>#define dontSaveChanges	3  pascal OSStatus OpenFileDialog(OSType applicationSignature, short numTypes, OSType typeList[]);// Displays the NavGet dialog and returns the selected file location.// To enable multiple document opening through AppleEvents pass NULL as the fileSpec anf fileType. pascal short ConfirmSaveDialog(StringPtr documentName, Boolean quitting);// Displays the save confirmation dialog anmd returns {ok, cancel, dontSaveChanges}   pascal OSStatus SaveFileDialog(StringPtr fileName, OSType filetype, OSType fileCreator,  FSSpec* fileSpec, Boolean* stationery, Boolean* replacing, NavReplyRecord* reply);// Displays the NavPut dialog and returns the selected file location and replacing info.pascal OSStatus CompleteSave(const FSSpec* fileSpec, NavReplyRecord* reply);pascal Boolean MyNavServicesAvailable();// Call this routine after savibg a document passing back the fileSpec and reply returned by SaveFileDialog// This call performs any file tranlation needed and disposes the reply  pascal void MyEventProc(const NavEventCallbackMessage callBackSelector, 						NavCBRecPtr callBackParms, 						NavCallBackUserData callBackUD);// Callback to handle event passing betwwn the navigation dialogs and the applicatio#include <CodeFragments.h>#include <Finder.h>#include <Dialogs.h>#include <LowMem.h>#include <string.h>#include <Processes.h>pascal Boolean MyNavServicesAvailable(){	return NavServicesAvailable();}static Handle NewOpenHandle(OSType applicationSignature, short numTypes, OSType typeList[]){	Handle hdl = NULL;		if ( numTypes > 0 )	{			hdl = NewHandle(sizeof(NavTypeList) + numTypes * sizeof(OSType));			if ( hdl != NULL )		{			NavTypeListHandle open		= (NavTypeListHandle)hdl;						(*open)->componentSignature = applicationSignature;			(*open)->osTypeCount		= numTypes;			BlockMoveData(typeList, (*open)->osType, numTypes * sizeof(OSType));		}	}		return hdl;}static OSStatus NavSendOpenAE(AEDescList list){	OSStatus		err;	AEAddressDesc	theAddress;	AppleEvent		dummyReply;	AppleEvent		theEvent;		theAddress.descriptorType	= typeNull;	theAddress.dataHandle		= NULL;	do {		ProcessSerialNumber psn;		psn.highLongOfPSN = 0;		psn.lowLongOfPSN = kCurrentProcess;				err =AECreateDesc(typeProcessSerialNumber, &psn, sizeof(ProcessSerialNumber), &theAddress);		if ( err != noErr) break;					dummyReply.descriptorType	= typeNull;		dummyReply.dataHandle		= NULL;		err = AECreateAppleEvent(kCoreEventClass, kAEOpenDocuments, &theAddress, kAutoGenerateReturnID, kAnyTransactionID, &theEvent);		if ( err != noErr) break;				err = AEPutParamDesc(&theEvent, keyDirectObject, &list);		if ( err != noErr) break;				err = AESend(&theEvent, &dummyReply, kAENoReply, kAENormalPriority, kAEDefaultTimeout, NULL, NULL);		if ( err != noErr) break;						} while (false);		return err;}pascal OSStatus OpenFileDialog(OSType applicationSignature, short numTypes, OSType typeList[]){	NavReplyRecord		theReply;	NavDialogOptions	dialogOptions;	OSErr				theErr		= noErr;	NavTypeListHandle	openList	= NULL;	NavEventUPP			eventUPP	= NewNavEventUPP(MyEventProc);		NavGetDefaultDialogOptions(&dialogOptions);	dialogOptions.dialogOptionFlags += kNavDontAutoTranslate;	dialogOptions.dialogOptionFlags += kNavNoTypePopup;	dialogOptions.dialogOptionFlags -= kNavAllowPreviews;		BlockMoveData(LMGetCurApName(), dialogOptions.clientName, LMGetCurApName()[0] + 1);		openList = (NavTypeListHandle)NewOpenHandle(applicationSignature, numTypes, typeList);	if ( openList )	{		HLock((Handle)openList);	}		theErr = NavGetFile(NULL, &theReply, &dialogOptions, eventUPP, NULL, NULL, openList, NULL);	DisposeNavEventUPP(eventUPP);		if ( theErr != noErr && theErr != userCanceledErr )	{		// if out of memory then a message will already be shown		if (theErr == memFullErr)			theErr = userCanceledErr;	}		if (theErr == noErr && theReply.validRecord)	{		// Multiple files open: use ApleEvents		theErr = NavSendOpenAE(theReply.selection);		NavDisposeReply(&theReply);	}		if (openList != NULL)	{		HUnlock((Handle)openList);		DisposeHandle((Handle)openList);	}		return theErr;} pascal short ConfirmSaveDialog(StringPtr documentName, Boolean quitting){	OSStatus				theStatusErr 	= noErr;	OSErr 					theErr 			= noErr;	NavAskSaveChangesResult	reply 			= 0;	NavAskSaveChangesAction	action 			= 0;	NavEventUPP				eventUPP		= NewNavEventUPP(MyEventProc);	NavDialogOptions		dialogOptions;	short					result;		if (quitting)		action = kNavSaveChangesQuittingApplication;	else		action = kNavSaveChangesClosingDocument;			BlockMoveData(LMGetCurApName(),dialogOptions.clientName,LMGetCurApName()[0]+1);	BlockMoveData(documentName,dialogOptions.savedFileName,documentName[0]+1);		theErr = NavAskSaveChanges(	&dialogOptions,								action,								&reply,								eventUPP,								NULL);	DisposeNavEventUPP(eventUPP);		// Map reply code to ok, cancel, dontSave	switch (reply)	{		case kNavAskSaveChangesSave:			result = ok;			break;					case kNavAskSaveChangesCancel:			result = cancel;			break;					case kNavAskSaveChangesDontSave:			result = dontSaveChanges;			break;	}		return result;}   pascal OSStatus SaveFileDialog(StringPtr fileName, OSType filetype, OSType fileCreator, 						 FSSpec* fileSpec, 						Boolean* stationery, Boolean* replacing, NavReplyRecord* reply){	NavDialogOptions	dialogOptions;	OSErr				theErr		= noErr;	NavEventUPP			eventUPP	= NewNavEventUPP(MyEventProc);	NavGetDefaultDialogOptions(&dialogOptions);	dialogOptions.dialogOptionFlags |= (stationery != NULL ? kNavAllowStationery : 0);	dialogOptions.dialogOptionFlags += kNavNoTypePopup;	BlockMoveData(fileName, dialogOptions.savedFileName, fileName[0] + 1);	BlockMoveData(LMGetCurApName(), dialogOptions.clientName, LMGetCurApName()[0] + 1);	theErr = NavPutFile(NULL, reply, &dialogOptions, eventUPP, filetype, fileCreator, NULL);	DisposeNavEventUPP(eventUPP);		if (reply->validRecord)	{		// User saved		AEDesc 	resultDesc;		AEKeyword keyword;					// retrieve the returned selection:		theErr = AEGetNthDesc(&reply->selection, 1, typeFSS, &keyword, &resultDesc);		if (theErr == noErr)#if TARGET_API_MAC_CARBON==0			BlockMove(*resultDesc.dataHandle, fileSpec, sizeof(FSSpec));#else			AEGetDescData(&resultDesc, fileSpec, sizeof(FSSpec));#endif		if ( replacing != NULL )			*replacing = reply->replacing;				if ( stationery != NULL )		{			*stationery	= reply->isStationery;		}	}	else	{		// User cancelled		if ( replacing != NULL )			*replacing = false;				if ( stationery != NULL )			*stationery	= false;			theErr = userCanceledErr;	}		return theErr;}pascal OSStatus CompleteSave(const FSSpec*, NavReplyRecord* reply){	OSStatus theErr;		if (reply->validRecord)	{		theErr = NavCompleteSave(reply, kNavTranslateInPlace);	}	theErr = NavDisposeReply(reply);		return theErr;}//// Callback to handle events that occur while navigation dialogs are up but really should be handled by the application//pascal extern void HandleEvent(EventRecord* pEvent); pascal void MyEventProc(const NavEventCallbackMessage callBackSelector, 						NavCBRecPtr callBackParms, 						NavCallBackUserData /*callBackUD*/)// Callback to handle event passing betwwn the navigation dialogs and the applicatio{	if ( callBackSelector == kNavCBEvent )		switch (callBackParms->eventData.eventDataParms.event->what)		{			case updateEvt:				HandleEvent(callBackParms->eventData.eventDataParms.event);				break;		}}