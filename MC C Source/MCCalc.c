#include <stdio.h>#include "CCode.h"#define UNORDERED  1#define ORDERED  2#define IRREVERSIBLE  3#define FISHER  4#define DOLLO  5#define EXCLUDED  255/*#define set32  unsigned long#define set16  unsigned short#define int16  short#define int32  long#define set09 1023#define set025 67108863*/typedef struct chstype *	chStuffPtr;typedef struct chstype {		set32 bools;		set32 sureset, singletons; //{ offsets +0; +4, +8 }		short maxst; //{ offset +12 }} chstype;void setMultistateBit(chStuffPtr ChstuffP); // bset	#7,bools(ChstuffP)	void setMultistateBit(chStuffPtr ChstuffP){	ChstuffP->bools = ChstuffP->bools | (1L<<7);}/*===================================================*/int getMaxState(chStuffPtr ChstuffP); //get maxst(ChstuffP),D4int getMaxState(chStuffPtr ChstuffP){	return ChstuffP->maxst;}/*===================================================*/void addToSureSet(set32 s, chStuffPtr ChstuffP);void addToSureSet(set32 s, chStuffPtr ChstuffP){	ChstuffP->sureset = ChstuffP->sureset | (s);}/*===================================================*/void addToSingletons(set32 s, chStuffPtr ChstuffP);void addToSingletons(set32 s, chStuffPtr ChstuffP){	ChstuffP->singletons = ChstuffP->singletons | (s);}//;=========================================================================== void set16to32 (set16 *s, set32 *r); void set16to32 (set16 *s, set32 *r){ 	set32 shigh = (*s);	set32 slow = shigh;	slow=(slow & setbound15L) ;	shigh=((shigh << 16) & ~setbound31);	(*r)=(shigh|slow);}/*===================================================*/ set16 makeSet2 (short i); set16 makeSet2 (short i){ return (1 << i);}/*===================================================*/ set32 makeSet4 (short i); set32 makeSet4 (short i){ return (1L << i);}/*===================================================*/int min2 (set16 spt);int min2 (set16 spt) {	set16 s=(spt);	s &= setbound15S;	if (s == 0 )		return (14);	else {		set16 b = 1;		int m = 0;		while ((s & b)==0) {			b <<= 1;			m++; 		} 		return m;	}}/*===================================================*/int min4 (set32 spt);int min4 (set32 spt) {	set32 s=(spt);	s &= setbound31;	if (s == 0 )		return (30);	else {		set32 b = 1;		int m = 0;		while ((s & b)==0) {			b <<= 1;			m++; 		} 		return m;	}}/*===================================================*/int max2 (set16 s);int max2 (set16 s){s &= setbound15S;if (s == 0 ) return (14);else	{ set16 b = 1; int m = 0;	while ((s &= ~b) != 0)		{ b <<= 1; m++;  } 	return m; }}/*===================================================*/int max4 (set32 s);int max4 (set32 s){s &= setbound31;if (s == 0 ) 	return (30);else	{ set32 b = 1; int m = 0;	while ((s &= ~b) != 0)		{ b <<= 1; m++;  } 	return m; }}/*===================================================*/	/*function MakeSpan (i1, i2: integer): lgsetchars;		returns set = [i1..i2] */ set16 span2 (short i, short j); set16 span2 (short i, short j){if (i>j)return((~(~0 << (i+1))) & (~0 << j));elsereturn((~(~0 << (j+1))) & (~0 << i));}/*===================================================*/	/*function MakeSpan (i1, i2: integer): lgsetchars;		returns set = [i1..i2] */ set32 span4 (short i, short j); set32 span4 (short i, short j){if (i>j)return((~(~0L << (i+1))) & (~0L << j));elsereturn((~(~0L << (j+1))) & (~0L << i));}/*===================================================*/ unsigned int16 bitPresent2 (set16 source, short i); unsigned int16 bitPresent2 (set16 source, short i){if (source & (1 << i))	return (257);else	return (0);}/*===================================================*/ unsigned int16 bitPresent4 (set32 source, short i); unsigned int16 bitPresent4 (set32 source, short i){if (source & (1L << i))	return (257);else	return (0);}/*===================================================*/ set16 clearBit2 (set16 source, short i); set16 clearBit2 (set16 source, short i){ return (source & ~(1 << i));}/*===================================================*/ set32 clearBit4 (set32 source, short i); set32 clearBit4 (set32 source, short i){ return (source & ~(1L << i));}/*===================================================*/ set16 clearHighBits2 (set16 source); set16 clearHighBits2 (set16 source){ return (source & setbound15S);}/*===================================================*/ set32 clearHighBits4 (set32 source); set32 clearHighBits4 (set32 source){ return (source & setbound31);}/*===================================================*/	/*FUNCTION CardG (s : lgsetchars) : integer;; returns cardinality of elements 0 to 25 in set */ int card2  (set16 s); int card2  (set16 s){ s &= setbound15S;if (s == 0 ) return (0);else	{ int b;	for (b = 0; s != 0; s >>=1)		if (s & 01)			b++;	return b; } }/*===================================================*/	/*FUNCTION CardG (s : lgsetchars) : integer;; returns cardinality of elements 0 to 25 in set */ int card4  (set32 s); int card4  (set32 s){ s &= setbound31;if (s == 0 ) return (0);else	{ int b;	for (b = 0; s != 0; s >>=1)		if (s & 01)			b++;	return b; } }//еееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее//===========================================================================//===========================================================================//// 	procedure STaxonDASM////		(numbytes: integer// NdnstP, ctypP, cpLP, ChstuffP: chStuffPtr// ichars: integer)//// This is the procedure which sets the downstates for the terminal taxa,// based on the taxon storage which has already been placed in NdnstP// Determines sets only for UNORDERED, ORDERED, IRREVERSIBLE, AND FISHER characters//    (excluded characters: sets downset to [])// Increments length only for UNORDERED, ORDERED, and IRREVERSIBLE characters//  // auxilliary functions://  for all included characters//			- cuts out footnote and footpict bits//			- records whether or not the character has a taxon with multiple states//  for unord, ord, irrev and fisher characters://			- calculates suresets and singletons (for dollo & user-def not needed)// //pascal void STaxonC(int numbytes, Ptr NdnstP, short *ctypP, long *cpolymLP, chStuffPtr ChstuffP, int ichars);pascal void STaxonC(int numbytes, Ptr NdnstP, short *ctypP, long *cpolymLP, chStuffPtr ChstuffP, int ichars){if (numbytes == 2) {	//TWO BYTE SETTAXONDOWNSTATES ========еееееееееееее	int ic;	set16* NdnstP2 = (set16*)NdnstP;	for (ic = 0; ic< ichars; ic++) {		short currentType;		set16 tempSet;		currentType = (*ctypP);		if (currentType == EXCLUDED) {			(*NdnstP2) = 0;		}		else {			set16 currentSet = (*NdnstP2);			//printf(" SetTax currentSetINIT %i\n", currentSet);			currentSet = clearBit2(currentSet, 10);			currentSet = clearBit2(currentSet, 11);			if (currentType >= DOLLO) { //DOLLOR OR USER DEFINED; need only check if multistate				(*NdnstP2) = currentSet; //simply return same set with footnote and footpict bits cut out				tempSet = clearHighBits2(currentSet);				if (tempSet!=0 && card2(tempSet)>1) {					setMultistateBit(ChstuffP); // bset	#7,bools(ChstuffP)						} //otherwise go to next character			}			else { //unordered, ordered, irreversible			//printf(" SetTax currentSet %i\n", currentSet);				if (bitPresent2(currentSet, 15)) { //missing data					int maxState = getMaxState(ChstuffP); //get maxst(ChstuffP),D4					currentSet= span2(0, maxState);		//set dnst to [0..maxst(ChstuffP)]					(*NdnstP2) = currentSet;				}				else { //not missing					if (!bitPresent2(currentSet, 13)) { //not uncertain 						set32 bigSet;						// if monomorphic or polymorphic add to set of surestates						tempSet = clearHighBits2(currentSet);						set16to32(&tempSet, &bigSet);						addToSureSet(bigSet, ChstuffP);					}					if (currentType==UNORDERED) {						//UNORDERED ==========						if (bitPresent2(currentSet, 13)) {							setMultistateBit(ChstuffP);  //bset	#7,bools(ChstuffP)	//set multistate bit								currentSet = clearHighBits2(currentSet);							(*NdnstP2) = currentSet;						}						else {							int card;								// add to polymorphism length count, if any							currentSet = clearHighBits2(currentSet);							card = card2(currentSet);							(*cpolymLP) += card-1;							if (card>1) 								setMultistateBit(ChstuffP);  //bset	#7,bools(ChstuffP)	//set multistate bit								else								addToSingletons(currentSet, ChstuffP);							(*NdnstP2) = currentSet;						}					}					else {						//ORDERED,IRREV,FISHER ========						tempSet = clearHighBits2(currentSet);						if (tempSet == 0) {							(*NdnstP2) = makeSet2(14);  //return set with error bit since set is empty						}						else {							int min = min2(tempSet);							int max = max2(tempSet);							if (min == max) { //singleton								addToSingletons(tempSet, ChstuffP);								(*NdnstP2) = tempSet;							}							else {								setMultistateBit(ChstuffP);  //bset	#7,bools(ChstuffP)	//set multistate bit									if (currentType== ORDERED) {									//ORDERED ============									if (!bitPresent2(currentSet, 13))  // not UC, therefore poly, therefore add length										(*cpolymLP) += max-min;									(*NdnstP2) = span2(min, max);								}								else { //irrev or fisher									//IRREVERSIBLE or FISHER=======									if (!bitPresent2(currentSet, 13)) { // not UC, therefore poly										(*NdnstP2) = makeSet2(min);	// polymorphic irreversible or fisher										if (currentType!=FISHER)											(*cpolymLP) += max-min;									}									else										(*NdnstP2) = span2(min, max);								}							}						}					} // ordered or higher				} //not missing			} // unord, ord, irrev, fisher		} // not excluded		NdnstP2++;	//increment pointer 		ctypP++;	//increment pointer		cpolymLP++;	//increment pointer		ChstuffP ++;	//increment pointer	} // cycle characters} //numbytes == 2else {	//FOUR BYTE SETTAXONDOWNSTATES ========еееееееееееее	int ic;	set32* NdnstP4 = (set32*)NdnstP;	for (ic = 0; ic< ichars; ic++) {		short currentType;		set32 tempSet;		currentType = (*ctypP);		if (currentType == EXCLUDED) {			(*NdnstP4) = 0;		}		else {			set32 currentSet = (*NdnstP4);			currentSet = clearBit4(currentSet, 26);			currentSet = clearBit4(currentSet, 27);			if (currentType >= DOLLO) { //DOLLOR OR USER DEFINED; need only check if multistate				(*NdnstP4) = currentSet; //simply return same set with footnote and footpict bits cut out				tempSet = clearHighBits4(currentSet);				if (tempSet!=0 && card4(tempSet)>1) {					setMultistateBit(ChstuffP); // bset	#7,bools(ChstuffP)						} //otherwise go to next character			}			else { //unordered, ordered, irreversible				if (bitPresent4(currentSet, 31)) { //missing data					int maxState = getMaxState(ChstuffP); //get maxst(ChstuffP),D4					currentSet= span4(0, maxState);		//set dnst to [0..maxst(ChstuffP)]					(*NdnstP4) = currentSet; //store result				}				else { //not missing					if (!bitPresent4(currentSet, 29)) { //not uncertain 						// if monomorphic or polymorphic add to set of surestates						tempSet = clearHighBits4(currentSet);						addToSureSet(tempSet, ChstuffP);					}					if (currentType==UNORDERED) {						//UNORDERED ==========						if (bitPresent4(currentSet, 29)) {							setMultistateBit(ChstuffP);  //bset	#7,bools(ChstuffP)	//set multistate bit								currentSet = clearHighBits4(currentSet);							(*NdnstP4) = currentSet;						}						else {							int card;								set32 recallCurrent = currentSet;							// add to polymorphism length count, if any							currentSet = clearHighBits4(currentSet);							card = card4(currentSet);							(*cpolymLP) += card-1;							if (card>1) 								setMultistateBit(ChstuffP);  //bset	#7,bools(ChstuffP)	//set multistate bit								else								addToSingletons(currentSet, ChstuffP);							(*NdnstP4) = currentSet;						}					}					else {						//ORDERED,IRREV,FISHER ========						tempSet = clearHighBits4(currentSet);						if (tempSet == 0) {							(*NdnstP4) = makeSet4(14);  //return set with error bit since set is empty						}						else {							int min = min4(tempSet);							int max = max4(tempSet);							if (min == max) { //singleton								addToSingletons(tempSet, ChstuffP);								(*NdnstP4) = tempSet;							}							else {								setMultistateBit(ChstuffP);  //bset	#7,bools(ChstuffP)	//set multistate bit									if (currentType== ORDERED) {									//ORDERED ============									if (!bitPresent4(currentSet, 29))  // not UC, therefore poly, therefore add length										(*cpolymLP) += max-min;									(*NdnstP4) = span4(min, max);								}								else { //irrev or fisher									//IRREVERSIBLE or FISHER=======									if (!bitPresent4(currentSet, 29)) { // not UC, therefore poly										(*NdnstP4) = makeSet4(min);	// polymorphic irreversible or fisher										if (currentType!=FISHER)											(*cpolymLP) += max-min;									}									else										(*NdnstP4) = span4(min, max);								}							}						}					} // ordered or higher				} //not missing			} // unord, ord, irrev, fisher		} // not excluded		NdnstP4++;	//increment pointer 		ctypP++;	//increment pointer		cpolymLP++;	//increment pointer		ChstuffP ++;	//increment pointer	} // cycle characters} //numbytes == 4}//еееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее//===========================================================================//===========================================================================//// 	procedure StSetsOpASM////		(NUMbytes: integer//NSP,NlfSP,NrtSP,chLP, chTP: IntPtr// numchars: integer)//// This is the grand procedure used to combine state sets of lf, rt into state sets at//// NSP.  // Determines sets only for UNORDERED, ORDERED, IRREVERSIBLE, AND FISHER characters// Increments length only for UNORDERED, ORDERED, and IRREVERSIBLE characterspascal void StSetsOpC(int numbytes, Ptr NSP, Ptr NlfSP, Ptr NrtSP, long *cLenP, short *ctypP, int numchars);pascal void StSetsOpC(int numbytes, Ptr NSP, Ptr NlfSP, Ptr NrtSP, long *cLenP, short *ctypP, int numchars){	if (numbytes == 2) {		set16* NSP2 = (set16*)NSP;		set16* NlfSP2 = (set16*)NlfSP;		set16* NrtSP2 = (set16*)NrtSP;		int ic = 0;		for (ic = 0; ic<numchars; ic++) {						set16 left = (*NlfSP2);			set16 right = (*NrtSP2);			set16 temp =left & right;				if (temp) { // temp was not empty				(*NSP2) = temp;			//printf(" left %i right %i temp* %i\n", left, right, temp);			}			else {				short currentType = (*ctypP);				if (currentType== UNORDERED) {					(*NSP2) = left | right;			//printf(" left %i right %i temp %i\n", left, right, temp);					(*cLenP)++; //increment length by one				}				else if (currentType<= DOLLO) { //ordered, fisher & irreversible					set16 minset, maxset;					if (left<right) {						minset = left;						maxset = right;					}					else {						minset = right;						maxset = left;					}					if (currentType == ORDERED) {						int minEdge = max2(minset);						int maxEdge = min2(maxset);						(*NSP2) = span2(minEdge, maxEdge);						(*cLenP)+= maxEdge - minEdge; //increment length by space between sets					}					else {						int minMin = min2(minset);						int minMax;						(*NSP2) = makeSet2(minMin);						if (currentType == IRREVERSIBLE) {							minMax = min2(maxset);							(*cLenP)+= minMax - minMin; //increment length by space between minima						}					}				}			}			cLenP++;			ctypP++;			NSP2++;			NlfSP2++;			NrtSP2++;		}	}	else {		set32* NSP4 = (set32*)NSP;		set32* NlfSP4 = (set32*)NlfSP;		set32* NrtSP4 = (set32*)NrtSP;		int ic = 0;		for (ic = 0; ic<numchars; ic++) {						set32 left = (*NlfSP4);			set32 right = (*NrtSP4);			set32 temp =left & right;				if (temp) { // temp was not empty				(*NSP4) = temp;			}			else {				short currentType = (*ctypP);				if (currentType== UNORDERED) {					(*NSP4) = left | right;					(*cLenP)++; //increment length by one				}				else if (currentType<= DOLLO) { //ordered, fisher & irreversible					set32 minset, maxset;					if (left<right) {						minset = left;						maxset = right;					}					else {						minset = right;						maxset = left;					}					if (currentType == ORDERED) {						int minEdge = max4(minset);						int maxEdge = min4(maxset);						(*NSP4) = span4(minEdge, maxEdge);						(*cLenP)+= maxEdge - minEdge; //increment length by space between sets					}					else {						int minMin = min4(minset);						int minMax;						(*NSP4) = makeSet4(minMin);						if (currentType == IRREVERSIBLE) {							minMax = min4(maxset);							(*cLenP)+= minMax - minMin; //increment length by space between minima						}					}				}			}			cLenP++;			ctypP++;			NSP4++;			NlfSP4++;			NrtSP4++;		}	}	}//===========================================================================// 	procedure UpOpASM //  (numbytes: integer; 26//   NuP, NancupP, SideNdP: Ptr; 22,18,14//  ctP: IP; ic: integer);  10,8// this procedure performs the uppass combining of ancestor's uppass states// with sister's downpass states for UNORDERED AND ORDERED characterspascal void UpOpC(int numbytes, Ptr NupP, Ptr NancupP, Ptr SideNdnstP, short *ctypP, int numchars);pascal void UpOpC(int numbytes, Ptr NupP, Ptr NancupP, Ptr SideNdnstP, short *ctypP, int numchars){	if (numbytes == 2) {		set16* NupP2 = (set16*)NupP;		set16* NancupP2 = (set16*)NancupP;		set16* SideNdnstP2 = (set16*)SideNdnstP;		int ic = 0;		for (ic = 0; ic<numchars; ic++) {						set16 ancUp = (*NancupP2);			set16 sideDn = (*SideNdnstP2);			set16 temp =ancUp & sideDn;				if (temp) { // temp was not empty				(*NupP2) = temp;			}			else {				short currentType = (*ctypP);				if (currentType== UNORDERED) {					(*NupP2) = ancUp | sideDn;				}				else if (currentType== ORDERED) { //ordered					if (ancUp<sideDn) 						(*NupP2) = span2(max2(ancUp), min2(sideDn));					else 						(*NupP2) = span2(max2(sideDn), min2(ancUp));				}			}			ctypP++;			NupP2++;			NancupP2++;			SideNdnstP2++;		}	}	else {		set32* NupP4 = (set32*)NupP;		set32* NancupP4 = (set32*)NancupP;		set32* SideNdnstP4 = (set32*)SideNdnstP;		int ic = 0;		for (ic = 0; ic<numchars; ic++) {						set32 ancUp = (*NancupP4);			set32 sideDn = (*SideNdnstP4);			set32 temp =ancUp & sideDn;				if (temp) { // temp was not empty				(*NupP4) = temp;			}			else {				short currentType = (*ctypP);				if (currentType== UNORDERED) {					(*NupP4) = ancUp | sideDn;				}				else if (currentType== ORDERED) { //ordered					if (ancUp<sideDn) 						(*NupP4) = span4(max4(ancUp), min4(sideDn));					else 						(*NupP4) = span4(max4(sideDn), min4(ancUp));				}			}			ctypP++;			NupP4++;			NancupP4++;			SideNdnstP4++;		}	}	}//еееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее//===========================================================================//===========================================================================// 	procedure TripleASM//		(NUMbytes: integer;  30//	    NSP,NlfSP,NrtSP,NupstP: Ptr;  26,22,18,14//		chTP: IntPtr; numchars: integer); 10,8// this procedure combines downpass state sets at left, right descendants// of N with its uppass state set to yield its final state set// for UNORDERED and ORDERED characterspascal void TripleC(int numbytes, Ptr NSP, Ptr NlfSP, Ptr NrtSP, Ptr NupP, short *ctypP, int numchars);pascal void TripleC(int numbytes, Ptr NSP, Ptr NlfSP, Ptr NrtSP, Ptr NupP, short *ctypP, int numchars){	if (numbytes == 2) {		set16* NSP2 = (set16*)NSP;		set16* NlfSP2 = (set16*)NlfSP;		set16* NrtSP2 = (set16*)NrtSP;		set16* NupP2 = (set16*)NupP;		int ic = 0;		for (ic = 0; ic<numchars; ic++) {						set16 left = (*NlfSP2);			set16 right = (*NrtSP2);			set16 up = (*NupP2);			set16 temp =left & right & up;			if (temp) { // temp was not empty				(*NSP2) = temp;			}			else {				short currentType = (*ctypP);				if (currentType== UNORDERED) {					temp = (left & right) | (left & up) | (right & up);					if (!temp)						temp = (left | right | up);					(*NSP2) = temp;				}				else if (currentType== ORDERED) { //ordered					int minA, maxA, minB, maxB, minC, maxC;					minA = min2(left);					maxA = max2(left);					minB = min2(right);					maxB = max2(right);					minC = min2(up);					maxC = max2(up);					//Two most distant sets found then between-space intersected with remaining set}					if ((minA > minB) && (minA > minC)) {						//set1 minimum furthest right}						if (maxB < maxC)  //most distant are 2 and 1}							temp = span2(maxB, minA) &  up;  //{[--2-(-]--3--)  [--1--] }						else //{most distant are 3 and 1}							temp = span2(maxC, minA) &  right; //{[--3-(-]--2--)  [--1--] }					}					else if (minB > minC) {						//set2 minimum furthest right}						if (maxA < maxC)  //{most distant are 1 and 2}							temp = span2(maxA, minB) &  up;  // {[--1-(-]--3--)  [--2--] }						else  //{most distant are 3 and 2}							temp = span2(maxC, minB) &  left;  // {[--3-(-]--1--)  [--2--] }					}					else {						//{set3 furthest right}						if (maxA < maxB)  //{most distant are 1 and 3}							temp = span2(maxA, minC) &  right;  // {[--1-(-]--2--)  [--3--] }						else  //{most distant are 2 and 3}							temp = span2(maxB, minC) &  left; //{[--2-(-]--1--)  [--3--] }					}					(*NSP2) = temp;				}			}			ctypP++;			NSP2++;			NlfSP2++;			NrtSP2++;			NupP2++;		}	}	else {		set32* NSP4 = (set32*)NSP;		set32* NlfSP4 = (set32*)NlfSP;		set32* NrtSP4 = (set32*)NrtSP;		set32* NupP4 = (set32*)NupP;		int ic = 0;		for (ic = 0; ic<numchars; ic++) {						set32 left = (*NlfSP4);			set32 right = (*NrtSP4);			set32 up = (*NupP4);			set32 temp =left & right & up;				if (temp) { // temp was not empty				(*NSP4) = temp;			}			else {				short currentType = (*ctypP);				if (currentType== UNORDERED) {					temp = (left & right) | (left & up) | (right & up);					if (!temp)						temp = (left | right | up);					(*NSP4) = temp;				}				else if (currentType== ORDERED) { //ordered					int minA, maxA, minB, maxB, minC, maxC;					minA = min4(left);					maxA = max4(left);					minB = min4(right);					maxB = max4(right);					minC = min4(up);					maxC = max4(up);					//Two most distant sets found then between-space intersected with remaining set}					if ((minA > minB) && (minA > minC)) {						//set1 minimum furthest right}						if (maxB < maxC)  //most distant are 2 and 1}							temp = span4(maxB, minA) &  up;  //{[--2-(-]--3--)  [--1--] }						else //{most distant are 3 and 1}							temp = span4(maxC, minA) &  right; //{[--3-(-]--2--)  [--1--] }					}					else if (minB > minC) {						//set2 minimum furthest right}						if (maxA < maxC)  //{most distant are 1 and 2}							temp = span4(maxA, minB) &  up;  // {[--1-(-]--3--)  [--2--] }						else  //{most distant are 3 and 2}							temp = span4(maxC, minB) &  left;  // {[--3-(-]--1--)  [--2--] }					}					else {						//{set3 furthest right}						if (maxA < maxB)  //{most distant are 1 and 3}							temp = span4(maxA, minC) &  right;  // {[--1-(-]--2--)  [--3--] }						else  //{most distant are 2 and 3}							temp = span4(maxB, minC) &  left; //{[--2-(-]--1--)  [--3--] }					}					(*NSP4) = temp;				}			}			ctypP++;			NSP4++;			NlfSP4++;			NrtSP4++;			NupP4++;		}	}	}/*еееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее;===========================================================================;===========================================================================;; 	procedure TerminalTripleASM ;;  (numbytes: integer; 30;;   NstsP, NancstsP, TstsP, NdnstP: Ptr; 26,22,18,14;;  ctP: IP; ic: integer);  10,8;  This procedure adjusts terminal final states, to handle cases where; missing, uncertain or polymorphic, for UNORDERED, ORDERED, IRREVERSIBLE; and FISHER CHARACTERS ONLY*/pascal void TerminalTripleC(int numbytes, Ptr NSP, Ptr NancstsP, Ptr TstsP, Ptr NdnstP, short *ctypP, int numchars);pascal void TerminalTripleC(int numbytes, Ptr NSP, Ptr NancstsP, Ptr TstsP, Ptr NdnstP, short *ctypP, int numchars){	if (numbytes == 2) {		set16* NSP2 = (set16*)NSP;		set16* NancstsP2 = (set16*)NancstsP;		set16* TstsP2 = (set16*)TstsP;		set16* NdnstP2 = (set16*)NdnstP;		int ic = 0;		for (ic = 0; ic<numchars; ic++) {			set16 aboveSet = (*TstsP2);			set16 copyAboveSet = aboveSet;			if (bitPresent2(aboveSet, 15)) {				(*NSP2) = (*NancstsP2);  // missing data; copy ancestral			}			else if (aboveSet= clearHighBits2(aboveSet)){// is not empty				if (card2(aboveSet) == 1) {					(*NSP2) = (*NdnstP2);  // missing data; copy ancestral				}				else {					set16 belowSet =  (*NancstsP2);					short currentType = (*ctypP);					if (currentType== UNORDERED) {						if ((belowSet & aboveSet) == belowSet) //belowSet is subset of aboveset; use belowset							(*NSP2) = belowSet;						else if (bitPresent2(copyAboveSet,13))  // aboveSet was uncertain; use it							(*NSP2) = aboveSet;						else							(*NSP2) = aboveSet | belowSet;					}					else {  // type above ordered						short min = min2(aboveSet);						short max = max2(aboveSet);						if (currentType== ORDERED || bitPresent2(copyAboveSet,13)) { //ordered or uncertain irrev, fisher							set16 span = span2(min, max);							set16 temp = span & belowSet;							if (temp) // intersects; use intersection								(*NSP2) = temp;							else if (span> belowSet) // span is above; use minimum								(*NSP2) = makeSet2(min);							else //span is below; use maximum								(*NSP2) = makeSet2(max);						}						else {  //certain irreversible, fisher							(*NSP2) = makeSet2( min2(aboveSet));						}					}				}			}			ctypP++;			NSP2++;			NancstsP2++;			TstsP2++;			NdnstP2++;					}	}	else {		set32* NSP4 = (set32*)NSP;		set32* NancstsP4 = (set32*)NancstsP;		set32* TstsP4 = (set32*)TstsP;		set32* NdnstP4 = (set32*)NdnstP;		int ic = 0;		for (ic = 0; ic<numchars; ic++) {			set32 aboveSet = (*TstsP4);			set32 copyAboveSet = aboveSet;			if (bitPresent4(aboveSet, 31)) {				(*NSP4) = (*NancstsP4);  // missing data; copy ancestral			}			else if (aboveSet= clearHighBits4(aboveSet)){// is not empty				if (card4(aboveSet) == 1) {					(*NSP4) = (*NdnstP4);  // missing data; copy ancestral				}				else {					set32 belowSet =  (*NancstsP4);					short currentType = (*ctypP);					if (currentType== UNORDERED) {						//set32 interSet = belowSet & aboveSet;						if ((belowSet & aboveSet) == belowSet) //belowSet is subset of aboveset; use belowset							(*NSP4) = belowSet;						else if (bitPresent4(copyAboveSet,29))  // aboveSet was uncertain; use it							(*NSP4) = aboveSet;						else							(*NSP4) = aboveSet | belowSet;					}					else {  // type above ordered						short min = min4(aboveSet);						short max = max4(aboveSet);						if (currentType== ORDERED || bitPresent4(copyAboveSet,29)) { //ordered or uncertain irrev, fisher							set32 span = span4(min, max);							set32 temp = span & belowSet;							if (temp) // intersects; use intersection								(*NSP4) = temp;							else if (span> belowSet) // span is above; use minimum								(*NSP4) = makeSet4(min);							else //span is below; use maximum								(*NSP4) = makeSet4(max);						}						else {  //certain irreversible, fisher							(*NSP4) = makeSet4( min4(aboveSet));						}					}				}			}			ctypP++;			NSP4++;			NancstsP4++;			TstsP4++;			NdnstP4++;					}	}	}/*;еееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее;===========================================================================;===========================================================================;	procedure changepassASM (;	numbytes: integer 28;	branchlistmode: integer	26; 	NstsP, aNstsP,CtypP: ptr  22,18,14;   numchars: integer; 12;	 Nlength1: ptr); 8*/#define UNAMBIGUOUS 0pascal void changepassC(int numbytes, int branchListMode, Ptr NSP, Ptr NancstsP, short *ctypP, int numchars, long *length);pascal void changepassC(int numbytes, int branchListMode, Ptr NSP, Ptr NancstsP, short *ctypP, int numchars, long *length){	if (numbytes == 2) {		if (branchListMode == UNAMBIGUOUS) {			set16* NSP2 = (set16*)NSP;			set16* NancstsP2 = (set16*)NancstsP;			int ic = 0;			for (ic = 0; ic<numchars; ic++) {				short currentType = (*ctypP);				if (currentType != EXCLUDED && currentType != FISHER) {					if (!(clearHighBits2((*NSP2) & (*NancstsP2)))) 						(*length)++;				}				ctypP++;				NSP2++;				NancstsP2++;			}		}		else {			set16* NSP2 = (set16*)NSP;			set16* NancstsP2 = (set16*)NancstsP;			int ic = 0;			for (ic = 0; ic<numchars; ic++) {				short currentType = (*ctypP);				if (currentType != EXCLUDED && currentType != FISHER) {					if (clearHighBits2(*NSP2) != clearHighBits2(*NancstsP2)) 						(*length)++;				}				ctypP++;				NSP2++;				NancstsP2++;			}		}	}	else {		if (branchListMode == UNAMBIGUOUS) {			set32* NSP4 = (set32*)NSP;			set32* NancstsP4 = (set32*)NancstsP;			int ic = 0;			for (ic = 0; ic<numchars; ic++) {				short currentType = (*ctypP);				if (currentType != EXCLUDED && currentType != FISHER) {					if (!(clearHighBits4((*NSP4) & (*NancstsP4)))) 						(*length)++;				}				ctypP++;				NSP4++;				NancstsP4++;			}		}		else {			set32* NSP4 = (set32*)NSP;			set32* NancstsP4 = (set32*)NancstsP;			int ic = 0;			for (ic = 0; ic<numchars; ic++) {				short currentType = (*ctypP);				if (currentType != EXCLUDED && currentType != FISHER) {					if (clearHighBits4(*NSP4) != clearHighBits4(*NancstsP4)) 						(*length)++;				}				ctypP++;				NSP4++;				NancstsP4++;			}		}	}}/*;еееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее;===========================================================================;	procedure FillGenDnstASM ;	(NgdnstP, NlfgdnstP, NrtgdnstP,ddistP: Ptr; 22,18,14,10;	mdef: integer); 8#define INFINITY -1//{------------------------------------------------------}short cGenLessThan (long a, long b);short cGenLessThan (long a, long b){	//{returns true if a less than b}	return ( (a != INFINITY) && ((b == INFINITY) || (a < b)));}/*----------------------------------------------------------------}	function GNabove (ND: Nptr; iq: integer): integer;{FROZEN 3.0}{Given "iq" at node below ND, calculates number of states ND^anc to ND & above}{  е---е }{   \ /  }{    ND  }{   /    }{  е     }		var			ir: integer;			min, num: longint;	begin		min := INFINITY;{Checks all possible assignments to ND for one minimizing length ND^anc and above,}{given that state iq is at ND^.anc}		for ir := 0 to maxdefgen do			begin				num := cAddGenDist(ddist[iq, ir], ND^.gdnst[ir]);				if cGenLessThan(num, min) then  {better ir is found to place at ND, record total length}					min := num;			end;		GNabove := min;	end;//{-----------------------------------------------------------------------------}	long cAddGenDist (long a, long b);	long cAddGenDist (long a, long b){		long monitor;		if ((a == INFINITY) || (b == INFINITY)) 			return INFINITY;		else 			return a+b;	}pascal void FillGenDnstC(Ptr NgdnstP, Ptr NlfgdnstP, Ptr NrtgdnstP, Ptr ddistP, short mdef);pascal void FillGenDnstC(Ptr NgdnstP, Ptr NlfgdnstP, Ptr NrtgdnstP, Ptr ddistP, short mdef){	int iq;	for (iq = 0; iq<= mdef; iq++)		N^.gdnst[iq] := cAddGenDist(cGNabove(N^.lf, iq), cGNabove(N^.rt, iq));}}*/