#include <Types.h>#include <Resources.h>#include <OSUtils.h>#include <Files.h>#include <Memory.h>#include <stdio.h>#if powerc#include <CodeFragments.h>#include <MixedMode.h>#endif#if powercProcInfoType		ModuleProcInfo = kPascalStackBased 														| RESULT_SIZE(SIZE_CODE(sizeof(long)))													| STACK_ROUTINE_PARAMETER(1,kFourByteCode)								 					| STACK_ROUTINE_PARAMETER(2,kFourByteCode)								 					| STACK_ROUTINE_PARAMETER(3,kFourByteCode)								 					| STACK_ROUTINE_PARAMETER(4,kFourByteCode)								 					| STACK_ROUTINE_PARAMETER(5,kFourByteCode);#endiftypedef pascal long (*ModuleProcType)(long, long, long, long,long); /*Prototypes ===================================================*/pascal long LoadModule(const FSSpec *moduleFile, Str63 moduleName, Handle *moduleHandle, long *PPCmodule);pascal long ExecuteModule(Handle moduleHandle, long moduleP, long request, long taskP, long magicP,long MCModuleformat);#include "MacCladeTypes.h"pascal long CheckRecordSizesC(MagicPtr magicP);/* ===================================================*/pascal long LoadModule(const FSSpec *moduleFile, Str63 moduleName, Handle *moduleHandle, long *PPCmodule){ModuleProcType  modulePtr = nil;/*OSErr err;CFragConnectionID connID;Str255 errName;ConstStr63Param fragName=moduleName;err = GetDiskFragment(moduleFile, 0, 0, fragName, kLoadNewCopy, &connID, &modulePtr, errName);if (err==noErr)   we have a PPC code fragment!	{	(*(ProcPtr)modulePtr)(num, squareP);	CloseConnection(&connID);	return(0);	}else  we have a resource!{ */	short				saveResFile = CurResFile();	short				fRefNum;	fRefNum = FSpOpenResFile(moduleFile, fsRdPerm);	if (fRefNum != -1) 		{		UseResFile(fRefNum);		*PPCmodule = 1;		#if powerc		*moduleHandle = Get1Resource('MPPC', 128);  /*prefer PPC module resource first*/		if (*moduleHandle == nil)				{				*moduleHandle = Get1Resource('M68K', 128);  /* take 68K module as second choice*/				*PPCmodule = 0;				}		#else		*moduleHandle = Get1Resource('M68K', 128);  /*seek 68K module resource*/		*PPCmodule = 0;		#endif		if (*moduleHandle == nil)  /* no module found; look for nubbins (four parameter direct execute procedures) */			{			#if powerc			*moduleHandle = Get1Resource('NPPC', 128);  /*prefer PPC nubbin resource first*/			if (*moduleHandle == nil)					{					*moduleHandle = Get1Resource('N68K', 128);  /* take 68K nubbin as second choice*/					*PPCmodule = 2;					}			else *PPCmodule = 3;			#else			*moduleHandle = Get1Resource('N68K', 128);  /*seek 68K nubbin resource*/			*PPCmodule = 2;			#endif			}		if (*moduleHandle != nil)			{			DetachResource(*moduleHandle);			return(0);}		else			return(1);		CloseResFile(fRefNum);		UseResFile(saveResFile);		}	else		return(1);/*	}  */		}/* ===================================================*/pascal long ExecuteModule(Handle moduleHandle, long moduleP, long request, long taskP, long magicP,long MCModuleformat){long result;ModuleProcType  modulePtr = nil;		if (moduleHandle != nil)			{			//HLock(moduleHandle);			modulePtr = (ModuleProcType)*moduleHandle;			#if powerc				result= CallUniversalProc((UniversalProcPtr)modulePtr,ModuleProcInfo, moduleP, request, taskP, magicP, MCModuleformat);			#else				 result= (*(ModuleProcType)modulePtr)(moduleP, request, taskP, magicP, MCModuleformat); 			#endif			//HUnlock(moduleHandle);			//ReleaseResource(moduleHandle); // Wayne: why was this here?? Now moved to Quit			return(result);}		else			return(2);	}/*-----------------------------------------------------------------------------*/pascal long CheckRecordSizesC (MagicPtr magicP){		if (magicP->recordSizes[1] != sizeof(TaskRecord))			return 1;		else if (magicP->recordSizes[2] != sizeof(ModuleRecord))			return 2;		else if (magicP->recordSizes[3] != sizeof(MessageRecord))			return 3;		else if (magicP->recordSizes[4] != sizeof(BranchLengthsRecord))			return 4;		else if (magicP->recordSizes[5] != sizeof(ShadeRecord))			return 5;		else if (magicP->recordSizes[6] != sizeof(LabelsRecord))			return 6;		else if (magicP->recordSizes[7] != sizeof(LabelAtNodeRecord))			return 7;		else if (magicP->recordSizes[8] != sizeof(NodePicturesRecord))			return 8;		else if (magicP->recordSizes[9] != sizeof(PictureAtNodeRecord))			return 9;		else if (magicP->recordSizes[10] != sizeof(TreeDisplayRecord))			return 10;		else if (magicP->recordSizes[11] != sizeof(NodeDisplayRecord))			return 11;		else if (magicP->recordSizes[12] != sizeof(NodeRecord))			return 12;		else if (magicP->recordSizes[13] != sizeof(TreeRecord))			return 13;		else if (magicP->recordSizes[14] != sizeof(TreeListRecord))			return 14;		else if (magicP->recordSizes[15] != sizeof(MagicRecord))			return 15;		else if (magicP->recordSizes[16] != sizeof(SelectionRecord))			return 16;		else if (magicP->recordSizes[17] != sizeof(FileDirInfoRec))			return 17;		else if (magicP->recordSizes[18] != sizeof(SinglePt))			return 18;		else if (magicP->recordSizes[19] != sizeof(BListRecord))			return 19;		else if (magicP->recordSizes[20] != sizeof(DutyNeededRecord))			return 20;		else if (magicP->recordSizes[21] != sizeof(TaxonRecord))			return 21;		else if (magicP->recordSizes[22] != sizeof(NodeLabeltype))			return 22;		else if (magicP->recordSizes[23] != sizeof(CharacterRecord))			return 23;		//else if (magicP->recordSizes[24] != sizeof(TypeRecord))		//	return 24;		else if (magicP->recordSizes[25] != sizeof(ModelClassRecord))			return 25;		else if (magicP->recordSizes[26] != sizeof(CharacterModelRecord))			 return 26;		else if (magicP->recordSizes[27] != sizeof(CharModelsListRecord))			return 27;		else if (magicP->recordSizes[28] != sizeof(ItemInLinkedListRecord))			return 28;		else if (magicP->recordSizes[29] != sizeof(LinkedListChoiceRecord))			return 29;		else if (magicP->recordSizes[30] != sizeof(DataMatrixRecord))			return 30;		else if (magicP->recordSizes[31] != sizeof(ToolBarButtonRecord))			return 31;		else if (magicP->recordSizes[32] != sizeof(LegendRecord))			return 32;		else			return 0;}