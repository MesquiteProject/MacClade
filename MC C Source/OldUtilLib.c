/* ; down, up, final pass calculations *//*;[0..9],#1023;;[0..15];#65535;;[0..25];#67108863;[10..15];#64512;[16..31];#-65536;[26..31];#-67108864*/#define set32  unsigned long#define set16  unsigned short#define boolean  unsigned short#define int16  short#define set09 1023#define set025 67108863/* prototypes */asm long multaddC (long a, long b, long c);asm	long RandomPosLong (long *seed);asm	short RandomInteger (long *seed);pascal	boolean chariswhite (short ccL); asm	boolean  ComparePointers (long ctypP, boolean mustbeidentical, boolean examineexcluded, short nummbytes, long src, long dest, short numchars);asm	void  ZeroBlockWords (long p, long numWords);asm	void  ZeroBlockLongwords (long p, long numlongs);asm	void  GetNodeTokenC (long descP,long  token);asm	void  SetToCellString (short miss, short gap, short uncert, short poly, long symb, long dest, long statenames, set32 setc);asm	boolean  charinstringC(short ch, long s); pascal	boolean  ComparestringC (char *st1, char *st2);asm	boolean  StringsEqual (long st1, long st2, short siglen); asm	void  ConcatStringChar (long s, short ch);asm	void  sectHandles (long src, long dest, long numbytes);asm	void  UnionHandles (long src, long dest, long numbytes);asm	short CharAtPointer (long p);asm	void  ExpandCHBlock (long dest, long source, short numchars);asm	void  ContractCHBlock (short newmaxstate, long dest, long source, short numchars);//еееееееееееееееееееееееееееееееееееееееееееееееееее//;//;//; =====================================================================//;   ZeroBlockWords    Clears an entire block, moving by words//;//;  p:ptr,numbytes: integer//; FROZEN 3.0asm	void  ZeroBlockWords (long p, long numWords){	link		A6,#0     	movem.l		A2/D2,-(SP)   		move.l		8(A6),A2 		//;get pointer	move.l		12(A6),D2		//;get numwordsonemoreZeroWords:	clr.w		(A2)+	subq.l		#1,D2	bgt		onemoreZeroWords	movem.l		(SP)+,A2/D2	unlk		A6	movea.l		(SP)+,A0	//$$lea		8(SP),SP	jmp		(A0)	}//;//;//; =====================================================================//;   ZeroBlockLongWords    Clears an entire block, moving by long words//;//;  p:ptr,numbytes: integer//; FROZEN 3.0asm	void  ZeroBlockLongwords (long p, long numlongs){	link		A6,#0     	movem.l		A2/D2,-(SP)   		move.l		8(A6),A2 		//;get pointer	move.l		12(A6),D2		//;get numlongwordsonemoreZeroLong:	clr.l		(A2)+	subq.l		#1,D2	bgt		onemoreZeroLong	movem.l		(SP)+,A2/D2	unlk		A6	movea.l		(SP)+,A0	//$$lea		8(SP),SP	jmp		(A0)	}//;//;//; =====================================================================//;//;//;  src,dest,numbytes//; FROZEN 3.0asm	void  sectHandles (long src, long dest, long numbytes){	link		A6,#0     	movem.l		A1/A2/A3/D1,-(SP)   		movea.l		8(A6),A1 		//;place in A1 the starting address of src	adda.l		16(A6),A1		//;calculate in A1 the expected end of src	movea.l		12(A6),A3		//; place in A3 the dest	movea.l		8(A6),A2		//; place in A2 the src//* == now start moving along string until done ====L1234:	move.w		(A2)+,D1	and.w		D1,(A3)+	cmpa.l		A2,A1		//;if expected end - src is positive keeping going	bgt		L1234	movem.l		(SP)+,A1/A2/A3/D1	unlk		A6	movea.l		(SP)+,A0	//$$lea		12(SP),SP	jmp		(A0)}//;//; =====================================================================asm	void  UnionHandles (long src, long dest, long numbytes){#define sourceptr    8#define destptr      12#define numbytes      16	link		A6,#0     	movem.l		A1/A2/A3/D1,-(SP)   		movea.l		sourceptr(A6),A1 	//;place in A1 the starting address of src	adda.l		numbytes(A6),A1		//;calculate in A1 the expected end of src	movea.l		sourceptr(A6),A2	//; place in A2 the src	movea.l		destptr(A6),A3		//; place in A3 the dest//* == now start moving along string until done ====L1200:	move.w		(A2)+,D1  	or.w		D1,(A3)+	cmpa.l		A2,A1		//;if expected end - src is positive keeping going	bgt		L1200	movem.l		(SP)+,A1/A2/A3/D1	unlk		A6	movea.l		(SP)+,A0	//$$lea		12(SP),SP	jmp		(A0)}	//; =====================================================================//; function chariswhite (tchar: char): boolean;//;		if not (c in [' ', chr(9), chr(13), ',', ';']) thenpascal boolean chariswhite (short ccL){if ((ccL==32)|(ccL==9)|(ccL==13)|(ccL==10)|(ccL==44)|(ccL==59))	return(257);else	return(0);}//;//; =====================================================================//; now case insensitivepascal	boolean  ComparestringC (char *st1, char *st2){		char b1=(*st1++);  // get first byte (size)	char b2=(*st2++);  // get first byte (size)	char b;	if (b1 != b2)		return(0);	else		{		if (b1==0)			return(257);		else			{char count=b1;			int keepgoing=1;				while (keepgoing)					{					b1=(*st1++);					b2=(*st2++);					if (b1==b2)						{count--;						if (count==0)							{							keepgoing=false;							return(257);							}						}					else 						{						if (b1>b2)							{b=b1; b1=b2; b2=b;}						b1 += 32;						if (b1!=b2)							{							keepgoing=false;							return(0);							}						else							{count--;							if (count==0)								{								keepgoing=false;								return(257);								}							}						}										}			}		}}	//;===================================================//;function charinstringC (ch:char; s: ptr): boolean;asm	boolean  charinstringC(short ch, long s){	link		A6,#0    	movem.l		A4/D1/D2/D3,-(SP)              	clr.w		D1		move.b		9(A6),D1   //;move test char into D1	movea.l		10(A6),A4	//;moving string ptr into A4	move.b		(A4)+,D2	//;initiate counter and move to first chartrynextinline:	cmp.b	#0,D2	//;see if reached end of string	beq	no	cmp.b	(A4)+,D1	//;check if next char same as D1	beq	yes	subq.b	#1,D2	//;if not move decrement counter and move to next char	bra	trynextinlineno:	move.w	#0,D0	bra	godone	yes:	move.w	#257,D0godone:	movem.l		(SP)+,A4/D1/D2/D3	unlk		A6	movea.l		(SP)+,A0	//$$addq.l		#6,SP	jmp		(A0)}/* asm	boolean  charinstringC(char ch, long s){	link		A6,#0    	movem.l		A4/D1/D2/D3,-(SP)              	clr.w		D1		move.b		9(A6),D1   //;move test char into D1	movea.l		10(A6),A4	//;moving string ptr into A4	move.b		(A4)+,D2	//;initiate counter and move to first chartrynextinline:	cmp.b	#0,D2	//;see if reached end of string	beq	no	cmp.b	(A4)+,D1	//;check if next char same as D1	beq	yes	subq.b	#1,D2	//;if not move decrement counter and move to next char	bra	trynextinlineno:	move.w	#0,D0	bra	godone	yes:	move.w	#257,D0godone:	movem.l		(SP)+,A4/D1/D2/D3	unlk		A6	movea.l		(SP)+,A0	//$$addq.l		#6,SP	jmp		(A0)}*///;//; ===================================================================== asm	short CharAtPointer (long p){	link		A6,#0     	movem.l		A4/D7,-(SP)                 	movea.l		8(A6),A4	clr.w		D7	move.b		(A4),D7  //;{getting char}	move.w		D7,D0	movem.l		(SP)+,A4/D7	unlk		A6	movea.l		(SP)+,A0	//$$addq.l		#4,SP	jmp		(A0)}//;//; =====================================================================//;	procedure ExpandCHBlock(dest,source: ptr//; numchar: integer)//;asm	void  ExpandCHBlock (long dest, long source, short numchars){	link		A6,#0     	movem.l		A1/A2/D5/D6/D7,-(SP)   		clr			D5	move.w		14(A6),D5		//;get num chars to cycle	move.l		12(A6),A1 		//;get starting address of src	move.l		8(A6),A2 		//;get starting address of dest	subq.w		#1,D5	//;subtract 1 from numcharsexpnextchar:	move.w		(A1),D6		//; get source setchars	andi.l		#65535,D6	//; zap high word	move.l		D6,D7		//; store copy of set	andi.l		#64512,D6	//; preserve bytes 10-15 of D6	swap		D6			//; swap register halves to move highbits up	andi.l		#1023,D7	//; preserve bytes 0-9 of D7	or.l		D6,D7		//; union D6,D7	move.l		D7,(A2)		//; return result into dest	addq.l		#2,A1		//;move to next setchars15 in src	addq.l		#4,A2		//;move to next setchars31 in dest	dbra		D5,expnextchar		movem.l		(SP)+,A1/A2/D5/D6/D7	unlk		A6	movea.l		(SP)+,A0	//$$adda.l		#10,SP	jmp		(A0)}//;//; =====================================================================//;	procedure ContractCHblock(dest,source: ptr//; numchar: integer)//;//; FROZEN 3.0asm	void  ContractCHBlock (short newmaxstate, long dest, long source, short numchars){	link		A6,#0     	movem.l		A1/A2/D3/D4/D5/D6/D7,-(SP)   		clr			D5	move.w		18(A6),D5		//;get num chars to cycle	move.l		14(A6),A1 		//;get starting address of src	move.l		10(A6),A2 		//;get starting address of dest	move.w		8(A6),D4		//;get new maxstate	cmpi.w		#9,D4			//;see if contraction to 0..9 or 0..3	beq		save09	move.l		#15,D3		//;set saveset to 0..3	bra		goccbsave09:	move.l		#1023,D3		//;set saveset to 0..9goccb:	subq.w		#1,D5	//;subtract 1 from numcharsconnextchar:	move.l		(A1),D6		//; get source setchars	move.l		D6,D7		//; store copy of set	andi.l		#-67108864,D6	//; preserve bytes 26..31 of D6	swap		D6			//; swap register halves	and.l		D3,D7	//; preserve bytes 0-9 or 0-3 of D7	beq		setasmissing  //;if result was nothing then set as missing	or.l		D7,D6		//;union D6,D7	bra		doneccsetasmissing:	bset		#15,D6donecc:	move.w		D6,(A2)		//; return result into dest	addq.l		#4,A1		//;move to next setchars31 in src	addq.l		#2,A2		//;move to next setchars15 in dest	dbra		D5,connextchar		movem.l		(SP)+,A1/A2/D3/D4/D5/D6/D7	unlk		A6	movea.l		(SP)+,A0	//$$adda.l		#12,SP	jmp		(A0)	}//;//; =====================================================================//;	procedure SetToCellString(miss,gap,uncert,poly: char//; 31,29,27,25(30,28,26,24)//;						symb,dest,statenames: ptr//; 20,16,12//;						setc: largestsetchars)//; 8//;FROZEN 3.0#define missoffset 9#define gapoffset 11#define uncertoffset 13#define polyoffset 15#define symbO 16#define destO 20#define statenamesO 24#define setCO 28asm	void  SetToCellString (short miss, short gap, short uncert, short poly, long symb, long dest, long statenames, set32 setc){	link		A6,#0     	movem.l		A1-A4/D1-D7,-(SP)   		move.l		8(A6),D1 		//;test	move.l		12(A6),D1 		//;test	move.l		16(A6),D1 		//;test	move.l		20(A6),D1 		//;test	move.l		24(A6),D1 		//;test	move.l		28(A6),D1 		//;test	move.l		32(A6),D1 		//;test	move.l		setCO(A6),D5 		//;get set to be converted	beq		emptysetstring	//;jump if empty	move.l		statenamesO(A6),A1		//;get starting address of statenames string	move.l		destO(A6),A2 		//;get starting address of dest	move.l		symbO(A6),A3 		//;get starting address of symbols//; if statenames string not up to maxst then record length & take care	move.l		A2,A4		//;store dest ptr	addq.l		#1,A1		//;skip length bit of source	addq.l		#1,A2		//;skip length bit of dest	clr.w		D2		//;initialize dest counter	move.w		#-1,D4		//;initialize set bit counter	cmp.l		#1,A1			//;test to see if nil source passed	beq		nosymbols	clr.w		D6	bra		ckmissingnosymbols:	move.w		#7,D6		//;indicating nil passed instead of statenames pointerckmissing://;first check if MS then set and quit	btst		#31,D5		//;check if missing	beq 		checkUC	btst		#28,D5		//; if gap then put in gap xxx	bne		putgap	move.b		missoffset(A6),D3	//;place in D3 the missing data char	bra		movemissputgap:	move.b		gapoffset(A6),D3	//;place in D3 the gap charmovemiss:	move.b		D3,(A2)+	//;transferring char into dest	addq.w		#1,D2		//;dest length counter	bra		doneset	checkUC:	btst		#29,D5	beq 		getAND	move.b		uncertoffset(A6),D7	//;getting Uncert state separator	andi.l		#67108863,D5	//;zapping high bits	bra		nextstategetAND:	move.b		polyoffset(A6),D7	//;getting poly state separator	andi.l		#67108863,D5	//;zapping high bits//;=======================nextstate:	addq.w		#1,D4		//;go to next bit	addq.l		#1,A3		//;go to next symbol	bclr		D4,D5		//;clear and test bit in setchars	beq		skipstatename	cmp.b		#7,D6		//;have we already hit end of statename string?	beq		usesymbolnextcharinname:	move.b		(A1)+,D6	//;getting character & moving ptr	cmp.b		#32,D6	//;checking if space (end of statename)	beq		checkifclrd    //;end of statename so see if set cleared	cmp.b		#7,D6	//;checking if end of statenamestring	beq		usesymbol	cmp.b		#8,D6	//;checking if no char	beq		usesymbol	cmp.b		#95,D6	bne		putchardest	move.b		#32,D6		//;replace _ by spaceputchardest:	move.b		D6,(A2)+		//;transferring char into dest	addq.w		#1,D2			//;dest length counter	bra		nextcharinnameusesymbol:	move.b		(A3),D3		//;move symbol into dest	move.b		D3,(A2)+		//;move symbol into dest	addq.l		#1,A1			//;increment source counter	addq.w		#1,D2			//;dest length counter	bra		checkifclrdskipstatename:  //;skip state name, then nextstate	cmp.b		#7,D6		//;have we already hit end?	beq		nextstateskipnextchar:	move.b		(A1)+,D6	//;getting character & moving ptr	cmp.b		#32,D6	//;checking if space (end of statename)	beq		nextstate	cmp.b		#7,D6	//;checking if end of statenamestring	bne		skipnextchar	bra		nextstate	checkifclrd:	tst.l		D5		//;checking to see if set exhausted	beq		doneset	move.b		D7,(A2)+		//;transferring separator into dest	addq.w		#1,D2			//;dest length counter	bra		nextstate	doneset:	move.b		D2,(A4)		//;place length bit for dest stringemptysetstring:		movem.l		(SP)+,A1-A4/D1-D7	unlk		A6	movea.l		(SP)+,A0	//$$adda.l		#24,SP	jmp		(A0)}//;//; =====================================================================//;  function StringsEqual(@str1, @str2: ptr//; siglen: integer):boolean//;//;FROZEN 3.0asm	boolean  StringsEqual (long st1, long st2, short siglen){	link		A6,#0   	movem.l		A3/A4/D3-D7,-(SP)              	clr		D7	move.w		16(A6),D7	//;get significance length (only byte)	movea.l		12(A6),A3   //;get ptr to str2	movea.l		8(A6),A4   //;get ptr to str1	//;if both have length longer than or equal to siglen then use siglen as counter	//;else if both have same length shorter than use this as counter	//;else different	clr.w		D5	move.b		(A3),D5	//;get len of str2	cmp.w 		D7,D5 //;is length greater than or equal to siglen?	bge		str2big  //;	clr.w		D6	move.b		(A4),D6	//;get len of str1	cmp.w 		D5,D6 //;are str2 and str1 same length?	bne		notsame	move.w		D5,D7	//;len of str is limit	bra		startcheck	str2big:	clr.w		D6	move.b		(A4),D6	//;get len of str1	cmp.w 		D7,D6 //;is length greater than siglen?	bge		startcheck  //;	bra		notsame	startcheck:	subq.w	#1,d7	adda.l	#1,A3	adda.l	#1,A4nextcharStringsEqual:	move.b		(A3)+,D3 //;getchar in string	cmp.b		#65,D3	blt		otherc	cmp.b		#90,D3	bgt		checkunder	add.b		#32,D3    //;turning to upper case letter	bra 		otherccheckunder:			cmp.b		#95,D3	//;turning underline to blank	bne		otherc	move.b		#32,D3otherc:	move.b		(A4)+,D4 //;getchar in string	cmp.b		#65,D4	blt		comc	cmp.b		#90,D4	bgt		checkunder4	add.b		#32,D4    //;turning to upper case letter	bra 		comccheckunder4:			cmp.b		#95,D4	//;turning underline to blank	bne		comc	move.b		#32,D4comc:	cmp.b		D3,D4	//;comparing character	bne		notsame	dbra	d7,nextcharStringsEqual	move.w		#257,D0	bra donestringsEqual	notsame:	move.w		#0,D0donestringsEqual:	movem.l		(SP)+,A3/A4/D3-D7	unlk		A6	movea.l		(SP)+,A0	//$$adda.l		#10,SP	jmp		(A0)	}//;#############################//;pass to comparePointer 2 more booleans: MustBeIdentical, ExamineExcluded}//;if MustBeIdentical is true, then ComparePointer returns true iff all states are absolutely identical,}//;otherwise returns true iff }//;1: states are identical}//;2: one is missing, the other is not}//;4: one and only one is uncertain, and the certain one is a subset of the uncertain one}//;5: they are both uncertain, and the intersection of the two exists }//;if ExamineExcluded is true, then examine all numchars characters//; otherwise, examine only}//;those that are included//; for these purposes, one needs also to pass to ComparePointer a pointer}//;to the character types}//;function ComparePointers (ctypP: ptr, mustbeidentical,examineexcluded: boolean//; numbytes: integer//; src, dest: Ptr//; numchars: integer): boolean//;//; numbytes is 2 or 4//;FROZEN 3.0asm boolean ComparePointers (long ctypP, boolean mustbeidentical, boolean examineexcluded, short nummbytes, long src, long dest, short numchars)// asm	boolean  ComparePointers (long ctypP 8, boolean mustbeidentical 12, boolean examineexcluded 14, short numbytes 16, //									long src 18, long dest 22 , short numchars 26){	link		A6,#0     	movem.l		A1-A3/D1-D4/D7,-(SP)   		move.l		8(A6),A3 		//;ctype storage	move.w		12(A6),D4		//;mustbeidentical	move.w		14(A6),D3		//;examineexcluded	move.l		18(A6),A1 		//;place in A1 the starting address of src	move.l		22(A6),A2		//; place in A2 the dest	clr			D7	move.w		26(A6),D7		//;number of characters in d7	subq.w		#1,D7		btst		#8,D4 	beq		NOTNeedIdent	MUSTBEIDENT:	move.w		16(A6),D1 		//;if 4 bytes then do 4 byte cycle	cmp.w		#4,D1 		//;if 4 bytes then do 4 byte cycle	beq		L4ident//;	* == now start moving along string until done ====L2ident:	move.w		(A1)+,D1	move.w		(A2)+,D2	btst		#8,D3	//;are excludeds to be examined 	bne		Examine2	move.w		(A3)+,D4	cmp.w		#255,D4	beq		NextWordI //; is excluded, go to nextExamine2:	and.w		#-19457,D1  //;#-19457 = [0..9, 12, 13, 15]	and.w		#-19457,D2	cmp.w		D1,D2	bne		NotEqCmpNextWordI:	dbra		D7,L2ident	move.w	#257,D0	bra		DoneCmpPtr	L4ident:	move.l		(A1)+,D1	move.l		(A2)+,D2	btst		#8,D3	//;are excludeds to be examined 	bne		Examine4	move.w		(A3)+,D4	cmp.w		#255,D4	beq		NextLongI //; is excluded, go to nextExamine4:	and.l		#-1275068417,D1  //;#-1275068417 = [0..25, 28,29, 31]	and.l		#-1275068417,D2	cmp.l		D1,D2	bne		NotEqCmpNextLongI:	dbra		D7,L4ident	move.w	#257,D0	bra		DoneCmpPtr	NOTNeedIdent:	move.w		16(A6),D1 		//;if 4 bytes then do 4 byte cycle	cmp.w		#4,D1 		//;if 4 bytes then do 4 byte cycle	beq		L4nodent	//;* == now start moving along string until done ====L2nodent:	move.w		(A1)+,D1	move.w		(A2)+,D2	btst		#8,D3	//;are excludeds to be examined 	bne		Examine2n	move.w		(A3)+,D4	cmp.w		#255,D4	beq		nextword //; is excluded, go to nextExamine2n://;1: states are identical}//;2: at least one is missing}//;3: one and only one is uncertain, and the certain one is a subset of the uncertain one}//;4: they are both uncertain, and the intersection of the two exists }	and.w		#-19457,D1  //;#-19457 = [0..9, 12, 13, 15]	and.w		#-19457,D2	cmp.w		D1,D2	beq		nextword  //;{identical, therefore passes}//; if D1 is a subset of D2 or D2 is a subset of D1 the nextword (because of UC this takes care of 3,4	move.w		D1,D4		//;move d1 into scrap	or.w		D2,D4		//;union of d1 and d2	btst		#12,D4		//; check if one has gap 	beq			CmpCkMissing	//; no gap, go on	move.w		D1,D4		//;move d1 into scrap	and.w		D2,D4		//;intersection of d1 and d2	btst		#15,D4			bne		nextword  //;both have missing, therefore other is missing and passes	bra 		NotEqCmp	//; other not missing, therefore failsCmpCkMissing:	bne			NotEqCmp	//;   (other doesn't, else would be identical//; therefore fail}	btst		#15,D4		//; one is missing, therefore pass	bne		nextword	btst		#13,D4		beq		NotEqCmp	//; neither uncertain, therefore fail	move.w		D1,D4	//; make intersection	and.w		D2,D4	bclr		#13,D4			beq		onecert2	//;intersection did not have UC//; therefore at least one certain	tst.w		D4	//; both uncertain//; therefore pass if intersection exists	bne	nextword	bra		NotEqCmponecert2:	cmp.w		D4,D1	//;intersection of two sets must equal the certain one	beq		nextword	cmp.w		D4,D2		beq		nextword	bra		NotEqCmp	nextword:	dbra		D7,L2nodent	move.w	#257,D0	bra		DoneCmpPtr	L4nodent:	move.l		(A1)+,D1	move.l		(A2)+,D2	btst		#8,D3	//;are excludeds to be examined 	bne		Examine4n	move.w		(A3)+,D4	cmp.w		#255,D4	beq		nextlongword //; is excluded, go to nextExamine4n:	and.l		#-1275068417,D1  //;#-1275068417 = [0..25, 28,29, 31]	and.l		#-1275068417,D2	cmp.l		D1,D2	beq		nextlongword  //;{identical, therefore passes}//; if D1 is a subset of D2 or D2 is a subset of D1 the nextword (because of UC this takes care of 3,4	move.l		D1,D4		//;move d1 into scrap	or.l		D2,D4		//;union of d1 and d2	btst		#28,D4		//;check if one has gap (if one does, then other doesn't, otherwise identical, and fails unless other is missing)	beq			CmpCkMissing4	//;if one has gap and other has missing then OK	move.l		D1,D4		//;move d1 into scrap	and.l		D2,D4		//;intersection of d1 and d2	btst		#31,D4			bne		nextlongword  //;both have missing, therefore other is missing and passes	bra		NotEqCmp	//; other not missing, therefore failsCmpCkMissing4:	btst		#31,D4		//; one is missing, therefore pass	bne		nextlongword	btst		#29,D4		beq		NotEqCmp	//; neither uncertain, therefore fail	move.l		D1,D4	//; make intersection	and.l		D2,D4	bclr		#29,D4			beq		onecert4	//;intersection did not have UC//; therefore at least one certain	tst.l		D4	//; both uncertain//; therefore pass if intersection exists	bne	nextlongword	bra		NotEqCmponecert4:	cmp.l		D4,D1	//;intersection of two sets must equal the certain one	beq		nextlongword	cmp.l		D4,D2		beq		nextlongword	bra		NotEqCmpnextlongword:	dbra		D7,L4nodent	move.w	#257,D0	bra		DoneCmpPtrNotEqCmp:	move.w	#0,D0DoneCmpPtr:	movem.l		(SP)+,A1-A3/D1-D4/D7	unlk		A6	movea.l		(SP)+,A0	//$$adda.l		#20,SP	jmp		(A0)}//;===================================================//;procedure ConcatStringChar (s: ptr//; ch: char)//;//;							12		8//;FROZEN 3.0asm	void  ConcatStringChar (long s, short ch){	link		A6,#0    	movem.l		A4/D1/D2,-(SP)              	clr.l		D2		movea.l		8(A6),A4	//;moving string ptr into A4	move.b		(A4),D2	//;get length of string	cmp.b		#-1,D2	//;compare against 255	beq		quitconcat	move.b		13(A6),D1   //;move  char into D1	addq.b		#1,D2	//;bumping up length	move.b		d2,(A4)	//;move length back in storage	adda.l		D2,A4	//;go to last place	move.b		D1,(A4)	//; put in characterquitconcat:	movem.l		(SP)+,A4/D1/D2	unlk		A6	movea.l		(SP)+,A0	//$$ addq.l		#6,SP	jmp		(A0)}//;=========//;procedure getNodeTokenC (var descP: ptr//; token: ptr)//; 12, 8//;FROZEN 3.0asm	void  GetNodeTokenC (long descP,long  token){	link		A6,#0    	movem.l		A2/A3/A4/D2/D3,-(SP)              	movea.l		12(A6),A4	//;moving destination ptr into A4	movea.l		8(A6),A2	//;get ptr to descP	movea.l		(A2),A3		//; moving descP into A3	clr.w		D2	//;initializing length of destination to 0#define colon  58#define space  32#define return  13#define linefeed  10#define tab  9#define rtparen  41#define lfparen  40#define comma  44#define semicolon  59#define quote  39	addq.l	#1,A3 //; go to next char in source	addq.l	#1,A4 //; go to first char in tokenfirstdarkchar:	move.b	(A3)+,D3 //;get next source char	cmp.b	#colon,D3	//; see if colon	bne	pastcolonskiptoPunc:	move.b (A3)+,D3	cmp.b	#rtparen,D3  //; check against '(//;,)'//;	beq	singlechartoken	cmp.b	#comma,D3  	beq	singlechartoken	cmp.b	#lfparen,D3 	beq	singlechartoken	cmp.b	#semicolon,D3  	bne	skiptoPunc	bra singlechartokenpastcolon:	cmp.b	#space,D3  //; check against blank,tab,return//;	beq	firstdarkchar	cmp.b	#tab,D3  	beq	firstdarkchar	cmp.b	#return,D3 	beq	firstdarkchar	cmp.b	#linefeed,D3 	beq	firstdarkchar	cmp.b	#rtparen,D3  //; if in s1 := '(//;,)' then singlechartoken//;	beq	singlechartoken	cmp.b	#comma,D3  	beq	singlechartoken	cmp.b	#lfparen,D3 	beq	singlechartoken	cmp.b	#semicolon,D3  	beq	singlechartoken	bra 	checkquotesinglechartoken:	move.b D3,(A4)+ //;put in token	move.w	#1,D2	subq.l	#1,A3 //;back up so sitting on last char	bra donegetnode	checkquote:	cmp.b	#quote,D3	bne	tokentilwhite	subq.w	#1,D2	//;subtract 1 from eventual string because of final quoteaddchartotoken:	move.b (A3)+,D3  //; get next char in quotes	move.b D3,(A4)+ //; add to token	addq.w	#1,D2	//;bump up length of token	cmp.b	#quote,D3 //;check if added was quote	bne	addchartotoken	//; not quote so go on	move.b  (A3),D3	//;if was quote check if next is quote	cmp.b	#quote,D3 //;check if second quote 	bne	donegetnode	//;wasn't second quote, thus done//; last quote effectively not added	adda.l	#1,A3	//;skip past second quote	bra addchartotoken //; otherwise was double quote, thus continue//;addchartotoken//;	move.b D3,(A4)+ //; add to token//;	addq.w	#1,D2	//;bump up length of token//;	move.b (A3)+,D3 //; get next char//;	cmp.b	#quote,D3 //;check if end quote //;	bne	addchartotoken//;	move.b  (A3)+,D3	//;if seems to be end quote then get next char//;	cmp.b	#quote,D3 //; if adjacent quote then is literal quote add and go on//;	beq	addchartotoken//;	subq.l	#1,A3 //;back up so sitting on last char//;	bra donegetnode	tokentilwhite:	move.b D3,(A4)+ //; add to token	addq.w	#1,D2	//;bump up length of token	move.b  (A3)+,D3 //; get next char		cmp.b	#rtparen,D3  //; if not in blank,tab,return,' )(,://;' then keep cycling//;	beq	endofnodetoken	cmp.b	#comma,D3  	beq	endofnodetoken	cmp.b	#colon,D3		beq	endofnodetoken	cmp.b	#semicolon,D3  	beq	endofnodetoken	cmp.b	#space,D3  	beq	endofnodetoken	cmp.b	#tab,D3  	beq	endofnodetoken	cmp.b	#return,D3 	beq	endofnodetoken	cmp.b	#linefeed,D3 	beq	endofnodetoken	cmp.b	#lfparen,D3 	beq	endofnodetoken	bra 	tokentilwhiteendofnodetoken:	subq.l	#2,A3 //;back up so sitting on last char	donegetnode:	move.l		A3,(A2)		//; returning new value of descP	movea.l		12(A6),A4	//;moving destination ptr into A4	move.b	D2,(A4)		//;moving string length into A4	movem.l		(SP)+,A2/A3/A4/D2/D3	unlk		A6	movea.l		(SP)+,A0	//$$addq.l		#8,SP	jmp		(A0)}//;===========================================================================//;//;function multaddC (n, l,r: longint): longint//;//;FROZEN 3.0asm	long multaddC (long a, long b, long c){	link		A6,#0 //; reserve local stack area	movem.l		D1-D6,-(SP)  //; save onto stack	move.l		16(A6),D3	//; rp^	move.l		12(A6),D2	//; lp^	//; if rp or lp are 0 then out	tst.l	D3	bne 	check0L	move.l		8(A6),D1	//; npp^	bra	donecheck0L:	tst.l	D2	bne 	check1R	move.l		8(A6),D1	//; npp^	bra	done	check1R://; if rp or lp are 1 then use other directly	cmpi.l	#1,D3	bne 	check1L	move.l		D2,D6	bra	gooncheck1L:	cmpi.l	#1,D2	bne 	multiply	move.l		D3,D6	bra	goonmultiply://;multiplying lp^ and rp^ together	move.l	D2,D6	//;moving first loword	mulu	D3,D6  //;low l/low r multiplication		move.l	D2,D4	//;moving whole word in from l	lsr.l	#8,D4	//;shifting highword of D4 down	lsr.l	#8,D4	//;shifting highword of D4 down	move.l	D3,D5  //;moving loword from r	mulu	D4,D5  //;low r/high l multiplication	cmpi.l	#32768,D5	//;check to see if any bits into high word	blt	goon0	move.l	#-1,D1	bra	done	goon0:	lsl.l	#8,D5	//;shifting result up	lsl.l	#8,D5	//;shifting result up	add.l	D5,D6	//;add to count	bvc	goon1	move.l	#-2,D1	bra	done	goon1:	move.l	D3,D1	//;moving whole word in from r	lsr.l	#8,D1	//;shifting highword of D1 down	lsr.l	#8,D1	//;shifting highword of D1 down	move.l	D2,D5  //;moving loword from l	mulu	D1,D5  //;low l/high r multiplication	cmpi.l	#32768,D5	//;check to see if any bits into high word	blt		goon2	move.l	#-3,D1	bra	done	goon2:	lsl.l	#8,D5	//;shifting result up	lsl.l	#8,D5	//;shifting result up	add.l	D5,D6	//;add to count	bvc		goon3	move.l	#-4,D1	bra	done	goon3:	tst.w	D1  //;checking to see that not 1's in both D3 and D4 highwords	beq		goon	tst.w	D4	beq		goon	move.l	#-5,D1	bra	done	goon://;adding lp^*rp^ to npp^	move.l		8(A6),D1	//; npp^	add.l	D6,D1	//;	bvc	done	move.l	#-6,D1	done:	move.l		D1,D0	//;returning function	movem.l		(SP)+,D1-D6  //;Restore d6/D7 from stack	unlk		A6	movea.l		(SP)+,A0	//$$add.l		#12,SP	jmp		(A0)}//;-------------------------------------------------//; function RandomPosLong(var seed: longint)//;//; given seed, returns random number (positive longinteger)//; as changed seed and function result//; From Dave Swofford, same as in PAUP//; translated from C by me//;x(i) = A * x(i-1) * mod (2**31 - 1).//;	It is recommended that the multiplier A be set to 397204094. asm	long RandomPosLong (long *seed){	link		A6,#0 //; reserve local stack area	movem.l		A4/D1-D7,-(SP)  //; save registers onto stack	movea.l		8(A6),A4	//;get seed's address//;====multiply multiplier (397204094) by seed ==========//;multiplier used=A= #397204094 = $17ACDA7E#define lowA  55934  //; lowword of A (DA7E)#define hiA  6060  //; hiword of A (17AC)#define x  D1#define y  D2#define o  D7#define ShiftAmount  D6//; to generate 64 bit result in two pieces, x and y//; ab x cd  = mnop  = xy//; a  x c   = kl--//; a  x  d  = -gh-//;  b x c   = -ij-//;  b x  d  = --ef	move.w	#16,ShiftAmount	//;with low word of seed	move.l	(A4),D3		//; getting copy of lowword of seed	andi.l	#0x00FFFF,D3		//; saving lowbits//; clearing highbits	move.l	D3,x		//; save copy of lowword of seed (=d)	mulu	#lowA,x	//;  b x  d  = --ef	move.l	x,o	lsr.l	ShiftAmount,o		//; getting e	andi.l	#0x000FFFF,x		//; getting f	mulu	#hiA,D3		//; a  x  d  = -gh-	move.l	D3,y		//; save copy a*d 	lsr.l	ShiftAmount,y		//; get g,  start running total of high (now g)	andi.l	#0x000FFFF,D3			add.l	D3,o	//;with high word of seed	move.l  (A4),D4		//; get seed again	lsr.l	ShiftAmount,D4			move.l	D4,D3		//; save hiword of seed (=c)		mulu	#lowA,D4	//;  b x c   = -ij-	move.l	D4,D5		//; save copy c*b	andi.l	#0x000FFFF,D4			add.l	D4,o		lsr.l	ShiftAmount,D5		//; get i			add.l	D5,y		//; add i to running total of high (now g+i) 		mulu	#hiA,D3		//; a  x c   = kl--	add.l	D3,y		//; add kl to running total of high (new g+i+kl,complete)	move.l	o,D5	//;get copy of e+h+j	lsl.l	ShiftAmount,D5		//; get e+h+j to add to x	add.l	D5,x		lsr.l	ShiftAmount,o			add.l	o,y	//;add carries into y//; multiplication of A and seed complete.  Results stored in x (lowLongword) and //;  y (hiLongword)//; shift y to left one, x to right 31, and or.l two results and place in y//;   y = (y << 1) | (x >> 31)//;		/* isolate high-order 31 bits *///;	LSL.l	#1,y		//; shift y one to left//;	move.l	x,D3	//; get copy of x//;	move.l	#31,ShiftAmount	//; put shift value in register//;	lsr.l	ShiftAmount,D3	//; shift x to right//;	or.l	D3,y	//; or D3 and y//;EDITORIAL COMMENT: could not the above be accomplished in the following//; speedier way (given slowness of logical shift by 31):	LSL.l	#1,y		//; shift y one to left	btst	#31,x	//; check if upper bit of x is set	beq	pastbit31x		//; bit was not set, just go on	bset	#0,y	//; if 31 bit in x had been set, place it in 0 position of ypastbit31x:	//; shift x to left 1, then to right 1, and store in x//;  x = (x << 1) >> 1//;				/* isolate low-order 31 bits *///;	lsl.l	#1,x  //; EDITORIAL COMMENT: why not just bclr	#31,x instead of these two statements?//;	lsr.l	#1,x	bclr	#31,x	//;   x += y//;						/* x'(i + 1) unless overflows */	add.l	y,x	//;	if (x & 0x80000000) 			/* overflow check TEST uppermostbit*/	btst	#31,x	beq	afteroverflow			//;if bit is not there then no overflow//;    then x -= M//;				/* deal with overflow */	sub.l	#2147483647,x		//;afteroverflow:	move.l	x,(A4)	move.l	x,D0  //; return also as function result	movem.l		(SP)+,A4/D1-D7  //;Restore registers from stack	unlk		A6	movea.l		(SP)+,A0	//$$addq.l		#4,SP	jmp		(A0)	}//;-------------------------------------------------//; function RandomInteger(var seed: longint)//;//; given seed, returns random number (positive longinteger)//; as changed seed and function result//; From Dave Swofford, same as in PAUP//; translated from C by me//;x(i) = A * x(i-1) * mod (2**31 - 1).//;	It is recommended that the multiplier A be set to 397204094. asm	short RandomInteger (long *seed){	link		A6,#0 //; reserve local stack area	movem.l		A4/D1-D7,-(SP)  //; save registers onto stack	movea.l		8(A6),A4	//;get seed's address//;====multiply multiplier (397204094) by seed ==========//;lowbits EQU 65535   //;  [0..15]//;hibits EQU -65536   //;[16..31]//;multiplier used=A= #397204094 = $17ACDA7E//;lowa EQU 55934  //; lowword of A (DA7E)//;hiA EQU 6060  //; hiword of A (17AC)//;X EQU D1//;y EQU D2//;o EQU D0//;ShiftAmount EQU D6//; to generate 64 bit result in two pieces, x and y//; ab x cd  = mnop  = xy//; a  x c   = kl--//; a  x  d  = -gh-//;  b x c   = -ij-//;  b x  d  = --ef		move.w	#16,ShiftAmount	//;with low word of seed	move.l	(A4),D3		//; getting copy of lowword of seed	andi.l	#0x00FFFF,D3		//; saving lowbits//; clearing highbits	move.l	D3,x		//; save copy of lowword of seed (=d)	mulu	#lowA,x	//;  b x  d  = --ef	move.l	x,o	lsr.l	ShiftAmount,o		//; getting e	andi.l	#0x00FFFF,x		//; getting f	mulu	#hiA,D3		//; a  x  d  = -gh-	move.l	D3,y		//; save copy a*d 	lsr.l	ShiftAmount,y		//; get g,  start running total of high (now g)	andi.l	#0x00FFFF,D3			add.l	D3,o	//;with high word of seed	move.l  (A4),D4		//; get seed again	lsr.l	ShiftAmount,D4			move.l	D4,D3		//; save hiword of seed (=c)		mulu	#lowA,D4	//;  b x c   = -ij-	move.l	D4,D5		//; save copy c*b	andi.l	#0x00FFFF,D4			add.l	D4,o		lsr.l	ShiftAmount,D5		//; get i			add.l	D5,y		//; add i to running total of high (now g+i) 		mulu	#hiA,D3		//; a  x c   = kl--	add.l	D3,y		//; add kl to running total of high (new g+i+kl,complete)	move.l	o,D5	//;get copy of e+h+j	lsl.l	ShiftAmount,D5		//; get e+h+j to add to x	add.l	D5,x		lsr.l	ShiftAmount,o			add.l	o,y	//;add carries into y//; multiplication of A and seed complete.  Results stored in x (lowLongword) and //;  y (hiLongword)//; shift y to left one, x to right 31, and or.l two results and place in y//;   y = (y << 1) | (x >> 31)//;		/* isolate high-order 31 bits *///;	LSL.l	#1,y		//; shift y one to left//;	move.l	x,D3	//; get copy of x//;	move.l	#31,ShiftAmount	//; put shift value in register//;	lsr.l	ShiftAmount,D3	//; shift x to right//;	or.l	D3,y	//; or D3 and y//;EDITORIAL COMMENT: could not the above be accomplished in the following//; speedier way (given slowness of logical shift by 31):	LSL.l	#1,y		//; shift y one to left	btst	#31,x	//; check if upper bit of x is set	beq	pastbit31xINT		//; bit was not set, just go on	bset	#0,y	//; if 31 bit in x had been set, place it in 0 position of ypastbit31xINT:	//; shift x to left 1, then to right 1, and store in x//;  x = (x << 1) >> 1//;				/* isolate low-order 31 bits *///;	lsl.l	#1,x  //; EDITORIAL COMMENT: why not just bclr	#31,x instead of these two statements?//;	lsr.l	#1,x	bclr	#31,x	//;   x += y//;						/* x'(i + 1) unless overflows */	add.l	y,x	//;	if (x & 0x80000000) 			/* overflow check TEST uppermostbit*/	btst	#31,x	beq	afteroverflowINT			//;if bit is not there then no overflow//;    then x -= M//;				/* deal with overflow */	sub.l	#2147483647,x		//;afteroverflowINT:	move.l	x,(A4)	move.w	x,D0  //; return only lowword as function result	movem.l		(SP)+,A4/D1-D7  //;Restore registers from stack	unlk		A6	movea.l		(SP)+,A0//$$	addq.l		#4,SP	jmp		(A0)	}