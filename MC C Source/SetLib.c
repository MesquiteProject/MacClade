/* ; general Library for set manipulations *//* ; contains union, intersection, min, max, cardinality and span functions,;[0..9],#1023;;[0..15];#65535;;[0..25];#67108863;[10..15];#64512;[16..31];#-65536;[26..31];#-67108864*/#include <stdio.h> //admestina#include "CCode.h"/*#define set32  unsigned long#define set16  unsigned short#define int16  short#define int32  long#define set09 1023#define set025 67108863 */short setbound15S;long setbound15L;long setbound31;/* prototypes */pascal set32 Union2(set32 s2, set32 s1);pascal set32 SubtractSets (set32 s1, set32 s2);pascal set32 Union3 (set32 s1, set32 s2, set32 s3);pascal set32 Intersect2 (set32 s1, set32 s2);pascal set32 Intersect3 (set32 s1, set32 s2, set32 s3);pascal set32 Un3ofInt2 (set32 s1, set32 s2, set32 s3);pascal set32 UnordOperator2 (set32 s1, set32 s2);pascal set32 UnordOperator3 (set32 s1, set32 s2, set32 s3);pascal unsigned int16  StateInSet (int32 s1, set32 s2);pascal unsigned int16  EmptySet (set32 s1);pascal unsigned int16  EqualSets (set32 s1, set32 s2);pascal set32 MakeSet (int32 i);pascal set32 MakeSpan (int32 i, int32 j);pascal set32 SetfromMin (set32 s);pascal set32 AddToSet (set32 s, unsigned int32 i);  pascal set32 SubtractFromSet (set32 s, int32 i);   pascal unsigned int16 EnSet (int32 i, set32 s);   pascal void ZeroHighBits31 (set32 *s);/*pascal set32 NewSetFromOld (set32 s);pascal set32 OldSetFromNew (set32 s); */pascal int32 MinG (set32 s);pascal int32 MaxG (set32 s);pascal int32 MinP (set32 *sp32, int32 slength);pascal int32 MaxP (set32 *sp32, int32 slength);pascal int32 MinLg (set32 spt);  //ptr to avoid set passing problemspascal int32 MaxLg (set32 spt); //ptr to avoid set passing problemspascal void MinMaxOfSet (set32 spt, int32 *minL, int32 *maxL);pascal void MaxMinLg (set32 spt, int16 *minL, int16 *maxL);pascal int32 CardLg  (set32 spt);pascal int32 Cardinality  (set32 spt);pascal unsigned int16 MultipleStatesLg (set32 spt);pascal unsigned int16 MonomorphLg (set32 spt);pascal int32 CardG  (set32 s);pascal int32 CardP (set32 *s, int32 slength);pascal int32 CardFrom (set32 *s, int32 slength);pascal unsigned int16 MultipleStatesG (set32 s);pascal unsigned int16 MonomorphG (set32 s);pascal set32 cOldSetFromNew  (set32 s);pascal set32 cOldSetFromNew  (set32 s){	return s;}pascal set32 cNewSetFromOld  (set32 s);pascal set32 cNewSetFromOld  (set32 s){	return s;}/*===================================================*/	/*PROCEDURE SetStateSetBoundaries (smallest: boolean);resets setbound, the replacement for set025 */pascal	void  SetStateSetBoundaries (char smallest)// 0..19 is 1048575// 0..20 is 2097151// 0..21 is 4194303// 0..22 is 8388607// 0..23 is 16777215// 0..24 is 33554431// 0..25 is 67108863// 0..26 is 134217727{ 	if (smallest) //then we want a full set025, otherwise set020		{		setbound31 = 1048575L; //set023;  		setbound15L = 255L; //set07;		setbound15S = 255; //set07;		}	else		{		setbound31 = 67108863L; //set025;		setbound15L = 1023L; //(set09)		setbound15S = 1023; //set09		} }//;=========================================================================== admestinapascal set32 set15to31C (set16 *s);pascal set32 set15to31C (set16 *s){ 	set32 shigh = (*s);	set32 slow = shigh;	set32 r;	slow=(slow & setbound15L) ;	r=((shigh << 16) & ~setbound31);//printf("set15to31C s %i  shigh %i slow %i  high shifted %i  return %i\n", *s, shigh, slow, r, r|slow);	return (r|slow);}//;=========================================================================== admestinapascal set16 set31to15C (set32 *s);pascal set16 set31to15C (set32 *s) {	set32 highbits = (*s) & ~setbound31;	set16* sP = (set16 *)(&highbits);	set16 shigh =(*sP);	set16 slow;	sP=(set16 *)(s);	sP++;	slow = (*sP)& ((set16)setbound15S);//printf("set31to15C s %i  shigh %i slow %i return %i\n", (*s), shigh, slow, shigh|slow);	return (shigh|slow);}//pascal void set15to31 (set16 *s, set32 *r);  //pascal void set31to15 (set32 *s, set16 *r);pascal set32 ReflectSet31 (set32 s);pascal set32 ReflectSet31 (set32 s){set32 stemp= s;return(s);}/*===================================================*/	/*function Union2 (s1, s2: lgsetchars): lgsetchars;		returns union of two 4-byte sets */pascal set32 Union2(set32 s2, set32 s1){ return (s1|s2); }/*===================================================*/	/*function SubtractSets (s1, s2: lgsetchars): lgsetchars; 		returns s1-s2 */pascal set32 SubtractSets (set32 s1, set32 s2){ return(s1 & ~s2); }/*===================================================*/	/*function Union3 (s1, s2, s3: lgsetchars): lgsetchars; 		returns union of three 4-byte sets */pascal set32 Union3 (set32 s1, set32 s2, set32 s3){ return(s1 | s2 | s3); }/*===================================================*/	/*function Intersect2 (s1, s2: lgsetchars): lgsetchars; 		returns intersection of two 4-byte sets */pascal set32 Intersect2 (set32 s1, set32 s2){ return(s1 & s2); }/*===================================================*/	/*function Intersect3 (s1, s2, s3: lgsetchars): lgsetchars;  		returns intersection of three 4-byte sets */pascal set32 Intersect3 (set32 s1, set32 s2, set32 s3){ return(s1 & s2 & s3); }/*===================================================*/	/*function StateInSet (s1: integer; s2: largestsetchars): boolean; 		returns if state s1 is in set s2 */pascal  unsigned int16   StateInSet (int32 s1, set32 s2){if (s2 & ((set32)1 <<s1))return(257); /* or ~0*/elsereturn(0);}/*===================================================*/	/*function EmptySet (s1: largestsetchars): boolean; 		returns if set is empty */pascal  unsigned int16   EmptySet (set32 s1){ if (s1==0) 	return 257;else	return 0; }/*===================================================*/	/*function EqualSets (s1, s2: largestsetchars): boolean; 		returns if two sets are the same */pascal  unsigned int16   EqualSets (set32 s1, set32 s2){ if (s1 == s2) 	return 257;   else   	return 0; }/*===================================================*/	/*function Un3ofInt2 (s1, s2, s3: lgsetchars): lgsetchars;  		returns union of pairwise intersections of three 4-byte sets */pascal set32 Un3ofInt2 (set32 s1, set32 s2, set32 s3){ return((s1 & s2) | (s1 & s3) |(s2 & s3)); }/*===================================================*/	/*function UnordOperator2 (s1, s2: lgsetchars): lgsetchars; */pascal set32 UnordOperator2 (set32 s1, set32 s2){ set32 s;if ((s = (s1 & s2)) == 0) 	s = s1 | s2;return(s); }/*===================================================*/	/*function UnordOperator3 (s1, s2, s3: lgsetchars): lgsetchars; */pascal set32 UnordOperator3 (set32 s1, set32 s2, set32 s3){ set32 s;if ((s = (s1 & s2 & s3)) == 0) 	if ((s = ((s1 & s2) | (s1 & s3) |(s2 & s3))) == 0)		 s = s1 | s2 | s3;return(s); }/*===================================================*/	/*function MakeSet (i1: integer): lgsetchars; 		returns set equal to [i1] */pascal set32 MakeSet (int32 i){ return (1L << i);}/*===================================================*/	/*function MakeSpan (i1, i2: integer): lgsetchars;		returns set = [i1..i2] */pascal set32 MakeSpan (int32 i, int32 j){if (i>j)return((~(~0L << (i+1))) & (~0L << j));elsereturn((~(~0L << (j+1))) & (~0L << i));}/*===================================================*/	/*function AddToSet (s1: lgsetchars; i1: integer): lgsetchars;	returns set consisting of union of s1 and [i1] */pascal set32 AddToSet (set32 s, unsigned int32 i){return (s | (1L << i));} //was return (s | ((set32)1 << i));/*===================================================*/	/*function SubtractFromSet (s1: lgsetchars; i1: integer): lgsetchars;	returns set consisting of s1 - [i1] */pascal set32 SubtractFromSet (set32 s, int32 i){return (s & (~(1L << i))); //was return (s & (~((set32)1 << i)));}/*===================================================*/	/*function EnSet (i1: integer; s1: lgsetchars): boolean;;		returns whether or not i1 is in set s1 */pascal unsigned int16 EnSet (int32 i, set32 s){if (s & (1L << i))return(257); /* or ~0*/elsereturn(0);}//;===========================================================================/* pascal set32 set15to31 (set16 s); pascal set32 set15to31 (set16 s){ 		set32 shigh = s;	set32 slow = shigh & setbound15;	shigh = (shigh& ~setbound15)<< 16;	return (shigh|slow);	set32 shigh = 0;	set16* sP = ((set16*)(&shigh));	set32 slow;	sP++;	(*sP) = s;		slow = shigh;	slow=(slow & setbound15) ;	shigh=((shigh << 16) & ~setbound31);	return (shigh|slow);}/**///;===========================================================================/* pascal set16 set31to15 (set32 s); pascal set16 set31to15 (set32 s){ 		set16* sP = (set16*)(&s);	set16 shigh = (*sP++)& ~setbound15;	set16 slow = (*sP)& setbound15;	return (shigh|slow);}*//*===================================================*/	/*function ZeroHighBitsLg (s1: largestsetchars): largestsetchars;	returns set with high bits zeroed */pascal void ZeroHighBits31 (set32 * s){//printf("zhbl s %i s&025 %i \n", *s, (*s) & setbound31); (*s) &= setbound31;}	/*===================================================*/	/*function SetfromMin (s1: lgsetchars): lgsetchars;	returns set containing only minimum value of s1	if s1 is empty, returns empty set */pascal set32 SetfromMin (set32 s){s &= setbound31;if (s == 0 )	return (0);else	{	set32 b=1;	while ((s & b)==0)		b <<= 1;	return b;	}}/*===================================================*/	/*function NewSetFromOld (s1: largestsetchars): lgsetchars;	this function coerces old pascal set into new storage *//*pascal set32 NewSetFromOld (set32 s){return(s);}/*===================================================*/	/*function OldSetFromNew (s1: lgsetchars): largestsetchars;	coerces new storage set into old pascal set *//*pascal set32 OldSetFromNew (set32 s){return(s);}/*===================================================*/	/*FUNCTION MinG (s : lgsetchars) : integer; */pascal int32 MinG (set32 s){s &= setbound31;if (s == 0 ) return (30);else	{ set32 b = 1; int m = 0;	while ((s & b)==0)		{ b <<= 1; m++; } 	return m; }}	/*FUNCTION MinLg (s : largestsetchars) : integer; */	/* 30 is errorvalue */pascal int32 MinLg (set32 spt){set32 s=(spt);s &= setbound31;if (s == 0 )	return (30);else	{	set32 b = 1;	int m = 0;		while ((s & b)==0)		{		b <<= 1;		m++; 		} 	return m;	}}/*===================================================*/	/*FUNCTION MaxG (s : lgsetchars) : integer; */pascal int32 MaxG (set32 s){s &= setbound31;if (s == 0 ) return (30);else	{ set32 b = 1; int m = 0;	while ((s &= ~b) != 0)		{ b <<= 1; m++;  } 	return m; }}/*===================================================*/	/*FUNCTION MaxLg (s : largestsetchars) : integer;	returns maximum value in s, 30 if empty from 0 to 26	Previously this procedure started at 25 and counted	down until first bit found.  Now it starts from 0 and clears bits	until last bit is cleared */pascal int32 MaxLg (set32 spt){set32 s=(spt);s &= setbound31;if (s == 0 )	return (30);else	{	set32 b = 1;	int m = 0;		while ((s &= ~b) != 0)		{		b <<= 1;		m++; 		} 	return m;	}}/*===================================================*/pascal void MinMaxOfSet (set32 spt, int32 *minL, int32 *maxL){set32 s=(spt);int16 min;int16 max;s &= setbound31;if (s == 0 )	{min = 30; max = 30;}else	{	set32 b = 1;	min = 0;		while ((s & b)==0)  /*finding minimum*/		{		b <<= 1;		min++; 		} 	max = min;	while ((s &= ~b) != 0)		{		b <<= 1;		max++; 		} 	}*minL = min;*maxL = max;}/*===================================================*/	/*FUNCTION MaxMinLg (s : largestsetchars, var minL,maxL:integer);	returns min and max values in set, 30 if empty from 0 to 25 */pascal void MaxMinLg (set32 spt, int16 *minL, int16 *maxL){set32 s=(spt);int16 min;int16 max;s &= setbound31;if (s == 0 )	{min = 30; max = 30;}else	{	set32 b = 1;	min = 0;		while ((s & b)==0)  /*finding minimum*/		{		b <<= 1;		min++; 		} 	max = min;	while ((s &= ~b) != 0)		{		b <<= 1;		max++; 		} 	}*minL = min;*maxL = max;}/*===================================================*/	/*FUNCTION MinP (s : ptr; slength: integer) : integer;; for set at address s of length slength (15 or 31), returns minimum value;	or 14/30 if empty */pascal int32 MinP (set32 *sp32, int32 slength){if (slength==15)	{	typedef set16 *ptr16;	set16 s16;	s16 = (*((ptr16) sp32)) & setbound15S;	if (s16 == 0 )		return (14);	else	{		set16 b = 1;		int m = 0;			while ((s16 & b)==0)			{			b <<= 1;			m++; 			} 		return m;	}		}else	{	set32 s32 = (*sp32) & setbound31;	if (s32 == 0)		return (30);	else		{		set32 b = 1;		int m = 0;			while ((s32 & b)==0)			{			b <<= 1;			m++; 			} 		return m;		}	}}/*===================================================*/	/*FUNCTION MaxP (s : ptr; slength: integer) : integer;; for set starting at s anc of length slength (15 or 31), returns maximum value;	or 14/30 if empty */pascal int32 MaxP (set32 *sp32, int32 slength){if (slength==15)	{	typedef set16 *ptr16;	set16 s16;	s16 = (*((ptr16) sp32)) & setbound15S;	if (s16 == 0 )		return (14);	else	{		set16 b = 1;		int m = 0;			while ((s16 &= ~b) != 0)			{			b <<= 1;			m++; 			} 		return m;	}		}else	{	set32 s32 = (*sp32) & setbound31;	if (s32 == 0)		return (30);	else		{		set32 b = 1;		int m = 0;			while ((s32 &= ~b) != 0)			{			b <<= 1;			m++; 			} 		return m;		}	}}/*===================================================*/	/*FUNCTION CardP (s : Ptr; slength: integer) : integer;; for set starting at s anc of length slength (15 or 31), returns cardinality */pascal int32 CardP (set32 *s, int32 slength){if (slength==15)        {        typedef set16 *ptr16;        set16 s16;        s16 = (*((ptr16) s)) & setbound15S;        if (s16 == 0 )                return (0);        else                {                int b;                for (b = 0; s16 != 0; s16 >>=1)                        if (s16 & 01)                                b++;                return b;                }        }else        {        set32 s32 = (*s) & setbound31;        if (s32 == 0 )                return (0);        else                {                int b;                for (b = 0; s32 != 0; s32 >>=1)                        if (s32 & 01)                                b++;                return b;                }        }}	/*===================================================*/	/*FUNCTION CardG (s : lgsetchars) : integer;; returns cardinality of elements 0 to 25 in set */pascal int32 CardG  (set32 s){ s &= setbound31;if (s == 0 ) return (0);else	{ int b;	for (b = 0; s != 0; s >>=1)		if (s & 01)			b++;	return b; } }/*===================================================*/	/*FUNCTION CardLg (s : largestsetchars) : integer;; returns cardinality of elements 0 to 25 in set; differs; from above CardG only in that it accepts type largestsetchars as argument */pascal int32 CardLg  (set32 spt){set32 s=(spt);s &= setbound31;if (s == 0 )	return (0);else	{	int b;	for (b = 0; s != 0; s >>=1)		if (s & 01)			b++;	return b;	}}/*===================================================*/	/*FUNCTION Cardinality (s : largestsetchars) : integer;; returns cardinality of elements 0 to 25 in set; differs; from above CardG only in that it accepts type largestsetchars as argument */pascal int32 Cardinality  (set32 spt){set32 s=(spt);s &= setbound31;if (s == 0 )	return (0);else	{	int b;	for (b = 0; s != 0; s >>=1)		if (s & 01)			b++;	return b;	}}//;-------------------------------------------------//; 	FUNCTION CardFrom (sptr: ptr; length: integer) : integer;//; returns cardinality of elements 0 through length of set starting at//; location sptrpascal int32 CardFrom (set32 *s, int32 slength){set32 s32 = (*s);int goon = 1;int b = 0;while (goon){       s32 = (*s);        s++;        {        if (slength <= 32)                {                 for (s32 &= (~0L << (32 - slength)); s32 != 0;)                        {if (s32 & 01)                                b++;                          s32 >>=1;}                goon = 0;                }        else                {                for (; s32 != 0; )                       { if (s32 & 01)                                b++;                               s32 >>=1;                                }                slength -= 32;                }        }        }return (b);}/*===================================================*/	/*FUNCTION MultipleStatesG (s : lgsetchars) : boolean;; returns true if s has more than one element  */pascal unsigned int16 MultipleStatesG (set32 s){if ((s &= setbound31)==0)	return(0);else{	set32 b = 1;	while ((s & b)==0)  /*finding minimum*/		b <<= 1;	if ((s & ~b) != 0)		return(257); 	else		return(0);}}pascal unsigned int16 MultipleStatesLg (set32 spt){set32 s=(spt);if ((s &= setbound31)==0)	return(0);else{	set32 b = 1;	while ((s & b)==0)  /*finding minimum*/		b <<= 1;	if ((s & ~b) != 0)		return(257); 	else		return(0);}}/*===================================================*/	/*FUNCTION MonomorphG (s : lgsetchars) : boolean;; returns true if s has only one element  */pascal unsigned int16 MonomorphG (set32 s){if ((s &= setbound31)==0) return(0);else	{ set32 b = 1;	while ((s & b)==0)  /*finding minimum*/		b <<= 1;	if ((s & ~b) == 0) return(257); 	else return(0);}}/*===================================================*/	/*FUNCTION MonomorphLg (s : largestsetchars) : boolean;; returns true if s has only one element  */pascal unsigned int16 MonomorphLg (set32 spt){set32 s=(spt);if ((s &= setbound31)==0)	return(0);else{	set32 b = 1;	while ((s & b)==0)  /*finding minimum*/		b <<= 1;	if ((s & ~b) == 0)		return(257); 	else		return(0);}}//;===========================================================================//;//; 	FUNCTION set15to31 (s : setchars15) : setchars31//;//; converts a 2 byte setchars into a 4 byte setchars; for use when data//; format is changed//;FROZEN 3.0/* pascal void set15to31 (set16 *s, set32 *r){ 	set32 shigh = (*s);	set32 slow = shigh;	slow=(slow & setbound15) ;	shigh=((shigh << 16) & ~setbound31);	(*r)=(shigh|slow);}	*///;===========================================================================//;; 	FUNCTION set31to15 (s : setchars31) : setchars15;//; converts a 4 byte setchars into a 2 byte setchars; for use when data//; format is changed//;FROZEN 3.0/*pascal void set31to15 (set32 *s, set16 *r){ set32 slong = (*s);(*r) = ((slong & ~setbound31) >> 16)|(slong & setbound15);	}*/