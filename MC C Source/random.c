/*	random.c||	A machine-independent multiplicative congruential pseudorandom number|	generator with associated utility routines.||	Copyright (c) 1991 by David Swofford, Illinois Natural History Survey.||	Implementation notes:||		1.	The types 'Int32' and 'UInt32' should be typedef'd in a header|			file as 32-bit signed and unsigned integers, respectively.||		2.	See comments in function 'RandUni' regarding definition of|			constants 'A' and 'M'.*/#include "daveswof.h"#include "paup.h"#if (IntSize == 64)	/* and multiplication of two 32-bit operands gives	*/					/*	64-bit precision as on Cray						*/#define	A	397204094		/* multiplier */#define	M	2147483647		/* modulus = 2**31 - 1 */#else#if !MACINTOSH				/* Mac Toolbox already declares this; */							/*	do it here for other machines     */	typedef struct		{		Int32	hiLong;		Int32	loLong;		}		Int64Bit;#endif#define	A	397204094L		/* multiplier */#define	M	2147483647L		/* modulus = 2**31 - 1 */#endif/*-------------------------------- Prototypes --------------------------------*/#if (IntSize < 64) && !MACINTOSHLocal void	LongMul __((Int32, Int32, Int64Bit *));	#endif#define TEST 0#if TEST/*--| main (for testing only) |-----------------------------------------------*/#define PermArraySize	10#define NPerms			50void main()	{	Int32		seed, saveSeed;	int			i, j, pos, perm[PermArraySize];	char		buf[256];	printf("seed? ");	scanf("%ld", &seed);	saveSeed = seed;	printf("1st 100 random numbers with seed = %ld:\n", (long)seed);	for (i = 0; i < 20; i++)		{		double		a, b, c, d, e;		a = RandUni(&seed);		b = RandUni(&seed);		c = RandUni(&seed);		d = RandUni(&seed);		e = RandUni(&seed);		printf("%10.5f%10.5f%10.5f%10.5f%10.5f\n",			a, b, c, d, e);		}			seed = 1L;	for (i = 0; i < 10000; i++)		RandUni(&seed);		printf("\nz(10001) given z(1)=1 ==> %ld (should be 10939054)\n", seed);		seed = saveSeed;	printf("\n%d Random permutations of size %d using seed = %ld:\n",	  NPerms, PermArraySize, seed);	  	for (i = 1; i <= NPerms; i++)		{		RandPermInt(perm, PermArraySize, &seed);		pos = 0;		for (j = 0; j < PermArraySize; j++)			pos += sprintf(buf + pos, "%3d", perm[j]);		printf("%4d: %s\n", i, buf);		}	}#endif/*--| RandUni |----------------------------------------------------------------|||	Return a pseudorandom number on U(0,1) via the multiplicative|	congruential method:||		x(i) = A * x(i-1) mod (2**31 - 1).||	It is recommended that the multiplier A be set to 397204094.  This is the|	smallest multiplier that performed well in Fishman and Moore's (1982,|	JASA 77:129-136) comprehensive evaluation.  (Smaller multipliers are much|	faster, and may be "good enough" depending on the purpose.)  Do not change|	the multiplier unless you know what you're doing!||	Pass a pointer to an 'Int32' variable containing the previous number in the|	sequence (or the starting seed, if this is the first call).  The seed must|	be greater than 0 and less than 2**31 - 1.  It is up to the caller to make|	sure that the seed falls within these bounds.||	The algorithm used here is based on that of Payne, Rabung, and Bogyo (1969;|	Comm. ACM 12:85-86).||	This routine is portable, so long as a 32-bit integer type is available.  |	(The code can easily be modified, and simplified as well, for machines|	with long's of 64 bits or longer.)  Note that the "overflow" in the|	comments below simply means that the value exceeded 2**31 -1 (but it|	will never exceed 2**32 - 1, so no actual hardware overflow occurs).||	Dave Swofford 9/21/87*/Entry double RandUni(pSeed)		Int32				*pSeed;{	RegVar UInt32		x, y;#	if IntSize < 64	Int64Bit			Ax;		LongMul(*pSeed, A, &Ax);		/* A * x */	x = Ax.loLong;					/* move to register variables */	y = Ax.hiLong;					/*	for speed				*/	y = (y << 1) | (x >> 31);		/* isolate high-order 31 bits */	x = (x << 1) >> 1;				/* isolate low-order 31 bits */	x += y;							/* x'(i + 1) unless overflows */	if (x & 0x80000000) 			/* overflow check */		x -= M;						/* deal with overflow */	#	else		x = (A * *pSeed) % 2147483647;	#	endif	*pSeed = x;						/* save for next time */	return (double)x / M;			/* scale to (0,1) */}/*--| RandPermInt |------------------------------------------------------------|||	Generate a random permutation of the integers 0 through n-1.*/Entry void RandPermInt(p, n, pSeed)	RegPtr int		*p;			/* buffer of at least n elements */	RegVar int		n;	Int32			*pSeed;		/* previous value in sequence (see */								/*	RandUni() description above)	*/{	RegVar int		i, j, temp;	for (i = 0; i < n; i++)		p[i] = i;	for (i = n - 1; i >= 1; i--)		{		j = RandomInt(i, pSeed);		temp = p[i];		p[i] = p[j];		p[j] = temp;		}}/*--| RandomInt |--------------------------------------------------------------|||	Return a random integer from the interval [0, n-1].*/Entry int RandomInt(n, pSeed)	int			n;	Int32		*pSeed;	/* previous value in sequence (see */						/*	RandUni() description above)	*/{	return (int)(RandUni(pSeed) * n);}#if (IntSize < 64) && !MACINTOSH/*--| LongMul |----------------------------------------------------------------|||	Multiply the two 32-bit integers 'ab' and 'cd' and store the result in 'mn' |	(high-order 32 bits) and 'op' (low order 32 bits); needed when it is not|	possible to store a 64-bit result directly due to overflow.||	Note:  This routine is a substitute for the Macintosh toolbox utility of|	the same name, however it has been written specifically for random number|	generation and assumes that its input arguments are nonnegative, even|	though they are stored as signed quantities.  Thus, the scope of valid|	inputs is [0, 2**31 - 1]); no checking is performed.||	The algorithm used is to break each 32-bit integer into 16-bit components|	and perform the multiplication as:|||		  ab		(a = high 16 bits, b = low 16 bits of 1st arg)|		x cd		(c = high 16 bits, d = low 16 bits of 2nd arg)|		----|		  ef		(d*b)|		 gh			(d*a)|		 ij			(c*b)|		kl			(c*a)|		----|		mnop		('mn' returned as result->hiLong; 'op' as result->loLong)*/Local void LongMul(ab, cd, result)	RegVar Int32		ab, cd;	Int64Bit			*result;{	RegVar UInt32		o;	UInt32				a, b, c, d, ef, gh, ij, kl;	a = ab >> 16;	b = ab & 0x0000FFFF;	c = cd >> 16;	d = cd & 0x0000FFFF;	ef = d * b;	gh = d * a;	ij = c * b;	kl = c * a;	o = (ef >> 16) + (gh & 0x0000FFFF) + (ij & 0x0000FFFF);	result->loLong = (o << 16) | (ef & 0x0000FFFF);	result->hiLong = (o >> 16 /* carry */) + (gh >> 16) + (ij >> 16) + kl;}#endif